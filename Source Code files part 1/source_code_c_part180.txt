state of a registry sub-tree is one of the following:
//
//         RtlpRXactStateNoTransaction - There is not a transaction in progress.
//
//         RtlpRXactStateCommitting    - The actions of a transaction are being
//                                       applied to the registry database.
//

typedef enum _RTLP_RXACT_STATE {
    RtlpRXactStateNoTransaction = 2,
    RtlpRXactStateCommitting
} RTLP_RXACT_STATE, *PRTLP_RXACT_STATE;


typedef struct _RTLP_RXACT {
    ULONG Revision;
    RTLP_RXACT_STATE State;   // no longer used
    ULONG OperationCount;     // no longer used
} RTLP_RXACT, *PRTLP_RXACT;


typedef struct _RXACT_LOG_ENTRY {
    ULONG LogEntrySize;
    RTL_RXACT_OPERATION Operation;
    UNICODE_STRING SubKeyName;       // Self-relativized (Buffer is really offset)
    UNICODE_STRING AttributeName;    // Self-relativized (Buffer is really offset)
    HANDLE KeyHandle;                // optional, not valid if read from disk.
    ULONG NewKeyValueType;
    ULONG NewKeyValueLength;
    PVOID NewKeyValue;               // Contains offset to data from start of log
} RXACT_LOG_ENTRY, *PRXACT_LOG_ENTRY;




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                      Prototypes for local procedures                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////




NTSTATUS
RXactpCommit(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
RXactpOpenTargetKey(
    IN HANDLE RootRegistryKey,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    OUT PHANDLE TargetKey
    );



VOID
RXactInitializeContext(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN HANDLE RootRegistryKey,
    IN HANDLE RXactKey
    );


#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RXactpCommit)
#pragma alloc_text(PAGE,RXactpOpenTargetKey)
#pragma alloc_text(PAGE,RXactInitializeContext)
#pragma alloc_text(PAGE,RtlInitializeRXact)
#pragma alloc_text(PAGE,RtlStartRXact)
#pragma alloc_text(PAGE,RtlAbortRXact)
#pragma alloc_text(PAGE,RtlAddAttributeActionToRXact)
#pragma alloc_text(PAGE,RtlAddActionToRXact)
#pragma alloc_text(PAGE,RtlApplyRXact)
#pragma alloc_text(PAGE,RtlApplyRXactNoFlush)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures   (defined in ntrtl.h)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
RtlInitializeRXact(
    IN HANDLE RootRegistryKey,
    IN BOOLEAN CommitIfNecessary,
    OUT PRTL_RXACT_CONTEXT *RXactContext
    )

/*++

Routine Description:

    This routine should be called by a server exactly once when it starts.
    This routine will check to see that the registry transaction information
    exists for the specified registry sub-tree, and will create it if it
    doesn't exist.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        a transaction is to be initialized.

    CommitIfNecessary - A BOOLEAN value indicating whether or not any
        previously aborted commit discovered should be commited at this
        time.  A value of TRUE indicates the commit should be applied
        if encountered.  A value of FALSE indicates a previously
        aborted COMMIT should not be committed at this time.

    RXactContext - Returns a pointer to an RTL_RXACT_CONTEXT structure
        allocated out of the local heap.  The caller must keep this
        pointer and pass it back in for all future RXact transactions
        for the passed RootRegistryKey.


Return Value:

    STATUS_SUCCESS - Indicates the transaction state already exists for the
        registry sub-tree and is already in the NO_TRANSACTION state.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state already
        exists for the specified sub-tree, but is a revision level that is
        unknown by this service.

    STATUS_RXACT_STATE_CREATED - This informational level status indicates
        that a specified registry sub-tree transaction state did not yet
        exist and had to be created.

    STATUS_RXACT_COMMIT_NECESSARY - This warning level status indicates that the
        transaction state already exists for the registry sub-tree, but that
        a transaction commit was previously aborted.  The commit has NOT been
        completed.  Another call to this service with a CommitIfNecessary value
        of TRUE may be used to commit the transaction.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.

--*/

{

    HANDLE RXactKey;
    LARGE_INTEGER LastWriteTime;
    NTSTATUS Status, TmpStatus;
    OBJECT_ATTRIBUTES RXactAttributes;
    PKEY_VALUE_FULL_INFORMATION FullInformation;
    RTLP_RXACT RXactKeyValue;
    UCHAR BasicInformation[128];      // Should be more than long enough
    ULONG Disposition;
    ULONG KeyValueLength;
    ULONG KeyValueType;
    ULONG ResultLength;
    UNICODE_STRING RXactKeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING NullName;

    RTL_PAGED_CODE();

    //
    // Initialize some stuff
    //

    KeyValueLength = (ULONG)sizeof( RTLP_RXACT );
    KeyValueType   = 0;         // Not used by RXact

    RtlInitUnicodeString( &NullName, NULL );

    //
    // Create or open the RXACT key.
    //

    RtlInitUnicodeString( &RXactKeyName, RTLP_RXACT_KEY_NAME);

    InitializeObjectAttributes(
        &RXactAttributes,
        &RXactKeyName,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
        RootRegistryKey,
        NULL);

//    Status = RtlpNtCreateKey(
//                 &RXactKey,
//                 (KEY_READ | KEY_WRITE | DELETE),
//                 &RXactAttributes,
//                 0,
//                 NULL,
//                 &Disposition
//                 );

    Status = NtCreateKey( &RXactKey,
                          (KEY_READ | KEY_WRITE | DELETE),
                          &RXactAttributes,
                          0,                          //TitleIndex
                          NULL,                       //Class OPTIONAL,
                          REG_OPTION_NON_VOLATILE,    //CreateOptions,
                          &Disposition
                          );

    if ( !NT_SUCCESS(Status) ) {
        return(Status);
    }

    //
    // Allocate the RXactContext block
    //

    *RXactContext = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( RTL_RXACT_CONTEXT ));

    if ( *RXactContext == NULL ) {

        //
        // Something prevented value assignment...
        // Get rid of the RXact key and return the error
        //

        TmpStatus = NtDeleteKey( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group

        return( STATUS_NO_MEMORY );
    }

    //
    // Initialize the newly created RXactContext structure.
    //

    RXactInitializeContext( *RXactContext, RootRegistryKey, RXactKey );

    //
    // If we created (as opposed to opened an existing) rxact key,
    // then we need to initialize it.
    //

    if ( Disposition == REG_CREATED_NEW_KEY ) {

        RXactKeyValue.Revision       = RTLP_RXACT_REVISION1;

        Status = NtSetValueKey( RXactKey,
                                &NullName,       // ValueName
                                0,               // TitleIndex
                                KeyValueType,
                                &RXactKeyValue,
                                KeyValueLength
                                );

        if ( !NT_SUCCESS(Status) ) {

            //
            // Something prevented value assignment...
            // Get rid of the RXact key and return the error
            //

            TmpStatus = NtDeleteKey( RXactKey );
            ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
            TmpStatus = NtClose( RXactKey );
            ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group

            RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );

            return( Status );
        }

        return( STATUS_RXACT_STATE_CREATED );
    }



    //
    // We have opened an existing RXACT key.
    // See if it is a revision level we know about.
    //

    Status = RtlpNtQueryValueKey(
                 RXactKey,              // KeyHandle
                 &KeyValueType,         // KeyValueType
                 &RXactKeyValue,        // KeyValue
                 &KeyValueLength,       // KeyValueLength
                 &LastWriteTime         // LastWriteTime
                 );


    if ( !NT_SUCCESS(Status) ) {

        //
        // Something prevented value query...
        //

        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( Status );
    }


    if ( KeyValueLength != (ULONG)sizeof(RTLP_RXACT) ) {
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( STATUS_UNKNOWN_REVISION );
    }

    if (RXactKeyValue.Revision != RTLP_RXACT_REVISION1) {
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( STATUS_UNKNOWN_REVISION );
    }



    //
    // Right revision...
    // See if there is a transaction or commit in progress.  If not,
    // return success
    //

    //
    // If a log file exists, then we are committing.
    //

    RtlInitUnicodeString( &ValueName, RTLP_RXACT_LOG_NAME );

    Status = NtQueryValueKey(
                 RXactKey,
                 &ValueName,
                 KeyValueBasicInformation,
                 &BasicInformation[0],
                 128,
                 &ResultLength
                 );

    if ( NT_SUCCESS( Status )) {

        //
        // We found a value called 'Log'.  This means that a commit
        // was in progress.
        //

        if ( CommitIfNecessary ) {

            //
            // Query the full value of the log, then call a low level routine
            // to actually perform the commit.
            //

            Status = NtQueryValueKey(
                         RXactKey,
                         &ValueName,
                         KeyValueFullInformation,
                         NULL,
                         0,
                         &ResultLength
                         );

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                return( Status );
            }

            FullInformation = RtlAllocateHeap( RtlProcessHeap(), 0, ResultLength );

            if ( FullInformation == NULL ) {
                return( STATUS_NO_MEMORY );
            }


            Status = NtQueryValueKey(
                         RXactKey,
                         &ValueName,
                         KeyValueFullInformation,
                         FullInformation,
                         ResultLength,
                         &ResultLength
                         );

            if ( !NT_SUCCESS( Status )) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullInformation );
                RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
                return( Status );
            }

            //
            // The log information is buried in the returned FullInformation
            // buffer.  Dig it out and make the RXactLog in the RXactContext
            // structure point to it.  Then commit.
            //

            (*RXactContext)->RXactLog = (PRTL_RXACT_LOG)((PCHAR)FullInformation + FullInformation->DataOffset);

            //
            // Don't use any handles we may find in the log file
            //

            (*RXactContext)->HandlesValid = FALSE;

            Status = RXactpCommit( *RXactContext );

            if ( !NT_SUCCESS( Status )) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullInformation );
                RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
                return( Status );
            }


            //
            // The commit was successful.  Clean up.
            // Delete the log file value and data
            //

            Status = NtDeleteValueKey( RXactKey, &ValueName );

            //
            // This should never fail
            //

            ASSERT( NT_SUCCESS( Status ));

            //
            // Get rid of the in memory data structures.  Abort
            // will free the RXactLog, so put what we want
            // freed in there and it will go away.
            //

            (*RXactContext)->RXactLog = (PRTL_RXACT_LOG)FullInformation;

            Status = RtlAbortRXact( *RXactContext );

            //
            // This should never fail
            //

            ASSERT( NT_SUCCESS( Status ));
            return( Status );
        } else {

            return( STATUS_RXACT_COMMIT_NECESSARY );
        }

    } else {

        //
        // No log, so nothing to do here.
        //

        return( STATUS_SUCCESS );
    }

}



VOID
RXactInitializeContext(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN HANDLE RootRegistryKey,
    IN HANDLE RXactKey
    )

/*++

Routine Description:

    Initializes an in-memory RXactContext structure.

Arguments:

    RXactContext - Supplies a pointer to an RXact Context created
        by RtlInitializeRXact.

    RootRegistryKey - Supplies the RootRegistryKey for this component.

    RXactKey - Supplies the {RootRegistryKey}\RXactKey for this component


Return Value:

    None.

--*/

{
    //
    // Initialize the RXactContext for this client
    //

    RXactContext->RootRegistryKey      = RootRegistryKey;
    RXactContext->HandlesValid         = TRUE;
    RXactContext->RXactLog             = NULL;
    RXactContext->RXactKey             = RXactKey;

    return;
}



NTSTATUS
RtlStartRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to start a new transaction in a registry sub-tree.
    Transactions must be serialized by the server so that only one transaction
    is in progress at a time.

Arguments:

    RXactContext - Supplies a pointer to an RTL_RXACT_CONTEXT structure
        that is not currently in use.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was started.

    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.

--*/
{
    PRTL_RXACT_LOG RXactLogHeader;

    RTL_PAGED_CODE();

    //
    // Allocate in-memory log file and initialize.  This implicitly
    // sets the state to 'transaction in progress'.
    //

    if ( RXactContext->RXactLog != NULL ) {

        //
        // There is already a transaction in progress for this
        // context.  Return an error.
        //

        return( STATUS_RXACT_INVALID_STATE );
    }

    RXactLogHeader = RtlAllocateHeap( RtlProcessHeap(), 0, RTLP_INITIAL_LOG_SIZE );

    if ( RXactLogHeader == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    //
    // Fill in the log header information at the top of the
    // newly allocated buffer.
    //


    RXactLogHeader->OperationCount = 0;
    RXactLogHeader->LogSize        = RTLP_INITIAL_LOG_SIZE;
    RXactLogHeader->LogSizeInUse   = sizeof( RTL_RXACT_LOG );

    RXactContext->RXactLog = RXactLogHeader;

    return( STATUS_SUCCESS );

}


NTSTATUS
RtlAbortRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to abort a transaction in a registry sub-tree.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        the transaction is to be aborted.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was aborted.


    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.

--*/

{
    RTL_PAGED_CODE();

    if ( RXactContext->RXactLog == NULL ) {

        //
        // There is no transaction in progress for this
        // context.  Return an error.
        //

        return( STATUS_RXACT_INVALID_STATE );
    }

    (VOID) RtlFreeHeap( RtlProcessHeap(), 0, RXactContext->RXactLog );

    //
    // Reinitialize the RXactContext structure with the same initial data.
    //

    RXactInitializeContext(
        RXactContext,
        RXactContext->RootRegistryKey,
        RXactContext->RXactKey
        );


    return( STATUS_SUCCESS );

}



NTSTATUS
RtlAddAttributeActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle OPTIONAL,
    IN PUNICODE_STRING AttributeName,
    IN ULONG NewValueType,
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )

/*++

Routine Description:

    This routine is used to add a new action to the transaction operation log.
    Upon commit, these operations are applied in the order they are added
    to the log.

    This routine differs from RtlAddActionToRXact in that it takes an Attribute
    Name parameter, rather than using the default ("NULL") Attribute of the
    specified key.


Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

    Operation - Indicates the type of operation to perform (e.g., delete
        a sub-key or set the value of a sub-key).  Sub-keys may be created
        by setting a value of a previously non-existent sub-key.  This will
        cause all sub-keys between the root and the specified sub-key to
        be created.

    SubKeyName - Specifies the name of the target registry key.  This name
        is relative to the Root of the Registry transaction sub-tree
        and must NOT start with a delimiter character ("\").

    KeyHandle - Optionally supplies a handle to the target key.  If
        not specified, the name passed for SubKeyName will determine
        the target key.

    AttributeName - Supplies the name of the key attribute to be
        modified.

    NewKeyValueType - (Optional) Contains the KeyValueType to assign
        to the target registry key.  This parameter is ignored if the
        Operation is not RtlRXactOperationSetValue.

    NewKeyValue -  (Optional) Points to a buffer containing the value
        to assign to the specified target registry key.  This parameter
        is ignored if the Operation is not RtlRXactOperationSetValue.

    NewKeyValueLength - Indicates the length (number of bytes) of the
        NewKeyValue buffer.  This parameter is ignored if the Operation
        is not RtlRXactOperationSetValue.


Return Value:

    STATUS_SUCCESS - Indicates the request completed successfully..

    STATUS_INVALID_PARAMETER - Indicates that an unknown Operation
        was requested.

    STATUS_NO_MEMORY - Insufficient memeory was available to complete
        this operation.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


--*/

{

    PRTL_RXACT_LOG   NewLog;
    PRXACT_LOG_ENTRY Base;

    ULONG End;
    ULONG LogEntrySize;
    ULONG NewLogSize;

    RTL_PAGED_CODE();

    //
    // Make sure we were passed a legitimate operation.
    //

    if (  (Operation != RtlRXactOperationDelete)  &&
          (Operation != RtlRXactOperationSetValue)   ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Compute the total size of the new data
    //

    LogEntrySize = sizeof( RXACT_LOG_ENTRY )               +
                   DwordAlign( SubKeyName->Length )        +
                   DwordAlign( AttributeName->Length )     +
                   DwordAlign( NewValueLength );

    LogEntrySize = ALIGN_UP( LogEntrySize, PVOID );

    //
    // Make sure there is enough space in the current
    // log file for this data.  If not, we must create
    // a larger log, copy all the old data, and then
    // append this to the end.
    //

    if ( RXactContext->RXactLog->LogSizeInUse + LogEntrySize >
                                   RXactContext->RXactLog->LogSize ) {

        //
        // We must allocate a bigger log file.
        //

        NewLogSize = RXactContext->RXactLog->LogSize;

        do {

            NewLogSize = NewLogSize * 2;

        } while ( NewLogSize <
            ( RXactContext->RXactLog->LogSizeInUse + LogEntrySize ) );

        NewLog = RtlAllocateHeap( RtlProcessHeap(), 0, NewLogSize );

        if ( NewLog == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Copy over previous information
        //

        RtlCopyMemory( NewLog, RXactContext->RXactLog, RXactContext->RXactLog->LogSizeInUse );

        //
        // Free the old log file
        //

        RtlFreeHeap( RtlProcessHeap(), 0, RXactContext->RXactLog );

        //
        // Install the new log file and adjust its size in its header
        //

        RXactContext->RXactLog = NewLog;
        RXactContext->RXactLog->LogSize = NewLogSize;
    }

    //
    // The log file is big enough, append data to
    // the end.
    //

    Base = (PRXACT_LOG_ENTRY)((PCHAR)(RXactContext->RXactLog) +
                             (RXactContext->RXactLog->LogSizeInUse));


    //
    // Append each parameter to the end of the log.  Unicode string data
    // will be appended to the end of the entry.  The Buffer field in the
    // Unicode string structure will contain the offset to the Buffer,
    // relative to the beginning of the log file.
    //

    Base->LogEntrySize      = LogEntrySize;
    Base->Operation         = Operation;
    Base->SubKeyName        = *SubKeyName;
    Base->AttributeName     = *AttributeName;
    Base->NewKeyValueType   = NewValueType;
    Base->NewKeyValueLength = NewValueLength;
    Base->KeyHandle         = KeyHandle;

    //
    // Fill in the variable length data: SubKeyName, AttributeName,
    // and NewKeyValue
    //

    //
    // End is an offset relative to the beginning of the entire log
    // structure.  It is initialized to 'point' to the offset immediately
    // following the structure we just filled in above.
    //

    End = (ULONG)((RXactContext->RXactLog->LogSizeInUse) +
                 sizeof( *Base ));


    //
    // Append SubKeyName information to the log file
    //

    RtlMoveMemory (
        (PCHAR)(RXactContext->RXactLog) + End,
        SubKeyName->Buffer,
        SubKeyName->Length
        );

    Base->SubKeyName.Buffer = (PWSTR)ULongToPtr(End);
    End += DwordAlign( SubKeyName->Length );



    //
    // Append AttributeName information to the log file
    //


    RtlMoveMemory(
        (PCHAR)(RXactContext->RXactLog) + End,
        AttributeName->Buffer,
        AttributeName->Length
        );

    Base->AttributeName.Buffer = (PWSTR)ULongToPtr(End);
    End += DwordAlign( AttributeName->Length );



    //
    // Append NewKeyValue information (if present) to the log file
    //

    if ( Operation == RtlRXactOperationSetValue ) {

        RtlMoveMemory(
            (PCHAR)(RXactContext->RXactLog) + End,
            NewValue,
            NewValueLength
            );

        Base->NewKeyValue = (PVOID)ULongToPtr(End);
        End += DwordAlign( NewValueLength );
    }

    End = ALIGN_UP( End, PVOID );

    RXactContext->RXactLog->LogSizeInUse = End;
    RXactContext->RXactLog->OperationCount++;

    //
    // We're done
    //

    return(STATUS_SUCCESS);
}


NTSTATUS
RtlAddActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN ULONG NewKeyValueType,
    IN PVOID NewKeyValue OPTIONAL,
    IN ULONG NewKeyValueLength
    )

/*++

Routine Description:

    This routine is used to add a new action to the transaction operation log.
    Upon commit, these operations are applied in the order they are added
    to the log.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

    Operation - Indicates the type of operation to perform (e.g., delete
        a sub-key or set the value of a sub-key).  Sub-keys may be created
        by setting a value of a previously non-existent sub-key.  This will
        cause all sub-keys between the root and the specified sub-key to
        be created.

    SubKeyName - Specifies the name of the target registry key.  This name
        is relative to the Root of the Registry transaction sub-tree
        and must NOT start with a delimiter character ("\").

    NewKeyValueType - (Optional) Contains the KeyValueType to assign
        to the target registry key.  This parameter is ignored if the
        Operation is not RtlRXactOperationSetValue.

    NewKeyValue -  (Optional) Points to a buffer containing the value
        to assign to the specified target registry key.  This parameter
        is ignored if the Operation is not RtlRXactOperationSetValue.

    NewKeyValueLength - Indicates the length (number of bytes) of the
        NewKeyValue buffer.  This parameter is ignored if the Operation
        is not RtlRXactOperationSetValue.

Return Value:

    STATUS_SUCCESS - Indicates the request completed successfully..


    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.

    Others - Other status values that may be returned from registry key
        services (such as STATUS_ACCESS_DENIED).

--*/
{
    UNICODE_STRING AttributeName;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    RtlInitUnicodeString( &AttributeName, NULL );

    Status = RtlAddAttributeActionToRXact(
                 RXactContext,
                 Operation,
                 SubKeyName,
                 INVALID_HANDLE_VALUE,
                 &AttributeName,
                 NewKeyValueType,
                 NewKeyValue,
                 NewKeyValueLength
                 );

    return( Status );


}



NTSTATUS
RtlApplyRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to apply the changes of a registry sub-tree
    Transaction to that registry sub-tree.  This routine is meant to be
    called for the common case, where the hive is automatically
    lazy-flushed.  That means that this routine must write the change log
    to disk, then flush the hive (to ensure that pieces of changes aren't
    lazy-written to disk before this routine finishes an atomic operation),
    the apply the changes, then delete the change log.

    The actual changes will be lazy-written to disk, but the registry
    guarantees that none or all will make it.  If the machine goes down
    while this routine is executing, the flushed change log guarantees
    that the hive can be put into a consistent state.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING LogName;
    HANDLE RXactKey;

    RTL_PAGED_CODE();

    //
    // Commit the contents of the current log to disk
    //

    RXactKey = RXactContext->RXactKey;

    RtlInitUnicodeString( &LogName, RTLP_RXACT_LOG_NAME );

    Status = NtSetValueKey( RXactKey,
                            &LogName,        // ValueName
                            0,               // TitleIndex
                            REG_BINARY,
                            RXactContext->RXactLog,
                            RXactContext->RXactLog->LogSizeInUse
                            );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = NtFlushKey( RXactKey );

    if ( !NT_SUCCESS( Status )) {

        //
        // If this fails, maintain the in-memory data,
        // but get rid of what we just tried to write
        // to disk.
        //
        // Ignore the error, since we're in a funky
        // state right now.
        //

        (VOID) NtDeleteValueKey( RXactKey, &LogName );

        return( Status );
    }

    //
    // The log is safe, now execute what is in it
    //

    Status = RXactpCommit( RXactContext );

    if ( !NT_SUCCESS( Status )) {

        //
        // As above, try to get rid of what's on
        // disk, leave the in-memory stuff alone,
        // so that the caller may try again.
        //

        (VOID) NtDeleteValueKey( RXactKey, &LogName );

        return( Status );
    }

    //
    // Delete the log file value and data
    //

    Status = NtDeleteValueKey( RXactKey, &LogName );

    //
    // This should never fail
    //

    ASSERT( NT_SUCCESS( Status ));

    //
    // Get rid of the in memory data structures.  Abort
    // does exactly what we want to do.
    //

    Status = RtlAbortRXact( RXactContext );

    //
    // This should never fail
    //

    ASSERT( NT_SUCCESS( Status ));

    return( STATUS_SUCCESS );

}



NTSTATUS
RtlApplyRXactNoFlush(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to apply the changes of a registry sub-tree
    Transaction to that registry sub-tree.  This routine should only be
    called for special hives that do not have automatic lazy-flushing.
    The caller must decide when to flush the hive in order to guarantee
    a consistent hive.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.


--*/
{
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    // Execute the contents of the RXACT log.
    //

    Status = RXactpCommit( RXactContext );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get rid of the in memory data structures.  Abort
        // does exactly what we want to do.
        //

        Status = RtlAbortRXact( RXactContext );

        //
        // This should never fail
        //

        ASSERT( NT_SUCCESS( Status ));
    }

    return( Status );

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Internal Procedures   (defined in within this file)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





NTSTATUS
RXactpCommit(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine commits the operations in the operation log.

    When all changes have been applied, the transaction state
    is changed to NO_TRANSACTION.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.



--*/
{
    BOOLEAN HandlesValid;

    HANDLE TargetKey;
    HANDLE RXactKey;
    HANDLE RootRegistryKey;

    PRTL_RXACT_LOG      RXactLog;
    PRXACT_LOG_ENTRY    RXactLogEntry;
    RTL_RXACT_OPERATION Operation;

    ULONG OperationCount;
    ULONG i;

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TmpStatus = STATUS_SUCCESS;
    BOOLEAN CloseTargetKey;

    //
    // Extract information from the RXactContext to simplify
    // the code that follows
    //

    RootRegistryKey = RXactContext->RootRegistryKey;
    RXactKey        = RXactContext->RXactKey;
    RXactLog        = RXactContext->RXactLog;

    OperationCount  = RXactLog->OperationCount;

    HandlesValid    = RXactContext->HandlesValid;


    //
    // Keep a pointer to the beginning of the current log entry.
    //

    RXactLogEntry = (PRXACT_LOG_ENTRY)((PCHAR)RXactLog + sizeof( RTL_RXACT_LOG ));


    //
    // Go through and perform each operation log.  Notice that some operation
    // logs may already have been deleted by a previous commit attempt.
    // So, don't get alarmed if we don't successfully open some operation
    // log entry keys.
    //

    for ( i=0 ; i<OperationCount ; i++ ) {

        //
        // Turn the self-relative offsets in the structure
        // back into real pointers.
        //

        RXactLogEntry->SubKeyName.Buffer = (PWSTR) ((PCHAR)RXactLogEntry->SubKeyName.Buffer +
                                                    (ULONG_PTR)RXactLog);

        RXactLogEntry->AttributeName.Buffer = (PWSTR) ((PCHAR)RXactLogEntry->AttributeName.Buffer +
                                                       (ULONG_PTR)RXactLog);

        RXactLogEntry->NewKeyValue = (PVOID)((PCHAR)RXactLogEntry->NewKeyValue + (ULONG_PTR)RXactLog);

        Operation = RXactLogEntry->Operation;

        //
        // Perform this operation
        //

        switch (Operation) {
            case RtlRXactOperationDelete:

                //
                // Open the target key and delete it.
                // The name is relative to the RootRegistryKey.
                //

                if ( ((RXactLogEntry->KeyHandle == INVALID_HANDLE_VALUE) || !HandlesValid) ) {

                    Status = RXactpOpenTargetKey(
                                 RootRegistryKey,
                                 RtlRXactOperationDelete,
                                 &RXactLogEntry->SubKeyName,
                                 &TargetKey
                                 );

                    if ( !NT_SUCCESS(Status)) {

                        //
                        // We must allow the object not to be found,
                        // because we may be replaying this log after
                        // it had been partially executed.
                        //

                        if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                            return( Status );

                        } else {

                            break;
                        }
                    }

                    CloseTargetKey = TRUE;

                } else {

                    TargetKey = RXactLogEntry->KeyHandle;
                    CloseTargetKey = FALSE;
                }


                //
                // If this fails, then it is an error
                // because the key should exist at
                // this point.
                //

                Status = NtDeleteKey( TargetKey );


                //
                // Only close the target key if we opened it
                //

                if ( CloseTargetKey ) {

                    TmpStatus = NtClose( TargetKey );

                    //
                    // If we opened this handle, then we should
                    // be able to close it, whether it has been
                    // deleted or not.
                    //

                    ASSERT(NT_SUCCESS(TmpStatus));        // safe to ignore, but curious...
                }


                if (!NT_SUCCESS(Status)) {
                    return(Status);
                }

                break;

            case RtlRXactOperationSetValue:

                //
                // Open the target key.
                // The name is relative to the RootRegistryKey.
                //

                if ( ((RXactLogEntry->KeyHandle == INVALID_HANDLE_VALUE) || !HandlesValid) ) {

                    Status = RXactpOpenTargetKey(
                                 RootRegistryKey,
                                 RtlRXactOperationSetValue,
                                 &RXactLogEntry->SubKeyName,
                                 &TargetKey
                                 );

                    if ( !NT_SUCCESS(Status) ) {
                        return(Status);
                    }

                    CloseTargetKey = TRUE;

                } else {

                    TargetKey = RXactLogEntry->KeyHandle;
                    CloseTargetKey = FALSE;
                }

                //
                // Assign to the target key's new value
                //

                Status = NtSetValueKey( TargetKey,
                                        &RXactLogEntry->AttributeName,
                                        0,               // TitleIndex
                                        RXactLogEntry->NewKeyValueType,
                                        RXactLogEntry->NewKeyValue,
                                        RXactLogEntry->NewKeyValueLength
                                        );

                //
                // Only close the target key if we opened it
                //

                if ( CloseTargetKey ) {

                    TmpStatus = NtClose( TargetKey );
                    ASSERT(NT_SUCCESS(TmpStatus));        // safe to ignore, but curious...

                }

                if ( !NT_SUCCESS(Status) ) {
                    return(Status);
                }

                break;



            default:

                //
                // Unknown operation type.  This should never happen.
                //

                ASSERT( FALSE );

                return(STATUS_INVALID_PARAMETER);

        }

        RXactLogEntry = (PRXACT_LOG_ENTRY)((PCHAR)RXactLogEntry + RXactLogEntry->LogEntrySize);

    }

    //
    // Commit complete
    //

    return( STATUS_SUCCESS );

}




NTSTATUS
RXactpOpenTargetKey(
    IN HANDLE RootRegistryKey,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    OUT PHANDLE TargetKey
    )

/*++

Routine Description:

    This routine opens the target registry key of an operation.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        a transaction is to be initialized.

    Operation - Indicates what operation is to be performed on the target.
        This will effect how the target is opened.

    OperationNameKey - A handle to the operation log sub-key
        containing the name of the target registry key.

    TargetKey - Receives a handle to the target registry key.

Return Value:

    STATUS_SUCCESS - Indicates the operation log entry was opened.

    STATUS_NO_MEMORY - Ran out of heap.


--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES TargetKeyAttributes;
    ACCESS_MASK DesiredAccess;
    ULONG Disposition;


    if (Operation == RtlRXactOperationDelete) {

        DesiredAccess = DELETE;

        InitializeObjectAttributes(
            &TargetKeyAttributes,
            SubKeyName,
            OBJ_CASE_INSENSITIVE,
            RootRegistryKey,
            NULL);

//        Status = RtlpNtOpenKey(
//                     TargetKey,
//                     DesiredAccess,
//                     &TargetKeyAttributes,
//                     0);

        Status = NtOpenKey( TargetKey,
                            DesiredAccess,
                            &TargetKeyAttributes
                            );


    } else if (Operation == RtlRXactOperationSetValue) {

        DesiredAccess = KEY_WRITE;

        InitializeObjectAttributes(
            &TargetKeyAttributes,
            SubKeyName,
            OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
            RootRegistryKey,
            NULL);

        Status = NtCreateKey(
                     TargetKey,
                     DesiredAccess,
                     &TargetKeyAttributes,
                     0,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     &Disposition
                     );

    } else {
        return STATUS_INVALID_PARAMETER;
    }



    return( Status );

}



//NTSTATUS
//RXactpAssignTargetValue(
//    IN PVOID NewKeyValue,
//    IN ULONG NewKeyValueLength,
//    IN ULONG NewKeyValueType,
//    IN HANDLE TargetKey,
//    IN PUNICODE_STRING AttributeName
//    );


//NTSTATUS
//RXactpAssignTargetValue(
//    IN PVOID NewKeyValue,
//    IN ULONG NewKeyValueLength,
//    IN ULONG NewKeyValueType,
//    IN HANDLE TargetKey,
//    IN PUNICODE_STRING AttributeName
//    )
//
///*++
//
//Routine Description:
//
//    This routine copies the value of an operation log entry to its
//    corresponding target key.  The target key must already be open.
//
//Arguments:
//
//    NewKeyValue - The new value for the key being modified.
//
//    NewKeyValueLength - The size in bytes of the new value information.
//
//    NewKeyValueType - The type of the data for the new key.
//
//    TargetKey - A handle to the target registry key.
//
//    AttributeName - Supplies the name of the key attribute being edited.
//
//Return Value:
//
//    STATUS_SUCCESS - Indicates the value was successfully applied to
//        the target registry key.
//
//    STATUS_NO_MEMORY - ran out of heap.
//
//
//--*/
//{
//    NTSTATUS Status;
//
//    //
//    // Now apply the value to the target key
//    //
//    // Even if there is no key value, we need to do the assign so that
//    // the key value type is assigned.
//    //
//
//    Status = NtSetValueKey( TargetKey,
//                            AttributeName,
//                            0,               // TitleIndex
//                            NewKeyValueType,
//                            NewKeyValue,
//                            NewKeyValueLength
//                            );
//
//
//    return( Status );
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\secmem.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    secmem.c

Abstract:

    This module implements a user level callback for securing memory for SAN IOs.

Author:

    Nar Ganapathy (narg) 8-Feb-2000 

Revision History:

--*/

#include "ntrtlp.h"

ULONG_PTR   RtlSecureMemorySystemRangeStart;
PRTL_SECURE_MEMORY_CACHE_CALLBACK       RtlSecureMemoryCacheCallback = NULL;

NTSTATUS
RtlRegisterSecureMemoryCacheCallback(
    IN PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    )
/*++

Routine Description:

    This routine allows a library to register to be called back whenever
    memory is freed or its protections are changed. This is useful for 
    maintaining user level secure memory cache for SAN applications.
    Current customer is winsock DP. 

Arguments:

    CallBack - Supplies a pointer to the callback routine

Return Value:

    NTSTATUS code. Returns STATUS_SUCCESS if we could sucessfully register
    the callback.
--*/
{
    NTSTATUS status;

    status = NtQuerySystemInformation(SystemRangeStartInformation,
                                      &RtlSecureMemorySystemRangeStart,
                                      sizeof(RtlSecureMemorySystemRangeStart),
                                      NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!RtlSecureMemoryCacheCallback) {
        RtlSecureMemoryCacheCallback = Callback;
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MORE_ENTRIES;
    }
}

BOOLEAN
RtlFlushSecureMemoryCache(
    IN PVOID   lpAddr,
    IN SIZE_T  size
    )
/*++

Routine Description:

    This routine is called from various Win32 and Heap APIs whenever memory is freed
    or its protections are changed. We call the callback routine that has been registered.
    Its possible that size is 0 which means that this routine has to figure out the region
    size. The NtQueryVirtualMemory API is used for this. Unfortunately this API does not 
    provide us the right boundary of the region. So we loop until the state changes to MEM_FREE.
    This will guarantee that a region boundary has been found. This implies that we might unlock
    more pages than we have to.

Arguments:

    lpAddr - Pointer to the address thats getting freed or its protections changed.
    size   - Size of the address range. Can be zero.

Return Value:

    Returns TRUE if the callback was successful.
    
--*/
{
    ULONG_PTR   addr; 
    SIZE_T  regionSize;
    ULONG   regType;
    ULONG   regState;
    MEMORY_BASIC_INFORMATION    memInfo;
    NTSTATUS   status;
    PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback;


    Callback = RtlSecureMemoryCacheCallback;
    if (Callback) {

        if (!size) {
            //
            // Compute the real size of the region
            //

            addr = (ULONG_PTR)lpAddr;
            status = NtQueryVirtualMemory( NtCurrentProcess(),
                                           (PVOID)addr,
                                           MemoryBasicInformation,
                                           (PMEMORY_BASIC_INFORMATION)&memInfo,
                                           sizeof(memInfo),
                                           NULL
                                         );
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }
            if (memInfo.State == MEM_FREE) {
                return FALSE;
            }
            while (1) {
                size += memInfo.RegionSize;
                regState = memInfo.State;
                addr = addr + memInfo.RegionSize;

                if (addr > RtlSecureMemorySystemRangeStart) {
                    break;
                }

                status = NtQueryVirtualMemory( NtCurrentProcess(),
                                               (PVOID)addr,
                                               MemoryBasicInformation,
                                               (PMEMORY_BASIC_INFORMATION)&memInfo,
                                               sizeof(memInfo),
                                               NULL
                                             );

                if (!NT_SUCCESS(status)) {
                    return FALSE;
                }

                if (memInfo.State == MEM_FREE) {
                    break;
                }

            }
        }

        status = Callback(lpAddr, size);

        return (NT_SUCCESS(status));
    }
    return FALSE;
}

NTSTATUS
RtlpSecMemFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
     )
/*++

Routine Description:

    This routine is called from the HEAP APIs to free virtual memory. In addition to calling
    NtFreeVirtualMemory it tries to flush the secure memory cache.

Arguments:

    The arguments are identical to NtFreeVirtualMemory. 
Return Value:

    Returns TRUE if the callback was successful.
    
--*/
{
    NTSTATUS    status;

    status = NtFreeVirtualMemory( ProcessHandle, 
                                  BaseAddress,
                                  RegionSize,
                                  FreeType
                                  );
    
    if (status == STATUS_INVALID_PAGE_PROTECTION) {

        if ((ProcessHandle == NtCurrentProcess()) && RtlFlushSecureMemoryCache(*BaseAddress, *RegionSize)) {
            status = NtFreeVirtualMemory( ProcessHandle, 
                                          BaseAddress,
                                          RegionSize,
                                          FreeType
                                          );
            return status;
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\splay.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Splay.c

Abstract:

    This module implements the general splay utilities

Author:

    Gary Kimura     [GaryKi]    23-May-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include <nt.h>

#include <ntrtl.h>

#define SwapPointers(Ptr1, Ptr2) {      \
    PVOID _SWAP_POINTER_TEMP;           \
    _SWAP_POINTER_TEMP = (PVOID)(Ptr1); \
    (Ptr1) = (Ptr2);                    \
    (Ptr2) = _SWAP_POINTER_TEMP; \
    }

#define ParentsChildPointerAddress(Links) ( \
    RtlIsLeftChild(Links) ?                 \
        &(((Links)->Parent)->LeftChild)     \
    :                                       \
        &(((Links)->Parent)->RightChild)    \
    )

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    );


PRTL_SPLAY_LINKS
RtlSplay (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Splay function takes as input a pointer to a splay link in a tree
    and splays the tree.  Its function return value is a pointer to the
    root of the splayed tree.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the splayed tree.

--*/

{
    PRTL_SPLAY_LINKS L;
    PRTL_SPLAY_LINKS P;
    PRTL_SPLAY_LINKS G;

    //
    //  while links is not the root we need to keep rotating it toward
    //  the root
    //

    L = Links;

    while (!RtlIsRoot(L)) {

        P = RtlParent(L);
        G = RtlParent(P);

        if (RtlIsLeftChild(L)) {

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                          P           L
                         / \         / \
                        L   c  ==>  a   P
                       / \             / \
                      a   b           b   c
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsLeftChild(P)) {

                /*
                  we have the following case

                          |           |
                          G           L
                         / \         / \
                        P   d  ==>  a   P
                       / \             / \
                      L   c           b   G
                     / \                 / \
                    a   b               c   d
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = P->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->RightChild = G;
                G->Parent = P;

            } else { // RtlIsRightChild(Parent)

                /*
                  we have the following case

                        |                |
                        G                L
                       / \             /   \
                      a   P           G     P
                         / \         / \   / \
                        L   d  ==>  a   b c   d
                       / \
                      b   c
                */

                //
                //  Connect G & b
                //

                G->RightChild = L->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & G
                //

                L->LeftChild = G;
                G->Parent = L;

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

            }

        } else { // RtlIsRightChild(L)

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                        P               L
                       / \             / \
                      a   L           P   c
                         / \         / \
                        b   c  ==>  a   b
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect P & L
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsRightChild(P)) {

                /*
                  we have the following case

                      |                   |
                      G                   L
                     / \                 / \
                    a   P               P   d
                       / \             / \
                      b   L           G   c
                         / \         / \
                        c   d  ==>  a   b
                */

                //
                //  Connect G & b
                //

                G->RightChild = P->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->LeftChild = G;
                G->Parent = P;

            } else { // RtlIsLeftChild(P)

                /*
                  we have the following case

                          |              |
                          G              L
                         / \           /   \
                        P   d         P     G
                       / \           / \   / \
                      a   L    ==>  a   b c   d
                         / \
                        b   c
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = L->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect L & G
                //

                L->RightChild = G;
                G->Parent = L;

            }
        }
    }

    return L;
}


PRTL_SPLAY_LINKS
RtlDelete (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree
    and deletes that node from the tree.  Its function return value is a
    pointer to the root of the tree.  If the tree is now empty, the return
    value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the tree.

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = RtlSubtreePredecessor(Links);
        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL, and splay the parent.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then return NULL
        //

        if (RtlIsRoot(Links)) {

            return NULL;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL and splay the parent.
        //

        Parent = RtlParent(Links);

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return RtlSplay(Parent);

    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent, and splay
    //  the parent.  But first remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;
        return Child;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent, and splay
    //  the parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return RtlSplay(RtlParent(Child));

}


VOID
RtlDeleteNoSplay (
    IN PRTL_SPLAY_LINKS Links,
    IN OUT PRTL_SPLAY_LINKS *Root
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree,
    a pointer to the callers pointer to the tree and deletes that node from
    the tree.  The caller's pointer is updated upon return.  If the tree is
    now empty, the value is NULL.

    Unfortunately, the original RtlDelete() always splays and this is not
    always a desireable side-effect.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

    Root - Pointer to the callers pointer to the root 

Return Value:

    None

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = RtlSubtreePredecessor(Links);

        if (RtlIsRoot(Links)) {

            //
            //  If we're switching with the root of the tree, fix the
            //  caller's root pointer
            //

            *Root = Predecessor;
        }

        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then set root to NULL
        //

        if (RtlIsRoot(Links)) {

            *Root = NULL;

            return;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL.
        //

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return;
    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent. But first
    //  remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;

        *Root = Child;

        return;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return;
}


PRTL_SPLAY_LINKS
RtlSubtreeSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreeSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node of
    the substree rooted at the input node.  If there is not a successor, the
    return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      check to see if there is a right subtree to the input link
      if there is then the subtree successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreePredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node of
    the substree rooted at the input node.  If there is not a predecessor,
    the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a left subtree to the input link
    //  if there is then the subtree predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree predecessor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsLeftChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealPredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right decendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsRightChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}


VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    )

{
    PRTL_SPLAY_LINKS *Parent1ChildPtr;
    PRTL_SPLAY_LINKS *Parent2ChildPtr;

    /*
      We have the following situation


             Parent1            Parent2
                |                  |
                |                  |
              Link1              Link2
               / \                / \
              /   \              /   \
            LC1   RC1          LC2   RC2

      where one of the links can possibly be the root and one of the links
      can possibly be a direct child of the other.  Without loss of
      generality we'll make link2 be the possible and root and link1 be
      the possible child.
    */

    if ((RtlIsRoot(Link1)) || (RtlParent(Link2) == Link1)) {
        SwapPointers(Link1, Link2);
    }

    //
    //  The four cases we need to handle are
    //
    //  1. Link1 is not a child of link2 and link2 is not the root
    //  2. Link1 is not a child of link2 and link2 is     the root
    //  3. Link1 is     a child of link2 and link2 is not the root
    //  4. Link1 is     a child of link2 and link2 is     the root
    //
    //
    //  Each case will be handled separately
    //

    if (RtlParent(Link1) != Link2) {

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 1 the initial steps are:
            //
            //  1. get both parent child pointers
            //  2. swap the parent child pointers
            //  3. swap the parent pointers
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            Parent2ChildPtr = ParentsChildPointerAddress(Link2);

            SwapPointers(*Parent1ChildPtr, *Parent2ChildPtr);

            SwapPointers(Link1->Parent, Link2->Parent);

        } else {

            //
            //  Case 2 the initial steps are:
            //
            //  1. Set link1's parent child pointer to link2
            //  2. Set parent pointer of link2 to link1's parent
            //  3. Set parent pointer of link1 to be itself
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            *Parent1ChildPtr = Link2;

            Link2->Parent = Link1->Parent;

            Link1->Parent = Link1;

        }

        //
        //  Case 1 and 2 common steps are:
        //
        //  1. swap the child pointers
        //

        SwapPointers(Link1->LeftChild, Link2->LeftChild);
        SwapPointers(Link1->RightChild, Link2->RightChild);

    } else { // RtlParent(Link1) == Link2

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 3 the initial steps are:
            //
            //  1. Set Link2's parent child pointer to link1
            //  2. Set Link1's parent pointer to parent of link2
            //

            Parent2ChildPtr = ParentsChildPointerAddress(Link2);
            *Parent2ChildPtr = Link1;

            Link1->Parent = Link2->Parent;

        } else {

            //
            //  Case 4 the initial steps are:
            //
            //  1. Set Link1's parent pointer to be link1
            //

            Link1->Parent = Link1;

        }

        //
        //  Case 3 and 4 common steps are:
        //
        //  1. Swap the child pointers
        //  2. if link1 was a left child (i.e., RtlLeftChild(Link1) == Link1)
        //     then set left child of link1 to link2
        //     else set right child of link1 to link2
        //

        SwapPointers(Link1->LeftChild, Link2->LeftChild);
        SwapPointers(Link1->RightChild, Link2->RightChild);

        if (Link1->LeftChild == Link1) {
            Link1->LeftChild = Link2;
        } else {
            Link1->RightChild = Link2;
        }

    }

    //
    //  Case 1, 2, 3, 4 common (and final) steps are:
    //
    //  1. Fix the parent pointers of the left and right children
    //

    if (Link1->LeftChild  != NULL) {Link1->LeftChild->Parent  = Link1;}
    if (Link1->RightChild != NULL) {Link1->RightChild->Parent = Link1;}
    if (Link2->LeftChild  != NULL) {Link2->LeftChild->Parent  = Link2;}
    if (Link2->RightChild != NULL) {Link2->RightChild->Parent = Link2;}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\stdtimep.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stdtimep.h

Abstract:

    This module contains definitions and function prototypes which are local to
    stdime.c and fmttime.c.

Author:

    Rob McKaughan (t-robmc) 17-Jul-1991

Revision History:

--*/

#ifndef _STD_TIME_P_
#define _STD_TIME_P_

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

extern LARGE_INTEGER Magic10000;
#define SHIFT10000                       13

extern LARGE_INTEGER Magic10000000;
#define SHIFT10000000                    23

extern LARGE_INTEGER Magic86400000;
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000L )             \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros for Time Differentials and Time Revisions                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The following define the minimum and maximum possible values for the Time
// Differential Factor as defined by ISO 4031-1978.
//

#define MAX_STDTIME_TDF (780)
#define MIN_STDTIME_TDF (-720)

//
// The revision of this design (will be inserted in the revision field of any
// STANDARD_TIMEs created by this revision).
//

#define STDTIME_REVISION (4)


//
// The number of bits we need to shift to get to and from a revision in a
// StdTime.TdfAndRevision field.
//

#define STDTIME_REVISION_SHIFT 12


//
// USHORT
// ShiftStandardTimeRevision(
//    IN USHORT Rev
//    )
// Description:
//    This routine shifts the given revision number to its proper place for
//    storing in a STANDARD_TIME.TdfAndRevision field.
//

#define ShiftStandardTimeRevision(Rev)                                        \
   ((USHORT) ((Rev) << STDTIME_REVISION_SHIFT))


//
// The pre-shifted value of the current revision
//

#define SHIFTED_STDTIME_REVISION (ShiftStandardTimeRevision(STDTIME_REVISION))


//
// The bit mask used to mask a STANDARD_TIME.TdfAndRevision field to retrieve
// the Tdf value.
//

#define TDF_MASK ((USHORT) 0x0fff)


//
// USHORT
// MaskStandardTimeTdf(
//    IN USHORT Tdf
//    )
// Description:
//    This routine masks the given tdf field with TDF_MASK and returns the
//    result.
//
// BUG: Byte order dependant
//

#define MaskStandardTimeTdf(Tdf) ((USHORT) ((Tdf) & TDF_MASK))


//
// SHORT
// GetStandardTimeTdf(
//    IN STANDARD_TIME
//    )
// Description:
//    This routine gets the Time Differential Factor from a tdf field and
//    makes any adjustments necessary to preserve the sign of the TDF.
//    The resulting TDF is returned.
//
//    Since the TDF is stored as a signed 12 bit int, it's sign bit is the
//    bit 0x0800.  To make it a 16 bit negative, we subtract 0x1000 from the
//    bottome 12 bits of the TdfAndRevision field.
//
// BUG: Byte order dependant
//

#define GetStandardTimeTdf(StdTime)                                           \
   ((SHORT)                                                                   \
     (((StdTime)->TdfAndRevision) & 0x0800)                                   \
        ? (MaskStandardTimeTdf((StdTime)->TdfAndRevision) - 0x1000)           \
        : MaskStandardTimeTdf((StdTime)->TdfAndRevision)                      \
   )


//
// USHORT
// GetStandardTimeRev(
//    IN USHORT Tdf
//    )
// Description:
//    This routine gets the revision number from a tdf field and returns it
//    shifted back down to its place as a SHORT.
//

#define GetStandardTimeRev(StdTime)                                           \
   ((USHORT) (((StdTime)->TdfAndRevision) >> STDTIME_REVISION_SHIFT))



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Tests for absolute and delta times                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// BOOLEAN
// IsPositive(
//    IN LARGE_INTEGER Time
//    )
// Returns:
//    TRUE - if the time in Time is positive.
//    FALSE - if Time is negative.
//

#define IsPositive(Time)                                                      \
   ( ((Time).HighPart > 0) || (((Time).HighPart = 0) & ((Time).LowPart > 0)) )

//
// BOOLEAN
// IsAbsoluteTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is an absolute time
//    FALSE - If the given time is not an absolute time
//

#define IsAbsoluteTime(Time)                                                  \
   ( IsPositive(Time->SimpleTime) )


//
// BOOLEAN
// IsDeltaTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is a delta time
//    FALSE - If the given time is not a delta time
//

#define IsDeltaTime(Time)                                                     \
   ( !IsAbsoluteTime(Time) )


//
// BOOLEAN
// GreaterThanTime(
//    IN PLARGE_INTEGER Time1,
//    IN PLARGE_INTEGER Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//
// BUG: Byte order dependant
// BUG: Only works on absolute times
//

#define GreaterThanTime(Time1, Time2)                                         \
   (                                                                          \
     ((Time1).HighPart > (Time2).HighPart)                                    \
     ||                                                                       \
     (                                                                        \
      ((Time1).HighPart == (Time2).HighPart)                                  \
      &&                                                                      \
      ((Time1).LowPart > (Time2).LowPart)                                     \
     )                                                                        \
   )


//
// BOOLEAN
// GreaterThanStandardTime(
//    IN PSTANDARD_TIME Time1,
//    IN PSTANDARD_TIME Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//

#define GreaterThanStdTime(Time1, Time2) \
   GreaterThanTime((Time1).SimpleTime, (Time2).SimpleTime)



//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//  The following definitions and declarations are some important constants  /
//  used in the time conversion routines                                     /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//
//  These are declared in time.c
//

extern const LARGE_INTEGER SecondsToStartOf1970;
extern const LARGE_INTEGER SecondsToStartOf1980;


//
//  ULONG
//  ElapsedDaysToYears (
//      IN ULONG ElapsedDays
//      );
//
//  To be completely true to the Gregorian calendar the equation to
//  go from days to years is really
//
//      ElapsedDays / 365.2425
//
//  But because we are doing the computation in ulong integer arithmetic
//  and the LARGE_INTEGER variable limits the number of expressible days to around
//  11,000,000 we use the following computation
//
//      (ElapsedDays * 128 + 127) / (365.2425 * 128)
//
//  which will be off from the Gregorian calendar in about 150,000 years
//  but that doesn't really matter because LARGE_INTEGER can only express around
//  30,000 years
//

#define ElapsedDaysToYears(DAYS) ( \
    ((DAYS) * 128 + 127) / 46751   \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )


//
// Local utlity function prototypes
//

VOID
RtlpConvert48To64(
   IN PSTDTIME_ERROR num48,
   OUT LARGE_INTEGER *num64
   );

NTSTATUS
RtlpConvert64To48(
   IN LARGE_INTEGER num64,
   OUT PSTDTIME_ERROR num48
   );

LARGE_INTEGER
RtlpTimeToLargeInt(
   IN LARGE_INTEGER Time
   );

LARGE_INTEGER
RtlpLargeIntToTime(
   IN LARGE_INTEGER Int
   );

NTSTATUS
RtlpAdd48Int(
   IN PSTDTIME_ERROR First48,
   IN PSTDTIME_ERROR Second48,
   IN PSTDTIME_ERROR Result48
   );

NTSTATUS
RtlpAddTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

NTSTATUS
RtlpSubtractTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

LARGE_INTEGER
RtlpAbsTime(
   IN LARGE_INTEGER Time
   );

#endif //_STD_TIME_P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\stktrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    This module implements routines to snapshot a set of stack back traces
    in a data base.  Useful for heap allocators to track allocation requests
    cheaply.

Author:

    Steve Wood (stevewo) 29-Jan-1992

Revision History:

    17-May-1999 (silviuc) : added RtlWalkFrameChain that replaces the
        unsafe RtlCaptureStackBackTrace.

    29-Jul-2000 (silviuc) : added RtlCaptureStackContext.

    6-Nov-2000 (silviuc): IA64 runtime stack traces.

    18-Feb-2001 (silviuc) : moved all x86 specific code into i386 directory.
    
    03-May-2002 (silviuc) : switched to a resource instead of a lock. Traces that
        are in the database can be found by locking the resource in shared mode.
        Only a real addition to the database will require exclusive acquisition.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include "ntrtlp.h"
#include <nturtl.h>
#include <zwapi.h>
#include <stktrace.h>
#include <heap.h>
#include <heappriv.h>

//
// Number of buckets used for the simple chaining hash table.
//

#define NUMBER_OF_BUCKETS 1567

//
// Macros to hide the different synchronization routines for
// user mode and kernel mode runtimes. For kernel runtime
// the OKAY_TO_LOCK macro points to a real function that makes
// sure current thread is not executing a DPC routine.
//

#ifdef NTOS_KERNEL_RUNTIME

typedef struct _KSPIN_LOCK_EX {

    KSPIN_LOCK Lock;
    KIRQL OldIrql;
    PKTHREAD Owner;

} KSPIN_LOCK_EX, *PKSPIN_LOCK_EX;

NTSTATUS
KeInitializeSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    KeInitializeSpinLock (&(Lock->Lock));
    Lock->OldIrql = 0;
    Lock->Owner = NULL;
    return STATUS_SUCCESS;
}

VOID
KeAcquireSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    KeAcquireSpinLock (&(Lock->Lock), &(Lock->OldIrql));
    Lock->Owner = KeGetCurrentThread();
}

VOID
KeReleaseSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    Lock->Owner = NULL;
    KeReleaseSpinLock (&(Lock->Lock), (Lock->OldIrql));
}

#define INITIALIZE_DATABASE_LOCK(R) KeInitializeSpinLockEx((PKSPIN_LOCK_EX)R)
#define ACQUIRE_DATABASE_LOCK(R) KeAcquireSpinLockEx((PKSPIN_LOCK_EX)R)
#define RELEASE_DATABASE_LOCK(R) KeReleaseSpinLockEx((PKSPIN_LOCK_EX)R)
#define OKAY_TO_LOCK_DATABASE(R) ExOkayToLockRoutine(&(((PKSPIN_LOCK_EX)R)->Lock))

BOOLEAN
ExOkayToLockRoutine (
    IN PVOID Lock
    );

#else //#ifdef NTOS_KERNEL_RUNTIME

#define INITIALIZE_DATABASE_LOCK(R) RtlInitializeCriticalSection(R)
#define ACQUIRE_DATABASE_LOCK(R) RtlEnterCriticalSection(R)
#define RELEASE_DATABASE_LOCK(R) RtlLeaveCriticalSection(R)
#define OKAY_TO_LOCK_DATABASE(R) (RtlDllShutdownInProgress() == FALSE)

#endif // #ifdef NTOS_KERNEL_RUNTIME

//
// Globals from elsewhere refered here.
//

extern BOOLEAN RtlpFuzzyStackTracesEnabled;

//
// Forward declarations of private functions.
//

USHORT
RtlpLogStackBackTraceEx(
    ULONG FramesToSkip
    );

LOGICAL
RtlpCaptureStackTraceForLogging (
    PRTL_STACK_TRACE_ENTRY Trace,
    PULONG Hash,
    ULONG FramesToSkip,
    LOGICAL UserModeStackFromKernelMode
    );

USHORT
RtlpLogCapturedStackTrace(
    PRTL_STACK_TRACE_ENTRY Trace,
    ULONG Hash
    );

PRTL_STACK_TRACE_ENTRY
RtlpExtendStackTraceDataBase(
    IN PRTL_STACK_TRACE_ENTRY InitialValue,
    IN SIZE_T Size
    );

//
// Global per process (user mode) or system wide (kernel mode) 
// stack trace database.
//

PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;

//
// Resource used to control access to stack trace database. We opted for 
// this solution so that we kept change in the database structure to an 
// absolute minimal. This way the tools that depend on this structure
// (at least umhd and oh) will not need a new version and will not
// introduce backcompatibility issues.
//

#ifdef NTOS_KERNEL_RUNTIME
KSPIN_LOCK_EX RtlpStackTraceDataBaseLock;
#else
RTL_CRITICAL_SECTION RtlpStackTraceDataBaseLock;
#endif

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Runtime stack trace database
/////////////////////////////////////////////////////////////////////

//
// The following section implements a trace database used to store
// stack traces captured with RtlCaptureStackBackTrace(). The database
// is implemented as a hash table and does not allow deletions. It is
// sensitive to "garbage" in the sense that spurios garbage (partially
// correct stacks) will hash in different buckets and will tend to fill
// the whole table. This is a problem only on x86 if "fuzzy" stack traces
// are used. The typical function used to log the trace is
// RtlLogStackBackTrace. One of the worst limitations of this package
// is that traces are refered using a ushort index which means we cannot
// ever store more than 65535 traces (remember we never delete traces).
//

PSTACK_TRACE_DATABASE
RtlpAcquireStackTraceDataBase(
    )
{
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;

    //
    // Sanity checks.
    //

    if (DataBase == NULL) {
        return NULL;
    }

    if (! OKAY_TO_LOCK_DATABASE (DataBase->Lock)) {
        return NULL;
    }

    ACQUIRE_DATABASE_LOCK (DataBase->Lock);

    if (DataBase->DumpInProgress) {
        
        RELEASE_DATABASE_LOCK (DataBase->Lock);
        return NULL;
    }
    else {

        return DataBase;
    }
}


VOID
RtlpReleaseStackTraceDataBase(
    )
{
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;
    
    //
    // Sanity checks.
    //

    if (DataBase == NULL) {
        return;
    }
    
    RELEASE_DATABASE_LOCK (DataBase->Lock);
}


NTSTATUS
RtlInitializeStackTraceDataBase(
    IN PVOID CommitBase,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize
    )
{
    NTSTATUS Status;
    PSTACK_TRACE_DATABASE DataBase;

    //
    // On x86 where runtime stack tracing algorithms are unreliable
    // if we have a big enough trace database then we can enable fuzzy
    // stack traces that do not hash very well and have the potential
    // to fill out the trace database.
    //

#if defined(_X86_) && !defined(NTOS_KERNEL_RUNTIME)
    if (ReserveSize >= 16 * RTL_MEG) {
        RtlpFuzzyStackTracesEnabled = TRUE;
    }
#endif 

    DataBase = (PSTACK_TRACE_DATABASE)CommitBase;
    
    if (CommitSize == 0) {

        //
        // Initially commit enough pages to accomodate the increased
        // number of hash chains (for improved performance we switched from ~100
        // to ~1000 in the hope that the hash chains will decrease ten-fold in 
        // length).
        //

        CommitSize = ROUND_TO_PAGES (NUMBER_OF_BUCKETS * sizeof (DataBase->Buckets[ 0 ]));
            
        Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
                                          (PVOID *)&CommitBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);

        if (! NT_SUCCESS(Status)) {

            KdPrint (("RTL: Unable to commit space to extend stack "
                      "trace data base - Status = %lx\n",
                      Status));
            return Status;
        }

        DataBase->PreCommitted = FALSE;
    }
    else if (CommitSize == ReserveSize) {

        RtlZeroMemory (DataBase, sizeof( *DataBase ));

        DataBase->PreCommitted = TRUE;
    }
    else {
        
        return STATUS_INVALID_PARAMETER;
    }

    DataBase->CommitBase = CommitBase;
    DataBase->NumberOfBuckets = NUMBER_OF_BUCKETS; 
    DataBase->NextFreeLowerMemory = (PCHAR)(&DataBase->Buckets[ DataBase->NumberOfBuckets ]);
    DataBase->NextFreeUpperMemory = (PCHAR)CommitBase + ReserveSize;

    if (! DataBase->PreCommitted) {

        DataBase->CurrentLowerCommitLimit = (PCHAR)CommitBase + CommitSize;
        DataBase->CurrentUpperCommitLimit = (PCHAR)CommitBase + ReserveSize;
    }
    else {
        
        RtlZeroMemory (&DataBase->Buckets[ 0 ],
                       DataBase->NumberOfBuckets * sizeof (DataBase->Buckets[ 0 ]));
    }

    DataBase->EntryIndexArray = (PRTL_STACK_TRACE_ENTRY *)DataBase->NextFreeUpperMemory;

    //
    // Initialize the database lock.
    //

    DataBase->Lock = &RtlpStackTraceDataBaseLock;

    Status = INITIALIZE_DATABASE_LOCK (DataBase->Lock);

    if (! NT_SUCCESS(Status)) {
        
        KdPrint(("RTL: Unable to initialize stack trace database lock (status %X)\n", Status));
        return Status;
    }

    RtlpStackTraceDataBase = DataBase;

    return STATUS_SUCCESS;
}


PRTL_STACK_TRACE_ENTRY
RtlpExtendStackTraceDataBase(
    IN PRTL_STACK_TRACE_ENTRY InitialValue,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This routine extends the stack trace database in order to accomodate
    the new stack trace that has to be saved.

Arguments:

    InitialValue - stack trace to be saved.

    Size - size of the stack trace in bytes. Note that this is not the
        depth of the trace but rather `Depth * sizeof(PVOID)'.

Return Value:

    The address of the just saved stack trace or null in case we have hit
    the maximum size of the database or we get commit errors.

Environment:

    User mode.

    Note. In order to make all this code work in kernel mode we have to
    rewrite this function that relies on VirtualAlloc.

--*/

{
    NTSTATUS Status;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    SIZE_T CommitSize;
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;

    //
    // We will try to find space for one stack trace entry in the
    // upper part of the database.
    //

    pp = (PRTL_STACK_TRACE_ENTRY *)DataBase->NextFreeUpperMemory;

    if ((! DataBase->PreCommitted) &&
        ((PCHAR)(pp - 1) < (PCHAR)DataBase->CurrentUpperCommitLimit)) {

        //
        // No more committed space in the upper part of the database.
        // We need to extend it downwards.
        //

        DataBase->CurrentUpperCommitLimit =
            (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit - PAGE_SIZE);

        if (DataBase->CurrentUpperCommitLimit < DataBase->CurrentLowerCommitLimit) {

            //
            // No more space at all. We have got over the lower part of the db.
            // We failed therefore increase back the UpperCommitLimit pointer.
            //

            DataBase->CurrentUpperCommitLimit =
                (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit + PAGE_SIZE);

            return( NULL );
        }

        CommitSize = PAGE_SIZE;
        Status = ZwAllocateVirtualMemory(
            NtCurrentProcess(),
            (PVOID *)&DataBase->CurrentUpperCommitLimit,
            0,
            &CommitSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if (!NT_SUCCESS( Status )) {

            //
            // We tried to increase the upper part of the db by one page.
            // We failed therefore increase back the UpperCommitLimit pointer
            //

            DataBase->CurrentUpperCommitLimit =
                (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit + PAGE_SIZE);

            return NULL;
        }
    }

    //
    // We managed to make sure we have usable space in the upper part
    // therefore we take out one stack trace entry address.
    //

    DataBase->NextFreeUpperMemory -= sizeof( *pp );

    //
    // Now we will try to find space in the lower part of the database for
    // for the eactual stack trace.
    //

    p = (PRTL_STACK_TRACE_ENTRY)DataBase->NextFreeLowerMemory;

    if ((! DataBase->PreCommitted) &&
        (((PCHAR)p + Size) > (PCHAR)DataBase->CurrentLowerCommitLimit)) {

        //
        // We need to extend the lower part.
        //

        if (DataBase->CurrentLowerCommitLimit >= DataBase->CurrentUpperCommitLimit) {

            //
            // We have hit the maximum size of the database.
            //

            return( NULL );
        }

        //
        // Extend the lower part of the database by one page.
        //

        CommitSize = Size;
        Status = ZwAllocateVirtualMemory(
            NtCurrentProcess(),
            (PVOID *)&DataBase->CurrentLowerCommitLimit,
            0,
            &CommitSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if (! NT_SUCCESS( Status )) {
            return NULL;
        }

        DataBase->CurrentLowerCommitLimit =
            (PCHAR)DataBase->CurrentLowerCommitLimit + CommitSize;
    }

    //
    // Take out the space for the stack trace.
    //

    DataBase->NextFreeLowerMemory += Size;

    //
    // Deal with a precommitted database case. If the lower and upper
    // pointers have crossed each other then rollback and return failure.
    //

    if (DataBase->PreCommitted &&
        DataBase->NextFreeLowerMemory >= DataBase->NextFreeUpperMemory) {

        DataBase->NextFreeUpperMemory += sizeof( *pp );
        DataBase->NextFreeLowerMemory -= Size;
        return( NULL );
    }

    //
    // Save the stack trace in the database
    //

    RtlMoveMemory( p, InitialValue, Size );
    p->HashChain = NULL;
    p->TraceCount = 0;
    p->Index = (USHORT)(++DataBase->NumberOfEntriesAdded);

    //
    // Save the address of the new stack trace entry in the
    // upper part of the databse.
    //

    *--pp = p;

    //
    // Return address of the saved stack trace entry.
    //

    return( p );
}


#pragma optimize("y", off) // disable FPO
USHORT
RtlLogStackBackTrace(
    VOID
    )
/*++

Routine Description:

    This routine will capture the current stacktrace (skipping the
    present function) and will save it in the global (per process)
    stack trace database. It should be noted that we do not save
    duplicate traces.

Arguments:

    None.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    return RtlpLogStackBackTraceEx (1);
}


#pragma optimize("y", off) // disable FPO
USHORT
RtlpLogStackBackTraceEx(
    ULONG FramesToSkip
    )
/*++

Routine Description:

    This routine will capture the current stacktrace (skipping the
    present function) and will save it in the global (per process)
    stack trace database. It should be noted that we do not save
    duplicate traces.

Arguments:

    FramesToSkip - no of frames that are not interesting and 
        should be skipped.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    RTL_STACK_TRACE_ENTRY Trace;
    USHORT TraceIndex;
    NTSTATUS Status;
    ULONG Hash;
    PSTACK_TRACE_DATABASE DataBase;

    //
    // Check the context in which we are running.
    //

    DataBase = RtlpStackTraceDataBase;

    if (DataBase == NULL) {
        return 0;
    }

    if (! OKAY_TO_LOCK_DATABASE (DataBase->Lock)) {
        return 0;
    }

    //
    // Capture stack trace. 
    //

    if (RtlpCaptureStackTraceForLogging (&Trace, &Hash, FramesToSkip + 1, FALSE) == FALSE) {
        return 0;
    }
    
    //
    // Add the trace if it is not already there.
    // Return trace index.
    //

    TraceIndex = RtlpLogCapturedStackTrace (&Trace, Hash);

    return TraceIndex;
}


#if defined(NTOS_KERNEL_RUNTIME)
#pragma optimize("y", off) // disable FPO
USHORT
RtlLogUmodeStackBackTrace(
    VOID
    )
/*++

Routine Description:

    This routine will capture the user mode stacktrace and will save 
    it in the global (per system) stack trace database. 
    It should be noted that we do not save duplicate traces.

Arguments:

    None.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    RTL_STACK_TRACE_ENTRY Trace;
    ULONG Hash;

    //
    // No database => nothing to do.
    //

    if (RtlpStackTraceDataBase == NULL) {
        return 0;
    }

    //
    // Capture user mode stack trace. 
    //

    if (RtlpCaptureStackTraceForLogging (&Trace, &Hash, 1, TRUE) == FALSE) {
        return 0;
    }
    
    //
    // Add the trace if it is not already there.
    // Return trace index.
    //

    return RtlpLogCapturedStackTrace (&Trace, Hash);
}
#endif // #if defined(NTOS_KERNEL_RUNTIME)


#pragma optimize("y", off) // disable FPO
LOGICAL
RtlpCaptureStackTraceForLogging (
    PRTL_STACK_TRACE_ENTRY Trace,
    PULONG Hash,
    ULONG FramesToSkip,
    LOGICAL UserModeStackFromKernelMode
    )
{
    if (UserModeStackFromKernelMode == FALSE) {
        
        //
        // Capture stack trace. The try/except was useful
        // in the old days when the function did not validate
        // the stack frame chain. We keep it just to be defensive.
        //

        try {

            Trace->Depth = RtlCaptureStackBackTrace (FramesToSkip + 1,
                                                    MAX_STACK_DEPTH,
                                                    Trace->BackTrace,
                                                    Hash);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {

            Trace->Depth = 0;
        }

        if (Trace->Depth == 0) {

            return FALSE;
        }
        else {

            return TRUE;
        }
    }
    else {

#ifdef NTOS_KERNEL_RUNTIME

        ULONG Index;

        //
        // Avoid weird situations.
        //

        if (KeAreAllApcsDisabled () == TRUE) {
            return FALSE;
        }

        //
        // Capture user mode stack trace and hash value.
        //

        Trace->Depth = (USHORT) RtlWalkFrameChain(Trace->BackTrace,
                                                  MAX_STACK_DEPTH,
                                                  1);
        if (Trace->Depth == 0) {
            
            return FALSE;
        }
        else {

            *Hash = 0;

            for (Index = 0; Index < Trace->Depth; Index += 1) {
                 *Hash += PtrToUlong (Trace->BackTrace[Index]);
            }

            return TRUE;
        }

#else //#ifdef NTOS_KERNEL_RUNTIME

        return FALSE;

#endif // #ifdef NTOS_KERNEL_RUNTIME
    }
}


USHORT
RtlpLogCapturedStackTrace(
    PRTL_STACK_TRACE_ENTRY Trace,
    ULONG Hash
    )
{
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG RequestedSize, DepthSize;
    USHORT ReturnValue;

    DataBase = RtlpStackTraceDataBase;

    //
    // Update statistics counters. Since they are used only for reference and do not
    // control decisions we increment them without protection even if this means we may
    // have numbers slightly out of sync.
    //

    DataBase->NumberOfEntriesLookedUp += 1;

    //
    // Lock the global per-process stack trace database.
    //

    if (RtlpAcquireStackTraceDataBase() == NULL) {

        //
        // Fail the log operation if we cannot acquire the lock.
        // This can happen only if there is a dump in progress or we are in
        // an invalid context (process shutdown (Umode) or DPC routine (Kmode).
        //

        return 0;
    }

    try {

        //
        // We will try to find out if the trace has been saved in the past.
        // We find the right hash chain and then traverse it.
        //

        DepthSize = Trace->Depth * sizeof (Trace->BackTrace[0]);

        pp = &DataBase->Buckets[ Hash % DataBase->NumberOfBuckets ];

        while (p = *pp) {

            //
            // ISSUE: SilviuC: we should use hash values in comparing traces.
            // Comparing first hash values and depth should save us a lot of
            // compares pointer by pointer.
            //

            if (p->Depth == Trace->Depth) {

                if (RtlCompareMemory( &p->BackTrace[ 0 ], &Trace->BackTrace[ 0 ], DepthSize) == DepthSize) {
                    
                    break;
                }
            }

            pp = &p->HashChain;
        }

        if (p == NULL) {

            //
            // If we get here we did not find a similar trace in the database. We need
            // to add it.
            //
            // We got the `*pp' value (address of last chain element) while the 
            // database lock was acquired shared so we need to take into consideration 
            // the case where another thread managed to acquire database exclusively 
            // and add a new trace at the end of the chain. Therefore if `*pp' is no longer
            // null we continue to traverse the chain until we get to the end.
            //

            p = NULL;

            if (*pp != NULL) {

                //
                // Somebody added some traces at the end of the chain while we
                // were trying to convert the lock from shared to exclusive.
                //

                while (p = *pp) {

                    if (p->Depth == Trace->Depth) {

                        if (RtlCompareMemory( &p->BackTrace[ 0 ], &Trace->BackTrace[ 0 ], DepthSize) == DepthSize) {

                            break;
                        }
                    }

                    pp = &p->HashChain;
                }
            }

            if (p == NULL) {
                
                //
                // Nobody added the trace and now `*pp' really points to the end
                // of the chain either because we traversed the rest of the chain
                // or it was at the end anyway.
                //

                RequestedSize = FIELD_OFFSET (RTL_STACK_TRACE_ENTRY, BackTrace) + DepthSize;

                p = RtlpExtendStackTraceDataBase (Trace, RequestedSize);

                if (p != NULL) {

                    //
                    // We added the trace no chain it as the last element.
                    //

                    *pp = p;
                }
            }
            else {

                //
                // Some other thread managed to add the same trace to the database
                // while we were trying to acquire the lock exclusive. `p' has the
                // address to the stack trace entry.
                //
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // We should never get here if the algorithm is correct.
        //

        p = NULL;
    }

    //
    // Release locks and return. At this stage we may return zero (failure)
    // if we did not manage to extend the database with a new trace (e.g. due to
    // out of memory conditions).
    //

    if (p != NULL) {

        p->TraceCount += 1;

        ReturnValue = p->Index;
    }
    else {
        
        ReturnValue = 0;
    }

    RtlpReleaseStackTraceDataBase();

    return ReturnValue;
}


PVOID
RtlpGetStackTraceAddress (
    USHORT Index
    )
{
    if (RtlpStackTraceDataBase == NULL) {
        return NULL;
    }

    if (! (Index > 0 && Index <= RtlpStackTraceDataBase->NumberOfEntriesAdded)) {
        return NULL;
    }

    return (PVOID)(RtlpStackTraceDataBase->EntryIndexArray[-Index]);
}



BOOLEAN
RtlpCaptureStackLimits (
    ULONG_PTR HintAddress,
    PULONG_PTR StartStack,
    PULONG_PTR EndStack)
/*++

Routine Description:

    This routine figures out what are the stack limits for the current thread.
    This is used in other routines that need to grovel the stack for various
    information (e.g. potential return addresses).

    The function is especially tricky in K-mode where the information kept in
    the thread structure about stack limits is not always valid because the
    thread might execute a DPC routine and in this case we use a different stack
    with different limits.

Arguments:

    HintAddress - Address of a local variable or parameter of the caller of the
        function that should be the start of the stack.

    StartStack - start address of the stack (lower value).

    EndStack - end address of the stack (upper value).

Return value:

    False if some weird condition is discovered, like an End lower than a Start.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME

    //
    // Avoid weird conditions. Doing this in an ISR is never a good idea.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return FALSE;
    }

    *StartStack = (ULONG_PTR)(KeGetCurrentThread()->StackLimit);
    *EndStack = (ULONG_PTR)(KeGetCurrentThread()->StackBase);

    if (*StartStack <= HintAddress && HintAddress <= *EndStack) {

        *StartStack = HintAddress;
    }
    else {

#if defined(_WIN64)

        //
        // On Win64 we do not know yet where DPCs are executed.
        //

        return FALSE;
#else
        *EndStack = (ULONG_PTR)(KeGetPcr()->Prcb->DpcStack);
#endif
        *StartStack = *EndStack - KERNEL_STACK_SIZE;

        //
        // Check if this is within the DPC stack for the current
        // processor.
        //

        if (*EndStack && *StartStack <= HintAddress && HintAddress <= *EndStack) {

            *StartStack = HintAddress;
        }
        else {

            //
            // This is not current thread's stack and is not the DPC stack
            // of the current processor. Basically we have no idea on what
            // stack we are running. We need to investigate this. On free
            // builds we try to make the best out of it by using only one
            // page for stack limits.
            //
            // SilviuC: I disabled the code below because it seems under certain 
            // conditions drivers do indeed switch execution to a different stack.
            // This function will need to be improved to deal with this too.
            //
#if 0
            DbgPrint ("RtlpCaptureStackLimits: mysterious stack (prcb @ %p) \n",
                      KeGetPcr()->Prcb);

            DbgBreakPoint ();
#endif

            *StartStack = HintAddress;

            *EndStack = (*StartStack + PAGE_SIZE) & ~((ULONG_PTR)PAGE_SIZE - 1);
        }
    }

#else

    *StartStack = HintAddress;

    *EndStack = (ULONG_PTR)(NtCurrentTeb()->NtTib.StackBase);

#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\str2adda.c ===
//
// Without this define, link errors can occur due to missing _pctype and 
// __mb_cur_max
//
#define _CTYPE_DISABLE_MACROS

#undef UNICODE
#undef _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdlib.h>
#include <tchar.h>

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressA
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressA
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExA
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExA
#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\sertl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sertl.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

Author:

    Jim Kelly       (JimK)     23-Mar-1990
    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine

Revision History:


--*/


#include "ntrtlp.h"
#include <winerror.h>
#ifndef BLDR_KERNEL_RUNTIME
#include <stdio.h>
#include "seopaque.h"
#include "sertlp.h"
#ifdef NTOS_KERNEL_RUNTIME
#include <..\se\sep.h>
#else // NTOS_KERNEL_RUNTIME
#include <..\ntdll\ldrp.h>
#endif // NTOS_KERNEL_RUNTIME

#undef RtlEqualLuid

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualLuid (
    PLUID Luid1,
    PLUID Luid2
    );

NTSTATUS
RtlpConvertAclToAutoInherit (
    IN PACL ParentAcl OPTIONAL,
    IN PACL ChildAcl,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCopyEffectiveAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN WillGenerateInheritAce,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN OUT PVOID *AcePosition,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited OPTIONAL,
    OUT PBOOLEAN EffectiveAceMapped,
    OUT PBOOLEAN AclOverflowed
    );

typedef enum {
     CopyInheritedAces,
     CopyNonInheritedAces,
     CopyAllAces } ACE_TYPE_TO_COPY;

NTSTATUS
RtlpCopyAces(
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACE_TYPE_TO_COPY AceTypeToCopy,
    IN UCHAR AceFlagsToReset,
    IN BOOLEAN MapSids,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN RetainInheritedAceBit,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl
    );

NTSTATUS
RtlpGenerateInheritedAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PULONG NewAceExtraLength,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpGenerateInheritAcl(
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpInheritAcl2 (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl2 (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCompareAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid,
    IN PSID GroupSid
    );

BOOLEAN
RtlpCompareKnownObjectAces(
    IN PKNOWN_OBJECT_ACE InheritedAce,
    IN PKNOWN_OBJECT_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpCompareKnownAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpIsDuplicateAce(
    IN PACL Acl,
    IN PKNOWN_ACE NewAce
    );

BOOLEAN
RtlpGuidPresentInGuidList(
    IN GUID *InheritedObjectType,
    IN GUID **pNewObjectType,
    IN ULONG GuidCount
    );

NTSTATUS
RtlpCreateServerAcl(
    IN PACL Acl,
    IN BOOLEAN AclUntrusted,
    IN PSID ServerSid,
    OUT PACL *ServerAcl,
    OUT BOOLEAN *ServerAclAllocated
    );

NTSTATUS
RtlpGetDefaultsSubjectContext(
    HANDLE ClientToken,
    OUT PTOKEN_OWNER *OwnerInfo,
    OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
    OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
    OUT PTOKEN_OWNER *ServerOwner,
    OUT PTOKEN_PRIMARY_GROUP *ServerGroup
    );

BOOLEAN RtlpValidateSDOffsetAndSize (
    IN ULONG   Offset,
    IN ULONG   Length,
    IN ULONG   MinLength,
    OUT PULONG MaxLength
    );

BOOLEAN
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlRunEncodeUnicodeString)
#pragma alloc_text(PAGE,RtlRunDecodeUnicodeString)
#pragma alloc_text(PAGE,RtlEraseUnicodeString)
#pragma alloc_text(PAGE,RtlAdjustPrivilege)
#pragma alloc_text(PAGE,RtlValidSid)
#pragma alloc_text(PAGE,RtlEqualSid)
#pragma alloc_text(PAGE,RtlEqualPrefixSid)
#pragma alloc_text(PAGE,RtlLengthRequiredSid)
#pragma alloc_text(PAGE,RtlInitializeSid)
#pragma alloc_text(PAGE,RtlIdentifierAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthorityCountSid)
#pragma alloc_text(PAGE,RtlLengthSid)
#pragma alloc_text(PAGE,RtlCopySid)
#pragma alloc_text(PAGE,RtlCopySidAndAttributesArray)
#pragma alloc_text(PAGE,RtlLengthSidAsUnicodeString)
#pragma alloc_text(PAGE,RtlConvertSidToUnicodeString)
#pragma alloc_text(PAGE,RtlEqualLuid)
#pragma alloc_text(PAGE,RtlCopyLuid)
#pragma alloc_text(PAGE,RtlCopyLuidAndAttributesArray)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptor)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptorRelative)
#pragma alloc_text(PAGE,RtlValidSecurityDescriptor)
#pragma alloc_text(PAGE,RtlLengthSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetAttributesSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlAreAllAccessesGranted)
#pragma alloc_text(PAGE,RtlAreAnyAccessesGranted)
#pragma alloc_text(PAGE,RtlMapGenericMask)
#pragma alloc_text(PAGE,RtlImpersonateSelf)
#pragma alloc_text(PAGE,RtlpApplyAclToObject)
#pragma alloc_text(PAGE,RtlpCopyEffectiveAce)
#pragma alloc_text(PAGE,RtlpCopyAces)
#pragma alloc_text(PAGE,RtlpGuidPresentInGuidList)
#pragma alloc_text(PAGE,RtlpInheritAcl2)
#pragma alloc_text(PAGE,RtlpInheritAcl)
#pragma alloc_text(PAGE,RtlpGenerateInheritedAce)
#pragma alloc_text(PAGE,RtlpGenerateInheritAcl)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl2)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl)
#pragma alloc_text(PAGE,RtlpConvertToAutoInheritSecurityObject)
#pragma alloc_text(PAGE,RtlpCompareAces)
#pragma alloc_text(PAGE,RtlpCompareKnownAces)
#pragma alloc_text(PAGE,RtlpCompareKnownObjectAces)
#pragma alloc_text(PAGE,RtlpConvertAclToAutoInherit)
#pragma alloc_text(PAGE,RtlpIsDuplicateAce)
#pragma alloc_text(PAGE,RtlpCreateServerAcl)
#pragma alloc_text(PAGE,RtlpNewSecurityObject)
#pragma alloc_text(PAGE,RtlpSetSecurityObject)
#pragma alloc_text(PAGE,RtlpValidateSDOffsetAndSize)
#pragma alloc_text(PAGE,RtlValidRelativeSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSecurityDescriptorRMControl)
#pragma alloc_text(PAGE,RtlSetSecurityDescriptorRMControl)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Local Macros and Symbols                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define CREATOR_SID_SIZE 12

#define max(a,b)            (((a) > (b)) ? (a) : (b))

//
// Define an array mapping all ACE types to their base type.
//
// For instance, all allowed ACE types are similar.  As are all denied ACE types.
//

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif

const UCHAR RtlBaseAceType[] = {
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_ACE_TYPE (0x1)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_ACE_TYPE (0x2)
    SYSTEM_ALARM_ACE_TYPE,      // SYSTEM_ALARM_ACE_TYPE (0x3)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    SYSTEM_ALARM_ACE_TYPE       // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

//
// Define an array defining whether an ACE is a system ACE
//

const UCHAR RtlIsSystemAceType[] = {
    FALSE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    FALSE,    // ACCESS_DENIED_ACE_TYPE (0x1)
    TRUE,     // SYSTEM_AUDIT_ACE_TYPE (0x2)
    TRUE,     // SYSTEM_ALARM_ACE_TYPE (0x3)
    FALSE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    FALSE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    FALSE,    // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    TRUE,     // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    TRUE      // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

#if DBG
BOOLEAN RtlpVerboseConvert = FALSE;
#endif // DBG

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Null DACL assertions                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if DBG
#define ASSERT_ON_NULL_DACL 1
#endif

#ifdef ASSERT_ON_NULL_DACL
ULONG RtlpAssertOnNullDacls;
#endif // ASSERT_ON_NULL_DACL



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    )

/*++

Routine Description:

    This function performs a trivial XOR run-encoding of a string.
    The purpose of this run-encoding is to change the character values
    to appear somewhat random and typically not printable.  This is
    useful for transforming passwords that you don't want to be easily
    distinguishable by visually scanning a paging file or memory dump.


Arguments:

    Seed - Points to a seed value to use in the encoding.  If the
        pointed to value is zero, then this routine will assign
        a value.

    String - The string to encode.  This string may be decode
        by passing it and the seed value to RtlRunDecodeUnicodeString().


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/
{

    LARGE_INTEGER Time;
    PUCHAR        LocalSeed;
    NTSTATUS      Status;
    ULONG         i;
    PSTRING       S;


    RTL_PAGED_CODE();

    //
    // Typecast so we can work on bytes rather than WCHARs
    //

    S = (PSTRING)((PVOID)String);

    //
    // If a seed wasn't passed, use the 2nd byte of current time.
    // This byte seems to be sufficiently random (by observation).
    //

    if ((*Seed) == 0) {
        Status = NtQuerySystemTime ( &Time );
        ASSERT(NT_SUCCESS(Status));

        LocalSeed = (PUCHAR)((PVOID)&Time);

        i = 1;

        (*Seed) = LocalSeed[ i ];

        //
        // Occasionally, this byte could be zero.  That would cause the
        // string to become un-decodable, since 0 is the magic value that
        // causes us to re-gen the seed.  This loop makes sure that we
        // never end up with a zero byte (unless time is zero, as well).
        //

        while ( ((*Seed) == 0) && ( i < sizeof( Time ) ) )
        {
            (*Seed) |= LocalSeed[ i++ ] ;
        }

        if ( (*Seed) == 0 )
        {
            (*Seed) = 1;
        }
    }

    //
    // Transform the initial byte.
    // The funny constant just keeps the first byte from propagating
    // into the second byte in the next step.  Without a funny constant
    // this would happen for many languages (which typically have every
    // other byte zero.
    //
    //

    if (S->Length >= 1) {
        S->Buffer[0] ^= ((*Seed) | 0X43);
    }


    //
    // Now transform the rest of the string
    //

    for (i=1; i<S->Length; i++) {

        //
        //  There are export issues that cause us to want to
        //  keep this algorithm simple.  Please don't change it
        //  without checking with JimK first.  Thanks.
        //

        //
        // In order to be compatible with zero terminated unicode strings,
        //  this algorithm is designed to not produce a wide character of
        //  zero as long a the seed is not zero.
        //

        //
        // Simple running XOR with the previous byte and the
        // seed value.
        //

        S->Buffer[i] ^= (S->Buffer[i-1]^(*Seed));

    }


    return;

}


VOID
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    )
/*++

Routine Description:

    This function performs the inverse of the function performed
    by RtlRunEncodeUnicodeString().  Please see RtlRunEncodeUnicodeString()
    for details.


Arguments:

    Seed - The seed value to use in RtlRunEncodeUnicodeString().

    String - The string to reveal.


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/

{

    ULONG
        i;

    PSTRING
        S;

    RTL_PAGED_CODE();

    //
    // Typecast so we can work on bytes rather than WCHARs
    //

    S = (PSTRING)((PVOID)String);


    //
    // Transform the end of the string
    //

    for (i=S->Length; i>1; i--) {

        //
        // a simple running XOR with the previous byte and the
        // seed value.
        //

        S->Buffer[i-1] ^= (S->Buffer[i-2]^Seed);

    }

    //
    // Finally, transform the initial byte
    //

    if (S->Length >= 1) {
        S->Buffer[0] ^= (Seed | 0X43);
    }


    return;
}



VOID
RtlEraseUnicodeString(
    PUNICODE_STRING String
    )
/*++

Routine Description:

    This function scrubs the passed string by over-writing all
    characters in the string.  The entire string (i.e., MaximumLength)
    is erased, not just the current length.


Argumen ts:

    String - The string to be erased.


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/

{
    RTL_PAGED_CODE();

    if ((String->Buffer == NULL) || (String->MaximumLength == 0)) {
        return;
    }

    RtlZeroMemory( (PVOID)String->Buffer, (ULONG)String->MaximumLength );

    String->Length = 0;

    return;
}



NTSTATUS
RtlAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This procedure enables or disables a privilege process-wide.

Arguments:

    Privilege - The lower 32-bits of the privilege ID to be enabled or
        disabled.  The upper 32-bits is assumed to be zero.

    Enable - A boolean indicating whether the privilege is to be enabled
        or disabled.  TRUE indicates the privilege is to be enabled.
        FALSE indicates the privilege is to be disabled.

    Client - A boolean indicating whether the privilege should be adjusted
        in a client token or the process's own token.   TRUE indicates
        the client's token should be used (and an error returned if there
        is no client token).  FALSE indicates the process's token should
        be used.

    WasEnabled - points to a boolean to receive an indication of whether
        the privilege was previously enabled or disabled.  TRUE indicates
        the privilege was previously enabled.  FALSE indicates the privilege
        was previoulsy disabled.  This value is useful for returning the
        privilege to its original state after using it.


Return Value:

    STATUS_SUCCESS - The privilege has been sucessfully enabled or disabled.

    STATUS_PRIVILEGE_NOT_HELD - The privilege is not held by the specified context.

    Other status values as may be returned by:

            NtOpenProcessToken()
            NtAdjustPrivilegesToken()


--*/

{
    NTSTATUS
        Status,
        TmpStatus;

    HANDLE
        Token;

    LUID
        LuidPrivilege;

    PTOKEN_PRIVILEGES
        NewPrivileges,
        OldPrivileges;

    ULONG
        Length;

    UCHAR
        Buffer1[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))],
        Buffer2[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))];


    RTL_PAGED_CODE();

    NewPrivileges = (PTOKEN_PRIVILEGES)Buffer1;
    OldPrivileges = (PTOKEN_PRIVILEGES)Buffer2;

    //
    // Open the appropriate token...
    //

    if (Client == TRUE) {
        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     FALSE,
                     &Token
                     );
    } else {

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     &Token
                    );
    }

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);


    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;



    //
    // Adjust the privilege
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                     // TokenHandle
                 FALSE,                     // DisableAllPrivileges
                 NewPrivileges,             // NewPrivileges
                 sizeof(Buffer1),           // BufferLength
                 OldPrivileges,             // PreviousState (OPTIONAL)
                 &Length                    // ReturnLength
                 );


    TmpStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust the one privilege.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (NT_SUCCESS(Status)) {

        //
        // If there are no privileges in the previous state, there were
        // no changes made. The previous state of the privilege
        // is whatever we tried to change it to.
        //

        if (OldPrivileges->PrivilegeCount == 0) {

            (*WasEnabled) = Enable;

        } else {

            (*WasEnabled) =
                (OldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                ? TRUE : FALSE;
        }
    }

    return(Status);
}


BOOLEAN
RtlValidSid (
    IN PSID Sid
    )

/*++

Routine Description:

    This procedure validates an SID's structure.

Arguments:

    Sid - Pointer to the SID structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Sid is valid.

--*/

{
    PISID Isid = (PISID) Sid;
    RTL_PAGED_CODE();
    //
    // Make sure revision is SID_REVISION and sub authority count is not
    // greater than maximum number of allowed sub-authorities.
    //

    try {

        if ( Isid != NULL && (Isid->Revision & 0x0f) == SID_REVISION) {
            if (Isid->SubAuthorityCount <= SID_MAX_SUB_AUTHORITIES) {

                //
                // Verify the memory actually contains the last subauthority
                //
#ifndef NTOS_KERNEL_RUNTIME
#define ProbeAndReadUlongUM(Address) \
        (*(volatile ULONG *)(Address))

                if (Isid->SubAuthorityCount > 0) {
                    ProbeAndReadUlongUM(
                        &Isid->SubAuthority[Isid->SubAuthorityCount-1]
                        );
                }
#endif // !NTOS_KERNEL_RUNTIME
                return TRUE;
          }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return FALSE;

}



BOOLEAN
RtlEqualSid (
    IN PSID Sid1,
    IN PSID Sid2
    )

/*++

Routine Description:

    This procedure tests two SID values for equality.

Arguments:

    Sid1, Sid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the value of Sid1 is equal to Sid2, and FALSE
        otherwise.

--*/

{
   ULONG SidLength;

   C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid1)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
   C_ASSERT (sizeof (((SID *)Sid1)->Revision) + sizeof (((SID *)Sid1)->SubAuthorityCount) == sizeof (USHORT));

   RTL_PAGED_CODE();

   //
   // Make sure they are the same revision. To make this routine faster we make the assumption that
   // the revision and subauthority fields are adjacent.
   //

   if (*(USHORT *)&((SID *)Sid1)->Revision == *(USHORT *)&((SID *)Sid2)->Revision) {
       SidLength = SeLengthSid (Sid1);
       return( (BOOLEAN)RtlEqualMemory( Sid1, Sid2, SidLength) );
   }

   return( FALSE );

}



BOOLEAN
RtlEqualPrefixSid (
    IN PSID Sid1,
    IN PSID Sid2
    )

/*++

Routine Description:

    This procedure tests two SID prefix values for equality.

    An SID prefix is the entire SID except for the last sub-authority
    value.

Arguments:

    Sid1, Sid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the prefix value of Sid1 is equal to Sid2, and FALSE
        otherwise.

--*/


{
    LONG Index;

    //
    // Typecast to the opaque SID structures.
    //

    SID *ISid1 = Sid1;
    SID *ISid2 = Sid2;

    RTL_PAGED_CODE();

    //
    // Make sure they are the same revision
    //

    if (ISid1->Revision == ISid2->Revision ) {

        //
        // Compare IdentifierAuthority values
        //

        if ( (ISid1->IdentifierAuthority.Value[0] ==
              ISid2->IdentifierAuthority.Value[0])  &&
             (ISid1->IdentifierAuthority.Value[1]==
              ISid2->IdentifierAuthority.Value[1])  &&
             (ISid1->IdentifierAuthority.Value[2] ==
              ISid2->IdentifierAuthority.Value[2])  &&
             (ISid1->IdentifierAuthority.Value[3] ==
              ISid2->IdentifierAuthority.Value[3])  &&
             (ISid1->IdentifierAuthority.Value[4] ==
              ISid2->IdentifierAuthority.Value[4])  &&
             (ISid1->IdentifierAuthority.Value[5] ==
              ISid2->IdentifierAuthority.Value[5])
            ) {

            //
            // Compare SubAuthorityCount values
            //

            if (ISid1->SubAuthorityCount == ISid2->SubAuthorityCount) {

                if (ISid1->SubAuthorityCount == 0) {
                    return TRUE;
                }

                Index = 0;
                while (Index < (ISid1->SubAuthorityCount - 1)) {
                    if ((ISid1->SubAuthority[Index]) != (ISid2->SubAuthority[Index])) {

                        //
                        // Found some SubAuthority values that weren't equal.
                        //

                        return FALSE;
                    }
                    Index += 1;
                }

                //
                // All SubAuthority values are equal.
                //

                return TRUE;
            }
        }
    }

    //
    // Either the Revision, SubAuthorityCount, or IdentifierAuthority values
    // weren't equal.
    //

    return FALSE;
}



ULONG
RtlLengthRequiredSid (
    IN ULONG SubAuthorityCount
    )

/*++

Routine Description:

    This routine returns the length, in bytes, required to store an SID
    with the specified number of Sub-Authorities.

Arguments:

    SubAuthorityCount - The number of sub-authorities to be stored in the SID.

Return Value:

    ULONG - The length, in bytes, required to store the SID.


--*/

{
    RTL_PAGED_CODE();

    return (8L + (4 * SubAuthorityCount));

}

#ifndef NTOS_KERNEL_RUNTIME

NTSTATUS
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    )

/*++

Routine Description:

    This function allocates and initializes a sid with the specified
    number of sub-authorities (up to 8).  A sid allocated with this
    routine must be freed using RtlFreeSid().

    THIS ROUTINE IS CURRENTLY NOT CALLABLE FROM KERNEL MODE.

Arguments:

    IdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    SubAuthorityCount - The number of sub-authorities to place in the SID.
        This also identifies how many of the SubAuthorityN parameters
        have meaningful values.  This must contain a value from 0 through
        8.

    SubAuthority0-7 - Provides the corresponding sub-authority value to
        place in the SID.  For example, a SubAuthorityCount value of 3
        indicates that SubAuthority0, SubAuthority1, and SubAuthority0
        have meaningful values and the rest are to be ignored.

    Sid - Receives a pointer to the SID data structure to initialize.

Return Value:

    STATUS_SUCCESS - The SID has been allocated and initialized.

    STATUS_NO_MEMORY - The attempt to allocate memory for the SID
        failed.

    STATUS_INVALID_SID - The number of sub-authorities specified did
        not fall in the valid range for this api (0 through 8).


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    if ( SubAuthorityCount > 8 ) {
        return( STATUS_INVALID_SID );
    }

    ISid = RtlAllocateHeap( RtlProcessHeap(), 0,
                            RtlLengthRequiredSid(SubAuthorityCount)
                            );
    if (ISid == NULL) {
        return(STATUS_NO_MEMORY);
    }

    ISid->SubAuthorityCount = (UCHAR)SubAuthorityCount;
    ISid->Revision = 1;
    ISid->IdentifierAuthority = *IdentifierAuthority;

    switch (SubAuthorityCount) {

    case 8:
        ISid->SubAuthority[7] = SubAuthority7;
    case 7:
        ISid->SubAuthority[6] = SubAuthority6;
    case 6:
        ISid->SubAuthority[5] = SubAuthority5;
    case 5:
        ISid->SubAuthority[4] = SubAuthority4;
    case 4:
        ISid->SubAuthority[3] = SubAuthority3;
    case 3:
        ISid->SubAuthority[2] = SubAuthority2;
    case 2:
        ISid->SubAuthority[1] = SubAuthority1;
    case 1:
        ISid->SubAuthority[0] = SubAuthority0;
    case 0:
        ;
    }

    (*Sid) = ISid;
    return( STATUS_SUCCESS );

}
#endif // NTOS_KERNEL_RUNTIME



NTSTATUS
RtlInitializeSid(
    IN PSID Sid,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount
    )
/*++

Routine Description:

    This function initializes an SID data structure.  It does not, however,
    set the sub-authority values.  This must be done separately.

Arguments:

    Sid - Pointer to the SID data structure to initialize.

    IdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    SubAuthorityCount - The number of sub-authorities that will be placed in
        the SID (a separate action).

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    if ( SubAuthorityCount > SID_MAX_SUB_AUTHORITIES ) {
        return( STATUS_INVALID_PARAMETER );
    }

    ISid->SubAuthorityCount = (UCHAR)SubAuthorityCount;
    ISid->Revision = 1;
    ISid->IdentifierAuthority = *IdentifierAuthority;

    return( STATUS_SUCCESS );

}

#ifndef NTOS_KERNEL_RUNTIME

PVOID
RtlFreeSid(
    IN PSID Sid
    )

/*++

Routine Description:

    This function is used to free a SID previously allocated using
    RtlAllocateAndInitializeSid().

    THIS ROUTINE IS CURRENTLY NOT CALLABLE FROM KERNEL MODE.

Arguments:

    Sid - Pointer to the SID to free.

Return Value:

    None.


--*/
{
    RTL_PAGED_CODE();

    if (RtlFreeHeap( RtlProcessHeap(), 0, Sid ))
        return NULL;
    else
        return Sid;
}
#endif // NTOS_KERNEL_RUNTIME


PSID_IDENTIFIER_AUTHORITY
RtlIdentifierAuthoritySid(
    IN PSID Sid
    )
/*++

Routine Description:

    This function returns the address of an SID's IdentifierAuthority field.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->IdentifierAuthority);

}

PULONG
RtlSubAuthoritySid(
    IN PSID Sid,
    IN ULONG SubAuthority
    )
/*++

Routine Description:

    This function returns the address of a sub-authority array element of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

    SubAuthority - An index indicating which sub-authority is being specified.
        This value is not compared against the number of sub-authorities in the
        SID for validity.

Return Value:


--*/
{
    RTL_PAGED_CODE();

    return RtlpSubAuthoritySid( Sid, SubAuthority );
}

PUCHAR
RtlSubAuthorityCountSid(
    IN PSID Sid
    )
/*++

Routine Description:

    This function returns the address of the sub-authority count field of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->SubAuthorityCount);

}

ULONG
RtlLengthSid (
    IN PSID Sid
    )

/*++

Routine Description:

    This routine returns the length, in bytes, of a structurally valid SID.

Arguments:

    Sid - Points to the SID whose length is to be returned.  The
        SID's structure is assumed to be valid.

Return Value:

    ULONG - The length, in bytes, of the SID.


--*/

{
    RTL_PAGED_CODE();

    return SeLengthSid(Sid);
}


NTSTATUS
RtlCopySid (
    IN ULONG DestinationSidLength,
    OUT PSID DestinationSid,
    IN PSID SourceSid
    )

/*++

Routine Description:

    This routine copies the value of the source SID to the destination
    SID.

Arguments:

    DestinationSidLength - Indicates the length, in bytes, of the
        destination SID buffer.

    DestinationSid - Pointer to a buffer to receive a copy of the
        source Sid value.

    SourceSid - Supplies the Sid value to be copied.

Return Value:

    STATUS_SUCCESS - Indicates the SID was successfully copied.

    STATUS_BUFFER_TOO_SMALL - Indicates the target buffer wasn't
        large enough to receive a copy of the SID.


--*/

{
    ULONG SidLength = SeLengthSid(SourceSid);

    RTL_PAGED_CODE();

    if (SidLength > DestinationSidLength) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Buffer is large enough
    //

    RtlMoveMemory( DestinationSid, SourceSid, SidLength );

    return STATUS_SUCCESS;

}


NTSTATUS
RtlCopySidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PSID_AND_ATTRIBUTES Source,
    IN ULONG TargetSidBufferSize,
    OUT PSID_AND_ATTRIBUTES TargetArrayElement,
    OUT PSID TargetSid,
    OUT PSID *NextTargetSid,
    OUT PULONG RemainingTargetSidBufferSize
    )

/*++

Routine Description:

    This routine copies the value of the source SID_AND_ATTRIBUTES array
    to the target.  The actual SID values are placed according to a separate
    parameter.  This allows multiple arrays to be merged using this service
    to copy each.

Arguments:

    ArrayLength - Number of elements in the source array to copy.

    Source - Pointer to the source array.

    TargetSidBufferSize - Indicates the length, in bytes, of the buffer
        to receive the actual SID values.  If this value is less than
        the actual amount needed, then STATUS_BUFFER_TOO_SMALL is returned.

    TargetArrayElement - Indicates where the array elements are to be
        copied to (but not the SID values themselves).

    TargetSid - Indicates where the target SID values s are to be copied.  This
        is assumed to be ULONG aligned.  Each SID value will be copied
        into this buffer.  Each SID will be ULONG aligned.

    NextTargetSid - On completion, will be set to point to the ULONG
        aligned address following the last SID copied.

    RemainingTargetSidBufferSize - On completion, receives an indicatation
        of how much of the SID buffer is still unused.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_BUFFER_TOO_SMALL - Indicates the buffer to receive the SID
        values wasn't large enough.



--*/

{

    ULONG Index = 0;
    PSID NextSid = TargetSid;
    ULONG NextSidLength;
    ULONG AlignedSidLength;
    ULONG RemainingLength = TargetSidBufferSize;

    RTL_PAGED_CODE();

    while (Index < ArrayLength) {

        NextSidLength = SeLengthSid( Source[Index].Sid );
        AlignedSidLength = PtrToUlong(LongAlign(NextSidLength));

        if (NextSidLength > RemainingLength) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        RemainingLength -= AlignedSidLength;

        TargetArrayElement[Index].Sid = NextSid;
        TargetArrayElement[Index].Attributes = Source[Index].Attributes;

        RtlCopySid( NextSidLength, NextSid, Source[Index].Sid );

        NextSid = (PSID)((PCHAR)NextSid + AlignedSidLength);

        Index += 1;

    } //end_while

    (*NextTargetSid) = NextSid;
    (*RemainingTargetSidBufferSize) = RemainingLength;

    return STATUS_SUCCESS;

}



NTSTATUS
RtlLengthSidAsUnicodeString(
    PSID Sid,
    PULONG StringLength
    )

/*++

Routine Description:


    This function returns the maximum length of the string needed
    to represent the SID supplied.  The actual string may be shorter,
    but this is intended to be a quick calculation.

Arguments:


    Sid - Supplies the SID that is to be converted to unicode.

    StringLength - Receives the max length required in bytes.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

--*/

{
    ULONG   i ;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure


    RTL_PAGED_CODE();

    if ( RtlValidSid( Sid ) != TRUE)
    {
        return(STATUS_INVALID_SID);
    }

    //
    // if the SID's IA value has 5 or 6 significant bytes, the
    // representation will be in hex, with a 0x preceding.  Otherwise
    // it will be in decimal, with at most 10 characters.
    //

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)  )
    {
        i = 14 ;    // 0x665544332211

    }
    else
    {
        i = 10 ;    // 4294967295 is the max ulong, at 10 chars
    }

    i += 4 ;        // room for the S-1-

    //
    // for each sub authority, it is a max of 10 chars (for a ulong),
    // plus the - separator
    //

    i += 11 * iSid->SubAuthorityCount ;

    *StringLength = i * sizeof( WCHAR );

    return STATUS_SUCCESS ;

}




NTSTATUS
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    NTSTATUS Status;
    WCHAR UniBuffer[ 256 ];
    PWSTR Offset ;
    UNICODE_STRING LocalString ;

    UCHAR   i;
    ULONG   Tmp;
    LARGE_INTEGER Auth ;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure


    RTL_PAGED_CODE();

    if (RtlValidSid( Sid ) != TRUE) {
        return(STATUS_INVALID_SID);
    }

    if ( iSid->Revision != SID_REVISION )
    {
        return STATUS_INVALID_SID ;
    }

    wcscpy( UniBuffer, L"S-1-" );

    Offset = &UniBuffer[ 4 ];

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){

        //
        // Ugly hex dump.
        //
	
        wcscat( UniBuffer, L"0x" );
	
        Offset = &UniBuffer[ 6 ];

        Auth.HighPart = (LONG) (iSid->IdentifierAuthority.Value[ 0 ] << 8) +
                        (LONG) iSid->IdentifierAuthority.Value[ 1 ] ;

        Auth.LowPart = (ULONG)iSid->IdentifierAuthority.Value[5]          +
                       (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlLargeIntegerToUnicode(
                        &Auth,
                        16,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );


    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlIntegerToUnicode(
                        Tmp,
                        10,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {

        while ( *Offset && ( Offset < &UniBuffer[ 255 ] ) )
        {
            Offset++ ;
        }

        *Offset++ = L'-' ;

        Status = RtlIntegerToUnicode(
                        iSid->SubAuthority[ i ],
                        10,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }
    }

    if ( AllocateDestinationString )
    {
        if ( RtlCreateUnicodeString( UnicodeString,
                                         UniBuffer ) )
        {
            Status = STATUS_SUCCESS ;
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

    }
    else
    {

        while ( *Offset && ( Offset < &UniBuffer[ 255 ] ) )
        {
            Offset++ ;
        }

        Tmp = (ULONG) (Offset - UniBuffer) * sizeof( WCHAR );

        if ( Tmp < UnicodeString->MaximumLength )
        {
            LocalString.Length = (USHORT) Tmp ;
            LocalString.MaximumLength = LocalString.Length + sizeof( WCHAR );
            LocalString.Buffer = UniBuffer ;

            RtlCopyUnicodeString(
                        UnicodeString,
                        &LocalString );

            Status = STATUS_SUCCESS ;
        }
        else
        {
            Status = STATUS_BUFFER_OVERFLOW ;
        }

    }

    return(Status);
}




BOOLEAN
RtlEqualLuid (
    IN PLUID Luid1,
    IN PLUID Luid2
    )

/*++

Routine Description:

    This procedure test two LUID values for equality.

    This routine is here for backwards compatibility only. New code
    should use the macro.

Arguments:

    Luid1, Luid2 - Supply pointers to the two LUID values to compare.

Return Value:

    BOOLEAN - TRUE if the value of Luid1 is equal to Luid2, and FALSE
        otherwise.


--*/

{
    LUID UNALIGNED * TempLuid1;
    LUID UNALIGNED * TempLuid2;

    RTL_PAGED_CODE();

    return((Luid1->HighPart == Luid2->HighPart) &&
           (Luid1->LowPart  == Luid2->LowPart));

}


VOID
RtlCopyLuid (
    OUT PLUID DestinationLuid,
    IN PLUID SourceLuid
    )

/*++

Routine Description:

    This routine copies the value of the source LUID to the
    destination LUID.

Arguments:

    DestinationLuid - Receives a copy of the source Luid value.

    SourceLuid - Supplies the Luid value to be copied.  This LUID is
                 assumed to be structurally valid.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    (*DestinationLuid) = (*SourceLuid);
    return;
}

VOID
RtlCopyLuidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PLUID_AND_ATTRIBUTES Source,
    OUT PLUID_AND_ATTRIBUTES Target
    )

/*++

Routine Description:

    This routine copies the value of the source LUID_AND_ATTRIBUTES array
    to the target.

Arguments:

    ArrayLength - Number of elements in the source array to copy.

    Source - The source array.

    Target - Indicates where the array elements are to be copied to.


Return Value:

    None.


--*/

{

    ULONG Index = 0;

    RTL_PAGED_CODE();

    while (Index < ArrayLength) {

        Target[Index] = Source[Index];

        Index += 1;

    } //end_while


    return;

}

NTSTATUS
RtlCreateSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Revision
    )

/*++

Routine Description:

    This procedure initializes a new "absolute format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    SecurityDescriptor - Supplies the security descriptor to
        initialize.

    Revision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision level provided
        is not supported by this routine.

--*/

{
    RTL_PAGED_CODE();

    //
    // Check the requested revision
    //

    if (Revision == SECURITY_DESCRIPTOR_REVISION) {

        //
        // Typecast to the opaque SECURITY_DESCRIPTOR structure.
        //

        SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

        RtlZeroMemory( ISecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

        ISecurityDescriptor->Revision = SECURITY_DESCRIPTOR_REVISION;

        return STATUS_SUCCESS;
    }

    return STATUS_UNKNOWN_REVISION;
}


NTSTATUS
RtlCreateSecurityDescriptorRelative (
    IN PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    IN ULONG Revision
    )

/*++

Routine Description:

    This procedure initializes a new "relative format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    SecurityDescriptor - Supplies the security descriptor to
        initialize.

    Revision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision level provided
        is not supported by this routine.

Note:
    Warning, this code assume the caller allocated a relative security
    descriptor rather than a relative one.  Absolute is larger on systems
    with 64-bit pointers.

--*/

{
    RTL_PAGED_CODE();

    //
    // Check the requested revision
    //

    if (Revision == SECURITY_DESCRIPTOR_REVISION) {

        //
        // Typecast to the opaque SECURITY_DESCRIPTOR structure.
        //

        RtlZeroMemory( SecurityDescriptor, sizeof(SECURITY_DESCRIPTOR_RELATIVE));

        SecurityDescriptor->Revision = SECURITY_DESCRIPTOR_REVISION;

        return STATUS_SUCCESS;
    }

    return STATUS_UNKNOWN_REVISION;
}


BOOLEAN
RtlValidSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure.  This
    involves validating the revision levels of each component of the
    security descriptor.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.

Return Value:

    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.


--*/

{
    PSID Owner;
    PSID Group;
    PACL Dacl;
    PACL Sacl;

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    try {

        //
        // known revision ?
        //

        if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
            return FALSE;
        }


        //
        // Validate each element contained in the security descriptor
        //

        Owner = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );

        if (Owner != NULL) {
            if (!RtlValidSid( Owner )) {
                return FALSE;
            }
        }

        Group = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );

        if (Group != NULL) {
            if (!RtlValidSid( Group )) {
                return FALSE;
            }
        }

        Dacl = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );
        if (Dacl != NULL ) {

            if (!RtlValidAcl( Dacl )) {
                return FALSE;
            }
        }

        Sacl = RtlpSaclAddrSecurityDescriptor( ISecurityDescriptor );
        if ( Sacl != NULL ) {
            if (!RtlValidAcl( Sacl )) {
                return FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    //
    // All components are valid
    //

    return TRUE;


}


ULONG
RtlLengthSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine returns the length, in bytes, necessary to capture a
    structurally valid SECURITY_DESCRIPTOR.  The length includes the length
    of all associated data structures (like SIDs and ACLs).  The length also
    takes into account the alignment requirements of each component.

    The minimum length of a security descriptor (one which has no associated
    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.


Arguments:

    SecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose
        length is to be returned.  The SECURITY_DESCRIPTOR's
        structure is assumed to be valid.

Return Value:

    ULONG - The length, in bytes, of the SECURITY_DESCRIPTOR.


--*/

{
    ULONG sum;
    PVOID Temp;


    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = (SECURITY_DESCRIPTOR *)SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // The length is the sum of the following:
    //
    //       SECURITY_DESCRIPTOR_MIN_LENGTH (or sizeof(SECURITY_DESCRIPTOR))
    //       length of Owner SID (if present)
    //       length of Group SID (if present)
    //       length of Discretionary ACL (if present and non-null)
    //       length of System ACL (if present and non-null)
    //

    sum = ISecurityDescriptor->Control & SE_SELF_RELATIVE ?
                            sizeof(SECURITY_DESCRIPTOR_RELATIVE) :
                            sizeof(SECURITY_DESCRIPTOR);

    //
    // Add in length of Owner SID
    //

    Temp = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);
    if (Temp != NULL) {
        sum += LongAlignSize(SeLengthSid(Temp));
    }

    //
    // Add in length of Group SID
    //

    Temp = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);
    if (Temp != NULL) {
        sum += LongAlignSize(SeLengthSid(Temp));
    }

    //
    // Add in used length of Discretionary ACL
    //

    Temp = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);
    if ( Temp != NULL ) {

        sum += LongAlignSize(((PACL) Temp)->AclSize );
    }

    //
    // Add in used length of System Acl
    //

    Temp = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);
    if ( Temp != NULL ) {

        sum += LongAlignSize(((PACL) Temp)->AclSize );
    }

    return sum;
}


NTSTATUS
RtlSetAttributesSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )
{
    RTL_PAGED_CODE();

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;

    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }

    // This is a worthless API.  There is no way to turn any of the bits off.
    // Use the newer RtlSetControlSecurityDescriptor.
    Control &= SE_VALID_CONTROL_BITS;
    return RtlSetControlSecurityDescriptor ( SecurityDescriptor, Control, Control );
}



NTSTATUS
RtlGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    RTL_PAGED_CODE();

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;


    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }


    *Control = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Control;

    return STATUS_SUCCESS;

}

NTSTATUS
RtlSetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    //
    // Ensure the caller passed valid bits.
    //

    if ( (ControlBitsOfInterest & ~SE_VALID_CONTROL_BITS) != 0 ||
         (ControlBitsToSet & ~ControlBitsOfInterest) != 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control &= ~ControlBitsOfInterest;
    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control |= ControlBitsToSet;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlSetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN DaclPresent,
    IN PACL Dacl OPTIONAL,
    IN BOOLEAN DaclDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the discretionary ACL information of an absolute
    format security descriptor.  If there is already a discretionary ACL
    present in the security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor to be which
        the discretionary ACL is to be added.

    DaclPresent - If FALSE, indicates the DaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the DaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    Dacl - Supplies the discretionary ACL for the security
        descriptor.  If this optional parameter is not passed, then a
        null ACL is assigned to the security descriptor.  A null
        discretionary ACL unconditionally grants access.  The ACL is
        referenced by, not copied into, by the security descriptor.

    DaclDefaulted - When set, indicates the discretionary ACL was
        picked up from some default mechanism (rather than explicitly
        specified by a user).  This value is set in the DaclDefaulted
        control flag in the security descriptor.  If this optional
        parameter is not passed, then the DaclDefaulted flag will be
        cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
       return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the DaclPresent flag value passed
    //


    if (DaclPresent) {

        ISecurityDescriptor->Control |= SE_DACL_PRESENT;

        //
        // Assign the ACL address if passed, otherwise set to null.
        //

        ISecurityDescriptor->Dacl = NULL;
        if (ARGUMENT_PRESENT(Dacl)) {
            ISecurityDescriptor->Dacl = Dacl;
        }




        //
        // Assign DaclDefaulted flag if passed, otherwise clear it.
        //

        ISecurityDescriptor->Control &= ~SE_DACL_DEFAULTED;
        if (DaclDefaulted == TRUE) {
            ISecurityDescriptor->Control |= SE_DACL_DEFAULTED;
        }
    } else {

        ISecurityDescriptor->Control &= ~SE_DACL_PRESENT;

    }


    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the discretionary ACL information of a
    security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    DaclPresent - If TRUE, indicates that the security descriptor
        does contain a discretionary ACL.  In this case, the
        remaining OUT parameters will receive valid values.
        Otherwise, the security descriptor does not contain a
        discretionary ACL and the remaining OUT parameters will not
        receive valid values.

    Dacl - This value is returned only if the value returned for the
        DaclPresent flag is TRUE.  In this case, the Dacl parameter
        receives the address of the security descriptor's
        discretionary ACL.  If this value is returned as null, then
        the security descriptor has a null discretionary ACL.

    DaclDefaulted - This value is returned only if the value returned
        for the DaclPresent flag is TRUE.  In this case, the
        DaclDefaulted parameter receives the value of the security
        descriptor's DaclDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Assign the DaclPresent flag value
    //

    *DaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_PRESENT );

    if (*DaclPresent) {

        //
        // Assign the ACL address.
        //

        *Dacl = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);

        //
        // Assign DaclDefaulted flag.
        //

        *DaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_DEFAULTED );
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN SaclPresent,
    IN PACL Sacl OPTIONAL,
    IN BOOLEAN SaclDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the system ACL information of an absolute security
    descriptor.  If there is already a system ACL present in the
    security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor to be which
        the system ACL is to be added.

    SaclPresent - If FALSE, indicates the SaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the SaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    Sacl - Supplies the system ACL for the security descriptor.  If
        this optional parameter is not passed, then a null ACL is
        assigned to the security descriptor.  The ACL is referenced
        by, not copied into, by the security descriptor.

    SaclDefaulted - When set, indicates the system ACL was picked up
        from some default mechanism (rather than explicitly specified
        by a user).  This value is set in the SaclDefaulted control
        flag in the security descriptor.  If this optional parameter
        is not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the SaclPresent flag value passed
    //


    if (SaclPresent) {

        ISecurityDescriptor->Control |= SE_SACL_PRESENT;

        //
        // Assign the ACL address if passed, otherwise set to null.
        //

        ISecurityDescriptor->Sacl = NULL;
        if (ARGUMENT_PRESENT(Sacl)) {
           ISecurityDescriptor->Sacl = Sacl;
        }

        //
        // Assign SaclDefaulted flag if passed, otherwise clear it.
        //

        ISecurityDescriptor->Control &= ~ SE_SACL_DEFAULTED;
        if (ARGUMENT_PRESENT(SaclDefaulted)) {
            ISecurityDescriptor->Control |= SE_SACL_DEFAULTED;
        }
    } else {

        ISecurityDescriptor->Control &= ~SE_SACL_PRESENT;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the system ACL information of a security
    descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    SaclPresent - If TRUE, indicates that the security descriptor
        does contain a system ACL.  In this case, the remaining OUT
        parameters will receive valid values.  Otherwise, the
        security descriptor does not contain a system ACL and the
        remaining OUT parameters will not receive valid values.

    Sacl - This value is returned only if the value returned for the
        SaclPresent flag is TRUE.  In this case, the Sacl parameter
        receives the address of the security descriptor's system ACL.
        If this value is returned as null, then the security
        descriptor has a null system ACL.

    SaclDefaulted - This value is returned only if the value returned
        for the SaclPresent flag is TRUE.  In this case, the
        SaclDefaulted parameter receives the value of the security
        descriptor's SaclDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Assign the SaclPresent flag value
    //

    *SaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_PRESENT );

    if (*SaclPresent) {

        //
        // Assign the ACL address.
        //

        *Sacl = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);

        //
        // Assign SaclDefaulted flag.
        //

        *SaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_DEFAULTED );

    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Owner OPTIONAL,
    IN BOOLEAN OwnerDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the owner information of an absolute security
    descriptor.  If there is already an owner present in the security
    descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor in which
        the owner is to be set.  If the security descriptor already
        includes an owner, it will be superseded by the new owner.

    Owner - Supplies the owner SID for the security descriptor.  If
        this optional parameter is not passed, then the owner is
        cleared (indicating the security descriptor has no owner).
        The SID is referenced by, not copied into, the security
        descriptor.

    OwnerDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the Owner field if passed, otherwise clear it.
    //

    ISecurityDescriptor->Owner = NULL;
    if (ARGUMENT_PRESENT(Owner)) {
        ISecurityDescriptor->Owner = Owner;
    }

    //
    // Assign the OwnerDefaulted flag if passed, otherwise clear it.
    //

    ISecurityDescriptor->Control &= ~SE_OWNER_DEFAULTED;
    if (OwnerDefaulted == TRUE) {
        ISecurityDescriptor->Control |= SE_OWNER_DEFAULTED;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the owner information of a security
    descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Owner - Receives a pointer to the owner SID.  If the security
        descriptor does not currently contain an owner, then this
        value will be returned as null.  In this case, the remaining
        OUT parameters are not given valid return values.  Otherwise,
        this parameter points to an SID and the remaining OUT
        parameters are provided valid return values.

    OwnerDefaulted - This value is returned only if the value
        returned for the Owner parameter is not null.  In this case,
        the OwnerDefaulted parameter receives the value of the
        security descriptor's OwnerDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Return the Owner field value.
    //

    *Owner = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);

    //
    // Return the OwnerDefaulted flag value.
    //

    *OwnerDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_OWNER_DEFAULTED );

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the primary group information of an absolute security
    descriptor.  If there is already an primary group present in the
    security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor in which
        the primary group is to be set.  If the security descriptor
        already includes a primary group, it will be superseded by
        the new group.

    Group - Supplies the primary group SID for the security
        descriptor.  If this optional parameter is not passed, then
        the primary group is cleared (indicating the security
        descriptor has no primary group).  The SID is referenced by,
        not copied into, the security descriptor.

    GroupDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the Group field if passed, otherwise clear it.
    //

    ISecurityDescriptor->Group = NULL;
    if (ARGUMENT_PRESENT(Group)) {
        ISecurityDescriptor->Group = Group;
    }

    //
    // Assign the GroupDefaulted flag if passed, otherwise clear it.
    //

    ISecurityDescriptor->Control &= ~SE_GROUP_DEFAULTED;
    if (ARGUMENT_PRESENT(GroupDefaulted)) {
        ISecurityDescriptor->Control |= SE_GROUP_DEFAULTED;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the primary group information of a
    security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Group - Receives a pointer to the primary group SID.  If the
        security descriptor does not currently contain a primary
        group, then this value will be returned as null.  In this
        case, the remaining OUT parameters are not given valid return
        values.  Otherwise, this parameter points to an SID and the
        remaining OUT parameters are provided valid return values.

    GroupDefaulted - This value is returned only if the value
        returned for the Group parameter is not null.  In this case,
        the GroupDefaulted parameter receives the value of the
        security descriptor's GroupDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor =
        (SECURITY_DESCRIPTOR *)SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Return the Group field value.
    //

    *Group = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);

    //
    // Return the GroupDefaulted flag value.
    //

    *GroupDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_GROUP_DEFAULTED );

    return STATUS_SUCCESS;

}


BOOLEAN
RtlAreAllAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine is used to check a desired access mask against a
    granted access mask.  It is used by the Object Management
    component when dereferencing a handle.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOLEAN - TRUE if the GrantedAccess mask has all the bits set
        that the DesiredAccess mask has set.  That is, TRUE is
        returned if all of the desired accesses have been granted.

--*/

{
    RTL_PAGED_CODE();

    return ((BOOLEAN)((~(GrantedAccess) & (DesiredAccess)) == 0));
}


BOOLEAN
RtlAreAnyAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine is used to test whether any of a set of desired
    accesses are granted by a granted access mask.  It is used by
    components other than the the Object Management component for
    checking access mask subsets.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOLEAN - TRUE if the GrantedAccess mask contains any of the bits
        specified in the DesiredAccess mask.  That is, if any of the
        desired accesses have been granted, TRUE is returned.


--*/

{
    RTL_PAGED_CODE();

    return ((BOOLEAN)(((GrantedAccess) & (DesiredAccess)) != 0));
}


VOID
RtlMapGenericMask(
    IN OUT PACCESS_MASK AccessMask,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.

Arguments:

        AccessMask - Points to the access mask to be mapped.

        GenericMapping - The mapping of generic to specific and standard
                         access types.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

//    //
//    // Make sure the pointer is properly aligned
//    //
//
//    ASSERT( ((ULONG)AccessMask >> 2) << 2 == (ULONG)AccessMask );

    if (*AccessMask & GENERIC_READ) {

        *AccessMask |= GenericMapping->GenericRead;
    }

    if (*AccessMask & GENERIC_WRITE) {

        *AccessMask |= GenericMapping->GenericWrite;
    }

    if (*AccessMask & GENERIC_EXECUTE) {

        *AccessMask |= GenericMapping->GenericExecute;
    }

    if (*AccessMask & GENERIC_ALL) {

        *AccessMask |= GenericMapping->GenericAll;
    }

    //
    // Now clear the generic flags
    //

    *AccessMask &= ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);

    return;
}

NTSTATUS
RtlImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.



Return Value:

    STATUS_SUCCESS -  The thread is now impersonating the calling process.

    Other - Status values returned by:

            NtOpenProcessToken()
            NtDuplicateToken()
            NtSetInformationThread()

--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Token1,
        Token2;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE
        Qos;


    RTL_PAGED_CODE();

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

    Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = ImpersonationLevel;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = FALSE;
    ObjectAttributes.SecurityQualityOfService = &Qos;

    Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_DUPLICATE, &Token1 );

    if (NT_SUCCESS(Status)) {
        Status = NtDuplicateToken(
                     Token1,
                     TOKEN_IMPERSONATE,
                     &ObjectAttributes,
                     FALSE,                 //EffectiveOnly
                     TokenImpersonation,
                     &Token2
                     );
        if (NT_SUCCESS(Status)) {
            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &Token2,
                         sizeof(HANDLE)
                         );

            IgnoreStatus = NtClose( Token2 );
        }


        IgnoreStatus = NtClose( Token1 );
    }


    return(Status);

}

#ifndef WIN16


#ifndef NTOS_KERNEL_RUNTIME

BOOLEAN
RtlpValidOwnerSubjectContext(
    IN HANDLE Token,
    IN PSID Owner,
    IN BOOLEAN ServerObject,
    OUT PNTSTATUS ReturnStatus
    )
/*++

Routine Description:

    This routine checks to see whether the provided SID is one the subject
    is authorized to assign as the owner of objects.

Arguments:

    Token - Points to the subject's effective token

    Owner - Points to the SID to be checked.

    ServerObject - Boolean indicating whether or not this is a server
       object, meaning it is protected by a primary-client combination.

    ReturnStatus - Status to be passed back to the caller on failure.

Return Value:

    FALSE on failure.

--*/

{
    NTSTATUS Status;

    ULONG Index;
    BOOLEAN Found;
    ULONG ReturnLength;
    PTOKEN_GROUPS GroupIds = NULL;
    PTOKEN_USER UserId = NULL;
    PVOID HeapHandle;
    HANDLE TokenToUse;

    BOOLEAN HasPrivilege;
    PRIVILEGE_SET PrivilegeSet;

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

    if ( Owner == NULL ) {
        *ReturnStatus = STATUS_INVALID_OWNER;
        return(FALSE);
    }

    //
    // If it's not a server object, check the owner against the contents of the
    // client token.  If it is a server object, the owner must be valid in the
    // primary token.
    //

    if (!ServerObject) {

        TokenToUse = Token;

    } else {

        *ReturnStatus = NtOpenProcessToken(
                            NtCurrentProcess(),
                            TOKEN_QUERY,
                            &TokenToUse
                            );

        if (!NT_SUCCESS( *ReturnStatus )) {
            return( FALSE );
        }
    }

    HeapHandle = RtlProcessHeap();

    //
    //  Get the User from the Token
    //

    *ReturnStatus = NtQueryInformationToken(
                         TokenToUse,
                         TokenUser,
                         UserId,
                         0,
                         &ReturnLength
                         );

    if (!NT_SUCCESS( *ReturnStatus ) && (STATUS_BUFFER_TOO_SMALL != *ReturnStatus)) {
        if (ServerObject) {
            NtClose( TokenToUse );
        }
        return( FALSE );

    }

    UserId = RtlAllocateHeap( HeapHandle, 0, ReturnLength );

    if (UserId == NULL) {

        *ReturnStatus = STATUS_NO_MEMORY;
        if (ServerObject) {
            NtClose( TokenToUse );
        }

        return( FALSE );
    }

    *ReturnStatus = NtQueryInformationToken(
                         TokenToUse,
                         TokenUser,
                         UserId,
                         ReturnLength,
                         &ReturnLength
                         );

    if (!NT_SUCCESS( *ReturnStatus )) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)UserId );
        if (ServerObject) {
            NtClose( TokenToUse );
        }
        return( FALSE );
    }

    if ( RtlEqualSid( Owner, UserId->User.Sid ) ) {

        RtlFreeHeap( HeapHandle, 0, (PVOID)UserId );
        if (ServerObject) {
            NtClose( TokenToUse );
        }
        return( TRUE );
    }

    RtlFreeHeap( HeapHandle, 0, (PVOID)UserId );

    //
    // Get the groups from the Token
    //

    *ReturnStatus = NtQueryInformationToken(
                         TokenToUse,
                         TokenGroups,
                         GroupIds,
                         0,
                         &ReturnLength
                         );

    if (!NT_SUCCESS( *ReturnStatus ) && (STATUS_BUFFER_TOO_SMALL != *ReturnStatus)) {

        if (ServerObject) {
            NtClose( TokenToUse );
        }
        return( FALSE );
    }

    GroupIds = RtlAllocateHeap( HeapHandle, 0, ReturnLength );

    if (GroupIds == NULL) {

        *ReturnStatus = STATUS_NO_MEMORY;
        if (ServerObject) {
            NtClose( TokenToUse );
        }
        return( FALSE );
    }

    *ReturnStatus = NtQueryInformationToken(
                         TokenToUse,
                         TokenGroups,
                         GroupIds,
                         ReturnLength,
                         &ReturnLength
                         );

    if (ServerObject) {
        NtClose( TokenToUse );
    }

    if (!NT_SUCCESS( *ReturnStatus )) {
        RtlFreeHeap( HeapHandle, 0, GroupIds );
        return( FALSE );
    }

    //
    //  Walk through the list of group IDs looking for a match to
    //  the specified SID.  If one is found, make sure it may be
    //  assigned as an owner.
    //
    //  This code is similar to that performed to set the default
    //  owner of a token (NtSetInformationToken).
    //

    Index = 0;
    while (Index < GroupIds->GroupCount) {

        Found = RtlEqualSid(
                    Owner,
                    GroupIds->Groups[Index].Sid
                    );

        if ( Found ) {

            if ( RtlpIdAssignableAsOwner(GroupIds->Groups[Index])) {

                RtlFreeHeap( HeapHandle, 0, GroupIds );
                return TRUE;

            } else {

                break;

            } //endif assignable

        }  //endif Found

        Index++;

    } //endwhile

    RtlFreeHeap( HeapHandle, 0, GroupIds );

    //
    // If we are going to fail this call, check for Restore privilege,
    // and succeed if he has it.
    //

    //
    // Check for appropriate Privileges
    //
    // Audit/Alarm messages need to be generated due to the attempt
    // to perform a privileged operation.
    //

    PrivilegeSet.PrivilegeCount = 1;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
    PrivilegeSet.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck(
                Token,
                &PrivilegeSet,
                &HasPrivilege
                );

    if (!NT_SUCCESS( Status )) {
        HasPrivilege = FALSE;
    }

    if ( HasPrivilege ) {
        return TRUE;
    } else {
        *ReturnStatus = STATUS_INVALID_OWNER;
        return FALSE;
    }
}
#endif // NTOS_KERNEL_RUNTIME

#endif  // WIN16





VOID
RtlpApplyAclToObject (
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is a private routine that maps Access Masks of an ACL so that
    they are applicable to the object type the ACL is being applied to.

    Only known DSA ACEs are mapped.  Unknown ACE types are ignored.

    Only access types in the GenericAll mapping for the target object
    type will be non-zero upon return.

Arguments:

    Acl - Supplies the acl being applied.

    GenericMapping - Specifies the generic mapping to use.


Return Value:

    None.

--*/

{
    ULONG i;

    PACE_HEADER Ace;

    RTL_PAGED_CODE();

    //
    //  First check if the acl is null
    //

    if (Acl == NULL) {

        return;

    }


    //
    // Now walk the ACL, mapping each ACE as we go.
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        if (IsMSAceType( Ace )) {

            RtlApplyAceToObject( Ace, GenericMapping );
        }

    }

    return;
}


BOOLEAN
RtlpCopyEffectiveAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN WillGenerateInheritAce,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN OUT PVOID *AcePosition,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited OPTIONAL,
    OUT PBOOLEAN EffectiveAceMapped,
    OUT PBOOLEAN AclOverflowed
    )

/*++

Routine Description:

    This routine copy a specified ACE into an ACL as an effective ACE.
    The resultant ACE has all the inheritance bits turned of.
    The resultant ACE has the SID mapped from a generic SID to a specific SID
    (e.g., From "creator owner" to the passed in owner sid).

Arguments:

    OldAce - Supplies the ace being inherited

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    WillGenerateInheritAce - Specifies if the caller intends to generate an
        inheritable ACE the corresponds to OldAce.  If TRUE, this routine will
        try to not map the effective ACE (increasing the likelyhood that
        EffectiveAceMapped will return FALSE),

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.

    GenericMapping - Specifies the generic mapping to use

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    AcePosition - On entry and exit, specifies location of the next available ACE
        position in NewAcl.
        A NULL ACE position means there is no room at all in NewAcl.

    NewAceLength - Returns the length (in bytes) needed in NewAcl to
        copy the specified ACE. This might be zero to indicate that the ACE
        need not be copied at all.

    NewAcl - Provides a pointer to the ACL into which the ACE is to be
        inherited.

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType
        If NULL, NewObjectType is ignored and the object ACE is always inherited

    EffectiveAceMapped - Return TRUE if the SID, guid, or access mask of Old Ace
        was modifed when copying the ACE.

    AclOverflowed - Returns TRUE if NewAcl wasn't long enough to contain NewAceLength.

Return Value:

    TRUE - No problem was detected.
    FALSE - Indicates something went wrong preventing
        the ACE from being compied.  This generally represents a bugcheck
        situation when returned from this call.

--*/
{
    ULONG LengthRequired;
    ACCESS_MASK LocalMask;
    BOOLEAN GuidOptimizationPossible = FALSE;

    PSID LocalServerOwner;
    PSID LocalServerGroup;
    NTSTATUS Status;

    ULONG CreatorSid[CREATOR_SID_SIZE];

    SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;


    RTL_PAGED_CODE();

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    LocalServerOwner = ARGUMENT_PRESENT(ServerOwnerSid) ? ServerOwnerSid : ClientOwnerSid;
    LocalServerGroup = ARGUMENT_PRESENT(ServerGroupSid) ? ServerGroupSid : ClientGroupSid;


    //
    // Initialization
    //
    *EffectiveAceMapped = FALSE;
    if ( ARGUMENT_PRESENT(ObjectAceInherited)) {
        *ObjectAceInherited = FALSE;
    }
    *AclOverflowed = FALSE;
    LengthRequired = (ULONG)OldAce->AceSize;

    //
    // Process all MS ACE types specially
    //

    if ( IsMSAceType(OldAce) ) {
        ULONG Rid;
        PSID SidToCopy = NULL;
        ULONG AceHeaderToCopyLength;
        PACE_HEADER AceHeaderToCopy = OldAce;
        PSID ServerSidToCopy = NULL;

        UCHAR DummyAce[sizeof(KNOWN_OBJECT_ACE)+sizeof(GUID)];

        //
        // Grab the Sid pointer and access mask as a function of the ACE type
        //
        if (IsKnownAceType( OldAce ) ) {
            SidToCopy = &((PKNOWN_ACE)OldAce)->SidStart;
            AceHeaderToCopyLength = FIELD_OFFSET(KNOWN_ACE, SidStart);

        } else if (IsCompoundAceType(OldAce)) {

            SidToCopy = RtlCompoundAceClientSid( OldAce );
            AceHeaderToCopyLength = FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart);
            ASSERT( FIELD_OFFSET(KNOWN_COMPOUND_ACE, Mask) ==
                    FIELD_OFFSET(KNOWN_ACE, Mask) );

            //
            // Compound ACEs have two SIDs (Map one now).
            //
            ServerSidToCopy = RtlCompoundAceServerSid( OldAce );

            if (RtlEqualPrefixSid ( ServerSidToCopy, CreatorSid )) {

                Rid = *RtlpSubAuthoritySid( ServerSidToCopy, 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    ServerSidToCopy = ClientOwnerSid;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientOwnerSid);
                    *EffectiveAceMapped = TRUE;
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( ClientGroupSid != NULL ) {
                        ServerSidToCopy = ClientGroupSid;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientGroupSid);
                        *EffectiveAceMapped = TRUE;
                    }
                    break;
                case SECURITY_CREATOR_OWNER_SERVER_RID:
                    ServerSidToCopy = LocalServerOwner;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerOwner);
                    *EffectiveAceMapped = TRUE;
                    break;
                case SECURITY_CREATOR_GROUP_SERVER_RID:
                    ServerSidToCopy = LocalServerGroup;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerGroup);
                    *EffectiveAceMapped = TRUE;
                    break;
                }

                //
                // If we don't know what this SID is, just copy the original.
                //
                if ( !*EffectiveAceMapped ) {
                    AceHeaderToCopyLength += SeLengthSid( ServerSidToCopy );
                    ServerSidToCopy = NULL;
                }

            } else {
                //
                // We don't know what this SID is, just copy the original.
                //
                AceHeaderToCopyLength += SeLengthSid( ServerSidToCopy );
                ServerSidToCopy = NULL;
            }

        //
        // Handle Object ACEs
        //
        } else {
            GUID *InheritedObjectType;

            SidToCopy = RtlObjectAceSid( OldAce );
            AceHeaderToCopyLength = (ULONG) ((PUCHAR)SidToCopy - (PUCHAR)OldAce);
            ASSERT( FIELD_OFFSET(KNOWN_OBJECT_ACE, Mask) ==
                    FIELD_OFFSET(KNOWN_ACE, Mask) );

            //
            // Handle ACEs that are only inherited for a specific object type,
            //
            InheritedObjectType = RtlObjectAceInheritedObjectType( OldAce );
            if ( ARGUMENT_PRESENT(ObjectAceInherited) && InheritedObjectType != NULL ) {

                //
                // If the object type doesn't match the inherited object type,
                //  don't inherit the ACE.
                //

                if ( pNewObjectType == NULL ||
                     !RtlpGuidPresentInGuidList( InheritedObjectType,
                                      pNewObjectType,
                                      GuidCount ) ) {

                    LengthRequired = 0;

                //
                // If the object type matches the inherited object type,
                //  Inherit an ACE with no inherited object type.
                //

                } else {

                    //
                    // Tell the caller we inherited an object type specific ACE.
                    //

                    *ObjectAceInherited = TRUE;

                    //
                    // If the caller is not going to generate an inheritable ACE,
                    //  deleting the inherited object type GUID for the effective ACE.
                    //
                    // Otherwise, leave it so the caller can merge the two ACEs.
                    //

                    if ( !WillGenerateInheritAce ) {
                        *EffectiveAceMapped = TRUE;

                        //
                        // If an object type GUID is present,
                        //  simply delete the inherited object type GUID.
                        //
                        if ( RtlObjectAceObjectTypePresent( OldAce )) {
                            LengthRequired -= sizeof(GUID);
                            AceHeaderToCopyLength -= sizeof(GUID);
                            RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );

                            AceHeaderToCopy = (PACE_HEADER)DummyAce;
                            ((PKNOWN_OBJECT_ACE)AceHeaderToCopy)->Flags &= ~ACE_INHERITED_OBJECT_TYPE_PRESENT;


                        //
                        // If an object type GUID is not present,
                        //  convert the ACE to non-object type specific.
                        //
                        } else {
                            AceHeaderToCopyLength = AceHeaderToCopyLength -
                                             sizeof(GUID) +
                                             sizeof(KNOWN_ACE) -
                                             sizeof(KNOWN_OBJECT_ACE);
                            LengthRequired = LengthRequired -
                                             sizeof(GUID) +
                                             sizeof(KNOWN_ACE) -
                                             sizeof(KNOWN_OBJECT_ACE);

                            RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
                            AceHeaderToCopy = (PACE_HEADER)DummyAce;

                            AceHeaderToCopy->AceType = RtlBaseAceType[ OldAce->AceType ];

                        }
                    } else {
                        GuidOptimizationPossible = TRUE;
                    }
                }

            }
        }

        //
        // Only proceed if we've not already determined to drop the ACE.
        //

        if ( LengthRequired != 0 ) {

            //
            // If after mapping the access mask, the access mask
            // is empty, then drop the ACE.
            //
            // This is incompatible with NT 4.0 which simply mapped and left
            //  undefined access bits set.

            LocalMask = ((PKNOWN_ACE)(OldAce))->Mask;
            RtlApplyGenericMask( OldAce, &LocalMask, GenericMapping);

            if ( LocalMask != ((PKNOWN_ACE)(OldAce))->Mask ) {
                *EffectiveAceMapped = TRUE;
            }

            //
            // Mask off any bits that aren't meaningful
            //

            LocalMask &= ( STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY );

            if (LocalMask == 0) {

                LengthRequired = 0;

            } else {

                //
                // See if the SID in the ACE is one of the various CREATOR_* SIDs by
                // comparing identifier authorities.
                //

                if (RtlEqualPrefixSid ( SidToCopy, CreatorSid )) {

                    Rid = *RtlpSubAuthoritySid( SidToCopy, 0 );

                    switch (Rid) {
                    case SECURITY_CREATOR_OWNER_RID:
                        SidToCopy = ClientOwnerSid;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientOwnerSid);
                        *EffectiveAceMapped = TRUE;
                        break;
                    case SECURITY_CREATOR_GROUP_RID:
                        if ( ClientGroupSid != NULL ) {
                            SidToCopy = ClientGroupSid;
                            LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientGroupSid);
                            *EffectiveAceMapped = TRUE;
                        }
                        break;
                    case SECURITY_CREATOR_OWNER_SERVER_RID:
                        SidToCopy = LocalServerOwner;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerOwner);
                        *EffectiveAceMapped = TRUE;
                        break;
                    case SECURITY_CREATOR_GROUP_SERVER_RID:
                        SidToCopy = LocalServerGroup;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerGroup);
                        *EffectiveAceMapped = TRUE;
                        break;
                    default :
                        //
                        // We don't know what this SID is, just copy the original.
                        //
                        break;
                    }
                }

                //
                // In cases where effective ace has been mapped because of
                //     a. CreatorOwner/Group OR
                //     b. Generic flags
                // AND
                //     this is an object type ace which will generate an IO ace
                // we can save space for a guid.
                //

                if (GuidOptimizationPossible && *EffectiveAceMapped) {

                    //
                    // If an object type GUID is present,
                    //  simply delete the inherited object type GUID.
                    //

                    if ( RtlObjectAceObjectTypePresent( OldAce )) {
                        LengthRequired -= sizeof(GUID);
                        AceHeaderToCopyLength -= sizeof(GUID);
                        RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );

                        AceHeaderToCopy = (PACE_HEADER)DummyAce;
                        ((PKNOWN_OBJECT_ACE)AceHeaderToCopy)->Flags &= ~ACE_INHERITED_OBJECT_TYPE_PRESENT;


                    //
                    // If an object type GUID is not present,
                    //  convert the ACE to non-object type specific.
                    //
                    } else {
                        AceHeaderToCopyLength = AceHeaderToCopyLength -
                                         sizeof(GUID) +
                                         sizeof(KNOWN_ACE) -
                                         sizeof(KNOWN_OBJECT_ACE);
                        LengthRequired = LengthRequired -
                                         sizeof(GUID) +
                                         sizeof(KNOWN_ACE) -
                                         sizeof(KNOWN_OBJECT_ACE);

                        RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
                        AceHeaderToCopy = (PACE_HEADER)DummyAce;

                        AceHeaderToCopy->AceType = RtlBaseAceType[ OldAce->AceType ];

                    }
                }

                //
                // If the ACE doesn't fit,
                //  just note the fact and don't copy the ACE.
                //

                if ( *AcePosition == NULL ||
                     LengthRequired > (ULONG)NewAcl->AclSize - ((PUCHAR)(*AcePosition) - (PUCHAR)NewAcl) ) {
                    *AclOverflowed = TRUE;
                } else {

                    PUCHAR Target;

                    //
                    // Copy individual parts of the ACE separately.
                    //

                    Target = (PUCHAR)*AcePosition;

                    RtlCopyMemory(
                        Target,
                        AceHeaderToCopy,
                        AceHeaderToCopyLength );

                    Target += AceHeaderToCopyLength;

                    //
                    // Now copy the correct server SID
                    //

                    if ( ServerSidToCopy != NULL ) {
                        RtlCopyMemory(
                            Target,
                            ServerSidToCopy,
                            SeLengthSid(ServerSidToCopy)
                            );
                        Target += SeLengthSid(ServerSidToCopy);
                    }

                    //
                    // Now copy the correct SID
                    //

                    RtlCopyMemory(
                        Target,
                        SidToCopy,
                        SeLengthSid(SidToCopy)
                        );
                    Target += SeLengthSid(SidToCopy);

                    //
                    // Set the size of the ACE accordingly
                    //

                    if ( LengthRequired < (ULONG)(Target - (PUCHAR)*AcePosition) ) {
                        return FALSE;
                    }
                    LengthRequired = (ULONG)(Target - (PUCHAR)*AcePosition);
                    ((PKNOWN_ACE)*AcePosition)->Header.AceSize =
                        (USHORT)LengthRequired;


                    //
                    // Put the mapped access mask in the new ACE
                    //

                    ((PKNOWN_ACE)*AcePosition)->Mask = LocalMask;

                }
            }
        }

    } else {

        //
        // If the ACE doesn't fit,
        //  just note the fact and don't copy the ACE.
        //

        if ( LengthRequired > (ULONG)NewAcl->AclSize - ((PUCHAR)*AcePosition - (PUCHAR)NewAcl) ) {
            *AclOverflowed = TRUE;
        } else {

            //
            // Not a known ACE type, copy ACE as is
            //

            RtlCopyMemory(
                *AcePosition,
                OldAce,
                LengthRequired );
         }
    }

    //
    // If the ACE was actually kept, clear all the inherit flags
    // and update the ACE count of the ACL.
    //

    if ( !*AclOverflowed && LengthRequired != 0 ) {
        ((PACE_HEADER)*AcePosition)->AceFlags &= ~VALID_INHERIT_FLAGS;
        if ( AutoInherit ) {
            ((PACE_HEADER)*AcePosition)->AceFlags |= INHERITED_ACE;
        }
        NewAcl->AceCount += 1;
    }

    //
    // We have the length of the new ACE, but we've calculated
    // it with a ULONG.  It must fit into a USHORT.  See if it
    // does.
    //

    if (LengthRequired > 0xFFFF) {
        return FALSE;
    }

    //
    // Move the Ace Position to where the next ACE goes.
    //
    if ( !*AclOverflowed ) {
        *AcePosition = ((PUCHAR)*AcePosition) + LengthRequired;
    }

    //
    //  Now return to our caller
    //

    (*NewAceLength) = LengthRequired;

    return TRUE;
}

#ifndef WIN16

NTSTATUS
RtlpCopyAces(
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACE_TYPE_TO_COPY AceTypeToCopy,
    IN UCHAR AceFlagsToReset,
    IN BOOLEAN MapSids,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN RetainInheritedAceBit,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl
    )

/*++

Routine Description:

    Copy ACEs from of an ACL and perform generic mapping.  Only ACEs specified
    by 'AceFilter' are copied.

Arguments:

    Acl - Supplies the ACL to copy from.

    GenericMapping - Specifies the generic mapping to use.

    AceTypeToCopy - Describes which aces to copy.

    AceFlagsToReset - Bit mask of ACE flags to reset (if set) on each ACE.

    MapSids - TRUE if the SID in the ACE is to be mapped to the corresponding
        actual SID.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerOwnerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ServerGroupSid - Optionally specifies the Server group Sid to use in compound ACEs.

    IsDirectoryObject - Whether the object is a container or a non-container
    
    RetainInheritedAceBit - Whether to retain INHERITED_ACE bit for effective aces.

    NewAclSizeParam - Receives the cumulatiave length of the copies ACEs

    NewAcl - Provides a pointer to the ACL to copy to.
        This ACL must already be initialized.


Return Value:

    STATUS_SUCCESS - An inheritable ACL has been generated.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        copied ACEs.  The required size is returned in NewAceLength.


--*/

{

    NTSTATUS Status;
    ULONG i;

    PACE_HEADER OldAce;
    ULONG NewAclSize, NewAceSize;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN CopyAce;
    PVOID AcePosition;
    BOOLEAN LocalAutoInherit = FALSE;


    RTL_PAGED_CODE();

    //
    // Validate the ACL.
    //

    if ( !ValidAclRevision(NewAcl) ) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Find where the first ACE goes.
    //

    if (!RtlFirstFreeAce( NewAcl, &AcePosition )) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    //
    // Walk through the original ACL copying ACEs.
    //

    NewAclSize = 0;
    for (i = 0, OldAce = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, OldAce = NextAce(OldAce)) {

        //
        // If the ACE wasn't inherited,
        //  copy it.
        //

        switch (AceTypeToCopy) {
        case CopyInheritedAces:
            CopyAce = AceInherited(OldAce);
            break;
        case CopyNonInheritedAces:
            CopyAce = !AceInherited(OldAce);
            break;
        case CopyAllAces:
            CopyAce = TRUE;
            break;
        default:
            CopyAce = FALSE;
            break;
        }

        if ( CopyAce ) {


            //
            // If SIDs are to be mapped,
            //  do so (and potentially create up to two ACEs).
            //

            if ( MapSids ) {
                PVOID TempAcePosition;
                ULONG EffectiveAceSize = 0;

                BOOLEAN EffectiveAceMapped;
                BOOLEAN GenerateInheritAce;

                //
                // Remember where the next ACE will be copied.
                //

                TempAcePosition = AcePosition;
                NewAceSize = 0;
                GenerateInheritAce = IsDirectoryObject &&
                    ((((PACE_HEADER)OldAce)->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE)) != 0);


                //
                // If the orginal ACE is an effective ACE,
                //  create an effective ACE.
                //

                if ( !(((PACE_HEADER)OldAce)->AceFlags & INHERIT_ONLY_ACE)) {
                    BOOLEAN LocalAclOverflowed;

                    //
                    // If the ace has INHERITED_ACE bit and the caller has requested
                    // preservation of the bit, copy the effective ace as an
                    // INHERITED_ACE.
                    //

                    LocalAutoInherit = FALSE;

                    if ( RetainInheritedAceBit ) {
                        if ( OldAce->AceFlags & INHERITED_ACE) {
                            LocalAutoInherit = TRUE;
                        }
                    }

                    //
                    // Copy the effective ACE into the ACL.
                    //
                    if ( !RtlpCopyEffectiveAce (
                                    OldAce,
                                    LocalAutoInherit,  
                                    GenerateInheritAce,
                                    ClientOwnerSid,
                                    ClientGroupSid,
                                    ServerOwnerSid,
                                    ServerGroupSid,
                                    GenericMapping,
                                    NULL,   // Always copy object ACES
                                    0,
                                    &TempAcePosition,
                                    &EffectiveAceSize,
                                    NewAcl,
                                    NULL,   // Always copy object ACES
                                    &EffectiveAceMapped,
                                    &LocalAclOverflowed ) ) {

                        return STATUS_BAD_INHERITANCE_ACL;
                    }

                    if (LocalAclOverflowed) {
                        AclOverflowed = TRUE;
                    }
                    NewAceSize += EffectiveAceSize;

                    //
                    // Reset any undesirable AceFlags.
                    //

                    if ( !AclOverflowed ) {
                        ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;
                    }

                }

                //
                // If the original ACE is inheritable,
                //  create an inheritable ACE.
                //
                // ASSERT: AcePosition points to where the effective ACE was copied
                // ASSERT: TempAcePosition points to where the inheritable ACE should be copied
                //

                if ( GenerateInheritAce ) {

                    //
                    // If a effective ACE was created,
                    //  and it wasn't mapped,
                    //  avoid generating another ACE and simply merge the inheritance bits into
                    //      the effective ACE.
                    //

                    if ( EffectiveAceSize != 0 && !EffectiveAceMapped ) {

                       //
                       // Copy the inherit bits from the original ACE.
                       //
                       if ( !AclOverflowed ) {
                            ((PACE_HEADER)AcePosition)->AceFlags |=
                                ((PACE_HEADER)OldAce)->AceFlags & (VALID_INHERIT_FLAGS);
                            ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;
                       }


                    //
                    // Otherwise, generate an explicit inheritance ACE.
                    //
                    // But only if the access mask isn't zero.
                    //

                    } else if ( !IsMSAceType(OldAce) || ((PKNOWN_ACE)(OldAce))->Mask != 0 ) {

                        //
                        // Account for the new ACE being added to the ACL.
                        //
                        NewAceSize += (ULONG)(((PACE_HEADER)OldAce)->AceSize);

                        if (NewAceSize > 0xFFFF) {
                            return STATUS_BAD_INHERITANCE_ACL;
                        }

                        //
                        // If the ACE doesn't fit,
                        //  just note the fact and don't copy the ACE.
                        //

                        if ( ((PACE_HEADER)OldAce)->AceSize > NewAcl->AclSize - ((PUCHAR)TempAcePosition - (PUCHAR)NewAcl) ) {
                            AclOverflowed = TRUE;
                        } else {

                            //
                            // copy it as is, but make sure the InheritOnly bit is set.
                            //

                            if ( !AclOverflowed ) {
                                RtlCopyMemory(
                                    TempAcePosition,
                                    OldAce,
                                    ((PACE_HEADER)OldAce)->AceSize
                                    );

                                ((PACE_HEADER)TempAcePosition)->AceFlags |= INHERIT_ONLY_ACE;
                                ((PACE_HEADER)TempAcePosition)->AceFlags &= ~AceFlagsToReset;
                                NewAcl->AceCount += 1;
                            }
                        }
                    }

                }

            } else {
                NewAceSize = (ULONG)OldAce->AceSize;

                //
                // If the ACE doesn't fit,
                //  just note the fact and don't copy the ACE.
                //

                if ( AcePosition == NULL ||
                     NewAceSize > (ULONG)NewAcl->AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
                    AclOverflowed = TRUE;
                } else if ( !AclOverflowed ) {


                    //
                    // Copy the ACE.
                    //

                    RtlCopyMemory(
                        AcePosition,
                        OldAce,
                        NewAceSize );

                    //
                    // Map the generic bits.
                    //
                    // Is it really right to map the generic bits on an ACE
                    // that's both effective and inheritable.  Shouldn't this
                    // be split into two ACEs in that case?  Or just skip the mapping?
                    //
                    if (IsMSAceType( AcePosition )) {
                        RtlApplyAceToObject( (PACE_HEADER)AcePosition, GenericMapping );
                    }

                    //
                    // Reset any undesirable AceFlags.
                    //

                    ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;

                    //
                    // Account for the new ACE.
                    //

                    NewAcl->AceCount += 1;
                }
            }


            //
            // Move the Ace Position to where the next ACE goes.
            //
            if ( !AclOverflowed ) {
                AcePosition = ((PUCHAR)AcePosition) + NewAceSize;
            } else {
                // On overflow, ensure no other ACEs are actually output to the buffer
                AcePosition = ((PUCHAR)NewAcl) + NewAcl->AclSize;
            }
            NewAclSize += NewAceSize;

        }
    }


    //
    // We have the length of the new ACE, but we've calculated
    // it with a ULONG.  It must fit into a USHORT.  See if it
    // does.
    //

    if (NewAclSize > 0xFFFF) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    (*NewAclSizeParam) = NewAclSize;

    return AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;

}


NTSTATUS
RtlpInheritAcl2 (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an inherited acl from
    a parent acl according to the rules of inheritance

Arguments:

    DirectoryAcl - Supplies the acl being inherited.

    ChildAcl - Supplies the acl associated with the object.  This
        is either the current acl on the object or the acl being assigned
        to the object.

    ChildGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the ChildAcl:

        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by
            the caller.

        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some
            defaulting mechanism.

        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and
            should not inherit any ACE from the DirectoryACL

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the non-inherited ACEs from the ChildAcl will be preserved and
        the inherited ACEs from the DirectoryAcl will be marked as such.

    DefaultDescriptorForObject - If set, the CreatorDescriptor
        is the default descriptor for ObjectType.  As such, the
        CreatorDescriptor will be ignored if any ObjectType specific
        ACEs are inherited from the parent.  If not such ACEs are inherited,
        the CreatorDescriptor is handled as though this flag were not
        specified.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    AclBufferSize - On input, specifies the size of AclBuffer.
        On output, on success, returns the used size of AclBuffer.
        On output, if the buffer is too small, returns the required size of AclBuffer.

    AclBuffer - Receives a pointer to the new (inherited) acl.

    NewAclExplicitlyAssigned - Returns true to indicate that some portion of
        "NewAcl" was derived from an the explicit ChildAcl

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.
        This is a warning completion status.  The caller should use the default
        ACL.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can becaused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in AclBufferSize.

--*/

{
    NTSTATUS Status;
    ULONG ChildNewAclSize = 0;
    ULONG UsedChildNewAclSize = 0;
    ULONG DirectoryNewAclSize = 0;
    ULONG AclRevision;
    USHORT ChildAceCount;
    PVOID ChildAcePosition;
    PVOID DirectoryAcePosition;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN AclProtected = FALSE;
    BOOLEAN NullAclOk = TRUE;
    BOOLEAN ObjectAceInherited;

    RTL_PAGED_CODE();


    //
    // Assume the ACL revision.
    //

    AclRevision = ACL_REVISION;
    RtlCreateAcl( (PACL)AclBuffer, *AclBufferSize, AclRevision );
    *NewAclExplicitlyAssigned = FALSE;
    *NewGenericControl = AutoInherit ? SEP_ACL_AUTO_INHERITED : 0;

    //
    // If the a current child ACL is not defaulted,
    //  the non-inherited ACEs from the current child ACL are to be preserved.
    //

    if ( (ChildGenericControl & SEP_ACL_DEFAULTED) == 0 ) {

        //
        // The resultant ACL should be protected if the input ACL is
        //  protected.
        //

        if ( ChildGenericControl & SEP_ACL_PROTECTED ) {
            AclProtected = TRUE;
            *NewGenericControl |= SEP_ACL_PROTECTED;
        }

        //
        // Only copy ACEs if the child ACL is actually present.
        //
        if ( (ChildGenericControl & (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) != 0 ) {


            if ( ChildAcl != NULL ) {
                ACE_TYPE_TO_COPY AceTypeToCopy;
                UCHAR AceFlagsToReset;
                BOOLEAN MapSids;


                AclRevision = max( AclRevision, ChildAcl->AclRevision );

                //
                // Since we're explicitly using the ACL specified by the caller,
                //  we never want to return a NULL ACL.
                //  Rather, if we have an ACL with no ACEs,
                //  we'll return exactly that.  For a DACL, that results
                //  in a DACL that grants no access rather than a DACL
                //  that grants all access.
                //

                NullAclOk = FALSE;

                //
                // If the caller doesn't understand auto inheritance,
                //  simply preserve the specified ACL 100% intact.
                //
                if ( !AutoInherit ) {

                    AceTypeToCopy = CopyAllAces;
                    AceFlagsToReset = 0;      // Don't turn off any ACE Flags
                    MapSids = FALSE;          // For backward compatibility

                //
                // If the child is protected,
                //  keep all of the ACEs turning off the INHERITED ACE flags.
                //
                } else if ( ChildGenericControl & SEP_ACL_PROTECTED ) {

                    AceTypeToCopy = CopyAllAces;
                    AceFlagsToReset = INHERITED_ACE; // Turn off all INHERITED_ACE flags
                    MapSids = TRUE;

                //
                // If the child is not protected,
                //  just copy the non-inherited ACEs.
                //
                // (The inherited ACEs will be recomputed from the parent.)
                //
                } else {

                    AceTypeToCopy = CopyNonInheritedAces;
                    AceFlagsToReset = 0;      // Don't turn off any ACE Flags
                    MapSids = TRUE;

                }

                //
                // Copy the requested ACEs.
                //

                Status = RtlpCopyAces(
                            ChildAcl,
                            GenericMapping,
                            AceTypeToCopy,
                            AceFlagsToReset,
                            MapSids,
                            OwnerSid,
                            GroupSid,
                            ServerOwnerSid,
                            ServerGroupSid,
                            IsDirectoryObject,
                            FALSE, // Do not retain INHERITED_ACE bit for effective aces
                            &ChildNewAclSize,
                            (PACL)AclBuffer );

                UsedChildNewAclSize = ChildNewAclSize;
                if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                    AclOverflowed = TRUE;
                    Status = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS(Status) ) {
                    return Status;
                }

                //
                // If this ACL might be ignored later,
                //  remember the current state of the ACL.
                //

                if ( DefaultDescriptorForObject && ChildNewAclSize != 0 ) {
                    ChildAceCount = ((PACL)AclBuffer)->AceCount;

                    if (!RtlFirstFreeAce( (PACL)AclBuffer, &ChildAcePosition ) ) {
                        return STATUS_BAD_INHERITANCE_ACL;
                    }
                }

            //
            // If the ACL isn't protected,
            //  don't allow NULL ACL semantics.
            //  (those semantics are ambiguous for auto inheritance)
            //
            } else if ( AutoInherit &&
                        !IsSacl &&
                        (ChildGenericControl & (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) == SEP_ACL_PRESENT ) {
                return STATUS_INVALID_ACL;

            }

            *NewAclExplicitlyAssigned = TRUE;

        }

    }

    //
    // Inherit ACEs from the Directory ACL in any of the following cases:
    //  If !AutoInheriting,
    //      Inherit if there is no explicit child ACL (ignoring a defaulted child).
    //  If AutoInheriting,
    //      observe the protected flag.
    //

    if ( (!AutoInherit &&
            (ChildGenericControl & SEP_ACL_PRESENT) == 0 ||
                (ChildGenericControl & SEP_ACL_DEFAULTED) != 0) ||
         (AutoInherit && !AclProtected) ) {

        //
        //  If there is no directory ACL,
        //      don't inherit from it.
        //

        if ( DirectoryAcl != NULL ) {

            //
            // If the DirectoryAcl is used,
            //  the revision of the Directory ACL is picked up.
            //

            if ( !ValidAclRevision(DirectoryAcl) ) {
                return STATUS_UNKNOWN_REVISION;
            }

            AclRevision = max( AclRevision, DirectoryAcl->AclRevision );

            //
            // Inherit the Parent's ACL.
            //

            Status = RtlpGenerateInheritAcl(
                         DirectoryAcl,
                         IsDirectoryObject,
                         AutoInherit,
                         OwnerSid,
                         GroupSid,
                         ServerOwnerSid,
                         ServerGroupSid,
                         GenericMapping,
                         pNewObjectType,
                         GuidCount,
                         &DirectoryNewAclSize,
                         (PACL)AclBuffer,
                         &ObjectAceInherited );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the default descriptor for the object should be ditched,
            //  because object specific ACEs were inherited from the directory,
            //  ditch them now.
            //

            if ( DefaultDescriptorForObject &&
                 ChildNewAclSize != 0 &&
                 ObjectAceInherited &&
                 !AclOverflowed ) {

                //
                // Compute the last used byte of the combined ACL
                //
                if (!RtlFirstFreeAce( (PACL)AclBuffer, &DirectoryAcePosition ) ) {
                    return STATUS_BAD_INHERITANCE_ACL;
                }
                if ( DirectoryAcePosition == NULL ) {
                    DirectoryAcePosition = AclBuffer + ((PACL)AclBuffer)->AclSize;
                }



                //
                // Move all the inherited ACEs to the front of the ACL.
                //

                RtlMoveMemory( FirstAce( AclBuffer ),
                               ChildAcePosition,
                               (ULONG)(((PUCHAR)DirectoryAcePosition) -
                                (PUCHAR)ChildAcePosition) );

                //
                // Adjust the ACE count to remove the deleted ACEs
                //

                ((PACL)AclBuffer)->AceCount -= ChildAceCount;

                //
                // Save the number of bytes of the Child ACL that were
                //  actually used.
                //

                UsedChildNewAclSize = 0;

            }
        }

    }

    //
    // If this routine didn't build the ACL,
    //  tell the caller.
    //

    if ( DirectoryNewAclSize + UsedChildNewAclSize == 0) {

        //
        // If the ACL was not explicitly assigned,
        //  tell the caller to default the ACL.
        //
        if ( !(*NewAclExplicitlyAssigned) ) {
            *AclBufferSize = 0;
            return STATUS_NO_INHERITANCE;

        //
        // If the Acl was explictly assigned,
        //  generate a NULL ACL based on the path taken above.
        //

        } else if ( NullAclOk ) {
            *AclBufferSize = 0;
            return STATUS_SUCCESS;
        }

        // DbgBreakPoint();
    }


    //
    // And make sure we don't exceed the length limitations of an ACL (WORD)
    //

    if ( DirectoryNewAclSize + UsedChildNewAclSize + sizeof(ACL) > 0xFFFF) {
        return(STATUS_BAD_INHERITANCE_ACL);
    }

    // The caller has to allocate a buffer large enough for
    // ChildNewAclSize rather than UsedChildNewAclSize.  Due to the nature of
    // my algorithm above.
    (*AclBufferSize) = DirectoryNewAclSize + ChildNewAclSize + sizeof(ACL);

    if ( AclOverflowed ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Patch the real ACL size and revision into the ACL
    //

    ((PACL)AclBuffer)->AclSize = (USHORT)
        (DirectoryNewAclSize + UsedChildNewAclSize + sizeof(ACL));
    ((PACL)AclBuffer)->AclRevision = (UCHAR) AclRevision;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlpInheritAcl (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PACL *NewAcl,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an inherited acl from
    a parent acl according to the rules of inheritance

Arguments:

    DirectoryAcl - Supplies the acl being inherited.

    ChildAcl - Supplies the acl associated with the object.  This
        is either the current acl on the object or the acl being assigned
        to the object.

    ChildGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the ChildAcl:

        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by
            the caller.

        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some
            defaulting mechanism.

        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and
            should not inherit any ACE from the DirectoryACL

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the non-inherited ACEs from the ChildAcl will be preserved and
        the inherited ACEs from the DirectoryAcl will be marked as such.

    DefaultDescriptorForObject - If set, the CreatorDescriptor
        is the default descriptor for ObjectType.  As such, the
        CreatorDescriptor will be ignored if any ObjectType specific
        ACEs are inherited from the parent.  If not such ACEs are inherited,
        the CreatorDescriptor is handled as though this flag were not
        specified.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAcl - Receives a pointer to the new (inherited) acl.

    NewAclExplicitlyAssigned - Returns true to indicate that some portion of
        "NewAcl" was derived from an the explicit ChildAcl

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.
        This is a warning completion status.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can becaused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   The logic in the ACL inheritance code must mirror the code for         //
//   inheritance in the executive (in seassign.c).  Do not make changes     //
//   here without also making changes in that module.                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////



    NTSTATUS Status;
    ULONG AclBufferSize;
    ULONG i;

#ifndef NTOS_KERNEL_RUNTIME
    PVOID HeapHandle;
#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

#ifndef NTOS_KERNEL_RUNTIME
    HeapHandle = RtlProcessHeap();
#endif // NTOS_KERNEL_RUNTIME


    //
    // Implement a two pass strategy.
    //
    // First try to create the ACL in a fixed length buffer.
    // If that is too small,
    //  then use the buffer size determined on the first pass
    //

    AclBufferSize = 200;
    for ( i=0; i<2 ; i++ ) {

        //
        // Allocate heap for the new ACL.
        //

#ifdef NTOS_KERNEL_RUNTIME
        (*NewAcl) = ExAllocatePoolWithTag(
                        PagedPool,
                        AclBufferSize,
                        'cAeS' );
#else // NTOS_KERNEL_RUNTIME
        (*NewAcl) = RtlAllocateHeap(
                        HeapHandle,
                        MAKE_TAG(SE_TAG),
                        AclBufferSize );
#endif // NTOS_KERNEL_RUNTIME

        if ((*NewAcl) == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Actually build the inherited ACL.
        //

        Status = RtlpInheritAcl2 (
                    DirectoryAcl,
                    ChildAcl,
                    ChildGenericControl,
                    IsDirectoryObject,
                    AutoInherit,
                    DefaultDescriptorForObject,
                    OwnerSid,
                    GroupSid,
                    ServerOwnerSid,
                    ServerGroupSid,
                    GenericMapping,
                    IsSacl,
                    pNewObjectType,
                    GuidCount,
                    &AclBufferSize,
                    (PUCHAR) *NewAcl,
                    NewAclExplicitlyAssigned,
                    NewGenericControl );


        if ( NT_SUCCESS(Status) ) {

            //
            // If a NULL ACL should be used,
            //  tell the caller.
            //

            if ( AclBufferSize == 0 ) {

#ifdef NTOS_KERNEL_RUNTIME
                ExFreePool( *NewAcl );
#else // NTOS_KERNEL_RUNTIME
                RtlFreeHeap( HeapHandle, 0, *NewAcl );
#endif // NTOS_KERNEL_RUNTIME

                *NewAcl = NULL;
            }

            break;

        } else {
#ifdef NTOS_KERNEL_RUNTIME
            ExFreePool( *NewAcl );
#else // NTOS_KERNEL_RUNTIME
            RtlFreeHeap( HeapHandle, 0, *NewAcl );
#endif // NTOS_KERNEL_RUNTIME

            *NewAcl = NULL;

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }
        }
    }


    return Status;
}


NTSTATUS
RtlpGenerateInheritedAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PULONG NewAceExtraLength,
    OUT PBOOLEAN ObjectAceInherited
    )

/*++

Routine Description:

    This is a private routine that checks if the input ace is inheritable
    and produces 0, 1, or 2 inherited aces in the given buffer.

Arguments:

    OldAce - Supplies the ace being inherited

    IsDirectoryObject - Specifies if the new ACE is for a directory

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.

    GenericMapping - Specifies the generic mapping to use

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAceLength - Receives the length (number of bytes) needed to allow for
        the inheritance of the specified ACE.  This might be zero.

    NewAcl - Provides a pointer to the ACL into which the ACE is to be
        inherited.

    NewAceExtraLength - Receives a length (number of bytes) temporarily used
        in the ACL for the inheritance ACE.  This might be zero

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType

Return Value:

    STATUS_SUCCESS - The ACE was inherited successfully.

    STATUS_BAD_INHERITANCE_ACL - Indicates something went wrong preventing
        the ACE from being inherited.  This generally represents a bugcheck
        situation when returned from this call.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in NewAceLength.


--*/

{
    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // !!!!!!!!!  This is tricky  !!!!!!!!!!                                 //
    //                                                                       //
    // The inheritence flags AND the sid of the ACE determine whether        //
    // we need 0, 1, or 2 ACEs.                                              //
    //                                                                       //
    // BE CAREFUL WHEN CHANGING THIS CODE.  READ THE DSA ACL ARCHITECTURE    //
    // SECTION COVERING INHERITENCE BEFORE ASSUMING YOU KNOW WHAT YOU ARE    //
    // DOING!!!!                                                             //
    //                                                                       //
    // The general gist of the algorithm is:                                 //
    //                                                                       //
    //       if ( (container  && ContainerInherit) ||                        //
    //            (!container && ObjectInherit)      ) {                     //
    //               GenerateEffectiveAce;                                   //
    //       }                                                               //
    //                                                                       //
    //                                                                       //
    //       if (Container && Propagate) {                                   //
    //           Propogate copy of ACE and set InheritOnly;                  //
    //       }                                                               //
    //                                                                       //
    //                                                                       //
    // A slightly more accurate description of this algorithm is:            //
    //                                                                       //
    //   IO  === InheritOnly flag                                            //
    //   CI  === ContainerInherit flag                                       //
    //   OI  === ObjectInherit flag                                          //
    //   NPI === NoPropagateInherit flag                                     //
    //                                                                       //
    //   if ( (container  && CI) ||                                          //
    //        (!container && OI)   ) {                                       //
    //       Copy Header of ACE;                                             //
    //       Clear IO, NPI, CI, OI;                                          //
    //                                                                       //
    //       if (KnownAceType) {                                             //
    //           if (SID is a creator ID) {                                  //
    //               Copy appropriate creator SID;                           //
    //           } else {                                                    //
    //               Copy SID of original;                                   //
    //           }                                                           //
    //                                                                       //
    //           Copy AccessMask of original;                                //
    //           MapGenericAccesses;                                         //
    //           if (AccessMask == 0) {                                      //
    //               discard new ACE;                                        //
    //           }                                                           //
    //                                                                       //
    //       } else {                                                        //
    //           Copy body of ACE;                                           //
    //       }                                                               //
    //                                                                       //
    //   }                                                                   //
    //                                                                       //
    //   if (!NPI) {                                                         //
    //       Copy ACE as is;                                                 //
    //       Set IO;                                                         //
    //   }                                                                   //
    //                                                                       //
    //                                                                       //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////



    ULONG LengthRequired = 0;
    ULONG ExtraLengthRequired = 0;
    PVOID AcePosition;
    PVOID EffectiveAcePosition;
    ULONG EffectiveAceSize = 0;

    BOOLEAN EffectiveAceMapped;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN GenerateInheritAce;

    RTL_PAGED_CODE();

    //
    //  This is gross and ugly, but it's better than allocating
    //  virtual memory to hold the ClientSid, because that can
    //  fail, and propogating the error back is a tremendous pain
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    *ObjectAceInherited = FALSE;
    GenerateInheritAce = IsDirectoryObject && Propagate(OldAce);

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    if (!RtlFirstFreeAce( NewAcl, &AcePosition ) ) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    //
    //  check to see if we will have a effective ACE (one mapped to
    //  the target object type).
    //

    if ( (IsDirectoryObject  && ContainerInherit(OldAce)) ||
         (!IsDirectoryObject && ObjectInherit(OldAce))      ) {


        //
        // Remember where the effective ACE will be copied to.
        //
        EffectiveAcePosition = AcePosition;

        //
        // Copy the effective ACE into the ACL.
        //
        if ( !RtlpCopyEffectiveAce (
                        OldAce,
                        AutoInherit,
                        GenerateInheritAce,
                        ClientOwnerSid,
                        ClientGroupSid,
                        ServerOwnerSid,
                        ServerGroupSid,
                        GenericMapping,
                        pNewObjectType,
                        GuidCount,
                        &AcePosition,
                        &EffectiveAceSize,
                        NewAcl,
                        ObjectAceInherited,
                        &EffectiveAceMapped,
                        &AclOverflowed ) ) {

            return STATUS_BAD_INHERITANCE_ACL;
        }

        //
        // If the effective ACE is a duplicate of existing inherited ACEs,
        //  Don't really generate it.
        //

        if ( !AclOverflowed &&
             EffectiveAceSize > 0 &&
             EffectiveAcePosition != NULL &&
                RtlpIsDuplicateAce(
                    NewAcl,
                    EffectiveAcePosition ) ) {


            //
            // Truncate the ACE we just added.
            //

            NewAcl->AceCount--;
            AcePosition = EffectiveAcePosition;
            ExtraLengthRequired = max( ExtraLengthRequired, EffectiveAceSize );
            EffectiveAceSize = 0;
        }

        LengthRequired += EffectiveAceSize;

    }

    //
    // If we are inheriting onto a container, then we may need to
    // propagate the inheritance as well.
    //

    if ( GenerateInheritAce ) {

        //
        // If a effective ACE was created,
        //  and it wasn't mapped,
        //  avoid generating another ACE and simply merge the inheritance bits into
        //      the effective ACE.
        //

        if ( EffectiveAceSize != 0 && !EffectiveAceMapped ) {

           //
           // Copy the inherit bits from the original ACE.
           //
           if ( !AclOverflowed ) {
               ((PACE_HEADER)EffectiveAcePosition)->AceFlags |=
                    ((PACE_HEADER)OldAce)->AceFlags & (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
               if ( AutoInherit ) {
                   ((PACE_HEADER)EffectiveAcePosition)->AceFlags |= INHERITED_ACE;
               }
           }


        //
        // Otherwise, generate an explicit inheritance ACE.
        //
        // But only if the access mask isn't zero.
        //

        } else if ( !IsMSAceType(OldAce) || ((PKNOWN_ACE)(OldAce))->Mask != 0 ) {

            //
            // Account for the new ACE being added to the ACL.
            //
            LengthRequired += (ULONG)(((PACE_HEADER)OldAce)->AceSize);

            if (LengthRequired > 0xFFFF) {
                return STATUS_BAD_INHERITANCE_ACL;
            }

            //
            // If the ACE doesn't fit,
            //  just note the fact and don't copy the ACE.
            //

            if ( ((PACE_HEADER)OldAce)->AceSize > NewAcl->AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
                AclOverflowed = TRUE;
            } else if (!AclOverflowed){

                //
                // copy it as is, but make sure the InheritOnly bit is set.
                //

                RtlCopyMemory(
                    AcePosition,
                    OldAce,
                    ((PACE_HEADER)OldAce)->AceSize
                    );

                ((PACE_HEADER)AcePosition)->AceFlags |= INHERIT_ONLY_ACE;
                NewAcl->AceCount += 1;
                if ( AutoInherit ) {
                    ((PACE_HEADER)AcePosition)->AceFlags |= INHERITED_ACE;

                    //
                    // If the inheritance ACE is a duplicate of existing inherited ACEs,
                    //  Don't really generate it.
                    //

                    if ( RtlpIsDuplicateAce(
                                NewAcl,
                                AcePosition ) ) {


                        //
                        // Truncate the ACE we just added.
                        //

                        NewAcl->AceCount--;
                        ExtraLengthRequired = max( ExtraLengthRequired,
                                                   ((PACE_HEADER)OldAce)->AceSize );
                        LengthRequired -= (ULONG)(((PACE_HEADER)OldAce)->AceSize);
                    }
                }

            }
        }
    }

    //
    //  Now return to our caller
    //

    (*NewAceLength) = LengthRequired;
    (*NewAceExtraLength) = ExtraLengthRequired;

    return AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
}


NTSTATUS
RtlpGenerateInheritAcl(
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited
    )

/*++

Routine Description:

    This is a private routine that produces an inheritable ACL.

    The buffer to contain the inherted ACL is passed in.  If the buffer is
    too small, the corect size is computed and STATUS_BUFFER_TOO_SMALL is
    returned.

Arguments:

    Acl - Supplies the acl being inherited.

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAclSizeParam - Receives the length of the inherited ACL.

    NewAcl - Provides a pointer to the buffer to receive the new
        (inherited) acl.  This ACL must already be initialized.

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType


Return Value:

    STATUS_SUCCESS - An inheritable ACL has been generated.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can becaused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in NewAceLength.


--*/

{

    NTSTATUS Status;
    ULONG i;

    PACE_HEADER OldAce;
    ULONG NewAclSize, NewAceSize;
    ULONG NewAclExtraSize, NewAceExtraSize;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN LocalObjectAceInherited;


    RTL_PAGED_CODE();

    //
    // Walk through the original ACL generating any necessary
    // inheritable ACEs.
    //

    NewAclSize = 0;
    NewAclExtraSize = 0;
    *ObjectAceInherited = FALSE;
    for (i = 0, OldAce = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, OldAce = NextAce(OldAce)) {

        //
        //  RtlpGenerateInheritedAce() will generate the ACE(s) necessary
        //  to inherit a single ACE.  This may be 0, 1, or more ACEs.
        //

        Status = RtlpGenerateInheritedAce(
                     OldAce,
                     IsDirectoryObject,
                     AutoInherit,
                     ClientOwnerSid,
                     ClientGroupSid,
                     ServerOwnerSid,
                     ServerGroupSid,
                     GenericMapping,
                     pNewObjectType,
                     GuidCount,
                     &NewAceSize,
                     NewAcl,
                     &NewAceExtraSize,
                     &LocalObjectAceInherited
                     );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            AclOverflowed = TRUE;
            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        if ( LocalObjectAceInherited ) {
            *ObjectAceInherited = TRUE;
        }

        //
        // Make room in the ACL for the new ACE
        //
        NewAclSize += NewAceSize;

        //
        // If a previous ACE needed 'extra' space,
        //  reduce that requirement by the size of this ACE.
        //
        // The previous ACE can use this ACE's space temporarily
        //
        if ( NewAceSize > NewAclExtraSize ) {
            NewAclExtraSize = 0 ;
        } else {
            NewAclExtraSize -= NewAceSize;
        }

        //
        // The 'extra' space needed is the larger of that needed by any
        //  previous ACE and that need by this ACE
        //
        NewAclExtraSize = max( NewAclExtraSize, NewAceExtraSize );

    }

    //
    // We only need to include the "ExtraSize" if we've overflowed.
    //  In those cases, the caller will allocate the size we requested and
    //  try again.  Otherwise, the caller won't call back so we don't care
    //  if it knows about the extra size.
    //

    if ( AclOverflowed ) {
        (*NewAclSizeParam) = NewAclSize + NewAclExtraSize;
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        (*NewAclSizeParam) = NewAclSize;
        return STATUS_SUCCESS;
    }

}


NTSTATUS
RtlpComputeMergedAcl2 (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This routine implements the 'set' semantics for auto inheritance.

    This routine builds the actual ACL that should be set on an object.
    The built ACL is a composite of the previous ACL on an object and
    the newly set ACL on the object.  The New ACL is built as follows:

    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,
    the NewAcl is constructed from the inherited ACEs from the
    CurrentAcl and the non-inherited ACEs from the ModificationAcl.
    (That is, it is impossible to edit an inherited ACE by changing the
    ACL on an object.)

    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.
    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE
    bits turned off.

    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the
    CurrentAcl is ignored.  NewAcl is built as a copy of
    ModificationDescriptor.  It is the callers responsibility to ensure
    that the correct ACEs have the INHERITED_ACE bit turned on.

Arguments:

    CurrentAcl - The current ACL on the object.

    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ModificationAcl - The ACL being applied to the object.

    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    GenericMapping - The mapping of generic to specific and standard
                     access types.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    AclBufferSize - On input, specifies the size of AclBuffer.
        On output, on success, returns the used size of AclBuffer.
        On output, if the buffer is too small, returns the required size of AclBuffer.

    AclBuffer - Receives a pointer to the new (inherited) acl.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        Only the Protected and AutoInherited bits are returned.

Return Value:

    STATUS_SUCCESS - An ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
    NTSTATUS Status;
    ULONG ModificationNewAclSize = 0;
    ULONG CurrentNewAclSize = 0;
    ULONG AclRevision;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN NullAclOk = TRUE;

    RTL_PAGED_CODE();


    //
    // Assume the ACL revision.
    //

    AclRevision = ACL_REVISION;
    RtlCreateAcl( (PACL)AclBuffer, *AclBufferSize, AclRevision );

    //
    // This routine is only called for the AutoInheritance case.
    //

    *NewGenericControl = SEP_ACL_AUTO_INHERITED;

    //
    // If the new ACL is protected,
    //  simply use the new ACL with the INHERITED_ACE bits turned off.
    //

    if ( (ModificationGenericControl & SEP_ACL_PROTECTED) != 0 ) {

        //
        // Set the Control bits for the resultant descriptor.
        //

        *NewGenericControl |= SEP_ACL_PROTECTED;

        //
        // Only copy the ACL if it is actually present
        //

        if ( ModificationAcl != NULL ) {

            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy all ACES, turn off the inherited bit, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyAllAces,
                        INHERITED_ACE,  // Turn off all INHERITED_ACE flags
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //

            NullAclOk = FALSE;
        }

    //
    // If the old ACL is protected but the new one isn't,
    //  simply use the new ACL as is.
    //
    // Rely on the caller to get the INHERITED_ACE bits right.
    //

    } else if ( (CurrentGenericControl & SEP_ACL_PROTECTED) != 0 ) {

        //
        // Only do the copy if the new ACL is specified.
        //

        if ( ModificationAcl != NULL ) {
            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy all ACES, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyAllAces,
                        0,
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        TRUE,           // Retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //

            NullAclOk = FALSE;

        //
        // Since the ACL isn't protected,
        //  don't allow NULL ACL semantics.
        //  (those semantics are ambiguous for auto inheritance)
        //
        } else if ( !IsSacl ) {
            return STATUS_INVALID_ACL;
        }


    //
    // If neither are protected,
    //  use the non-inherited ACEs from the new ACL, and
    //  preserve the inherited ACEs from the old ACL.
    //

    } else {

        //
        // NULL ACLs are always OK for a SACL.
        // NULL ACLs are never OK for a non-protected DACL.
        //

        NullAclOk = IsSacl;


        //
        // Only do the copy if the new ACL is specified.
        //

        if ( ModificationAcl != NULL ) {
            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy the non-inherited ACES, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyNonInheritedAces,
                        0,
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //
            // If inherited aces were deleted, leave the flag alone allowing
            //  a NULL SACL to be generated.
            //

            if ( ModificationAcl->AceCount == 0 ) {
                NullAclOk = FALSE;
            }

        //
        // Since the ACL isn't protected,
        //  don't allow NULL ACL semantics.
        //  (those semantics are ambiguous for auto inheritance)
        //
        } else if ( !IsSacl ) {
            return STATUS_INVALID_ACL;
        }


        //
        // Only do the copy if the old ACL is specified.
        //

        if ( CurrentAcl != NULL ) {

            AclRevision = max( AclRevision, CurrentAcl->AclRevision );


            //
            // Copy the inherited ACES, and generic map them.
            //
            // Don't bother mapping the sids in these ACEs.  They got mapped
            // during inheritance.
            //

            Status = RtlpCopyAces(
                        CurrentAcl,
                        GenericMapping,
                        CopyInheritedAces,
                        0,
                        FALSE,          // Don't map the sids,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &CurrentNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }
    }

    //
    // If this routine didn't build the ACL,
    //  tell the caller to use an explict NULL ACL
    //

    if ( ModificationNewAclSize + CurrentNewAclSize == 0) {
        //
        // If the Acl was explictly assigned,
        //  generate a NULL ACL based on the path taken above.
        //

        if ( NullAclOk ) {
            *AclBufferSize = 0;
            return STATUS_SUCCESS;
        }
    }


    //
    // And make sure we don't exceed the length limitations of an ACL (WORD)
    //

    if ( ModificationNewAclSize + CurrentNewAclSize + sizeof(ACL) > 0xFFFF) {
        return(STATUS_BAD_INHERITANCE_ACL);
    }

    (*AclBufferSize) = ModificationNewAclSize + CurrentNewAclSize + sizeof(ACL);

    if ( AclOverflowed ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Patch the real ACL size and revision into the ACL
    //

    ((PACL)AclBuffer)->AclSize = (USHORT) *AclBufferSize;
    ((PACL)AclBuffer)->AclRevision = (UCHAR) AclRevision;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlpComputeMergedAcl (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This routine builds the actual ACL that should be set on an object.
    The built ACL is a composite of the previous ACL on an object and
    the newly set ACL on the object.  The New ACL is built as follows:

    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,
    the NewAcl is constructed from the inherited ACEs from the
    CurrentAcl and the non-inherited ACEs from the ModificationAcl.
    (That is, it is impossible to edit an inherited ACE by changing the
    ACL on an object.)

    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.
    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE
    bits turned off.

    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the
    CurrentAcl is ignored.  NewAcl is built as a copy of
    ModificationDescriptor.  It is the callers responsibility to ensure
    that the correct ACEs have the INHERITED_ACE bit turned on.

Arguments:

    CurrentAcl - The current ACL on the object.

    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ModificationAcl - The ACL being applied to the object.

    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    GenericMapping - The mapping of generic to specific and standard
                     access types.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    NewAcl - Receives a pointer to the new resultant acl.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        Only the Protected and AutoInherited bits are returned.

Return Value:

    STATUS_SUCCESS - An ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
    NTSTATUS Status;
    ULONG AclBufferSize;
    ULONG i;
#ifndef NTOS_KERNEL_RUNTIME
    PVOID HeapHandle;
#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

#ifndef NTOS_KERNEL_RUNTIME
    HeapHandle = RtlProcessHeap();
#endif // NTOS_KERNEL_RUNTIME


    //
    // Implement a two pass strategy.
    //
    // First try to create the ACL in a fixed length buffer.
    // If that is too small,
    //  then use the buffer size determined on the first pass
    //

    AclBufferSize = 1024;
    for ( i=0; i<2 ; i++ ) {

        //
        // Allocate heap for the new ACL.
        //

#ifdef NTOS_KERNEL_RUNTIME
        (*NewAcl) = ExAllocatePoolWithTag(
                        PagedPool,
                        AclBufferSize,
                        'cAeS' );
#else // NTOS_KERNEL_RUNTIME
        (*NewAcl) = RtlAllocateHeap( HeapHandle, 0, AclBufferSize );
#endif // NTOS_KERNEL_RUNTIME
        if ((*NewAcl) == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Merge the ACLs
        //

        Status = RtlpComputeMergedAcl2 (
                    CurrentAcl,
                    CurrentGenericControl,
                    ModificationAcl,
                    ModificationGenericControl,
                    ClientOwnerSid,
                    ClientGroupSid,
                    GenericMapping,
                    IsSacl,
                    &AclBufferSize,
                    (PUCHAR) *NewAcl,
                    NewGenericControl );


        if ( NT_SUCCESS(Status) ) {

            //
            // If a NULL ACL should be used,
            //  tell the caller.
            //

            if ( AclBufferSize == 0 ) {
#ifdef NTOS_KERNEL_RUNTIME
                ExFreePool( *NewAcl );
#else // NTOS_KERNEL_RUNTIME
                RtlFreeHeap( HeapHandle, 0, *NewAcl );
#endif // NTOS_KERNEL_RUNTIME
                *NewAcl = NULL;
            }

            break;

        } else {
#ifdef NTOS_KERNEL_RUNTIME
            ExFreePool( *NewAcl );
#else // NTOS_KERNEL_RUNTIME
            RtlFreeHeap( HeapHandle, 0, *NewAcl );
#endif // NTOS_KERNEL_RUNTIME
            *NewAcl = NULL;

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }
        }
    }


    return Status;
}

#endif // WIN16

#if DBG
NTSTATUS
RtlDumpUserSid(
    VOID
    )
{
    NTSTATUS Status;
    HANDLE   TokenHandle;
    CHAR     Buffer[200];
    ULONG    ReturnLength;
    PSID     pSid;
    UNICODE_STRING SidString;
    PTOKEN_USER  User;

    //
    // Attempt to open the impersonation token first
    //

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 GENERIC_READ,
                 FALSE,
                 &TokenHandle
                 );

    if (!NT_SUCCESS( Status )) {

        DbgPrint("Not impersonating, status = %X, trying process token\n",Status);

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     GENERIC_READ,
                     &TokenHandle
                     );

        if (!NT_SUCCESS( Status )) {
            DbgPrint("Unable to open process token, status = %X\n",Status);
            return( Status );
        }
    }

    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 Buffer,
                 200,
                 &ReturnLength
                 );

    if (!NT_SUCCESS( Status )) {

        DbgPrint("Unable to query user sid, status = %X \n",Status);
        NtClose(TokenHandle);
        return( Status );
    }

    User = (PTOKEN_USER)Buffer;

    pSid = User->User.Sid;

    Status = RtlConvertSidToUnicodeString( &SidString, pSid, TRUE );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Unable to format sid string, status = %X \n",Status);
        NtClose(TokenHandle);
        return( Status );
    }

    DbgPrint("Current Sid = %wZ \n",&SidString);

    RtlFreeUnicodeString( &SidString );

    return( STATUS_SUCCESS );
}

#endif


NTSTATUS
RtlpConvertToAutoInheritSecurityObject(
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    See comments for RtlConvertToAutoInheritSecurityObject.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    See comments for RtlConvertToAutoInheritSecurityObject.


--*/
{
    NTSTATUS Status;
    PISECURITY_DESCRIPTOR CurrentDescriptor;
    PACL CurrentSacl;
    PACL CurrentDacl;

    PSID NewOwner;
    PSID NewGroup;

    PACL NewSacl = NULL;
    ULONG NewSaclControl = 0;
    BOOLEAN NewSaclAllocated = FALSE;

    PACL NewDacl = NULL;
    ULONG NewDaclControl = 0;
    BOOLEAN NewDaclAllocated = FALSE;
    PACL TemplateInheritedDacl = NULL;
    ULONG GenericControl;

    ULONG AllocationSize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;
    ULONG NewSaclSize;
    ULONG NewDaclSize;

    PCHAR Field;
    PCHAR Base;

    PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = NULL;
    ULONG ReturnLength;
    NTSTATUS PassedStatus;
    HANDLE PrimaryToken;

#ifndef NTOS_KERNEL_RUNTIME
    PVOID HeapHandle;
#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

#ifndef NTOS_KERNEL_RUNTIME
    HeapHandle = RtlProcessHeap();
#endif // NTOS_KERNEL_RUNTIME



    //
    //

    CurrentDescriptor = CurrentSecurityDescriptor;

    //
    // Validate the incoming security descriptor.
    //

    if (!RtlValidSecurityDescriptor ( CurrentDescriptor )) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }


    NewOwner = RtlpOwnerAddrSecurityDescriptor( CurrentDescriptor );
    if ( NewOwner == NULL ) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    NewGroup = RtlpGroupAddrSecurityDescriptor( CurrentDescriptor );




    //
    // Handle the SACL.
    //
    //
    // If the SACL isn't present,
    //  special case it.
    //

    CurrentSacl = RtlpSaclAddrSecurityDescriptor( CurrentDescriptor );

    if ( CurrentSacl == NULL ) {
        PACL ParentSacl;

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewSaclControl |= CurrentDescriptor->Control & (SE_SACL_PROTECTED|SE_SACL_PRESENT);

        // Always set the autoinherited bit.
        NewSaclControl |= SE_SACL_AUTO_INHERITED;


        //
        // If the Parent also has a NULL SACL,
        //  just consider this SACL as inherited.
        //  otherwise, this SACL is protected.
        //

        ParentSacl = ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpSaclAddrSecurityDescriptor( ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL;
        if ( ParentSacl != NULL) {
            NewSaclControl |= SE_SACL_PROTECTED;
        }


    //
    // If the SACL is already converted,
    //  or if this object is at the root of the tree,
    //  simply leave it alone.
    //
    // Don't force the Protect bit on at the root of the tree since it is semantically
    //  a no-op and gets in the way if the object is ever moved.
    //

    } else if ( RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_AUTO_INHERITED) ||
                RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_PROTECTED ) ||
                !ARGUMENT_PRESENT(ParentDescriptor) ) {

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewSaclControl |= CurrentDescriptor->Control & (SE_SACL_PROTECTED|SE_SACL_PRESENT);

        // Always set the autoinherited bit.
        NewSaclControl |= SE_SACL_AUTO_INHERITED;

        NewSacl = CurrentSacl;


    //
    // If the SACL is present,
    //  compute a new SACL with appropriate ACEs marked as inherited.
    //

    } else {


        Status = RtlpConvertAclToAutoInherit (
                    ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpSaclAddrSecurityDescriptor(
                            ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL,
                    RtlpSaclAddrSecurityDescriptor(CurrentDescriptor),
                    ObjectType,
                    IsDirectoryObject,
                    RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
                    RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
                    GenericMapping,
                    &NewSacl,
                    &GenericControl );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        NewSaclAllocated = TRUE;
        NewSaclControl |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );
    }


    //
    // Handle the DACL.
    //
    //
    // If the DACL isn't present,
    //  special case it.
    //

    CurrentDacl = RtlpDaclAddrSecurityDescriptor( CurrentDescriptor );

    if ( CurrentDacl == NULL ) {
        // Preserve the Dacl Present bit from the existing descriptor.
        NewDaclControl |= CurrentDescriptor->Control & SE_DACL_PRESENT;

        // Always set the autoinherited bit.
        // Force it protected.
        NewDaclControl |= SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED;



    //
    // If the DACL is already converted,
    //  or if this object is at the root of the tree,
    //  simply leave it alone.
    //
    // Don't force the Protect bit on at the root of the tree since it is semantically
    //  a no-op and gets in the way if the object is ever moved.
    //

    } else if ( RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_AUTO_INHERITED) ||
                RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_PROTECTED ) ||
                !ARGUMENT_PRESENT(ParentDescriptor) ) {

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewDaclControl |= CurrentDescriptor->Control & (SE_DACL_PROTECTED|SE_DACL_PRESENT);

        // Always set the autoinherited bit.
        NewDaclControl |= SE_DACL_AUTO_INHERITED;

        NewDacl = CurrentDacl;



    //
    // If the DACL is present,
    //  compute a new DACL with appropriate ACEs marked as inherited.
    //

    } else {


        Status = RtlpConvertAclToAutoInherit (
                    ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpDaclAddrSecurityDescriptor(
                            ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL,
                    RtlpDaclAddrSecurityDescriptor(CurrentDescriptor),
                    ObjectType,
                    IsDirectoryObject,
                    RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
                    RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
                    GenericMapping,
                    &NewDacl,
                    &GenericControl );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        NewDaclAllocated = TRUE;
        NewDaclControl |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );
    }



    //
    // Build the resultant security descriptor
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    NewOwnerSize = LongAlignSize(SeLengthSid(NewOwner));

    if ( NewGroup != NULL ) {
        NewGroupSize = LongAlignSize(SeLengthSid(NewGroup));
    } else {
        NewGroupSize = 0;
    }

    if (NewSacl != NULL) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if (NewDacl != NULL) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //


#ifdef NTOS_KERNEL_RUNTIME
    INewDescriptor = ExAllocatePoolWithTag(
                        PagedPool,
                        AllocationSize,
                        'dSeS' );
#else // NTOS_KERNEL_RUNTIME
    INewDescriptor = RtlAllocateHeap(
                        HeapHandle,
                        MAKE_TAG(SE_TAG),
                        AllocationSize );
#endif // NTOS_KERNEL_RUNTIME

    if ( INewDescriptor == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Initialize the security descriptor as self-relative form.
    //

    RtlCreateSecurityDescriptorRelative(
        INewDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( INewDescriptor, SE_SELF_RELATIVE );

    Base = (PCHAR)(INewDescriptor);
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Copy the Sacl
    //

    RtlpSetControlBits( INewDescriptor, NewSaclControl );
    if (NewSacl != NULL ) {

        RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );
        INewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
        Field += NewSaclSize;

    } else {

        INewDescriptor->Sacl = 0;
    }

    //
    // Copy the Dacl
    //

    RtlpSetControlBits( INewDescriptor, NewDaclControl );
    if (NewDacl != NULL ) {

        RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );
        INewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
        Field += NewDaclSize;

    } else {

        INewDescriptor->Dacl = 0;
    }

    //
    // Assign the owner
    //

    RtlCopyMemory( Field, NewOwner, SeLengthSid(NewOwner) );
    INewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if ( NewGroup != NULL ) {
        RtlCopyMemory( Field, NewGroup, SeLengthSid(NewGroup) );
        INewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    Status = STATUS_SUCCESS;



    //
    // Cleanup any locally used resources.
    //
Cleanup:
    if (NewDaclAllocated) {
#ifdef NTOS_KERNEL_RUNTIME
            ExFreePool( NewDacl );
#else // NTOS_KERNEL_RUNTIME
            RtlFreeHeap( HeapHandle, 0, NewDacl );
#endif // NTOS_KERNEL_RUNTIME
    }
    if (NewSaclAllocated) {
#ifdef NTOS_KERNEL_RUNTIME
            ExFreePool( NewSacl );
#else // NTOS_KERNEL_RUNTIME
            RtlFreeHeap( HeapHandle, 0, NewSacl );
#endif // NTOS_KERNEL_RUNTIME
    }

    *NewSecurityDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;

    return Status;


}

//
// Local macro to classify the ACE flags in an ACE.
//
// Returns one or more of the following ACE flags:
//
//  CONTAINER_INHERIT_ACE - ACE is inherited to child containers
//  OBJECT_INHERIT_ACE - ACE is inherited to child leaf objects
//  EFFECTIVE_ACE - ACE is used during access validation
//

#define MAX_CHILD_SID_GROUP_SIZE 3 // Number of bits in above list
#define EFFECTIVE_ACE INHERIT_ONLY_ACE
#define AceFlagsInAce( _Ace) \
            (((PACE_HEADER)(_Ace))->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE) | \
             (((PACE_HEADER)(_Ace))->AceFlags & INHERIT_ONLY_ACE) ^ INHERIT_ONLY_ACE )


BOOLEAN
RtlpCompareAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid,
    IN PSID GroupSid
    )
/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/
{
    BOOLEAN AcesCompare = FALSE;

    if (IsObjectAceType(InheritedAce) && IsObjectAceType(ChildAce)) {

        AcesCompare = RtlpCompareKnownObjectAces( (PKNOWN_OBJECT_ACE)InheritedAce,
                                                  (PKNOWN_OBJECT_ACE)ChildAce,
                                                  OwnerSid,
                                                  GroupSid
                                                  );
    } else {

        if (!IsObjectAceType(InheritedAce) && !IsObjectAceType(ChildAce)) {

            AcesCompare = RtlpCompareKnownAces( InheritedAce,
                                                ChildAce,
                                                OwnerSid,
                                                GroupSid
                                                );
        }
    }

    return( AcesCompare );
}


BOOLEAN
RtlpCompareKnownAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    )

/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/

{
    NTSTATUS Status;
    ACE_HEADER volatile *InheritedAceHdr = &InheritedAce->Header;

    RTL_PAGED_CODE();

    ASSERT(!IsObjectAceType(InheritedAce));
    ASSERT(!IsObjectAceType(ChildAce));

    //
    // If the Ace types are different,
    //  we don't match.
    //
    if ( RtlBaseAceType[ChildAce->Header.AceType] != RtlBaseAceType[InheritedAceHdr->AceType] ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("AceType mismatch"));
        }
#endif // DBG
        return FALSE;
    }

    //
    // If this is a system ACE,
    //  ensure the SUCCESS/FAILURE flags match.
    //

    if ( RtlIsSystemAceType[ChildAce->Header.AceType] ) {
        if ( (ChildAce->Header.AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
             (InheritedAceHdr->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("System ace success/fail mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // If the SID of the inherited ACE doesn't match,
    //  we don't match.
    //

    if ( !RtlEqualSid( (PSID)&ChildAce->SidStart, (PSID)&InheritedAce->SidStart )) {

        //
        // The inheritance algorithm only does SID mapping when building the effective
        //  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.
        //

        if ( AceFlagsInAce(ChildAce) != EFFECTIVE_ACE ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }

        //
        // In the case of CreatorOwner and CreatorGroup, the SIDs don't have to
        //  exactly match.  When the InheritedAce was generated, care was taken
        //  to NOT map these sids.  The SID may (or may not) have been mapped in
        //  the ChildAce.  We want to compare equal in both cases.
        //
        // If the InheritedAce contains a CreatorOwner/Group SID,
        //  do the another comparison of the SID in the child ACE with the
        //  real owner/group from the child security descriptor.
        //

        if ( OwnerSid != NULL || GroupSid != NULL ) {
            SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
            ULONG CreatorSid[CREATOR_SID_SIZE];

            //
            // Allocate and initialize the universal SIDs we're going to need
            // to look for inheritable ACEs.
            //

            ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
            Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );
            if ( !NT_SUCCESS(Status) ) {
                return FALSE;
            }

            *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

            if (RtlEqualPrefixSid ( (PSID)&InheritedAce->SidStart, CreatorSid )) {
                ULONG Rid;

                Rid = *RtlpSubAuthoritySid( (PSID)&InheritedAce->SidStart, 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    if ( OwnerSid == NULL ||
                         !RtlEqualSid( (PSID)&ChildAce->SidStart, OwnerSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Owner)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( GroupSid == NULL ||
                         !RtlEqualSid( (PSID)&ChildAce->SidStart, GroupSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Group)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                default:
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("SID mismatch (Creator)"));
                    }
#endif // DBG
                    return FALSE;
                }

            } else {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("SID mismatch"));
                }
#endif // DBG
                return FALSE;
            }
        } else {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    return TRUE;

}


BOOLEAN
RtlpCompareKnownObjectAces(
    IN PKNOWN_OBJECT_ACE InheritedAce,
    IN PKNOWN_OBJECT_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    )

/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/

{
    NTSTATUS Status;
    BOOLEAN DoingObjectAces;
    GUID *ChildObjectGuid;
    GUID *InhObjectGuid;
    GUID *ChildInheritedObjectGuid;
    GUID *InhInheritedObjectGuid;
    ACE_HEADER volatile *InheritedAceHdr = &InheritedAce->Header;

    RTL_PAGED_CODE();

    ASSERT(IsObjectAceType(InheritedAce));
    ASSERT(IsObjectAceType(ChildAce));
    //
    // If the Ace types are different,
    //  we don't match.
    //
    if ( RtlBaseAceType[ChildAce->Header.AceType] != RtlBaseAceType[InheritedAceHdr->AceType] ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("AceType mismatch"));
        }
#endif // DBG
        return FALSE;
    }

    //
    // If this is a system ACE,
    //  ensure the SUCCESS/FAILURE flags match.
    //

    if ( RtlIsSystemAceType[ChildAce->Header.AceType] ) {
        if ( (ChildAce->Header.AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
             (InheritedAceHdr->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("System ace success/fail mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // Get the GUIDs from the Object Aces
    //

    ChildObjectGuid = RtlObjectAceObjectType(ChildAce);
    ChildInheritedObjectGuid = RtlObjectAceInheritedObjectType(ChildAce);

    InhObjectGuid = RtlObjectAceObjectType(InheritedAce);
    InhInheritedObjectGuid = RtlObjectAceInheritedObjectType(InheritedAce);

    //
    // If the InheritedObjectGuid is present in either ACE,
    //  they must be equal.
    //

    if ( ChildInheritedObjectGuid != NULL || InhInheritedObjectGuid != NULL ) {

        if ( ChildInheritedObjectGuid == NULL ||
             InhInheritedObjectGuid == NULL ||
             !RtlpIsEqualGuid( ChildInheritedObjectGuid, InhInheritedObjectGuid )) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("InheritedObject GUID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // If the ObjectGUID is present in either ACE,
    //  they must be equal.
    //
    // Any missing object GUID defaults to the passed in object GUID.
    //

    if ( (ChildObjectGuid != NULL) && (InhObjectGuid != NULL) ) {

        if (!RtlpIsEqualGuid( ChildObjectGuid, InhObjectGuid )) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Object GUID mismatch"));
            }
#endif // DBG

            return( FALSE );
        }
    } else {

        //
        // One or both is NULL, if it's only one, they don't match.
        //

        if ( !((ChildObjectGuid == NULL) && (InhObjectGuid == NULL)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Object GUID mismatch"));
            }
#endif // DBG

            return( FALSE );
        }
    }

    //
    // If the SID of the inherited ACE doesn't match,
    //  we don't match.
    //

    if ( !RtlEqualSid( RtlObjectAceSid(ChildAce), RtlObjectAceSid(InheritedAce))) {

        //
        // The inheritance algorithm only does SID mapping when building the effective
        //  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.
        //

        if ( AceFlagsInAce(ChildAce) != EFFECTIVE_ACE ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }



        //
        // In the case of CreatorOwner and CreatorGroup, the SIDs don't have to
        //  exactly match.  When the InheritedAce was generated, care was taken
        //  to NOT map these sids.  The SID may (or may not) have been mapped in
        //  the ChildAce.  We want to compare equal in both cases.
        //
        // If the InheritedAce contains a CreatorOwner/Group SID,
        //  do the another comparison of the SID in the child ACE with the
        //  real owner/group from the child security descriptor.
        //

        if ( OwnerSid != NULL || GroupSid != NULL ) {
            SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
            ULONG CreatorSid[CREATOR_SID_SIZE];

            //
            // Allocate and initialize the universal SIDs we're going to need
            // to look for inheritable ACEs.
            //

            ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
            Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );
            if ( !NT_SUCCESS(Status) ) {
                return FALSE;
            }

            *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

            if (RtlEqualPrefixSid ( RtlObjectAceSid(InheritedAce), CreatorSid )) {
                ULONG Rid;

                Rid = *RtlpSubAuthoritySid( RtlObjectAceSid(InheritedAce), 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    if ( OwnerSid == NULL ||
                         !RtlEqualSid( RtlObjectAceSid(ChildAce), OwnerSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Owner)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( GroupSid == NULL ||
                         !RtlEqualSid( RtlObjectAceSid(ChildAce), GroupSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Group)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                default:
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("SID mismatch (Creator)"));
                    }
#endif // DBG
                    return FALSE;
                }

            } else {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("SID mismatch"));
                }
#endif // DBG
                return FALSE;
            }
        } else {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    return TRUE;

}




NTSTATUS
RtlpConvertAclToAutoInherit (
    IN PACL ParentAcl OPTIONAL,
    IN PACL ChildAcl,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an auto inherited acl from
    a ChildAcl that is not marked as auto inherited.  The passed in InheritedAcl
    is computed as the pure inherited ACL of Parent ACL of the object.

    See comments for RtlConvertToAutoInheritSecurityObject.

Arguments:

    ParentAcl - Supplies the ACL of the parent object.

    ChildAcl - Supplies the acl associated with the object.  This
        is the current acl on the object.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    NewAcl - Receives a pointer to the new (auto inherited) acl.
        The ACL must be deallocated using the pool (kernel mode) or
            heap (user mode) deallocator.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_PRESENT: Specifies that the ACL is explictly supplied by
            the caller. ?? Ever set?

        SEP_ACL_DEFAULTED: Specifies that the ACL was supplied by some
            defaulting mechanism. ?? Ever set

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

    STATUS_INVALID_ACL - The structure of one of the ACLs in invalid.

--*/

{
    NTSTATUS Status;

    PACL InheritedAcl = NULL;
    PACL RealInheritedAcl = NULL;
    BOOLEAN AclExplicitlyAssigned;
    ULONG GenericControl;

    PKNOWN_ACE ChildAce = NULL;
    PKNOWN_ACE InheritedAce;

    LONG ChildAceIndex;
    LONG InheritedAceIndex;

    BOOLEAN InheritedAllowFound;
    BOOLEAN InheritedDenyFound;

    BOOLEAN AcesCompare;

    ACCESS_MASK InheritedContainerInheritMask;
    ACCESS_MASK InheritedObjectInheritMask;
    ACCESS_MASK InheritedEffectiveMask;
    ACCESS_MASK OriginalInheritedContainerInheritMask;
    ACCESS_MASK OriginalInheritedObjectInheritMask;
    ACCESS_MASK OriginalInheritedEffectiveMask;

    ULONG InheritedAceFlags;
    ULONG MatchedFlags;
    ULONG NonInheritedAclSize;


    PACE_HEADER AceHeader;
    PUCHAR Where;

    // ULONG i;

    //
    // This routine maintains an array of the structure below (one element per ACE in
    // the ChildAcl).
    //
    // The ACE is broken down into its component parts.  The access mask is triplicated.
    // That is, if the ACE is a ContainerInherit ACE, the access mask is remembered as
    // being a "ContainerInheritMask".  The same is true if the ACE is an ObjectInherit ACE
    // on an effective ACE.  This is done since each of the resultant 96 bits are
    // individually matched against corresponding bits in the computed inherited ACE.
    //
    // Each of the above mentioned masks are maintained in two forms.  The first is never
    // changed and represents the bits as the originally appeared in the child ACL.
    // This second is modified as the corresponding bits are matched in the inherited ACL.
    // When the algorithm is completed, bits that haven't been matched represent ACEs
    // that weren't inherited from the parent.
    //

    typedef struct {
        ACCESS_MASK OriginalContainerInheritMask;
        ACCESS_MASK OriginalObjectInheritMask;
        ACCESS_MASK OriginalEffectiveMask;

        ACCESS_MASK ContainerInheritMask;
        ACCESS_MASK ObjectInheritMask;
        ACCESS_MASK EffectiveMask;
    } ACE_INFO, *PACE_INFO;

    PACE_INFO ChildAceInfo = NULL;

    ULONG CreatorOwnerSid[CREATOR_SID_SIZE];
    ULONG CreatorGroupSid[CREATOR_SID_SIZE];

    SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

#ifndef NTOS_KERNEL_RUNTIME
    PVOID HeapHandle;
#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

#ifndef NTOS_KERNEL_RUNTIME
    HeapHandle = RtlProcessHeap();
#endif // NTOS_KERNEL_RUNTIME

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    Status = RtlInitializeSid( (PSID)CreatorOwnerSid, &CreatorSidAuthority, 1 );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    Status = RtlInitializeSid( (PSID)CreatorGroupSid, &CreatorSidAuthority, 1 );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

    //
    // Ensure the passed in ACLs are valid.
    //

    *NewGenericControl = SEP_ACL_AUTO_INHERITED;
    *NewAcl = NULL;

    if ( ParentAcl != NULL && !RtlValidAcl( ParentAcl ) ) {
        Status = STATUS_INVALID_ACL;
        goto Cleanup;
    }

    if (!RtlValidAcl( ChildAcl ) ) {
        Status = STATUS_INVALID_ACL;
        goto Cleanup;
    }


    //
    // Compute what the inherited ACL "should" look like.
    //
    // The inherited ACL is computed to NOT SID-map Creator Owner and Creator Group.
    // This allows use to later recognize the constant SIDs and special case them
    // rather than mistakenly confuse them with the mapped SID.
    //

    Status = RtlpInheritAcl (
                ParentAcl,
                NULL,   // No explicit child ACL
                0,      // No Child Generic Control
                IsDirectoryObject,
                TRUE,   // AutoInherit the DACL
                FALSE,  // Not default descriptor for object
                CreatorOwnerSid,   // Subsitute a constant SID
                CreatorGroupSid,   // Subsitute a constant SID
                CreatorOwnerSid,   // Server Owner (Technically incorrect, but OK since we don't support compound ACEs)
                CreatorGroupSid,   // Server Group
                GenericMapping,
                TRUE,   // Is a SACL
                ObjectType ? &ObjectType : NULL, 
                ObjectType ? 1 : 0,
                &InheritedAcl,
                &AclExplicitlyAssigned,
                &GenericControl );

    if ( Status == STATUS_NO_INHERITANCE ) {
        *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("NO_INHERITANCE of the parent ACL\n" ));
        }
#endif // DBG
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't build inherited ACL %lX\n", Status ));
        }
#endif // DBG
        goto Cleanup;
    }





    //
    // Allocate a work buffer describing the ChildAcl
    //

#ifdef NTOS_KERNEL_RUNTIME
    ChildAceInfo = ExAllocatePoolWithTag(
                        PagedPool,
                        ChildAcl->AceCount * sizeof(ACE_INFO),
                        'cAeS' );
#else // NTOS_KERNEL_RUNTIME
    ChildAceInfo = RtlAllocateHeap(
                        HeapHandle,
                        MAKE_TAG(SE_TAG),
                        ChildAcl->AceCount * sizeof(ACE_INFO) );
#endif // NTOS_KERNEL_RUNTIME

    if (ChildAceInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {
        ACCESS_MASK LocalMask;
        ULONG ChildAceFlags;

        if ( !IsV4AceType(ChildAce) || IsCompoundAceType(ChildAce)) {
             *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
             if ( RtlpVerboseConvert ) {
                 KdPrint(("Inherited Ace type (%ld) not known\n", ChildAce->Header.AceType ));
             }
#endif // DBG
             Status = STATUS_SUCCESS;
             goto Cleanup;
        }

        //
        // Compute the generic mapped mask for use in all comparisons.  The
        //  generic mapping will be undone if needed later.
        //
        // All V4 aces have an access mask in the same location.
        //
        LocalMask = ((PKNOWN_ACE)(ChildAce))->Mask;
        RtlApplyGenericMask( ChildAce, &LocalMask, GenericMapping);


        //
        // Break the ACE into its component parts.
        //
        ChildAceFlags = AceFlagsInAce( ChildAce );
        if ( ChildAceFlags & CONTAINER_INHERIT_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = LocalMask;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = 0;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask = 0;
        }

        if ( ChildAceFlags & OBJECT_INHERIT_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = LocalMask;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = 0;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask = 0;
        }

        if ( ChildAceFlags & EFFECTIVE_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = LocalMask;
            ChildAceInfo[ChildAceIndex].EffectiveMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = 0;
            ChildAceInfo[ChildAceIndex].EffectiveMask = 0;
        }

    }


    //
    // Walk through the computed inherited ACL one ACE at a time.
    //

    for (InheritedAceIndex = 0, InheritedAce = FirstAce(InheritedAcl);
         InheritedAceIndex < InheritedAcl->AceCount;
         InheritedAceIndex += 1, InheritedAce = NextAce(InheritedAce)) {

        ACCESS_MASK LocalMask;

        //
        // If the ACE isn't a valid version 4 ACE,
        //  this isn't an ACL we're interested in handling.
        //

        if ( !IsV4AceType(InheritedAce) || IsCompoundAceType(InheritedAce)) {
             *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
             if ( RtlpVerboseConvert ) {
                 KdPrint(("Inherited Ace type (%ld) not known\n", InheritedAce->Header.AceType ));
             }
#endif // DBG
             Status = STATUS_SUCCESS;
             goto Cleanup;
        }

        //
        // Compute the generic mapped mask for use in all comparisons.  The
        //  generic mapping will be undone if needed later.
        //
        // All V4 aces have an access mask in the same location.
        //
        LocalMask = ((PKNOWN_ACE)(InheritedAce))->Mask;
        RtlApplyGenericMask( InheritedAce, &LocalMask, GenericMapping);

        if ( LocalMask == 0 ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Worthless INH ACE: %ld 0x%8.8lx\n", InheritedAceIndex, LocalMask ));
            }
#endif // DBG
            continue;
        }

        //
        // This ACE is some combination of an effective ACE, a container
        //  inherit ACE and an object inherit ACE.  Process each of those
        //  attributes separately since they might be represented separately
        //  in the ChildAcl.
        //

        InheritedAceFlags = AceFlagsInAce( InheritedAce );

        if  ( InheritedAceFlags == 0 ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Worthless INH ACE: %ld 0x%lx\n", InheritedAceIndex, InheritedAceFlags ));
            }
#endif // DBG
            continue;
        }

        if ( InheritedAceFlags & CONTAINER_INHERIT_ACE ) {
            OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = LocalMask;
        } else {
            OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = 0;
        }

        if ( InheritedAceFlags & OBJECT_INHERIT_ACE ) {
            OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = LocalMask;
        } else {
            OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = 0;
        }

        if ( InheritedAceFlags & EFFECTIVE_ACE ) {
            OriginalInheritedEffectiveMask = InheritedEffectiveMask = LocalMask;
        } else {
            OriginalInheritedEffectiveMask = InheritedEffectiveMask = 0;
        }

#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Doing INH ACE:  %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
        }
#endif // DBG


        //
        // Loop through the entire child ACL comparing each inherited ACE with
        //  each child ACE.  Don't stop simply because we've matched once.
        //  Multiple ACEs in the one ACL may have been condensed into a single ACE
        //  in the other ACL in any combination (by any of our friendly ACL editors).
        //  In all cases, it is better to compute a resultant auto inherited ACL
        //  than it is to compute a protected ACL.
        //

        for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
             ChildAceIndex < ChildAcl->AceCount;
             ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {


            //
            // Ensure the ACE represents the same principal and object,
            //

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Compare Child Ace: %ld ", ChildAceIndex ));
            }
#endif // DBG

            if ( !RtlpCompareAces( InheritedAce,
                                   ChildAce,
                                   OwnerSid,
                                   GroupSid ) ) {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("\n" ));
                }
#endif // DBG
                continue;
            }
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("\n" ));
            }
#endif // DBG


            //
            // Match as many access bits in the INH ACE as possible.
            //
            // Don't pay any attention to whether the bits have been previously matched
            // in the CHILD ACE.  To do so, would imply that there is a one-to-one
            // correspondance between bits in the INH ACL and Child ACL.  Unfortunately,
            // ACL editors feel free to compress out duplicate bits in both
            // the CHILD ACL and PARENT ACL as they see fit.
            //

            InheritedEffectiveMask &= ~ChildAceInfo[ChildAceIndex].OriginalEffectiveMask;
            InheritedContainerInheritMask &= ~ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask;
            InheritedObjectInheritMask &= ~ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask;

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("New   INH MASKs %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
            }
#endif // DBG


            //
            // Match as many access bits in the child ACE as possible.
            //
            // Same reasoning as above.
            //

            ChildAceInfo[ChildAceIndex].EffectiveMask &= ~OriginalInheritedEffectiveMask;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask &= ~OriginalInheritedContainerInheritMask;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask &= ~OriginalInheritedObjectInheritMask;

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("New Child MASKs %ld %8.8lX %8.8lX %8.8lX\n", ChildAceIndex, ChildAceInfo[ChildAceIndex].EffectiveMask, ChildAceInfo[ChildAceIndex].ContainerInheritMask, ChildAceInfo[ChildAceIndex].ObjectInheritMask ));
            }
#endif // DBG

        }


        //
        // If we couldn't process this inherited ACE,
        //  then the child ACL wasn't inherited.
        //

        if ( (InheritedEffectiveMask | InheritedContainerInheritMask | InheritedObjectInheritMask) != 0 ) {
            *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("INH ACE not completely matched: %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
            }
#endif // DBG
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }


    }

    //
    // ASSERT: All of the inherited ACEs have been processed.
    //

    //
    // Loop through the Child ACL ensuring we can build a valid auto inherited ACL
    //

    InheritedAllowFound = FALSE;
    InheritedDenyFound = FALSE;
    NonInheritedAclSize = 0;
    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {

        ACCESS_MASK ResultantMask;

        //
        // Any Child ACE access bits not eliminated above required than an
        //  explicit non-inherited ACE by built.  That ACE will have an
        //  access mask that is the combined access mask of the unmatched bit
        //  in the effective, container inherit, and object inherit categories.
        //  Even though, the combined mask may include access bits not absolutely
        //  required (since they were already inherited), this strategy prevents
        //  us from having to build multiple ACEs (one for each category) for this
        //  single ACE.
        //

        ResultantMask =
            ChildAceInfo[ChildAceIndex].EffectiveMask |
            ChildAceInfo[ChildAceIndex].ContainerInheritMask |
            ChildAceInfo[ChildAceIndex].ObjectInheritMask;


        //
        // Handle an inherited ACE
        //

        if ( ResultantMask == 0 ) {

            //
            // Keep track of whether inherited "allow" and "deny" ACEs are found.
            //

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_ALLOWED_ACE_TYPE ) {
                InheritedAllowFound = TRUE;
            }

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_DENIED_ACE_TYPE ) {
                InheritedDenyFound = TRUE;
            }

        //
        // Handle a non-inherited ACE
        //

        } else {

            //
            // Keep a running tab of the size of the non-inherited ACEs.
            //

            NonInheritedAclSize += ChildAce->Header.AceSize;

            //
            // Since non-inherited ACEs will be moved to the front of the ACL,
            //  we have to be careful that we don't move a deny ACE in front of a
            //  previously found inherited allow ACE (and vice-versa).  To do so would
            //  change the semantics of the ACL.
            //

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_ALLOWED_ACE_TYPE && InheritedDenyFound ) {
                *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("Previous deny found Child ACE: %ld\n", ChildAceIndex ));
                }
#endif // DBG
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_DENIED_ACE_TYPE && InheritedAllowFound ) {
                *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("Previous allow found Child ACE: %ld\n", ChildAceIndex ));
                }
#endif // DBG
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

        }

    }

    //
    // The resultant ACL is composed of the non-inherited ACEs followed by
    // the inherited ACE. The inherited ACEs are built by running the
    // inheritance algorithm over the Parent ACL.
    //
    // The Inherited ACL computed below is almost identical to InhertedAcl.
    // However, InheritedAcl didn't properly substitute the correct owner and
    // group SID.
    //

    Status = RtlpInheritAcl (
                ParentAcl,
                NULL,   // No explicit child ACL
                0,      // No Child Generic Control
                IsDirectoryObject,
                TRUE,   // AutoInherit the DACL
                FALSE,  // Not default descriptor for object
                OwnerSid,   // Subsitute a constant SID
                GroupSid,   // Subsitute a constant SID
                OwnerSid,   // Server Owner (Technically incorrect, but OK since we don't support compound ACEs)
                GroupSid,   // Server Group
                GenericMapping,
                TRUE,   // Is a SACL
                ObjectType ? &ObjectType : NULL, 
                ObjectType ? 1 : 0,
                &RealInheritedAcl,
                &AclExplicitlyAssigned,
                &GenericControl );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't build real inherited ACL %lX\n", Status ));
        }
#endif // DBG
        goto Cleanup;
    }



    //
    // Allocate a buffer for the inherited ACL
    //

#ifdef NTOS_KERNEL_RUNTIME
    *NewAcl = ExAllocatePoolWithTag(
                        PagedPool,
                        RealInheritedAcl->AclSize + NonInheritedAclSize,
                        'cAeS' );
#else // NTOS_KERNEL_RUNTIME
    *NewAcl = RtlAllocateHeap(
                        HeapHandle,
                        MAKE_TAG(SE_TAG),
                        RealInheritedAcl->AclSize + NonInheritedAclSize );
#endif // NTOS_KERNEL_RUNTIME

    if ( *NewAcl == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // All non-inherited ACEs are copied first.
    // The inherited ACES are grabbed from real inherited ACL.
    //
    // Build an ACL Header.
    //

    Status = RtlCreateAcl( *NewAcl,
                           RealInheritedAcl->AclSize + NonInheritedAclSize,
                           max( RealInheritedAcl->AclRevision, ChildAcl->AclRevision ) );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't create final ACL %lX\n", Status ));
        }
#endif // DBG
        //
        // The only reason for failure would be if the combined ACL is too large.
        // So just create a protected ACL (better than a failure).
        //
        *NewGenericControl |= SEP_ACL_PROTECTED;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Copy the non-inherited ACES.
    //

    Where = ((PUCHAR)(*NewAcl)) + sizeof(ACL);
    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {

        ACCESS_MASK ResultantMask;

        //
        // Copy the non-inherited ACE from the Child only if there's a non-zero access mask.
        //

        ResultantMask =
            ChildAceInfo[ChildAceIndex].EffectiveMask |
            ChildAceInfo[ChildAceIndex].ContainerInheritMask |
            ChildAceInfo[ChildAceIndex].ObjectInheritMask;

        if ( ResultantMask != 0 ) {
            PKNOWN_ACE NewAce;
            ULONG GenericBitToTry;

            //
            // Use the original ChildAce as the template.
            //

            RtlCopyMemory( Where, ChildAce, ChildAce->Header.AceSize );
            NewAce = (PKNOWN_ACE)Where;
            NewAce->Header.AceFlags &= ~INHERITED_ACE;  // Clear stray bits
            Where += ChildAce->Header.AceSize;

            (*NewAcl)->AceCount ++;

            //
            // The AccessMask on the ACE are those access bits that didn't get matched
            //  by inherited ACEs.
            //

            NewAce->Mask = ChildAce->Mask & ResultantMask;
            ResultantMask &= ~ChildAce->Mask;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Original non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
            }
#endif // DBG

            //
            // Map any remaining bits back to generic access bits.
            // Doing so might expand the ResultantMask to beyond what was computed above.
            // Doing so will never expand the computed ACE to beyond what the original
            //  ChildAce granted.
            //

            ASSERT( GENERIC_WRITE == (GENERIC_READ >> 1));
            ASSERT( GENERIC_EXECUTE == (GENERIC_WRITE >> 1));
            ASSERT( GENERIC_ALL == (GENERIC_EXECUTE >> 1));

            GenericBitToTry = GENERIC_READ;

            while ( ResultantMask && GenericBitToTry >= GENERIC_ALL ) {

                //
                // Only map generic bits that are in the ChildAce.
                //

                if ( GenericBitToTry & ChildAce->Mask ) {
                    ACCESS_MASK GenericMask;

                    //
                    // Compute the real access mask corresponding to the Generic bit.
                    //

                    GenericMask = GenericBitToTry;
                    RtlMapGenericMask( &GenericMask, GenericMapping );

                    //
                    // If the current generic bit matches any of the bits remaining,
                    //  set the generic bit in the current ACE.
                    //

                    if ( (ResultantMask & GenericMask) != 0 ) {
                        NewAce->Mask |= GenericBitToTry;
                        ResultantMask &= ~GenericMask;
                    }
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("Generic  non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
                    }
#endif // DBG
                }

                //
                // Try the next Generic bit.
                //

                GenericBitToTry >>= 1;
            }


            //
            // This is really an internal error, but press on regardless.
            //

            ASSERT(ResultantMask == 0 );
            NewAce->Mask |= ResultantMask;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Final    non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
            }
#endif // DBG

        }
    }

    //
    // Copy the inherited ACES.
    //  Simply copy computed Inherited ACL.
    //

    RtlCopyMemory( Where,
                   FirstAce(RealInheritedAcl),
                   RealInheritedAcl->AclSize - (ULONG)(((PUCHAR)FirstAce(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl));
    Where += RealInheritedAcl->AclSize - (ULONG)(((PUCHAR)FirstAce(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl);

    (*NewAcl)->AceCount += RealInheritedAcl->AceCount;
    ASSERT( (*NewAcl)->AclSize == Where - (PUCHAR)(*NewAcl) );


    Status = STATUS_SUCCESS;
Cleanup:

    //
    // If successful,
    //  build the resultant autoinherited ACL.
    //

    if ( NT_SUCCESS(Status) ) {

        //
        // If the Child ACL is protected,
        //  just build it as a copy of the original ACL
        //

        if ( *NewGenericControl & SEP_ACL_PROTECTED ) {

            //
            // If we've already allocated a new ACL (and couldn't finish it for some reason),
            //  free it.

            if ( *NewAcl != NULL) {
#ifdef NTOS_KERNEL_RUNTIME
                ExFreePool( *NewAcl );
#else // NTOS_KERNEL_RUNTIME
                RtlFreeHeap( HeapHandle, 0, *NewAcl );
#endif // NTOS_KERNEL_RUNTIME
                *NewAcl = NULL;
            }

            //
            // Allocate a buffer for the protected ACL.
            //

#ifdef NTOS_KERNEL_RUNTIME
            *NewAcl = ExAllocatePoolWithTag(
                                PagedPool,
                                ChildAcl->AclSize,
                                'cAeS' );
#else // NTOS_KERNEL_RUNTIME
            *NewAcl = RtlAllocateHeap(
                                HeapHandle,
                                MAKE_TAG(SE_TAG),
                                ChildAcl->AclSize );
#endif // NTOS_KERNEL_RUNTIME

            if ( *NewAcl == NULL ) {
                Status = STATUS_NO_MEMORY;
            } else {
                RtlCopyMemory( *NewAcl, ChildAcl, ChildAcl->AclSize );
            }
        }

    }

    if ( ChildAceInfo != NULL) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( ChildAceInfo );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, ChildAceInfo );
#endif // NTOS_KERNEL_RUNTIME
    }

    if ( InheritedAcl != NULL) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( InheritedAcl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, InheritedAcl );
#endif // NTOS_KERNEL_RUNTIME
    }

    if ( RealInheritedAcl != NULL) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( RealInheritedAcl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, RealInheritedAcl );
#endif // NTOS_KERNEL_RUNTIME
    }

    return Status;
}


BOOLEAN
RtlpIsDuplicateAce(
    IN PACL Acl,
    IN PKNOWN_ACE NewAce
    )

/*++

Routine Description:

    This routine determine if an ACE is a duplicate of an ACE already in an
    ACL.  If so, the NewAce can be removed from the end of the ACL.

    This routine currently only detects duplicate version 4 ACEs.  If the
    ACE isn't version 4, the ACE will be declared to be a non-duplicate.

    This routine only detects duplicate INHERTED ACEs.

Arguments:

    Acl - Existing ACL

    NewAce - Ace to determine if it is already in Acl.
        NewAce is expected to be the last ACE in "Acl".

Return Value:

    TRUE - NewAce is a duplicate of another ACE on the Acl
    FALSE - NewAce is NOT a duplicate of another ACE on the Acl

--*/

{
    NTSTATUS Status;
    BOOLEAN RetVal = FALSE;

    LONG AceIndex;

    ACCESS_MASK NewAceContainerInheritMask;
    ACCESS_MASK NewAceObjectInheritMask;
    ACCESS_MASK NewAceEffectiveMask;

    ACCESS_MASK LocalMask;

    PKNOWN_ACE AceFromAcl;

    RTL_PAGED_CODE();


    //
    // Ensure the passed in ACE is one this routine understands
    //

    if ( !IsV4AceType(NewAce) || IsCompoundAceType(NewAce)) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("New Ace type (%ld) not known\n", NewAce->Header.AceType ));
        }
#endif // DBG
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // This routine only works for ACEs marked as INHERITED.
    //

    if ( (NewAce->Header.AceFlags & INHERITED_ACE ) == 0 ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("New Ace type isn't inherited\n" ));
        }
#endif // DBG
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Break the new ACE into its component parts.
    //
    // All V4 aces have an access mask in the same location.
    //
    LocalMask = ((PKNOWN_ACE)(NewAce))->Mask;

    if ( NewAce->Header.AceFlags & CONTAINER_INHERIT_ACE ) {
        NewAceContainerInheritMask = LocalMask;
    } else {
        NewAceContainerInheritMask = 0;
    }

    if ( NewAce->Header.AceFlags & OBJECT_INHERIT_ACE ) {
        NewAceObjectInheritMask = LocalMask;
    } else {
        NewAceObjectInheritMask = 0;
    }

    if ( (NewAce->Header.AceFlags & INHERIT_ONLY_ACE) == 0 ) {
        NewAceEffectiveMask = LocalMask;
    } else {
        NewAceEffectiveMask = 0;
    }
#if DBG
    if ( RtlpVerboseConvert ) {
        KdPrint(("Starting MASKs:  %8.8lX %8.8lX %8.8lX", NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
    }
#endif // DBG




    //
    // Walk through the ACL one ACE at a time.
    //

    for (AceIndex = 0, AceFromAcl = FirstAce(Acl);
         AceIndex < Acl->AceCount-1;    // NewAce is the last ACE
         AceIndex += 1, AceFromAcl = NextAce(AceFromAcl)) {


        //
        // If the ACE isn't a valid version 4 ACE,
        //  this isn't an ACE we're interested in handling.
        //

        if ( !IsV4AceType(AceFromAcl) || IsCompoundAceType(AceFromAcl)) {
            continue;
        }

        //
        // This routine only works for ACEs marked as INHERITED.
        //

        if ( (AceFromAcl->Header.AceFlags & INHERITED_ACE ) == 0 ) {
            continue;
        }


        //
        // Compare the Ace from the ACL with the New ACE
        //
        //  Don't stop simply because we've matched once.
        //  Multiple ACEs in the one ACL may have been condensed into a single ACE
        //  in the other ACL in any combination (by any of our friendly ACL editors).
        //
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Compare Ace: %ld ", AceIndex ));
        }
#endif // DBG

        if ( RtlpCompareAces( AceFromAcl,
                              NewAce,
                              NULL,
                              NULL ) ) {


            //
            // Match the bits from the current ACE with bits from the New ACE.
            //
            // All V4 aces have an access mask in the same location.
            //

            LocalMask = ((PKNOWN_ACE)(AceFromAcl))->Mask;

            if ( AceFromAcl->Header.AceFlags & CONTAINER_INHERIT_ACE ) {
                NewAceContainerInheritMask &= ~LocalMask;
            }

            if ( AceFromAcl->Header.AceFlags & OBJECT_INHERIT_ACE ) {
                NewAceObjectInheritMask &= ~LocalMask;
            }

            if ( (AceFromAcl->Header.AceFlags & INHERIT_ONLY_ACE) == 0 ) {
                NewAceEffectiveMask &= ~LocalMask;
            }

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Remaining MASKs:  %8.8lX %8.8lX %8.8lX", NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
            }
#endif // DBG

            //
            // If all bits have been matched in the New Ace,
            //  then this is a duplicate ACE.
            //

            if ( (NewAceEffectiveMask | NewAceContainerInheritMask | NewAceObjectInheritMask) == 0 ) {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("\n"));
                }
#endif // DBG
                RetVal = TRUE;
                goto Cleanup;
            }
        }
#if DBG
        if ( RtlpVerboseConvert ) {
              KdPrint(("\n"));
        }
#endif // DBG


    }

    //
    // All of the ACEs of the ACL have been processed.
    //
    // We haven't matched all of the bits in the New Ace so this is not a duplicate ACE.
    //

    RetVal = FALSE;
Cleanup:

    return RetVal;

}


NTSTATUS
RtlpCreateServerAcl(
    IN PACL Acl,
    IN BOOLEAN AclUntrusted,
    IN PSID ServerSid,
    OUT PACL *ServerAcl,
    OUT BOOLEAN *ServerAclAllocated
    )

/*++

Routine Description:

    This routine takes an ACL and converts it into a server ACL.
    Currently, that means converting all of the GRANT ACEs into
    Compount Grants, and if necessary sanitizing any Compound
    Grants that are encountered.

Arguments:



Return Value:


--*/

{
    USHORT RequiredSize = sizeof(ACL);
    USHORT AceSizeAdjustment;
    USHORT ServerSidSize;
    PACE_HEADER Ace;
    ULONG i;
    PVOID Target;
    PVOID AcePosition;
    PSID UntrustedSid;
    PSID ClientSid;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    if (Acl == NULL) {
        *ServerAclAllocated = FALSE;
        *ServerAcl = NULL;
        return( STATUS_SUCCESS );
    }

    AceSizeAdjustment = sizeof( KNOWN_COMPOUND_ACE ) - sizeof( KNOWN_ACE );
    ASSERT( sizeof( KNOWN_COMPOUND_ACE ) >= sizeof( KNOWN_ACE ) );

    ServerSidSize = (USHORT)SeLengthSid( ServerSid );

    //
    // Do this in two passes.  First, determine how big the final
    // result is going to be, and then allocate the space and make
    // the changes.
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        //
        // If it's an ACCESS_ALLOWED_ACE_TYPE, we'll need to add in the
        // size of the Server SID.
        //

        if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE) {

            //
            // Simply add the size of the new Server SID plus whatever
            // adjustment needs to be made to increase the size of the ACE.
            //

            RequiredSize += ( ServerSidSize + AceSizeAdjustment );

        } else {

            if (AclUntrusted && Ace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE ) {

                //
                // Since the Acl is untrusted, we don't care what is in the
                // server SID, we're going to replace it.
                //

                UntrustedSid = RtlCompoundAceServerSid( Ace );
                if ((USHORT)SeLengthSid(UntrustedSid) > ServerSidSize) {
                    RequiredSize += ((USHORT)SeLengthSid(UntrustedSid) - ServerSidSize);
                } else {
                    RequiredSize += (ServerSidSize - (USHORT)SeLengthSid(UntrustedSid));

                }
            }
        }

        RequiredSize += Ace->AceSize;
    }

#ifdef NTOS_KERNEL_RUNTIME
    (*ServerAcl) = (PACL)ExAllocatePoolWithTag( PagedPool, RequiredSize, 'cAeS' );
#else // NTOS_KERNEL_RUNTIME
    (*ServerAcl) = (PACL)RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( SE_TAG ), RequiredSize );
#endif // NTOS_KERNEL_RUNTIME

    if ((*ServerAcl) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Mark as allocated so caller knows to free it.
    //

    *ServerAclAllocated = TRUE;

    Status = RtlCreateAcl( (*ServerAcl), RequiredSize, ACL_REVISION3 );
    ASSERT( NT_SUCCESS( Status ));

    for (i = 0, Ace = FirstAce(Acl), Target=FirstAce( *ServerAcl );
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        //
        // If it's an ACCESS_ALLOWED_ACE_TYPE, convert to a Server ACE.
        //

        if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE ||
           (AclUntrusted && Ace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE )) {

            AcePosition = Target;

            if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE) {
                ClientSid =  &((PKNOWN_ACE)Ace)->SidStart;
            } else {
                ClientSid = RtlCompoundAceClientSid( Ace );
            }

            //
            // Copy up to the access mask.
            //

            RtlCopyMemory(
                Target,
                Ace,
                FIELD_OFFSET(KNOWN_ACE, SidStart)
                );

            //
            // Now copy the correct Server SID
            //

            Target = ((PCHAR)Target + (UCHAR)(FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart)));

            RtlCopyMemory(
                Target,
                ServerSid,
                SeLengthSid(ServerSid)
                );

            Target = ((PCHAR)Target + (UCHAR)SeLengthSid(ServerSid));

            //
            // Now copy in the correct client SID.  We can copy this right out of
            // the original ACE.
            //

            RtlCopyMemory(
                Target,
                ClientSid,
                SeLengthSid(ClientSid)
                );

            Target = ((PCHAR)Target + SeLengthSid(ClientSid));

            //
            // Set the size of the ACE accordingly
            //

            ((PKNOWN_COMPOUND_ACE)AcePosition)->Header.AceSize =
                (USHORT)FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart) +
                (USHORT)SeLengthSid(ServerSid) +
                (USHORT)SeLengthSid(ClientSid);

            //
            // Set the type
            //

            ((PKNOWN_COMPOUND_ACE)AcePosition)->Header.AceType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
            ((PKNOWN_COMPOUND_ACE)AcePosition)->CompoundAceType = COMPOUND_ACE_IMPERSONATION;

        } else {

            //
            // Just copy the ACE as is.
            //

            RtlCopyMemory( Target, Ace, Ace->AceSize );

            Target = ((PCHAR)Target + Ace->AceSize);
        }
    }

    (*ServerAcl)->AceCount = Acl->AceCount;

    return( STATUS_SUCCESS );
}

#ifndef NTOS_KERNEL_RUNTIME
NTSTATUS
RtlpGetDefaultsSubjectContext(
    HANDLE ClientToken,
    OUT PTOKEN_OWNER *OwnerInfo,
    OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
    OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
    OUT PTOKEN_OWNER *ServerOwner,
    OUT PTOKEN_PRIMARY_GROUP *ServerGroup
    )
{
    HANDLE PrimaryToken;
    PVOID HeapHandle;
    NTSTATUS Status;
    ULONG ServerGroupInfoSize;
    ULONG ServerOwnerInfoSize;
    ULONG TokenDaclInfoSize;
    ULONG TokenGroupInfoSize;
    ULONG TokenOwnerInfoSize;

    BOOLEAN ClosePrimaryToken = FALSE;

    *OwnerInfo = NULL;
    *GroupInfo = NULL;
    *DefaultDaclInfo = NULL;
    *ServerOwner = NULL;
    *ServerGroup = NULL;

    HeapHandle = RtlProcessHeap();

    //
    // If the caller doesn't know the client token,
    //  simply don't return any information.
    //

    if ( ClientToken != NULL ) {
        //
        // Obtain the default owner from the client.
        //

        Status = NtQueryInformationToken(
                     ClientToken,                        // Handle
                     TokenOwner,                   // TokenInformationClass
                     NULL,                         // TokenInformation
                     0,                            // TokenInformationLength
                     &TokenOwnerInfoSize           // ReturnLength
                     );

        if ( STATUS_BUFFER_TOO_SMALL != Status ) {
            goto Cleanup;
        }

        *OwnerInfo = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), TokenOwnerInfoSize );

        if ( *OwnerInfo == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = NtQueryInformationToken(
                     ClientToken,                        // Handle
                     TokenOwner,                   // TokenInformationClass
                     *OwnerInfo,               // TokenInformation
                     TokenOwnerInfoSize,           // TokenInformationLength
                     &TokenOwnerInfoSize           // ReturnLength
                     );

        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        //
        // Obtain the default group from the client token.
        //

        Status = NtQueryInformationToken(
                     ClientToken,                        // Handle
                     TokenPrimaryGroup,            // TokenInformationClass
                     *GroupInfo,                   // TokenInformation
                     0,                            // TokenInformationLength
                     &TokenGroupInfoSize           // ReturnLength
                     );

        if ( STATUS_BUFFER_TOO_SMALL != Status ) {
            goto Cleanup;
        }

        *GroupInfo = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), TokenGroupInfoSize );

        if ( *GroupInfo == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = NtQueryInformationToken(
                     ClientToken,                  // Handle
                     TokenPrimaryGroup,            // TokenInformationClass
                     *GroupInfo,                   // TokenInformation
                     TokenGroupInfoSize,           // TokenInformationLength
                     &TokenGroupInfoSize           // ReturnLength
                     );

        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        Status = NtQueryInformationToken(
                     ClientToken,                        // Handle
                     TokenDefaultDacl,             // TokenInformationClass
                     *DefaultDaclInfo,             // TokenInformation
                     0,                            // TokenInformationLength
                     &TokenDaclInfoSize            // ReturnLength
                     );

        if ( STATUS_BUFFER_TOO_SMALL != Status ) {
            goto Cleanup;
        }

        *DefaultDaclInfo = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), TokenDaclInfoSize );

        if ( *DefaultDaclInfo == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = NtQueryInformationToken(
                     ClientToken,                        // Handle
                     TokenDefaultDacl,             // TokenInformationClass
                     *DefaultDaclInfo,             // TokenInformation
                     TokenDaclInfoSize,            // TokenInformationLength
                     &TokenDaclInfoSize            // ReturnLength
                     );

        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }
    }

    //
    // Now open the primary token to determine how to substitute for
    // ServerOwner and ServerGroup.
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &PrimaryToken
                 );

    if (!NT_SUCCESS( Status )) {
        ClosePrimaryToken = FALSE;
        goto Cleanup;
    } else {
        ClosePrimaryToken = TRUE;
    }

    Status = NtQueryInformationToken(
                 PrimaryToken,                 // Handle
                 TokenOwner,                   // TokenInformationClass
                 NULL,                         // TokenInformation
                 0,                            // TokenInformationLength
                 &ServerOwnerInfoSize          // ReturnLength
                 );

    if ( STATUS_BUFFER_TOO_SMALL != Status ) {
        goto Cleanup;
    }

    *ServerOwner = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), ServerOwnerInfoSize );

    if ( *ServerOwner == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                 PrimaryToken,                 // Handle
                 TokenOwner,                   // TokenInformationClass
                 *ServerOwner,                 // TokenInformation
                 ServerOwnerInfoSize,          // TokenInformationLength
                 &ServerOwnerInfoSize          // ReturnLength
                 );

    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    //
    // Find the server group.
    //

    Status = NtQueryInformationToken(
                 PrimaryToken,                 // Handle
                 TokenPrimaryGroup,            // TokenInformationClass
                 *ServerGroup,                 // TokenInformation
                 0,                            // TokenInformationLength
                 &ServerGroupInfoSize          // ReturnLength
                 );

    if ( STATUS_BUFFER_TOO_SMALL != Status ) {
        goto Cleanup;
    }

    *ServerGroup = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), ServerGroupInfoSize );

    if ( *ServerGroup == NULL ) {
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                 PrimaryToken,                 // Handle
                 TokenPrimaryGroup,            // TokenInformationClass
                 *ServerGroup,                 // TokenInformation
                 ServerGroupInfoSize,          // TokenInformationLength
                 &ServerGroupInfoSize          // ReturnLength
                 );

    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    NtClose( PrimaryToken );

    return( STATUS_SUCCESS );

Cleanup:

    if (*OwnerInfo != NULL) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)*OwnerInfo );
        *OwnerInfo = NULL;
    }

    if (*GroupInfo != NULL) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)*GroupInfo );
        *GroupInfo = NULL;
    }

    if (*DefaultDaclInfo != NULL) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)*DefaultDaclInfo );
        *DefaultDaclInfo = NULL;
    }

    if (*ServerOwner != NULL) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)*ServerOwner );
        *ServerOwner = NULL;
    }

    if (*ServerGroup != NULL) {
        RtlFreeHeap( HeapHandle, 0, (PVOID)*ServerGroup );
        *ServerGroup = NULL;
    }

    if (ClosePrimaryToken  == TRUE) {
        NtClose( PrimaryToken );
    }

    return( Status );
}
#endif // NTOS_KERNEL_RUNTIME


NTSTATUS
RtlpNewSecurityObject (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created.  The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.  Memory is
    allocated to hold each of the security descriptor's components (using
    NtAllocateVirtualMemory()).  The final security descriptor generated by
    this procedure is produced according to the rules stated in ???

    System and Discretionary ACL Assignment
    ---------------------------------------

    The assignment of system and discretionary ACLs is governed by the
    logic illustrated in the following table:

                 |  Explicit      |  Explicit     |
                 | (non-default)  |  Default      |   No
                 |  Acl           |  Acl          |   Acl
                 |  Specified     |  Specified    |   Specified
    -------------+----------------+---------------+--------------
                 |                |               |
    Inheritable  | Assign         |  Assign       | Assign
    Acl From     | Specified      |  Inherited    | Inherited
    Parent       | Acl(1)(2)      |  Acl          | Acl
                 |                |               |
    -------------+----------------+---------------+--------------
    No           |                |               |
    Inheritable  | Assign         |  Assign       | Assign
    Acl From     | Specified      |  Default      | No Acl
    Parent       | Acl(1)         |  Acl          |
                 |                |               |
    -------------+----------------+---------------+--------------

    (1) Any ACEs with the INHERITED_ACE bit set are NOT copied to the assigned
    security descriptor.

    (2) If the AutoInheritFlags is flagged to automatically inherit ACEs from
    parent (SEF_DACL_AUTO_INHERIT or SEF_SACL_AUTO_INHERIT), inherited
    ACEs from the parent will be appended after explicit ACEs from the
    CreatorDescriptor.


    Note that an explicitly specified ACL, whether a default ACL or
    not, may be empty or null.

    If the caller is explicitly assigning a system acl, default or
    non-default, the caller must either be a kernel mode client or
    must be appropriately privileged.


    Owner and Group Assignment
    --------------------------

    The assignment of the new object's owner and group is governed
    by the following logic:

       1)   If the passed security descriptor includes an owner, it
            is assigned as the new object's owner.  Otherwise, the
            caller's token is looked in for the owner.  Within the
            token, if there is a default owner, it is assigned.
            Otherwise, the caller's user ID is assigned.

       2)   If the passed security descriptor includes a group, it
            is assigned as the new object's group.  Otherwise, the
            caller's token is looked in for the group.  Within the
            token, if there is a default group, it is assigned.
            Otherwise, the caller's primary group ID is assigned.


Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If no such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

        For calls from the kernel, Supplies the security context of the subject creating the
        object. This is used to retrieve default security information for the
        new object, such as default owner, primary group, and discretionary
        access control.

        If not specified, the Owner and Primary group must be specified in the
        CreatorDescriptor.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the owner of the
        target security descriptor is not one the subject is authorized to
        assign as the owner of an object.

    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly
        provided and the caller is not currently impersonating a client.

    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege
        necessary to explicitly assign the specified system ACL.
        SeSecurityPrivilege privilege is needed to explicitly assign
        system ACLs to objects.


--*/
{


    SECURITY_DESCRIPTOR *CapturedDescriptor;
    SECURITY_DESCRIPTOR InCaseOneNotPassed;
    BOOLEAN SecurityDescriptorPassed;

    NTSTATUS Status;

    PACL NewSacl = NULL;
    BOOLEAN NewSaclInherited = FALSE;

    PACL NewDacl = NULL;
    PACL ServerDacl = NULL;
    BOOLEAN NewDaclInherited = FALSE;

    PSID NewOwner = NULL;
    PSID NewGroup = NULL;

    BOOLEAN SaclExplicitlyAssigned = FALSE;
    BOOLEAN OwnerExplicitlyAssigned = FALSE;
    BOOLEAN DaclExplicitlyAssigned = FALSE;

    BOOLEAN ServerDaclAllocated = FALSE;

    BOOLEAN ServerObject;
    BOOLEAN DaclUntrusted;

    BOOLEAN HasPrivilege;
    PRIVILEGE_SET PrivilegeSet;

    PSID SubjectContextOwner = NULL;
    PSID SubjectContextGroup = NULL;
    PSID ServerOwner = NULL;
    PSID ServerGroup = NULL;

    PACL SubjectContextDacl = NULL;

    ULONG AllocationSize;
    ULONG NewOwnerSize, OwnerSize;
    ULONG NewGroupSize, GroupSize;
    ULONG NewSaclSize;
    ULONG NewDaclSize;

    PCHAR Field;
    PCHAR Base;



    PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = NULL;
    NTSTATUS PassedStatus;
    KPROCESSOR_MODE RequestorMode;

    ULONG GenericControl;
    ULONG NewControlBits = SE_SELF_RELATIVE;

#ifndef NTOS_KERNEL_RUNTIME
    PTOKEN_OWNER         TokenOwnerInfo = NULL;
    PTOKEN_PRIMARY_GROUP TokenPrimaryGroupInfo = NULL;
    PTOKEN_DEFAULT_DACL  TokenDefaultDaclInfo = NULL;

    PTOKEN_OWNER         ServerOwnerInfo = NULL;
    PTOKEN_PRIMARY_GROUP ServerGroupInfo = NULL;
    PVOID HeapHandle;

#else

    //
    // For kernel mode callers, the Token parameter is really
    // a pointer to a subject context structure.
    //

    PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PVOID SubjectContextInfo = NULL;

    SubjectSecurityContext = (PSECURITY_SUBJECT_CONTEXT)Token;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

#ifdef NTOS_KERNEL_RUNTIME
    //
    //  Get the previous mode of the caller
    //

    RequestorMode = KeGetPreviousMode();
#else // NTOS_KERNEL_RUNTIME
    RequestorMode = UserMode;

    //
    // Get the handle to the current process heap
    //

    HeapHandle = RtlProcessHeap();

    //
    // Ensure the token is an impersonation token.
    //
    if ( Token != NULL ) {
        TOKEN_STATISTICS    ThreadTokenStatistics;
        ULONG ReturnLength;

        Status = NtQueryInformationToken(
                     Token,                        // Handle
                     TokenStatistics,              // TokenInformationClass
                     &ThreadTokenStatistics,       // TokenInformation
                     sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                     &ReturnLength                 // ReturnLength
                     );

        if (!NT_SUCCESS( Status )) {
            return( Status );
        }

        //
        //  If it is an impersonation token, then make sure it is at a
        //  high enough level.
        //

        if (ThreadTokenStatistics.TokenType == TokenImpersonation) {

            if (ThreadTokenStatistics.ImpersonationLevel < SecurityIdentification ) {

                return( STATUS_BAD_IMPERSONATION_LEVEL );
            }
        }

    }
#endif // NTOS_KERNEL_RUNTIME


    //
    //  The desired end result is to build a self-relative security descriptor.
    //  This means that a single block of memory will be allocated and all
    //  security information copied into it.  To minimize work along the way,
    //  it is desirable to reference (rather than copy) each field as we
    //  determine its source.  This can not be done with inherited ACLs, however,
    //  since they must be built from another ACL.  So, explicitly assigned
    //  and defaulted SIDs and ACLs are just referenced until they are copied
    //  into the self-relative descriptor.  Inherited ACLs are built in a
    //  temporary buffer which must be deallocated after being copied to the
    //  self-relative descriptor.
    //



    //
    //  If a security descriptor has been passed, capture it, otherwise
    //  cobble up a fake one to simplify the code that follows.
    //

    if (ARGUMENT_PRESENT(CreatorDescriptor)) {

        CapturedDescriptor = CreatorDescriptor;
        SecurityDescriptorPassed = TRUE;

    } else {

        //
        //  No descriptor passed, make a fake one
        //

        SecurityDescriptorPassed = FALSE;

        RtlCreateSecurityDescriptor(&InCaseOneNotPassed,
                                    SECURITY_DESCRIPTOR_REVISION);
        CapturedDescriptor = &InCaseOneNotPassed;

    }


    if ( CapturedDescriptor->Control & SE_SERVER_SECURITY ) {
        ServerObject = TRUE;
    } else {
        ServerObject = FALSE;
    }

    if ( CapturedDescriptor->Control & SE_DACL_UNTRUSTED ) {
        DaclUntrusted = TRUE;
    } else {
        DaclUntrusted = FALSE;
    }



    //
    // Get the required information from the token.
    //
    //
    // Grab pointers to the default owner, primary group, and
    // discretionary ACL.
    //
    if ( Token != NULL || ServerObject ) {

#ifdef NTOS_KERNEL_RUNTIME

        PSID TmpSubjectContextOwner = NULL;
        PSID TmpSubjectContextGroup = NULL;
        PSID TmpServerOwner = NULL;
        PSID TmpServerGroup = NULL;

        PACL TmpSubjectContextDacl = NULL;

        SIZE_T SubjectContextInfoSize = 0;

        //
        // Lock the subject context for read access so that the pointers
        // we copy out of it don't disappear on us at random
        //

        SeLockSubjectContext( SubjectSecurityContext );

        SepGetDefaultsSubjectContext(
            SubjectSecurityContext,
            &TmpSubjectContextOwner,
            &TmpSubjectContextGroup,
            &TmpServerOwner,
            &TmpServerGroup,
            &TmpSubjectContextDacl
            );

        //
        // We can't keep the subject context locked, because
        // we may have to do a privilege check later, which calls
        // PsLockProcessSecurityFields, which can cause a deadlock
        // with PsImpersonateClient, which takes them in the reverse
        // order.
        //
        // Since we're giving up our read lock on the token, we
        // need to copy all the stuff that we just got back.  Since
        // it's not going to change, we can save some cycles and copy
        // it all into a single chunck of memory.
        //

        SubjectContextInfoSize = SeLengthSid( TmpSubjectContextOwner ) +
                                 SeLengthSid( TmpServerOwner )         +
                                 (TmpSubjectContextGroup != NULL ? SeLengthSid( TmpSubjectContextGroup ) : 0) +
                                 (TmpServerGroup         != NULL ? SeLengthSid( TmpServerGroup )         : 0) +
                                 (TmpSubjectContextDacl  != NULL ? TmpSubjectContextDacl->AclSize        : 0);

        SubjectContextInfo = ExAllocatePoolWithTag( PagedPool, SubjectContextInfoSize, 'dSeS');

        if (SubjectContextInfo) {

            //
            // Copy in the data
            //

            Base = SubjectContextInfo;

            //
            // There will always be an owner.
            //

            SubjectContextOwner = (PSID)Base;
            RtlCopySid( SeLengthSid( TmpSubjectContextOwner), Base, TmpSubjectContextOwner );
            Base += SeLengthSid( TmpSubjectContextOwner);

            //
            // Groups may be NULL
            //

            if (TmpSubjectContextGroup != NULL) {
                SubjectContextGroup = (PSID)Base;
                RtlCopySid( SeLengthSid( TmpSubjectContextGroup), Base, TmpSubjectContextGroup );
                Base += SeLengthSid( TmpSubjectContextGroup );
            } else {
                SubjectContextGroup = NULL;
            }

            ServerOwner = (PSID)Base;
            RtlCopySid( SeLengthSid( TmpServerOwner ), Base, TmpServerOwner );
            Base += SeLengthSid( TmpServerOwner );

            //
            // Groups may be NULL
            //

            if (TmpServerGroup != NULL) {
                ServerGroup = (PSID)Base;
                RtlCopySid( SeLengthSid( TmpServerGroup ), Base, TmpServerGroup );
                Base += SeLengthSid( TmpServerGroup );
            } else {
                ServerGroup = NULL;
            }

            if (TmpSubjectContextDacl != NULL) {
                SubjectContextDacl = (PACL)Base;
                RtlCopyMemory( Base, TmpSubjectContextDacl, TmpSubjectContextDacl->AclSize );
                // Base += TmpSubjectContextDacl->AclSize;
            } else {
                SubjectContextDacl = NULL;
            }

        } else {

            SeUnlockSubjectContext( SubjectSecurityContext );

            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        SeUnlockSubjectContext( SubjectSecurityContext );


#else // NTOS_KERNEL_RUNTIME
        Status = RtlpGetDefaultsSubjectContext(
                     Token,
                     &TokenOwnerInfo,
                     &TokenPrimaryGroupInfo,
                     &TokenDefaultDaclInfo,
                     &ServerOwnerInfo,
                     &ServerGroupInfo
                     );

        if (!NT_SUCCESS( Status )) {
            return( Status );
        }

        SubjectContextOwner = TokenOwnerInfo->Owner;
        SubjectContextGroup = TokenPrimaryGroupInfo->PrimaryGroup;
        SubjectContextDacl  = TokenDefaultDaclInfo->DefaultDacl;
        ServerOwner         = ServerOwnerInfo->Owner;
        ServerGroup         = ServerGroupInfo->PrimaryGroup;
#endif // NTOS_KERNEL_RUNTIME
    }



    //
    // Establish an owner SID
    //

    NewOwner = RtlpOwnerAddrSecurityDescriptor(CapturedDescriptor);

    if ((NewOwner) != NULL) {

        //
        // Use the specified owner
        //

        OwnerExplicitlyAssigned = TRUE;

    } else {

        //
        // If the caller said to default the owner from the parent descriptor,
        //  grab it now.
        //

        if ( AutoInheritFlags & SEF_DEFAULT_OWNER_FROM_PARENT) {
            if ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }
            NewOwner = RtlpOwnerAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
            OwnerExplicitlyAssigned = TRUE;

            if ( NewOwner == NULL ) {
                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }
        } else {

            //
            // Pick up the default from the subject's security context.
            //
            // This does NOT constitute explicit assignment of owner
            // and does not have to be checked as an ID that can be
            // assigned as owner.  This is because a default can not
            // be established in a token unless the user of the token
            // can assign it as an owner.
            //

            //
            // If we've been asked to create a ServerObject, we need to
            // make sure to pick up the new owner from the Primary token,
            // not the client token.  If we're not impersonating, they will
            // end up being the same.
            //

            NewOwner = ServerObject ? ServerOwner : SubjectContextOwner;

            //
            // Ensure an owner is now defined.
            //

            if ( NewOwner == NULL ) {
                Status = STATUS_NO_TOKEN;
                goto Cleanup;
            }
        }
    }


    //
    // Establish a Group SID
    //

    NewGroup = RtlpGroupAddrSecurityDescriptor(CapturedDescriptor);

    if (NewGroup == NULL) {

        //
        // If the caller said to default the group from the parent descriptor,
        //  grab it now.
        //

        if ( AutoInheritFlags & SEF_DEFAULT_GROUP_FROM_PARENT) {
            if ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
                Status = STATUS_INVALID_PRIMARY_GROUP;
                goto Cleanup;
            }
            NewGroup = RtlpGroupAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
        } else {
            //
            // Pick up the primary group from the subject's security context
            //
            // If we're creating a Server object, use the group from the server
            // context.
            //

            NewGroup = ServerObject ? ServerGroup : SubjectContextGroup;

        }

    }

    if (NewGroup == NULL) {
        Status = STATUS_INVALID_PRIMARY_GROUP;
        goto Cleanup;
    }



    //
    // Establish System Acl
    //

    Status = RtlpInheritAcl (
                ARGUMENT_PRESENT(ParentDescriptor) ?
                    RtlpSaclAddrSecurityDescriptor(
                        ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                    NULL,
                RtlpSaclAddrSecurityDescriptor(CapturedDescriptor),
                SeControlSaclToGeneric( CapturedDescriptor->Control ),
                IsDirectoryObject,
                (BOOLEAN)((AutoInheritFlags & SEF_SACL_AUTO_INHERIT) != 0),
                (BOOLEAN)((AutoInheritFlags & SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
                NewOwner,
                NewGroup,
                ServerOwner,
                ServerGroup,
                GenericMapping,
                TRUE,   // Is a SACL
                pObjectType,
                GuidCount,
                &NewSacl,
                &SaclExplicitlyAssigned,
                &GenericControl );

    if ( NT_SUCCESS(Status) ) {
        NewSaclInherited = TRUE;
        NewControlBits |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );

    } else if ( Status == STATUS_NO_INHERITANCE ) {

        //
        // Always set the auto inherit bit if the caller requested it.
        //

        if ( AutoInheritFlags & SEF_SACL_AUTO_INHERIT) {
            NewControlBits |= SE_SACL_AUTO_INHERITED;
        }

        //
        // No inheritable ACL - check for a defaulted one.
        //
        if ( RtlpAreControlBitsSet( CapturedDescriptor,
                                SE_SACL_PRESENT | SE_SACL_DEFAULTED ) ) {

            //
            // Reference the default ACL
            //

            NewSacl = RtlpSaclAddrSecurityDescriptor(CapturedDescriptor);
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= (CapturedDescriptor->Control & SE_SACL_PROTECTED);

            //
            // This counts as an explicit assignment.
            //
            SaclExplicitlyAssigned = TRUE;
        }

    } else {

        //
        // Some unusual error occured
        //

        goto Cleanup;
    }




    //
    // Establish Discretionary Acl
    //

    Status = RtlpInheritAcl (
                ARGUMENT_PRESENT(ParentDescriptor) ?
                    RtlpDaclAddrSecurityDescriptor(
                        ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                    NULL,
                RtlpDaclAddrSecurityDescriptor(CapturedDescriptor),
                SeControlDaclToGeneric( CapturedDescriptor->Control ),
                IsDirectoryObject,
                (BOOLEAN)((AutoInheritFlags & SEF_DACL_AUTO_INHERIT) != 0),
                (BOOLEAN)((AutoInheritFlags & SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
                NewOwner,
                NewGroup,
                ServerOwner,
                ServerGroup,
                GenericMapping,
                FALSE,   // Is a DACL
                pObjectType,
                GuidCount,
                &NewDacl,
                &DaclExplicitlyAssigned,
                &GenericControl );

    if ( NT_SUCCESS(Status) ) {
        NewDaclInherited = TRUE;
        NewControlBits |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );

    } else if ( Status == STATUS_NO_INHERITANCE ) {

        //
        // Always set the auto inherit bit if the caller requested it.
        //

        if ( AutoInheritFlags & SEF_DACL_AUTO_INHERIT) {
            NewControlBits |= SE_DACL_AUTO_INHERITED;
        }

        //
        // No inheritable ACL - check for a defaulted one.
        //
        if ( RtlpAreControlBitsSet( CapturedDescriptor,
                                SE_DACL_PRESENT | SE_DACL_DEFAULTED ) ) {

            //
            // Reference the default ACL
            //

            NewDacl = RtlpDaclAddrSecurityDescriptor(CapturedDescriptor);
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= (CapturedDescriptor->Control & SE_DACL_PROTECTED);

            //
            // This counts as an explicit assignment.
            //
            DaclExplicitlyAssigned = TRUE;

        //
        // Default to the DACL on the token.
        //
        } else if (ARGUMENT_PRESENT(SubjectContextDacl)) {

            NewDacl = SubjectContextDacl;
            NewControlBits |= SE_DACL_PRESENT;

        }


    } else {

        //
        // Some unusual error occured
        //

        goto Cleanup;
    }

#ifdef  ASSERT_ON_NULL_DACL

    //
    // Culprit will probably be the caller NtCreate*, or
    // RtlNewSecurityObject.  Note that although this will not always occur
    // because of explicit user action it still must be corrected.
    //
    
    if (RtlpAssertOnNullDacls) {

        ASSERT(("NULL DACLs are NOT allowed!", NewDacl != NULL));
    }

#endif // ASSERT_ON_NULL_DACL

    //
    // If auto inheriting and the computed child DACL is NULL,
    //  mark it as protected.
    //
    // NULL DACLs are problematic when ACEs are actually inherited from the
    // parent DACL.  It is better to mark them as protected NOW (even if we don't
    // end up inheriting any ACEs) to avoid confusion later.
    //

    if ( (AutoInheritFlags & SEF_DACL_AUTO_INHERIT) != 0 &&
         NewDacl == NULL ) {
        NewControlBits |= SE_DACL_PROTECTED;
    }



    //
    // Now make sure that the caller has the right to assign
    // everything in the descriptor.  The requestor is subjected
    // to privilege and restriction tests for some assignments.
    //
    if (RequestorMode == UserMode) {


        //
        // Anybody can assign any Discretionary ACL or group that they want to.
        //

        //
        //  See if the system ACL was explicitly specified
        //

        if ( SaclExplicitlyAssigned &&
             (AutoInheritFlags & SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {

            //
            // Require a Token if we're to do the privilege check.
            //

            if ( Token == NULL ) {
                Status = STATUS_NO_TOKEN;
                goto Cleanup;
            }

#ifdef NTOS_KERNEL_RUNTIME

            //
            // Check for appropriate Privileges
            // Audit/Alarm messages need to be generated due to the attempt
            // to perform a privileged operation.
            //

            //
            // Note: be sure to do the privilege check against
            // the passed subject context!
            //

            PrivilegeSet.PrivilegeCount = 1;
            PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
            PrivilegeSet.Privilege[0].Luid = SeSecurityPrivilege;
            PrivilegeSet.Privilege[0].Attributes = 0;

            HasPrivilege = SePrivilegeCheck(
                               &PrivilegeSet,
                               SubjectSecurityContext,
                               RequestorMode
                               );

            if ( RequestorMode != KernelMode ) {

                SePrivilegedServiceAuditAlarm (
                    NULL,
                    SubjectSecurityContext,
                    &PrivilegeSet,
                    HasPrivilege
                    );
            }

#else // NTOS_KERNEL_RUNTIME
            //
            // Check for appropriate Privileges
            //
            // Audit/Alarm messages need to be generated due to the attempt
            // to perform a privileged operation.
            //

            PrivilegeSet.PrivilegeCount = 1;
            PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
            PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
            PrivilegeSet.Privilege[0].Attributes = 0;

            Status = NtPrivilegeCheck(
                        Token,
                        &PrivilegeSet,
                        &HasPrivilege
                        );

            if (!NT_SUCCESS( Status )) {
                goto Cleanup;
            }

#endif // NTOS_KERNEL_RUNTIME

            if ( !HasPrivilege ) {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

        }

        //
        // See if the owner field is one the requestor can assign
        //

        if (OwnerExplicitlyAssigned &&
            (AutoInheritFlags & SEF_AVOID_OWNER_CHECK) == 0 ) {

#ifdef NTOS_KERNEL_RUNTIME


            if (!SepValidOwnerSubjectContext(
                    SubjectSecurityContext,
                    NewOwner,
                    ServerObject)
                    ) {

                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }

#else // NTOS_KERNEL_RUNTIME

            //
            // Require a Token if we're to do the privilege check.
            //

            if ( Token == NULL ) {
                Status = STATUS_NO_TOKEN;
                goto Cleanup;
            }

            if (!RtlpValidOwnerSubjectContext(
                    Token,
                    NewOwner,
                    ServerObject,
                    &PassedStatus) ) {

                Status = PassedStatus;
                goto Cleanup;
            }
#endif // NTOS_KERNEL_RUNTIME
        }


        //
        // If the DACL was explictly assigned and this is a server object,
        //  convert the DACL to be a server DACL
        //

        if (DaclExplicitlyAssigned && ServerObject) {

            Status = RtlpCreateServerAcl(
                         NewDacl,
                         DaclUntrusted,
                         ServerOwner,
                         &ServerDacl,
                         &ServerDaclAllocated
                         );

            if (!NT_SUCCESS( Status )) {
                goto Cleanup;
            }
            
            if (NewDaclInherited && NewDacl) {
#ifdef NTOS_KERNEL_RUNTIME
                ExFreePool( NewDacl );
#else // NTOS_KERNEL_RUNTIME
                RtlFreeHeap( HeapHandle, 0, (PVOID)NewDacl );
#endif // NTOS_KERNEL_RUNTIME
            }

            NewDacl = ServerDacl;
            ServerDacl = NULL;
        }
    }


    //
    // Everything is assignable by the requestor.
    // Calculate the memory needed to house all the information in
    // a self-relative security descriptor.
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    OwnerSize = SeLengthSid(NewOwner);
    NewOwnerSize = LongAlignSize(OwnerSize);
    if (NewGroup != NULL) {
        GroupSize = SeLengthSid(NewGroup);
        NewGroupSize = LongAlignSize(GroupSize);
    }

    if ((NewControlBits & SE_SACL_PRESENT) && (NewSacl != NULL)) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if ( (NewControlBits & SE_DACL_PRESENT) && (NewDacl != NULL)) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //

#ifdef NTOS_KERNEL_RUNTIME
    INewDescriptor = (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag( PagedPool, AllocationSize, 'dSeS');
#else // NTOS_KERNEL_RUNTIME
    INewDescriptor = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), AllocationSize );
#endif // NTOS_KERNEL_RUNTIME

    if ( INewDescriptor == NULL ) {
#ifdef NTOS_KERNEL_RUNTIME
        Status = STATUS_INSUFFICIENT_RESOURCES;
#else // NTOS_KERNEL_RUNTIME
        Status = STATUS_NO_MEMORY;
#endif // NTOS_KERNEL_RUNTIME
        goto Cleanup;
    }

    RtlCreateSecurityDescriptorRelative(
        INewDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( INewDescriptor, NewControlBits );

    Base = (PCHAR)(INewDescriptor);
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Map and Copy in the Sacl
    //

    if (NewControlBits & SE_SACL_PRESENT) {

        if (NewSacl != NULL) {

            RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );

            if (!NewSaclInherited) {
                RtlpApplyAclToObject( (PACL)Field, GenericMapping );
            }

            INewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
            if (NewSaclSize > NewSacl->AclSize) {
                RtlZeroMemory (Field + NewSacl->AclSize, NewSaclSize - NewSacl->AclSize);
            }
            Field += NewSaclSize;

        } else {

            INewDescriptor->Sacl = 0;
        }

    }

    //
    // Map and Copy in the Dacl
    //

    if (NewControlBits & SE_DACL_PRESENT) {

        if (NewDacl != NULL) {

            RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );

            if (!NewDaclInherited) {
                RtlpApplyAclToObject( (PACL)Field, GenericMapping );
            }

            INewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
            if (NewDaclSize > NewDacl->AclSize) {
                RtlZeroMemory (Field + NewDacl->AclSize, NewDaclSize - NewDacl->AclSize);
            }
            Field += NewDaclSize;

        } else {

            INewDescriptor->Dacl = 0;
        }

    }

    //
    // Assign the owner
    //

    RtlCopyMemory( Field, NewOwner, OwnerSize );
    if (NewOwnerSize > OwnerSize) {
        RtlZeroMemory (Field + OwnerSize, NewOwnerSize - OwnerSize);
    }
    INewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if (NewGroup != NULL) {
        RtlCopyMemory( Field, NewGroup, GroupSize );
        if (NewGroupSize > GroupSize) {
            RtlZeroMemory (Field + GroupSize, NewGroupSize - GroupSize);
        }
        INewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    Status = STATUS_SUCCESS;



Cleanup:
    //
    // If we allocated memory for a Server DACL, free it now.
    //

    if (ServerDaclAllocated && ServerDacl != NULL) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( ServerDacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap(RtlProcessHeap(), 0, ServerDacl );
#endif // NTOS_KERNEL_RUNTIME
    }

    //
    // Either an error was encountered or the assignment has completed
    // successfully.  In either case, we have to clean up any memory.
    //

#ifdef NTOS_KERNEL_RUNTIME
//     if ( SubjectSecurityContext != NULL ) {
//         SeUnlockSubjectContext( SubjectSecurityContext );
//     }

    if (SubjectContextInfo != NULL) {
        ExFreePool( SubjectContextInfo );
    }

#else // NTOS_KERNEL_RUNTIME
    RtlFreeHeap( HeapHandle, 0, (PVOID)TokenOwnerInfo );
    RtlFreeHeap( HeapHandle, 0, (PVOID)TokenPrimaryGroupInfo );
    RtlFreeHeap( HeapHandle, 0, (PVOID)TokenDefaultDaclInfo );
    RtlFreeHeap( HeapHandle, 0, (PVOID)ServerOwnerInfo );
    RtlFreeHeap( HeapHandle, 0, (PVOID)ServerGroupInfo );
#endif // NTOS_KERNEL_RUNTIME

    if (NewSaclInherited && NewSacl != NULL ) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( NewSacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, (PVOID)NewSacl );
#endif // NTOS_KERNEL_RUNTIME
    }

    if (NewDaclInherited && NewDacl != NULL ) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( NewDacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, (PVOID)NewDacl );
#endif // NTOS_KERNEL_RUNTIME
    }

    *NewDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;


    return Status;
}


NTSTATUS
RtlpSetSecurityObject (
    IN PVOID Object OPTIONAL,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN ULONG PoolType,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )


/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

                                  - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    Object - Optionally supplies the object whose security is
        being adjusted.  This is used to update security quota
        information.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    AutoInheritFlags - Controls automatic inheritance of ACES.
        Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the
            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the
            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

         SEF_AVOID_PRIVILEGE_CHECK - If set, the Token in not used to ensure the
            Owner passed in ModificationDescriptor is valid.

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the new owner of the
        target security descriptor is not one the caller is authorized to
        assign as the owner of an object, or the client did not pass
        a token at all.

    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly
        provided and the caller is not currently impersonating a client.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates the provided object's security
        descriptor was not in self-relative format.

--*/

{
    BOOLEAN NewGroupPresent = FALSE;
    BOOLEAN NewOwnerPresent = FALSE;

    BOOLEAN ServerAclAllocated = FALSE;
    BOOLEAN LocalDaclAllocated = FALSE;
    BOOLEAN LocalSaclAllocated = FALSE;
    BOOLEAN ServerObject;
    BOOLEAN DaclUntrusted;

    PCHAR Field;
    PCHAR Base;

    PISECURITY_DESCRIPTOR_RELATIVE NewDescriptor = NULL;

    NTSTATUS Status;

    TOKEN_STATISTICS ThreadTokenStatistics;

    ULONG ReturnLength;

    PSID NewGroup;
    PSID NewOwner;

    PACL NewDacl;
    PACL LocalDacl;
    PACL NewSacl;
    PACL LocalSacl;

    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewOwnerSize, OwnerSize;
    ULONG NewGroupSize, GroupSize;
    ULONG AllocationSize;
    ULONG ServerOwnerInfoSize;

    HANDLE PrimaryToken;
    ULONG GenericControl;
    ULONG NewControlBits = SE_SELF_RELATIVE;

    PACL ServerDacl;

    SECURITY_SUBJECT_CONTEXT SubjectContext;


    //
    // Typecast to internal representation of security descriptor.
    // Note that the internal one is not a pointer to a pointer.
    // It is just a pointer to a security descriptor.
    //
    PISECURITY_DESCRIPTOR IModificationDescriptor =
       (PISECURITY_DESCRIPTOR)ModificationDescriptor;

    PISECURITY_DESCRIPTOR *IObjectsSecurityDescriptor =
       (PISECURITY_DESCRIPTOR *)(ObjectsSecurityDescriptor);

#ifndef NTOS_KERNEL_RUNTIME
    PVOID HeapHandle;
#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    // Get the handle to the current process heap
    //

#ifndef NTOS_KERNEL_RUNTIME
    HeapHandle = RtlProcessHeap();
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Validate that the provided SD is in self-relative form
    //

    if ( !RtlpAreControlBitsSet(*IObjectsSecurityDescriptor, SE_SELF_RELATIVE) ) {
        Status = STATUS_BAD_DESCRIPTOR_FORMAT;
        goto Cleanup;
    }

    //
    // Check to see if we need to edit the passed acl
    // either because we're creating a server object, or because
    // we were passed an untrusted ACL.
    //

    if (ARGUMENT_PRESENT(ModificationDescriptor)) {

        if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SERVER_SECURITY)) {
            ServerObject = TRUE;
        } else {
            ServerObject = FALSE;
        }

        if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_UNTRUSTED)) {
            DaclUntrusted = TRUE;
        } else {
            DaclUntrusted = FALSE;
        }

    } else {

        ServerObject = FALSE;
        DaclUntrusted = FALSE;

    }


    //
    // For each item specified in the SecurityInformation, extract it
    // and get it to the point where it can be copied into a new
    // descriptor.
    //

    //
    // if he's setting the owner field, make sure he's
    // allowed to set that value as an owner.
    //

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        NewOwner = RtlpOwnerAddrSecurityDescriptor( IModificationDescriptor );
        NewOwnerPresent = TRUE;

        if ((AutoInheritFlags & SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {

#ifdef NTOS_KERNEL_RUNTIME

            SeCaptureSubjectContext( &SubjectContext );

            if (!SepValidOwnerSubjectContext( &SubjectContext, NewOwner, ServerObject ) ) {

                SeReleaseSubjectContext( &SubjectContext );
                return( STATUS_INVALID_OWNER );

            } else {

                SeReleaseSubjectContext( &SubjectContext );
            }
#else // NTOS_KERNEL_RUNTIME

            if ( ARGUMENT_PRESENT( Token )) {

                Status = NtQueryInformationToken(
                             Token,                        // Handle
                             TokenStatistics,              // TokenInformationClass
                             &ThreadTokenStatistics,       // TokenInformation
                             sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                             &ReturnLength                 // ReturnLength
                             );

                if (!NT_SUCCESS( Status )) {
                    goto Cleanup;
                }

                //
                //  If it is an impersonation token, then make sure it is at a
                //  high enough level.
                //

                if (ThreadTokenStatistics.TokenType == TokenImpersonation) {

                    if (ThreadTokenStatistics.ImpersonationLevel < SecurityIdentification ) {
                        Status = STATUS_BAD_IMPERSONATION_LEVEL;
                        goto Cleanup;
                    }
                }

            } else {

                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }

            if (!RtlpValidOwnerSubjectContext(
                    Token,
                    NewOwner,
                    ServerObject,
                    &Status) ) {

                    Status = STATUS_INVALID_OWNER;
                    goto Cleanup;
            }
#endif // NTOS_KERNEL_RUNTIME
        }

    } else {

        NewOwner = RtlpOwnerAddrSecurityDescriptor ( *IObjectsSecurityDescriptor );
        if (NewOwner == NULL) {
            Status = STATUS_INVALID_OWNER;
            goto Cleanup;
        }

    }
    ASSERT( NewOwner != NULL );
    if (!RtlValidSid( NewOwner )) {
        Status = STATUS_INVALID_OWNER;
        goto Cleanup;
    }


    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        NewGroup = RtlpGroupAddrSecurityDescriptor(IModificationDescriptor);
        NewGroupPresent = TRUE;

    } else {

        NewGroup = RtlpGroupAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }

    if (NewGroup != NULL) {
        if (!RtlValidSid( NewGroup )) {
            Status = STATUS_INVALID_PRIMARY_GROUP;
            goto Cleanup;
        }
    } else {
        Status = STATUS_INVALID_PRIMARY_GROUP;
        goto Cleanup;
    }


    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

#ifdef  ASSERT_ON_NULL_DACL

        //
        // Culprit will probably be the caller NtSetSecurityObject, or
        // RtlSetSecurityObject. 
        // 

        if (RtlpAssertOnNullDacls) {

            ASSERT(("NULL DACLs are NOT allowed!",
                    RtlpDaclAddrSecurityDescriptor(IModificationDescriptor) != NULL));
        }
#endif // ASSERT_ON_NULL_DACL

        //
        // If AutoInherit is requested,
        //  build a merged ACL.
        //

        if ( AutoInheritFlags & SEF_DACL_AUTO_INHERIT ) {
            Status = RtlpComputeMergedAcl(
                        RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
                        SeControlDaclToGeneric( (*IObjectsSecurityDescriptor)->Control ),
                        RtlpDaclAddrSecurityDescriptor( IModificationDescriptor ),
                        SeControlDaclToGeneric( IModificationDescriptor->Control ),
                        NewOwner,
                        NewGroup,
                        GenericMapping,
                        FALSE,      // Not a SACL
                        &LocalDacl,
                        &GenericControl );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            LocalDaclAllocated = TRUE;
            NewDacl = LocalDacl;
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= SeControlGenericToDacl( GenericControl );

        //
        // If AutoInherit isn't requested,
        //  just grab a copy of the input DACL.
        //

        } else {
            NewDacl = RtlpDaclAddrSecurityDescriptor( IModificationDescriptor );
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= IModificationDescriptor->Control & SE_DACL_PROTECTED;

            //
            // If the original caller claims he understands auto inheritance,
            //  preserve the AutoInherited flag.
            //

            if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED) ) {
                NewControlBits |= SE_DACL_AUTO_INHERITED;
            }
        }

        if (ServerObject) {

#ifdef NTOS_KERNEL_RUNTIME

            PSID SubjectContextOwner;
            PSID SubjectContextGroup;
            PSID SubjectContextServerOwner;
            PSID SubjectContextServerGroup;
            PACL SubjectContextDacl;

            SeCaptureSubjectContext( &SubjectContext );

            SepGetDefaultsSubjectContext(
                &SubjectContext,
                &SubjectContextOwner,
                &SubjectContextGroup,
                &SubjectContextServerOwner,
                &SubjectContextServerGroup,
                &SubjectContextDacl
                );

            Status = RtlpCreateServerAcl(
                         NewDacl,
                         DaclUntrusted,
                         SubjectContextServerOwner,
                         &ServerDacl,
                         &ServerAclAllocated
                         );

            SeReleaseSubjectContext( &SubjectContext );
#else // NTOS_KERNEL_RUNTIME
            PTOKEN_OWNER ServerSid;

            //
            // Obtain the default Server SID to substitute in the
            // ACL if necessary.
            //

            ServerOwnerInfoSize = RtlLengthRequiredSid( SID_MAX_SUB_AUTHORITIES );

            ServerSid = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), ServerOwnerInfoSize );

            if (ServerSid == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &PrimaryToken
                         );

            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( HeapHandle, 0, ServerSid );
                goto Cleanup;
            }

            Status = NtQueryInformationToken(
                         PrimaryToken,                 // Handle
                         TokenOwner,                   // TokenInformationClass
                         ServerSid,                    // TokenInformation
                         ServerOwnerInfoSize,          // TokenInformationLength
                         &ServerOwnerInfoSize          // ReturnLength
                         );

            NtClose( PrimaryToken );

            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( HeapHandle, 0, ServerSid );
                goto Cleanup;
            }

            Status = RtlpCreateServerAcl(
                         NewDacl,
                         DaclUntrusted,
                         ServerSid->Owner,
                         &ServerDacl,
                         &ServerAclAllocated
                         );

            RtlFreeHeap( HeapHandle, 0, ServerSid );
#endif // NTOS_KERNEL_RUNTIME

            if (!NT_SUCCESS( Status )) {
                goto Cleanup;
            }

            NewDacl = ServerDacl;

        }

    } else {

        NewDacl = RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }



    if (SecurityInformation & SACL_SECURITY_INFORMATION) {


        //
        // If AutoInherit is requested,
        //  build a merged ACL.
        //

        if ( AutoInheritFlags & SEF_SACL_AUTO_INHERIT ) {
            Status = RtlpComputeMergedAcl(
                        RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
                        SeControlSaclToGeneric( (*IObjectsSecurityDescriptor)->Control ),
                        RtlpSaclAddrSecurityDescriptor( IModificationDescriptor ),
                        SeControlSaclToGeneric( IModificationDescriptor->Control ),
                        NewOwner,
                        NewGroup,
                        GenericMapping,
                        TRUE,      // Is a SACL
                        &LocalSacl,
                        &GenericControl );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            LocalSaclAllocated = TRUE;
            NewSacl = LocalSacl;
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= SeControlGenericToSacl( GenericControl );
        } else {
            NewSacl = RtlpSaclAddrSecurityDescriptor( IModificationDescriptor );
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= IModificationDescriptor->Control & SE_SACL_PROTECTED;

            //
            // If the original caller claims he understands auto inheritance,
            //  preserve the AutoInherited flag.
            //

            if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SACL_AUTO_INHERIT_REQ|SE_SACL_AUTO_INHERITED) ) {
                NewControlBits |= SE_SACL_AUTO_INHERITED;
            }
        }

    } else {

        NewSacl = RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }


    //
    // Everything is assignable by the requestor.
    // Calculate the memory needed to house all the information in
    // a self-relative security descriptor.
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    OwnerSize = SeLengthSid(NewOwner);
    NewOwnerSize = LongAlignSize(OwnerSize);

    if (NewGroup != NULL) {
        GroupSize = SeLengthSid(NewGroup);
    } else {
        GroupSize = 0;
    }
    NewGroupSize = LongAlignSize(GroupSize);

    if (NewSacl != NULL) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if (NewDacl !=NULL) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //

#ifdef NTOS_KERNEL_RUNTIME
    NewDescriptor = ExAllocatePoolWithTag(PoolType, AllocationSize, 'dSeS');
#else // NTOS_KERNEL_RUNTIME
    NewDescriptor = RtlAllocateHeap( HeapHandle, MAKE_TAG( SE_TAG ), AllocationSize );
#endif // NTOS_KERNEL_RUNTIME

    if ( NewDescriptor == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = RtlCreateSecurityDescriptorRelative(
                 NewDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    ASSERT( NT_SUCCESS( Status ) );

#ifdef NTOS_KERNEL_RUNTIME
    //
    // We must check to make sure that the Group and Dacl size
    // do not exceed the quota preallocated for this object's
    // security when it was created.
    //
    // Update SeComputeSecurityQuota if this changes.
    //


    if (ARGUMENT_PRESENT( Object )) {

        Status = ObValidateSecurityQuota(
                     Object,
                     NewGroupSize + NewDaclSize
                     );

        if (!NT_SUCCESS( Status )) {

            //
            // The new information is too big.
            //

            ExFreePool( NewDescriptor );
            goto Cleanup;
        }

    }
#endif // NTOS_KERNEL_RUNTIME


    Base = (PCHAR)NewDescriptor;
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Map and Copy in the Sacl
    //


    //         if new item {
    //             PRESENT=TRUE
    //             DEFAULTED=FALSE
    //             if (NULL) {
    //                 set new pointer to NULL
    //             } else {
    //                 copy into new SD
    //             }
    //         } else {
    //             copy PRESENT bit
    //             copy DEFAULTED bit
    //             if (NULL) {
    //                 set new pointer to NULL
    //             } else {
    //                 copy old one into new SD
    //             }
    //         }

    RtlpSetControlBits( NewDescriptor, NewControlBits );


    if (IModificationDescriptor->Control & SE_RM_CONTROL_VALID) {
        NewDescriptor->Sbz1 = IModificationDescriptor->Sbz1;
        NewDescriptor->Control |= SE_RM_CONTROL_VALID;
    }

    if (NewSacl == NULL) {
        NewDescriptor->Sacl = 0;

    } else {
        RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );
        RtlpApplyAclToObject( (PACL)Field, GenericMapping );
        NewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
        if (NewSaclSize > NewSacl->AclSize) {
            RtlZeroMemory( Field + NewSacl->AclSize, NewSaclSize - NewSacl->AclSize);
        }
        Field += NewSaclSize;
    }




    if ( (NewControlBits & SE_SACL_PRESENT) == 0 ) {

        //
        // Propagate the SE_SACL_DEFAULTED and SE_SACL_PRESENT
        // bits from the old security descriptor into the new
        // one.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_SACL_DEFAULTED | SE_SACL_PRESENT | SE_SACL_PROTECTED | SE_SACL_AUTO_INHERITED
            );

    }



    //
    // Fill in Dacl field in new SD
    //

    if (NewDacl == NULL) {
        NewDescriptor->Dacl = 0;

    } else {
        RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );
        RtlpApplyAclToObject( (PACL)Field, GenericMapping );
        NewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
        if (NewDaclSize > NewDacl->AclSize) {
            RtlZeroMemory( Field + NewDacl->AclSize, NewDaclSize - NewDacl->AclSize);
        }
        Field += NewDaclSize;
    }


    if ( (NewControlBits & SE_DACL_PRESENT) == 0 ) {

        //
        // Propagate the SE_DACL_DEFAULTED and SE_DACL_PRESENT
        // bits from the old security descriptor into the new
        // one.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_DACL_DEFAULTED | SE_DACL_PRESENT | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED
            );

    }

//         if new item {
//             PRESENT=TRUE
//             DEFAULTED=FALSE
//             if (NULL) {
//                 set new pointer to NULL
//             } else {
//                 copy into new SD
//             }
//         } else {
//             copy PRESENT bit
//             copy DEFAULTED bit
//             if (NULL) {
//                 set new pointer to NULL
//             } else {
//                 copy old one into new SD
//             }
//         }


    //
    // Fill in Owner field in new SD
    //

    RtlCopyMemory( Field, NewOwner, OwnerSize );
    if (OwnerSize < NewOwnerSize) {
        RtlZeroMemory( Field + OwnerSize, NewOwnerSize - OwnerSize );
    }
    NewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if (!NewOwnerPresent) {

        //
        // Propagate the SE_OWNER_DEFAULTED bit from the old SD.
        // If a new owner is being assigned, we want to leave
        // SE_OWNER_DEFAULTED off, which means leave it alone.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_OWNER_DEFAULTED
            );

    } else {
        ASSERT( !RtlpAreControlBitsSet( NewDescriptor, SE_OWNER_DEFAULTED ) );
    }


    //
    // Fill in Group field in new SD
    //

    if ( NewGroup != NULL) {
        RtlCopyMemory( Field, NewGroup, GroupSize );
        if (GroupSize < NewGroupSize) {
            RtlZeroMemory( Field + GroupSize, NewGroupSize - GroupSize);
        }
        NewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    if (!NewGroupPresent) {

        //
        // Propagate the SE_GROUP_DEFAULTED bit from the old SD
        // If a new owner is being assigned, we want to leave
        // SE_GROUP_DEFAULTED off, which means leave it alone.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_GROUP_DEFAULTED
            );
    } else {
        ASSERT( !RtlpAreControlBitsSet( NewDescriptor, SE_GROUP_DEFAULTED ) );

    }

    //
    // Free old descriptor
    //

    // Kernel version doesn't free the old descriptor
#ifndef NTOS_KERNEL_RUNTIME
    RtlFreeHeap( HeapHandle, 0, (PVOID) *IObjectsSecurityDescriptor );
#endif // NTOS_KERNEL_RUNTIME

    *ObjectsSecurityDescriptor = (PSECURITY_DESCRIPTOR)NewDescriptor;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( LocalDaclAllocated ) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( LocalDacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, LocalDacl );
#endif // NTOS_KERNEL_RUNTIME
    }
    if ( LocalSaclAllocated ) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( LocalSacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, LocalSacl );
#endif // NTOS_KERNEL_RUNTIME
    }
    if (ServerAclAllocated) {
#ifdef NTOS_KERNEL_RUNTIME
        ExFreePool( ServerDacl );
#else // NTOS_KERNEL_RUNTIME
        RtlFreeHeap( HeapHandle, 0, ServerDacl );
#endif // NTOS_KERNEL_RUNTIME
    }

    return( Status );
}

BOOLEAN RtlpValidateSDOffsetAndSize (
    IN ULONG   Offset,
    IN ULONG   Length,
    IN ULONG   MinLength,
    OUT PULONG MaxLength
    )
/*++

Routine Description:

    This procedure validates offsets within a SecurityDescriptor.
    It checks that the structure can have the minimum length,
    not overlap with the fixed header and returns the maximum size
    of the item and longword alignment.

Arguments:

    Offset - Offset from start of SD of structure to validate
    Length - Total size of SD
    MinLength - Minimum size this structure can be
    MaxLength - Retuns the maximum length this item can be given by
                the enclosing structure.

Return Value:

    BOOLEAN - TRUE if the item is valid


--*/

{
    ULONG Left;

    *MaxLength = 0;
    //
    // Don't allow overlap with header just in case caller modifies control bits etc
    //
    if (Offset < sizeof (SECURITY_DESCRIPTOR_RELATIVE)) {
       return FALSE;
    }

    //
    // Don't allow offsets beyond the end of the buffer
    //
    if (Offset >= Length) {
       return FALSE;
    }

    //
    // Calculate maximim size of segment and check its limits
    //
    Left = Length - Offset;

    if (Left < MinLength) {
       return FALSE;
    }

    //
    // Reject unaligned offsets
    //
    if (Offset & (sizeof (ULONG) - 1)) {
       return FALSE;
    }
    *MaxLength = Left;
    return TRUE;
}


BOOLEAN
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    )

/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure
    contained within a flat buffer.  This involves validating
    the revision levels of each component of the security
    descriptor.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.
    SecurityDescriptorLength - Size of flat buffer containing the security
        descriptor.
    RequiredInformation - Which SD components must be present to be valid.
        OWNER_SECURITY_INFORMATION etc as a bit mask.
        OWNER_SECURITY_INFORMATION - There must be a valid owner SID
        GROUP_SECURITY_INFORMATION - There must be a valid group SID
        DACL_SECURITY_INFORMATION - Ignored
        SACL_SECURITY_INFORMATION - Ignored

Return Value:

    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.


--*/

{
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor;
    PISID OwnerSid;
    PISID GroupSid;
    PACE_HEADER Ace;
    PACL Dacl;
    PACL Sacl;
    ULONG MaxOwnerSidLength;
    ULONG MaxGroupSidLength;
    ULONG MaxDaclLength;
    ULONG MaxSaclLength;

    if (SecurityDescriptorLength < sizeof(SECURITY_DESCRIPTOR_RELATIVE)) {
        return FALSE;
    }

    //
    // Check the revision information.
    //

    if (((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)->Revision !=
             SECURITY_DESCRIPTOR_REVISION) {
        return FALSE;
    }

    //
    // Make sure the passed SecurityDescriptor is in self-relative form
    //

    if (!(((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)->Control & SE_SELF_RELATIVE)) {
        return FALSE;
    }

    SecurityDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE) SecurityDescriptorInput;

    //
    // Validate the owner if it's there and see if its allowed to be missing
    //
    if (SecurityDescriptor->Owner == 0) {
        if (RequiredInformation & OWNER_SECURITY_INFORMATION) {
            return FALSE;
        }
    } else {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Owner,
                                          SecurityDescriptorLength,
                                          sizeof (SID),
                                          &MaxOwnerSidLength)) {
            return FALSE;
        }
        //
        // It is safe to reference the owner's SubAuthorityCount, compute the
        // expected length of the SID
        //

        OwnerSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
                                             SecurityDescriptor->Owner);

        if (OwnerSid->Revision != SID_REVISION) {
            return FALSE;
        }

        if (OwnerSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
            return FALSE;
        }

        if (MaxOwnerSidLength < (ULONG) SeLengthSid (OwnerSid)) {
            return FALSE;
        }

    }

    //
    // The owner appears to be a structurally valid SID that lies within
    // the bounds of the security descriptor.  Do the same for the Group
    // if there is one.
    //
    //
    // Validate the group if it's there and see if its allowed to be missing
    //
    if (SecurityDescriptor->Group == 0) {
        if (RequiredInformation & GROUP_SECURITY_INFORMATION) {
            return FALSE;
        }
    } else {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Group,
                                          SecurityDescriptorLength,
                                          sizeof (SID),
                                          &MaxGroupSidLength)) {
            return FALSE;
        }
        //
        // It is safe to reference the group's SubAuthorityCount, compute the
        // expected length of the SID
        //

        GroupSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
                                             SecurityDescriptor->Group);

        if (GroupSid->Revision != SID_REVISION) {
            return FALSE;
        }

        if (GroupSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
            return FALSE;
        }

        if (MaxGroupSidLength < (ULONG) SeLengthSid (GroupSid)) {
             return FALSE;
        }

    }

    //
    // Validate the DACL if it's there and check if its allowed to be missing.
    //

    if (!RtlpAreControlBitsSet (SecurityDescriptor, SE_DACL_PRESENT)) {
//
// Some code does this kind of thing:
//
// InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
// RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, &sd) )
//
// With the current system this works the same as passing in a NULL DACL but it looks
// almost by accident
//
//        if (RequiredInformation & DACL_SECURITY_INFORMATION) {
//            return FALSE;
//        }
    } else if (SecurityDescriptor->Dacl) {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Dacl,
                                          SecurityDescriptorLength,
                                          sizeof (ACL),
                                          &MaxDaclLength)) {
            return FALSE;
        }

        Dacl = (PACL) RtlOffsetToPointer (SecurityDescriptor,
                                          SecurityDescriptor->Dacl);

        //
        // Make sure the DACL length fits within the bounds of the security descriptor.
        //
        if (MaxDaclLength < Dacl->AclSize) {
            return FALSE;
        }

        //
        // Make sure the ACL is structurally valid.
        //
        if (!RtlValidAcl (Dacl)) {
            return FALSE;
        }
    }

    //
    // Validate the SACL if it's there and check if its allowed to be missing.
    //

    if (!RtlpAreControlBitsSet (SecurityDescriptor, SE_SACL_PRESENT)) {
//        if (RequiredInformation & SACL_SECURITY_INFORMATION) {
//            return FALSE;
//        }
    } else if (SecurityDescriptor->Sacl) {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Sacl,
                                          SecurityDescriptorLength,
                                          sizeof (ACL),
                                          &MaxSaclLength)) {
            return FALSE;
        }

        Sacl = (PACL) RtlOffsetToPointer (SecurityDescriptor,
                                          SecurityDescriptor->Sacl);

        //
        // Make sure the SACL length fits within the bounds of the security descriptor.
        //

        if (MaxSaclLength < Sacl->AclSize) {
            return FALSE;
        }

        //
        // Make sure the ACL is structurally valid.
        //

        if (!RtlValidAcl (Sacl)) {
            return FALSE;
        }
    }

    return TRUE;
}





BOOLEAN
RtlGetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    )

/*++

Routine Description:

    This procedure returns the RM Control flags from a SecurityDescriptor if
    SE_RM_CONTROL_VALID flags is present in the control field.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
    RMControl          - Returns the flags in the SecurityDescriptor if
                         SE_RM_CONTROL_VALID is set in the control bits of the
                         SecurityDescriptor.


Return Value:

    BOOLEAN - TRUE if SE_RM_CONTROL_VALID is set in the Control bits of the
              SecurityDescriptor.

Note:
    Parameter validation has already been done in Advapi.


--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;

    if (!(ISecurityDescriptor->Control & SE_RM_CONTROL_VALID))
    {
        *RMControl = 0;
        return FALSE;
    }

    *RMControl = ISecurityDescriptor->Sbz1;

    return TRUE;
}


BOOLEAN
RtlpGuidPresentInGuidList(
    IN GUID *InheritedObjectType,
    IN GUID **pNewObjectType,
    IN ULONG GuidCount
    )

/*++

Routine Description:

    This routine returns whether a given guid is present in a list of guids.

Arguments:

    InheritedObjectType - Guid from the ace that will be compared against 
        the object types for the object.
        
    pNewObjectType - List of types of object being inherited to.

    GuidCount - Number of object types in the list.


Return Value:

    Returns TRUE if the given guid is present in the list of guids.
    FALSE otherwise.

--*/

{
    ULONG i;

    for (i = 0; i < GuidCount; i++) {

        if (RtlEqualMemory(
                InheritedObjectType,
                pNewObjectType[i],
                sizeof(GUID) ) ) {

            return TRUE;
        }

    }

    return FALSE;
}


VOID
RtlSetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the RM Control flag in the control field of
    SecurityDescriptor and sets Sbz1 to the the byte to which RMContol points.
    If RMControl is NULL then the bits are cleared.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
    RMControl          - Pointer to the flags to set. If NULL then the bits
                         are cleared.

Note:
    Parameter validation has already been done in Advapi.


--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;

    if (ARGUMENT_PRESENT(RMControl)) {
        ISecurityDescriptor->Control |= SE_RM_CONTROL_VALID;
        ISecurityDescriptor->Sbz1 = *RMControl;
    } else {
        ISecurityDescriptor->Control &= ~SE_RM_CONTROL_VALID;
        ISecurityDescriptor->Sbz1 = 0;
    }
}

#endif // #ifndef BLDR_KERNEL_RUNTIME

NTSTATUS
RtlMapSecurityErrorToNtStatus(
    IN SECURITY_STATUS Error
    )
/*++

Routine Description:

    This procedure maps a security HRESULT to the proper NTSTATUS code.
    
Arguments:

    Error - a security HRESULT
    
Return Value:  The NTSTATUS code corresponding to the HRESULT. If no
               status code can be mapped, the original error is returned.

Note:
    


--*/
{
    NTSTATUS Status;

    switch(Error) {
    case SEC_E_INSUFFICIENT_MEMORY : Status = STATUS_INSUFFICIENT_RESOURCES; break;
    case SEC_E_INVALID_HANDLE : Status = STATUS_INVALID_HANDLE; break;
    case SEC_E_UNSUPPORTED_FUNCTION : Status = STATUS_NOT_SUPPORTED; break;
    case SEC_E_TARGET_UNKNOWN : Status = STATUS_BAD_NETWORK_PATH; break;
    case SEC_E_INTERNAL_ERROR : Status = STATUS_INTERNAL_ERROR; break;
    case SEC_E_SECPKG_NOT_FOUND : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_NOT_OWNER : Status = STATUS_PRIVILEGE_NOT_HELD; break;
    case SEC_E_CANNOT_INSTALL : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_INVALID_TOKEN : Status = STATUS_INVALID_PARAMETER; break;
    case SEC_E_CANNOT_PACK : Status = STATUS_INVALID_PARAMETER; break;
    case SEC_E_QOP_NOT_SUPPORTED : Status = STATUS_NOT_SUPPORTED; break;
    case SEC_E_NO_IMPERSONATION : Status = STATUS_CANNOT_IMPERSONATE; break;
    case SEC_E_LOGON_DENIED : Status = STATUS_LOGON_FAILURE; break;
    case SEC_E_UNKNOWN_CREDENTIALS : Status = STATUS_NO_SUCH_LOGON_SESSION; break;
    case SEC_E_NO_CREDENTIALS : Status = STATUS_NO_SUCH_LOGON_SESSION; break;
    case SEC_E_MESSAGE_ALTERED : Status = STATUS_ACCESS_DENIED; break;
    case SEC_E_OUT_OF_SEQUENCE : Status = STATUS_ACCESS_DENIED; break;
    case SEC_E_NO_AUTHENTICATING_AUTHORITY : Status = STATUS_NO_LOGON_SERVERS; break;
    case SEC_E_BAD_PKGID : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_TIME_SKEW : Status = STATUS_TIME_DIFFERENCE_AT_DC; break;

    default: Status = (NTSTATUS) Error;
    }

    return(Status);
}

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\str2addw.c ===
//
// Without this define, link errors can occur due to missing _pctype and
// __mb_cur_max
//
#define _CTYPE_DISABLE_MACROS

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdlib.h>
#include <tchar.h>

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressW
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressW
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExW
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExW

#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\str2addt.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    str2addt.h

Abstract:

    Code file for IP string-to-address translation routines.

Author:

    Dave Thaler (dthaler)   3-28-2001

Revision History:

    IPv4 conversion code originally from old winsock code
    IPv6 conversion code originally by Rich Draves (richdr)

--*/

struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
};
#define s6_bytes   u.Byte
#define s6_words   u.Word

struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
};
#define s_addr  S_un.S_addr

//
// Define some versions of crt functions which are not affected by locale.
//
#define ISDIGIT(c)  (_istascii(c) && _istdigit(c))
#define ISLOWER(c)  (_istascii(c) && _istlower(c))
#define ISXDIGIT(c) (_istascii(c) && _istxdigit(c))

#define INADDR_NONE 0xffffffff

NTSTATUS
RtlIpv6StringToAddressT(
    IN LPCTSTR S,
    OUT LPCTSTR *Terminator,
    OUT struct in6_addr *Addr
    )

/*++

Routine Description:

    Parses the string S as an IPv6 address. See RFC 1884.
    The basic string representation consists of 8 hex numbers
    separated by colons, with a couple embellishments:
    - a string of zero numbers (at most one) may be replaced
    with a double-colon. Double-colons are allowed at beginning/end
    of the string.
    - the last 32 bits may be represented in IPv4-style dotted-octet notation.

    For example,
        ::
        ::1
        ::157.56.138.30
        ::ffff:156.56.136.75
        ff01::
        ff02::2
        0:1:2:3:4:5:6:7

Arguments:

    S - RFC 1884 string representation of an IPv6 address.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives the IPv6 address.

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    enum { Start, InNumber, AfterDoubleColon } state = Start;
    const TCHAR *number = NULL;
    BOOLEAN sawHex;
    ULONG numColons = 0, numDots = 0, numDigits = 0;
    ULONG sawDoubleColon = 0;
    ULONG i = 0;
    TCHAR c;

    // There are a several difficulties here. For one, we don't know
    // when we see a double-colon how many zeroes it represents.
    // So we just remember where we saw it and insert the zeroes
    // at the end. For another, when we see the first digits
    // of a number we don't know if it is hex or decimal. So we
    // remember a pointer to the first character of the number
    // and convert it after we see the following character.

    while (c = *S) {

        switch (state) {
        case Start:
            if (c == _T(':')) {

                // this case only handles double-colon at the beginning

                if (numDots > 0)
                    goto Finish;
                if (numColons > 0)
                    goto Finish;
                if (S[1] != _T(':'))
                    goto Finish;

                sawDoubleColon = 1;
                numColons = 2;
                Addr->s6_words[i++] = 0; // pretend it was 0::
                S++;
                state = AfterDoubleColon;

            } else
        case AfterDoubleColon:
            if (ISDIGIT(c)) {

                sawHex = FALSE;
                number = S;
                state = InNumber;
                numDigits = 1;

            } else if (ISXDIGIT(c)) {

                if (numDots > 0)
                    goto Finish;

                sawHex = TRUE;
                number = S;
                state = InNumber;
                numDigits = 1;

            } else
                goto Finish;
            break;

        case InNumber:
            if (ISDIGIT(c)) {

                numDigits++;

                // remain in InNumber state

            } else if (ISXDIGIT(c)) {

                numDigits++;

                if (numDots > 0)
                    goto Finish;

                sawHex = TRUE;
                // remain in InNumber state;

            } else if (c == _T(':')) {

                if (numDots > 0)
                    goto Finish;
                if (numColons > 6)
                    goto Finish;

                if (S[1] == _T(':')) {

                    if (sawDoubleColon)
                        goto Finish;
                    if (numColons > 5)
                        goto Finish;

                    sawDoubleColon = numColons+1;
                    numColons += 2;
                    S++;
                    state = AfterDoubleColon;

                } else {
                    numColons++;
                    state = Start;
                }

            } else if (c == _T('.')) {

                if (sawHex)
                    goto Finish;
                if (numDots > 2)
                    goto Finish;
                if (numColons > 6)
                    goto Finish;
                numDots++;
                state = Start;

            } else
                goto Finish;
            break;
        }

        // If we finished a number, parse it.

        if ((state != InNumber) && (number != NULL)) {

            // Note either numDots > 0 or numColons > 0,
            // because something terminated the number.

            if (numDots == 0) {
                if (numDigits > 4)
                    return STATUS_INVALID_PARAMETER;
                Addr->s6_words[i++] =
                    RtlUshortByteSwap((USHORT) _tcstol(number, NULL, 16));
            } else {
                ULONG Temp;
                if (numDigits > 3)
                    return STATUS_INVALID_PARAMETER;
                Temp = _tcstol(number, NULL, 10);
                if (Temp > 255) 
                    return STATUS_INVALID_PARAMETER;
                Addr->s6_bytes[2*i + numDots-1] = (UCHAR) Temp;
            }
        }

        S++;
    }

Finish:
    *Terminator = S;

    // Check that we have a complete address.

    if (numDots == 0)
        ;
    else if (numDots == 3)
        numColons++;
    else
        return STATUS_INVALID_PARAMETER;

    if (sawDoubleColon)
        ;
    else if (numColons == 7)
        ;
    else
        return STATUS_INVALID_PARAMETER;

    // Parse the last number, if necessary.

    if (state == InNumber) {

        if (numDots == 0) {
            if (numDigits > 4)
                return STATUS_INVALID_PARAMETER;
            Addr->s6_words[i] =
                RtlUshortByteSwap((USHORT) _tcstol(number, NULL, 16));
        } else {
            ULONG Temp;
            if (numDigits > 3)
                return STATUS_INVALID_PARAMETER;
            Temp = _tcstol(number, NULL, 10);
            if (Temp > 255) 
                return STATUS_INVALID_PARAMETER;
            Addr->s6_bytes[2*i + numDots] = (UCHAR) Temp;
        }

    } else if (state == AfterDoubleColon) {

        Addr->s6_words[i] = 0; // pretend it was ::0

    } else
        return STATUS_INVALID_PARAMETER;

    // Insert zeroes for the double-colon, if necessary.

    if (sawDoubleColon) {

        RtlMoveMemory(&Addr->s6_words[sawDoubleColon + 8 - numColons],
                      &Addr->s6_words[sawDoubleColon],
                      (numColons - sawDoubleColon) * sizeof(USHORT));
        RtlZeroMemory(&Addr->s6_words[sawDoubleColon],
                      (8 - numColons) * sizeof(USHORT));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlIpv6StringToAddressExT (
    IN LPCTSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to Address, port number and scope id. 

    The syntax is address%scope-id or [address%scope-id]:port, where 
    the scope-id and port are optional.
    Note that since the IPv6 address format uses a varying number
    of ':' characters, the IPv4 convention of address:port cannot
    be supported without the braces.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Address - Receive address part (in6_addr) of this address.

    ScopeId - Receive scopeid of this address. If there is no scope id in
             the address string, 0 is returned. 

    Port - Receive port number of this address. If there is no port number 
          in the string, 0 is returned. Port is returned in network byte order.

Return Value:

    NT_STATUS - STATUS_SUCCESS if successful, NT error code if not.

--*/

{
    LPTSTR Terminator;
    ULONG TempScopeId;
    USHORT TempPort;
    TCHAR Ch;
    BOOLEAN ExpectBrace;

    //
    // Quick sanity checks.
    //
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (ScopeId == NULL) ||
        (Port == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    TempPort = 0;
    TempScopeId = 0;
    ExpectBrace = FALSE;
    if (*AddressString == _T('[')) {
        ExpectBrace = TRUE;
        AddressString++;
    }

    if (!NT_SUCCESS(RtlIpv6StringToAddressT(AddressString, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We have parsed the address, check for a scope-id.
    //
    if (*Terminator == _T('%')) {
        Terminator++;
        Ch = *Terminator;
        if (!ISDIGIT(Ch)) {
            return STATUS_INVALID_PARAMETER;
        }
        while ((Ch != 0) && (Ch != _T(']'))) {
            if (!ISDIGIT(Ch)) {
                return STATUS_INVALID_PARAMETER;
            }
            //
            // first check the possibility of overflow
            //
            if (((ULONGLONG)TempScopeId * 10 + Ch - _T('0')) >  
                0xFFFFFFFF) {
                return STATUS_INVALID_PARAMETER;
            }
            TempScopeId = 10 * TempScopeId + (Ch - _T('0'));
            Terminator++;
            Ch = *Terminator;
        }
        
    }

    //
    // When we come here, the current char should either be the
    // end of the string or ']' if expectbrace is true. 
    //
    if (*Terminator == _T(']')) {
        if (!ExpectBrace) {
            return STATUS_INVALID_PARAMETER;
        }
        ExpectBrace = FALSE;
        Terminator++;
        //
        // See if we have a port to parse.
        //
        if (*Terminator == _T(':')) {
            USHORT Base;
            Terminator++;
            Base = 10;
            if (*Terminator == _T('0')) {
                Base = 8;
                Terminator++;         
                if ((*Terminator == _T('x')) || 
                    (*Terminator == _T('X'))) {
                    Base = 16;
                    Terminator++;
                }
            }
            Ch = *Terminator;
            while (Ch != 0) {
                if (ISDIGIT(Ch) && (Ch - _T('0')) < Base) {
                    //
                    // check the possibility for overflow first
                    //
                    if (((ULONG)TempPort * Base + Ch - _T('0')) >  
                         0xFFFF) {
                        return STATUS_INVALID_PARAMETER; 
                    }
                    TempPort = (TempPort * Base) + (Ch - _T('0'));
                } else if (Base == 16 && ISXDIGIT(Ch)) {
                    //
                    // check the possibility for overflow
                    //
                    if ((((ULONG)TempPort << 4) + Ch + 10 - 
                        (ISLOWER(Ch)? _T('a') : _T('A'))) > 0xFFFF) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    TempPort = (TempPort << 4);
                    TempPort += Ch + 10 - (ISLOWER(Ch)? _T('a') : _T('A')); 
                } else {
                    return STATUS_INVALID_PARAMETER;
                }
                Terminator++;
                Ch = *Terminator;
            }
        }       
    }

    //
    // We finished parsing address, scope id and port number. We are expecting the
    // end of the string. 
    //
    if ((*Terminator != 0) || ExpectBrace) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now construct the address.
    //
    *Port = RtlUshortByteSwap(TempPort);
    *ScopeId = TempScopeId;
    return STATUS_SUCCESS;
} 

NTSTATUS
RtlIpv4StringToAddressT(
    IN LPCTSTR String,
    IN BOOLEAN Strict,
    OUT LPCTSTR *Terminator,
    OUT struct in_addr *Addr
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Strict - If TRUE, the string must be dotted-decimal with 4 parts.
             Otherwise, any of the four forms are allowed, with decimal,
             octal, or hex.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives a pointer to the structure to fill in with
        a suitable binary representation of the Internet address given. 

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    ULONG val, n;
    LONG base;
    TCHAR c;
    ULONG parts[4], *pp = parts;
    BOOLEAN sawDigit;

again:
    //
    // We must see at least one digit for address to be valid.
    //
    sawDigit=FALSE; 

    //
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; 
    base = 10;
    if (*String == _T('0')) {
        String++;
        if (ISDIGIT(*String)) {
            base = 8;
        } else if (*String == _T('x') || *String == _T('X')) {
            base = 16;
            String++;
        } else {
            //
            // It is still decimal but we saw the digit
            // and it was 0.
            //
            sawDigit = TRUE;
        }
    }
    if (Strict && (base != 10)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    while ((c = *String)!= 0) {
        ULONG newVal;
        if (ISDIGIT(c) && ((c - _T('0')) < base)) {
            newVal = (val * base) + (c - _T('0'));
        } else if ((base == 16) && ISXDIGIT(c)) {
            newVal = (val << 4) + (c + 10 - (ISLOWER(c) ? _T('a') : _T('A')));
        } else {
            break;
        }

        //
        // Protect from overflow
        //
        if (newVal < val) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        String++;
        sawDigit = TRUE;
        val = newVal;
    }
    if (*String == _T('.')) {
        //
        // Internet format:
        //      a.b.c.d
        //      a.b.c   (with c treated as 16-bits)
        //      a.b     (with b treated as 24 bits)
        //
        if (pp >= parts + 3) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        *pp++ = val, String++;

        //
        // Check if we saw at least one digit.
        //
        if (!sawDigit) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }

        goto again;
    }

    //
    // Check if we saw at least one digit.
    //
    if (!sawDigit) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    *pp++ = val;

    //
    // Concoct the address according to
    // the number of parts specified.
    //
    n = (ULONG)(pp - parts);
    if (Strict && (n != 4)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    switch ((int) n) {

    case 1:                         /* a -- 32 bits */
        val = parts[0];
        break;

    case 2:                         /* a.b -- 8.24 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:                         /* a.b.c -- 8.8.16 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
        break;

    case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xff) || (parts[3] > 0xff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    val = RtlUlongByteSwap(val);
    *Terminator = String;
    Addr->s_addr = val;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlIpv4StringToAddressExT (
    IN LPCTSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to in_addr and port number.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Strict - If TRUE, the address portion must be dotted-decimal with 4 parts.
             Otherwise, any of the four forms are allowed, with decimal,
             octal, or hex.

    Address - Receives the address (in_addr) itself.

    Port - Receives port number. 0 is returned if there is no port number.
           Port is returned in network byte order.  

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, error code if not.

--*/

{
    LPTSTR Terminator;
    USHORT TempPort;
    
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (Port == NULL)) { 
        return STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(RtlIpv4StringToAddressT(AddressString, 
                                            Strict, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (*Terminator == _T(':')) {
        TCHAR Ch;
        USHORT Base;
        BOOLEAN ExpectPort = TRUE;
        Terminator++;
        TempPort = 0;
        Base = 10;
        if (*Terminator == _T('0')) {
            Base = 8;
            Terminator++;
            if ((*Terminator == _T('x')) || (*Terminator == _T('X'))) {
                Base = 16;
                Terminator++;
            }
        }
        if (Ch = *Terminator) {
            ExpectPort = FALSE;
        }
        while (Ch = *Terminator++) {
            if (ISDIGIT(Ch) && (USHORT)(Ch-_T('0')) < Base) {
                //
                // Check the possibility for overflow
                //
                if (((ULONG)TempPort * Base + Ch - _T('0')) > 0xFFFF) {
                    return STATUS_INVALID_PARAMETER;
                }
                TempPort = (TempPort * Base) + (Ch - _T('0'));
            } else if (Base == 16 && ISXDIGIT(Ch)) {
                //
                // Check the possibility for overflow first
                //
                if ((((ULONG)TempPort << 4) + Ch + 10 -  
                    (ISLOWER(Ch) ? _T('a') : _T('A')))
                    > 0xFFFF) {
                    return STATUS_INVALID_PARAMETER;
                }
                TempPort = TempPort << 4;
                TempPort += Ch + 10 - (ISLOWER(Ch) ? _T('a') : _T('A'));
            } else {
                return STATUS_INVALID_PARAMETER;
            }
        }
        if (ExpectPort) {
            return STATUS_INVALID_PARAMETER;
        }
    } else if (*Terminator == 0) {
        TempPort = 0;
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    *Port = RtlUshortByteSwap(TempPort);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\string.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    strings.c

Abstract:

    This module defines functions for manipulating counted strings (STRING).
    A counted string is a data structure containing three fields.  The Buffer
    field is a pointer to the string itself.  The MaximumLength field contains
    the maximum number of bytes that can be stored in the memory pointed to
    by the Buffer field.  The Length field contains the current length, in
    bytes, of the string pointed to by the Buffer field.  Users of counted
    strings should not make any assumptions about the existence of a null
    byte at the end of the string, unless the null byte is explicitly
    included in the Length of the string.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

    22-Sep-1993    JulieB    Fixed TO_UPPER macro for chars above 0x7f.


--*/

#include "string.h"
#include "nt.h"
#include "ntrtlp.h"


#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
//#pragma alloc_text(NONPAGE,RtlInitString)
//#pragma alloc_text(NONPAGE,RtlInitAnsiString)
//#pragma alloc_text(NONPAGE,RtlInitUnicodeString)
#pragma alloc_text(PAGE,RtlUpperChar)
#pragma alloc_text(PAGE,RtlCompareString)
#pragma alloc_text(PAGE,RtlPrefixString)
#pragma alloc_text(PAGE,RtlCreateUnicodeStringFromAsciiz)
#pragma alloc_text(PAGE,RtlUpperString)
#pragma alloc_text(PAGE,RtlAppendAsciizToString)
#pragma alloc_text(PAGE,RtlAppendStringToString)
#endif

//
// Global data used for translations.
//
extern PUSHORT  NlsAnsiToUnicodeData;    // Ansi CP to Unicode translation table
extern PCH      NlsUnicodeToAnsiData;    // Unicode to Ansi CP translation table
extern const PUSHORT  NlsLeadByteInfo;         // Lead byte info for ACP
extern PUSHORT  NlsUnicodeToMbAnsiData;  // Unicode to Multibyte Ansi CP translation table
extern BOOLEAN  NlsMbCodePageTag;        // TRUE -> Multibyte ACP, FALSE -> Singlebyte ACP

#if !defined(_M_IX86)

VOID
RtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        ASSERT( Length < MAXUSHORT );
        if( Length >= MAXUSHORT ) {
            Length = MAXUSHORT - 1;
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        ASSERT( Length < MAXUSHORT );
        if( Length >= MAXUSHORT ) {
            Length = MAXUSHORT - 1;
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        ASSERT( Length < MAX_USTRING );
        if( Length >= MAX_USTRING ) {
            Length = MAX_USTRING - sizeof(UNICODE_NULL);
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

#endif // !defined(_M_IX86)

NTSTATUS
RtlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )
{
    if (SourceString != NULL) {
        SIZE_T Length = wcslen(SourceString);

        // We are actually limited to 32765 characters since we want to store a meaningful
        // MaximumLength also.
        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) {
            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + sizeof(WCHAR));
        DestinationString->Buffer = (PWSTR) SourceString;
    } else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlInitAnsiStringEx(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )
{
    ULONG Length;

    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);

        // We are actually limited to 64K - 1 characters since we want to store a meaningful
        // MaximumLength also.
        if (Length > (MAXUSHORT - 1)) {
            return STATUS_NAME_TOO_LONG;
        }

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
    } else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
    }
    DestinationString->Buffer = (PCHAR)SourceString;

    return STATUS_SUCCESS;
}

VOID
RtlCopyString(
    OUT PSTRING DestinationString,
    IN const STRING *SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    if (ARGUMENT_PRESENT( SourceString )) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
            }
        DestinationString->Length = (USHORT)n;
        while (n) {
            *dst++ = *src++;
            n--;
            }
        }
    else {
        DestinationString->Length = 0;
        }
}

CHAR
RtlUpperChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character uppercased
.
Arguments:

    IN CHAR Character - Supplies the character to upper case

Return Value:

    CHAR - Uppercased version of the charac
ter
--*/

{

    RTL_PAGED_CODE();

    //
    // NOTE:  This assumes an ANSI string and it does NOT upper case
    //        DOUBLE BYTE characters properly.
    //

    //
    //  Handle a - z separately.
    //
    if (Character <= 'z') {
        if (Character >= 'a') {
            return Character ^ 0x20;
            }
        else {
            return Character;
            }
        }
    else {
        WCHAR wCh;

        /*
         *  Handle extended characters.
         */
        if (!NlsMbCodePageTag) {
            //
            //  Single byte code page.
            //
            wCh = NlsAnsiToUnicodeData[(UCHAR)Character];
            wCh = NLS_UPCASE(wCh);
            return NlsUnicodeToAnsiData[(USHORT)wCh];
            }
        else {
            //
            //  Multi byte code page.  Do nothing to the character
            //  if it's a lead byte or if the translation of the
            //  upper case Unicode character is a DBCS character.
            //
            if (!NlsLeadByteInfo[Character]) {
                wCh = NlsAnsiToUnicodeData[(UCHAR)Character];
                wCh = NLS_UPCASE(wCh);
                wCh = NlsUnicodeToMbAnsiData[(USHORT)wCh];
                if (!HIBYTE(wCh)) {
                    return LOBYTE(wCh);
                    }
                }
            }
        }

    return Character;
}

LONG
RtlCompareString(
    IN const STRING *String1,
    IN const STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareString function compares two counted strings.  The return
    value indicates if the strings are equal or String1 is less than String2
    or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;
    Limit = s1 + (n1 <= n2 ? n1 : n2);
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 !=c2) {
                c1 = RtlUpperChar(c1);
                c2 = RtlUpperChar(c2);
                if (c1 != c2) {
                    return (LONG)c1 - (LONG)c2;
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }
        }
    }

    return n1 - n2;
}

BOOLEAN
RtlEqualString(
    IN const STRING *String1,
    IN const STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    c1 = RtlUpperChar(c1);
                    c2 = RtlUpperChar(c2);
                    if (c1 != c2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlPrefixString(
    const STRING * String1,
    const STRING * String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixString function determines if the String1 counted string
    parameter is a prefix of the String2 counted string parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PCSZ s1, s2;
    USHORT n;
    UCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if (c1 != c2 && RtlUpperChar(c1) != RtlUpperChar(c2)) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}

BOOLEAN
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    Status = RtlInitAnsiStringEx( &AnsiString, SourceString );
    if(!NT_SUCCESS( Status )) {
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}


VOID
RtlUpperString(
    IN PSTRING DestinationString,
    IN const STRING *SourceString
    )

/*++

Routine Description:

    The RtlUpperString function copies the SourceString to the
    DestinationString, converting it to upper case.  The MaximumLength
    and Buffer fields of DestinationString are not modified by this
    function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    RTL_PAGED_CODE();

    dst = DestinationString->Buffer;
    src = SourceString->Buffer;
    n = SourceString->Length;
    if ((USHORT)n > DestinationString->MaximumLength) {
        n = DestinationString->MaximumLength;
        }
    DestinationString->Length = (USHORT)n;
    while (n) {
        *dst++ = RtlUpperChar(*src++);
        n--;
        }
}


NTSTATUS
RtlAppendAsciizToString (
    IN PSTRING Destination,
    IN PCSZ Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied ASCIIZ string to an existing PSTRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PSTRING->MaximumLength field.

Arguments:

    IN PSTRING Destination, - Supplies a pointer to the destination string
    IN PSZ Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    SIZE_T   n;

    RTL_PAGED_CODE();

    if (ARGUMENT_PRESENT( Source )) {
        n = strlen( Source );

        if( (n > MAXUSHORT ) ||
            ((n + Destination->Length) > Destination->MaximumLength) ) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ], Source, n );
        Destination->Length += (USHORT)n;
        }

    return( STATUS_SUCCESS );
}



NTSTATUS
RtlAppendStringToString (
    IN PSTRING Destination,
    IN const STRING *Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;

    RTL_PAGED_CODE();

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ],
                       Source->Buffer,
                       n
                     );
        Destination->Length += n;
        }

    return( STATUS_SUCCESS );
}

#if !defined(_X86_) && !defined(_AMD64_)

SIZE_T
NTAPI
RtlCompareMemoryUlong(
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    )

/*++

Routine Description:

    This function compares two blocks of memory and returns the number
    of bytes that compared equal.

    N.B. This routine requires that the source address is aligned on a
         longword boundary and that the length is an even multiple of
         longwords.

Arguments:

    Source - Supplies a pointer to the block of memory to compare against.

    Length - Supplies the Length, in bytes, of the memory to be
        compared.

    Pattern - Supplies a 32-bit pattern to compare against the block of
        memory.

Return Value:

   The number of bytes that compared equal is returned as the function
   value.  If all bytes compared equal, then the length of the orginal
   block of memory is returned.  Returns zero if either the Source
   address is not longword aligned or the length is not a multiple of
   longwords.

--*/
{
    SIZE_T CountLongs;
    PULONG p = (PULONG)Source;
    PCHAR p1, p2;

    if (((ULONG_PTR)p & (sizeof( ULONG )-1)) ||
        (Length & (sizeof( ULONG )-1))
       ) {
        return( 0 );
        }

    CountLongs = Length / sizeof( ULONG );
    while (CountLongs--) {
        if (*p++ != Pattern) {
            p1 = (PCHAR)(p - 1);
            p2 = (PCHAR)&Pattern;
            Length = p1 - (PCHAR)Source;
            while (*p1++ == *p2++) {
                if (p1 > (PCHAR)p) {
                    break;
                    }

                Length++;
                }
            }
        }

    return( Length );
}

#endif // !defined(_X86_) && !defined(_AMD64_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\sysvol.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SysVol.c

Abstract:

    Creation and Maintenance of the NTFS "System Volume Information"
    directory.

Author:

    Norbert P. Kusters (NorbertK)   1-Nov-2000

Revision History:

--*/

#include "ntrtlp.h"

PVOID
RtlpSysVolAllocate(
    IN  ULONG   Size
    );

VOID
RtlpSysVolFree(
    IN  PVOID   Buffer
    );

NTSTATUS
RtlpSysVolCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    );

NTSTATUS
RtlpSysVolCheckOwnerAndSecurity(
    IN  HANDLE  Handle,
    IN  PACL    StandardAcl
    );

VOID
RtlpSysVolAdminSid(
    IN OUT  SID*    Sid
    );

static const SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlCreateSystemVolumeInformationFolder)
#pragma alloc_text(PAGE,RtlpSysVolAllocate)
#pragma alloc_text(PAGE,RtlpSysVolFree)
#pragma alloc_text(PAGE,RtlpSysVolCreateSecurityDescriptor)
#pragma alloc_text(PAGE,RtlpSysVolCheckOwnerAndSecurity)
#pragma alloc_text(PAGE,RtlpSysVolAdminSid)
#endif

PVOID
RtlpSysVolAllocate(
    IN  ULONG   Size
    )

{
    PVOID   p;

#ifdef NTOS_KERNEL_RUNTIME
    p = ExAllocatePoolWithTag(PagedPool, Size, 'SloV');
#else
    p = RtlAllocateHeap(RtlProcessHeap(), 0, Size);
#endif

    return p;
}

VOID
RtlpSysVolFree(
    IN  PVOID   Buffer
    )

{
#ifdef NTOS_KERNEL_RUNTIME
    ExFreePool(Buffer);
#else
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
#endif
}

VOID
RtlpSysVolAdminSid(
    IN OUT  SID*    Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 2;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    Sid->SubAuthority[1] = DOMAIN_ALIAS_RID_ADMINS;
}

VOID
RtlpSysVolSystemSid(
    IN OUT  SID*    Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 1;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_LOCAL_SYSTEM_RID;
}

NTSTATUS
RtlpSysVolCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    )

{
    PSECURITY_DESCRIPTOR    sd;
    NTSTATUS                status;
    PSID                    systemSid;
    UCHAR                   sidBuffer[2*sizeof(SID)];
    ULONG                   aclLength;
    PACL                    acl;

    sd = RtlpSysVolAllocate(sizeof(SECURITY_DESCRIPTOR));
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    systemSid = (PSID) sidBuffer;
    RtlpSysVolSystemSid(systemSid);

    aclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                RtlLengthSid(systemSid) - sizeof(ULONG);

    acl = RtlpSysVolAllocate(aclLength);
    if (!acl) {
        RtlpSysVolFree(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, aclLength, ACL_REVISION);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlAddAccessAllowedAceEx(acl, ACL_REVISION, OBJECT_INHERIT_ACE |
                                      CONTAINER_INHERIT_ACE,
                                      STANDARD_RIGHTS_ALL |
                                      SPECIFIC_RIGHTS_ALL, systemSid);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    *SecurityDescriptor = sd;
    *Acl = acl;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpSysVolCheckOwnerAndSecurity(
    IN  HANDLE  Handle,
    IN  PACL    StandardAcl
    )

{
    NTSTATUS                status;
    ULONG                   sdLength, sdLength2;
    PSECURITY_DESCRIPTOR    sd, sd2;
    PSID                    sid;
    BOOLEAN                 ownerDefaulted, daclPresent, daclDefaulted;
    PACL                    acl;
    ULONG                   i;
    PACCESS_ALLOWED_ACE     ace;
    PSID                    systemSid;
    UCHAR                   sidBuffer[2*sizeof(SID)];
    PSID                    adminSid;
    UCHAR                   sidBuffer2[2*sizeof(SID)];

    status = NtQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, NULL, 0,
                                   &sdLength);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        // The file system does not support security.
        return STATUS_SUCCESS;
    }

    sd = RtlpSysVolAllocate(sdLength);
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = NtQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, sd, sdLength,
                                   &sdLength);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlGetDaclSecurityDescriptor(sd, &daclPresent, &acl,
                                          &daclDefaulted);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlGetOwnerSecurityDescriptor(sd, &sid, &ownerDefaulted);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    //
    //  Setup well know SIDs
    //  

    systemSid = (PSID) sidBuffer;
    adminSid = (PSID) sidBuffer2;

    RtlpSysVolSystemSid(systemSid);
    RtlpSysVolAdminSid(adminSid);


    if (!sid) {
        goto ResetSecurity;
    }

    if (!RtlEqualSid(sid, adminSid)) {
        goto ResetSecurity;
    }

    if (!daclPresent || (daclPresent && !acl)) {
        goto ResetSecurity;
    }

    for (i = 0; ; i++) {
        status = RtlGetAce(acl, i, &ace);
        if (!NT_SUCCESS(status)) {
            ace = NULL;
        }
        if (!ace) {
            break;
        }

        if (ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) {
            continue;
        }

        sid = (PSID) &ace->SidStart;
        if (!RtlEqualSid(sid, systemSid)) {
            continue;
        }

        break;
    }

    if (!ace) {
        goto ResetSecurity;
    }

    if (!(ace->Header.AceFlags&OBJECT_INHERIT_ACE) ||
        !(ace->Header.AceFlags&CONTAINER_INHERIT_ACE)) {

        ace->Header.AceFlags |= OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        status = NtSetSecurityObject(Handle, DACL_SECURITY_INFORMATION, sd);

    } else {
        status = STATUS_SUCCESS;
    }

    RtlpSysVolFree(sd);

    return status;

ResetSecurity:

    sdLength2 = sdLength;
    status = RtlSelfRelativeToAbsoluteSD2(sd, &sdLength2);
    if (status == STATUS_BUFFER_TOO_SMALL) {
        sd2 = RtlpSysVolAllocate(sdLength2);
        if (!sd2) {
            RtlpSysVolFree(sd);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(sd2, sd, sdLength);
        RtlpSysVolFree(sd);
        sd = sd2;
        sdLength = sdLength2;

        status = RtlSelfRelativeToAbsoluteSD2(sd, &sdLength);
        if (!NT_SUCCESS(status)) {
            RtlpSysVolFree(sd);
            return status;
        }
    }

    status = RtlSetOwnerSecurityDescriptor(sd, adminSid, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, StandardAcl, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    sdLength2 = 0;
    status = RtlMakeSelfRelativeSD(sd, NULL, &sdLength2);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        RtlpSysVolFree(sd);
        return status;
    }

    sd2 = RtlpSysVolAllocate(sdLength2);
    if (!sd2) {
        RtlpSysVolFree(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlMakeSelfRelativeSD(sd, sd2, &sdLength2);
    RtlpSysVolFree(sd);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd2);
        return status;
    }

    sd = sd2;
    sdLength = sdLength2;

    status = NtSetSecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                 DACL_SECURITY_INFORMATION, sd);

    RtlpSysVolFree(sd);

    return status;
}

VOID
RtlpSysVolTakeOwnership(
    IN  PUNICODE_STRING         DirectoryName
    )

/*++

Routine Description:

    This routine is called when the open for the directory failed.  This
    routine will attempt to set the owner of the file to the caller's
    ownership so that another attempt to open the file can be attempted.

Arguments:

    DirectoryName       - Supplies the directory name.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    HANDLE              tokenHandle, fileHandle;
    TOKEN_PRIVILEGES    tokenPrivileges;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatus;
    SECURITY_DESCRIPTOR sd;
    PSID                adminSid;
    UCHAR               sidBuffer[2*sizeof(SID)];

    status = NtOpenProcessToken(NtCurrentProcess(), TOKEN_ADJUST_PRIVILEGES |
                                TOKEN_QUERY, &tokenHandle);
    if (!NT_SUCCESS(status)) {
        return;
    }

    tokenPrivileges.PrivilegeCount = 1;
    tokenPrivileges.Privileges[0].Luid =
            RtlConvertLongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);
    tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    status = NtAdjustPrivilegesToken(tokenHandle, FALSE, &tokenPrivileges,
                                     sizeof(tokenPrivileges), NULL, NULL);
    if (!NT_SUCCESS(status)) {
        NtClose(tokenHandle);
        return;
    }

    InitializeObjectAttributes(&oa, DirectoryName, OBJ_CASE_INSENSITIVE, NULL,
                               NULL);
    status = NtOpenFile(&fileHandle, WRITE_OWNER | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);
    if (!NT_SUCCESS(status)) {
        NtClose(tokenHandle);
        return;
    }

    RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    adminSid = (PSID) sidBuffer;
    RtlpSysVolAdminSid(adminSid);

    status = RtlSetOwnerSecurityDescriptor(&sd, adminSid, FALSE);
    if (!NT_SUCCESS(status)) {
        NtClose(fileHandle);
        NtClose(tokenHandle);
        return;
    }

    status = NtSetSecurityObject(fileHandle, OWNER_SECURITY_INFORMATION, &sd);
    if (!NT_SUCCESS(status)) {
        NtClose(fileHandle);
        NtClose(tokenHandle);
        return;
    }

    NtClose(fileHandle);
    NtClose(tokenHandle);
}

NTSTATUS
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    )

/*++

Routine Description:

    This routine verifies the existence of the "System Volume Information"
    folder on the given volume.  If the folder is not present, then the
    folder is created with one ACE indicating full access for SYSTEM.  The ACE
    will have the inheritance bits set.  The folder will be created with
    the HIDDEN and SYSTEM attributes set.

    If the folder is already present, the ACE that indicates full control
    for SYSTEM will be checked and if necessary modified to have the
    inheritance bits set.

Arguments:

    VolumeRootPath  - Supplies a path to the root of an NTFS volume.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          sysVolName;
    UNICODE_STRING          dirName;
    BOOLEAN                 needBackslash;
    NTSTATUS                status;
    PSECURITY_DESCRIPTOR    securityDescriptor;
    PACL                    acl;
    OBJECT_ATTRIBUTES       oa;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&sysVolName, RTL_SYSTEM_VOLUME_INFORMATION_FOLDER);

    dirName.Length = VolumeRootPath->Length + sysVolName.Length;
    if (VolumeRootPath->Buffer[VolumeRootPath->Length/sizeof(WCHAR) - 1] !=
        '\\') {

        dirName.Length += sizeof(WCHAR);
        needBackslash = TRUE;
    } else {
        needBackslash = FALSE;
    }
    dirName.MaximumLength = dirName.Length + sizeof(WCHAR);
    dirName.Buffer = RtlpSysVolAllocate(dirName.MaximumLength);
    if (!dirName.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(dirName.Buffer, VolumeRootPath->Buffer,
                  VolumeRootPath->Length);
    dirName.Length = VolumeRootPath->Length;
    if (needBackslash) {
        dirName.Buffer[VolumeRootPath->Length/sizeof(WCHAR)] = '\\';
        dirName.Length += sizeof(WCHAR);
    }
    RtlCopyMemory((PCHAR) dirName.Buffer + dirName.Length,
                  sysVolName.Buffer, sysVolName.Length);
    dirName.Length += sysVolName.Length;
    dirName.Buffer[dirName.Length/sizeof(WCHAR)] = 0;

    status = RtlpSysVolCreateSecurityDescriptor(&securityDescriptor, &acl);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(dirName.Buffer);
        return status;
    }

    InitializeObjectAttributes(&oa, &dirName, OBJ_CASE_INSENSITIVE, NULL,
                               securityDescriptor);

    status = NtCreateFile(&h, READ_CONTROL | WRITE_DAC | WRITE_OWNER |
                          SYNCHRONIZE, &oa, &ioStatus, NULL,
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ | FILE_SHARE_WRITE |
                          FILE_SHARE_DELETE, FILE_OPEN_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                          NULL, 0);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolTakeOwnership(&dirName);
        status = NtCreateFile(&h, READ_CONTROL | WRITE_DAC | WRITE_OWNER |
                              SYNCHRONIZE, &oa, &ioStatus, NULL,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                              FILE_SHARE_READ | FILE_SHARE_WRITE |
                              FILE_SHARE_DELETE, FILE_OPEN_IF,
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              FILE_DIRECTORY_FILE, NULL, 0);
    }

    RtlpSysVolFree(dirName.Buffer);

    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(securityDescriptor);
        return status;
    }

    RtlpSysVolFree(securityDescriptor);

    status = RtlpSysVolCheckOwnerAndSecurity(h, acl);

    NtClose(h);
    RtlpSysVolFree(acl);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\threads.c ===
/*++

Copyright (c) 1989-1998 Microsoft Corporation

Module Name:

    threads.c

Abstract:

    This module defines support functions for the worker, waiter, and
    timer thread pools.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Revision History:

    lokeshs - extended/modified threadpool.
    Rob Earhart (earhart) September 28, 2000
      Moved globals from threads.h to threads.c
      Split into independant modules
      Event cache cleanup

Environment:

    These routines are statically linked in the caller's executable and
    are callable only from user mode. They make use of Nt system services.


--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wow64t.h>
#include "ntrtlp.h"
#include "threads.h"

// Thread pool globals

// Events used for synchronization

// NTRAID#201102-2000/10/10-earhart -- C requires that statically
// declared structures be initialized to zero, which is correct for an
// slist -- although it would be nice to have some sort of an
// SLIST_HEADER_STATIC_INITIALIZER available to use here.
SLIST_HEADER EventCache;

RTLP_START_THREAD RtlpStartThread ;
PRTLP_START_THREAD RtlpStartThreadFunc = RtlpStartThread ;
RTLP_EXIT_THREAD RtlpExitThread ;
PRTLP_EXIT_THREAD RtlpExitThreadFunc = RtlpExitThread ;

ULONG MaxThreads = 500;

#if DBG1
PVOID CallbackFn1, CallbackFn2, Context1, Context2 ;
#endif

#if DBG
CHAR InvalidSignatureMsg[] = "Invalid threadpool object signature";
CHAR InvalidDelSignatureMsg[] = "Invalid or deleted threadpool object signature";
#endif

NTSTATUS
NTAPI
RtlSetThreadPoolStartFunc(
    PRTLP_START_THREAD StartFunc,
    PRTLP_EXIT_THREAD ExitFunc
    )
/*++

Routine Description:

    This routine sets the thread pool's thread creation function.  This is not
    thread safe, because it is intended solely for kernel32 to call for processes
    that aren't csrss/smss.

Arguments:

    StartFunc - Function to create a new thread

Return Value:

--*/

{
    RtlpStartThreadFunc = StartFunc ;
    RtlpExitThreadFunc = ExitFunc ;
    return STATUS_SUCCESS ;
}

NTSTATUS
RtlThreadPoolCleanup (
    ULONG Flags
    )
/*++

Routine Description:
    This routine cleans up the thread pool.

Arguments:

    None

Return Value:

    STATUS_SUCCESS : if none of the components are in use.
    STATUS_UNSUCCESSFUL : if some components are still in use.

--*/
{
    NTSTATUS Status, NextStatus;

    return STATUS_UNSUCCESSFUL;

    //
    // Attempt to cleanup all modules.  Keep, as our final return
    // value, the status of the first cleanup routine to error (it's
    // pretty arbitrary), but continue on and attempt cleanup of all
    // modules.
    //

    Status = RtlpTimerCleanup();
    NextStatus = RtlpWaitCleanup();
    if (NT_SUCCESS(Status)) {
        Status = NextStatus;
    }
    NextStatus = RtlpWorkerCleanup();
    if (NT_SUCCESS(Status)) {
        Status = NextStatus;
    }

    return Status;
}

NTSTATUS
NTAPI
RtlpStartThread (
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE *ThreadHandleReturn
    )
{
    return RtlCreateUserThread(
        NtCurrentProcess(),     // process handle
        NULL,                   // security descriptor
        TRUE,                   // Create suspended?
        0L,                     // ZeroBits: default
        0L,                     // Max stack size: default
        0L,                     // Committed stack size: default
        Function,               // Function to start in
        Parameter,              // Parameter to start with
        ThreadHandleReturn,     // Thread handle return
        NULL                    // Thread id
        );
}

NTSTATUS
NTAPI
RtlpStartThreadpoolThread (
    PUSER_THREAD_START_ROUTINE Function,
    PVOID   Parameter,
    HANDLE *ThreadHandleReturn
    )
/*++

Routine Description:

    This routine is used start a new wait thread in the pool.
Arguments:

    None

Return Value:

    STATUS_SUCCESS - Timer Queue created successfully.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the requested operation.

--*/
{
    NTSTATUS Status;
    HANDLE   ThreadHandle;

    if (ThreadHandleReturn) {
        *ThreadHandleReturn = NULL;
    }

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }
    
    // We don't want to create the thread while impersonating;
    // this was nt raid #278770
    ASSERT(! RtlIsImpersonating());

    // Create the thread.

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "StartThread: Starting worker thread %p(%p)\n",
               Function,
               Parameter);
#endif

    Status = RtlpStartThreadFunc(Function,
                                 Parameter,
                                 &ThreadHandle);
        
#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "StartThread: Started worker thread: status %p, handle %x\n",
               Status,
               ThreadHandle);
#endif

    if (! NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (ThreadHandleReturn) {
        // Set the thread handle return before we resume the
        // thread -- in case the thread proceeds to use the
        // returned handle.
        *ThreadHandleReturn = ThreadHandle;
    }

    Status = NtResumeThread(ThreadHandle, NULL);

    if (! NT_SUCCESS(Status)) {

        NtTerminateThread(ThreadHandle, Status);

        if (ThreadHandleReturn) {
            *ThreadHandleReturn = NULL;
        }

        NtClose(ThreadHandle);
    }

  cleanup:

    return Status ;
}

NTSTATUS
NTAPI
RtlpExitThread(
    NTSTATUS Status
    )
{
    return NtTerminateThread( NtCurrentThread(), Status );
}

VOID
RtlpDoNothing (
    PVOID NotUsed1,
    PVOID NotUsed2,
    PVOID NotUsed3
    )
/*++

Routine Description:

    This routine is used to see if the thread is alive

Arguments:

    NotUsed1, NotUsed2 and NotUsed 3 - not used

Return Value:

    None

--*/
{

}

VOID
RtlpThreadCleanup (
    )
/*++

Routine Description:

    This routine is used for exiting timer, wait and IOworker threads.

Arguments:

Return Value:

--*/
{
    NtTerminateThread( NtCurrentThread(), 0) ;
}


NTSTATUS
RtlpWaitForEvent (
    HANDLE Event,
    HANDLE ThreadHandle
    )
/*++

Routine Description:

    Waits for the event to be signalled. If the event is not signalled within
    one second, then checks to see that the thread is alive

Arguments:

    Event : Event handle used for signalling completion of request

    ThreadHandle: Thread to check whether still alive

Return Value:

    STATUS_SUCCESS if event was signalled
    else return NTSTATUS

--*/
{
    NTSTATUS Status;
    HANDLE Handles[2];

    Handles[0] = Event;
    Handles[1] = ThreadHandle;

    Status = NtWaitForMultipleObjects(2, Handles, WaitAny, FALSE, NULL);

    if (Status == STATUS_WAIT_0) {
        //
        // The event has been signalled
        //
        Status = STATUS_SUCCESS;

    } else if (Status == STATUS_WAIT_1) {
        //
        // The target thread has died.
        //
#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "Threadpool thread died before event could be signalled\n");
#endif
        Status = STATUS_UNSUCCESSFUL;

    } else if (NT_SUCCESS(Status)) {
        //
        // Something else has happened; make sure we fail.
        //
        Status = STATUS_UNSUCCESSFUL;

    }

    return Status;
}

PRTLP_EVENT
RtlpGetWaitEvent (
    VOID
    )
/*++

Routine Description:

    Returns an event from the event cache.

Arguments:

    None

Return Value:

    Pointer to event structure

--*/
{
    PSLIST_ENTRY    Entry;
    PRTLP_EVENT     Event;
    NTSTATUS        Status;

    ASSERT(! RtlIsImpersonating());
    
    Entry = RtlInterlockedPopEntrySList(&EventCache);

    if (Entry) {

        Event = CONTAINING_RECORD(Entry, RTLP_EVENT, Link);

    } else {

        Event = RtlpAllocateTPHeap(sizeof(RTLP_EVENT), 0);

        if (Event) {
            Status = NtCreateEvent(&Event->Handle,
                                   EVENT_ALL_ACCESS,
                                   NULL,
                                   SynchronizationEvent,
                                   FALSE);
            if (! NT_SUCCESS(Status)) {
                RtlpFreeTPHeap(Event);
                Event = NULL;
            } else {
                OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

                HandleInfo.Inherit = FALSE;
                HandleInfo.ProtectFromClose = TRUE;
                NtSetInformationObject(Event->Handle,
                                       ObjectHandleFlagInformation,
                                       &HandleInfo,
                                       sizeof(HandleInfo));
            }
        }
    }

    return Event;
}

VOID
RtlpFreeWaitEvent (
    PRTLP_EVENT Event
    )
/*++

Routine Description:

    Frees the event to the event cache

Arguments:

    Event - the event struct to put back into the cache

Return Value:

    Nothing

--*/
{
    ASSERT(Event != NULL);

    //
    // Note: There's a race between checking the depth and pushing the 
    // event.  This doesn't hurt anything.
    //

    if (RtlQueryDepthSList(&EventCache) >= MAX_UNUSED_EVENTS) {
        OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

        HandleInfo.Inherit = FALSE;
        HandleInfo.ProtectFromClose = FALSE;
        NtSetInformationObject(Event->Handle,
                               ObjectHandleFlagInformation,
                               &HandleInfo,
                               sizeof(HandleInfo));
        NtClose(Event->Handle);
        RtlpFreeTPHeap(Event);
    } else {
        RtlInterlockedPushEntrySList(&EventCache,
                                     (PSLIST_ENTRY)&Event->Link);
    }
}

VOID
RtlpWaitOrTimerCallout(WAITORTIMERCALLBACKFUNC Function,
                       PVOID Context,
                       BOOLEAN TimedOut,
                       PACTIVATION_CONTEXT ActivationContext,
                       HANDLE ImpersonationToken,
                       PRTL_CRITICAL_SECTION const *LocksHeld)
/*++

Routine Description:

    Perform a safe callout to the supplied wait or timer callback

Arguments:

    Function -- the function to call

    Context -- the context parameter for the function

    TimedOut -- whether this callback occurred because of a timer
                expiration

    ActivationContext -- the request's originating activation context

    ImpersonationToken -- the request's impersonation token

Return Value:

    None

--*/
{
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

#if (DBG1)
    DBG_SET_FUNCTION( Function, Context );
#endif
    if (ImpersonationToken) {
        RTL_VERIFY(
            NT_SUCCESS(
                NtSetInformationThread(NtCurrentThread(),
                                       ThreadImpersonationToken,
                                       (PVOID)&ImpersonationToken,
                                       (ULONG)sizeof(HANDLE))));
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        // ISSUE-2000/10/10-earhart: Once the top level exception
        // handling code's moved to RTL, we need to catch any
        // exceptions here, and recover the thread.
        Function(Context, TimedOut);
    } __finally {

        RtlCheckHeldCriticalSections(NtCurrentThread(), LocksHeld);

        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);

        if (RtlIsImpersonating()) {
            HANDLE NewToken = NULL;
            
            RTL_VERIFY(
                NT_SUCCESS(
                    NtSetInformationThread(NtCurrentThread(),
                                           ThreadImpersonationToken,
                                           (PVOID)&NewToken,
                                           (ULONG)sizeof(HANDLE))));
        }
    }
}

VOID
RtlpApcCallout(APC_CALLBACK_FUNCTION Function,
               NTSTATUS Status,
               PVOID Context1,
               PVOID Context2)
/*++

Routine Description:

    Perform a safe callout to the supplied APC callback

Arguments:

    Function -- the function to call

    Status -- the status parameter for the function

    Context1 -- the first context parameter for the function

    Context2 -- the second context parameter for the function

Return Value:

    None

--*/
{
    // ISSUE-2000/10/10-earhart: Once the top level exception handling
    // code's moved to RTL, we need to catch any exceptions here, and
    // recover the thread.
    Function(Status, Context1, Context2) ;

    RtlCheckHeldCriticalSections(NtCurrentThread(), NULL);
}

VOID
RtlpWorkerCallout(WORKERCALLBACKFUNC Function,
                  PVOID Context,
                  PACTIVATION_CONTEXT ActivationContext,
                  HANDLE ImpersonationToken)
/*++

Routine Description:

    Perform a safe callout to the supplied worker callback

Arguments:

    Function -- the function to call

    Context -- the context parameter for the function

    ActivationContext -- the request's originating activation context

    ImpersonationToken -- the request's impersonation token

Return Value:

    None

--*/
{
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

#if (DBG1)
    DBG_SET_FUNCTION( Function, Context ) ;
#endif
    if (ImpersonationToken) {
        RTL_VERIFY(
            NT_SUCCESS(
                NtSetInformationThread(NtCurrentThread(),
                                       ThreadImpersonationToken,
                                       (PVOID)&ImpersonationToken,
                                       (ULONG)sizeof(HANDLE))));
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        // ISSUE-2000/10/10-earhart: Once the top level exception
        // handling code's moved to RTL, we need to catch any
        // exceptions here, and recover the thread.
        Function(Context) ;
    } __finally {

        RtlCheckHeldCriticalSections(NtCurrentThread(), NULL);

        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);

        if (RtlIsImpersonating()) {
            HANDLE NewToken = NULL;
            
            RTL_VERIFY(
                NT_SUCCESS(
                    NtSetInformationThread(NtCurrentThread(),
                                           ThreadImpersonationToken,
                                           (PVOID)&NewToken,
                                           (ULONG)sizeof(HANDLE))));
        }
    }
}

NTSTATUS
RtlpCaptureImpersonation(
    IN  LOGICAL RequestDuplicateAccess,
    OUT PHANDLE Token
    )
{
    NTSTATUS Status;
    HANDLE NewToken;

    *Token = NULL;

    if (RtlIsImpersonating()) {

        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_IMPERSONATE
                                   | (RequestDuplicateAccess
                                      ? TOKEN_DUPLICATE
                                      : 0),
                                   TRUE,
                                   Token);
        if (! NT_SUCCESS(Status)) {
            return Status;
        }

        NewToken = NULL;

        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID) &NewToken,
                                        (ULONG) sizeof(NewToken));

        if (! NT_SUCCESS(Status)) {

            NtSetInformationThread(NtCurrentThread(),
                                   ThreadImpersonationToken,
                                   (PVOID) Token,
                                   (ULONG) sizeof(*Token));
            NtClose(*Token);
            *Token = NULL;
            return Status;
        }
    }

    return STATUS_SUCCESS;
}

VOID
RtlpRestartImpersonation(
    IN HANDLE Token
    )
{
    NtSetInformationThread(NtCurrentThread(),
                           ThreadImpersonationToken,
                           &Token,
                           sizeof(Token));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\threads.h ===
/*++

Copyright (c) 1989-1998 Microsoft Corporation

Module Name:

    threads.h

Abstract:

    This module is the header file for thread pools. Thread pools can be used for
    one time execution of tasks, for waits and for one shot or periodic timers.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Environment:

    The thread pool routines are statically linked in the caller's
    executable and are callable only from user mode. They make use of
    Nt system services.


Revision History:

    Aug-19 lokeshs - modifications to thread pool apis.
    Rob Earhart (earhart) September 29, 2000
      Moved globals to threads.c
      Split up thread pools to seperate modules
      Moved module-specific interfaces to modules

--*/

//todo remove below
#define DBG1 1



// Structures used by the Thread pool

// Timer structures

// Timer Queues and Timer entries both use RTLP_GENERIC_TIMER structure below.
// Timer Queues are linked using List.
// Timers are attached to the Timer Queue using TimerList
// Timers are linked to each other using List

#define RTLP_TIMER RTLP_GENERIC_TIMER
#define PRTLP_TIMER PRTLP_GENERIC_TIMER

#define RTLP_TIMER_QUEUE RTLP_GENERIC_TIMER
#define PRTLP_TIMER_QUEUE PRTLP_GENERIC_TIMER

struct _RTLP_WAIT ;

typedef struct _RTLP_GENERIC_TIMER {

    LIST_ENTRY List ;                   // All Timers and Queues are linked using this.
    ULONG DeltaFiringTime ;             // Time difference in Milliseconds from the TIMER entry
                                        // just before this entry
    union {
        ULONG RefCount ;        // Timer RefCount
        ULONG * RefCountPtr ;   // Pointer to Wait->Refcount
    } ;                         // keeps count of async callbacks still executing

    ULONG State ;               // State of timer: CREATED, DELETE, ACTIVE. DONT_FIRE

    union {

        // Used for Timer Queues

        struct  {

            LIST_ENTRY  TimerList ;     // Timers Hanging off of the queue
            LIST_ENTRY  UncancelledTimerList ;// List of one shot timers not cancelled
                                              // not used for wait timers
#if DBG1
            ULONG NextDbgId;
#endif
            
        } ;

        // Used for Timers

        struct  {
            struct _RTLP_GENERIC_TIMER *Queue ;// Queue to which this timer belongs
            struct _RTLP_WAIT *Wait ;  // Pointer to Wait event if timer is part of waits. else NULL
            ULONG Flags ;              // Flags indicating special treatment for this timer
            PVOID Function ;           // Function to call when timer fires
            PVOID Context ;            // Context to pass to function when timer fires
            PACTIVATION_CONTEXT ActivationContext; // Activation context to activate around callbacks to Function
            ULONG Period ;             // In Milliseconds. Used for periodic timers.
            LIST_ENTRY TimersToFireList;//placed in this list if the timer is fired
            HANDLE ImpersonationToken; // Token to use for callouts
        } ;
    } ;

    HANDLE CompletionEvent ;   // Event signalled when the timer is finally deleted

#if DBG1
    ULONG DbgId;
    ULONG ThreadId ;
    ULONG ThreadId2 ;
#endif

}  RTLP_GENERIC_TIMER, *PRTLP_GENERIC_TIMER ;

// Structures used by Wait Threads

// Wait structure

typedef struct _RTLP_WAIT {
    struct _RTLP_WAIT_THREAD_CONTROL_BLOCK *ThreadCB ;
    HANDLE WaitHandle ;         // Object to wait on
    ULONG State ;               // REGISTERED, ACTIVE,DELETE state flags
    ULONG RefCount ;            // initially set to 1. When 0, then ready to be deleted
    HANDLE CompletionEvent ;
    struct _RTLP_GENERIC_TIMER *Timer ; // For timeouts on the wait
    ULONG Flags ;               // Flags indicating special treatment for this wait
    PVOID Function ;            // Function to call when wait completes
    PVOID Context ;             // Context to pass to function
    ULONG Timeout ;             // In Milliseconds.
    PACTIVATION_CONTEXT ActivationContext; // Activation context to activate around calls out to function
    HANDLE ImpersonationToken; // Token to use for callouts
#if DBG1
    ULONG DbgId ;
    ULONG ThreadId ;
    ULONG ThreadId2 ;
#endif
    
} RTLP_WAIT, *PRTLP_WAIT ;


// Wait Thread Control Block

typedef struct _RTLP_WAIT_THREAD_CONTROL_BLOCK {

    LIST_ENTRY WaitThreadsList ;// List of all the thread control blocks

    HANDLE ThreadHandle ;       // Handle for this thread
    ULONG ThreadId ;            // Used to check if callback is in WaitThread

    ULONG NumWaits ;            // Number of active waits + handles pending waits
    ULONG NumActiveWaits ;      // Number of active waits (reflects ActiveWaitArray)
    ULONG NumRegisteredWaits ;  // Number of waits that are registered
    HANDLE ActiveWaitArray[MAXIMUM_WAIT_OBJECTS] ;// Array used for waiting
    PRTLP_WAIT ActiveWaitPointers[MAXIMUM_WAIT_OBJECTS] ;// Array of pointers to active Wait blocks.
    HANDLE TimerHandle ;        // Handle to the NT timer used for timeouts
    RTLP_TIMER_QUEUE TimerQueue;// Queue in which all timers are kept

    LARGE_INTEGER Current64BitTickCount ;
    LONGLONG Firing64BitTickCount ;
    
    RTL_CRITICAL_SECTION WaitThreadCriticalSection ;
                                // Used for addition and deletion of waits

} RTLP_WAIT_THREAD_CONTROL_BLOCK, *PRTLP_WAIT_THREAD_CONTROL_BLOCK ;


// Structure used for attaching all I/O worker threads

typedef struct _RTLP_IOWORKER_TCB {

    LIST_ENTRY List ;           // List of IO Worker threads
    HANDLE     ThreadHandle ;   // Handle of this thread
    ULONG      Flags ;          // WT_EXECUTEINPERSISTENTIOTHREAD
    BOOLEAN    LongFunctionFlag ;// Is the thread currently executing long fn
} RTLP_IOWORKER_TCB, *PRTLP_IOWORKER_TCB ;

typedef struct _RTLP_WAITWORKER {
    union {
        PRTLP_WAIT Wait ;
        PRTLP_TIMER Timer ;
    } ;
    BOOLEAN WaitThreadCallback ; //callback queued by Wait thread or Timer thread
    BOOLEAN TimerCondition ;//true if fired because wait timed out.
} RTLP_ASYNC_CALLBACK, * PRTLP_ASYNC_CALLBACK ;



// structure used for calling worker function

typedef struct _RTLP_WORK {

    WORKERCALLBACKFUNC Function ;
    ULONG Flags ;
    PACTIVATION_CONTEXT ActivationContext;
    HANDLE ImpersonationToken;
    
} RTLP_WORK, *PRTLP_WORK ;



// Structure used for storing events.  Note that Link is used as an
// SLIST_ENTRY, however declaring it as such would unnecessarily pad
// the RTLP_EVENT structure.

typedef struct _RTLP_EVENT {

    SINGLE_LIST_ENTRY Link ;
    HANDLE Handle ;
    
} RTLP_EVENT, *PRTLP_EVENT ;

// Defines used in the thread pool

#define THREAD_CREATION_DAMPING_TIME1    1000    // In Milliseconds. Time between starting successive threads.
#define THREAD_CREATION_DAMPING_TIME2    15000    // In Milliseconds. Time between starting successive threads.
#define THREAD_TERMINATION_DAMPING_TIME 10000    // In Milliseconds. Time between stopping successive threads.
#define NEW_THREAD_THRESHOLD            7       // Number of requests outstanding before we start a new thread
#define NEW_THREAD_THRESHOLD2            14
#define MAX_WORKER_THREADS              1000    // Max effective worker threads
#define INFINITE_TIME                   (ULONG)~0   // In milliseconds
#define PSEUDO_INFINITE_TIME            0x80000000  // In milliseconds
#define RTLP_MAX_TIMERS                 0x00080000  // 524288 timers per process
#define MAX_UNUSED_EVENTS               40
#define NEEDS_IO_THREAD(Flags) (Flags & (WT_EXECUTEINIOTHREAD                   \
                                       | WT_EXECUTEINUITHREAD                   \
                                       | WT_EXECUTEINPERSISTENTIOTHREAD))

// Macros


#define ONE_MILLISECOND_TIMEOUT(TimeOut) {      \
        TimeOut.LowPart  = 0xffffd8f0 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define HUNDRED_MILLISECOND_TIMEOUT(TimeOut) {  \
        TimeOut.LowPart  = 0xfff0bdc0 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define ONE_SECOND_TIMEOUT(TimeOut) {           \
        TimeOut.LowPart  = 0xff676980 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define USE_PROCESS_HEAP 1

#define RtlpFreeTPHeap(Ptr) \
    RtlFreeHeap( RtlProcessHeap(), 0, (Ptr) )

#define RtlpAllocateTPHeap(Size, Flags) \
    RtlAllocateHeap( RtlProcessHeap(), (Flags), (Size) )

// used to allocate Wait thread

#define ACQUIRE_GLOBAL_WAIT_LOCK() \
    RtlEnterCriticalSection (&WaitCriticalSection)

#define RELEASE_GLOBAL_WAIT_LOCK() \
    RtlLeaveCriticalSection(&WaitCriticalSection)


// taken before a timer/queue is deleted and when the timers
// are being fired. Used to assure that no timers will be fired later.

#define ACQUIRE_GLOBAL_TIMER_LOCK() \
    RtlEnterCriticalSection (&TimerCriticalSection)

#define RELEASE_GLOBAL_TIMER_LOCK() \
    RtlLeaveCriticalSection(&TimerCriticalSection)

// used in RtlpThreadPoolCleanup to find if a component is initialized

#define IS_COMPONENT_INITIALIZED(StartedVariable, CompletedVariable, Flag) \
{\
    LARGE_INTEGER TimeOut ;     \
    Flag = FALSE ;              \
                                \
    if ( StartedVariable ) {    \
                                \
        if ( !CompletedVariable ) { \
                                    \
            ONE_MILLISECOND_TIMEOUT(TimeOut) ;  \
                                                \
            while (!*((ULONG volatile *)&CompletedVariable)) \
                NtDelayExecution (FALSE, &TimeOut) ;    \
                                                        \
            if (CompletedVariable == 1)                 \
                Flag = TRUE ;                           \
                                                        \
        } else {                                        \
            Flag = TRUE ;                               \
        }                                               \
    }                                                   \
}    


// macro used to set dbg function/context

#define DBG_SET_FUNCTION(Fn, Context) { \
    CallbackFn1 = CallbackFn2 ;         \
    CallbackFn2 = (Fn) ;                \
    Context1 = Context2 ;               \
    Context2 = (Context ) ;             \
}


// used to move the wait array
/*
VOID
RtlpShiftWaitArray(
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ThreadCB,
    ULONG SrcIndex,
    ULONG DstIndex,
    ULONG Count
    )
*/
#define RtlpShiftWaitArray(ThreadCB, SrcIndex, DstIndex, Count) {  \
                                                            \
    RtlMoveMemory (&(ThreadCB)->ActiveWaitArray[DstIndex],  \
                    &(ThreadCB)->ActiveWaitArray[SrcIndex], \
                    sizeof (HANDLE) * (Count)) ;            \
                                                            \
    RtlMoveMemory (&(ThreadCB)->ActiveWaitPointers[DstIndex],\
                    &(ThreadCB)->ActiveWaitPointers[SrcIndex],\
                    sizeof (HANDLE) * (Count)) ;            \
}

// signature for timer and wait entries

#define SET_WAIT_SIGNATURE(ptr)     RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0xfedc0100)
#define SET_TIMER_SIGNATURE(ptr)    RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0xfedc0200)
#define SET_TIMER_QUEUE_SIGNATURE(ptr)    RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0xfedc0300)
#define IS_WAIT_SIGNATURE(ptr)      (((ptr)->State & 0x00000f00) == 0x00000100)
#define IS_TIMER_SIGNATURE(ptr)     (((ptr)->State & 0x00000f00) == 0x00000200)
#define CHECK_SIGNATURE(ptr)        ASSERTMSG( InvalidSignatureMsg, \
                                               ((ptr)->State & 0xffff0000) == 0xfedc0000 )
#define SET_DEL_SIGNATURE(ptr)      RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0x00009000)
#define SET_DEL_PENDING_SIGNATURE(ptr)      RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0x00002000)
#define CHECK_DEL_SIGNATURE(ptr)    ASSERTMSG( InvalidDelSignatureMsg, \
                                               (((ptr)->State & 0xffff0000) == 0xfedc0000) \
                                               && ( ! ((ptr)->State & 0x00009000)) )
#define CHECK_DEL_PENDING_SIGNATURE(ptr) ASSERTMSG( InvalidDelSignatureMsg, \
                                               (((ptr)->State & 0xffff0000) == 0xfedc0000) \
                                               && ( ! ((ptr)->State & 0x0000f000)) )
#define IS_DEL_SIGNATURE_SET(ptr)   ((ptr)->State & 0x00009000)
#define IS_DEL_PENDING_SIGNATURE_SET(ptr)   ((ptr)->State & 0x00002000)
#define CLEAR_SIGNATURE(ptr)        RtlInterlockedSetClearBits(&(ptr)->State, \
                                               0xcdef0000, \
                                               0xfedc0000 & ~(0xcdef0000))
#define SET_DEL_TIMERQ_SIGNATURE(ptr)  RtlInterlockedSetBitsDiscardReturn(&(ptr)->State, 0x00000a00)


// debug prints
#define RTLP_THREADPOOL_ERROR_MASK   (0x01 | DPFLTR_MASK)
#define RTLP_THREADPOOL_WARNING_MASK (0x02 | DPFLTR_MASK)
#define RTLP_THREADPOOL_INFO_MASK    (0x04 | DPFLTR_MASK)
#define RTLP_THREADPOOL_TRACE_MASK   (0x08 | DPFLTR_MASK)
#define RTLP_THREADPOOL_VERBOSE_MASK (0x10 | DPFLTR_MASK)

#if DBG
extern CHAR InvalidSignatureMsg[];
extern CHAR InvalidDelSignatureMsg[];
#endif

extern ULONG MaxThreads;

extern BOOLEAN LdrpShutdownInProgress;

NTSTATUS
NTAPI
RtlpStartThreadpoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID   Parameter,
    HANDLE *ThreadHandleReturn
    );

extern PRTLP_EXIT_THREAD RtlpExitThreadFunc;

#if DBG1
extern PVOID CallbackFn1, CallbackFn2, Context1, Context2 ;
#endif

// Timer globals needed by worker
extern ULONG StartedTimerInitialization ;      // Used by Timer thread startup synchronization
extern ULONG CompletedTimerInitialization ;    // Used for to check if Timer thread is initialized
extern HANDLE TimerThreadHandle;

VOID
RtlpAsyncWaitCallbackCompletion(
    IN PVOID Context
    );

NTSTATUS
RtlpInitializeTimerThreadPool (
    ) ;

NTSTATUS
RtlpTimerCleanup(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlpWaitCleanup(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlpWorkerCleanup(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlpThreadCleanup (
    VOID
    );

VOID
RtlpResetTimer (
    HANDLE TimerHandle,
    ULONG DueTime,
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    ) ;


BOOLEAN
RtlpInsertInDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER NewTimer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime
    ) ;

BOOLEAN
RtlpRemoveFromDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime
    ) ;

BOOLEAN
RtlpReOrderDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime,
    ULONG ChangedFiringTime
    ) ;

NTSTATUS
RtlpDeactivateWait (
    PRTLP_WAIT Wait,
    BOOLEAN OkayToFreeTheTimer
    ) ;

VOID
RtlpDeleteWait (
    PRTLP_WAIT Wait
    ) ;

VOID
RtlpProcessTimeouts (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    ) ;

ULONG
RtlpGetTimeRemaining (
    HANDLE TimerHandle
    ) ;

#define THREAD_TYPE_WORKER 1
#define THREAD_TYPE_IO_WORKER 2

VOID
RtlpDeleteTimer (
    PRTLP_TIMER Timer
    ) ;

PRTLP_EVENT
RtlpGetWaitEvent (
    VOID
    ) ;

VOID
RtlpFreeWaitEvent (
    PRTLP_EVENT Event
    ) ;

VOID
RtlpDoNothing (
    PVOID NotUsed1,
    PVOID NotUsed2,
    PVOID NotUsed3
    ) ;

VOID
RtlpExecuteWorkerRequest (
    NTSTATUS Status,
    PVOID Context,
    PVOID ActualFunction
    ) ;

NTSTATUS
RtlpWaitForEvent (
    HANDLE Event,
    HANDLE ThreadHandle
    ) ;

NTSTATUS
RtlpCaptureImpersonation(
    IN  LOGICAL RequestDuplicateAccess,
    OUT PHANDLE Token
    );

VOID
RtlpRestartImpersonation(
    IN HANDLE Token
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlThreadPoolCleanup (
    ULONG Flags
    ) ;

VOID
RtlpWaitOrTimerCallout(WAITORTIMERCALLBACKFUNC Function,
                       PVOID Context,
                       BOOLEAN TimedOut,
                       PACTIVATION_CONTEXT ActivationContext,
                       HANDLE ImpersonationToken,
                       PRTL_CRITICAL_SECTION const *LocksHeld);

VOID
RtlpApcCallout(APC_CALLBACK_FUNCTION Function,
               NTSTATUS Status,
               PVOID Context1,
               PVOID Context2);

VOID
RtlpWorkerCallout(WORKERCALLBACKFUNC Function,
                  PVOID Context,
                  PACTIVATION_CONTEXT ActivationContext,
                  HANDLE ImpersonationToken);

// Waits and timers may specify that their callbacks must execute
// within worker threads of various types.  This can cause a problem
// if those worker threads are unavailable.  RtlpAcquireWorker
// guarantees that at least one worker thread of the appropriate type
// will be available to handle callbacks until a matching call to
// RtlpReleaseWorker is made.

NTSTATUS
RtlpAcquireWorker(ULONG Flags);

VOID
RtlpReleaseWorker(ULONG Flags);

//to make sure that a wait is not deleted before being registered
#define STATE_REGISTERED   0x0001

//set when wait registered. Removed when one shot wait fired.
//when deregisterWait called, tells whether to be removed from ActiveArray
//If timer active, then have to remove it from delta list and reset the timer.
#define STATE_ACTIVE       0x0002

//when deregister wait is called(RefCount may be >0)
#define STATE_DELETE       0x0004

//set when cancel timer called. The APC will clean it up.
#define STATE_DONTFIRE     0x0008

//set when one shot timer fired.
#define STATE_ONE_SHOT_FIRED 0x0010
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\time.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,227 years, or around 10,675,199 days

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    );
static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    );
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    );

ULONG
RtlGetTickCount (
    VOID
    );

#pragma alloc_text(PAGE, RtlCutoverTimeToSystemTime)
#pragma alloc_text(PAGE, RtlTimeToElapsedTimeFields)
#pragma alloc_text(PAGE, RtlSystemTimeToLocalTime)
#pragma alloc_text(PAGE, RtlLocalTimeToSystemTime)
#pragma alloc_text(INIT, RtlGetTickCount)

#endif


//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

CONST UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

CONST UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 86400 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

const LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

const LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

const LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

const LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}

BOOLEAN
RtlCutoverTimeToSystemTime(
    PTIME_FIELDS CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    )
{
    TIME_FIELDS CurrentTimeFields;

    //
    // Get the current system time
    //

    RtlTimeToTimeFields(CurrentSystemTime,&CurrentTimeFields);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an abosulte time
    //

    if ( CutoverTime->Year ) {

        //
        // Convert this to a time value and make sure it
        // is greater than the current system time
        //

        if ( !RtlTimeFieldsToTime(CutoverTime,SystemTime) ) {
            return FALSE;
            }

        if (SystemTime->QuadPart < CurrentSystemTime->QuadPart) {
            return FALSE;
            }
        return TRUE;
        }
    else {

        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->Day;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->Weekday;
        TargetMonth = CutoverTime->Month;
        MonthMatches = FALSE;
        if ( !ThisYear ) {
            if ( TargetMonth < CurrentTimeFields.Month ) {
                TargetYear = CurrentTimeFields.Year + 1;
                }
            else if ( TargetMonth > CurrentTimeFields.Month ) {
                TargetYear = CurrentTimeFields.Year;
                }
            else {
                TargetYear = CurrentTimeFields.Year;
                MonthMatches = TRUE;
                }
            }
        else {
            TargetYear = CurrentTimeFields.Year;
            }
try_next_year:
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->Hour;
        WorkingTimeField.Minute = CutoverTime->Minute;
        WorkingTimeField.Second = CutoverTime->Second;
        WorkingTimeField.Milliseconds = CutoverTime->Milliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < CurrentTimeFields.Day ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == CurrentTimeFields.Day ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
}


BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    //
    //  Year 30827 check: Time (in 100ns units) is stored in a
    //  64-bit integer, rooted at 1/1/1601.
    //
    //  2^63 / (10^7 * 86400) = 10675199 days
    //  10675199 / 146097 = 73 400-year chunks, 10118 days
    //  10118 / 1461 = 6 4-year chunks, 1352 days
    //  1352 / 365 = 3 years, some residual days
    //  1600 + 73*400 + 6*4 + 3 = 30827 is last year fully
    //  supported.
    //
    //  I'm guessing it's undesirable to support part of the
    //  year 30828.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Year > 30827)                               ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlTimeToElapsedTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  The input time is the elapsed time (difference
    between to times).  It will tell the caller the number of days, hour,
    minute, second, and milliseconds that the elapsed time represents.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Days;
    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = 0;
    TimeFields->Month        = 0;
    TimeFields->Day          = (CSHORT)Days;
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
RtlTimeToSecondsSince1980 (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedSeconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit NT Time variable to the
    number of seconds since the start of 1980.  The NT time must be
    within the range 1980 to around 2115.

Arguments:

    Time - Supplies the Time to convert from

    ElapsedSeconds - Receives the number of seconds since the start of 1980
        denoted by Time

Return Value:

    BOOLEAN - TRUE if the input Time is within a range expressible by
        ElapsedSeconds and FALSE otherwise

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  First convert time to seconds since 1601
    //

    Seconds = Convert100nsToSeconds( *(PLARGE_INTEGER)Time );

    //
    //  Then subtract the number of seconds from 1601 to 1980.
    //

    Seconds.QuadPart = Seconds.QuadPart - SecondsToStartOf1980.QuadPart;

    //
    //  If the results is negative then the date was before 1980 or if
    //  the results is greater than a ulong then its too far in the
    //  future so we return FALSE
    //

    if (Seconds.HighPart != 0) {

        return FALSE;

    }

    //
    //  Otherwise we have the answer
    //

    *ElapsedSeconds = Seconds.LowPart;

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlSecondsSince1980ToTime (
    IN ULONG ElapsedSeconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts the seconds since the start of 1980 to an
    NT Time value.

Arguments:

    ElapsedSeconds - Supplies the number of seconds from the start of 1980
        to convert from

    Time - Receives the converted Time value

Return Value:

    None

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  Move elapsed seconds to a large integer
    //

    Seconds.LowPart = ElapsedSeconds;
    Seconds.HighPart = 0;

    //
    //  convert number of seconds from 1980 to number of seconds from 1601
    //

    Seconds.QuadPart = Seconds.QuadPart + SecondsToStartOf1980.QuadPart;

    //
    //  Convert seconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertSecondsTo100ns( Seconds );

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
RtlTimeToSecondsSince1970 (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedSeconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit NT Time variable to the
    number of seconds since the start of 1970.  The NT time must be
    within the range 1970 to around 2105.

Arguments:

    Time - Supplies the Time to convert from

    ElapsedSeconds - Receives the number of seconds since the start of 1970
        denoted by Time

Return Value:

    BOOLEAN - TRUE if the input time is within the range expressible by
        ElapsedSeconds and FALSE otherwise

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  First convert time to seconds since 1601
    //

    Seconds = Convert100nsToSeconds( *(PLARGE_INTEGER)Time );

    //
    //  Then subtract the number of seconds from 1601 to 1970.
    //

    Seconds.QuadPart = Seconds.QuadPart - SecondsToStartOf1970.QuadPart;

    //
    //  If the results is negative then the date was before 1970 or if
    //  the results is greater than a ulong then its too far in the
    //  future so we return FALSE
    //

    if (Seconds.HighPart != 0) {

        return FALSE;

    }

    //
    //  Otherwise we have the answer
    //

    *ElapsedSeconds = Seconds.LowPart;

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlSecondsSince1970ToTime (
    IN ULONG ElapsedSeconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts the seconds since the start of 1970 to an
    NT Time value

Arguments:

    ElapsedSeconds - Supplies the number of seconds from the start of 1970
        to convert from

    Time - Receives the converted Time value

Return Value:

    None

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  Move elapsed seconds to a large integer
    //

    Seconds.LowPart = ElapsedSeconds;
    Seconds.HighPart = 0;

    //
    //  Convert number of seconds from 1970 to number of seconds from 1601
    //

    Seconds.QuadPart = Seconds.QuadPart + SecondsToStartOf1970.QuadPart;

    //
    //  Convert seconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertSecondsTo100ns( Seconds );

    //
    //  return to our caller
    //

    return;
}

NTSTATUS
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    )
{
    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // LocalTime = SystemTime - TimeZoneBias
    //

    LocalTime->QuadPart = SystemTime->QuadPart - TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    )
{

    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // SystemTime = LocalTime + TimeZoneBias
    //

    SystemTime->QuadPart = LocalTime->QuadPart + TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}


ULONG
RtlGetTickCount (
    VOID
    )
/*++

Routine Description:

    This routine returns the current tick count for the system.
    This routine is provided for compatibility only

Arguments:

    None.

Return Value:

    System tick count.

--*/

{
    return NtGetTickCount ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\tracedbp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tracedbp.h

Abstract:

    This header contains the private interfaces for the trace database 
    module (hash table to store stack traces in User/Kernel mode).

Author:

    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _TRACEDBP_H
#define _TRACEDBP_H

//
// RTL_TRACE_SEGMENT
//

typedef struct _RTL_TRACE_SEGMENT {

    ULONG Magic;

    struct _RTL_TRACE_DATABASE * Database;
    struct _RTL_TRACE_SEGMENT * NextSegment;
    SIZE_T TotalSize;
    PCHAR SegmentStart;
    PCHAR SegmentEnd;
    PCHAR SegmentFree;

} RTL_TRACE_SEGMENT, * PRTL_TRACE_SEGMENT;

//
// RTL_TRACE_DATABASE
//

typedef struct _RTL_TRACE_DATABASE {

    ULONG Magic;
    ULONG Flags;
    ULONG Tag;

    struct _RTL_TRACE_SEGMENT * SegmentList;

    SIZE_T MaximumSize;
    SIZE_T CurrentSize;

#ifdef NTOS_KERNEL_RUNTIME

    KIRQL SavedIrql;
    PVOID Owner;

    union {
        KSPIN_LOCK SpinLock;
        FAST_MUTEX FastMutex;
    } u;
#else

    PVOID Owner;
    RTL_CRITICAL_SECTION Lock;

#endif // #ifdef NTOS_KERNEL_RUNTIME

    ULONG NoOfBuckets;
    struct _RTL_TRACE_BLOCK * * Buckets;
    RTL_TRACE_HASH_FUNCTION HashFunction;

    SIZE_T NoOfTraces;
    SIZE_T NoOfHits;

    ULONG HashCounter[16];

} RTL_TRACE_DATABASE, * PRTL_TRACE_DATABASE;


#endif // #ifndef _TRACEDBP_H

//
// End of header: tracedbp.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\timer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module defines functions for the timer thread pool.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Revision History:

    lokeshs - extended/modified threadpool.

    Rob Earhart (earhart) September 29, 2000
      Split off from threads.c

Environment:

    These routines are statically linked in the caller's executable
    and are callable only from user mode. They make use of Nt system
    services.


--*/

#include <ntos.h>
#include <ntrtl.h>
#include <wow64t.h>
#include "ntrtlp.h"
#include "threads.h"

// Timer Thread Pool
// -----------------
// Clients create one or more Timer Queues and insert one shot or periodic
// timers in them. All timers in a queue are kept in a "Delta List" with each
// timer's firing time relative to the timer before it. All Queues are also
// kept in a "Delta List" with each Queue's firing time (set to the firing time
// of the nearest firing timer) relative to the Queue before it. One NT Timer
// is used to service all timers in all queues.

ULONG StartedTimerInitialization ;      // Used by Timer thread startup synchronization
ULONG CompletedTimerInitialization ;    // Used for to check if Timer thread is initialized

HANDLE TimerThreadHandle ;              // Holds the timer thread handle
ULONG TimerThreadId ;                   // Used to check if current thread is a timer thread

LIST_ENTRY TimerQueues ;                // All timer queues are linked in this list
HANDLE     TimerHandle ;                // Holds handle of NT Timer used by the Timer Thread
HANDLE     TimerThreadStartedEvent ;    // Indicates that the timer thread has started
ULONG      NumTimerQueues ;             // Number of timer queues

RTL_CRITICAL_SECTION TimerCriticalSection ;     // Exclusion used by timer threads

LARGE_INTEGER   Last64BitTickCount ;
LARGE_INTEGER   Resync64BitTickCount ;
LARGE_INTEGER   Firing64BitTickCount ;

#if DBG
ULONG RtlpDueTimeMax = 0;
#endif

#if DBG1
ULONG NextTimerDbgId;
#endif

#define RtlpGetResync64BitTickCount()  Resync64BitTickCount.QuadPart
#define RtlpSetFiring64BitTickCount(Timeout) \
            Firing64BitTickCount.QuadPart = (Timeout)

__inline
LONGLONG
RtlpGet64BitTickCount(
    LARGE_INTEGER *Last64BitTickCount
    )
/*++

Routine Description:

    This routine is used for getting the latest 64bit tick count.

Arguments:

Return Value: 64bit tick count

--*/
{
    LARGE_INTEGER liCurTime ;

    liCurTime.QuadPart = NtGetTickCount() + Last64BitTickCount->HighPart ;

    // see if timer has wrapped.

    if (liCurTime.LowPart < Last64BitTickCount->LowPart) {
        liCurTime.HighPart++ ;
    }

    return (Last64BitTickCount->QuadPart = liCurTime.QuadPart) ;
}

__inline
LONGLONG
RtlpResync64BitTickCount(
    )
/*++

Routine Description:

    This routine is used for getting the latest 64bit tick count.

Arguments:

Return Value: 64bit tick count

Remarks: This call should be made in the first line of any APC queued
    to the timer thread and nowhere else. It is used to reduce the drift

--*/
{
    return Resync64BitTickCount.QuadPart =
                    RtlpGet64BitTickCount(&Last64BitTickCount);
}

VOID
RtlpAsyncTimerCallbackCompletion(
    PVOID Context
    )
/*++

Routine Description:

    This routine is called in a (IO)worker thread and is used to decrement the
    RefCount at the end and call RtlpDeleteTimer if required

Arguments:

    Context - pointer to the Timer object,

Return Value:

--*/
{
    PRTLP_TIMER Timer = (PRTLP_TIMER) Context;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Calling WaitOrTimer:Timer: fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
               Timer->DbgId,
               (ULONG_PTR)Timer->Function, (ULONG_PTR)Timer->Context,
               TRUE,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    RtlpWaitOrTimerCallout(Timer->Function,
                           Timer->Context,
                           TRUE,
                           Timer->ActivationContext,
                           Timer->ImpersonationToken,
                           NULL);

    // decrement RefCount after function is executed so that the context is not deleted

    if ( InterlockedDecrement( &Timer->RefCount ) == 0 ) {

        RtlpDeleteTimer( Timer ) ;
    }
}

VOID
RtlpFireTimers (
    PLIST_ENTRY TimersToFireList
    )
/*++

Routine Description:

    Finally all the timers are fired here.

Arguments:

    TimersToFireList: List of timers to fire

--*/

{
    PLIST_ENTRY Node ;
    PRTLP_TIMER Timer ;
    NTSTATUS Status;
    BOOLEAN IsSingleShotWaitTimer;

    for (Node = TimersToFireList->Flink;  Node != TimersToFireList; Node = TimersToFireList->Flink)
    {
        Timer = CONTAINING_RECORD (Node, RTLP_TIMER, TimersToFireList) ;

        RemoveEntryList( Node ) ;
        InitializeListHead( Node ) ;

        IsSingleShotWaitTimer = (Timer->Wait != NULL
                                 && Timer->Period == 0);

        if ( (Timer->State & STATE_DONTFIRE)
            || (Timer->Queue->State & STATE_DONTFIRE) )
        {
            //
            // Wait timers *never* use STATE_DONTFIRE.  Let's just
            // make sure this isn't one:
            //
            ASSERT(Timer->Wait == NULL);

        } else if ( Timer->Flags & (WT_EXECUTEINTIMERTHREAD | WT_EXECUTEINWAITTHREAD ) ) {

#if DBG
            DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                       RTLP_THREADPOOL_TRACE_MASK,
                       "<%d> Calling WaitOrTimer(Timer): fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
                       Timer->DbgId,
                       (ULONG_PTR)Timer->Function, (ULONG_PTR)Timer->Context,
                       TRUE,
                       HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                       HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

            {
                PRTL_CRITICAL_SECTION const LocksHeld[] = {
                    &TimerCriticalSection,
                    NULL
                };

                RtlpWaitOrTimerCallout(Timer->Function,
                                       Timer->Context,
                                       TRUE,
                                       Timer->ActivationContext,
                                       Timer->ImpersonationToken,
                                       LocksHeld);
            }

        } else {

            // timer associated with WaitEvents should be treated differently

            if ( Timer->Wait != NULL ) {

                InterlockedIncrement( Timer->RefCountPtr ) ;

                // Set the low bit of the context to indicate to
                // RtlpAsyncWaitCallbackCompletion that this is a
                // timer-initiated callback.

                Status = RtlQueueWorkItem(RtlpAsyncWaitCallbackCompletion,
                                          (PVOID)(((ULONG_PTR) Timer->Wait) | 1),
                                          Timer->Flags);

            } else {

                InterlockedIncrement( &Timer->RefCount ) ;

                Status = RtlQueueWorkItem(RtlpAsyncTimerCallbackCompletion,
                                          Timer,
                                          Timer->Flags);
            }

            if (!NT_SUCCESS(Status)) {

                // NTRAID#202802-2000/10/12-earhart: we really ought
                // to deal with this case in a better way, since we
                // can't guarantee (with our current architecture)
                // that the enqueue will work.

                if ( Timer->Wait != NULL ) {
                    InterlockedDecrement( Timer->RefCountPtr );
                } else {
                    InterlockedDecrement( &Timer->RefCount );
                }
            }

        }

        //
        // If it's a singleshot wait timer, we can free it now.
        // (N.B. if it's *not*, the timer may be invalid by now.)
        //
        if (IsSingleShotWaitTimer) {
            RtlpFreeTPHeap(Timer);
        }

    }
}

VOID
RtlpFireTimersAndReorder (
    PRTLP_TIMER_QUEUE Queue,
    ULONG *NewFiringTime,
    PLIST_ENTRY TimersToFireList
    )
/*++

Routine Description:

    Fires all timers in TimerList that have DeltaFiringTime == 0. After firing the timers
    it reorders the timers based on their periodic times OR frees the fired one shot timers.

Arguments:

    TimerList - Timer list to work thru.

    NewFiringTime - Location where the new firing time for the first timer in the delta list
                    is returned.


Return Value:


--*/
{
    PLIST_ENTRY TNode ;
    PRTLP_TIMER Timer ;
    LIST_ENTRY ReinsertTimerList ;
    PLIST_ENTRY TimerList = &Queue->TimerList ;

    InitializeListHead (&ReinsertTimerList) ;
    *NewFiringTime = 0 ;


    for (TNode = TimerList->Flink ; (TNode != TimerList) && (*NewFiringTime == 0);
            TNode = TimerList->Flink)
    {

        Timer = CONTAINING_RECORD (TNode, RTLP_TIMER, List) ;

        // Fire all timers with delta time of 0

        if (Timer->DeltaFiringTime == 0) {

            // detach this timer from the list

            RemoveEntryList (TNode) ;

            // get next firing time

            if (!IsListEmpty(TimerList)) {

                PRTLP_TIMER TmpTimer ;

                TmpTimer = CONTAINING_RECORD (TimerList->Flink, RTLP_TIMER, List) ;

                *NewFiringTime  = TmpTimer->DeltaFiringTime ;

                TmpTimer->DeltaFiringTime = 0 ;

            } else {

                *NewFiringTime = INFINITE_TIME ;
            }


            // if timer is not periodic then remove active state. Timer will be deleted
            // when cancel timer is called.

            if (Timer->Period == 0) {

                if ( Timer->Wait ) {

                    // If one shot wait was timed out, then deactivate the
                    // wait.  Make sure that RtlpDeactivateWait knows
                    // we're going to continue using the timer's memory.

                    RtlpDeactivateWait( Timer->Wait, FALSE ) ;

                    // The timer does *not* go on the uncancelled
                    // timer list.  Initialize its list head to avoid
                    // refering to other timers.
                    InitializeListHead( &Timer->List );
                }
                else {
                    // If a normal non-periodic timer was timed out,
                    // then insert it into the uncancelled timer list.

                    InsertHeadList( &Queue->UncancelledTimerList, &Timer->List ) ;

                    // should be set at the end

                    RtlInterlockedClearBitsDiscardReturn(&Timer->State,
                                                         STATE_ACTIVE);
                }

                RtlInterlockedSetBitsDiscardReturn(&Timer->State,
                                                   STATE_ONE_SHOT_FIRED);

            } else {

                // Set the DeltaFiringTime to be the next period

                Timer->DeltaFiringTime = Timer->Period ;

                // reinsert the timer in the list.

                RtlpInsertInDeltaList (TimerList, Timer, *NewFiringTime, NewFiringTime) ;
            }


            // Call the function associated with this timer. call it in the end
            // so that RtlTimer calls can be made in the timer function

            if ( (Timer->State & STATE_DONTFIRE)
                || (Timer->Queue->State & STATE_DONTFIRE) )
            {
                //
                // Wait timers *never* use STATE_DONTFIRE.  Let's just
                // make sure this isn't one:
                //
                ASSERT(Timer->Wait == NULL);

            } else {

                InsertTailList( TimersToFireList, &Timer->TimersToFireList ) ;

            }

        } else {

            // No more Timers with DeltaFiringTime == 0

            break ;

        }
    }


    if ( *NewFiringTime == 0 ) {
        *NewFiringTime = INFINITE_TIME ;
    }
}

VOID
RtlpInsertTimersIntoDeltaList (
    IN PLIST_ENTRY NewTimerList,
    IN PLIST_ENTRY DeltaTimerList,
    IN ULONG TimeRemaining,
    OUT ULONG *NewFiringTime
    )
/*++

Routine Description:

    This routine walks thru a list of timers in NewTimerList and inserts them into a delta
    timers list pointed to by DeltaTimerList. The timeout associated with the first element
    in the new list is returned in NewFiringTime.

Arguments:

    NewTimerList - List of timers that need to be inserted into the DeltaTimerList

    DeltaTimerList - Existing delta list of zero or more timers.

    TimeRemaining - Firing time of the first element in the DeltaTimerList

    NewFiringTime - Location where the new firing time will be returned

Return Value:


--*/
{
    PRTLP_GENERIC_TIMER Timer ;
    PLIST_ENTRY TNode ;
    PLIST_ENTRY Temp ;

    for (TNode = NewTimerList->Flink ; TNode != NewTimerList ; TNode = TNode->Flink) {

        Temp = TNode->Blink ;

        RemoveEntryList (Temp->Flink) ;

        Timer = CONTAINING_RECORD (TNode, RTLP_GENERIC_TIMER, List) ;

        if (RtlpInsertInDeltaList (DeltaTimerList, Timer, TimeRemaining, NewFiringTime)) {

            TimeRemaining = *NewFiringTime ;

        }

        TNode = Temp ;

    }

}

VOID
RtlpServiceTimer (
    PVOID NotUsedArg,
    ULONG NotUsedLowTimer,
    LONG NotUsedHighTimer
    )
/*++

Routine Description:

    Services the timer. Runs in an APC.

Arguments:

    NotUsedArg - Argument is not used in this function.

    NotUsedLowTimer - Argument is not used in this function.

    NotUsedHighTimer - Argument is not used in this function.

Return Value:

Remarks:
    This APC is called only for timeouts of timer threads.

--*/
{
    PRTLP_TIMER Timer ;
    PRTLP_TIMER_QUEUE Queue ;
    PLIST_ENTRY TNode ;
    PLIST_ENTRY QNode ;
    PLIST_ENTRY Temp ;
    ULONG NewFiringTime ;
    LIST_ENTRY ReinsertTimerQueueList ;
    LIST_ENTRY TimersToFireList ;

    RtlpResync64BitTickCount() ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_VERBOSE_MASK,
               "Before service timer ThreadId<%x:%x>\n",
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
    RtlDebugPrintTimes ();
#endif

    ACQUIRE_GLOBAL_TIMER_LOCK();

    // fire it if it even 200ms ahead. else reset the timer

    if (Firing64BitTickCount.QuadPart > RtlpGet64BitTickCount(&Last64BitTickCount) + 200) {

        RtlpResetTimer (TimerHandle, RtlpGetTimeRemaining (TimerHandle), NULL) ;

        RELEASE_GLOBAL_TIMER_LOCK() ;
        return ;
    }

    InitializeListHead (&ReinsertTimerQueueList) ;

    InitializeListHead (&TimersToFireList) ;


    // We run thru all queues with DeltaFiringTime == 0 and fire all timers that
    // have DeltaFiringTime == 0. We remove the fired timers and either free them
    // (for one shot timers) or put them in aside list (for periodic timers).
    // After we have finished firing all timers in a queue we reinsert the timers
    // in the aside list back into the queue based on their new firing times.
    //
    // Similarly, we remove each fired Queue and put it in a aside list. After firing
    // all queues with DeltaFiringTime == 0, we reinsert the Queues in the aside list
    // and reprogram the NT timer to be the firing time of the first queue in the list


    for (QNode = TimerQueues.Flink ; QNode != &TimerQueues ; QNode = QNode->Flink) {

        Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;

        // If the delta time in the timer queue is 0 - then this queue
        // has timers that are ready to fire. Walk the list and fire all timers with
        // Delta time of 0

        if (Queue->DeltaFiringTime == 0) {

            // Walk all timers with DeltaFiringTime == 0 and fire them. After that
            // reinsert the periodic timers in the appropriate place.

            RtlpFireTimersAndReorder (Queue, &NewFiringTime, &TimersToFireList) ;

            // detach this Queue from the list

            QNode = QNode->Blink ;

            RemoveEntryList (QNode->Flink) ;

            // If there are timers in the queue then prepare to reinsert the queue in
            // TimerQueues.

            if (NewFiringTime != INFINITE_TIME) {

                Queue->DeltaFiringTime = NewFiringTime ;

                // put the timer in list that we will process after we have
                // fired all elements in this queue

                InsertHeadList (&ReinsertTimerQueueList, &Queue->List) ;

            } else {

                // Queue has no more timers in it. Let the Queue float.

                InitializeListHead (&Queue->List) ;

            }


        } else {

            // No more Queues with DeltaFiringTime == 0

            break ;

        }

    }

    // At this point we have fired all the ready timers. We have two lists that need to be
    // merged - TimerQueues and ReinsertTimerQueueList. The following steps do this - at the
    // end of this we will reprogram the NT Timer.

    if (!IsListEmpty(&TimerQueues)) {

        Queue = CONTAINING_RECORD (TimerQueues.Flink, RTLP_TIMER_QUEUE, List) ;

        NewFiringTime = Queue->DeltaFiringTime ;

        Queue->DeltaFiringTime = 0 ;

        if (!IsListEmpty (&ReinsertTimerQueueList)) {

            // TimerQueues and ReinsertTimerQueueList are both non-empty. Merge them.

            RtlpInsertTimersIntoDeltaList (&ReinsertTimerQueueList, &TimerQueues,
                                            NewFiringTime, &NewFiringTime) ;

        }

        // NewFiringTime contains the time the NT Timer should be programmed to.

    } else {

        if (!IsListEmpty (&ReinsertTimerQueueList)) {

            // TimerQueues is empty. ReinsertTimerQueueList is not.

            RtlpInsertTimersIntoDeltaList (&ReinsertTimerQueueList, &TimerQueues, 0,
                                            &NewFiringTime) ;

        } else {

            NewFiringTime = INFINITE_TIME ;

        }

        // NewFiringTime contains the time the NT Timer should be programmed to.

    }


    // Reset the timer to reflect the Delta time associated with the first Queue

    RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_VERBOSE_MASK,
               "After service timer:ThreadId<%x:%x>\n",
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
    RtlDebugPrintTimes ();
#endif

    // finally fire all the timers

    RtlpFireTimers( &TimersToFireList ) ;

    RELEASE_GLOBAL_TIMER_LOCK();

}

VOID
RtlpResetTimer (
    HANDLE TimerHandle,
    ULONG DueTime,
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    )
/*++

Routine Description:

    This routine resets the timer object with the new due time.

Arguments:

    TimerHandle - Handle to the timer object

    DueTime - Relative timer due time in Milliseconds

Return Value:

--*/
{
    LARGE_INTEGER LongDueTime ;

    NtCancelTimer (TimerHandle, NULL) ;

    // If the DueTime is INFINITE_TIME then set the timer to the largest integer possible

    if (DueTime >= PSEUDO_INFINITE_TIME) {

        LongDueTime.LowPart = 0x1 ;

        LongDueTime.HighPart = 0x80000000 ;

    } else {

        //
        // set the absolute time when timer is to be fired
        //

        if (ThreadCB) {

            ThreadCB->Firing64BitTickCount = DueTime
                                + RtlpGet64BitTickCount(&ThreadCB->Current64BitTickCount) ;

        } else {
            //
            // adjust for drift only if it is a global timer
            //

            ULONG Drift ;
            LONGLONG llCurrentTick ;

            llCurrentTick = RtlpGet64BitTickCount(&Last64BitTickCount) ;

            Drift = (ULONG) (llCurrentTick - RtlpGetResync64BitTickCount()) ;
            DueTime = (DueTime > Drift) ? DueTime-Drift : 1 ;
            RtlpSetFiring64BitTickCount(llCurrentTick + DueTime) ;
        }


        LongDueTime.QuadPart = (LONGLONG) UInt32x32To64( DueTime, 10000 );
        
        LongDueTime.QuadPart *= -1;

    }

#if DBG
    if ((RtlpDueTimeMax != 0) && (DueTime > RtlpDueTimeMax)) {

        DbgPrint("\n*** Requested timer due time %d is greater than max allowed (%d)\n",
                 DueTime,
                 RtlpDueTimeMax);

        DbgBreakPoint();
    }

    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "RtlpResetTimer: %dms => %p'%p in thread:<%x:%x>\n",
               DueTime,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    NtSetTimer (
        TimerHandle,
        &LongDueTime,
        ThreadCB ? NULL : RtlpServiceTimer,
        NULL,
        FALSE,
        0,
        NULL
        ) ;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

LONG
RtlpTimerThread (
    PVOID Parameter
    )
/*++

Routine Description:

    All the timer activity takes place in APCs.

Arguments:

    HandlePtr - Pointer to our handle

Return Value:

--*/
{
    LARGE_INTEGER TimeOut ;

    // no structure initializations should be done here as new timer thread
    // may be created after threadPoolCleanup

    UNREFERENCED_PARAMETER(Parameter);

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "Starting timer thread\n");
#endif

    TimerThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    // Reset the NT Timer to never fire initially
    RtlpResetTimer (TimerHandle, -1, NULL) ;

    // Signal the thread creation path that we're ready to go
    NtSetEvent(TimerThreadStartedEvent, NULL);

    // Sleep alertably so that all the activity can take place
    // in APCs

    for ( ; ; ) {

        // Set timeout for the largest timeout possible

        TimeOut.LowPart = 0 ;
        TimeOut.HighPart = 0x80000000 ;

        NtDelayExecution (TRUE, &TimeOut) ;

    }

    return 0 ;  // Keep compiler happy

}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

NTSTATUS
RtlpInitializeTimerThreadPool (
    )
/*++

Routine Description:

    This routine is used to initialize structures used for Timer Thread

Arguments:


Return Value:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER TimeOut ;
    PRTLP_EVENT Event;

    ASSERT(! RtlIsImpersonating());

    // In order to avoid an explicit RtlInitialize() function to initialize the wait thread pool
    // we use StartedTimerInitialization and CompletedTimerInitialization to provide us the
    // necessary synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() or NtCreateEvent fails - but in this case the
    // caller has not choices left.

    if (!InterlockedExchange(&StartedTimerInitialization, 1L)) {

        if (CompletedTimerInitialization)
            InterlockedExchange(&CompletedTimerInitialization, 0 ) ;

        do {

            // Initialize global timer lock

            Status = RtlInitializeCriticalSection( &TimerCriticalSection ) ;
            if (! NT_SUCCESS( Status )) {
                break ;
            }

            Status = NtCreateTimer(
                                &TimerHandle,
                                TIMER_ALL_ACCESS,
                                NULL,
                                NotificationTimer
                                ) ;

            if (!NT_SUCCESS(Status) ) {
                RtlDeleteCriticalSection( &TimerCriticalSection );
                break ;
            }

            InitializeListHead (&TimerQueues) ; // Initialize Timer Queue Structures


            // initialize tick count

            Resync64BitTickCount.QuadPart = NtGetTickCount()  ;
            Firing64BitTickCount.QuadPart = 0 ;

            Event = RtlpGetWaitEvent();
            if (! Event) {
                Status = STATUS_NO_MEMORY;
                RtlDeleteCriticalSection(&TimerCriticalSection);
                NtClose(TimerHandle);
                TimerHandle = NULL;
                break;
            }

            TimerThreadStartedEvent = Event->Handle;

            Status = RtlpStartThreadpoolThread (RtlpTimerThread,
                                                NULL, 
                                                &TimerThreadHandle);

            if (!NT_SUCCESS(Status) ) {
                RtlpFreeWaitEvent(Event);
                RtlDeleteCriticalSection( &TimerCriticalSection );
                NtClose(TimerHandle);
                TimerHandle = NULL;
                break ;
            }

            Status = NtWaitForSingleObject(TimerThreadStartedEvent,
                                           FALSE,
                                           NULL);

            RtlpFreeWaitEvent(Event);
            TimerThreadStartedEvent = NULL;

            if (! NT_SUCCESS(Status)) {
                RtlDeleteCriticalSection( &TimerCriticalSection );
                NtClose(TimerHandle);
                TimerHandle = NULL;
                break ;
            }

        } while(FALSE ) ;

        if (!NT_SUCCESS(Status) ) {

            StartedTimerInitialization = 0 ;
            InterlockedExchange (&CompletedTimerInitialization, ~0) ;

            return Status ;
        }

        InterlockedExchange (&CompletedTimerInitialization, 1L) ;

    } else {

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!*((ULONG volatile *)&CompletedTimerInitialization)) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

        if (CompletedTimerInitialization != 1)
            Status = STATUS_NO_MEMORY ;
    }

    return NT_SUCCESS(Status) ? STATUS_SUCCESS : Status ;
}

NTSTATUS
RtlCreateTimerQueue(
    OUT PHANDLE TimerQueueHandle
    )

/*++

Routine Description:

    This routine creates a queue that can be used to queue time based tasks.

Arguments:

    TimerQueueHandle - Returns back the Handle identifying the timer queue created.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer Queue created successfully.

        STATUS_NO_MEMORY - There was not sufficient heap to perform the
            requested operation.

--*/

{
    PRTLP_TIMER_QUEUE Queue ;
    NTSTATUS Status;
    HANDLE Token = NULL;

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = RtlpCaptureImpersonation(FALSE, &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    // Initialize the timer component if it hasnt been done already

    if (CompletedTimerInitialization != 1) {

        Status = RtlpInitializeTimerThreadPool () ;

        if ( !NT_SUCCESS(Status) )
            goto cleanup ;
    }


    InterlockedIncrement( &NumTimerQueues ) ;


    // Allocate a Queue structure

    Queue = (PRTLP_TIMER_QUEUE) RtlpAllocateTPHeap (
                                      sizeof (RTLP_TIMER_QUEUE),
                                      HEAP_ZERO_MEMORY
                                      ) ;

    if (Queue == NULL) {

        InterlockedDecrement( &NumTimerQueues ) ;
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Queue->RefCount = 1 ;


    // Initialize the allocated queue

    InitializeListHead (&Queue->List) ;
    InitializeListHead (&Queue->TimerList) ;
    InitializeListHead (&Queue->UncancelledTimerList) ;
    SET_TIMER_QUEUE_SIGNATURE( Queue ) ;

    Queue->DeltaFiringTime = 0 ;

#if DBG1
    Queue->DbgId = ++NextTimerDbgId ;
    Queue->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> TimerQueue %x created by thread:<%x:%x>\n",
               Queue->DbgId, 1, (ULONG_PTR)Queue,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

    *TimerQueueHandle = Queue ;

    Status = STATUS_SUCCESS;

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status;
}

ULONG
RtlpGetQueueRelativeTime (
    PRTLP_TIMER_QUEUE Queue
    )
/*++

Routine Description:

    Walks the list of queues and returns the relative firing time by adding all the
    DeltaFiringTimes for all queues before it.

Arguments:

    Queue - Queue for which to find the relative firing time

Return Value:

    Time in milliseconds

--*/
{
    PLIST_ENTRY Node ;
    ULONG RelativeTime ;
    PRTLP_TIMER_QUEUE CurrentQueue ;

    RelativeTime = 0 ;

    // It the Queue is not attached to TimerQueues List because it has no timer
    // associated with it simply returns 0 as the relative time. Else run thru
    // all queues before it in the list and compute the relative firing time

    if (!IsListEmpty (&Queue->List)) {

        for (Node = TimerQueues.Flink; Node != &Queue->List; Node=Node->Flink) {

            CurrentQueue = CONTAINING_RECORD (Node, RTLP_TIMER_QUEUE, List) ;

            RelativeTime += CurrentQueue->DeltaFiringTime ;

        }

        // Add the queue's delta firing time as well

        RelativeTime += Queue->DeltaFiringTime ;

    }

    return RelativeTime ;

}

VOID
RtlpDeactivateTimer (
    PRTLP_TIMER_QUEUE Queue,
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in an APC and cancels the specified timer if it exists

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;


    // Remove the timer from the appropriate queue

    TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
    QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;

#if DBG
    if ((RtlpDueTimeMax != 0)
        && (QueueRelTimeRemaining > RtlpDueTimeMax)) {
        DbgPrint("\n*** Queue due time %d is greater than max allowed (%d) in RtlpDeactivateTimer\n",
                 QueueRelTimeRemaining,
                 RtlpDueTimeMax);

            DbgBreakPoint();
    }
#endif
        
    if (RtlpRemoveFromDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining, &NewFiringTime)) {

        // If we removed the last timer from the queue then we should remove the queue
        // from TimerQueues, else we should readjust its position based on the delta time change

        if (IsListEmpty (&Queue->TimerList)) {

            // Remove the queue from TimerQueues

            if (RtlpRemoveFromDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }

            InitializeListHead (&Queue->List) ;

        } else {

            // If we remove from the head of the timer delta list we will need to
            // make sure the queue delta list is readjusted

            if (RtlpReOrderDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }

        }

    }
}

VOID
RtlpCancelTimerEx (
    PRTLP_TIMER Timer,
    BOOLEAN DeletingQueue
    )
/*++

Routine Description:

    This routine cancels the specified timer.

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information
    DeletingQueue - FALSE: routine executing in an APC. Delete timer only.
                    TRUE : routine called by timer queue which is being deleted. So dont
                            reset the queue's position
Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue ;

    RtlpResync64BitTickCount() ;
    CHECK_SIGNATURE( Timer ) ;
    SET_DEL_SIGNATURE( Timer ) ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> RtlpCancelTimerEx: Timer: %p Thread<%d:%d>\n",
               Timer->Queue->DbgId,
               Timer->DbgId,
               Timer,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    Queue = Timer->Queue ;


    if ( Timer->State & STATE_ACTIVE ) {

        // if queue is being deleted, then the timer should not be reset

        if ( ! DeletingQueue )
            RtlpDeactivateTimer( Queue, Timer ) ;

    } else {

        // remove one shot Inactive timer from Queue->UncancelledTimerList
        // called only when the time queue is being deleted

        RemoveEntryList( &Timer->List ) ;

    }


    // Set the State to deleted

    RtlInterlockedSetBitsDiscardReturn(&Timer->State,
                                       STATE_DELETE);


    // delete timer if refcount == 0

    if ( InterlockedDecrement( &Timer->RefCount ) == 0 ) {

        RtlpDeleteTimer( Timer ) ;
    }
}

VOID
RtlpDeleteTimerQueueComplete (
    PRTLP_TIMER_QUEUE Queue
    )
/*++

Routine Description:

    This routine frees the queue and sets the event.

Arguments:

    Queue - queue to delete

    Event - Event Handle used for signalling completion of request

Return Value:

--*/
{
#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Queue: %x: deleted\n", Queue->DbgId,
               (ULONG_PTR)Queue) ;
#endif

    InterlockedDecrement( &NumTimerQueues ) ;

    // Notify the thread issuing the cancel that the request is completed

    if ( Queue->CompletionEvent )
        NtSetEvent (Queue->CompletionEvent, NULL) ;

    RtlpFreeTPHeap( Queue ) ;
}

NTSTATUS
RtlpDeleteTimerQueue (
    PRTLP_TIMER_QUEUE Queue
    )
/*++

Routine Description:

    This routine deletes the queue specified in the Request and frees all timers

Arguments:

    Queue - queue to delete

    Event - Event Handle used for signalling completion of request

Return Value:

--*/
{
    ULONG TimeRemaining ;
    ULONG NewFiringTime ;
    PLIST_ENTRY Node ;
    PRTLP_TIMER Timer ;

    RtlpResync64BitTickCount() ;

    SET_DEL_SIGNATURE( Queue ) ;
    SET_DEL_TIMERQ_SIGNATURE( Queue ) ;


    // If there are no timers in the queue then it is not attached to TimerQueues
    // In this case simply free the memory and return. Otherwise we have to first
    // remove the queue from the TimerQueues List, update the firing time if this
    // was the first queue in the list and then walk all the timers and free them
    // before freeing the Timer Queue.

    if (!IsListEmpty (&Queue->List)) {

        TimeRemaining = RtlpGetTimeRemaining (TimerHandle)
                        + RtlpGetQueueRelativeTime (Queue) ;

#if DBG
        if ((RtlpDueTimeMax != 0)
            && (TimeRemaining > RtlpDueTimeMax)) {
            DbgPrint("\n*** Queue due time %d is greater than max allowed (%d) in RtlpDeleteTimerQueue\n",
                     TimeRemaining,
                     RtlpDueTimeMax);

            DbgBreakPoint();
        }
#endif
        
        if (RtlpRemoveFromDeltaList (&TimerQueues, Queue, TimeRemaining,
                                    &NewFiringTime))
        {

            // If removed from head of queue list, reset the timer

            RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;
        }


        // Free all the timers associated with this queue

        for (Node = Queue->TimerList.Flink ; Node != &Queue->TimerList ; ) {

            Timer =  CONTAINING_RECORD (Node, RTLP_TIMER, List) ;

            Node = Node->Flink ;

            RtlpCancelTimerEx( Timer ,TRUE ) ; // Queue being deleted
        }
    }


    // Free all the uncancelled one shot timers in this queue

    for (Node = Queue->UncancelledTimerList.Flink ; Node != &Queue->UncancelledTimerList ; ) {

        Timer =  CONTAINING_RECORD (Node, RTLP_TIMER, List) ;

        Node = Node->Flink ;

        RtlpCancelTimerEx( Timer ,TRUE ) ; // Queue being deleted
    }


    // delete the queue completely if the RefCount is 0

    if ( InterlockedDecrement( &Queue->RefCount ) == 0 ) {

        RtlpDeleteTimerQueueComplete( Queue ) ;

        return STATUS_SUCCESS ;

    } else {

        return STATUS_PENDING ;
    }

}

NTSTATUS
RtlDeleteTimerQueueEx (
    HANDLE QueueHandle,
    HANDLE Event
    )
/*++

Routine Description:

    This routine deletes the queue specified in the Request and frees all timers.
    This call is blocking or non-blocking depending on the value passed for Event.
    Blocking calls cannot be made from ANY Timer callbacks. After this call returns,
    no new Callbacks will be fired for any timer associated with the queue.

Arguments:

    QueueHandle - queue to delete

    Event - Event to wait upon.
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an event. The function marks the queue for deletion,
                    but does not wait for all callbacks to complete. The event is
                    signalled after all callbacks have completed.
            NULL : The function is non-blocking. The function marks the queue for deletion,
                    but does not wait for all callbacks to complete.

Return Value:

    STATUS_SUCCESS - All timer callbacks have completed.
    STATUS_PENDING - Non-Blocking call. Some timer callbacks associated with timers
                    in this queue may not have completed.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut ;
    PRTLP_EVENT CompletionEvent = NULL ;
    PRTLP_TIMER_QUEUE Queue = (PRTLP_TIMER_QUEUE)QueueHandle ;
#if DBG
    ULONG QueueDbgId;
#endif
    HANDLE Token = NULL;

    if (LdrpShutdownInProgress) {
        return STATUS_SUCCESS;
    }

    if (!Queue) {
        return STATUS_INVALID_PARAMETER_1 ;
    }

    Status = RtlpCaptureImpersonation(FALSE, &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    CHECK_DEL_SIGNATURE( Queue );
    SET_DEL_PENDING_SIGNATURE( Queue ) ;

#if DBG1
    Queue->ThreadId2 = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    QueueDbgId = Queue->DbgId;
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> Queue Delete(Queue:%x Event:%x by Thread:<%x:%x>)\n",
               QueueDbgId, Queue->RefCount, (ULONG_PTR)Queue, (ULONG_PTR)Event,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif


    if (Event == (HANDLE)-1 ) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            Status = STATUS_NO_MEMORY ;
            goto cleanup;

        }
    }

    Queue->CompletionEvent = CompletionEvent
                             ? CompletionEvent->Handle
                             : Event ;


    // once this flag is set, no timer will be fired

    ACQUIRE_GLOBAL_TIMER_LOCK();
    RtlInterlockedSetBitsDiscardReturn(&Queue->State,
                                       STATE_DONTFIRE);
    RELEASE_GLOBAL_TIMER_LOCK();



    // queue an APC

    Status = NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpDeleteTimerQueue,
                    (PVOID) QueueHandle,
                    NULL,
                    NULL
                    );

    if (! NT_SUCCESS(Status)) {

        if ( CompletionEvent ) {
            RtlpFreeWaitEvent( CompletionEvent ) ;
        }

        goto cleanup;
    }

    if (CompletionEvent) {

        // wait for Event to be fired. Return if the thread has been killed.


#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "<%d> Queue %p delete waiting Thread<%d:%d>\n",
                   QueueDbgId,
                   (ULONG_PTR)Queue,
                   HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                   HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif


        Status = RtlpWaitForEvent( CompletionEvent->Handle, TimerThreadHandle ) ;


#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "<%d> Queue %p delete completed\n",
                   QueueDbgId,
                   (ULONG_PTR) Queue) ;
#endif

        RtlpFreeWaitEvent( CompletionEvent ) ;

        Status = NT_SUCCESS( Status ) ? STATUS_SUCCESS : Status ;
        goto cleanup;

    } else {
        Status = STATUS_PENDING ;
        goto cleanup;
    }

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status;
}

NTSTATUS
RtlDeleteTimerQueue(
    IN HANDLE TimerQueueHandle
    )

/*++

Routine Description:

    This routine deletes a previously created queue. This call is non-blocking and
    can be made from Callbacks. Pending callbacks already queued to worker threads
    are not cancelled.

Arguments:

    TimerQueueHandle - Handle identifying the timer queue created.

Return Value:

    NTSTATUS - Result code from call.

        STATUS_PENDING - Timer Queue created successfully.

--*/

{
    return RtlDeleteTimerQueueEx( TimerQueueHandle, NULL ) ;
}

VOID
RtlpAddTimer (
    PRTLP_TIMER Timer,
    PRTLP_EVENT StartEvent
    )
/*++

Routine Description:

    This routine runs as an APC into the Timer thread. It adds a new timer to the
    specified queue.

Arguments:

    Timer - Pointer to the timer to add

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue = Timer->Queue;
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;

    ASSERT(StartEvent);
    NtWaitForSingleObject(StartEvent->Handle, FALSE, NULL);
    RtlpFreeWaitEvent(StartEvent);

    RtlpResync64BitTickCount() ;


    // the timer was set to be deleted in a callback function.

    if (Timer->State & STATE_DELETE ) {

        RtlpDeleteTimer( Timer ) ;
        return ;
    }

    // Check if the timer queue is already deleted -- that is, if it's 
    // delete has already been fully processed, not just enqueued.
    if (IS_DEL_SIGNATURE_SET(Queue)) {
        RtlpDeleteTimer(Timer);
        return;
    }

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> RtlpAddTimer: Timer: %p Delta: %dms Period: %dms Thread<%d:%d>\n",
               Timer->Queue->DbgId,
               Timer->DbgId,
               Timer,
               Timer->DeltaFiringTime,
               Timer->Period,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    // TimeRemaining is the time left in the current timer + the relative time of
    // the queue it is being inserted into

    TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
    QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;

#if DBG
    if ((RtlpDueTimeMax != 0)
        && (QueueRelTimeRemaining > RtlpDueTimeMax)) {
        DbgPrint("\n*** Queue due time %d is greater than max allowed (%d) in RtlpAddTimer\n",
                 QueueRelTimeRemaining,
                 RtlpDueTimeMax);

            DbgBreakPoint();
    }
#endif
        
    if (RtlpInsertInDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining,
                                &NewFiringTime))
    {

        // If the Queue is not attached to TimerQueues since it had no timers
        // previously then insert the queue into the TimerQueues list, else just
        // reorder its existing position.

        if (IsListEmpty (&Queue->List)) {

            Queue->DeltaFiringTime = NewFiringTime ;

            if (RtlpInsertInDeltaList (&TimerQueues, Queue, TimeRemaining,
                                        &NewFiringTime))
            {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire sooner.

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;
            }

        } else {

            // If we insert at the head of the timer delta list we will need to
            // make sure the queue delta list is readjusted

            if (RtlpReOrderDeltaList(&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)){

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire sooner.

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }
        }

    }

    RtlInterlockedSetBitsDiscardReturn(&Timer->State,
                                       STATE_REGISTERED | STATE_ACTIVE);
}

VOID
RtlpTimerReleaseWorker(ULONG Flags)
{
    if (! (Flags & WT_EXECUTEINTIMERTHREAD)) {
        RtlpReleaseWorker(Flags);
    }
}

NTSTATUS
RtlCreateTimer(
    IN  HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  DueTime,
    IN  ULONG  Period,
    IN  ULONG  Flags
    )
/*++

Routine Description:

    This routine puts a timer request in the queue identified in by TimerQueueHandle.
    The timer request can be one shot or periodic.

Arguments:

    TimerQueueHandle - Handle identifying the timer queue in which to insert the timer
                    request.

    Handle - Specifies a location to return a handle to this timer request

    Function - Routine that is called when the timer fires

    Context - Opaque pointer passed in as an argument to WorkerProc

    DueTime - Specifies the time in milliseconds after which the timer fires.

    Period - Specifies the period of the timer in milliseconds. This should be 0 for
    one shot requests.

    Flags - Can be one of:

            WT_EXECUTEINTIMERTHREAD - if WorkerProc should be invoked in the wait thread
            it this should only be used for small routines.

            WT_EXECUTELONGFUNCTION - if WorkerProc can possibly block for a long time.

            WT_EXECUTEINIOTHREAD - if WorkerProc should be invoked in IO worker thread

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer Queue created successfully.

        STATUS_NO_MEMORY - There was not sufficient heap to perform the
            requested operation.

--*/

{
    NTSTATUS Status;
    PRTLP_TIMER Timer;
    PRTLP_TIMER_QUEUE Queue = (PRTLP_TIMER_QUEUE) TimerQueueHandle;
    PRTLP_EVENT StartEvent;
    HANDLE Token = NULL;

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = RtlpCaptureImpersonation(Flags & WT_TRANSFER_IMPERSONATION,
                                      &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    if (Flags&0xffff0000) {
        MaxThreads = (Flags & 0xffff0000)>>16;
    }

    // check if timer queue already deleted

    if (IS_DEL_PENDING_SIGNATURE_SET(Queue)) {
        Status = STATUS_INVALID_HANDLE;
        goto cleanup_token;
    }

    StartEvent = RtlpGetWaitEvent();
    if (! StartEvent) {
        Status = STATUS_NO_MEMORY;
        goto cleanup_token;
    }

    if (! (Flags & WT_EXECUTEINTIMERTHREAD)) {
        Status = RtlpAcquireWorker(Flags);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_waitevent;
        }
    }

    Timer = (PRTLP_TIMER) RtlpAllocateTPHeap (
                                sizeof (RTLP_TIMER),
                                HEAP_ZERO_MEMORY
                                ) ;

    if (Timer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup_worker;
    }

    // Initialize the allocated timer

    Status = RtlpThreadPoolGetActiveActivationContext(&Timer->ActivationContext);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SXS_THREAD_QUERIES_DISABLED) {
            Timer->ActivationContext = INVALID_ACTIVATION_CONTEXT;
            Status = STATUS_SUCCESS;
        } else {
            goto cleanup_timerblock;
        }
    }

    if (Token && (Flags & WT_TRANSFER_IMPERSONATION)) {
        Status = NtDuplicateToken(Token,
                                  TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                  NULL,
                                  FALSE,
                                  TokenImpersonation,
                                  &Timer->ImpersonationToken);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_actctx;
        }
    } else {
        Timer->ImpersonationToken = NULL;
    }

    Timer->DeltaFiringTime = DueTime ;
    Timer->Queue = Queue;
    Timer->RefCount = 1 ;
    Timer->Flags = Flags ;
    Timer->Function = Function ;
    Timer->Context = Context ;
    //todo:remove below
    Timer->Period = (Period == -1) ? 0 : Period;
    InitializeListHead( &Timer->TimersToFireList ) ;
    InitializeListHead( &Timer->List ) ;
    SET_TIMER_SIGNATURE( Timer ) ;


#if DBG1
    Timer->DbgId = ++ Timer->Queue->NextDbgId ;
    Timer->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d:%d> Timer: created by Thread:<%x:%x>\n",
               Timer->Queue->DbgId, Timer->DbgId, 1,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

    // Increment the total number of timers in the queue

    InterlockedIncrement( &((PRTLP_TIMER_QUEUE)TimerQueueHandle)->RefCount ) ;


    // Queue APC to timer thread

    Status = NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpAddTimer,
                    (PVOID)Timer,
                    (PVOID)StartEvent,
                    NULL
                    ) ;

    if (NT_SUCCESS(Status)) {
        // We successfully queued the APC -- the timer is now valid
        *Handle = Timer ;
	NtSetEvent(StartEvent->Handle, NULL);
	Status = STATUS_SUCCESS;
        goto cleanup_token;
    }

    // Error path
    if (InterlockedDecrement(&((PRTLP_TIMER_QUEUE)TimerQueueHandle)->RefCount)
        == 0) {
        RtlpDeleteTimerQueueComplete(Queue);
    }

    if (Timer->ImpersonationToken) {
        NtClose(Timer->ImpersonationToken);
    }

 cleanup_actctx:
    if (Timer->ActivationContext != INVALID_ACTIVATION_CONTEXT)
        RtlReleaseActivationContext (Timer->ActivationContext);

 cleanup_timerblock:
    RtlpFreeTPHeap(Timer);

 cleanup_worker:
    RtlpTimerReleaseWorker(Flags);

 cleanup_waitevent:
    RtlpFreeWaitEvent(StartEvent);

    // Common cleanup path
 cleanup_token:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status ;
}

VOID
RtlpUpdateTimer (
    PRTLP_TIMER Timer,
    PRTLP_TIMER UpdatedTimer
    )
/*++

Routine Description:

    This routine executes in an APC and updates the specified timer if it exists

Arguments:

    Timer - Timer that is actually updated
    UpdatedTimer - Specifies pointer to a timer structure that contains Queue and
                Timer information

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue ;
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> RtlpUpdateTimer: Timer: %p Updated: %p Delta: %dms Period: %dms Thread<%d:%d>\n",
               Timer->Queue->DbgId,
               Timer->DbgId,
               Timer,
               UpdatedTimer,
               UpdatedTimer->DeltaFiringTime,
               UpdatedTimer->Period,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    try {
        RtlpResync64BitTickCount( ) ;

        CHECK_SIGNATURE(Timer) ;

        Queue = Timer->Queue ;

        if (IS_DEL_SIGNATURE_SET(Queue)) {
            leave;
        }
        
        // Update the periodic time on the timer

        Timer->Period = UpdatedTimer->Period ;

        // if timer is not in active state, then dont update it

        if ( ! ( Timer->State & STATE_ACTIVE ) ) {
            leave;
        }

        // Get the time remaining on the NT timer

        TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
        QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;
#if DBG
        if ((RtlpDueTimeMax != 0)
            && (QueueRelTimeRemaining > RtlpDueTimeMax)) {
            DbgPrint("\n*** Queue due time %d is greater than max allowed (%d) in RtlpUpdateTimer\n",
                     QueueRelTimeRemaining,
                     RtlpDueTimeMax);

            DbgBreakPoint();
        }
#endif

        // Update the timer based on the due time

        if (RtlpReOrderDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining,
                                  &NewFiringTime,
                                  UpdatedTimer->DeltaFiringTime))
            {

                // If this update caused the timer at the head of the queue to change, then reinsert
                // this queue in the list of queues.

                if (RtlpReOrderDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)) {

                    // NT timer needs to be updated since the change caused the queue at the head of
                    // the TimerQueues to change.

                    RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

                }

            }
    } finally {
        RtlpFreeTPHeap( UpdatedTimer ) ;
    }
}

NTSTATUS
RtlUpdateTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE Timer,
    IN ULONG  DueTime,
    IN ULONG  Period
    )
/*++

Routine Description:

    This routine updates the timer

Arguments:

    TimerQueueHandle - Handle identifying the queue in which the timer to be updated exists

    Timer - Specifies a handle to the timer which needs to be updated

    DueTime - Specifies the time in milliseconds after which the timer fires.

    Period - Specifies the period of the timer in milliseconds. This should be
            0 for one shot requests.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer updated successfully.

--*/
{
    NTSTATUS Status;
    PRTLP_TIMER TmpTimer, ActualTimer=(PRTLP_TIMER)Timer ;
    PRTLP_TIMER_QUEUE Queue = (PRTLP_TIMER_QUEUE) TimerQueueHandle;

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!TimerQueueHandle) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (!Timer) {
        return STATUS_INVALID_PARAMETER_2;
    }

    // check if timer queue already deleted

    if (IS_DEL_PENDING_SIGNATURE_SET(Queue)) {
        return STATUS_INVALID_HANDLE;
    }
    
    CHECK_DEL_SIGNATURE(ActualTimer) ;

    TmpTimer = (PRTLP_TIMER) RtlpAllocateTPHeap (
                                        sizeof (RTLP_TIMER),
                                        0
                                        ) ;

    if (TmpTimer == NULL) {
        return STATUS_NO_MEMORY ;
    }

    TmpTimer->DeltaFiringTime = DueTime;
    //todo:remove below
    if (Period==-1) Period = 0;
    TmpTimer->Period = Period ;

#if DBG1
    ActualTimer->ThreadId2 = 
                    HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d:%d> Timer: updated by Thread:<%x:%x>\n",
               ((PRTLP_TIMER)Timer)->Queue->DbgId,
               ((PRTLP_TIMER)Timer)->DbgId, ((PRTLP_TIMER)Timer)->RefCount,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

    // queue APC to update timer

    Status = NtQueueApcThread (
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpUpdateTimer,
                    (PVOID)Timer, //Actual timer
                    (PVOID)TmpTimer,
                    NULL
                    );
    if (!NT_SUCCESS (Status)) {
        RtlpFreeTPHeap(TmpTimer);
    }

    return Status ;
}

VOID
RtlpCancelTimer (
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in an APC and cancels the specified timer if it exists

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    RtlpCancelTimerEx( Timer, FALSE ) ; // queue not being deleted
}

NTSTATUS
RtlDeleteTimer (
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel,
    IN HANDLE Event
    )
/*++

Routine Description:

    This routine cancels the timer

Arguments:

    TimerQueueHandle - Handle identifying the queue from which to delete timer

    TimerToCancel - Handle identifying the timer to cancel

    Event - Event to be signalled when the timer is deleted
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an event. The function marks the timer for deletion,
                    but does not wait for all callbacks to complete. The event is
                    signalled after all callbacks have completed.
            NULL : The function is non-blocking. The function marks the timer for deletion,
                    but does not wait for all callbacks to complete.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer cancelled. No pending callbacks.
        STATUS_PENDING - Timer cancelled. Some callbacks still not completed.

--*/
{
    NTSTATUS Status;
    PRTLP_EVENT CompletionEvent = NULL ;
    PRTLP_TIMER Timer = (PRTLP_TIMER) TimerToCancel ;
    ULONG TimerRefCount ;
    HANDLE Token = NULL;
#if DBG
    ULONG QueueDbgId ;
#endif

    if (LdrpShutdownInProgress) {
        return STATUS_SUCCESS;
    }

    if (!TimerQueueHandle) {
        return STATUS_INVALID_PARAMETER_1 ;
    }
    if (!TimerToCancel) {
        return STATUS_INVALID_PARAMETER_2 ;
    }

    Status = RtlpCaptureImpersonation(FALSE, &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

#if DBG
    QueueDbgId = Timer->Queue->DbgId ;
#endif


    CHECK_DEL_SIGNATURE( Timer );
    SET_DEL_PENDING_SIGNATURE( Timer );
    CHECK_DEL_PENDING_SIGNATURE( (PRTLP_TIMER_QUEUE)TimerQueueHandle ) ;


    if (Event == (HANDLE)-1 ) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            Status = STATUS_NO_MEMORY ;
            goto cleanup;
        }
    }

#if DBG1
    Timer->ThreadId2 = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d:%d> Timer: Cancel:(Timer:%x, Event:%x)\n",
               Timer->Queue->DbgId, Timer->DbgId, Timer->RefCount,
               (ULONG_PTR)Timer, (ULONG_PTR)Event) ;
#endif

    Timer->CompletionEvent = CompletionEvent
                            ? CompletionEvent->Handle
                            : Event ;


    ACQUIRE_GLOBAL_TIMER_LOCK();
    RtlInterlockedSetBitsDiscardReturn(&Timer->State,
                                       STATE_DONTFIRE);
    TimerRefCount = Timer->RefCount ;
    RELEASE_GLOBAL_TIMER_LOCK();


    Status = NtQueueApcThread(
                TimerThreadHandle,
                (PPS_APC_ROUTINE)RtlpCancelTimer,
                (PVOID)TimerToCancel,
                NULL,
                NULL
                );

    if (! NT_SUCCESS(Status)) {

        if ( CompletionEvent ) {
            RtlpFreeWaitEvent( CompletionEvent ) ;
        }

        goto cleanup;
    }



    if ( CompletionEvent ) {

        // wait for the event to be signalled

#if DBG
      DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                 RTLP_THREADPOOL_TRACE_MASK,
                 "<%d> Timer: %x: Cancel waiting Thread<%d:%d>\n",
                 QueueDbgId, (ULONG_PTR)Timer,
                 HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                 HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

        Status = RtlpWaitForEvent( CompletionEvent->Handle,  TimerThreadHandle ) ;


#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "<%d> Timer: %x: Cancel waiting done\n", QueueDbgId,
                   (ULONG_PTR)Timer) ;
#endif

        RtlpFreeWaitEvent( CompletionEvent ) ;

        Status = NT_SUCCESS(Status) ? STATUS_SUCCESS : Status ;

    } else {

        Status = (TimerRefCount > 1) ? STATUS_PENDING : STATUS_SUCCESS;
    }

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status;
}

VOID
RtlpDeleteTimer (
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in worker or timer thread and deletes the timer
    whose RefCount == 0. The function can be called outside timer thread,
    so no structure outside Timer can be touched (no list etc).

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue = Timer->Queue ;
    HANDLE Event;

    CHECK_SIGNATURE( Timer ) ;
    CLEAR_SIGNATURE( Timer ) ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Timer: %x: deleted\n", Timer->Queue->DbgId,
               (ULONG_PTR)Timer) ;
#endif

    // safe to call this. Either the timer is in the TimersToFireList and
    // the function is being called in time context or else it is not in the
    // list

    RemoveEntryList( &Timer->TimersToFireList ) ;

    Event = Timer->CompletionEvent;

    // decrement the total number of timers in the queue

    if ( InterlockedDecrement( &Queue->RefCount ) == 0 )

        RtlpDeleteTimerQueueComplete( Queue ) ;

    RtlpTimerReleaseWorker(Timer->Flags);
    if (Timer->ActivationContext != INVALID_ACTIVATION_CONTEXT)
        RtlReleaseActivationContext(Timer->ActivationContext);

    if (Timer->ImpersonationToken) {
        NtClose(Timer->ImpersonationToken);
    }

    RtlpFreeTPHeap( Timer ) ;

    if ( Event ) {
        NtSetEvent( Event, NULL ) ;
    }
}

ULONG
RtlpGetTimeRemaining (
    HANDLE TimerHandle
    )
/*++

Routine Description:

    Gets the time remaining on the specified NT timer

Arguments:

    TimerHandle - Handle to the NT timer

Return Value:

    Time remaining on the timer

--*/
{
    ULONG InfoLen ;
    TIMER_BASIC_INFORMATION Info ;
    NTSTATUS Status ;
    LARGE_INTEGER RemainingTime;

    Status = NtQueryTimer (TimerHandle, TimerBasicInformation, &Info, sizeof(Info), &InfoLen) ;

    if (! NT_SUCCESS(Status)) {
        ASSERTMSG ("NtQueryTimer failed", Status == STATUS_SUCCESS) ;
        return 0;
    }

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "RtlpGetTimeRemaining: Read SignalState %d, time %p'%p in thread:<%x:%x>\n",
               Info.TimerState,
               Info.RemainingTime.HighPart,
               Info.RemainingTime.LowPart,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif

    // Due to an executive bug, Info.TimerState and Info.RemainingTime
    // may be out of sync -- it's possible for us to be told that the
    // timer has not fired, but that it will fire very far into the
    // future (because we use ULONGLONGs), when in fact it's *just* fired.
    //
    // So: if the time remaining on the timer is negative, we'll
    // assume that it just fired, and invert it.  We'll use this as
    // our signal state, too, instead of trusting the one from the
    // executive.

    if (Info.RemainingTime.QuadPart < 0) {

        // The timer has fired.

        return 0;

    } else {

        // Capture the remaining time.
        
        RemainingTime = Info.RemainingTime;

        // Translate the remaining time from 100ns units to ms,
        // clamping at PSEUDO_INFINITE_TIME.

        RemainingTime.QuadPart /= (10 * 1000); /* 100ns per ms */

        if (RemainingTime.QuadPart > PSEUDO_INFINITE_TIME) {
            RemainingTime.QuadPart = PSEUDO_INFINITE_TIME;
        }

        ASSERT(RemainingTime.HighPart == 0);

#if DBG
        if ((RtlpDueTimeMax != 0)
            && ((ULONG) RemainingTime.LowPart > RtlpDueTimeMax)) {
            DbgPrint("\n*** Discovered timer due time %d is greater than max allowed (%d)\n",
                     RemainingTime.LowPart,
                     RtlpDueTimeMax);

            DbgBreakPoint();
        }
#endif
        
        return RemainingTime.LowPart;

    }

}

BOOLEAN
RtlpInsertInDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER NewTimer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime
    )
/*++

Routine Description:

    Inserts the timer element in the appropriate place in the delta list.

Arguments:

    DeltaList - Delta list to insert into

    NewTimer - Timer element to insert into list

    TimeRemaining - This time must be added to the head of the list to get "real"
                    relative time.

    NewFiringTime - If the new element was inserted at the head of the list - this
                    will contain the new firing time in milliseconds. The caller
                    can use this time to re-program the NT timer. This MUST NOT be
                    changed if the function returns FALSE.

Return Value:

    TRUE - If the timer was inserted at head of delta list

    FALSE - otherwise

--*/
{
    PLIST_ENTRY Node ;
    PRTLP_GENERIC_TIMER Temp ;
    PRTLP_GENERIC_TIMER Head ;

    if (IsListEmpty (DeltaList)) {

        InsertHeadList (DeltaList, &NewTimer->List) ;

        *NewFiringTime = NewTimer->DeltaFiringTime ;

        NewTimer->DeltaFiringTime = 0 ;

        return TRUE ;

    }

    // Adjust the head of the list to reflect the time remaining on the NT timer

    Head = CONTAINING_RECORD (DeltaList->Flink, RTLP_GENERIC_TIMER, List) ;

    Head->DeltaFiringTime += TimeRemaining ;


    // Find the appropriate location to insert this element in

    for (Node = DeltaList->Flink ; Node != DeltaList ; Node = Node->Flink) {

        Temp = CONTAINING_RECORD (Node, RTLP_GENERIC_TIMER, List) ;


        if (Temp->DeltaFiringTime <= NewTimer->DeltaFiringTime) {

            NewTimer->DeltaFiringTime -= Temp->DeltaFiringTime ;

        } else {

            // found appropriate place to insert this timer

            break ;

        }

    }

    // Either we have found the appopriate node to insert before in terms of deltas.
    // OR we have come to the end of the list. Insert this timer here.

    InsertHeadList (Node->Blink, &NewTimer->List) ;


    // If this isnt the last element in the list - adjust the delta of the
    // next element

    if (Node != DeltaList) {

        Temp->DeltaFiringTime -= NewTimer->DeltaFiringTime ;

    }


    // Check if element was inserted at head of list

    if (DeltaList->Flink == &NewTimer->List) {

        // Set NewFiringTime to the time in milliseconds when the new head of list
        // should be serviced.

        *NewFiringTime = NewTimer->DeltaFiringTime ;

        // This means the timer must be programmed to service this request

        NewTimer->DeltaFiringTime = 0 ;

        return TRUE ;

    } else {

        // No change to the head of the list, set the delta time back

        Head->DeltaFiringTime -= TimeRemaining ;

        return FALSE ;

    }

}

BOOLEAN
RtlpRemoveFromDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime
    )
/*++

Routine Description:

    Removes the specified timer from the delta list

Arguments:

    DeltaList - Delta list to insert into

    Timer - Timer element to insert into list

    TimerHandle - Handle of the NT Timer object

    TimeRemaining - This time must be added to the head of the list to get "real"
                    relative time.

Return Value:

    TRUE if the timer was removed from head of timer list
    FALSE otherwise

--*/
{
    PLIST_ENTRY Next ;
    PRTLP_GENERIC_TIMER Temp ;

    Next = Timer->List.Flink ;

    RemoveEntryList (&Timer->List) ;

    if (IsListEmpty (DeltaList)) {

        *NewFiringTime = INFINITE_TIME ;

        return TRUE ;

    }

    if (Next == DeltaList)  {

        // If we removed the last element in the list nothing to do either

        return FALSE ;

    } else {

        Temp = CONTAINING_RECORD ( Next, RTLP_GENERIC_TIMER, List) ;

        Temp->DeltaFiringTime += Timer->DeltaFiringTime ;

        // Check if element was removed from head of list

        if (DeltaList->Flink == Next) {

            *NewFiringTime = Temp->DeltaFiringTime + TimeRemaining ;

            Temp->DeltaFiringTime = 0 ;

            return TRUE ;

        } else {

            return FALSE ;

        }

    }

}

BOOLEAN
RtlpReOrderDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime,
    ULONG ChangedFiringTime
    )
/*++

Routine Description:

    Called when a timer in the delta list needs to be re-inserted because the firing time
    has changed.

Arguments:

    DeltaList - List in which to re-insert

    Timer - Timer for which the firing time has changed

    TimeRemaining - Time before the head of the delta list is fired

    NewFiringTime - If the new element was inserted at the head of the list - this
                    will contain the new firing time in milliseconds. The caller
                    can use this time to re-program the NT timer.

    ChangedFiringTime - Changed Time for the specified timer.

Return Value:

    TRUE if the timer was removed from head of timer list
    FALSE otherwise

--*/
{
    ULONG NewTimeRemaining ;
    PRTLP_GENERIC_TIMER Temp ;

    // Remove the timer from the list

    if (RtlpRemoveFromDeltaList (DeltaList, Timer, TimeRemaining, NewFiringTime)) {

        // If element was removed from the head of the list we should record that

        NewTimeRemaining = *NewFiringTime ;


    } else {

        // Element was not removed from head of delta list, the current TimeRemaining is valid

        NewTimeRemaining = TimeRemaining ;

    }

    // Before inserting Timer, set its delta time to the ChangedFiringTime

    Timer->DeltaFiringTime = ChangedFiringTime ;

    // Reinsert this element back in the list

    if (!RtlpInsertInDeltaList (DeltaList, Timer, NewTimeRemaining, NewFiringTime)) {

        // If we did not add at the head of the list, then we should return TRUE if
        // RtlpRemoveFromDeltaList() had returned TRUE. We also update the NewFiringTime to
        // the reflect the new firing time returned by RtlpRemoveFromDeltaList()

        *NewFiringTime = NewTimeRemaining ;

        return (NewTimeRemaining != TimeRemaining) ;

    } else {

        // NewFiringTime contains the time the NT timer must be programmed for

        return TRUE ;

    }

}

VOID
RtlpAddTimerQueue (
    PVOID Queue
    )
/*++

Routine Description:

    This routine runs as an APC into the Timer thread. It does whatever necessary to
    create a new timer queue

Arguments:

    Queue - Pointer to the queue to add

Return Value:


--*/
{

    // We do nothing here. The newly created queue is free floating until a timer is
    // queued onto it.

}

VOID
RtlpProcessTimeouts (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    )
/*++

Routine Description:

    This routine processes timeouts for the wait thread

Arguments:

    ThreadCB - The wait thread to add the wait to

Return Value:

--*/
{
    ULONG NewFiringTime, TimeRemaining ;
    LIST_ENTRY TimersToFireList ;
    
    //
    // check if incorrect timer fired
    //
    if (ThreadCB->Firing64BitTickCount >
            RtlpGet64BitTickCount(&ThreadCB->Current64BitTickCount) + 200 )
    {
        RtlpResetTimer (ThreadCB->TimerHandle,
                    RtlpGetTimeRemaining (ThreadCB->TimerHandle),
                    ThreadCB) ;

        return ;
    }

    InitializeListHead( &TimersToFireList ) ;


    // Walk thru the timer list and fire all waits with DeltaFiringTime == 0

    RtlpFireTimersAndReorder (&ThreadCB->TimerQueue, &NewFiringTime, &TimersToFireList) ;

    // Reset the NT timer

    RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;


    RtlpFireTimers( &TimersToFireList ) ;
}

NTSTATUS
RtlpTimerCleanup(
    VOID
    )
{
    BOOLEAN Cleanup;

    IS_COMPONENT_INITIALIZED(StartedTimerInitialization,
                            CompletedTimerInitialization,
                            Cleanup ) ;

    if ( Cleanup ) {

        ACQUIRE_GLOBAL_TIMER_LOCK() ;

        if (NumTimerQueues != 0 ) {

            RELEASE_GLOBAL_TIMER_LOCK() ;

            return STATUS_UNSUCCESSFUL ;
        }

        NtQueueApcThread(
                TimerThreadHandle,
                (PPS_APC_ROUTINE)RtlpThreadCleanup,
                NULL,
                NULL,
                NULL
                );

        NtClose( TimerThreadHandle ) ;
        TimerThreadHandle = NULL ;

        RELEASE_GLOBAL_TIMER_LOCK() ;

    }

    return STATUS_SUCCESS;
}

#if DBG
VOID
PrintTimerQueue(PLIST_ENTRY QNode, ULONG Delta, ULONG Count
    )
{
    PLIST_ENTRY Tnode ;
    PRTLP_TIMER Timer ;
    PRTLP_TIMER_QUEUE Queue ;

    Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_VERBOSE_MASK,
               "<%1d> Queue: %x FiringTime:%d\n", Count, (ULONG_PTR)Queue,
               Queue->DeltaFiringTime);
    for (Tnode=Queue->TimerList.Flink; Tnode!=&Queue->TimerList;
            Tnode=Tnode->Flink)
    {
        Timer = CONTAINING_RECORD (Tnode, RTLP_TIMER, List) ;
        Delta += Timer->DeltaFiringTime ;
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_VERBOSE_MASK,
                   "        Timer: %x Delta:%d Period:%d\n",(ULONG_PTR)Timer,
                   Delta, Timer->Period);
    }

}
#endif

VOID
RtlDebugPrintTimes (
    )
{
#if DBG
    PLIST_ENTRY QNode ;
    ULONG Count = 0 ;
    ULONG Delta = RtlpGetTimeRemaining (TimerHandle) ;
    ULONG CurrentThreadId =
                        HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    RtlpResync64BitTickCount();

    if (CompletedTimerInitialization != 1) {

        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "RtlTimerThread not yet initialized\n");
        return ;
    }

    if (CurrentThreadId == TimerThreadId)
    {
        PRTLP_TIMER_QUEUE Queue ;

        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_VERBOSE_MASK,
                   "================Printing timerqueues====================\n");
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_VERBOSE_MASK,
                   "TimeRemaining: %d\n", Delta);
        for (QNode = TimerQueues.Flink; QNode != &TimerQueues;
                QNode = QNode->Flink)
        {
            Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;
            Delta += Queue->DeltaFiringTime ;

            PrintTimerQueue(QNode, Delta, ++Count);

        }
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_VERBOSE_MASK,
                   "================Printed ================================\n");
    }

    else
    {
        NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlDebugPrintTimes,
                    NULL,
                    NULL,
                    NULL
                    );
    }
#endif
    return;
}

/*DO NOT USE THIS FUNCTION: REPLACED BY RTLCREATETIMER*/

NTSTATUS
RtlSetTimer(
    IN  HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  DueTime,
    IN  ULONG  Period,
    IN  ULONG  Flags
    )
{
#if DBG
    static ULONG Count = 0;
    if (Count++ ==0 ) {
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "Using obsolete function call: RtlSetTimer\n");
        DbgBreakPoint();
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "Using obsolete function call: RtlSetTimer\n");
    }
#endif

    return RtlCreateTimer(TimerQueueHandle,
                            Handle,
                            Function,
                            Context,
                            DueTime,
                            Period,
                            Flags
                            ) ;
}

/*DO NOT USE THIS FUNCTION: REPLACED BY RTLDeleteTimer*/

NTSTATUS
RtlCancelTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel
    )
/*++

Routine Description:

    This routine cancels the timer. This call is non-blocking. The timer Callback
    will not be executed after this call returns.

Arguments:

    TimerQueueHandle - Handle identifying the queue from which to delete timer

    TimerToCancel - Handle identifying the timer to cancel

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer cancelled. All callbacks completed.
        STATUS_PENDING - Timer cancelled. Some callbacks still not completed.

--*/
{
#if DBG
    static ULONG Count = 0;
    if (Count++ ==0) {
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "Using obsolete function call: RtlCancelTimer\n");
        DbgBreakPoint();
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_ERROR_MASK,
                   "Using obsolete function call: RtlCancelTimer\n");
    }
#endif
    
    return RtlDeleteTimer( TimerQueueHandle, TimerToCancel, NULL ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\tracedb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tracedb.c

Abstract:

    This module contains the implementation for the trace database 
    module (hash table to store stack trace in USer/Kernel mode).

Author:

    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#include "tracedbp.h"

//
// TRACE_ASSERT
//
// SilviuC: should change this to normal ASSERT() macro when code gets
// mature enough.
//

#if DBG
#define TRACE_ASSERT(Expr) {                                              \
    if (!(Expr)) {                                                        \
        DbgPrint ("Page heap: (%s, %d): \" %s \" -- assertion failed \n", \
          __FILE__, __LINE__, #Expr);                                     \
        DbgBreakPoint ();                                                 \
    }}
#else
#define TRACE_ASSERT(Expr)
#endif // #if DBG

//
// Magic values that prefix tracedb structures and allow
// early detection of corruptions.
//

#define RTL_TRACE_BLOCK_MAGIC       0xABCDAAAA
#define RTL_TRACE_SEGMENT_MAGIC     0xABCDBBBB
#define RTL_TRACE_DATABASE_MAGIC    0xABCDCCCC

//
// Amount of memory with each a trace database will be
// increased if a new trace cannot be stored.
//

#ifdef NTOS_KERNEL_RUNTIME
#define RTL_TRACE_SIZE_INCREMENT PAGE_SIZE
#else
#define RTL_TRACE_SIZE_INCREMENT 0x10000
#endif // #ifdef NTOS_KERNEL_RUNTIME

//
// Internal function declarations
//

BOOLEAN
RtlpTraceDatabaseInternalAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlpTraceDatabaseInternalFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

ULONG 
RtlpTraceStandardHashFunction (
    IN ULONG Count,
    IN PVOID * Trace
    );

PVOID 
RtlpTraceDatabaseAllocate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    );

BOOLEAN 
RtlpTraceDatabaseFree (
    PVOID Block,
    IN ULONG Tag    // OPTIONAL in User mode
    );

BOOLEAN 
RtlpTraceDatabaseInitializeLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseUninitializeLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseAcquireLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseReleaseLock (
    IN PRTL_TRACE_DATABASE Database
    );

PRTL_TRACE_SEGMENT
RtlpTraceSegmentCreate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    );

//
// Trace database implementation
//

PRTL_TRACE_DATABASE
RtlTraceDatabaseCreate (
    IN ULONG Buckets,
    IN SIZE_T MaximumSize OPTIONAL,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag,   // OPTIONAL in User mode
    IN RTL_TRACE_HASH_FUNCTION HashFunction OPTIONAL
    )
/*++

Routine Description:

    This routine creates a trace database, that is a hash table
    to store stack traces.

Arguments:

    Buckets - no of buckets of the hash table with simple chaining.
    
    MaximumSize - maximum amount of memory that the database can use.
        When limit is hit, database add operations will start to fail.
        If the value is zero then no limit will be imposed.
        
    Flags - flags to control if allocation in K mode is done in P or NP
        pool. The possible bits that can be used right now are:
        RTL_TRACE_USE_PAGED_POOL
        RTL_TRACE_USE_NONPAGED_POOL
        
    Tag - tag used for K mode allocations.
    
    HashFunction - hash function to be used. If null passed a standard hash 
        function will be provided by the module.    

Return Value:

    Pointer to an initialized trace database structure.

Environment:

    Any.

--*/
{
    PVOID RawArea;
    SIZE_T RawSize;
    PRTL_TRACE_DATABASE Database;
    PRTL_TRACE_SEGMENT Segment;
    ULONG FirstFlags;

    //
    // Prepare trace database flags. The first segment of
    // the database will be allocated in nonpaged pool
    // no matter what flags are used because it contains
    // kernel synchronization objects that need to be in
    // that pool. 
    //

#ifdef NTOS_KERNEL_RUNTIME
    Flags |= RTL_TRACE_IN_KERNEL_MODE;
    FirstFlags = RTL_TRACE_IN_KERNEL_MODE | RTL_TRACE_USE_NONPAGED_POOL;
#else
    Flags |= RTL_TRACE_IN_USER_MODE;
    FirstFlags = Flags;
#endif // #ifdef NTOS_KERNEL_RUNTIME

    //
    // Allocate first segment of trace database that will contain
    // DATABASE, SEGMENT, buckets of the hash table and later traces.
    //

    RawSize = sizeof (RTL_TRACE_DATABASE) +
        sizeof (RTL_TRACE_SEGMENT) +
        Buckets * sizeof (PRTL_TRACE_BLOCK);

    RawSize += RTL_TRACE_SIZE_INCREMENT;
    RawSize &= ~(RTL_TRACE_SIZE_INCREMENT - 1);

    RawArea = RtlpTraceDatabaseAllocate (
        RawSize, 
        FirstFlags,
        Tag);

    if (RawArea == NULL) {
        return NULL;
    }

    Database = (PRTL_TRACE_DATABASE)RawArea;
    Segment = (PRTL_TRACE_SEGMENT)(Database + 1);

    //
    // Initialize the database
    //

    Database->Magic = RTL_TRACE_DATABASE_MAGIC;
    Database->Flags = Flags;
    Database->Tag = Tag;
    Database->SegmentList = NULL;
    Database->MaximumSize = MaximumSize;
    Database->CurrentSize = RTL_TRACE_SIZE_INCREMENT;
    Database->Owner = NULL;

    Database->NoOfHits = 0;
    Database->NoOfTraces = 0;
    RtlZeroMemory (Database->HashCounter, sizeof (Database->HashCounter));

    if (! RtlpTraceDatabaseInitializeLock (Database)) {
        RtlpTraceDatabaseFree (RawArea, Tag);
        return NULL;
    }

    Database->NoOfBuckets = Buckets;      

    if (HashFunction == NULL) {
        Database->HashFunction = RtlpTraceStandardHashFunction;
    }
    else {
        Database->HashFunction = HashFunction;
    }

    //
    // Initialize first segment of the database
    //

    Segment->Magic = RTL_TRACE_SEGMENT_MAGIC;
    Segment->Database = Database;
    Segment->NextSegment = NULL;
    Segment->TotalSize = RTL_TRACE_SIZE_INCREMENT;

    Database->SegmentList = Segment;

    //
    // Initialize the buckets of the database.
    //

    Database->Buckets = (PRTL_TRACE_BLOCK *)(Segment + 1);
    RtlZeroMemory (Database->Buckets, Database->NoOfBuckets * sizeof(PRTL_TRACE_BLOCK));

    //
    // Initialize free pointer for segment
    //

    Segment->SegmentStart = (PCHAR)RawArea;
    Segment->SegmentEnd = Segment->SegmentStart + RTL_TRACE_SIZE_INCREMENT;
    Segment->SegmentFree = (PCHAR)(Segment + 1) + Database->NoOfBuckets * sizeof(PRTL_TRACE_BLOCK);

    return Database;
}

BOOLEAN
RtlTraceDatabaseDestroy (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine destroys a trace database. It takes care of
    deallocating everything, uninitializing synchronization 
    objects, etc.

Arguments:

    Database - trace database

Return Value:

    TRUE if destroy operation was successful. FALSE otherwise.

Environment:

    Any.

--*/
{
    PRTL_TRACE_SEGMENT Current;
    BOOLEAN Success;
    BOOLEAN SomethingFailed = FALSE;
    PRTL_TRACE_SEGMENT NextSegment;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);
    TRACE_ASSERT (RtlTraceDatabaseValidate (Database));

    //
    // Uninitialize the database lock. Even if we fail
    // we will continue to release memory for all segments.
    //
    // N.B. We cannot acquire the lock here for the last time because this
    // has as a side effect elevating the irql (in K mode) and then the 
    // function will return with raised irql.
    //

    Success = RtlpTraceDatabaseUninitializeLock (Database);

    if (! Success) {
        SomethingFailed = TRUE;
    }

    //
    // Traverse the list of segments and release memory one by one.
    // Special attention with the last segment because it contains
    // the database structure itself and we do not want to shoot.
    // ourselves in the foot.
    //

    for (Current = Database->SegmentList;
         Current != NULL;
         Current = NextSegment) {

        //
        // We save the next segment before freeing the structure.
        //

        NextSegment = Current->NextSegment;

        //
        // If this is the last segment we need to offset Current pointer
        // by the size of the database structure.
        //

        if (NextSegment == NULL) {
            
            Current = (PRTL_TRACE_SEGMENT) ((PRTL_TRACE_DATABASE)Current - 1);
        }

        Success = RtlpTraceDatabaseFree (Current, Database->Tag);

        if (! Success) {

            DbgPrint ("Trace database: failed to release segment %p \n", Current);
            SomethingFailed = TRUE;
        }
    }

    if (SomethingFailed) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOLEAN
RtlTraceDatabaseValidate (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine validates the correctness of a trace database.
    It is intended to be used for testing purposes.

Arguments:

    Database - trace database

Return Value:

    TRUE if the database is ok. For most of the inconsistencies this
    function will break in the debugger.

Environment:

    Any.

--*/
{
    PRTL_TRACE_SEGMENT Segment;
    PRTL_TRACE_BLOCK Block;
    ULONG Index;

    TRACE_ASSERT (Database != NULL);
    TRACE_ASSERT (Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    //
    // Check all segments.
    //

    for (Segment = Database->SegmentList;
         Segment != NULL;
         Segment = Segment->NextSegment) {

        TRACE_ASSERT (Segment->Magic == RTL_TRACE_SEGMENT_MAGIC);
    }

    //
    // Check all blocks.
    //
    
    for (Index = 0; Index < Database->NoOfBuckets; Index++) {

        for (Block = Database->Buckets[Index];
             Block != NULL;
             Block = Block->Next) {

            TRACE_ASSERT (Block->Magic == RTL_TRACE_BLOCK_MAGIC);
        }
    }

    RtlpTraceDatabaseReleaseLock (Database);
    return TRUE;
}

BOOLEAN
RtlTraceDatabaseAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This routine adds a new stack trace to the database. If the trace
    already exists then only the `Count' field for the trace will be
    incremented.

Arguments:

    Database - trace database
    
    Count - number of pointers (PVOIDs) in the trace
    
    Trace - array of PVOIDs (the trace)
    
    TraceBlock - if not null will contain the address of the block where
        the trace was stored.

Return Value:

    TRUE if a trace was added to the database. TraceBlock will contain
    the address of the block. If the trace was already present in the
    database a block with `Count' greater than 1 will be returned.

Environment:

    Any.

--*/
{
    BOOLEAN Result;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    Result = RtlpTraceDatabaseInternalAdd (
        Database,
        Count,
        Trace,
        TraceBlock);

    RtlpTraceDatabaseReleaseLock (Database);

    return Result;
}

BOOLEAN
RtlTraceDatabaseFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This routine searches a trace in the database. If the trace
    is found then the address of the block that stores the trace
    will be returned.

Arguments:

    Database - trace database
    
    Count - number of pointers (PVOIDs) in the trace
    
    Trace - array of PVOIDs (the trace)
    
    TraceBlock - if not null will contain the address of the block where
        the trace is stored.

Return Value:

    TRUE if the trace was found in the database. TraceBlock will contain
    the address of the block that stores the trace.

Environment:

    Any.

--*/
{
    BOOLEAN Result;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    Result = RtlpTraceDatabaseInternalFind (
        Database,
        Count,
        Trace,
        TraceBlock);

    if (Result) {
        Database->NoOfHits += 1;
    }

    RtlpTraceDatabaseReleaseLock (Database);

    return Result;
}

BOOLEAN
RtlpTraceDatabaseInternalAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This is the internal routine to add a trace. See RtlTraceDatabaseAdd
    for more details.

Arguments:

    Database - trace database
    
    Count - size of trace (in PVOIDs)
    
    Trace - trace
    
    TraceBlock - address of block where the trace is stored

Return Value:

    TRUE if trace was added.

Environment:

    Called from RtlTraceDatabaseAdd. Assumes the database lock
    is held.

--*/
{
    PRTL_TRACE_BLOCK Block;
    PRTL_TRACE_SEGMENT Segment;
    PRTL_TRACE_SEGMENT TopSegment;
    ULONG HashValue;
    SIZE_T RequestSize;

    //
    // Check if the block is already in the database (hash table).
    // If it is increase the number of hits and return.
    //

    if (RtlpTraceDatabaseInternalFind (Database, Count, Trace, &Block)) {

        Block->Count += 1;

        if (TraceBlock) {
            *TraceBlock = Block;
        }

        Database->NoOfHits += 1;
        return TRUE;
    }

    //
    //  We need to create a new block. First we need to figure out
    // if the current segment can accomodate the new block.
    // 

    RequestSize = sizeof(*Block) + Count * sizeof(PVOID);

    TopSegment = Database->SegmentList;
    if (RequestSize > (SIZE_T)(TopSegment->SegmentEnd - TopSegment->SegmentFree)) {

        //
        // If the database has a maximum size and that limit
        // has been reached then fail the call.
        //

        if (Database->MaximumSize > 0) {
            if (Database->CurrentSize > Database->MaximumSize) {
                
                if (TraceBlock) {
                    *TraceBlock = NULL;
                }

                return FALSE;
            }
        }

        //
        // Allocate a new database segment. Fail call if cannot
        // allocate.
        //

        Segment = RtlpTraceSegmentCreate (RTL_TRACE_SIZE_INCREMENT, 
                                          Database->Flags,
                                          Database->Tag);

        if (Segment == NULL) {
            
            if (TraceBlock) {
                *TraceBlock = NULL;
            }
            
            return FALSE;
        }

        //
        // Add the new segment to the database.
        //

        Segment->Magic = RTL_TRACE_SEGMENT_MAGIC;
        Segment->Database = Database;
        Segment->TotalSize = RTL_TRACE_SIZE_INCREMENT;
        Segment->SegmentStart = (PCHAR)Segment;
        Segment->SegmentEnd = Segment->SegmentStart + RTL_TRACE_SIZE_INCREMENT;
        Segment->SegmentFree = (PCHAR)(Segment + 1);

        Segment->NextSegment = Database->SegmentList;
        Database->SegmentList = Segment;
        TopSegment = Database->SegmentList;

        Database->CurrentSize += RTL_TRACE_SIZE_INCREMENT;
    }

    if (RequestSize > (SIZE_T)(TopSegment->SegmentEnd - TopSegment->SegmentFree)) {

        DbgPrint ("Trace database: failing attempt to save biiiiig trace (size %u) \n", 
                  Count);
        
        if (TraceBlock) {
            *TraceBlock = NULL;
        }

        return FALSE;
    }

    //
    // Finaly we can allocate our block.
    //

    Block = (PRTL_TRACE_BLOCK)(TopSegment->SegmentFree);
    TopSegment->SegmentFree += RequestSize;

    //
    // Fill the block with the new trace.
    //

    Block->Magic = RTL_TRACE_BLOCK_MAGIC;
    Block->Size = Count;
    Block->Count = 1;
    Block->Trace = (PVOID *)(Block + 1);

    Block->UserCount = 0;
    Block->UserSize = 0;

    //
    // Copy the trace
    //

    RtlMoveMemory (Block->Trace, Trace, Count * sizeof(PVOID));

    //
    // Add the block to corresponding bucket.
    //

    HashValue = (Database->HashFunction) (Count, Trace);
    HashValue %= Database->NoOfBuckets;
    Database->HashCounter[HashValue / (Database->NoOfBuckets / 16)] += 1;

    Block->Next = Database->Buckets[HashValue];
    Database->Buckets[HashValue] = Block;

    //
    // Loooong function. Finally return succes.
    //

    if (TraceBlock) {
        *TraceBlock = Block;
    }

    Database->NoOfTraces += 1;
    return TRUE;
}

BOOLEAN
RtlpTraceDatabaseInternalFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This internal routine searches for a trace in the database.

Arguments:

    Database - trace database
    
    Count - size of trace (in PVOIDs)
    
    Trace - trace
    
    TraceBlock - element where the trace is stored.

Return Value:

    TRUE if the trace was found.

Environment:

    Called from RtlTraceDatabaseFind. Assumes the database lock is held.

--*/
{
    ULONG HashValue;
    PRTL_TRACE_BLOCK Current;
    ULONG Index;
    ULONG RequestSize;

    //
    // Find the bucket to search into.
    //

    HashValue = (Database->HashFunction) (Count, Trace);
    Database->HashCounter[HashValue % 16] += 1;
    HashValue %= Database->NoOfBuckets;

    //
    // Traverse the list of blocks for the found bucket
    //

    for (Current = Database->Buckets[HashValue];
         Current != NULL;
         Current = Current->Next) {

        //
        // If the size of the trace matches we might have a chance
        // to find an equal trace.
        //

        if (Count == Current->Size) {

            //
            // Figure out if the whole trace matches.
            //

            for (Index = 0; Index < Count; Index++) {
                if (Current->Trace[Index] != Trace[Index]) {
                    break;
                }
            }

            //
            // If the trace matched completely we have found an entry.
            //

            if (Index == Count) {
                if (TraceBlock) {
                    *TraceBlock = Current;
                }

                return TRUE;
            }
        }
    }

    //
    // If we traversed the whole list for the hashed bucket and did not
    // find anything we will fail the call.
    //

    if (TraceBlock) {
        *TraceBlock = NULL;
    }
    
    return FALSE;
}

ULONG 
RtlpTraceStandardHashFunction (
    IN ULONG Count,
    IN PVOID * Trace
    )
/*++

Routine Description:

    This routine is a simple hash function for stack traces in
    the case the caller of RtlTraceDatabaseCreate does not provide
    one. The function just xor's together all the pointers in the
    trace.

Arguments:

    Count - size of trace (in PVOIDs)
    
    Trace - trace

Return Value:

    Hash value. This needs to be reduced to the number of buckets
    in the hash table by a modulo operation (or something similar).

Environment:

    Called internally by RtlpTraceDatabaseInternalAdd/Find.

--*/
{
    ULONG_PTR Value = 0;
    ULONG Index;
    unsigned short * Key; 

    Key = (unsigned short *)Trace;
    for (Index = 0; Index < Count * (sizeof (PVOID) / sizeof(*Key)); Index += 2) {

        Value += Key[Index] ^ Key[Index + 1];
    }

    return PtrToUlong ((PVOID)Value);
}

PVOID 
RtlpTraceDatabaseAllocate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine allocates memory and hides all the different
    details for User vs Kernel mode allocation and paged vs
    nonpaged pool.

Arguments:

    Size -  size in bytes
    
    Flags - flags (specify U/K mode and P/NP pool)
    
    Tag - tag used for K mode allocations

Return Value:

    Pointer to memory area allocated or null.

Environment:

    Internal function for trace database module.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    //
    // SilviuC: should take a look if I can allocate with low
    // priority here (allocate with priority in pool).
    //

    if ((Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        return ExAllocatePoolWithTag (NonPagedPool, Size, Tag);
    }
    else {
        return ExAllocatePoolWithTag (PagedPool, Size, Tag);
    }

#else

    NTSTATUS Status;
    PVOID RequestAddress;
    SIZE_T RequestSize;

    RequestAddress = NULL;
    RequestSize = Size;

    Status = NtAllocateVirtualMemory (
        NtCurrentProcess (),
        &RequestAddress,
        0,
        &RequestSize,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);

    if (NT_SUCCESS(Status)) {
        return RequestAddress;
    }
    else {
        return NULL;
    }

#endif // #ifdef NTOS_KERNEL_RUNTIME
}

BOOLEAN 
RtlpTraceDatabaseFree (
    PVOID Block,
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine frees memory and hides all the different
    details for User vs Kernel mode allocation and paged vs
    nonpaged pool.

Arguments:

    Block - memory area to free
    
    Tag - tag used for K mode allocation

Return Value:

    TRUE if deallocation was successful.

Environment:

    Internal function for trace database module.
    
--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    ExFreePoolWithTag (Block, Tag);
    return TRUE;

#else

    NTSTATUS Status;
    PVOID Address;
    SIZE_T Size;

    Address = Block;
    Size = 0;

    Status = NtFreeVirtualMemory (
        NtCurrentProcess (),
        &Address,
        &Size,
        MEM_RELEASE);

    if (NT_SUCCESS(Status)) {
        return TRUE;
    }
    else {
        return FALSE;
    }

#endif // #ifdef NTOS_KERNEL_RUNTIME
}

BOOLEAN 
RtlpTraceDatabaseInitializeLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine initializes the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeInitializeSpinLock (&(Database->u.SpinLock));
    }
    else {
        ExInitializeFastMutex (&(Database->u.FastMutex));
    }

    return TRUE;

#else

    ASSERT((Database->Flags & RTL_TRACE_IN_USER_MODE));

    RtlInitializeCriticalSection (&(Database->Lock));

    return TRUE;

#endif // #ifdef NTOS_KERNEL_RUNTIME
}


BOOLEAN 
RtlpTraceDatabaseUninitializeLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine uninitializes the trace database lock.
    It hides all details about the actual nature of the lock.
    (e.g. In user mode we need to call RtlDeleteCriticalSection).

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {

        //
        // No "uninitialize" required for spinlocks.
        //
    }
    else {
        
        //
        // No "uninitialize" required for fast mutexes.
        //
    }

    return TRUE;

#else

    ASSERT((Database->Flags & RTL_TRACE_IN_USER_MODE));

    RtlDeleteCriticalSection (&(Database->Lock));

    return TRUE;

#endif // #ifdef NTOS_KERNEL_RUNTIME
}


VOID 
RtlTraceDatabaseLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine acquires the trace database lock.
    It hides all details about the actual nature of the lock.
    
    The callers needs to acquire the database lock only if 
    a trace block will be modified (UserCount, UserSize fields).
    The lock is not needed for Add/Find/Enumerate operations.

Arguments:

    Database - trace database

Return Value:

    None.

Environment:

    Called if a trace block will be modified.

--*/
{
    RtlpTraceDatabaseAcquireLock(Database);
}


VOID 
RtlTraceDatabaseUnlock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine releases the trace database lock.
    It hides all details about the actual nature of the lock.
    
    The callers needs to acquire/release the database lock only if 
    a trace block will be modified (UserCount, UserSize fields).
    The lock is not needed for Add/Find/Enumerate operations.

Arguments:

    Database - trace database

Return Value:

    None.

Environment:

    Called if a trace block will be modified.

--*/
{
    RtlpTraceDatabaseReleaseLock(Database);
}


BOOLEAN 
RtlpTraceDatabaseAcquireLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine acquires the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeAcquireSpinLock (&(Database->u.SpinLock), &(Database->SavedIrql));
    }
    else {
        ExAcquireFastMutex (&(Database->u.FastMutex));
    }

    Database->Owner = KeGetCurrentThread();
    return TRUE;

#else

    ASSERT((Database->Flags & RTL_TRACE_IN_USER_MODE));

    RtlEnterCriticalSection (&(Database->Lock));
    
    //
    // SilviuC: it might be useful to get thread address here
    // although not really important.
    //

    Database->Owner = NULL; 
    return TRUE;

#endif // #ifdef NTOS_KERNEL_RUNTIME
}

BOOLEAN 
RtlpTraceDatabaseReleaseLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine releases the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
#ifdef NTOS_KERNEL_RUNTIME
                                                     
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));
    Database->Owner = NULL;

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeReleaseSpinLock (&(Database->u.SpinLock), Database->SavedIrql);
    }
    else {
        ExReleaseFastMutex (&(Database->u.FastMutex));
    }

    return TRUE;

#else

    ASSERT((Database->Flags & RTL_TRACE_IN_USER_MODE));
    Database->Owner = NULL;

    RtlLeaveCriticalSection (&(Database->Lock));
    return TRUE;

#endif // #ifdef NTOS_KERNEL_RUNTIME
}

PRTL_TRACE_SEGMENT
RtlpTraceSegmentCreate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine creates a new segment. The segment is the device
    through which a database can increase in size to accomodata
    more traces.

Arguments:

    Size - size in bytes
    
    Flags - allocation flags (U/K mode, P/NP pool)
    
    Tag - tag for K mode allocations

Return Value:

    New allocated segment or null.

Environment:

    Internal trace database module function.

--*/
{
    PRTL_TRACE_SEGMENT Segment;

    Segment = RtlpTraceDatabaseAllocate (Size, Flags, Tag);
    return Segment;
}


BOOLEAN
RtlTraceDatabaseEnumerate (
    PRTL_TRACE_DATABASE Database,
    OUT PRTL_TRACE_ENUMERATE Enumerate,
    OUT PRTL_TRACE_BLOCK * TraceBlock
    )
/*++

Routine Description:

    This function enumerates all traces in the database. It requires a
    RTL_TRACE_ENUMERATE function (zeroed initially) to keep the state of
    the enumeration. Since the trace database does not support delete
    operations we do not need to keep a lock across multiple calls to
    Enumerate(). However this can change if we add support for deletions.

Arguments:

    Database - trace database pointer
    
    Enumerate - enumeration opaque structure. Used to keep the state of 
        the enumeration.
        
    TraceBlock - on each succesful return this pointer gets filled with
        the address of a trace block from the database.        

Return Value:

    TRUE if a trace block was found (during enumeration) and FALSE if there
    are no more blocks in the database.

Environment:

    User/Kernel mode.

--*/

{
    BOOLEAN Result;
    
    TRACE_ASSERT (Database != NULL);
    TRACE_ASSERT (Database->Magic == RTL_TRACE_DATABASE_MAGIC);
    
    //
    // (SilviuC): If we ever add support for deleting stack traces
    // then it will not be enough to acquire the lock inside the
    // call to Enumerate(). We will need to keep the lock across
    // calls.
    //

    RtlpTraceDatabaseAcquireLock (Database);
    
    //
    // Start the search process if this is the first call.
    // If this is not the first call try to validate what
    // we have inside the enumerator.
    //

    if (Enumerate->Database == NULL) {

        Enumerate->Database = Database;
        Enumerate->Index = 0;
        Enumerate->Block = Database->Buckets[0];
    }
    else {

        if (Enumerate->Database != Database) {
            Result = FALSE;
            goto Exit;
        }

        if (Enumerate->Index >= Database->NoOfBuckets) {
            Result = FALSE;
            goto Exit;
        }
    }

    //
    // Find out the next trace block in case we are at the end
    // of a bucket or the bucket was empty.
    //

    while (Enumerate->Block == NULL) {
        
        Enumerate->Index += 1;
        
        if (Enumerate->Index >= Database->NoOfBuckets) {
            break;
        }
        
        Enumerate->Block = Database->Buckets[Enumerate->Index];
    }
    
    //
    // Figure out if we have finished the enumeration.
    //

    if (Enumerate->Index >= Database->NoOfBuckets && Enumerate->Block == NULL) {

        *TraceBlock = NULL;
        Result = FALSE;
        goto Exit;
    }

    //
    // Fill out the next trace block and advance the enumerator.
    //

    *TraceBlock = Enumerate->Block;
    Enumerate->Block = Enumerate->Block->Next;
    Result = TRUE;

    //
    // Clean up and exit
    //

    Exit:

    RtlpTraceDatabaseReleaseLock (Database);
    return Result;
}

//
// End of module: tracedb.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\triangle.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Triangle.c

Abstract:

    This module implements the general splay utilities for a two link
    triangular splay structure.

Author:

    Gary Kimura     [GaryKi]    28-May-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include <nt.h>
#include "triangle.h"


//
//  There are three type of swap macros.  The first two (are really the same)
//  are used to swap pointer and ulongs.  The last macro is used to swap refs
//  but it does not swap the ref type flags.
//

#define SwapPointers(Ptr1, Ptr2) {      \
    PVOID _SWAP_POINTER_TEMP;           \
    _SWAP_POINTER_TEMP = (PVOID)(Ptr1); \
    (Ptr1) = (Ptr2);                    \
    (Ptr2) = _SWAP_POINTER_TEMP;        \
    }

#define SwapUlongs(Ptr1, Ptr2) {        \
    ULONG _SWAP_POINTER_TEMP;           \
    _SWAP_POINTER_TEMP = (ULONG)(Ptr1); \
    (Ptr1) = (Ptr2);                    \
    (Ptr2) = _SWAP_POINTER_TEMP;        \
    }

#define SwapRefsButKeepFlags(Ref1, Ref2) {                            \
    ULONG _SWAP_ULONG_TEMP;                                           \
    _SWAP_ULONG_TEMP = (ULONG)(Ref1);                                 \
    (Ref1) = ((Ref2)           & 0xfffffffc) | ((Ref1) & 0x00000003); \
    (Ref2) = (_SWAP_ULONG_TEMP & 0xfffffffc) | ((Ref2) & 0x00000003); \
    }

//
//  The macro SetRefViaPointer takes a pointer to a ref and checks to see if
//  it is a valid pointer.  If it is a valid pointer it copies in the ref
//  a ulong, but does not overwrite the ref flags already in the ref.
//

#define SetRefViaPointer(Ref, Ulong) { \
    if (Ref != NULL) { \
        (*(Ref)) = (((ULONG)(Ulong)) & 0xfffffffc) | ((ULONG)(*(Ref)) & 0x00000003); \
    } \
}


//
//  The following five procedures are local to triangle.c and are used to
//  help manipluate the splay links.  The first two procedures take a pointer
//  to a splay link and returns the address of the ref that points back to the
//  input link, via either the parent or child.  They return NULL if there is
//  not a back pointer.  The result of these two procedures is often used in
//  the code with the SetRefViaPointer macro.  The third procedure is used
//  to swap the position to two splay links in the tree (i.e., the links swap
//  position, but everyone else stays stationary).  This is a general procedure
//  that can will swap any two nodes, irregardless of their relative positions
//  in the tree.  The last two procedures do a single rotation about a
//  tree node.  They either rotate left or rotate right and assume that the
//  appropriate child exists (i.e., for rotate left a right child exists and
//  for rotate right a left child exists).
//

PULONG
TriAddressOfBackRefViaParent (
    IN PTRI_SPLAY_LINKS Links
    );

PULONG
TriAddressOfBackRefViaChild (
    IN PTRI_SPLAY_LINKS Links
    );

VOID
TriSwapSplayLinks (
    IN PTRI_SPLAY_LINKS Link1,
    IN PTRI_SPLAY_LINKS Link2
    );

VOID
TriRotateRight (
   IN PTRI_SPLAY_LINKS Links
   );

VOID
TriRotateLeft (
    IN PTRI_SPLAY_LINKS Links
    );

PTRI_SPLAY_LINKS
TriSplay (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This Splay function takes as input a pointer to a splay link in a tree
    and splays the tree.  Its function return value is a pointer to the
    root of the splayed tree.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the root of the splayed tree

--*/

{
    PTRI_SPLAY_LINKS Parent;
    PTRI_SPLAY_LINKS GrandParent;

    //
    //  While Links is not the root we test and rotate until it is the root.
    //

    while (!TriIsRoot(Links)) {

        //
        //  Get Parent and then check if we don't have a grandparent.
        //

        Parent = TriParent(Links);

        if (TriIsRoot(Parent)) {

            //
            //  No grandparent so check for single rotation
            //

            if (TriIsLeftChild(Links)) {

                //
                //  do the following single rotation
                //
                //          Parent           Links
                //           /        ==>        \
                //      Links                     Parent
                //

                TriRotateRight(Parent);

            } else { // TriIsRightChild(Links)

                //
                //  do the following single rotation
                //
                //
                //      Parent                    Links
                //          \        ==>          /
                //           Links          Parent
                //

                TriRotateLeft(Parent);

            }

        } else { // !TriIsRoot(Parent)

            //
            //  Get grandparent and check for the four double rotation
            //  cases
            //

            GrandParent = TriParent(Parent);

            if (TriIsLeftChild(Links)) {

                if (TriIsLeftChild(Parent)) {

                    //
                    //  do the following double rotation
                    //
                    //          GP         L
                    //         /            \
                    //        P      ==>     P
                    //       /                \
                    //      L                  GP
                    //

                    TriRotateRight(GrandParent);
                    TriRotateRight(Parent);

                } else { // TriIsRightChild(Parent)

                    //
                    //  do the following double rotation
                    //
                    //      GP                L
                    //        \              / \
                    //         P    ==>    GP   P
                    //        /
                    //       L
                    //

                    TriRotateRight(Parent);
                    TriRotateLeft(GrandParent);

                }

            } else { // TriIsRightChild(Links);

                if (TriIsLeftChild(Parent)) {

                    //
                    //  do the following double rotation
                    //
                    //        GP             L
                    //       /              / \
                    //      P       ==>    P   GP
                    //       \
                    //        L
                    //

                    TriRotateLeft(Parent);
                    TriRotateRight(GrandParent);

                } else { // TriIsRightChild(Parent)

                    //
                    //  do the following double rotation
                    //
                    //      GP                   L
                    //        \                 /
                    //         P      ==>      P
                    //          \             /
                    //           L          GP
                    //

                    TriRotateLeft(GrandParent);
                    TriRotateLeft(Parent);

                }

            }

        }

    }

    return Links;

}


PTRI_SPLAY_LINKS
TriDelete (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This Delete function takes as input a pointer to a splay link in a tree
    and deletes that node from the tree.  Its function return value is a
    pointer to the root the tree.  If the tree is now empty, the return
    value is NULL.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the root of the splayed tree

--*/

{
    PTRI_SPLAY_LINKS Predecessor;
    PTRI_SPLAY_LINKS Parent;
    PTRI_SPLAY_LINKS Child;

    PULONG ParentChildRef;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((TriLeftChild(Links) != NULL) && (TriRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = TriSubtreePredecessor(Links);
        TriSwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise set the appropriate parent's child
    //  pointer, and possibly sibling, and splay the parent.
    //

    if ((TriLeftChild(Links) == NULL) && (TriRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then return NULL
        //

        if (TriIsRoot(Links)) {

            return NULL;

        }

        //
        //  Links has no children, check to see if links is an only child
        //

        Parent = TriParent(Links);
        if (MakeIntoPointer(Parent->Refs.Child) == Links &&
            MakeIntoPointer(Links->Refs.ParSib) == Parent) {

            //
            //  Links has no children and is an only child.  So simply make
            //  our parent have no children and splay our parent.
            //
            //          Parent              Parent
            //            |         ==>
            //          Links
            //

            Parent->Refs.Child = 0;
            return TriSplay(Parent);

        } else if (TriIsLeftChild(Links)) {

            //
            //  Links has no children and has a right sibling.  So make the
            //  parent's child Ref be the right sibling, splay the parent.
            //
            //             Parent                 Parent
            //              /  \           ==>        \
            //          Links  Sibling                Sibling
            //

            Parent->Refs.Child = MakeIntoRightChildRef(Links->Refs.ParSib);
            return TriSplay(Parent);

        } else { // TriIsRightChild(Links)

            //
            //  Links has no children and has a left sibling.  So make link's
            //  back via its parent into a parent ref of link's parent, and
            //  splay the parent.
            //
            //             Parent                    Parent
            //              /  \                     /
            //        Sibling  Links    ==>    Sibling
            //

            ParentChildRef = TriAddressOfBackRefViaParent(Links);
            *ParentChildRef = MakeIntoParentRef(Parent);
            return TriSplay(Parent);

        }

    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent, and splay
    //  the parent.  But first remember who our child is.
    //

    if (TriLeftChild(Links) != NULL) {
        Child = TriLeftChild(Links);
    } else {
        Child = TriRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (TriIsRoot(Links)) {
        Child->Refs.ParSib = MakeIntoParentRef(Child);
        return Child;
    }

    //
    //  Links is not the root, so set links's back ref via its parent to be
    //  links's child and the set the child's ParSib to be link's ParSib, and
    //  splay the parent.  This will handle the case where link is an only
    //  or has a sibling on either side.
    //

    Parent = TriParent(Links);
    ParentChildRef = TriAddressOfBackRefViaParent(Links);
    SetRefViaPointer(ParentChildRef, Child);
    Child->Refs.ParSib = Links->Refs.ParSib;

    return TriSplay(Parent);

}


PTRI_SPLAY_LINKS
TriSubtreeSuccessor (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This SubTreeSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node of
    the subtree rooted at the input node.  If there is not a successor, the
    return value is NULL.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the successor in the subtree

--*/

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a right subtree to the input link
    //  if there is then the subtree successor is the left most node in
    //  the right subtree.  That is find and return P in the following diagram
    //
    //              Links
    //                 \
    //                  .
    //                 .
    //                .
    //               /
    //              P
    //               \
    //

    if ((Ptr = TriRightChild(Links)) != NULL) {

        while (TriLeftChild(Ptr) != NULL) {
            Ptr = TriLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  Otherwise we do not have a subtree successor so we simply return NULL
    //

    return NULL;

}


PTRI_SPLAY_LINKS
TriSubtreePredecessor (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This SubTreePredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node of
    the subtree rooted at the input node.  If there is not a predecessor,
    the return value is NULL.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the predecessor in the subtree

--*/

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a left subtree to the input link
    //  if there is then the subtree predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = TriLeftChild(Links)) != NULL) {

        while (TriRightChild(Ptr) != NULL) {
            Ptr = TriRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  Otherwise we do not have a subtree predecessor so we simply return NULL
    //

    return NULL;

}


PTRI_SPLAY_LINKS
TriRealSuccessor (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This RealSuccess function takes as input a pointer to a splay link in a
    tree and returns a pointer to the successor of the input node within the
    entire tire.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the successor in the entire tree

--*/

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  first check to see if there is a right subtree to the input link
    //  if there is then the real successor is the left most node in
    //  the right subtree.  That is find and return P in the following diagram
    //
    //              Links
    //                 \
    //                  .
    //                 .
    //                .
    //               /
    //              P
    //               \
    //

    if ((Ptr = TriRightChild(Links)) != NULL) {

        while (TriLeftChild(Ptr) != NULL) {
            Ptr = TriLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  we do not have a right child so check to see if have a parent and if
    //  so find the first ancestor that we are a left decendent of. That
    //  is find and return P in the following diagram
    //
    //                   P
    //                  /
    //                 .
    //                  .
    //                   .
    //                  Links
    //

    Ptr = Links;
    while (!TriIsLeftChild(Ptr) && !TriIsRoot(Ptr)) {  // (TriIsRightChild(Ptr)) {
        Ptr = TriParent(Ptr);
    }

    if (TriIsLeftChild(Ptr)) {
        return TriParent(Ptr);
    }

    //
    //  Otherwise we do not have a real successor so we simply return NULL
    //

    return NULL;

}


PTRI_SPLAY_LINKS
TriRealPredecessor (
    IN PTRI_SPLAY_LINKS Links
    )

/*++

Routine Description:

    This RealPredecessor function takes as input a pointer to a splay link in
    a tree and returns a pointer to the predecessor of the input node within
    the entire tree.  If there is not a predecessor, the return value is NULL.

Arguments:

    Links - Supplies the pointer to a splay link in a tree

Return Values:

    PRTI_SPLAY_LINKS - Returns a pointer to the predecessor in the entire tree

--*/

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  first check to see if there is a left subtree to the input link
    //  if there is then the real predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = TriLeftChild(Links)) != NULL) {

        while (TriRightChild(Ptr) != NULL) {
            Ptr = TriRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  we do not have a left child so check to see if have a parent and if
    //  so find the first ancestor that we are a right decendent of. That
    //  is find and return P in the following diagram
    //
    //                   P
    //                    \
    //                     .
    //                    .
    //                   .
    //                Links
    //

    Ptr = Links;
    while (TriIsLeftChild(Ptr)) {
        Ptr = TriParent(Ptr);
    }

    if (!TriIsLeftChild(Ptr) && !TriIsRoot(Ptr)) { // (TriIsRightChild(Ptr)) {
        return TriParent(Ptr);
    }

    //
    //  Otherwise we do not have a real predecessor so we simply return NULL
    //

    return NULL;

}


PULONG
TriAddressOfBackRefViaParent (
    IN PTRI_SPLAY_LINKS Links
    )

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  If Links is the root then we do not have a back pointer via our parent
    //  so return NULL
    //

    if (TriIsRoot(Links)) {

        return NULL;

    }

    //
    //  We are not the root so find our parent and if our parent directly points
    //  to us we return the address of our parent's reference to us.  Otherwise
    //  (we must be a right child with a sibling) so return the address of
    //  our sibling's ParSib reference to us.
    //

    Ptr = TriParent(Links);
    if (MakeIntoPointer(Ptr->Refs.Child) == Links) {
        return &(Ptr->Refs.Child);
    } else {
        return &(MakeIntoPointer(Ptr->Refs.Child)->Refs.ParSib);
    }

}


PULONG
TriAddressOfBackRefViaChild (
    IN PTRI_SPLAY_LINKS Links
    )

{
    PTRI_SPLAY_LINKS Ptr;

    //
    //  Make Ptr be the same reference as found in our child field.
    //

    Ptr = MakeIntoPointer(Links->Refs.Child);

    //
    //  If our child pointer is null then we don't have a back pointer
    //  via our child so return NULL.
    //

    if (Ptr == NULL) {
        return NULL;

    //
    //  if our child directly reference's us (then we only have one child)
    //  return the address of the ParSib of our only child.
    //

    } else if (MakeIntoPointer(Ptr->Refs.ParSib) == Links) {
        return &(Ptr->Refs.ParSib);

    //
    //  otherwise we have two children so return the address of the ParSib
    //  of the second child.
    //

    } else {
        return &(MakeIntoPointer(Ptr->Refs.ParSib)->Refs.ParSib);

    }

}


VOID
TriSwapSplayLinks (
    IN PTRI_SPLAY_LINKS Link1,
    IN PTRI_SPLAY_LINKS Link2
    )

{
    PULONG Parent1ChildRef;
    PULONG Parent2ChildRef;

    PULONG Child1ParSibRef;
    PULONG Child2ParSibRef;

    //
    //  We have the following situation
    //
    //
    //         Parent1            Parent2
    //            |                  |
    //            |                  |
    //          Link1              Link2
    //           / \                / \
    //          /   \              /   \
    //        LC1   RC1          LC2   RC2
    //
    //  where one of the links can possibly be the root and one of the links
    //  can possibly be a direct child of the other, or can be connected
    //  via their sibling pointers.  Without loss of generality we'll make
    //  link2 be the possible and root and link1 be the possible child, or
    //  link2 have a parsib pointer to link1
    //

    if ((TriIsRoot(Link1)) ||
        (TriParent(Link2) == Link1) ||
        (MakeIntoPointer(Link1->Refs.ParSib) == Link2)) {

        SwapPointers(Link1, Link2);

    }

    //
    //  The cases we need to handle are
    //
    //  1. Link1 is not a child of link2, link2 is not the root, and they are not siblings
    //  2. Link1 is not a child of link2, link2 is not the root, and they are     siblings
    //
    //  3. Link1 is not a child of link2, link2 is     the root
    //
    //  4. Link1 is an only child of link2, and link2 is not the root
    //  5. Link1 is an only child of link2, and link2 is     the root
    //
    //  6. Link1 is a left child of link2 (has a sibling), and link2 is not the root
    //  7. Link1 is a left child of link2 (has a sibling), and link2 is     the root
    //
    //  8. Link1 is a right child of link2 (has a sibling), and link2 is not the root
    //  9. Link1 is a right child of link2 (has a sibling), and link2 is     the root
    //
    //  Each case will be handled separately
    //

    if (TriParent(Link1) != Link2) {

        if (!TriIsRoot(Link2)) {

            if (MakeIntoPointer(Link2->Refs.ParSib) != Link1) {

                //
                //  Case 1 - Link1 is not a child of link2,
                //           Link2 is not the root, and
                //           they are not siblings
                //

                Parent1ChildRef = TriAddressOfBackRefViaParent(Link1);
                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Parent2ChildRef = TriAddressOfBackRefViaParent(Link2);
                Child2ParSibRef = TriAddressOfBackRefViaChild(Link2);
                SwapUlongs(Link1->Refs.Child, Link2->Refs.Child);
                SwapUlongs(Link1->Refs.ParSib, Link2->Refs.ParSib);
                SetRefViaPointer(Parent1ChildRef, Link2);
                SetRefViaPointer(Parent2ChildRef, Link1);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Child2ParSibRef, Link1);

            } else {

                //
                //  Case 2 - Link1 is not a child of link2,
                //           Link2 is not the root, and
                //           they are siblings
                //

                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Parent2ChildRef = TriAddressOfBackRefViaParent(Link2);
                Child2ParSibRef = TriAddressOfBackRefViaChild(Link2);
                SwapUlongs(Link1->Refs.Child, Link2->Refs.Child);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Child2ParSibRef, Link1);
                *Parent2ChildRef = MakeIntoLeftChildRef(Link1);
                Link2->Refs.ParSib = Link1->Refs.ParSib;
                Link1->Refs.ParSib = MakeIntoSiblingRef(Link2);

            }

        } else {

            //
            //  Case 3 - Link1 is not a child of link2, and
            //           Link2 is the root
            //

            Parent1ChildRef = TriAddressOfBackRefViaParent(Link1);
            Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
            Child2ParSibRef = TriAddressOfBackRefViaChild(Link2);
            SwapUlongs(Link1->Refs.Child, Link2->Refs.Child);
            Link2->Refs.ParSib = Link1->Refs.ParSib;
            Link1->Refs.ParSib = MakeIntoParentRef(Link1);
            SetRefViaPointer(Child1ParSibRef, Link2);
            SetRefViaPointer(Child2ParSibRef, Link1);
            SetRefViaPointer(Parent1ChildRef, Link2);

        }

    } else { // TriParent(Link1) == Link2

        if (MakeIntoPointer(Link2->Refs.Child) == Link1 &&
            MakeIntoPointer(Link1->Refs.ParSib) == Link2) { // Link1 is an only child

            if (!TriIsRoot(Link2)) {

                //
                //  Case 4 - Link1 is an only child of link2, and
                //           Link2 is not the root
                //

                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Parent2ChildRef = TriAddressOfBackRefViaParent(Link2);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Parent2ChildRef, Link1);
                Link1->Refs.ParSib = Link2->Refs.ParSib;
                Link2->Refs.ParSib = MakeIntoParentRef(Link1);
                SwapRefsButKeepFlags(Link1->Refs.Child, Link2->Refs.Child);
                SetRefViaPointer(&Link1->Refs.Child, Link2);

            } else {

                //
                //  Case 5 - Link1 is an only child of link2, and
                //           Link2 is the root
                //

                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                SetRefViaPointer(Child1ParSibRef, Link2);
                Link1->Refs.ParSib = MakeIntoParentRef(Link1);
                Link2->Refs.ParSib = MakeIntoParentRef(Link1);
                SwapRefsButKeepFlags(Link1->Refs.Child, Link2->Refs.Child);
                SetRefViaPointer(&Link1->Refs.Child, Link2);

            }

        } else if (TriIsLeftChild(Link1)) {  // and link1 has a sibling

            if (!TriIsRoot(Link2)) {

                //
                //  Case 6 - Link1 is a left child of link2 (has a sibling), and
                //           Link2 is not the root
                //

                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Parent2ChildRef = TriAddressOfBackRefViaParent(Link2);
                Child2ParSibRef = TriAddressOfBackRefViaChild(Link2);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Parent2ChildRef, Link1);
                SetRefViaPointer(Child2ParSibRef, Link1);
                Link2->Refs.Child = Link1->Refs.Child;
                Link1->Refs.Child = MakeIntoLeftChildRef(Link2);
                SwapUlongs(Link1->Refs.ParSib, Link2->Refs.ParSib);

            } else {

                //
                //  Case 7 - Link1 is a left child of link2 (has a sibling), and
                //           Link2 is the root
                //

                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Child2ParSibRef = TriAddressOfBackRefViaChild(Link2);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Child2ParSibRef, Link1);
                Link2->Refs.Child = Link1->Refs.Child;
                Link1->Refs.Child = MakeIntoLeftChildRef(Link2);
                Link2->Refs.ParSib = Link1->Refs.ParSib;
                Link1->Refs.ParSib = MakeIntoParentRef(Link1);

            }

        } else { // TriIsRightChild(Link1) and Link1 has a sibling

            if (!TriIsRoot(Link2)) {

                //
                //  Case 8 - Link1 is a right child of link2 (has a sibling), and
                //           Link2 is not the root
                //

                Parent1ChildRef = TriAddressOfBackRefViaParent(Link1);
                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                Parent2ChildRef = TriAddressOfBackRefViaParent(Link2);
                SetRefViaPointer(Parent1ChildRef, Link2);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SetRefViaPointer(Parent2ChildRef, Link1);
                SwapUlongs(Link1->Refs.Child, Link2->Refs.Child);
                Link1->Refs.ParSib = Link2->Refs.ParSib;
                Link2->Refs.ParSib = MakeIntoParentRef(Link1);

            } else {

                //
                //  Case 9 - Link1 is a right child of link2 (has a sibling), and
                //           Link2 is the root
                //

                Parent1ChildRef = TriAddressOfBackRefViaParent(Link1);
                Child1ParSibRef = TriAddressOfBackRefViaChild(Link1);
                SetRefViaPointer(Parent1ChildRef, Link2);
                SetRefViaPointer(Child1ParSibRef, Link2);
                SwapUlongs(Link1->Refs.Child, Link2->Refs.Child);
                Link1->Refs.ParSib = MakeIntoParentRef(Link1);
                Link1->Refs.ParSib = MakeIntoParentRef(Link1);

            }

        }

    }

}


VOID
TriRotateRight (
    IN PTRI_SPLAY_LINKS Links
    )

{
    BOOLEAN IsRoot;
    PULONG ParentChildRef;
    ULONG SavedParSibRef;
    PTRI_SPLAY_LINKS LeftChild;
    PTRI_SPLAY_LINKS a,b,c;

    //
    //  We perform the following rotation
    //
    //               -Links-       -LeftChild-
    //                 / \           /     \
    //        LeftChild   c   ==>   a       Links
    //         /     \                       / \
    //        a       b                     b   c
    //
    //  where Links is a possible root and a,b, and c are all optional.
    //  We will consider each combination of optional children individually
    //  and handle the case of the root when we set T's parsib pointer and
    //  the backpointer to T.
    //

    //
    //  First remember if we are the root and if not also remember our
    //  back ref via our parent.
    //

    if (TriIsRoot(Links)) {
        IsRoot = TRUE;
    } else {
        IsRoot = FALSE;
        ParentChildRef = TriAddressOfBackRefViaParent(Links);
        SavedParSibRef = Links->Refs.ParSib;
    }

    //
    //  Now we set LeftChild, a, b, and c, and then later check for the
    //  different combinations.  In the diagrams only those links that
    //  need to change are shown in the after part.
    //

    LeftChild = TriLeftChild(Links);
    a = TriLeftChild(LeftChild);
    b = TriRightChild(LeftChild);
    c = TriRightChild(Links);

    if        ((a != NULL) && (b != NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               / \     ==>            \
        //      LeftChild   c            a ----- Links
        //       /     \                          /
        //      a       b                        b - c
        //

        a->Refs.ParSib = MakeIntoSiblingRef(Links);
        b->Refs.ParSib = MakeIntoSiblingRef(c);
        Links->Refs.Child = MakeIntoLeftChildRef(b);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);

    } else if ((a != NULL) && (b != NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               /       ==>            \
        //      LeftChild                a ----- Links
        //       /     \                          /
        //      a       b                        b --
        //

        a->Refs.ParSib = MakeIntoSiblingRef(Links);
        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.Child = MakeIntoLeftChildRef(b);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);

    } else if ((a != NULL) && (b == NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               / \     ==>            \
        //      LeftChild   c            a ----- Links
        //       /                                /
        //      a                                    c
        //

        a->Refs.ParSib = MakeIntoSiblingRef(Links);
        Links->Refs.Child = MakeIntoRightChildRef(c);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);

    } else if ((a != NULL) && (b == NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               /       ==>            \
        //      LeftChild                a ----- Links
        //       /                                /
        //      a
        //

        a->Refs.ParSib = MakeIntoSiblingRef(Links);
        Links->Refs.Child = 0L;
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);

    } else if ((a == NULL) && (b != NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               / \     ==>      /     \
        //      LeftChild   c                    Links
        //             \                          /
        //              b                        b - c
        //

        b->Refs.ParSib = MakeIntoSiblingRef(c);
        Links->Refs.Child = MakeIntoLeftChildRef(b);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);
        LeftChild->Refs.Child = MakeIntoRightChildRef(Links);

    } else if ((a == NULL) && (b != NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               /       ==>      /     \
        //      LeftChild                        Links
        //             \                          /
        //              b                        b -
        //

        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.Child = MakeIntoLeftChildRef(b);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);
        LeftChild->Refs.Child = MakeIntoRightChildRef(Links);

    } else if ((a == NULL) && (b == NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               / \     ==>      /     \
        //      LeftChild   c                    Links
        //                                        /
        //                                           c
        //

        Links->Refs.Child = MakeIntoRightChildRef(c);
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);
        LeftChild->Refs.Child = MakeIntoRightChildRef(Links);

    } else if ((a == NULL) && (b == NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //              Links            LeftChild
        //               /       ==>      /     \
        //      LeftChild                        Links
        //                                        /
        //

        Links->Refs.Child = 0L;
        Links->Refs.ParSib = MakeIntoParentRef(LeftChild);
        LeftChild->Refs.Child = MakeIntoRightChildRef(Links);

    }

    if (IsRoot) {
        LeftChild->Refs.ParSib = MakeIntoParentRef(LeftChild);
    } else {
        LeftChild->Refs.ParSib = SavedParSibRef;
        SetRefViaPointer(ParentChildRef, LeftChild);
    }

}


VOID
TriRotateLeft (
    IN PTRI_SPLAY_LINKS Links
    )

{
    BOOLEAN IsRoot;
    PULONG ParentChildRef;
    ULONG SavedParSibRef;
    PTRI_SPLAY_LINKS RightChild;
    PTRI_SPLAY_LINKS a,b,c;

    //
    //  We perform the following rotation
    //
    //      -Links-                   -RightChild-
    //        / \                       /      \
    //       a   RightChild   ==>   Links       c
    //            /      \           / \
    //           b        c         a   b
    //
    //  where Links is a possible root and a,b, and c are all optional.
    //  We will consider each combination of optional children individually
    //  and handle the case of the root when we set T's parsib pointer and
    //  the backpointer to T.
    //

    //
    //  First remember if we are the root and if not also remember our
    //  back ref via our parent.
    //

    if (TriIsRoot(Links)) {
        IsRoot = TRUE;
    } else {
        IsRoot = FALSE;
        ParentChildRef = TriAddressOfBackRefViaParent(Links);
        SavedParSibRef = Links->Refs.ParSib;
    }

    //
    //  Now we set RightChild, a, b, and c, and then later check for the
    //  different combinations.  In the diagrams only those links that
    //  need to change are shown in the after part.
    //

    RightChild = TriRightChild(Links);
    a = TriLeftChild(Links);
    b = TriLeftChild(RightChild);
    c = TriRightChild(RightChild);

    if        ((a != NULL) && (b != NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //        / \                       /
        //       a   RightChild   ==>   Links ----- c
        //            /      \             \
        //           b        c         a - b
        //

        a->Refs.ParSib = MakeIntoSiblingRef(b);
        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.ParSib = MakeIntoSiblingRef(c);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a != NULL) && (b != NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //        / \                       /
        //       a   RightChild   ==>   Links -----
        //            /                    \
        //           b                  a - b
        //

        a->Refs.ParSib = MakeIntoSiblingRef(b);
        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.ParSib = MakeIntoParentRef(RightChild);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a != NULL) && (b == NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //        / \                       /
        //       a   RightChild   ==>   Links ----- c
        //                   \
        //                    c         a -
        //

        a->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.ParSib = MakeIntoSiblingRef(c);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a != NULL) && (b == NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //        / \                       /
        //       a   RightChild   ==>   Links -----
        //
        //                              a -
        //

        a->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.ParSib = MakeIntoParentRef(RightChild);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a == NULL) && (b != NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //          \                       /
        //           RightChild   ==>   Links ----- c
        //            /      \           / \
        //           b        c             b
        //

        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.Child = MakeIntoRightChildRef(b);
        Links->Refs.ParSib = MakeIntoSiblingRef(c);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a == NULL) && (b != NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //          \                       /
        //           RightChild   ==>   Links -----
        //            /                  / \
        //           b                      b
        //

        b->Refs.ParSib = MakeIntoParentRef(Links);
        Links->Refs.Child = MakeIntoRightChildRef(b);
        Links->Refs.ParSib = MakeIntoParentRef(RightChild);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a == NULL) && (b == NULL) && (c != NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //          \                       /
        //           RightChild   ==>   Links ----- c
        //                   \           /
        //                    c
        //

        Links->Refs.Child = 0L;
        Links->Refs.ParSib = MakeIntoSiblingRef(c);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    } else if ((a == NULL) && (b == NULL) && (c == NULL)) {

        //
        //  Handle the following case
        //
        //       Links                     RightChild
        //          \                       /
        //           RightChild   ==>   Links -----
        //                               /
        //
        //

        Links->Refs.Child = 0L;
        Links->Refs.ParSib = MakeIntoParentRef(RightChild);
        RightChild->Refs.Child = MakeIntoLeftChildRef(Links);

    }

    if (IsRoot) {
        RightChild->Refs.ParSib = MakeIntoParentRef(RightChild);
    } else {
        RightChild->Refs.ParSib = SavedParSibRef;
        SetRefViaPointer(ParentChildRef, RightChild);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\triangle.h ===
//
//  Define the two pointer triangle splay links and the associated
//  manipuliation macros and routines.  Note that the tri_splay_links should
//  be an opaque type.  Routine are provided to traverse and manipulate the
//  structure.
//
//  The structure of a tri_splay_links record is really
//
//      typedef struct _TRI_SPLAY_LINKS {
//          ULONG ParSib; // struct _TRI_SPLAY_LINKS *ParSib;
//          ULONG Child;  // struct _TRI_SPLAY_LINKS *Child;
//      } TRI_SPLAY_LINKS;
//
//  However to aid in debugging (and without extra cost) we declare the
//  structure to be a union so we can also reference the links as pointers
//  in the debugger.
//

typedef union _TRI_SPLAY_LINKS {
    struct {
        ULONG ParSib;
        ULONG Child;
    } Refs;
    struct {
        union _TRI_SPLAY_LINKS *ParSibPtr;
        union _TRI_SPLAY_LINKS *ChildPtr;
    } Ptrs;
} TRI_SPLAY_LINKS;
typedef TRI_SPLAY_LINKS *PTRI_SPLAY_LINKS;

//
//  The macro procedure InitializeSplayLinks takes as input a pointer to
//  splay link and initializes its substructure.  All splay link nodes must
//  be initialized before they are used in the different splay routines and
//  macros.
//
// VOID
// TriInitializeSplayLinks (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriInitializeSplayLinks(Links) { \
    (Links)->Refs.ParSib = MakeIntoParentRef(Links); \
    (Links)->Refs.Child = 0; \
    }

//
//  The macro function Parent takes as input a pointer to a splay link in a
//  tree and returns a pointer to the splay link of the parent of the input
//  node.  If the input node is the root of the tree the return value is
//  equal to the input value.
//
// PTRI_SPLAY_LINKS
// TriParent (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriParent(Links) ( \
    (IsParentRef((Links)->Refs.ParSib)) ? \
        MakeIntoPointer((Links)->Refs.ParSib) \
    : \
        MakeIntoPointer(MakeIntoPointer((Links)->Refs.ParSib)->Refs.ParSib) \
    )

//
//  The macro function LeftChild takes as input a pointer to a splay link in
//  a tree and returns a pointer to the splay link of the left child of the
//  input node.  If the left child does not exist, the return value is NULL.
//
// PTRI_SPLAY_LINKS
// TriLeftChild (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriLeftChild(Links) ( \
    (IsLeftChildRef((Links)->Refs.Child)) ? \
        MakeIntoPointer((Links)->Refs.Child) \
    : \
        0 \
    )

//
//  The macro function RightChild takes as input a pointer to a splay link
//  in a tree and returns a pointer to the splay link of the right child of
//  the input node.  If the right child does not exist, the return value is
//  NULL.
//
// PTRI_SPLAY_LINKS
// TriRightChild (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriRightChild(Links) ( \
    (IsRightChildRef((Links)->Refs.Child)) ? \
        MakeIntoPointer((Links)->Refs.Child) \
    : ( \
        (IsLeftChildRef((Links)->Refs.Child) && \
         IsSiblingRef(MakeIntoPointer((Links)->Refs.Child)->Refs.ParSib)) ? \
            MakeIntoPointer(MakeIntoPointer((Links)->Refs.Child)->Refs.ParSib) \
        : \
            0 \
        ) \
    )

//
//  The macro function IsRoot takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the root of the tree,
//  otherwise it returns FALSE.
//
// BOOLEAN
// TriIsRoot (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriIsRoot(Links) ( \
    (IsParentRef((Links)->Refs.ParSib) && MakeIntoPointer((Links)->Refs.ParSib) == (Links)) ? \
        TRUE \
    : \
        FALSE \
    )

//
//  The macro function IsLeftChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the left child of its
//  parent, otherwise it returns FALSE.  Note that if the input link is the
//  root node this function returns FALSE.
//
// BOOLEAN
// TriIsLeftChild (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriIsLeftChild(Links) ( \
    (TriLeftChild(TriParent(Links)) == (Links)) ? \
        TRUE \
    : \
        FALSE \
    )

//
//  The macro function IsRightChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the right child of its
//  parent, otherwise it returns FALSE.  Note that if the input link is the
//  root node this function returns FALSE.
//
// BOOLEAN
// TriIsRightChild (
//     IN PTRI_SPLAY_LINKS Links
//     );
//

#define TriIsRightChild(Links) ( \
    (TriRightChild(TriParent(Links)) == (Links)) ? \
        TRUE \
    : \
        FALSE \
    )

//
//  The macro procedure InsertAsLeftChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the left child of the first node.  The first node must not
//  already have a left child, and the second node must not already have a
//  parent.
//
// VOID
// TriInsertAsLeftChild (
//     IN PTRI_SPLAY_LINKS ParentLinks,
//     IN PTRI_SPLAY_LINKS ChildLinks
//     );
//

#define TriInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PTRI_SPLAY_LINKS RightChild; \
    if ((ParentLinks)->Refs.Child == 0) { \
        (ParentLinks)->Refs.Child = MakeIntoLeftChildRef(ChildLinks); \
        (ChildLinks)->Refs.ParSib = MakeIntoParentRef(ParentLinks); \
    } else { \
        RightChild = TriRightChild(ParentLinks); \
        (ParentLinks)->Refs.Child = MakeIntoLeftChildRef(ChildLinks); \
        (ChildLinks)->Refs.ParSib = MakeIntoSiblingRef(RightChild); \
    } \
}

//
//  The macro procedure InsertAsRightChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the right child of the first node.  The first node must not
//  already have a right child, and the second node must not already have a
//  parent.
//
// VOID
// TriInsertAsRightChild (
//     IN PTRI_SPLAY_LINKS ParentLinks,
//     IN PTRI_SPLAY_LINKS ChildLinks
//     );
//

#define TriInsertAsRightChild(ParentLinks,ChildLinks) { \
    PTRI_SPLAY_LINKS LeftChild; \
    if ((ParentLinks)->Refs.Child == 0) { \
        (ParentLinks)->Refs.Child = MakeIntoRightChildRef(ChildLinks); \
        (ChildLinks)->Refs.ParSib = MakeIntoParentRef(ParentLinks); \
    } else { \
        LeftChild = TriLeftChild(ParentLinks); \
        LeftChild->Refs.ParSib = MakeIntoSiblingRef(ChildLinks); \
        (ChildLinks)->Refs.ParSib = MakeIntoParentRef(ParentLinks); \
    } \
}

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

PTRI_SPLAY_LINKS
TriSplay (
    IN PTRI_SPLAY_LINKS Links
    );

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//

PTRI_SPLAY_LINKS
TriDelete (
    IN PTRI_SPLAY_LINKS Links
    );

//
//  The SubtreeSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node of
//  the substree rooted at the input node.  If there is not a successor, the
//  return value is NULL.
//

PTRI_SPLAY_LINKS
TriSubtreeSuccessor (
    IN PTRI_SPLAY_LINKS Links
    );

//
//  The SubtreePredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node of
//  the substree rooted at the input node.  If there is not a predecessor,
//  the return value is NULL.
//

PTRI_SPLAY_LINKS
TriSubtreePredecessor (
    IN PTRI_SPLAY_LINKS Links
    );

//
//  The RealSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node within
//  the entire tree.  If there is not a successor, the return value is NULL.
//

PTRI_SPLAY_LINKS
TriRealSuccessor (
    IN PTRI_SPLAY_LINKS Links
    );

//
//  The RealPredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node
//  within the entire tree.  If there is not a predecessor, the return value
//  is NULL.
//

PTRI_SPLAY_LINKS
TriRealPredecessor (
    IN PTRI_SPLAY_LINKS Links
    );


//
//  The remainder of this module really belong in triangle.c  None of
//  the macros or routines are (logically) exported for use by the programmer
//  however they need to appear in this module to allow the earlier macros
//  to function properly.
//
//  In the splay record (declared earlier) the low order bit of the
//  ParSib field indicates whether the link is to a Parent or a Sibling, and
//  the low order bit of the Child field is used to indicate if the link
//  is to a left child or a right child.  The values are:
//
//      A parent field has the lower bit set to 0
//      A sibling field has the lower bit set to 1
//      A left child field has the lower bit set to 0
//      A right child field has the lower bit set to 1
//
//  The comments and code in triangle.c use the term "Ref" to indicate a
//  ParSib field or a Child field with the low order bit to indicate its type.
//  A ref cannot be directly used as a pointer.  The following macros help
//  in deciding the type of a ref and making refs from pointers.  There is
//  also a macro (MakeIntoPointer) that takes a ref and returns a pointer.
//

#define IsParentRef(Ulong)           (((((ULONG)Ulong) & 1) == 0) && ((Ulong) != 0) ? TRUE : FALSE)
#define MakeIntoParentRef(Ulong)     (((ULONG)Ulong) & 0xfffffffc)

#define IsSiblingRef(Ulong)          ((((ULONG)Ulong) & 1) == 1 ? TRUE : FALSE)
#define MakeIntoSiblingRef(Ulong)    (((ULONG)Ulong) | 1)

#define IsLeftChildRef(Ulong)        (((((ULONG)Ulong) & 1) == 0) && ((Ulong) != 0) ? TRUE : FALSE)
#define MakeIntoLeftChildRef(Ulong)  (((ULONG)Ulong) & 0xfffffffc)

#define IsRightChildRef(Ulong)       ((((ULONG)Ulong) & 1) == 1 ? TRUE : FALSE)
#define MakeIntoRightChildRef(Ulong) (((ULONG)Ulong) | 1)

#define MakeIntoPointer(Ulong)       ((PTRI_SPLAY_LINKS)((Ulong) & 0xfffffffc))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\wait.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module defines functions for the wait thread pool.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Revision History:

    lokeshs - extended/modified threadpool.

    Rob Earhart (earhart) September 29, 2000
      Split off from threads.c

Environment:

    These routines are statically linked in the caller's executable
    and are callable only from user mode. They make use of Nt system
    services.


--*/

#include <ntos.h>
#include <ntrtl.h>
#include <wow64t.h>
#include "ntrtlp.h"
#include "threads.h"

// Wait Thread Pool
// ----------------
// Clients can submit a waitable object with an optional timeout to wait on.
// One thread is created per MAXIMUM_WAIT_OBJECTS-1 such waitable objects.

//
// Lifecycle of a wait object:
//
// Things start when a client calls RtlRegisterWait.  RtlRegisterWait
// allocates memory for the wait object, captures the activation
// context, calls RtlpFindWaitThread to obtain a wait thread, and
// queues an RtlpAddWait APC to the wait thread.  The wait is now
// bound to this wait thread for the rest of its life cycle.
//
// RtlpAddWait executes in an APC in the wait thread.  If the wait's
// deleted bit has already been set, it simply deletes the wait;
// otherwise, it adds the wait to the thread's wait array block, and
// sets the wait's STATE_REGISTERED and STATE_ACTIVE flags.  It also
// creates a timer object if necessary, and sets the wait's refcount
// to one.
//
// RtlDeregisterWait is a wrapper for RtlDeregisterWaitEx.
// RtlDeregisterWaitEx gets a completion event if necessary, and
// stuffs it or the user's supplied event into the wait.  If
// RtlDeregisterWaitEx is called within the wait thread, it then calls
// RtlpDeregisterWait directly; otherwise, it allocates a partial
// completion event, and queues RtlpDeregisterWait as an APC to the
// wait's thread, and blocks until the partial completion event is
// triggered (indicating that the APC in the wait thread has begun --
// this means no more callbacks will occur).  In a blocking call to
// RtlDeregisterWaitEx, the function waits on the completion event,
// and returns.
//
// RtlpDeregisterWait is always executed in the wait thread associated
// with the wait it's being called on.  It checks the state; if the
// event hasn't been registered, then it's being called before
// RtlpAddWait, so it sets the Deleted bit and returns -- RtlpAddWait
// will delete the object when it sees this.  Otherwise, if the wait
// is active, it calls RtlpDeactivateWait (which calls
// RtlpDeactivateWithIndex), sets the delete bit, decrements the
// refcount, and if it has the last reference, calls RtlpDeleteWait to
// reclaim the wait's memory.  Finally, it sets the partial completion
// event, if one was passed in.
//
// RtlpDeleteWait assumes that the last reference to the wait has gone 
// away; it sets the wait's completion event, if it has one, releases
// the activation context, and frees the wait's memory.
//
// The wait thread runs RtlpWaitThread, which allocates a wait thread
// block from its stack, initializes it with a timer and a handle on
// the thread (among other things), tells its starter to proceed, and
// drops into its wait loop.  The thread waits on its objects,
// restarting if alerted or if an APC is delivered (since the APC may
// have adjusted the wait array).  If the wait on the timer object
// completes, the thread processes timeouts via RtlpProcessTimeouts;
// otherwise, it calls RtlpProcessWaitCompletion to handle the
// completed wait.
//
// If RtlpWaitThread finds an abandoned mutant or a bad handle, it
// calls RtlpDeactivateWaitWithIndex to kill the wait.
//
// RtlpDeactivateWithIndex resets the wait's timer, turns off its
// active bit, and removes it from the wait thread's wait array.
//
// RtlpProcessWaitCompletion deactivates the wait if it's meant to
// only be executed once; otherwise, it resets the wait's timer, and
// moves the wait to the end of the wait array.  If the wait's
// supposed to be executed in the wait thread, it calls the wait's
// callback function directly; otherwise, it bumps up the wait's
// refcount, and queues an RtlpAsyncWaitCallbackCompletion APC to a
// worker thread.
//
// RtlpAsyncWaitCallbackCompletion makes the callout, and decrements
// the refcount, calling RtlpDeleteWait if the refcount falls to
// zero.
//
// RtlpProcessTimeouts calls RtlpFireTimersAndReorder to extract the
// times to be fired, and then calls RtlpFireTimers to fire them.
// This either calls the callback directly, or queues an
// RtlpAsyncWaitCallbackCompletion APC to a worker thread (bumping up
// the refcount in the process).
//

LIST_ENTRY WaitThreads ;                // List of all wait threads created
RTL_CRITICAL_SECTION WaitCriticalSection ;      // Exclusion used by wait threads
ULONG StartedWaitInitialization ;       // Used for Wait thread startup synchronization
ULONG CompletedWaitInitialization ;     // Used to check if Wait thread pool is initialized
HANDLE WaitThreadStartedEvent;          // Indicates that a wait thread has started
HANDLE WaitThreadTimer;                 // Timer handle for the new wait thread
HANDLE WaitThreadHandle;                // Thread handle for the new wait thread

#if DBG1
ULONG NextWaitDbgId;
#endif

NTSTATUS
RtlpInitializeWaitThreadPool (
    )
/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER TimeOut ;

    ASSERT(! RtlIsImpersonating());

    // In order to avoid an explicit RtlInitialize() function to initialize the wait thread pool
    // we use StartedWaitInitialization and CompletedWait Initialization to provide us the
    // necessary synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() or NtCreateEvent fails - but in this case the
    // caller has not choices left.

    if (!InterlockedExchange(&StartedWaitInitialization, 1L)) {

        if (CompletedWaitInitialization)
            InterlockedExchange (&CompletedWaitInitialization, 0L) ;

        // Initialize Critical Section

        Status = RtlInitializeCriticalSection( &WaitCriticalSection ) ;

        if (! NT_SUCCESS( Status ) ) {

            StartedWaitInitialization = 0 ;
            InterlockedExchange (&CompletedWaitInitialization, ~0) ;

            return Status ;
        }

        InitializeListHead (&WaitThreads);  // Initialize global wait threads list

        InterlockedExchange (&CompletedWaitInitialization, 1L) ;

    } else {

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!*((ULONG volatile *)&CompletedWaitInitialization)) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

        if (CompletedWaitInitialization != 1) {
            Status = STATUS_NO_MEMORY ;
        }
    }

    return Status ;
}

#if DBG
VOID
RtlpDumpWaits(
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    )
{
    ULONG Lupe;
    
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_VERBOSE_MASK,
               "Current active waits [Handle, Wait] for thread %x:",
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread));
    for (Lupe = 0; Lupe < ThreadCB->NumActiveWaits; Lupe++) {
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_VERBOSE_MASK,
                   "%s  [%p, %p]",
                   Lupe % 4 ? "" : "\n",
                   ThreadCB->ActiveWaitArray[Lupe],
                   ThreadCB->ActiveWaitPointers[Lupe]);
    }
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_VERBOSE_MASK,
               "\n%d (0x%x) total waits\n",
               ThreadCB->NumActiveWaits,
               ThreadCB->NumActiveWaits);
}
#endif

VOID
RtlpAddWait (
    PRTLP_WAIT          Wait,
    PRTLP_GENERIC_TIMER Timer,
    PRTLP_EVENT         StartEvent
    )
/*++

Routine Description:

    This routine is used for adding waits to the wait thread. It is executed in
    an APC.

Arguments:

    Wait - The wait to add

    Timer - Space for the wait timer's memory (if needed)

    StartEvent - Event which will be set once the caller has the handle

Return Value:

--*/
{
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = Wait->ThreadCB;

    ASSERT(StartEvent);
    NtWaitForSingleObject(StartEvent->Handle, FALSE, NULL);
    RtlpFreeWaitEvent(StartEvent);

    // if the state is deleted, it implies that RtlDeregister was called in a
    // WaitThreadCallback for a Wait other than that which was fired. This is
    // an application bug, but we handle it.

    if ( Wait->State & STATE_DELETE ) {

        InterlockedDecrement( &ThreadCB->NumWaits );

        RtlpDeleteWait (Wait);

        if (Timer) {
            RtlpFreeTPHeap(Timer);
        }

        return ;
    }


    // activate Wait

    ThreadCB->ActiveWaitArray [ThreadCB->NumActiveWaits] = Wait->WaitHandle ;
    ThreadCB->ActiveWaitPointers[ThreadCB->NumActiveWaits] = Wait ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Wait %p (Handle %p) inserted as index %d in thread %x\n",
               Wait->DbgId,
               Wait,
               Wait->WaitHandle,
               ThreadCB->NumActiveWaits,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)) ;
#endif

    ThreadCB->NumActiveWaits ++ ;

#if DBG
    RtlpDumpWaits(ThreadCB);
#endif

    ThreadCB->NumRegisteredWaits++;
    RtlInterlockedSetBitsDiscardReturn(&Wait->State,
                                       STATE_REGISTERED
                                       | STATE_ACTIVE);
    Wait->RefCount = 1 ;


    // Fill in the wait timer

    if (Wait->Timeout != INFINITE_TIME) {

        ULONG TimeRemaining ;
        ULONG NewFiringTime ;

        // Initialize timer related fields and insert the timer in the timer queue for
        // this wait thread
        ASSERT(Timer != NULL);
        Wait->Timer = Timer;
        Wait->Timer->Function = Wait->Function ;
        Wait->Timer->Context = Wait->Context ;
        Wait->Timer->Flags = Wait->Flags ;
        Wait->Timer->DeltaFiringTime = Wait->Timeout ;
        Wait->Timer->Period = ( Wait->Flags & WT_EXECUTEONLYONCE )
                                ? 0
                                : Wait->Timeout == INFINITE_TIME
                                ? 0 : Wait->Timeout ;

        RtlInterlockedSetBitsDiscardReturn(&Wait->Timer->State,
                                           STATE_REGISTERED | STATE_ACTIVE);
        Wait->Timer->Wait = Wait ;
        Wait->Timer->RefCountPtr = &Wait->RefCount ;
        Wait->Timer->Queue = &ThreadCB->TimerQueue ;


        TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;

        if (RtlpInsertInDeltaList (&ThreadCB->TimerQueue.TimerList, Wait->Timer,
                                    TimeRemaining, &NewFiringTime))
        {
            // If the element was inserted at head of list then reset the timers

            RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
        }

    } else {

        // No timer with this wait

        ASSERT(Timer == NULL);

    }

    return ;
}

VOID
RtlpAsyncWaitCallbackCompletion(
    PVOID Context
    )
/*++

Routine Description:

    This routine is called in a (IO)worker thread and is used to decrement the
    RefCount at the end and call RtlpDeleteWait if required

Arguments:

    Context - pointer to the Wait object

    Low bit of context: TimedOut parameter to RtlpWaitOrTimerCallout

Return Value:

--*/
{
    BOOLEAN TimedOut = (BOOLEAN)((ULONG_PTR)Context & 1);
    PRTLP_WAIT Wait = (PRTLP_WAIT)((ULONG_PTR)Context & ~((ULONG_PTR) 1));
    
#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Calling Wait %p: Handle:%p fn:%p context:%p bool:%d Thread<%x:%x>\n",
               Wait->DbgId,
               Wait,
               Wait->WaitHandle,
               Wait->Function,
               Wait->Context,
               (ULONG)TimedOut,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)
      ) ;
#endif

    RtlpWaitOrTimerCallout(Wait->Function,
                           Wait->Context,
                           TimedOut,
                           Wait->ActivationContext,
                           Wait->ImpersonationToken,
                           NULL);

    if ( InterlockedDecrement( &Wait->RefCount ) == 0 ) {

        RtlpDeleteWait( Wait ) ;

    }
}

NTSTATUS
RtlpDeactivateWaitWithIndex (
    PRTLP_WAIT Wait,
    BOOLEAN    OkayToFreeTheTimer,
    ULONG      ArrayIndex
    )
/*++

Routine Description:

    This routine is used for deactivating the specified wait. It is executed in a APC.

Arguments:

    Wait - The wait to deactivate

    OkayToFreeTheTimer - If TRUE, we can delete the wait's timer immediately;
                         otherwise, we need to keep it around.

    ArrayIndex - The index of the wait to deactivate

Return Value:

--*/
{
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = Wait->ThreadCB ;
    ULONG EndIndex = ThreadCB->NumActiveWaits -1;

    ASSERT(Wait == ThreadCB->ActiveWaitPointers[ArrayIndex]);

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Deactivating Wait %p (Handle %p); index %d in thread %x\n",
               Wait->DbgId,
               Wait,
               Wait->WaitHandle,
               ArrayIndex,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)) ;
#endif

    // Move the remaining ActiveWaitArray left.
    RtlpShiftWaitArray( ThreadCB, ArrayIndex+1, ArrayIndex,
                        EndIndex - ArrayIndex ) ;

    //
    // delete timer if associated with this wait
    //

    if ( Wait->Timer ) {

        ULONG TimeRemaining ;
        ULONG NewFiringTime ;

        if (! (Wait->Timer->State & STATE_ACTIVE) ) {

            RemoveEntryList( &Wait->Timer->List ) ;

        } else {

            TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;


            if (RtlpRemoveFromDeltaList (&ThreadCB->TimerQueue.TimerList, Wait->Timer,
                                            TimeRemaining, &NewFiringTime))
            {

                RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
            }
        }

        if (OkayToFreeTheTimer) {
            //
            // Our caller doesn't want the timer's memory; free it now.
            //
            RtlpFreeTPHeap(Wait->Timer);

        } else {

            //
            // Our caller wants to keep using the timer's memory, so we 
            // can't free it; instead, we leave it up to our caller.
            //
            NOTHING;
        }

        Wait->Timer = NULL;
    } else {
        //
        // If the wait doesn't have a timer, there's no way our caller 
        // has the timer, so our caller *should* have set
        // OkayToFreeTheTimer.  Let's make sure:
        //
        ASSERT(OkayToFreeTheTimer);
    }

    // Decrement the (active) wait count

    ThreadCB->NumActiveWaits-- ;
    InterlockedDecrement( &ThreadCB->NumWaits ) ;

#if DBG
    RtlpDumpWaits(ThreadCB);
#endif

    RtlInterlockedClearBitsDiscardReturn(&Wait->State,
                                         STATE_ACTIVE);

    return STATUS_SUCCESS;

}

NTSTATUS
RtlpDeactivateWait (
    PRTLP_WAIT Wait,
    BOOLEAN    OkayToFreeTheTimer
    )
/*++

Routine Description:

    This routine is used for deactivating the specified wait. It is executed in a APC.

Arguments:

    Wait - The wait to deactivate

    OkayToFreeTheTimer - If TRUE, we can delete the wait's timer immediately;
                         otherwise, we need to keep it around.

Return Value:

--*/
{
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = Wait->ThreadCB ;
    ULONG ArrayIndex ; //Index in ActiveWaitArray where the Wait object is placed
    ULONG EndIndex = ThreadCB->NumActiveWaits -1;

    // get the index in ActiveWaitArray

    for (ArrayIndex = 0;  ArrayIndex <= EndIndex; ArrayIndex++) {

        if (ThreadCB->ActiveWaitPointers[ArrayIndex] == Wait)
            break ;
    }

    if ( ArrayIndex > EndIndex ) {

        return STATUS_NOT_FOUND;
    }

    return RtlpDeactivateWaitWithIndex(Wait, OkayToFreeTheTimer, ArrayIndex);
}

VOID
RtlpProcessWaitCompletion (
    PRTLP_WAIT Wait,
    ULONG ArrayIndex
    )
/*++

Routine Description:

    This routine is used for processing a completed wait

Arguments:

    Wait - Wait that completed

Return Value:

--*/
{
    ULONG TimeRemaining ;
    ULONG NewFiringTime ;
    LARGE_INTEGER DueTime ;
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;
    NTSTATUS Status;

    ThreadCB = Wait->ThreadCB ;

    // deactivate wait if it is meant for single execution

    if ( Wait->Flags & WT_EXECUTEONLYONCE ) {

        RtlpDeactivateWaitWithIndex (Wait, TRUE, ArrayIndex) ;
    }

    else {
        // if wait being reactivated, then reset the timer now itself as
        // it can be deleted in the callback function

        if  ( Wait->Timer ) {

            TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;

            if (RtlpReOrderDeltaList (
                        &ThreadCB->TimerQueue.TimerList,
                        Wait->Timer,
                        TimeRemaining,
                        &NewFiringTime,
                        Wait->Timer->Period)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
            }

        }

        // move the wait entry to the end, and shift elements to its right one pos towards left
        {
            HANDLE HandlePtr = ThreadCB->ActiveWaitArray[ArrayIndex];
            PRTLP_WAIT WaitPtr = ThreadCB->ActiveWaitPointers[ArrayIndex];

            RtlpShiftWaitArray(ThreadCB, ArrayIndex+1, ArrayIndex,
                            ThreadCB->NumActiveWaits -1 - ArrayIndex)
            ThreadCB->ActiveWaitArray[ThreadCB->NumActiveWaits-1] = HandlePtr ;
            ThreadCB->ActiveWaitPointers[ThreadCB->NumActiveWaits-1] = WaitPtr ;
        }
    }

    // call callback function (FALSE since this isnt a timeout related callback)

    if ( Wait->Flags & WT_EXECUTEINWAITTHREAD ) {

        // executing callback after RtlpDeactivateWait allows the Callback to call
        // RtlDeregisterWait Wait->RefCount is not incremented so that RtlDeregisterWait
        // will work on this Wait. Though Wait->RefCount is not incremented, others cannot
        // deregister this Wait as it has to be queued as an APC.

#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "<%d> Calling WaitOrTimer(wait) %p: Handle %p fn:%p context:%p bool:%d Thread<%x:%x>\n",
                   Wait->DbgId,
                   Wait,
                   Wait->WaitHandle,
                   Wait->Function, Wait->Context,
                   FALSE,
                   HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                   HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
#endif
        
        RtlpWaitOrTimerCallout(Wait->Function,
                               Wait->Context,
                               FALSE,
                               Wait->ActivationContext,
                               Wait->ImpersonationToken,
                               NULL);

        // Wait object could have been deleted in the above callback

        return ;

    } else {

        InterlockedIncrement( &Wait->RefCount );

        Status = RtlQueueWorkItem(
            RtlpAsyncWaitCallbackCompletion,
            Wait,
            Wait->Flags );

        if (!NT_SUCCESS(Status)) {

            // NTRAID#202802-2000/10/12-earhart: we really ought
            // to deal with this case in a better way, since we
            // can't guarantee (with our current architecture)
            // that the enqueue will work.

            if ( InterlockedDecrement( &Wait->RefCount ) == 0 ) {
                RtlpDeleteWait( Wait );
            }
        }
    }
}

LONG
RtlpWaitThread (
    PVOID Parameter
    )
/*++

Routine Description:

    This routine is used for all waits in the wait thread pool

Arguments:

    HandlePtr - Pointer to our handle

Return Value:

    Nothing. The thread never terminates.


    N.B. This thread is started while another thread (calling
         RtlpStartWaitThread) holds the WaitCriticalSection;
         WaitCriticalSection will be held until WaitThreadStartedEvent
         is set.

--*/
{
    ULONG  i ;                                   // Used as an index
    NTSTATUS Status ;
    LARGE_INTEGER TimeOut;                       // Timeout used for waits
    PLARGE_INTEGER TimeOutPtr;                   // Pointer to timeout
    RTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCBBuf;  // Control Block
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = &ThreadCBBuf;
#define WAIT_IDLE_TIMEOUT 400000

    UNREFERENCED_PARAMETER(Parameter);

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "Starting wait thread\n");
#endif

    // Initialize thread control block

    RtlZeroMemory(&ThreadCBBuf, sizeof(ThreadCBBuf));

    InitializeListHead (&ThreadCB->WaitThreadsList) ;

    ThreadCB->ThreadHandle = WaitThreadHandle;

    ThreadCB->ThreadId =  HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    RtlZeroMemory (&ThreadCB->ActiveWaitArray[0], sizeof (HANDLE) * MAXIMUM_WAIT_OBJECTS) ;

    RtlZeroMemory (&ThreadCB->ActiveWaitPointers[0], sizeof (HANDLE) * MAXIMUM_WAIT_OBJECTS) ;

    ThreadCB->TimerHandle = WaitThreadTimer;

    ThreadCB->Firing64BitTickCount = 0 ;
    ThreadCB->Current64BitTickCount.QuadPart = NtGetTickCount() ;

    // Reset the NT Timer to never fire initially

    RtlpResetTimer (ThreadCB->TimerHandle, -1, ThreadCB) ;

    InitializeListHead (&ThreadCB->TimerQueue.TimerList) ;
    InitializeListHead (&ThreadCB->TimerQueue.UncancelledTimerList) ;

    // Insert this new wait thread in the WaitThreads list. Insert at the head so that
    // the request that caused this thread to be created can find it right away.

    InsertHeadList (&WaitThreads, &ThreadCB->WaitThreadsList) ;


    // The first wait element is the timer object

    ThreadCB->ActiveWaitArray[0] = ThreadCB->TimerHandle ;

    ThreadCB->NumActiveWaits = ThreadCB->NumWaits = 1 ;

    ThreadCB->NumRegisteredWaits = 0;

    // till here, the function is running under the global wait lock

    // We are all initialized now. Notify the starter to queue the task.

    NtSetEvent(WaitThreadStartedEvent, NULL);

    // Loop forever - wait threads never, never die.

    for ( ; ; ) {

        if (ThreadCB->NumActiveWaits == 1
            && ThreadCB->NumRegisteredWaits == 0) {
            // It we don't have anything depending on us, and we're
            // idle for a while, it might be good for us to go away.
            TimeOut.QuadPart = Int32x32To64( WAIT_IDLE_TIMEOUT, -10000 ) ;
            TimeOutPtr = &TimeOut;
        } else {
            // We need to stick around.
            TimeOutPtr = NULL;
        }

        Status = NtWaitForMultipleObjects (
                     (CHAR) ThreadCB->NumActiveWaits,
                     ThreadCB->ActiveWaitArray,
                     WaitAny,
                     TRUE,      // Wait Alertably
                     TimeOutPtr
                     ) ;

        if (Status == STATUS_ALERTED || Status == STATUS_USER_APC) {

            continue ;

        } else if (Status >= STATUS_WAIT_0 && Status <= STATUS_WAIT_63) {

            if (Status == STATUS_WAIT_0) {

                RtlpProcessTimeouts (ThreadCB) ;

            } else {

                // Wait completed call Callback function

                RtlpProcessWaitCompletion (
                        ThreadCB->ActiveWaitPointers[Status], Status) ;

            }

        } else if (Status >= STATUS_ABANDONED_WAIT_0
                    && Status <= STATUS_ABANDONED_WAIT_63) {

            PRTLP_WAIT Wait = ThreadCB->ActiveWaitPointers[Status - STATUS_ABANDONED_WAIT_0];

#if DBG
            DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                       RTLP_THREADPOOL_ERROR_MASK,
                       "<%d> Abandoned wait %p: index:%d Handle:%p\n",
                       Wait->DbgId,
                       Wait,
                       Status - STATUS_ABANDONED_WAIT_0,
                       ThreadCB->ActiveWaitArray[Status - STATUS_ABANDONED_WAIT_0]);
#endif

            // Abandoned wait -- nuke it.

            // ISSUE-2000/10/13-earhart: It would be ideal to do
            // something with the mutex -- maybe release it?  If we
            // could abandon it as we release it, that would be ideal.
            // This is not a good situation.  Maybe we could call
            // NtReleaseMutant when we register the object, failing
            // the registration unless we get back
            // STATUS_OBJECT_TYPE_MISMATCH.  Although who knows
            // whether someone's having wait threads wait for mutexes, 
            // doing their lock processing inside the callback?
            RtlpDeactivateWaitWithIndex(Wait,
                                        TRUE,
                                        Status - STATUS_ABANDONED_WAIT_0);

        } else if (Status == STATUS_TIMEOUT) {

            //
            // remove this thread from the wait list and terminate
            //

            {
                ULONG NumWaits;

                ACQUIRE_GLOBAL_WAIT_LOCK() ;

                NumWaits = ThreadCB->NumWaits;

                if (ThreadCB->NumWaits <= 1) {
                    RemoveEntryList(&ThreadCB->WaitThreadsList) ;
                    NtClose(ThreadCB->ThreadHandle) ;
                    NtClose(ThreadCB->TimerHandle) ;
                }

                RELEASE_GLOBAL_WAIT_LOCK() ;

                if (NumWaits <= 1) {

                    RtlpExitThreadFunc( 0 );
                }
            }

        } else if (Status == STATUS_INSUFFICIENT_RESOURCES) {

	  //
	  // Delay for a short period of time, and retry the wait.
	  //
	  TimeOut.QuadPart = UInt32x32To64( 10 /* Milliseconds to sleep */,
                                            10000 /* Milliseconds to 100 Nanoseconds) */);
	  TimeOut.QuadPart *= -1; /* Make it a relative time */
	  NtDelayExecution(TRUE, &TimeOut);

	} else {

            // Some other error: scan for bad object handles and keep going.
            ULONG xi ;
                  
#if DBG
            DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                       RTLP_THREADPOOL_WARNING_MASK,
                       "Application broke an object handle "
                       "that the wait thread was waiting on: Code:%x ThreadId:<%x:%x>\n",
                       Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                       HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

            TimeOut.QuadPart = 0 ;

            for (xi = 0;
                 xi < ThreadCB->NumActiveWaits;
                 xi++) {

                Status = NtWaitForSingleObject(
                    ThreadCB->ActiveWaitArray[xi],
                    FALSE,     // Don't bother being alertable
                    &TimeOut   // Just poll
                    ) ;

                if (Status == STATUS_SUCCESS) {

                    // We succeded our wait here; we need to issue its 
                    // callout now (in case waiting on it changes its
                    // status -- auto-reset events, mutexes, &c...)
                    if (xi == 0) {
                        RtlpProcessTimeouts(ThreadCB);
                    } else {
                        RtlpProcessWaitCompletion(ThreadCB->ActiveWaitPointers[xi], xi);
                    }

                    // In case that causes us to take any APCs, let's
                    // drop out and go back to waiting.

                    break;

                } else if (Status == STATUS_USER_APC) {

                    // It's not worth going on after this -- bail.
                    break;

                } else if (Status != STATUS_TIMEOUT) {
                    
#if DBG
                    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                               Status == STATUS_ABANDONED_WAIT_0
                               ? RTLP_THREADPOOL_ERROR_MASK
                               : RTLP_THREADPOOL_WARNING_MASK,
                               "<%d> %s: index:%d Handle:%p WaitEntry Ptr:%p\n",
                               ThreadCB->ActiveWaitPointers[xi]->DbgId,
                               Status == STATUS_ABANDONED_WAIT_0
                               ? "Abandoned wait"
                               : "Deactivating invalid handle",
                               xi,
                               ThreadCB->ActiveWaitArray[xi],
                               ThreadCB->ActiveWaitPointers[xi] ) ;
#endif
                    RtlpDeactivateWaitWithIndex(ThreadCB->ActiveWaitPointers[xi],
                                                TRUE,
                                                xi);

                    break;

                }
            } // loop over active waits
        }

    } // forever

    return 0 ; // Keep compiler happy

}

NTSTATUS
RtlpStartWaitThread(
    VOID
    )
// N.B. The WaitCriticalSection MUST be held when calling this function
{
    NTSTATUS Status;
    PRTLP_EVENT Event = NULL;

    WaitThreadTimer = NULL;
    WaitThreadStartedEvent = NULL;

    Event = RtlpGetWaitEvent();
    if (! Event) {
        Status = STATUS_NO_MEMORY;
        goto fail;
    }

    WaitThreadStartedEvent = Event->Handle;

    Status = NtCreateTimer(&WaitThreadTimer,
                           TIMER_ALL_ACCESS,
                           NULL,
                           NotificationTimer);

    if (! NT_SUCCESS(Status)) {
        goto fail;
    }

    Status = RtlpStartThreadpoolThread (RtlpWaitThread, NULL, &WaitThreadHandle);

    if (! NT_SUCCESS(Status)) {
        goto fail;
    }

    Status = NtWaitForSingleObject(WaitThreadStartedEvent, FALSE, NULL);

    if (! NT_SUCCESS(Status)) {
        goto fail;
    }

    RtlpFreeWaitEvent(Event);

    WaitThreadTimer = NULL;
    WaitThreadStartedEvent = NULL;

    return STATUS_SUCCESS;

 fail:
    if (WaitThreadTimer) {
        NtClose(WaitThreadTimer);
    }

    if (Event) {
        RtlpFreeWaitEvent(Event);
    }

    WaitThreadTimer = NULL;
    WaitThreadStartedEvent = NULL;

    return Status;
}

NTSTATUS
RtlpFindWaitThread (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK *ThreadCB
)
/*++

Routine Description:

    Walks thru the list of wait threads and finds one which can accomodate another wait.
    If one is not found then a new thread is created.

    This routine assumes that the caller has the GlobalWaitLock.

Arguments:

    ThreadCB: returns the ThreadCB of the wait thread that will service the wait request.

Return Value:

    STATUS_SUCCESS if a wait thread was allocated,

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY Node ;
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCBTmp;


    ACQUIRE_GLOBAL_WAIT_LOCK() ;

    do {

        // Walk thru the list of Wait Threads and find a Wait thread that can accomodate a
        // new wait request.

        // *Consider* finding a wait thread with least # of waits to facilitate better
        // load balancing of waits.


        for (Node = WaitThreads.Flink ; Node != &WaitThreads ; Node = Node->Flink) {

            ThreadCBTmp = CONTAINING_RECORD (Node, RTLP_WAIT_THREAD_CONTROL_BLOCK,
                                            WaitThreadsList) ;


            // Wait Threads can accomodate up to MAXIMUM_WAIT_OBJECTS
            // waits (NtWaitForMultipleObjects limit)

            if ((ThreadCBTmp)->NumWaits < MAXIMUM_WAIT_OBJECTS) {

                // Found a thread with some wait slots available.

                InterlockedIncrement ( &(ThreadCBTmp)->NumWaits) ;

                *ThreadCB = ThreadCBTmp;

                RELEASE_GLOBAL_WAIT_LOCK() ;

                return STATUS_SUCCESS ;
            }

        }


        // If we reach here, we dont have any more wait threads. so create a new wait thread.

        Status = RtlpStartWaitThread();

        // If thread creation fails then return the failure to caller

        if (! NT_SUCCESS(Status) ) {

#if DBG
            DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                       RTLP_THREADPOOL_WARNING_MASK,
                       "ThreadPool could not create wait thread\n");
#endif

            RELEASE_GLOBAL_WAIT_LOCK() ;

            return Status ;

        }

        // Loop back now that we have created another thread

    } while (TRUE) ;    // Loop back to top and put new wait request in the newly created thread

    RELEASE_GLOBAL_WAIT_LOCK() ;

    return Status ;
}

VOID
RtlpWaitReleaseWorker(ULONG Flags)
{
    if (! (Flags & WT_EXECUTEINWAITTHREAD)) {
        RtlpReleaseWorker(Flags);
    }
}

NTSTATUS
RtlRegisterWait (
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    )

/*++

Routine Description:

    This routine adds a new wait request to the pool of objects being waited on.

Arguments:

    WaitHandle - Handle returned on successful completion of this routine.

    Handle - Handle to the object to be waited on

    Function - Routine that is called when the wait completes or a timeout occurs

    Context - Opaque pointer passed in as an argument to Function

    Milliseconds - Timeout for the wait in milliseconds. 0xffffffff means dont
            timeout.

    Flags - Can be one of:

        WT_EXECUTEINWAITTHREAD - if WorkerProc should be invoked in the wait
                thread itself. This should only be used for small routines.
        WT_EXECUTEINIOTHREAD - use only if the WorkerProc should be invoked in
                an IO Worker thread. Avoid using it.

    If Flags is not WT_EXECUTEINWAITTHREAD, the following flag can also be set:

        WT_EXECUTELONGFUNCTION - indicates that the callback might be blocked
                for a long duration. Use only if the callback is being queued to a
                worker thread.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

    STATUS_SUCCESS - The registration was successful.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the requested
                operation.

    or other NTSTATUS error code

--*/

{
    PRTLP_WAIT Wait ;
    NTSTATUS Status ;
    PRTLP_EVENT Event ;
    LARGE_INTEGER TimeOut ;
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = NULL;
    PRTLP_GENERIC_TIMER Timer;
    PRTLP_EVENT StartEvent;
    HANDLE StartEventHandle;
    HANDLE Token = NULL;

    *WaitHandle = NULL ;

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    if (Handle == NtCurrentThread()
        || Handle == NtCurrentProcess()) {
        return STATUS_INVALID_PARAMETER_2;
    }

    Status = RtlpCaptureImpersonation(Flags & WT_TRANSFER_IMPERSONATION,
                                      &Token);
                                      
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    // Initialize thread pool if it isnt already done

    if ( CompletedWaitInitialization != 1) {

        Status = RtlpInitializeWaitThreadPool () ;

        if (! NT_SUCCESS( Status ) )
            goto cleanup_token;
    }

    if (Flags&0xffff0000) {
        MaxThreads = (Flags & 0xffff0000)>>16;
    }

    StartEvent = RtlpGetWaitEvent();
    if (! StartEvent) {
        Status = STATUS_NO_MEMORY;
        goto cleanup_token;
    }

    // Initialize Wait request
    if (! (Flags & WT_EXECUTEINWAITTHREAD)) {
        Status = RtlpAcquireWorker(Flags);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_waitevent;
        }
    }

    Wait = (PRTLP_WAIT) RtlpAllocateTPHeap ( sizeof (RTLP_WAIT),
                                            HEAP_ZERO_MEMORY) ;

    if (!Wait) {
        Status = STATUS_NO_MEMORY;
        goto cleanup_worker;
    }

    Wait->Timer = NULL;

    if (Milliseconds != INFINITE_TIME) {
        Timer = RtlpAllocateTPHeap(sizeof(RTLP_GENERIC_TIMER),
                                   HEAP_ZERO_MEMORY);
        if (! Timer) {
            Status = STATUS_NO_MEMORY;
            goto cleanup_waitblock;
        }
    } else {
        Timer = NULL;
    }

    if (Token && (Flags & WT_TRANSFER_IMPERSONATION)) {
        Status = NtDuplicateToken(Token,
                                  TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                  NULL,
                                  FALSE,
                                  TokenImpersonation,
                                  &Wait->ImpersonationToken);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_timer;
        }
    } else {
        Wait->ImpersonationToken = NULL;
    }

    Status = RtlGetActiveActivationContext(&Wait->ActivationContext);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SXS_THREAD_QUERIES_DISABLED) {
            Wait->ActivationContext = INVALID_ACTIVATION_CONTEXT;
            Status = STATUS_SUCCESS;
        } else {
            goto cleanup_waittoken;
        }
    }

    Wait->WaitHandle = Handle ;
    Wait->Flags = Flags ;
    Wait->Function = Function ;
    Wait->Context = Context ;
    Wait->Timeout = Milliseconds ;
    SET_WAIT_SIGNATURE(Wait) ;

    // timer part of wait is initialized by wait thread in RtlpAddWait

    // Get a wait thread that can accomodate another wait request.

    Status = RtlpFindWaitThread (&ThreadCB) ;

    if (! NT_SUCCESS(Status)) {
        goto cleanup_signature;
    }

    Wait->ThreadCB = ThreadCB ;

#if DBG1
    Wait->DbgId = ++NextWaitDbgId ;
    Wait->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
#endif

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> Wait %p (Handle %p) created by thread:<%x:%x>; queueing APC\n",
               Wait->DbgId, 1, Wait, Wait->WaitHandle,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

    // Queue an APC to the Wait Thread

    Status = NtQueueApcThread(
                    ThreadCB->ThreadHandle,
                    (PPS_APC_ROUTINE)RtlpAddWait,
                    (PVOID)Wait,
                    (PVOID)Timer,
                    (PVOID)StartEvent
                    );


    if ( NT_SUCCESS(Status) ) {

        *WaitHandle = Wait ;

	NtSetEvent(StartEvent->Handle, NULL);

        Status = STATUS_SUCCESS ;

        goto cleanup_token;
    }

    // Error path
    // This comes from RtlpFindWaitThread
    InterlockedDecrement(&ThreadCB->NumWaits);

 cleanup_signature:
    CLEAR_SIGNATURE(Wait);

    if (Wait->ActivationContext != INVALID_ACTIVATION_CONTEXT) {
        RtlReleaseActivationContext(Wait->ActivationContext);
    }

 cleanup_waittoken:
    if (Wait->ImpersonationToken) {
        NtClose(Wait->ImpersonationToken);
    }

 cleanup_timer:
    if (Timer) {
        RtlpFreeTPHeap(Timer);
    }
        
 cleanup_waitblock:
    RtlpFreeTPHeap( Wait ) ;

 cleanup_worker:
    RtlpWaitReleaseWorker(Flags);

 cleanup_waitevent:
    RtlpFreeWaitEvent(StartEvent);

    // Common cleanup path
 cleanup_token:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status;
}

NTSTATUS
RtlpDeregisterWait (
    PRTLP_WAIT Wait,
    HANDLE PartialCompletionEvent,
    PULONG RetStatusPtr
    )
/*++

Routine Description:

    This routine is used for deregistering the specified wait.

Arguments:

    Wait - The wait to deregister

Return Value:

--*/
{
    ULONG Status = STATUS_SUCCESS ;
    ULONG DontUse ;
    PULONG RetStatus = RetStatusPtr ? RetStatusPtr : &DontUse;

    CHECK_SIGNATURE(Wait) ;
    SET_DEL_SIGNATURE(Wait) ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Deregistering Wait %p (Handle %p) in thread %x\n",
               Wait->DbgId,
               Wait,
               Wait->WaitHandle,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)) ;
#endif

    // RtlpDeregisterWait can be called on a wait that has not yet been
    // registered. This indicates that someone calls a RtlDeregisterWait
    // inside a WaitThreadCallback for a Wait other than that was fired.
    // Application bug!! We handle it

    if ( ! (Wait->State & STATE_REGISTERED) ) {

        // set state to deleted, so that it does not get registered

        RtlInterlockedSetBitsDiscardReturn(&Wait->State,
                                           STATE_DELETE);

        InterlockedDecrement( &Wait->RefCount );

        if ( PartialCompletionEvent ) {

            NtSetEvent( PartialCompletionEvent, NULL ) ;
        }

        *RetStatus = STATUS_SUCCESS ;
        return STATUS_SUCCESS ;
    }


    // deactivate wait.

    if ( Wait->State & STATE_ACTIVE ) {

        if ( ! NT_SUCCESS( RtlpDeactivateWait ( Wait, TRUE ) ) ) {

            *RetStatus = STATUS_NOT_FOUND ;
            return STATUS_NOT_FOUND ;
        }
    }

    // Deregister wait and set delete bit
    RtlInterlockedClearBitsDiscardReturn(&Wait->State,
                                         STATE_REGISTERED);
    RtlInterlockedSetBitsDiscardReturn(&Wait->State,
                                       STATE_DELETE);

    ASSERT(Wait->ThreadCB->NumRegisteredWaits > 0);
    Wait->ThreadCB->NumRegisteredWaits--;

    // We can no longer guarantee that the wait thread will be around; 
    // clear the wait's ThreadCB to make it obvious if we attempt to
    // make use of it.
    Wait->ThreadCB = NULL;

    // delete wait if RefCount == 0
    if ( InterlockedDecrement (&Wait->RefCount) == 0 ) {

        RtlpDeleteWait ( Wait ) ;

        Status = *RetStatus = STATUS_SUCCESS ;

    } else {

        Status = *RetStatus = STATUS_PENDING ;
    }

    if ( PartialCompletionEvent ) {

        NtSetEvent( PartialCompletionEvent, NULL ) ;
    }

    return Status ;
}

NTSTATUS
RtlDeregisterWaitEx(
    IN HANDLE WaitHandle,
    IN HANDLE Event
    )
/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being
    waited on. Once this call returns, no new Callbacks will be invoked.
    Depending on the value of Event, the call can be blocking or non-blocking.
    Blocking calls MUST NOT be invoked inside the callback routines, except
    when a callback being executed in the Wait thread context deregisters
    its associated Wait (in this case there is no reason for making blocking calls),
    or when a callback queued to a worker thread is deregistering some other wait item
    (be careful of deadlocks here).

Arguments:

    WaitHandle - Handle indentifying the wait.

    Event - Event to wait upon.
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an Event. The function removes the wait handle,
                    but does not wait for all callbacks to complete. The Event is
                    released after all callbacks have completed.
            NULL : The function is non-blocking. The function removes the wait handle,
                    but does not wait for all callbacks to complete.

Return Value:

    STATUS_SUCCESS - The deregistration was successful.
    STATUS_PENDING - Some callback is still pending.

--*/

{
    NTSTATUS Status, StatusAsync = STATUS_SUCCESS ;
    PRTLP_WAIT Wait = (PRTLP_WAIT) WaitHandle ;
    ULONG CurrentThreadId =  HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    PRTLP_EVENT CompletionEvent = NULL ;
    HANDLE ThreadHandle ;
    ULONG NonBlocking = ( Event != (HANDLE) -1 ) ; //The call returns non-blocking
    HANDLE Token;
#if DBG
    ULONG WaitDbgId;
    HANDLE Handle;
#endif

    if (LdrpShutdownInProgress) {
        return STATUS_SUCCESS;
    }

    if (!Wait) {
        return STATUS_INVALID_PARAMETER_1 ;
    }

    Status = RtlpCaptureImpersonation(FALSE, &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    ThreadHandle = Wait->ThreadCB->ThreadHandle ;

    CHECK_DEL_SIGNATURE( Wait );
    SET_DEL_PENDING_SIGNATURE( Wait ) ;

#if DBG1
    Wait->ThreadId2 = CurrentThreadId ;
#endif

    if (Event == (HANDLE)-1) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            Status = STATUS_NO_MEMORY ;
            goto cleanup;

        }
    }


#if DBG
    WaitDbgId = Wait->DbgId;
    Handle = Wait->WaitHandle;

    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d:%d> Wait %p (Handle %p) deregistering by thread:<%x:%x>\n",
               WaitDbgId,
               Wait->RefCount,
               Wait,
               Handle,
               CurrentThreadId,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif


    Wait->CompletionEvent = CompletionEvent
                            ? CompletionEvent->Handle
                            : Event ;

    //
    // RtlDeregisterWaitEx is being called from within the Wait thread callback
    //

    if ( CurrentThreadId == Wait->ThreadCB->ThreadId ) {

        Status = RtlpDeregisterWait ( Wait, NULL, NULL ) ;

        // all callback functions run in the wait thread. So cannot return PENDING

        ASSERT(Status != STATUS_PENDING);
        
    } else {

        PRTLP_EVENT PartialCompletionEvent = NULL ;

        if (NonBlocking) {

            PartialCompletionEvent = RtlpGetWaitEvent () ;

            if (!PartialCompletionEvent) {

                if (CompletionEvent) {
                    RtlpFreeWaitEvent(CompletionEvent);
                }

                Status = STATUS_NO_MEMORY ;
                goto cleanup;
            }
        }

        // Queue an APC to the Wait Thread

        Status = NtQueueApcThread(
                        Wait->ThreadCB->ThreadHandle,
                        (PPS_APC_ROUTINE)RtlpDeregisterWait,
                        (PVOID) Wait,
                        NonBlocking ? PartialCompletionEvent->Handle : NULL ,
                        NonBlocking ? (PVOID)&StatusAsync : NULL
                        );

        if (! NT_SUCCESS(Status)) {

            if (CompletionEvent) RtlpFreeWaitEvent( CompletionEvent ) ;
            if (PartialCompletionEvent) RtlpFreeWaitEvent( PartialCompletionEvent ) ;

            goto cleanup;
        }

        // Block till the wait entry has been deactivated

        if (NonBlocking) {

            Status = RtlpWaitForEvent( PartialCompletionEvent->Handle, ThreadHandle ) ;
        }


        if (PartialCompletionEvent) RtlpFreeWaitEvent( PartialCompletionEvent ) ;
    }

    if ( CompletionEvent ) {

        // wait for Event to be fired. Return if the thread has been killed.

#if DBG
      DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                 RTLP_THREADPOOL_TRACE_MASK,
                 "<%d> Wait %p (Handle %p) deregister waiting ThreadId<%x:%x>\n",
                 WaitDbgId,
                 Wait,
                 Handle,
                 HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                 HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
#endif

        Status = RtlpWaitForEvent( CompletionEvent->Handle, ThreadHandle ) ;

#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "<%d> Wait %p (Handle %p) deregister completed\n",
                   WaitDbgId,
                   Wait,
                   Handle) ;
#endif

        RtlpFreeWaitEvent( CompletionEvent ) ;

        Status = NT_SUCCESS( Status ) ? STATUS_SUCCESS : Status ;
        goto cleanup;

    } else {

        Status = StatusAsync;
    }

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status;
}

NTSTATUS
RtlDeregisterWait(
    IN HANDLE WaitHandle
    )
/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being
    waited on. This routine is non-blocking. Once this call returns, no new
    Callbacks are invoked. However, Callbacks that might already have been queued
    to worker threads are not cancelled.

Arguments:

    WaitHandle - Handle indentifying the wait.

Return Value:

    STATUS_SUCCESS - The deregistration was successful.
    STATUS_PENDING - Some callbacks associated with this Wait, are still executing.
--*/

{
    return RtlDeregisterWaitEx( WaitHandle, NULL ) ;
}

VOID
RtlpDeleteWait (
    PRTLP_WAIT Wait
    )
/*++

Routine Description:

    This routine is used for deleting the specified wait. It can be executed
    outside the context of the wait thread. So structure except the WaitEntry
    can be changed. It also sets the event.

Arguments:

    Wait - The wait to delete

Return Value:

--*/
{
    CHECK_SIGNATURE( Wait ) ;
    CLEAR_SIGNATURE( Wait ) ;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "<%d> Wait %p (Handle %p) deleted in thread:%x\n", Wait->DbgId,
               Wait,
               Wait->WaitHandle,
               HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)) ;
#endif


    if ( Wait->CompletionEvent ) {

        NtSetEvent( Wait->CompletionEvent, NULL ) ;
    }

    RtlpWaitReleaseWorker(Wait->Flags);
    if (Wait->ActivationContext != INVALID_ACTIVATION_CONTEXT)
        RtlReleaseActivationContext(Wait->ActivationContext);

    if (Wait->ImpersonationToken) {
        NtClose(Wait->ImpersonationToken);
    }

    RtlpFreeTPHeap( Wait) ;

    return ;
}

NTSTATUS
RtlpWaitCleanup(
    VOID
    )
{
    PLIST_ENTRY Node;
    HANDLE TmpHandle;
    BOOLEAN Cleanup;

    IS_COMPONENT_INITIALIZED(StartedWaitInitialization,
                             CompletedWaitInitialization,
                             Cleanup ) ;

    if ( Cleanup ) {

        PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;

        ACQUIRE_GLOBAL_WAIT_LOCK() ;

        // Queue an APC to all Wait Threads

        for (Node = WaitThreads.Flink ; Node != &WaitThreads ;
                Node = Node->Flink)
        {

            ThreadCB = CONTAINING_RECORD(Node,
                                RTLP_WAIT_THREAD_CONTROL_BLOCK,
                                WaitThreadsList) ;

            if ( ThreadCB->NumWaits != 0 ) {

                RELEASE_GLOBAL_WAIT_LOCK( ) ;

                return STATUS_UNSUCCESSFUL ;
            }

            RemoveEntryList( &ThreadCB->WaitThreadsList ) ;
            TmpHandle = ThreadCB->ThreadHandle ;

            NtQueueApcThread(
                    ThreadCB->ThreadHandle,
                    (PPS_APC_ROUTINE)RtlpThreadCleanup,
                    NULL,
                    NULL,
                    NULL
                    );

            NtClose( TmpHandle ) ;
        }

        RELEASE_GLOBAL_WAIT_LOCK( ) ;

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\version.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Version.c

Abstract:

    This module implements a function to compare OS versions. Its the basis for
    VerifyVersionInfoW API. The Rtl version can be called from device drivers.

Author:

    Nar Ganapathy     [Narg]    19-Oct-1998

Environment:

    Pure utility routine

Revision History:

--*/

#include <stdio.h>
#include <ntrtlp.h>
#if !defined(NTOS_KERNEL_RUNTIME)
#include <winerror.h>
#endif

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE, RtlGetVersion)
#endif

//
// The following comment explains the old and the new style layouts for the
// condition masks. The condition mask is passed as a parameter to the
// VerifyVersionInfo API. The condition mask encodes conditions like VER_AND,
// VER_OR, VER_EQUAL for various types like VER_PLATFORMID, VER_MINORVERSION
// etc., When the API was originally designed the application used a macro
// called VER_SET_CONDTION which was defined to be  _m_=(_m_|(_c_<<(1<<_t_))).
// where _c_ is the condition and _t_ is the type. This macro is buggy for
// types >= VER_PLATFORMID. Unfortunately a lot of application code already
// uses this buggy macro (notably this terminal server) and have been shipped.
// To fix this bug, a new API VerSetConditionMask is defined which has a new
// bit layout. To provide backwards compatibility, we need to know if a
// specific condition mask is a new style mask (has the new bit layout) or is
// an old style mask. In both bit layouts bit 64 can never be set.
// So the new API sets this bit to indicate that the condition mask is a new
// style condition mask. So the code in this function that extracts the
// condition uses the new bit layout if bit 63 is set and the old layout if
// bit 63 is not set. This should allow applications that was compiled with
// the old macro to work.
//

//
// Use bit 63 to indicate that the new style bit layout is followed.
//
#define NEW_STYLE_BIT_MASK              0x8000000000000000


//
// Condition extractor for the old style mask.
//
#define OLD_CONDITION(_m_,_t_)  (ULONG)((_m_&(0xff<<(1<<_t_)))>>(1<<_t_))

//
// Test to see  if the mask is an old style mask.
//
#define OLD_STYLE_CONDITION_MASK(_m_)  (((_m_) & NEW_STYLE_BIT_MASK)  == 0)

#define RTL_GET_CONDITION(_m_, _t_) \
        (OLD_STYLE_CONDITION_MASK(_m_) ? (OLD_CONDITION(_m_,_t_)) : \
                RtlpVerGetConditionMask((_m_), (_t_)))

#define LEXICAL_COMPARISON        1     /* Do string comparison. Used for minor numbers */
#define MAX_STRING_LENGTH         20    /* Maximum number of digits for sprintf */

ULONG
RtlpVerGetConditionMask(
        ULONGLONG       ConditionMask,
        ULONG   TypeMask
        );


/*++

Routine Description:

    This function retrieves the OS version information. Its the kernel equivalent of
    the GetVersionExW win 32 API.

Arguments:

    lpVersionInformation - Supplies a pointer to the version info structure.
        In the kernel always assume that the structure is of type
        PRTL_OSVERSIONINFOEXW as its not exported to drivers. The signature
        is kept the same as for the user level RtlGetVersion.

Return Value:

    Always succeeds and returns STATUS_SUCCESS.
--*/
#if defined(NTOS_KERNEL_RUNTIME)
NTSTATUS
RtlGetVersion (
    OUT  PRTL_OSVERSIONINFOW lpVersionInformation
    )
{
        NT_PRODUCT_TYPE NtProductType;
    RTL_PAGED_CODE();

    lpVersionInformation->dwMajorVersion = NtMajorVersion;
    lpVersionInformation->dwMinorVersion = NtMinorVersion;
    lpVersionInformation->dwBuildNumber = (USHORT)(NtBuildNumber & 0x3FFF);
    lpVersionInformation->dwPlatformId  = 2; // VER_PLATFORM_WIN32_NT from winbase.h
    if (lpVersionInformation->dwOSVersionInfoSize == sizeof( RTL_OSVERSIONINFOEXW )) {
        ((PRTL_OSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = ((USHORT)CmNtCSDVersion >> 8) & (0xFF);
        ((PRTL_OSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = (USHORT)CmNtCSDVersion & 0xFF;
        ((PRTL_OSVERSIONINFOEXW)lpVersionInformation)->wSuiteMask = (USHORT)(USER_SHARED_DATA->SuiteMask&0xffff);
        ((PRTL_OSVERSIONINFOEXW)lpVersionInformation)->wProductType = (RtlGetNtProductType(&NtProductType) ? NtProductType :0);

        /* Not set as its not needed by VerifyVersionInfoW */
        ((PRTL_OSVERSIONINFOEXW)lpVersionInformation)->wReserved = (UCHAR)0;
    }

    return STATUS_SUCCESS;
}
#else
NTSTATUS
RtlGetVersion(
    OUT  PRTL_OSVERSIONINFOW lpVersionInformation
    )
{
    PPEB Peb;
    NT_PRODUCT_TYPE NtProductType;

    Peb = NtCurrentPeb();
    lpVersionInformation->dwMajorVersion = Peb->OSMajorVersion;
    lpVersionInformation->dwMinorVersion = Peb->OSMinorVersion;
    lpVersionInformation->dwBuildNumber  = Peb->OSBuildNumber;
    lpVersionInformation->dwPlatformId   = Peb->OSPlatformId;
    if (Peb->CSDVersion.Buffer) {
        wcscpy( lpVersionInformation->szCSDVersion, Peb->CSDVersion.Buffer );
    } else {
        lpVersionInformation->szCSDVersion[0] = 0;
    }

    if (lpVersionInformation->dwOSVersionInfoSize == sizeof( OSVERSIONINFOEXW ))
    {
        ((POSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = (Peb->OSCSDVersion >> 8) & 0xFF;
        ((POSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = Peb->OSCSDVersion & 0xFF;
        ((POSVERSIONINFOEXW)lpVersionInformation)->wSuiteMask = (USHORT)(USER_SHARED_DATA->SuiteMask&0xffff);
        ((POSVERSIONINFOEXW)lpVersionInformation)->wProductType = 0;
        if (RtlGetNtProductType( &NtProductType )) {
            ((POSVERSIONINFOEXW)lpVersionInformation)->wProductType = (UCHAR)NtProductType;
            if (NtProductType == VER_NT_WORKSTATION) {
               //
               // For workstation product never return VER_SUITE_TERMINAL
               //
                ((POSVERSIONINFOEXW)lpVersionInformation)->wSuiteMask = ((POSVERSIONINFOEXW)lpVersionInformation)->wSuiteMask & 0xffef;
            }

        }
    }

    return STATUS_SUCCESS;
}
#endif


BOOLEAN
RtlpVerCompare(
    LONG Condition,
    LONG Value1,
    LONG Value2,
    BOOLEAN *Equal,
    int   Flags
    )
{
    char    String1[MAX_STRING_LENGTH];
    char    String2[MAX_STRING_LENGTH];
    LONG    Comparison;

    if (Flags & LEXICAL_COMPARISON) {
        sprintf(String1, "%d", Value1); 
        sprintf(String2, "%d", Value2);
        Comparison = strcmp(String2, String1);
        Value1 = 0;
        Value2 = Comparison;
    }
    *Equal = (Value1 == Value2);
    switch (Condition) {
        case VER_EQUAL:
            return (Value2 == Value1);

        case VER_GREATER:
            return (Value2 > Value1);

        case VER_LESS:
            return (Value2 < Value1);

        case VER_GREATER_EQUAL:
            return (Value2 >= Value1);

        case VER_LESS_EQUAL:
            return (Value2 <= Value1);

        default:
            break;
    }

    return FALSE;
}



NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    )

/*+++
    This function verifies a version condition.  Basically, this
    function lets an app query the system to see if the app is
    running on a specific version combination.


Arguments:

    VersionInfo     - a version structure containing the comparison data
    TypeMask        - a mask comtaining the data types to look at
    ConditionMask   - a mask containing conditionals for doing the comparisons


Return Value:

    STATUS_INVALID_PARAMETER if the parameters are not valid.
    STATUS_REVISION_MISMATCH if the versions don't match.
    STATUS_SUCCESS if the versions match.

--*/

{
    ULONG i;
    OSVERSIONINFOEXW CurrVersion;
    BOOLEAN SuiteFound = FALSE;
    BOOLEAN Equal;
        NTSTATUS Status;
    ULONG   Condition;


    if (TypeMask == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory( &CurrVersion, sizeof(OSVERSIONINFOEXW) );
    CurrVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    Status = RtlGetVersion((PRTL_OSVERSIONINFOW)&CurrVersion);
    if (Status != STATUS_SUCCESS)
                    return Status;

    if ((TypeMask & VER_SUITENAME) && (VersionInfo->wSuiteMask != 0)) {
        for (i=0; i<16; i++) {
            if (VersionInfo->wSuiteMask&(1<<i)) {
                switch (RTL_GET_CONDITION(ConditionMask,VER_SUITENAME)) {
                    case VER_AND:
                        if (!(CurrVersion.wSuiteMask&(1<<i))) {
                            return STATUS_REVISION_MISMATCH;
                        }
                        break;

                    case VER_OR:
                        if (CurrVersion.wSuiteMask&(1<<i)) {
                            SuiteFound = TRUE;
                        }
                        break;

                    default:
                        return STATUS_INVALID_PARAMETER;
                }
            }
        }
        if ((RtlpVerGetConditionMask(ConditionMask,VER_SUITENAME) == VER_OR) && (SuiteFound == FALSE)) {
            return STATUS_REVISION_MISMATCH;
        }
    }

    Equal = TRUE;
    Condition = VER_EQUAL;
    if (TypeMask & VER_MAJORVERSION) {
        Condition = RTL_GET_CONDITION( ConditionMask, VER_MAJORVERSION);
        if (RtlpVerCompare(
                Condition,
                VersionInfo->dwMajorVersion,
                CurrVersion.dwMajorVersion,
                &Equal,
                0
                ) == FALSE)
        {
            if (!Equal) {
                return STATUS_REVISION_MISMATCH;
            }
        }
    }

    if (Equal) {
        ASSERT(Condition);
        if (TypeMask & VER_MINORVERSION) {
            if (Condition == VER_EQUAL) {
                Condition = RTL_GET_CONDITION(ConditionMask, VER_MINORVERSION); 
            }
            if (RtlpVerCompare(
                Condition,
                VersionInfo->dwMinorVersion,
                CurrVersion.dwMinorVersion,
                &Equal,
                LEXICAL_COMPARISON
                ) == FALSE)
            {
                if (!Equal) {
                    return STATUS_REVISION_MISMATCH;
                }
            }
        }

        if (Equal) {
            if (TypeMask & VER_SERVICEPACKMAJOR) {
                if (Condition == VER_EQUAL) {
                    Condition = RTL_GET_CONDITION(ConditionMask, VER_SERVICEPACKMAJOR); 
                }
                if (RtlpVerCompare(
                    Condition,
                    VersionInfo->wServicePackMajor,
                    CurrVersion.wServicePackMajor,
                    &Equal,
                    0
                    ) == FALSE)
                {
                    if (!Equal) {
                        return STATUS_REVISION_MISMATCH;
                    }
                }
            }
            if (Equal) {
                if (TypeMask & VER_SERVICEPACKMINOR) {
                    if (Condition == VER_EQUAL) {
                        Condition = RTL_GET_CONDITION(ConditionMask, VER_SERVICEPACKMINOR); 
                    }
                    if (RtlpVerCompare(
                        Condition,
                        (ULONG)VersionInfo->wServicePackMinor,
                        (ULONG)CurrVersion.wServicePackMinor,
                        &Equal,
                        LEXICAL_COMPARISON
                        ) == FALSE)
                    {
                        return STATUS_REVISION_MISMATCH;
                    }
                }
            }
        }
    }

    if ((TypeMask & VER_BUILDNUMBER) &&
        RtlpVerCompare(
            RTL_GET_CONDITION( ConditionMask, VER_BUILDNUMBER),
            VersionInfo->dwBuildNumber,
            CurrVersion.dwBuildNumber,
            &Equal,
            0
            ) == FALSE)
    {
        return STATUS_REVISION_MISMATCH;
    }

    if ((TypeMask & VER_PLATFORMID) &&
        RtlpVerCompare(
            RTL_GET_CONDITION( ConditionMask, VER_PLATFORMID),
            VersionInfo->dwPlatformId,
            CurrVersion.dwPlatformId,
            &Equal,
            0
            ) == FALSE)
    {
        return STATUS_REVISION_MISMATCH;
    }


    if ((TypeMask & VER_PRODUCT_TYPE) &&
        RtlpVerCompare(
            RTL_GET_CONDITION( ConditionMask, VER_PRODUCT_TYPE),
            VersionInfo->wProductType,
            CurrVersion.wProductType,
            &Equal,
            0
            ) == FALSE)
    {
        return STATUS_REVISION_MISMATCH;
    }

    return STATUS_SUCCESS;
}

ULONG
RtlpVerGetConditionMask(
        ULONGLONG       ConditionMask,
        ULONG   TypeMask
        )
{
        ULONG   NumBitsToShift;
        ULONG   Condition = 0;

        if (!TypeMask) {
                return 0;
        }

        for (NumBitsToShift = 0; TypeMask;  NumBitsToShift++) {
                TypeMask >>= 1;
    }

        Condition |=  (ConditionMask) >> ((NumBitsToShift - 1)
                                                                        * VER_NUM_BITS_PER_CONDITION_MASK);
        Condition &= VER_CONDITION_MASK;
        return Condition;
}


ULONGLONG
VerSetConditionMask(
        ULONGLONG       ConditionMask,
        ULONG   TypeMask,
        UCHAR   Condition
        )
{
        int     NumBitsToShift;

        Condition &= VER_CONDITION_MASK;

        if (!TypeMask) {
                return 0;
    }

        for (NumBitsToShift = 0; TypeMask;  NumBitsToShift++) {
                TypeMask >>= 1;
    }

    //
    // Mark that we are using a new style condition mask
    //
    ConditionMask |=  NEW_STYLE_BIT_MASK;
        ConditionMask |=  (Condition) << ((NumBitsToShift - 1)
                                * VER_NUM_BITS_PER_CONDITION_MASK);

        return ConditionMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\worker.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    worker.c

Abstract:

    This module defines functions for the worker thread pool.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Revision History:

    lokeshs - extended/modified threadpool.

    Rob Earhart (earhart) September 29, 2000
      Split off from threads.c

Environment:

    These routines are statically linked in the caller's executable
    and are callable only from user mode. They make use of Nt system
    services.


--*/

#include <ntos.h>
#include <ntrtl.h>
#include <wow64t.h>
#include "ntrtlp.h"
#include "threads.h"

// Worker Thread Pool
// ------------------
// Clients can submit functions to be executed by a worker thread. Threads are
// created if the work queue exceeds a threshold. Clients can request that the
// function be invoked in the context of a I/O thread. I/O worker threads
// can be used for initiating asynchronous I/O requests. They are not terminated if
// there are pending IO requests. Worker threads terminate if inactivity exceeds a
// threshold.
// Clients can also associate IO completion requests with the IO completion port
// waited upon by the non I/O worker threads. One should not post overlapped IO requests
// in worker threads.

ULONG StartedWorkerInitialization ;     // Used for Worker thread startup synchronization
ULONG CompletedWorkerInitialization ;   // Used to check if Worker thread pool is initialized
ULONG NumFutureWorkItems = 0 ;          // Future work items (timers, waits, &c to exec in workers)
ULONG NumFutureIOWorkItems = 0 ;        // Future IO work items (timers, waits, &c to exec in IO workers)
ULONG NumIOWorkerThreads ;              // Count of IO Worker Threads alive
ULONG NumWorkerThreads ;                // Count of Worker Threads alive
ULONG NumMinWorkerThreads ;             // Min worker threads should be alive: 1 if ioCompletion used, else 0
ULONG NumIOWorkRequests ;               // Count of IO Work Requests pending
ULONG NumLongIOWorkRequests ;           // IO Worker threads executing long worker functions
ULONG NumWorkRequests ;                 // Count of Work Requests pending.
ULONG NumQueuedWorkRequests;            // Count of work requests pending on IO completion
ULONG NumLongWorkRequests ;             // Worker threads executing long worker functions
ULONG NumExecutingWorkerThreads ;       // Worker threads currently executing worker functions
ULONG TotalExecutedWorkRequests ;       // Total worker requests that were picked up
ULONG OldTotalExecutedWorkRequests ;    // Total worker requests since last timeout.
HANDLE WorkerThreadTimerQueue = NULL ;  // Timer queue used by worker threads
HANDLE WorkerThreadTimer = NULL ;       // Timer used by worker threads
RTL_CRITICAL_SECTION WorkerTimerCriticalSection; // Synchronizes access to the worker timer

ULONG LastThreadCreationTickCount ;     // Tick count at which the last thread was created

LIST_ENTRY IOWorkerThreads ;            // List of IOWorkerThreads
PRTLP_IOWORKER_TCB PersistentIOTCB ;    // ptr to TCB of persistest IO worker thread
HANDLE WorkerCompletionPort ;           // Completion port used for queuing tasks to Worker threads

RTL_CRITICAL_SECTION WorkerCriticalSection ;    // Exclusion used by worker threads

NTSTATUS
RtlpStartWorkerThread (
    VOID
    );

VOID
RtlpWorkerThreadCancelTimer(
    VOID
    )
{
    if (! RtlTryEnterCriticalSection(&WorkerTimerCriticalSection)) {
        //
        // Either another thread is setting a timer, or clearing it.
        // Either way, there's no reason for us to clear the timer --
        // return immediately.
        //
        return;
    }

    __try {
        if (WorkerThreadTimer) {
            ASSERT(WorkerThreadTimerQueue);
            
            RtlDeleteTimer(WorkerThreadTimerQueue,
                           WorkerThreadTimer,
                           NULL);
        }
    } __finally {

        WorkerThreadTimer = NULL;

        RtlLeaveCriticalSection(&WorkerTimerCriticalSection);

    }
}

VOID
RtlpWorkerThreadTimerCallback(
    PVOID Context,
    BOOLEAN NotUsed
    )
/*++

Routine Description:

    This routine checks if new worker thread has to be created

Arguments:
    None

Return Value:
    None

--*/
{
    IO_COMPLETION_BASIC_INFORMATION Info ;
    BOOLEAN bCreateThread = FALSE ;
    NTSTATUS Status ;
    ULONG QueueLength, Threshold ;


    Status = NtQueryIoCompletion(
                WorkerCompletionPort,
                IoCompletionBasicInformation,
                &Info,
                sizeof(Info),
                NULL
                ) ;

    if (!NT_SUCCESS(Status))
        return ;

    QueueLength = Info.Depth ;

    if (!QueueLength) {
        OldTotalExecutedWorkRequests = TotalExecutedWorkRequests ;
        return ;
    }


    RtlEnterCriticalSection (&WorkerCriticalSection) ;


    // if there are queued work items and no new work items have been scheduled
    // in the last 30 seconds then create a new thread.
    // this will take care of deadlocks.

    // this will create a problem only if some thread is running for a long time

    if (TotalExecutedWorkRequests == OldTotalExecutedWorkRequests) {

        bCreateThread = TRUE ;
    }


    // if there are a lot of queued work items, then create a new thread
    {
        ULONG NumEffWorkerThreads = NumWorkerThreads > NumLongWorkRequests
                                     ? NumWorkerThreads - NumLongWorkRequests
                                     : 0;
        ULONG ShortWorkRequests ;
        ULONG CapturedNumExecutingWorkerThreads;

        ULONG ThreadCreationDampingTime = NumWorkerThreads < NEW_THREAD_THRESHOLD
                                            ? THREAD_CREATION_DAMPING_TIME1
                                            : (NumWorkerThreads < 30
                                                ? THREAD_CREATION_DAMPING_TIME2
                                                : (NumWorkerThreads << 13)); // *100ms
        
        Threshold = (NumWorkerThreads < MAX_WORKER_THREADS
                        ? (NumEffWorkerThreads < 7
                            ? NumEffWorkerThreads*NumEffWorkerThreads
                            : ((NumEffWorkerThreads<40)
                                ? NEW_THREAD_THRESHOLD * NumEffWorkerThreads
                                : NEW_THREAD_THRESHOLD2 * NumEffWorkerThreads))
                        : 0xffffffff) ;

        CapturedNumExecutingWorkerThreads = NumExecutingWorkerThreads;

        ShortWorkRequests = QueueLength + CapturedNumExecutingWorkerThreads > NumLongWorkRequests
                             ? QueueLength + CapturedNumExecutingWorkerThreads - NumLongWorkRequests
                             : 0;

        if (LastThreadCreationTickCount > NtGetTickCount())
            LastThreadCreationTickCount = NtGetTickCount() ;


        if (ShortWorkRequests  > Threshold
            && (LastThreadCreationTickCount + ThreadCreationDampingTime
                    < NtGetTickCount()))
        {
            bCreateThread = TRUE ;
        }


    }

    if (bCreateThread && NumWorkerThreads<MaxThreads) {

        RtlpStartWorkerThread();
        RtlpWorkerThreadCancelTimer();
    }


    OldTotalExecutedWorkRequests = TotalExecutedWorkRequests ;

    RtlLeaveCriticalSection (&WorkerCriticalSection) ;

}

NTSTATUS
RtlpWorkerThreadSetTimer(
    VOID
    )
{
    NTSTATUS Status;
    HANDLE NewTimerQueue;
    HANDLE NewTimer;

    Status = STATUS_SUCCESS;

    if (! RtlTryEnterCriticalSection(&WorkerTimerCriticalSection)) {
        //
        // Either another thread is setting a timer, or clearing it.
        // Either way, there's no reason for us to set the timer --
        // return immediately.
        //
        return STATUS_SUCCESS;
    }

    __try {

        if (! WorkerThreadTimerQueue) {
            Status = RtlCreateTimerQueue(&NewTimerQueue);
            if (! NT_SUCCESS(Status)) {
                __leave;
            }
            
            WorkerThreadTimerQueue = NewTimerQueue;
        }
        
        ASSERT(WorkerThreadTimerQueue != NULL);

        if (! WorkerThreadTimer) {
            Status = RtlCreateTimer(
                WorkerThreadTimerQueue,
                &NewTimer,
                RtlpWorkerThreadTimerCallback,
                NULL,
                60000,
                60000,
                WT_EXECUTEINTIMERTHREAD
                ) ;
            
            if (! NT_SUCCESS(Status)) {
                __leave;
            }

            WorkerThreadTimer = NewTimer;
        }

    } __finally {

        RtlLeaveCriticalSection(&WorkerTimerCriticalSection);

    }

    return Status;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

LONG
RtlpWorkerThread (
    PVOID Parameter
    )
/*++

Routine Description:

    All non I/O worker threads execute in this routine. Worker thread will try to
    terminate when it has not serviced a request for

        STARTING_WORKER_SLEEP_TIME +
        STARTING_WORKER_SLEEP_TIME << 1 +
        ...
        STARTING_WORKER_SLEEP_TIME << MAX_WORKER_SLEEP_TIME_EXPONENT

Arguments:

    HandlePtr - Pointer to our handle.
                N.B. This is closed by RtlpStartWorkerThread, but
                     we're still responsible for the memory.

Return Value:

--*/
{
    NTSTATUS Status ;
    PVOID WorkerProc ;
    PVOID Context ;
    IO_STATUS_BLOCK IoSb ;
    ULONG SleepTime ;
    LARGE_INTEGER TimeOut ;
    ULONG Terminate ;
    PVOID Overlapped ;

    UNREFERENCED_PARAMETER(Parameter);

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "Starting worker thread\n");
#endif

    // Set default sleep time for 40 seconds.

#define WORKER_IDLE_TIMEOUT     40000    // In Milliseconds

    SleepTime = WORKER_IDLE_TIMEOUT ;

    // Loop servicing I/O completion requests

    for ( ; ; ) {

        TimeOut.QuadPart = Int32x32To64( SleepTime, -10000 ) ;

        Status = NtRemoveIoCompletion(
                    WorkerCompletionPort,
                    (PVOID) &WorkerProc,
                    &Overlapped,
                    &IoSb,
                    &TimeOut
                    ) ;

        if (Status == STATUS_SUCCESS) {


            TotalExecutedWorkRequests ++ ;//interlocked op not req
            InterlockedIncrement(&NumExecutingWorkerThreads) ;

            // Call the work item.
            // If IO APC, context1 contains number of IO bytes transferred, and context2
            // contains the overlapped structure.
            // If (IO)WorkerFunction, context1 contains the actual WorkerFunction to be
            // executed and context2 contains the actual context

            Context = (PVOID) IoSb.Information ;

            RtlpApcCallout(WorkerProc,
                           IoSb.Status,
                           Context,
                           Overlapped);

            SleepTime = WORKER_IDLE_TIMEOUT ;

            InterlockedDecrement(&NumExecutingWorkerThreads) ;

            RtlpWorkerThreadCancelTimer();

        } else if (Status == STATUS_TIMEOUT) {

            // NtRemoveIoCompletion timed out. Check to see if have hit our limit
            // on waiting. If so terminate.

            Terminate = FALSE ;

            RtlEnterCriticalSection (&WorkerCriticalSection) ;

            // The thread terminates if there are > 1 threads and the queue is small
            // OR if there is only 1 thread and there is no request pending

            if (NumWorkerThreads >  1) {

                ULONG NumEffWorkerThreads = NumWorkerThreads > NumLongWorkRequests
                                             ? NumWorkerThreads - NumLongWorkRequests
                                             : 0;

                if (NumEffWorkerThreads<=NumMinWorkerThreads) {

                    Terminate = FALSE ;

                } else {

                    //
                    // have been idle for very long time. terminate irrespective of number of
                    // work items. (This is useful when the set of runnable threads is taking
                    // care of all the work items being queued). dont terminate if
                    // (NumEffWorkerThreads == 1)
                    //

                    if (NumEffWorkerThreads > 1) {
                        Terminate = TRUE ;
                    } else {
                        Terminate = FALSE ;
                    }

                }

            } else {

                if ( NumMinWorkerThreads == 0
                     && NumWorkRequests == 0
                     && NumFutureWorkItems == 0) {

                    Terminate = TRUE ;

                } else {

                    Terminate = FALSE ;

                }

            }

            if (Terminate) {

                THREAD_BASIC_INFORMATION ThreadInfo;
                ULONG IsIoPending ;

                Terminate = FALSE ;

                Status = NtQueryInformationThread( NtCurrentThread(),
                                                   ThreadIsIoPending,
                                                   &IsIoPending,
                                                   sizeof( IsIoPending ),
                                                   NULL
                                                 );
                if (NT_SUCCESS( Status )) {

                    if (! IsIoPending )
                        Terminate = TRUE ;
                }
            }

            if (Terminate) {

                ASSERT(NumWorkerThreads > 0);
                NumWorkerThreads--;

                RtlLeaveCriticalSection (&WorkerCriticalSection) ;

                RtlpExitThreadFunc( 0 );

            } else {

                // This is the condition where a request was queued *after* the
                // thread woke up - ready to terminate because of inactivity. In
                // this case dont terminate - service the completion port.

                RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            }

        } else {

            ASSERTMSG ("NtRemoveIoCompletion failed",
                       (Status != STATUS_SUCCESS) && (Status != STATUS_TIMEOUT)) ;

        }

    }


    return 1 ;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

NTSTATUS
RtlpStartWorkerThread (
    VOID
    )
/*++

Routine Description:

    This routine starts a regular worker thread

Arguments:


Return Value:

    NTSTATUS error codes resulting from attempts to create a thread
    STATUS_SUCCESS

--*/
{
    HANDLE ThreadHandle;
    ULONG CurrentTickCount;
    NTSTATUS Status;

    // Create worker thread

    Status = RtlpStartThreadpoolThread (RtlpWorkerThread,
                                        NULL,
                                        &ThreadHandle);

    if (NT_SUCCESS(Status)) {

#if DBG
        DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                   RTLP_THREADPOOL_TRACE_MASK,
                   "Created worker thread; handle %d (closing)\n",
                   ThreadHandle);
#endif

        // We don't care about worker threads' handles.
        NtClose(ThreadHandle);

        // Update the time at which the current thread was created

        LastThreadCreationTickCount = NtGetTickCount() ;

        // Increment the count of the thread type created

        NumWorkerThreads++;

    } else {

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "Failed to create worker thread; status %p\n",
               Status);
#endif

        // Thread creation failed. If there is even one thread present do not return
        // failure - else queue the request anyway.

        if (NumWorkerThreads <= NumLongWorkRequests) {

            return Status ;
        }

    }

    return STATUS_SUCCESS ;
}

NTSTATUS
RtlpInitializeWorkerThreadPool (
    )
/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS Status = STATUS_SUCCESS ;
    LARGE_INTEGER TimeOut ;
    SYSTEM_BASIC_INFORMATION BasicInfo;

    ASSERT(! RtlIsImpersonating());

    // Initialize the timer component if it hasnt been done already

    if (CompletedTimerInitialization != 1) {

        Status = RtlpInitializeTimerThreadPool () ;

        if ( !NT_SUCCESS(Status) )
            return Status ;

    }


    // In order to avoid an explicit RtlInitialize() function to initialize the thread pool
    // we use StartedInitialization and CompletedInitialization to provide us the necessary
    // synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() fails - but in this case the
    // caller has no choices left.

    if (!InterlockedExchange(&StartedWorkerInitialization, 1L)) {

        if (CompletedWorkerInitialization)
            InterlockedExchange( &CompletedWorkerInitialization, 0 ) ;


        do {

            // Initialize Critical Sections

            Status = RtlInitializeCriticalSection( &WorkerCriticalSection );
            if (!NT_SUCCESS(Status))
                break ;

            Status = RtlInitializeCriticalSection( &WorkerTimerCriticalSection );
            if (! NT_SUCCESS(Status)) {
                RtlDeleteCriticalSection( &WorkerCriticalSection );
                break;
            }

            InitializeListHead (&IOWorkerThreads) ;

            // get number of processors

            Status = NtQuerySystemInformation (
                                SystemBasicInformation,
                                &BasicInfo,
                                sizeof(BasicInfo),
                                NULL
                                ) ;

            if ( !NT_SUCCESS(Status) ) {
                BasicInfo.NumberOfProcessors = 1 ;
            }

            // Create completion port used by worker threads

            Status = NtCreateIoCompletion (
                                &WorkerCompletionPort,
                                IO_COMPLETION_ALL_ACCESS,
                                NULL,
                                BasicInfo.NumberOfProcessors
                                );

            if (!NT_SUCCESS(Status)) {
                RtlDeleteCriticalSection( &WorkerCriticalSection );
                RtlDeleteCriticalSection( &WorkerTimerCriticalSection );
                break;
            }

        } while ( FALSE ) ;

        if (!NT_SUCCESS(Status) ) {

            StartedWorkerInitialization = 0 ;
            InterlockedExchange( &CompletedWorkerInitialization, ~0 ) ;
            return Status ;
        }

        // Signal that initialization has completed

        InterlockedExchange (&CompletedWorkerInitialization, 1L) ;

    } else {

        LARGE_INTEGER Timeout ;

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!*((ULONG volatile *)&CompletedWorkerInitialization)) {

            NtDelayExecution (FALSE, &TimeOut) ;
        }

        if (CompletedWorkerInitialization != 1)
            return STATUS_NO_MEMORY ;

    }

    return NT_SUCCESS(Status)  ? STATUS_SUCCESS : Status ;
}

LONG
RtlpIOWorkerThread (
    PVOID Parameter
    )
/*++

Routine Description:

    All I/O worker threads execute in this routine. All the work requests execute as APCs
    in this thread.

Arguments:

    HandlePtr - Pointer to our handle.

Return Value:

--*/
{
    #define IOWORKER_IDLE_TIMEOUT     40000    // In Milliseconds

    LARGE_INTEGER TimeOut ;
    ULONG SleepTime = IOWORKER_IDLE_TIMEOUT ;
    PRTLP_IOWORKER_TCB ThreadCB ;    // Control Block allocated on the
                                     // heap by the parent thread
    NTSTATUS Status ;
    BOOLEAN Terminate ;

    ASSERT(Parameter != NULL);

    ThreadCB = (PRTLP_IOWORKER_TCB) Parameter;

#if DBG
    DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
               RTLP_THREADPOOL_TRACE_MASK,
               "Starting IO worker thread\n");
#endif

    // Sleep alertably so that all the activity can take place
    // in APCs

    for ( ; ; ) {

        // Set timeout for IdleTimeout

        TimeOut.QuadPart = Int32x32To64( SleepTime, -10000 ) ;


        Status = NtDelayExecution (TRUE, &TimeOut) ;


        // Status is STATUS_SUCCESS only when it has timed out

        if (Status != STATUS_SUCCESS) {
            continue ;
        }


        //
        // idle timeout. check if you can terminate the thread
        //

        Terminate = FALSE ;

        RtlEnterCriticalSection (&WorkerCriticalSection) ;


        // dont terminate if it is a persistent thread

        if (ThreadCB->Flags & WT_EXECUTEINPERSISTENTIOTHREAD) {

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            continue ;
        }


        // The thread terminates if there are > 1 threads and the queue is small
        // OR if there is only 1 thread and there is no request pending

        if (NumIOWorkerThreads >  1) {


            ULONG NumEffIOWorkerThreads = NumIOWorkerThreads > NumLongIOWorkRequests
                                           ? NumIOWorkerThreads - NumLongIOWorkRequests
                                           : 0;
            ULONG Threshold;

            if (NumEffIOWorkerThreads == 0) {

                Terminate = FALSE ;

            } else {

                // Check if we need to shrink worker thread pool

                Threshold = NEW_THREAD_THRESHOLD * (NumEffIOWorkerThreads-1);



                if  (NumIOWorkRequests-NumLongIOWorkRequests < Threshold)  {

                    Terminate = TRUE ;

                } else {

                    Terminate = FALSE ;
                    SleepTime <<= 1 ;
                }
            }

        } else {

            if (NumIOWorkRequests == 0
                && NumFutureIOWorkItems == 0) {

                // delay termination of last thread

                if (SleepTime < 4*IOWORKER_IDLE_TIMEOUT) {

                    SleepTime <<= 1 ;
                    Terminate = FALSE ;

                } else {

                    Terminate = TRUE ;
                }

            } else {

                Terminate = FALSE ;

            }

        }

        //
        // terminate only if no io is pending
        //

        if (Terminate) {

            NTSTATUS xStatus;
            THREAD_BASIC_INFORMATION ThreadInfo;
            ULONG IsIoPending ;

            Terminate = FALSE ;

            xStatus = NtQueryInformationThread( ThreadCB->ThreadHandle,
                                                ThreadIsIoPending,
                                                &IsIoPending,
                                                sizeof( IsIoPending ),
                                                NULL
                                              );
            if (NT_SUCCESS( xStatus )) {

                if (! IsIoPending )
                    Terminate = TRUE ;
            }
        }

        if (Terminate) {

            ASSERT(NumIOWorkerThreads > 0);
            NumIOWorkerThreads--;

            RemoveEntryList (&ThreadCB->List) ;
            NtClose( ThreadCB->ThreadHandle ) ;
            RtlpFreeTPHeap( ThreadCB );

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            RtlpExitThreadFunc( 0 );

        } else {

            // This is the condition where a request was queued *after* the
            // thread woke up - ready to terminate because of inactivity. In
            // this case dont terminate - service the completion port.

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

        }
    }

    return 0 ;  // Keep compiler happy

}

NTSTATUS
RtlpStartIOWorkerThread (
    )
/*++

Routine Description:

    This routine starts an I/O worker thread

    N.B. Callers MUST hold the WorkerCriticalSection.

Arguments:


Return Value:

    NTSTATUS error codes resulting from attempts to create a thread
    STATUS_SUCCESS

--*/
{
    ULONG CurrentTickCount ;
    NTSTATUS Status ;
    PRTLP_IOWORKER_TCB ThreadCB;

    // Create the worker's control block
    ThreadCB = (PRTLP_IOWORKER_TCB) RtlpAllocateTPHeap(sizeof(RTLP_IOWORKER_TCB), 0);
    if (! ThreadCB) {
        return STATUS_NO_MEMORY;
    }

    // Fill in the control block
    ThreadCB->Flags = 0;
    ThreadCB->LongFunctionFlag = FALSE;

    // Create worker thread

    Status = RtlpStartThreadpoolThread (RtlpIOWorkerThread,
                                        ThreadCB,
                                        &ThreadCB->ThreadHandle);

    if (NT_SUCCESS(Status)) {

        // Update the time at which the current thread was created,
        // and insert the ThreadCB into the IO worker thread list.

        LastThreadCreationTickCount = NtGetTickCount() ;
        NumIOWorkerThreads++;
        InsertHeadList(&IOWorkerThreads, &ThreadCB->List);

    } else {

        // Thread creation failed.

        RtlpFreeTPHeap(ThreadCB);

        // If there is even one thread present do not return
        // failure since we can still service the work request.

        if (NumIOWorkerThreads <= NumLongIOWorkRequests) {

            return Status ;

        }
    }

    return STATUS_SUCCESS ;
}

VOID
RtlpExecuteLongIOWorkItem (
    PVOID WorkEntryPtr,
    PVOID Context,
    PVOID ThreadCB
    )
/*++

Routine Description:

    Executes an IO Work function. RUNs in a APC in the IO Worker thread.

Arguments:

    WorkEntryPtr - Work entry to run

    Context - Context for the work entry

    ThreadCB - The thread running this APC

Return Value:

    None.

--*/
{
    PRTLP_WORK WorkEntry = (PRTLP_WORK) WorkEntryPtr;

    RtlpWorkerCallout(WorkEntry->Function,
                      Context,
                      WorkEntry->ActivationContext,
                      WorkEntry->ImpersonationToken);

    ((PRTLP_IOWORKER_TCB)ThreadCB)->LongFunctionFlag = FALSE ;

    RtlEnterCriticalSection(&WorkerCriticalSection);

    // Decrement pending IO requests count

    NumIOWorkRequests--;

    // decrement pending long funcitons

    NumLongIOWorkRequests--;

    RtlLeaveCriticalSection(&WorkerCriticalSection);

    if (WorkEntry->ActivationContext != INVALID_ACTIVATION_CONTEXT) {
        RtlReleaseActivationContext(WorkEntry->ActivationContext);
    }

    if (WorkEntry->ImpersonationToken) {
        NtClose(WorkEntry->ImpersonationToken);
    }

    RtlpFreeTPHeap(WorkEntry);
}

VOID
RtlpExecuteIOWorkItem (
    PVOID WorkEntryPtr,
    PVOID Context,
    PVOID Parameter
    )
/*++

Routine Description:

    Executes an IO Work function. RUNs in a APC in the IO Worker thread.

Arguments:

    WorkEntryPtr - Work entry to run

    Context - Context for the work entry

    Parameter - Argument is not used in this function.

Return Value:


--*/
{
    PRTLP_WORK WorkEntry = (PRTLP_WORK) WorkEntryPtr;

    UNREFERENCED_PARAMETER(Parameter);

    RtlpWorkerCallout(WorkEntry->Function,
                      Context,
                      WorkEntry->ActivationContext,
                      WorkEntry->ImpersonationToken);

    RtlEnterCriticalSection(&WorkerCriticalSection);

    // Decrement pending IO requests count

    NumIOWorkRequests--;

    RtlLeaveCriticalSection(&WorkerCriticalSection);

    if (WorkEntry->ActivationContext != INVALID_ACTIVATION_CONTEXT) {
        RtlReleaseActivationContext(WorkEntry->ActivationContext);
    }

    if (WorkEntry->ImpersonationToken) {
        NtClose(WorkEntry->ImpersonationToken);
    }

    RtlpFreeTPHeap(WorkEntry);
}

NTSTATUS
RtlpQueueIOWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags,
    HANDLE Token
    )

/*++

Routine Description:

    This routine queues up the request to be executed in an IO worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

    Flags - Flags passed to RtlQueueWorkItem

    Token - Impersonation token to use

Return Value:

--*/

{
    NTSTATUS Status ;
    PRTLP_IOWORKER_TCB TCB ;
    BOOLEAN LongFunction = (Flags & WT_EXECUTELONGFUNCTION) ? TRUE : FALSE ;
    PLIST_ENTRY  ple ;
    PRTLP_WORK WorkEntry ;

    WorkEntry = (PRTLP_WORK) RtlpAllocateTPHeap(sizeof(RTLP_WORK),
                                                HEAP_ZERO_MEMORY);

    if (! WorkEntry) {
        return STATUS_NO_MEMORY;
    }

    WorkEntry->Function = Function;
    WorkEntry->Flags = Flags;

    Status = RtlpThreadPoolGetActiveActivationContext(&WorkEntry->ActivationContext);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SXS_THREAD_QUERIES_DISABLED) {
            WorkEntry->ActivationContext = INVALID_ACTIVATION_CONTEXT;
            Status = STATUS_SUCCESS;
        } else {
            goto cleanup_workentry;
        }
    }

    if (Token) {
        Status = NtDuplicateToken(Token,
                                  TOKEN_IMPERSONATE,
                                  NULL,
                                  FALSE,
                                  TokenImpersonation,
                                  &WorkEntry->ImpersonationToken);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_actctx;
        }
    } else {
        WorkEntry->ImpersonationToken = NULL;
    }

    if (Flags & WT_EXECUTEINPERSISTENTIOTHREAD) {

        if (!PersistentIOTCB) {
            for (ple=IOWorkerThreads.Flink;  ple!=&IOWorkerThreads;  ple=ple->Flink) {
                TCB = CONTAINING_RECORD (ple, RTLP_IOWORKER_TCB, List) ;
                if (! TCB->LongFunctionFlag)
                    break;
            }

            if (ple == &IOWorkerThreads) {
                Status = STATUS_NO_MEMORY;
                goto cleanup_token;
            }


            PersistentIOTCB = TCB ;
            TCB->Flags |= WT_EXECUTEINPERSISTENTIOTHREAD ;

        } else {
            TCB = PersistentIOTCB ;
        }

    } else {
        for (ple=IOWorkerThreads.Flink;  ple!=&IOWorkerThreads;  ple=ple->Flink) {

            TCB = CONTAINING_RECORD (ple, RTLP_IOWORKER_TCB, List) ;

            // do not queue to the thread if it is executing a long function, or
            // if you are queueing a long function and the thread is a persistent thread

            if (! TCB->LongFunctionFlag
                && (! ((TCB->Flags&WT_EXECUTEINPERSISTENTIOTHREAD)
                        && (Flags&WT_EXECUTELONGFUNCTION)))) {
                break ;
            }

        }

        if ((ple == &IOWorkerThreads) && (NumIOWorkerThreads<1)) {

#if DBG
            DbgPrintEx(DPFLTR_RTLTHREADPOOL_ID,
                       RTLP_THREADPOOL_WARNING_MASK,
                       "Out of memory. "
                       "Could not execute IOWorkItem(%x)\n", (ULONG_PTR)Function);
#endif

            Status = STATUS_NO_MEMORY;
            goto cleanup_token;
        }
        else {
            ple = IOWorkerThreads.Flink;
            TCB = CONTAINING_RECORD (ple, RTLP_IOWORKER_TCB, List) ;

            // treat it as a short function so that counters work fine.

            LongFunction = FALSE;
        }

        // In order to implement "fair" assignment of work items between IO worker threads
        // each time remove the entry and reinsert at back.

        RemoveEntryList (&TCB->List) ;
        InsertTailList (&IOWorkerThreads, &TCB->List) ;
    }


    // Increment the outstanding work request counter

    NumIOWorkRequests++;
    if (LongFunction) {
        NumLongIOWorkRequests++;
        TCB->LongFunctionFlag = TRUE ;
    }

    // Queue an APC to the IoWorker Thread

    Status = NtQueueApcThread(
                    TCB->ThreadHandle,
                    LongFunction? (PPS_APC_ROUTINE)RtlpExecuteLongIOWorkItem:
                                  (PPS_APC_ROUTINE)RtlpExecuteIOWorkItem,
                    (PVOID)WorkEntry,
                    Context,
                    TCB
                    );

    if (! NT_SUCCESS( Status ) ) {
        goto cleanup_counters;
    }

    return STATUS_SUCCESS;

 cleanup_counters:
    NumIOWorkRequests--;
    if (LongFunction)
        NumLongIOWorkRequests--;

 cleanup_token:
    if (WorkEntry->ImpersonationToken) {
        NtClose(WorkEntry->ImpersonationToken);
    }

 cleanup_actctx:
    if (WorkEntry->ActivationContext != INVALID_ACTIVATION_CONTEXT) {
        RtlReleaseActivationContext(WorkEntry->ActivationContext);
    }

 cleanup_workentry:
    RtlpFreeTPHeap(WorkEntry);

    return Status;
}

NTSTATUS
RtlSetIoCompletionCallback (
    IN  HANDLE  FileHandle,
    IN  APC_CALLBACK_FUNCTION  CompletionProc,
    IN  ULONG Flags
    )

/*++

Routine Description:

    This routine binds an Handle and an associated callback function to the
    IoCompletionPort which queues work items to worker threads.

Arguments:

    Handle - handle to be bound to the IO completion port

    CompletionProc - callback function to be executed when an IO request
        pending on the IO handle completes.

    Flags - Reserved. pass 0.

--*/

{
    IO_STATUS_BLOCK IoSb ;
    FILE_COMPLETION_INFORMATION CompletionInfo ;
    NTSTATUS Status;
    HANDLE Token = NULL;

    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    if (Flags) {
        return STATUS_INVALID_PARAMETER_3;
    }

    Status = RtlpCaptureImpersonation(FALSE, &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    // Make sure that the worker thread pool is initialized as the file handle
    // is bound to IO completion port.

    if (CompletedWorkerInitialization != 1) {

        Status = RtlpInitializeWorkerThreadPool () ;

        if (! NT_SUCCESS(Status) ) {
            goto cleanup;
        }

    }


    //
    // from now on NumMinWorkerThreads should be 1. If there is only 1 worker thread
    // create a new one.
    //

    if ( NumMinWorkerThreads == 0 ) {

        // Take lock for the global worker thread pool

        RtlEnterCriticalSection (&WorkerCriticalSection) ;

        if ((NumWorkerThreads-NumLongWorkRequests) == 0) {

            Status = RtlpStartWorkerThread () ;

            if ( ! NT_SUCCESS(Status) ) {

                RtlLeaveCriticalSection (&WorkerCriticalSection) ;
                goto cleanup;
            }
        }

        // from now on, there will be at least 1 worker thread
        NumMinWorkerThreads = 1 ;

        RtlLeaveCriticalSection (&WorkerCriticalSection) ;

    }

    // bind to IoCompletionPort, which queues work items to worker threads

    CompletionInfo.Port = WorkerCompletionPort ;
    CompletionInfo.Key = (PVOID) CompletionProc ;

    Status = NtSetInformationFile (
                        FileHandle,
                        &IoSb, //not initialized
                        &CompletionInfo,
                        sizeof(CompletionInfo),
                        FileCompletionInformation //enum flag
                        ) ;

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status ;
}

VOID
RtlpExecuteWorkerRequest (
    NTSTATUS StatusIn, //not  used
    PVOID Context,
    PVOID WorkContext
    )
/*++

Routine Description:

    This routine executes a work item.

Arguments:

    Context - contains context to be passed to the callback function.

    WorkContext - contains callback function ptr and flags

Return Value:

Notes:
    This function executes in a worker thread or a timer thread if
    WT_EXECUTEINTIMERTHREAD flag is set.

--*/

{
    PRTLP_WORK WorkEntry = (PRTLP_WORK) WorkContext;
    NTSTATUS Status;

    if (! (WorkEntry->Flags & WT_EXECUTEINPERSISTENTTHREAD)
        && InterlockedDecrement(&NumQueuedWorkRequests)
        && NumExecutingWorkerThreads == NumWorkerThreads) {

        RtlpWorkerThreadSetTimer();

    }

    RtlpWorkerCallout(WorkEntry->Function,
                      Context,
                      WorkEntry->ActivationContext,
                      WorkEntry->ImpersonationToken);

    RtlEnterCriticalSection(&WorkerCriticalSection);
    NumWorkRequests--;
    if (WorkEntry->Flags & WT_EXECUTELONGFUNCTION) {
        NumLongWorkRequests--;
    }
    RtlLeaveCriticalSection(&WorkerCriticalSection);

    if (WorkEntry->ActivationContext != INVALID_ACTIVATION_CONTEXT)
        RtlReleaseActivationContext(WorkEntry->ActivationContext);

    if (WorkEntry->ImpersonationToken) {
        NtClose(WorkEntry->ImpersonationToken);
    }

    RtlpFreeTPHeap( WorkEntry ) ;
}

NTSTATUS
RtlpQueueWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags,
    HANDLE Token
    )
/*++

Routine Description:

    This routine queues up the request to be executed in a worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

    Flags - Flags passed to RtlQueueWorkItem

    Token - Impersonation token to use

Return Value:

--*/

{
    NTSTATUS Status ;
    PRTLP_WORK WorkEntry ;

    WorkEntry = (PRTLP_WORK) RtlpAllocateTPHeap ( sizeof (RTLP_WORK),
                                                  HEAP_ZERO_MEMORY) ;

    if (! WorkEntry) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlpThreadPoolGetActiveActivationContext(&WorkEntry->ActivationContext);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SXS_THREAD_QUERIES_DISABLED) {
            WorkEntry->ActivationContext = INVALID_ACTIVATION_CONTEXT;
            Status = STATUS_SUCCESS;
        } else {
            goto cleanup_workentry;
        }
    }

    if (Token) {
        Status = NtDuplicateToken(Token,
                                  TOKEN_IMPERSONATE,
                                  NULL,
                                  FALSE,
                                  TokenImpersonation,
                                  &WorkEntry->ImpersonationToken);
        if (! NT_SUCCESS(Status)) {
            goto cleanup_actctx;
        }
    } else {
        WorkEntry->ImpersonationToken = NULL;
    }

    // Increment the outstanding work request counter

    NumWorkRequests++;
    if (Flags & WT_EXECUTELONGFUNCTION) {
        NumLongWorkRequests++;
    }

    WorkEntry->Function = Function ;
    WorkEntry->Flags = Flags ;

    if (Flags & WT_EXECUTEINPERSISTENTTHREAD) {

        // Queue APC to timer thread

        Status = NtQueueApcThread(
                        TimerThreadHandle,
                        (PPS_APC_ROUTINE)RtlpExecuteWorkerRequest,
                        (PVOID) STATUS_SUCCESS,
                        (PVOID) Context,
                        (PVOID) WorkEntry
                        ) ;

    } else {

        InterlockedIncrement(&NumQueuedWorkRequests);

        Status = NtSetIoCompletion (
                    WorkerCompletionPort,
                    RtlpExecuteWorkerRequest,
                    (PVOID) WorkEntry,
                    STATUS_SUCCESS,
                    (ULONG_PTR)Context
                    );
        if (! NT_SUCCESS(Status)) {
            InterlockedDecrement(&NumQueuedWorkRequests);
        } else {
            if (NumExecutingWorkerThreads == NumWorkerThreads) {
                RtlpWorkerThreadSetTimer();
            }
        }
    }

    if ( ! NT_SUCCESS(Status) ) {
        goto cleanup_counters;
    }

    return STATUS_SUCCESS;

 cleanup_counters:
    NumWorkRequests--;
    if (Flags & WT_EXECUTELONGFUNCTION) {
        NumLongWorkRequests--;
    }

    if (WorkEntry->ImpersonationToken) {
        NtClose(WorkEntry->ImpersonationToken);
    }

 cleanup_actctx:
    if (WorkEntry->ActivationContext != INVALID_ACTIVATION_CONTEXT) {
        RtlReleaseActivationContext(WorkEntry->ActivationContext);
    }

 cleanup_workentry:
    RtlpFreeTPHeap( WorkEntry ) ;
    
    return Status;
}

NTSTATUS
RtlQueueWorkItem(
    IN  WORKERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Flags
    )

/*++

Routine Description:

    This routine queues up the request to be executed in a worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

    Flags - Can be:

            WT_EXECUTEINIOTHREAD - Specifies that the WorkerProc should be invoked
            by a thread that is never destroyed when there are pending IO requests.
            This can be used by threads that invoke I/O and/or schedule APCs.

            The below flag can also be set:
            WT_EXECUTELONGFUNCTION - Specifies that the function might block for a
            long duration.

Return Value:

    STATUS_SUCCESS - Queued successfully.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the
        requested operation.

--*/

{
    ULONG Threshold ;
    ULONG CurrentTickCount ;
    NTSTATUS Status = STATUS_SUCCESS ;
    HANDLE Token = NULL;
    HANDLE RequestToken;
    
    if (LdrpShutdownInProgress) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = RtlpCaptureImpersonation(Flags & WT_TRANSFER_IMPERSONATION,
                                      &Token);
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    if (Flags & WT_TRANSFER_IMPERSONATION) {
        RequestToken = Token;
    } else {
        RequestToken = NULL;
    }

    // Make sure the worker thread pool is initialized

    if (CompletedWorkerInitialization != 1) {

        Status = RtlpInitializeWorkerThreadPool () ;

        if (! NT_SUCCESS(Status) ) {
            goto cleanup;
        }
    }


    // Take lock for the global worker thread pool

    RtlEnterCriticalSection (&WorkerCriticalSection) ;

    if (Flags&0xffff0000) {
        MaxThreads = (Flags & 0xffff0000)>>16;
    }

    if (NEEDS_IO_THREAD(Flags)) {

        //
        // execute in IO Worker thread
        //

        ULONG NumEffIOWorkerThreads = NumIOWorkerThreads > NumLongIOWorkRequests
                                       ? NumIOWorkerThreads - NumLongIOWorkRequests
                                       : 0;
        
        ULONG ThreadCreationDampingTime = NumIOWorkerThreads < NEW_THREAD_THRESHOLD
                                            ? THREAD_CREATION_DAMPING_TIME1
                                            : THREAD_CREATION_DAMPING_TIME2 ;

        if (NumEffIOWorkerThreads && PersistentIOTCB && (Flags&WT_EXECUTELONGFUNCTION))
            NumEffIOWorkerThreads -- ;


            // Check if we need to grow I/O worker thread pool

        Threshold = (NumEffIOWorkerThreads < MAX_WORKER_THREADS
                         ? NEW_THREAD_THRESHOLD * NumEffIOWorkerThreads
                         : 0xffffffff) ;

        if (LastThreadCreationTickCount > NtGetTickCount())
            LastThreadCreationTickCount = NtGetTickCount() ;

        if (NumEffIOWorkerThreads == 0
            || ((NumIOWorkRequests - NumLongIOWorkRequests > Threshold)
                && (LastThreadCreationTickCount + ThreadCreationDampingTime
                    < NtGetTickCount()))) {

            // Grow the IO worker thread pool

            Status = RtlpStartIOWorkerThread () ;

        }

        if (NT_SUCCESS(Status)) {

            // Queue the work request

            Status = RtlpQueueIOWorkerRequest(Function,
                                              Context,
                                              Flags,
                                              RequestToken);
        }


    } else {

        //
        // execute in regular worker thread
        //

        ULONG NumEffWorkerThreads = NumWorkerThreads > NumLongWorkRequests
                                     ? NumWorkerThreads - NumLongWorkRequests
                                     : 0;
        ULONG ThreadCreationDampingTime = NumWorkerThreads < NEW_THREAD_THRESHOLD
                                            ? THREAD_CREATION_DAMPING_TIME1
                                            : (NumWorkerThreads < 30
                                                ? THREAD_CREATION_DAMPING_TIME2
                                                : NumWorkerThreads << 13);

        // if io completion set, then have 1 more thread

        if (NumMinWorkerThreads && NumEffWorkerThreads)
            NumEffWorkerThreads -- ;


        // Check if we need to grow worker thread pool

        Threshold = (NumWorkerThreads < MAX_WORKER_THREADS
                     ? (NumEffWorkerThreads < 7
                        ? NumEffWorkerThreads*NumEffWorkerThreads
                        : ((NumEffWorkerThreads<40)
                          ? NEW_THREAD_THRESHOLD * NumEffWorkerThreads 
                          : NEW_THREAD_THRESHOLD2 * NumEffWorkerThreads))
                      : 0xffffffff) ;

        if (LastThreadCreationTickCount > NtGetTickCount())
            LastThreadCreationTickCount = NtGetTickCount() ;

        if (NumEffWorkerThreads == 0 ||
            ( (NumWorkRequests - NumLongWorkRequests >= Threshold)
              && (LastThreadCreationTickCount + ThreadCreationDampingTime
                  < NtGetTickCount())))
            {
                // Grow the worker thread pool
                if (NumWorkerThreads<MaxThreads) {
                    
                    Status = RtlpStartWorkerThread () ;

                }
            }

        // Queue the work request

        if (NT_SUCCESS(Status)) {

            Status = RtlpQueueWorkerRequest(Function,
                                            Context,
                                            Flags, 
                                            RequestToken);
        }
    }

    // Release lock on the worker thread pool

    RtlLeaveCriticalSection (&WorkerCriticalSection) ;

 cleanup:
    if (Token) {
        RtlpRestartImpersonation(Token);
        NtClose(Token);
    }

    return Status ;
}

NTSTATUS
RtlpWorkerCleanup(
    VOID
    )
{
    PLIST_ENTRY Node;
    ULONG i;
    HANDLE TmpHandle;
    BOOLEAN Cleanup;

        IS_COMPONENT_INITIALIZED( StartedWorkerInitialization,
                            CompletedWorkerInitialization,
                            Cleanup ) ;

    if ( Cleanup ) {

        RtlEnterCriticalSection (&WorkerCriticalSection) ;

        if ( (NumWorkRequests != 0) || (NumIOWorkRequests != 0) ) {

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            return STATUS_UNSUCCESSFUL ;
        }

        // queue a cleanup for each worker thread

        for (i = 0 ;  i < NumWorkerThreads ; i ++ ) {

            NtSetIoCompletion (
                    WorkerCompletionPort,
                    RtlpThreadCleanup,
                    NULL,
                    STATUS_SUCCESS,
                    0
                    );
        }

        // queue an apc to cleanup all IO worker threads

        for (Node = IOWorkerThreads.Flink ; Node != &IOWorkerThreads ;
                Node = Node->Flink )
        {
            PRTLP_IOWORKER_TCB ThreadCB ;

            ThreadCB = CONTAINING_RECORD (Node, RTLP_IOWORKER_TCB, List) ;
            RemoveEntryList( &ThreadCB->List) ;
            TmpHandle = ThreadCB->ThreadHandle ;

            NtQueueApcThread(
                   ThreadCB->ThreadHandle,
                   (PPS_APC_ROUTINE)RtlpThreadCleanup,
                   NULL,
                   NULL,
                   NULL
                   );

            NtClose( TmpHandle ) ;
        }

        NumWorkerThreads = NumIOWorkerThreads = 0 ;

        RtlLeaveCriticalSection (&WorkerCriticalSection) ;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpThreadPoolGetActiveActivationContext(
    PACTIVATION_CONTEXT* ActivationContext
    )
{
    ACTIVATION_CONTEXT_BASIC_INFORMATION ActivationContextInfo = {0};
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(ActivationContext != NULL);
    *ActivationContext = NULL;

    Status =
        RtlQueryInformationActivationContext(
            RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
            NULL,
            0,
            ActivationContextBasicInformation,
            &ActivationContextInfo,
            sizeof(ActivationContextInfo),
            NULL);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    if ((ActivationContextInfo.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) != 0) {
        RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);
        ActivationContextInfo.ActivationContext = NULL;
        // fall through
    }
    *ActivationContext = ActivationContextInfo.ActivationContext;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpAcquireWorker(ULONG Flags)
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (CompletedWorkerInitialization != 1) {
        Status = RtlpInitializeWorkerThreadPool () ;

        if (! NT_SUCCESS(Status) )
            return Status ;
    }

    if (NEEDS_IO_THREAD(Flags)) {
        RtlEnterCriticalSection(&WorkerCriticalSection);
        InterlockedIncrement(&NumFutureIOWorkItems);
        if (NumIOWorkerThreads == 0) {
            Status = RtlpStartIOWorkerThread();
        }
        RtlLeaveCriticalSection(&WorkerCriticalSection);
    } else {
        RtlEnterCriticalSection(&WorkerCriticalSection);
        InterlockedIncrement(&NumFutureWorkItems);
        if (NumWorkerThreads == 0) {
            Status = RtlpStartWorkerThread();
        }
        RtlLeaveCriticalSection(&WorkerCriticalSection);
    }

    return Status;
}

VOID
RtlpReleaseWorker(ULONG Flags)
{
    if (NEEDS_IO_THREAD(Flags)) {
        ASSERT(NumFutureIOWorkItems > 0);
        InterlockedDecrement(&NumFutureIOWorkItems);
    } else {
        ASSERT(NumFutureWorkItems > 0);
        InterlockedDecrement(&NumFutureWorkItems);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\xprs.h ===
#ifndef _XPRS_H_
#define _XPRS_H_

/* -------------------------------------------------------------------- */
/*                                                                      */
/*               Copyright (c) 1991-1999 by Andrew Kadatch              */
/*                                                                      */
/* -------------------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "xpress.h"

#ifdef _MSC_VER
#pragma code_seg ("PAGELK")
#pragma optimize ("tgaw", on)
#endif



/* ------------------------ Configuration ----------------------------- */
/*                          -------------                               */

#ifndef CODING_ALG
#define CODING_ALG      1
#endif

#define CODING_DIRECT2  (1 << 1)
#define CODING_DIRECT   (1 << 2)
#define CODING_BY_BIT   (1 << 3)
#define CODING_HUFF_LEN (1 << 4)
#define CODING_HUFF_PTR (1 << 5)
#define CODING_HUFF_ALL (1 << 6)

#define CODING          (1 << CODING_ALG)

#define SUPPORT_CRC     0

#define BUFF_SIZE_LOG    XPRESS_MAX_BLOCK_LOG
#define BUFF_SIZE        (1<<BUFF_SIZE_LOG)

#if 1
#define MAX_OFFSET      (BUFF_SIZE_LOG > 16 ? 16 : BUFF_SIZE_LOG)
#else
#define MAX_OFFSET      13
#endif

#if CODING == CODING_DIRECT2 && MAX_OFFSET > 13
#undef MAX_OFFSET
#define MAX_OFFSET 13
#define DIRECT2_LEN_LOG (16 - MAX_OFFSET)
#define DIRECT2_MAX_LEN ((1 << DIRECT2_LEN_LOG) - 1)
#endif

#if BUFF_SIZE < XPRESS_MAX_BLOCK
#error BUFF_SIZE should not be less than XPRESS_MAX_BLOCK
#endif

#if CODING == CODING_HUFF_LEN
#define MAX_LENGTH      32
#define HUFF_SIZE       (MAX_LENGTH * 2)
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#if (256 / MAX_OFFSET) >= 32
#define MAX_LENGTH_LOG  5
#else
#define MAX_LENGTH_LOG  4
#endif
#define MAX_LENGTH      (1 << MAX_LENGTH_LOG)
#if CODING == CODING_HUFF_PTR
#define HUFF_SIZE       ((MAX_LENGTH * MAX_OFFSET + 1) & ~1)
#elif CODING == CODING_HUFF_ALL
#define HUFF_SIZE       (256 + ((MAX_LENGTH * MAX_OFFSET + 1) & ~1))
#endif
#endif

#define MIN_MATCH       3       /* min acceptable match length  */

#if CODING == CODING_HUFF_LEN
#define DECODE_BITS     8
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#define DECODE_BITS     10
#endif


/* ---------------------- Useful types ------------------------ */
/*                        ------------                          */

#define uchar unsigned char     /* useful types */
#define schar signed char

#ifndef __alpha
#define __unaligned
#endif

#define int4 int                /* any long enough integral type            */
#define int2 short              /* assert (2*sizeof(int2) == sizeof (int4)) */
#define xint int                /* any int type >= 32 bits && >= sizeof (bitmask4) */
#define int32 int               /* 32 bit type */
#define int16 short             /* 16 bit type */


#if defined (_M_IX86) && !defined (i386)
#define i386 1          // ifdef i386 asm code will be used for some encodings
#endif

#define tag_t    int32

#ifdef i386
#define bitmask4 int32  // must be 32 bit for i386
#define bitmask2 int16
#else
#define bitmask4 int4   // not important otherwise; shall not exceed xint
#define bitmask2 int2
#endif


#define uint4 unsigned int4
#define uint2 unsigned int2
#define uxint unsigned xint
#define uint32 unsigned int32
#define uint16 unsigned int16
#define utag_t unsigned tag_t
#define ubitmask4 unsigned bitmask4
#define ubitmask2 unsigned bitmask2

#ifdef _MSC_VER
#if _MSC_VER >= 1200
#define INLINE  __forceinline
#else
#define INLINE __inline
#endif
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4711)   /* function XXX selected for automatic inline expansion */
#pragma warning(disable:4710)   /* function XXX not expanded */
#pragma warning(disable:4100)   /* unreferenced formal paramter */
#pragma warning(disable:4068)   /* bogus "unknown pragma" */
#endif

#ifndef DEBUG
#define DEBUG 0
#endif

#if !defined (INLINE) || DEBUG
#undef  INLINE
#define INLINE static
#endif

#if !DEBUG
#undef assert
#define assert(x)
#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)
#define MIN_SIZE0       8
#elif CODING == CODING_BY_BIT
#define MIN_SIZE0       7
#elif CODING == CODING_HUFF_LEN
#define MIN_SIZE0       44
#elif CODING == CODING_HUFF_PTR
#define MIN_SIZE0       139
#elif CODING == CODING_HUFF_ALL
#define MIN_SIZE0       261
#else
#error wrong CODING
#endif

#define MIN_SIZE        (MIN_SIZE0 + CRC_STAMP_SIZE)


#define CRC32_FIRST     0
#if SUPPORT_CRC
#define CRC_STAMP_SIZE  sizeof (uint32)
#else
#define CRC_STAMP_SIZE  0
#endif

#if DEBUG
extern long xxx[];
#endif


#endif /* _XPRS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\xdecode.c ===
#include "xprs.h"

#define ALLOCATE_ON_STACK       1

#define MAGIC_DECODE 0x35DEC0DE

typedef struct
{
  struct
  {
    uchar *end, *beg, *careful, *stop, *last;
  } dst;
  struct
  {
    const uchar *end, *beg, *careful, *end_1, *end_tag, *end_bitmask2, *last;
  }
  src;
  int result;
  int eof;
  int magic;
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uint16 table[(1 << DECODE_BITS) + (HUFF_SIZE << 1)];
#endif
} decode_info;

#if CODING == CODING_BY_BIT
static int bit_to_len_initialized = 0;
static uchar bit_to_len1[1 << (9 - MIN_MATCH)];
static uchar bit_to_len2[1 << (9 - MIN_MATCH)];
static void bit_to_len_init (void)
{
  int i, k;
  if (bit_to_len_initialized) return;
  bit_to_len1[0] = 0;
  bit_to_len2[0] = 9 - MIN_MATCH;
  for (k = 1, i = 1 << (8 - MIN_MATCH); i != 0; i >>= 1, ++k)
  {
    memset (bit_to_len1 + i, k, i);
    memset (bit_to_len2 + i, k - 1, i);
  }
  bit_to_len_initialized = 1;
}
#endif

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)


static int huffman_decode_create (uint16 *table, const uchar *length)
{
  xint i, j, k, last, freq[16], sum[16];

  /* calculate number of codewords                                      */
  memset (freq, 0, sizeof (freq));
  i = HUFF_SIZE >> 1;
  do
  {
    k = length[--i];
    ++freq[k & 0xf];
    ++freq[k >> 4];
  }
  while (i != 0);

  /* handle special case(s) -- 0 and 1 symbols in alphabet              */
  if (freq[0] == HUFF_SIZE)
    goto ok;
  if (freq[0] == HUFF_SIZE - 1)
    goto bad;
#if 0
  {

    if (freq[1] != 1)
      goto bad;
    i = -1; do ++i; while (length[i] == 0);
    k = i << 1;
    if (length[i] != 1) ++k;
    i = 1 << DECODE_BITS;
    do
      *table++ = (uint16) k;
    while (--i > 0);
    goto ok;
  }
#endif

  /* save frequences                    */
  memcpy (sum, freq, sizeof (sum));

  /* check code correctness             */
  k = 0;
  i = 15;
  do
  {
    if ((k += freq[i]) & 1)
      goto bad;
    k >>= 1;
  }
  while (--i != 0);
  if (k != 1)
    goto bad;

  /* sort symbols               */
  k = 0;
  for (i = 1; i < 16; ++i)
    freq[i] = (k += freq[i]);
  last = freq[15];      /* preserve number of symbols in alphabet       */
  i = HUFF_SIZE << 4;
  do
  {
    i -= 1 << 4;
    k = length[i >> 5] >> 4;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
    i -= 1 << 4;
    k = length[i >> 5] & 0xf;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
  }
  while (i != 0);

  /* now create decoding table  */
  k = i = (1 << DECODE_BITS) + (HUFF_SIZE << 1);

  {
    xint n;
    for (n = 15; n > DECODE_BITS; --n)
    {
      j = i;
      while (k > j)
        table[--i] = (uint16) ((k -= 2) | 0x8000);
      for (k = sum[n]; --k >= 0;)
        table[--i] = table[--last];
      k = j;
    }
  }

  j = i;
  i = 1 << DECODE_BITS;
  while (k > j)
    table[--i] = (uint16) ((k -= 2) | 0x8000);

  while (last > 0)
  {
    k = table[--last];
    j = i - ((1 << DECODE_BITS) >> (k & 15));
    do
      table[--i] = (uint16) k;
    while (i != j);
  }
  assert ((i | last) == 0);

ok:
  return (1);

bad:
  return (0);
}


#endif /* CODING */

#if DEBUG
#define RET_OK do {printf ("OK @ %d\n", __LINE__); goto ret_ok;} while (0)
#define RET_ERR do {printf ("ERR @ %d\n", __LINE__); goto ret_err;} while (0)
#else
#define RET_OK goto ret_ok
#define RET_ERR goto ret_err
#endif


#define GET_UINT16(x,p) x = *(__unaligned uint16 *)(p); p += 2


#define COPY_8_BYTES(dst,src) \
  dst[0] = src[0]; dst[1] = src[1]; dst[2] = src[2]; dst[3] = src[3]; \
  dst[4] = src[4]; dst[5] = src[5]; dst[6] = src[6]; dst[7] = src[7]


/* do not use "memcpy" -- it makes it hard if "dst" and "src" are close */
#define COPY_BLOCK_SLOW(dst,src,len) \
  if (len > 8) do \
  { \
    COPY_8_BYTES (dst, src); \
    len -= 8; dst += 8; src += 8; \
  } \
  while (len > 8); \
  do \
    *dst++ = *src++, --len; \
  while (len)


#ifdef __alpha
#define COPY_BLOCK_FAST_8(dst,src) \
  COPY_8_BYTES (dst, src)
#else
#if 0
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned uint32 *) dst)[0] = ((__unaligned uint32 *) src)[0]; \
  ((__unaligned uint32 *) dst)[1] = ((__unaligned uint32 *) src)[1]
#else
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned __int64 *) dst)[0] = ((__unaligned __int64 *) src)[0]
#endif
#endif


#define BIORD(bits) \
  (Mask >> (sizeof (Mask) * 8 - (bits)))

#define CONCAT2(x,y) x##y
#define CONCAT(x,y) CONCAT2(x,y)

#define bits_t signed char

#define BIORD_MORE0(bits)                       \
  if ((Bits = (bits_t) (Bits - (bits))) < 0)    \
  {                                             \
    CAREFUL_ERR_IF (src >= info->src.end_1);    \
    Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
    src += sizeof (ubitmask2);                      \
    Bits += (bits_t) (sizeof (ubitmask2) * 8);      \
  }


#define BIORD_MORE(bits)                        \
  Mask <<= (bits_t)(bits);                      \
  BIORD_MORE0 (bits)


#define BIORD_WORD(result,bits)         \
  result = 1 << (bits);                 \
  if (bits)                             \
  {                                     \
    result += BIORD (bits);             \
    BIORD_MORE (bits);                  \
  }


#define BIORD_DECODE(result,table) {     \
  bits_t __bits;                         \
  result = ((int16 *)(table))[BIORD (DECODE_BITS)]; \
  if (result < 0)                        \
  {                                      \
    Mask <<= DECODE_BITS;                \
    do                                   \
    {                                    \
      result &= 0x7fff;                  \
      if ((bitmask4) Mask < 0) ++result; \
      result = ((int16 *)(table))[result];          \
      Mask <<= 1;                        \
    }                                    \
    while (result < 0);                  \
    __bits = (bits_t)(result & 15);      \
  }                                      \
  else                                   \
  {                                      \
    __bits = (bits_t)(result & 15);      \
    Mask <<= __bits;                     \
  }                                      \
  result >>= 4;                          \
  Bits = (bits_t) (Bits - __bits);       \
}                                        \
if (Bits < 0)                            \
{                                                         \
  CAREFUL_ERR_IF (src >= info->src.end_1);                \
  if (CODING == CODING_HUFF_ALL)                          \
    {CAREFUL_IF (src >= info->src.careful, rdmore);}      \
  Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
  src += sizeof (ubitmask2);                              \
  Bits += (bits_t) (sizeof (ubitmask2) * 8);              \
}

#ifdef _MSC_VER
#pragma optimize ("aw", off)
#endif

#define CAREFUL 0
#include "xdecode.i"
#define CAREFUL 1
#include "xdecode.i"

#ifdef _MSC_VER
#pragma optimize ("aw", on)
#endif


int XPRESS_CALL XpressDecode
(
  XpressDecodeStream stream,
  void *orig, int orig_size, int decode_size,
  const void *comp, int comp_size
)
{
  decode_info *info;
  const uchar *src;

#if ALLOCATE_ON_STACK
  decode_info stack_info;
  info = &stack_info;
  info->src.beg = (void *) stream;
#else
  if (stream == 0 || (info = (decode_info *) stream)->magic != MAGIC_DECODE)
    return (-1);
#endif

  if (comp_size == orig_size)
    return (decode_size);

  if (orig_size < comp_size
    || comp_size < 0
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
  )
    return (-1);

  if (orig_size > BUFF_SIZE || decode_size <= 0)
    return (decode_size);

  src = comp;
  info->dst.beg = orig;
  info->dst.end = (uchar *) orig + orig_size;
  info->dst.stop = (uchar *) orig + decode_size;
  info->src.end = src + comp_size;
  info->src.end_1 = info->src.end - 1;
  info->src.end_tag = info->src.end - (sizeof (tag_t) - 1);
  info->src.end_bitmask2 = info->src.end - (sizeof (bitmask2) - 1);

  // check bounds when we read new mask (at most 8 * sizeof (tag_t)) pointers

  // we may write at most 8 bytes without checks
  #define RESERVE_DST ((8 * 8 + 2) * sizeof (tag_t))
  info->dst.careful = info->dst.beg;
  if (info->dst.stop - info->dst.beg > RESERVE_DST)
    info->dst.careful = info->dst.stop - RESERVE_DST;

  // we may read at most 7 bytes
  #define RESERVE_SRC ((7 * 8 + 2) * sizeof (tag_t))
  info->src.careful = info->src.beg;
  if (info->src.end - info->src.beg > RESERVE_SRC)
    info->src.careful = info->src.end - RESERVE_SRC;

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (!huffman_decode_create (info->table, src))
    return (-1);
  src += HUFF_SIZE >> 1;
#endif
#if CODING == CODING_BY_BIT
  bit_to_len_init ();
#endif

  info->src.beg = src;
  info->result = 0;
  info->eof = 0;

  do_decode (info);

  if (!info->result || info->dst.last > info->dst.stop || info->src.last > info->src.end
    || (info->dst.stop == info->dst.end && !info->eof)
  )
    return (-1);

  return (decode_size);
}

XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn              // memory allocation callback
  )
{
#if ALLOCATE_ON_STACK
  return ((XpressDecodeStream) 1);
#else
  decode_info *info;
  if (AllocFn == 0 || (info = AllocFn (context, sizeof (*info))) == 0)
    return (0);
  info->magic = MAGIC_DECODE;
  return ((XpressDecodeStream) info);
#endif
}

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,  // encoder's workspace
    void *context,                      // user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn                // callback that releases the memory
  )
{
#if ALLOCATE_ON_STACK
  /* do nothing */
#else
  if (FreeFn != 0 && stream != 0 && ((decode_info *) stream)->magic == MAGIC_DECODE)
  {
    ((decode_info *) stream)->magic = 0;
    FreeFn (context, stream);
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\capture.asm ===
title   "Capture and Restore Context"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   capture.asm
;
; Abstract:
;
;   This module implements the platform specific code to capture and restore
;   the context of the caller.
;
; Author:
;
;   David N. Cutler (davec) 4-Jul-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        altentry RcConsolidateFrames

        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (
;     IN PCONTEXT ContextRecord
;     )
;
; Routine Description:
;
;   This function captures the context of the caller in the specified
;   context record.
;
;   N.B. The stored value of registers rcx and rsp will be a side effect of
;        having made this call. All other registers will be stored as they
;        were when the call to this function was made.
;
; Arguments:
;
;    ContextRecord (rcx) - Supplies a pointer to a context record.
;
; Return Value:
;
;    None.
;
;--

CcFrame struct
        EFlags  dd ?                    ; saved procssor flags
        Fill    dd ?                    ; fill
CcFrame ends

        NESTED_ENTRY RtlCaptureContext, _TEXT$00

        push_eflags                     ; save processor flags

        END_PROLOGUE

        mov     CxSegCs[rcx], cs        ; save segment registers
        mov     CxSegDs[rcx], ds        ;
        mov     CxSegEs[rcx], es        ;
        mov     CxSegSs[rcx], ss        ;
        mov     CxSegFs[rcx], fs        ;
        mov     CxSegGs[rcx], gs        ;

        mov     CxRax[rcx], rax         ; save integer registers
        mov     CxRcx[rcx], rcx         ;
        mov     CxRdx[rcx], rdx         ;
        mov     CxRbx[rcx], rbx         ;
        lea     rax, 16[rsp]            ;
        mov     CxRsp[rcx], rax         ;
        mov     CxRbp[rcx], rbp         ;
        mov     CxRsi[rcx], rsi         ;
        mov     CxRdi[rcx], rdi         ;
        mov     CxR8[rcx], r8           ;
        mov     CxR9[rcx], r9           ;
        mov     CxR10[rcx], r10         ;
        mov     CxR11[rcx], r11         ;
        mov     CxR12[rcx], r12         ;
        mov     CxR13[rcx], r13         ;
        mov     CxR14[rcx], r14         ;
        mov     CxR15[rcx], r15         ;

        movdqa  CxXmm0[rcx], xmm0       ; save xmm floating registers
        movdqa  CxXmm1[rcx], xmm1       ;
        movdqa  CxXmm2[rcx], xmm2       ;
        movdqa  CxXmm3[rcx], xmm3       ;
        movdqa  CxXmm4[rcx], xmm4       ;
        movdqa  CxXmm5[rcx], xmm5       ;
        movdqa  CxXmm6[rcx], xmm6       ;
        movdqa  CxXmm7[rcx], xmm7       ;
        movdqa  CxXmm8[rcx], xmm8       ;
        movdqa  CxXmm9[rcx], xmm9       ;
        movdqa  CxXmm10[rcx], xmm10     ;
        movdqa  CxXmm11[rcx], xmm11     ;
        movdqa  CxXmm12[rcx], xmm12     ;
        movdqa  CxXmm13[rcx], xmm13     ;
        movdqa  CxXmm14[rcx], xmm14     ;
        movdqa  CxXmm15[rcx], xmm15     ;

        stmxcsr CxMxCsr[rcx]            ; save xmm floating state

ifndef NTOS_KERNEL_RUNTIME

        fnsaved CxFltSave[rcx]          ; save legacy floating state

endif

        mov     rax, 8[rsp]             ; set return address
        mov     CxRip[rcx], rax         ;

        mov     eax, Ccframe.EFlags[rsp] ; set processor flags
        mov     CxEFlags[rcx], eax      ;

        mov     dword ptr CxContextFlags[rcx], CONTEXT_FULL or CONTEXT_SEGMENTS ; set context flags
        add     rsp, sizeof CcFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlCaptureContext, _TEXT$00

        subttl  "Restore Context"
;++
;
; VOID
; RtlRestoreContext (
;     IN PCONTEXT ContextRecord,
;     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
;     )
;
; Routine Description:
;
;   This function restores the context of the caller to the specified
;   context.
;
; Arguments:
;
;    ContextRecord (rcx) - Supplies a pointer to a context record.
;
;    ExceptionRecord (rdx) - Supplies an optional pointer to an exception
;        record.
;
; Return Value:
;
;    None - there is no return from this function.
;
;--

RcFrame struct
        Mframe  db MachineFrameLength dup (?) ; machine frame
        Fill    dq ?                    ; fill to 0 mod 16
RcFrame ends

        NESTED_ENTRY RtlRestoreContext, _TEXT$00

        push_reg rbp                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rdi                    ;
        alloc_stack (sizeof RcFrame)    ; allocate stack frame
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

;
; If an exception record is specified and the exception status is the unwind
; consolidation code and there is at least one parameter, then consolidate
; all the frames that have been unwound and call back to a language specified
; routine.
;

        test    rdx, rdx                ; test if exception record specified
        jz      Rc10                    ; if z, no exception record specified
        cmp     dword ptr ErExceptionCode[rdx], STATUS_UNWIND_CONSOLIDATE ; check call back
        jne     short Rc05              ; if ne, not C++ unwind
        cmp     dword ptr ErNumberParameters[rdx], 1 ; check number parameters
        jae     Rc20                    ; if ae, unwind consolidation

;
; If an exception record is specified and the exception status is long jump,
; then restore the nonvolatile registers to their state at the call to set
; jump before restoring the context record.
;

Rc05:   cmp     dword ptr ErExceptionCode[rdx], STATUS_LONGJUMP ; check for long jump
        jne     Rc10                    ; if ne, not a long jump

;
; Long jump unwind.
;
; Copy register values from the jump buffer to the context record.
;

        mov     rax, ErExceptionInformation[rdx] ; get jump buffer address
        mov     r8, JbRbx[rax]          ; move nonvolatile integer registers
        mov     CxRbx[rcx], r8          ; to context record
        mov     r8, JbRsp[rax]          ;
        mov     CxRsp[rcx], r8          ;
        mov     r8, JbRbp[rax]          ;
        mov     CxRbp[rcx], r8          ;
        mov     r8, JbRsi[rax]          ;
        mov     CxRsi[rcx], r8          ;
        mov     r8, JbRdi[rax]          ;
        mov     CxRdi[rcx], r8          ;
        mov     r8, JbR12[rax]          ;
        mov     CxR12[rcx], r8          ;
        mov     r8, JbR13[rax]          ;
        mov     CxR13[rcx], r8          ;
        mov     r8, JbR14[rax]          ;
        mov     CxR14[rcx], r8          ;
        mov     r8, JbR15[rax]          ;
        mov     CxR15[rcx], r8          ;
        mov     r8, JbRip[rax]          ;
        mov     CxRip[rcx], r8          ;

        movdqa  xmm0, JbXmm6[rax]       ; move nonvolatile floating register
        movdqa  CxXmm6[rcx], xmm0       ; to context record
        movdqa  xmm0, JbXmm7[rax]       ;
        movdqa  CxXmm7[rcx], xmm0       ;
        movdqa  xmm0, JbXmm8[rax]       ;
        movdqa  CxXmm8[rcx], xmm0       ;
        movdqa  xmm0, JbXmm9[rax]       ;
        movdqa  CxXmm9[rcx], xmm0       ;
        movdqa  xmm0, JbXmm10[rax]      ;
        movdqa  CxXmm10[rcx], xmm0      ;
        movdqa  xmm0, JbXmm11[rax]      ;
        movdqa  CxXmm11[rcx], xmm0      ;
        movdqa  xmm0, JbXmm12[rax]      ;
        movdqa  CxXmm12[rcx], xmm0      ;
        movdqa  xmm0, JbXmm13[rax]      ;
        movdqa  CxXmm13[rcx], xmm0      ;
        movdqa  xmm0, JbXmm14[rax]      ;
        movdqa  CxXmm14[rcx], xmm0      ;
        movdqa  xmm0, JbXmm15[rax]      ;
        movdqa  CxXmm15[rcx], xmm0      ;

;
; Restore context and continue.
;

Rc10:   movdqa  xmm0, CxXmm0[rcx]       ; restore floating registers
        movdqa  xmm1, CxXmm1[rcx]       ;
        movdqa  xmm2, CxXmm2[rcx]       ;
        movdqa  xmm3, CxXmm3[rcx]       ;
        movdqa  xmm4, CxXmm4[rcx]       ;
        movdqa  xmm5, CxXmm5[rcx]       ;
        movdqa  xmm6, CxXmm6[rcx]       ;
        movdqa  xmm7, CxXmm7[rcx]       ;
        movdqa  xmm8, CxXmm8[rcx]       ;
        movdqa  xmm9, CxXmm9[rcx]       ;
        movdqa  xmm10, CxXmm10[rcx]     ;
        movdqa  xmm11, CxXmm11[rcx]     ;
        movdqa  xmm12, CxXmm12[rcx]     ;
        movdqa  xmm13, CxXmm13[rcx]     ;
        movdqa  xmm14, CxXmm14[rcx]     ;
        movdqa  xmm15, CxXmm15[rcx]     ;

        ldmxcsr CxMxCsr[rcx]            ; restore floating state

        mov     ax, CxSegSs[rcx]        ; set SS segment
        mov     MfSegSs[rsp], ax        ;
        mov     rax, CxRsp[rcx]         ; set stack address
        mov     MfRsp[rsp], rax         ;
        mov     eax, CxEFlags[rcx]      ; set processor flags
        mov     MfEFlags[rsp], eax      ;
        mov     ax, CxSegCs[rcx]        ; set CS segment
        mov     MfSegCs[rsp], ax        ;
        mov     rax, CxRip[rcx]         ; set return address
        mov     MfRip[rsp], rax         ;

        mov     rax, CxRax[rcx]         ; restore volatile integer registers
        mov     rdx, CxRdx[rcx]         ;
        mov     r8, CxR8[rcx]           ;
        mov     r9, CxR9[rcx]           ;
        mov     r10, CxR10[rcx]         ;
        mov     r11, CxR11[rcx]         ;

ifdef NTOS_KERNEL_RUNTIME

        cli                             ; disable interrupts

endif

        mov     rbx, CxRbx[rcx]         ; restore nonvolatile integer registers
        mov     rsi, CxRsi[rcx]         ;
        mov     rdi, CxRdi[rcx]         ;
        mov     rbp, CxRbp[rcx]         ;
        mov     r12, CxR12[rcx]         ;
        mov     r13, CxR13[rcx]         ;
        mov     r14, CxR14[rcx]         ;
        mov     r15, CxR15[rcx]         ;
        mov     rcx, CxRcx[rcx]         ; restore integer register
        iretq                           ; return

;
; Frame consoldation and language specific unwind call back.
; 

Rc20:   sub     rsp, MachineFrameLength + 8; allocate machine frame
        mov     r8, rsp                 ; save machine frame address
        sub     rsp, CONTEXT_FRAME_LENGTH ; allocate context frame
        mov     rsi, rcx                ; set source copy address
        mov     rdi, rsp                ; set destination copy address
        mov     ecx, CONTEXT_FRAME_LENGTH / 8 ; set length of copy
    rep movsq                           ; copy context frame
        mov     rax, CxRsp[rsp]         ; set destination stack address in
        mov     MfRsp[r8], rax          ;   machine frame
        mov     rax, CxRip[rsp]         ; set destination address in machine
        mov     MfRip[r8], rax          ;   frame
        mov     rcx, rdx                ; set address of exception record
        jmp    RcConsolidateFrames      ; consolidate frames - no return

        NESTED_END RtlRestoreContext, _TEXT$00

        subttl  "Frame Consolidation"
;++
;
; Ths following code is never executed. Its purpose is to provide the dummy
; prologue necessary to consolidate stack frames for unwind call back processing
; at the end of an unwind operation.
;
;--

        NESTED_ENTRY RcFrameConsolidation, _TEXT$00

        .pushframe                      ;
        .allocstack CONTEXT_FRAME_LENGTH ; allocate stack frame
        .savereg rbx, CxRbx             ; save nonvolatile integer registers
        .savereg rbp, CxRbp             ;
        .savereg rsi, CxRsi             ;
        .savereg rdi, CxRdi             ;
        .savereg r12, CxR12             ;
        .savereg r13, CxR13             ;
        .savereg r14, CxR14             ;
        .savereg r15, CxR15             ;
        .savexmm128 xmm6, CxXmm6        ; save nonvolatile floating register
        .savexmm128 xmm7, CxXmm7        ;
        .savexmm128 xmm8, CxXmm8        ;
        .savexmm128 xmm9, CxXmm9        ;
        .savexmm128 xmm10, CxXmm10      ;
        .savexmm128 xmm11, CxXmm11      ;
        .savexmm128 xmm12, CxXmm12      ;
        .savexmm128 xmm13, CxXmm13      ;
        .savexmm128 xmm14, CxXmm14      ;
        .savexmm128 xmm15, CxXmm15      ;

        END_PROLOGUE

;++
;
; VOID
; RcConsolidateFrames (
;     IN PEXCEPTION_RECORD ExceptionRecord
;     )
;
; Routine Description:
;
;   This routine is called at the end of a  unwind operation to logically
;   remove unwound frames from the stack. This is accomplished by building a
;   call frame using a machine frame and a context record and then calling
;   the alternate entry of this function.
;
;   The following code calls the language call back function specified in the
;   exception record. If the function returns, then the destination frame
;   context is restored and control transfered to the address returned by the
;   language call back function. If control does not return, then another
;   exception must be raised.
;
; Arguments:
;
;   ExceptionRecord (rdx) - Supplies a pointer to an exception record.
;
; Implicit Arguments:
;
;   ContextRecord (rsp) - Supplies a pointer to a context record.
;
; Return Value:
;
;   None.
;
;--

        ALTERNATE_ENTRY RcConsolidateFrames

;
; At this point all call frames from the dispatching of the an exception to
; a destination language specific handler have been logically unwound and
; consolidated into a single large frame.
;
; The first parameter in the exception record is the address of a callback
; routine that performs language specific operations. This routine is called
; with the specified exception record as a parameter.
;

        call    qword ptr ErExceptionInformation[rcx] ; call back to handler

;
; Restore context and continue.
;

        mov     rcx, rsp                ; set address of context record
        mov     CxRip[rcx], rax         ; set destination address
        movdqa  xmm0, CxXmm0[rcx]       ; restore floating registers
        movdqa  xmm1, CxXmm1[rcx]       ;
        movdqa  xmm2, CxXmm2[rcx]       ;
        movdqa  xmm3, CxXmm3[rcx]       ;
        movdqa  xmm4, CxXmm4[rcx]       ;
        movdqa  xmm5, CxXmm5[rcx]       ;
        movdqa  xmm6, CxXmm6[rcx]       ;
        movdqa  xmm7, CxXmm7[rcx]       ;
        movdqa  xmm8, CxXmm8[rcx]       ;
        movdqa  xmm9, CxXmm9[rcx]       ;
        movdqa  xmm10, CxXmm10[rcx]     ;
        movdqa  xmm11, CxXmm11[rcx]     ;
        movdqa  xmm12, CxXmm12[rcx]     ;
        movdqa  xmm13, CxXmm13[rcx]     ;
        movdqa  xmm14, CxXmm14[rcx]     ;
        movdqa  xmm15, CxXmm15[rcx]     ;

        ldmxcsr CxMxCsr[rcx]            ; restore floating state

;
; Contruct a machine frame of the stack using information from the context
; record.
;
; N.B. The machine frame overlays the parameter area in the context record.
;

        mov     ax, CxSegSs[rcx]        ; set SS segment
        mov     MfSegSs[rsp], ax        ;
        mov     rax, CxRsp[rcx]         ; set stack address
        mov     MfRsp[rsp], rax         ;
        mov     eax, CxEFlags[rcx]      ; set processor flags
        mov     MfEFlags[rsp], eax      ;
        mov     ax, CxSegCs[rcx]        ; set CS segment
        mov     MfSegCs[rsp], ax        ;
        mov     rax, CxRip[rcx]         ; set return address
        mov     MfRip[rsp], rax         ;

        mov     rax, CxRax[rcx]         ; restore volatile integer registers
        mov     rdx, CxRdx[rcx]         ;
        mov     r8, CxR8[rcx]           ;
        mov     r9, CxR9[rcx]           ;
        mov     r10, CxR10[rcx]         ;
        mov     r11, CxR11[rcx]         ;

ifdef NTOS_KERNEL_RUNTIME

        cli                             ; disable interrupts

endif

        mov     rbx, CxRbx[rcx]         ; restore nonvolatile integer registers
        mov     rsi, CxRsi[rcx]         ;
        mov     rdi, CxRdi[rcx]         ;
        mov     rbp, CxRbp[rcx]         ;
        mov     r12, CxR12[rcx]         ;
        mov     r13, CxR13[rcx]         ;
        mov     r14, CxR14[rcx]         ;
        mov     r15, CxR15[rcx]         ;
        mov     rcx, CxRcx[rcx]         ; restore integer register
        iretq                           ; return

        NESTED_END RcFrameConsolidation, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\chkstk.asm ===
TITLE   "Runtime Stack Checking"
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;   chkstk.s
;
; Abstract:
;
;   This module implements runtime stack checking.
;
; Author:
;
;   David N. Cutler (davec) 20-Oct-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

        subttl  "Check Stack"
;++
;
; ULONG64
; __chkstk (
;     VOID
;     )
;
; Routine Description:
;
;   This function provides runtime stack checking for local allocations
;   that are more than a page and for storage dynamically allocated with
;   the alloca function. Stack checking consists of probing downward in
;   the stack a page at a time. If the current stack commitment is exceeded,
;   then the system will automatically attempts to expand the stack. If the
;   attempt succeeds, then another page is committed. Otherwise, a stack
;   overflow exception is raised. It is the responsibility of the caller to
;   handle this exception.
;
;   N.B. This routine is called using a non-standard calling sequence since
;        it is typically called from within the prologue. The allocation size
;        argument is in register rax and it must be preserved. Registers r10
;        and r11 used by this function and are not preserved.
;
;        The typical calling sequence from the prologue is:
;
;        mov    rax, allocation-size    ; set requested stack frame size
;        call   __chkstk                ; check stack page allocation
;        sub    rsp, rax                ; allocate stack frame
;
; Arguments:
;
;   None.
;
; Implicit Arguments:
;
;   Allocation (rax) - Supplies the size of the allocation on the stack.
;
; Return Value:
;
;   The allocation size is returned as the function value.
;
;--

        LEAF_ENTRY __chkstk, _TEXT$00

ifdef NTOS_KERNEL_RUNTIME

        ret                             ; return

else

        lea     r10, 8[rsp]             ; compute requested stack address
        sub     r10, rax                ;

;
; If the new stack address is greater than the current stack limit, then the
; pages have already been allocated and nothing further needs to be done.
;

        mov     r11, gs:[TeStackLimit]  ; get current stack limit
        cmp     r10, r11                ; check if stack within limits
        jae     short cs20              ; if ae, stack within limits

;
; The new stack address is not within the currently allocated stack. Probe
; pages downward in the stack until all pages have been allocated or a stack
; overflow occurs in which case an exception will be raised.
;

        and     r10w, not (PAGE_SIZE - 1) ; round down new stack address
cs10:   lea     r11, (-PAGE_SIZE)[r11]  ; get next lower page address
        mov     byte ptr [r11], 0       ; probe stack address
        cmp     r10, r11                ; check if end of probe range
        jne     short cs10              ; if ne, not end of probe range
cs20:   ret                             ; return

endif

        LEAF_END __chkstk, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\xencode.c ===
/* -------------------------------------------------------------------- */
/*                                                                      */
/*               Copyright (c) 1991-1999 by Andrew Kadatch              */
/*                                                                      */
/* -------------------------------------------------------------------- */

#include "xprs.h"

#define MAX_CHAIN       9


// Zobrist hashing
#define Z_HASH_SIZE_LOG    (BUFF_SIZE_LOG - 1)
#define Z_HASH_SIZE        (1 << Z_HASH_SIZE_LOG)
#define Z_HASH_SUM(b)      (z_hash_map[0][b[0]] ^ z_hash_map[1][b[1]] ^ z_hash_map[2][b[2]])

// quick hashing
#define Q_HASH_SH1      3
#define Q_HASH_SH2      (Q_HASH_SH1 >> 1)
#define Q_HASH_SUM3(c1,c2,c3) (((c1) << Q_HASH_SH1) + ((c2) << Q_HASH_SH2) + (c3))
#define Q_HASH_SUM(b)   Q_HASH_SUM3 (b[0], b[1], b[2])
#define Q_HASH_SIZE     (Q_HASH_SUM3 (255, 255, 255) + 1)

#define z_hash_t uint16
#define z_index_t uint16

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
typedef struct huff_node_t huff_node;

struct huff_node_t
{
  huff_node *son[2];
  uxint freq;
  uint16 ch;
  uint16 bits;
};

typedef struct
{
  huff_node buff[2 * HUFF_SIZE], *head[256], **link[256];
} huff_info;
#endif

typedef struct
{
  struct
  {
#if CODING == CODING_BY_BIT
    xint bits;
    uchar *ptr;
#elif CODING & (CODING_DIRECT | CODING_DIRECT2)
    uchar *ptr;
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    uxint freq[HUFF_SIZE];
    uxint mask[HUFF_SIZE];
    uchar bits[HUFF_SIZE];
    huff_info info;
    uxint pointers;
    uxint extra;
    uxint masks;
#endif /* CODING */
  } stat;
  xint chain;
  xint max_size;
  struct
  {
    uchar *beg;
    uchar *ptr;
  } comp;
  struct
  {
    z_index_t *hash;
    uchar *beg;
    uchar *ptr;
    uchar *tag_ptr;
    tag_t  tag_mask;
  } temp;
  struct
  {
    xint len;
    xint pos;
  } match;
  struct
  {
    xint   pos;
    xint   size;
    xint   stop;
    xint   progress;
    const uchar *ptr;
    const uchar *end;
    const uchar *end_16;
    const uchar *end_3;
    const uchar *ptr_stop;
  } orig;
} context;


#define v p[-1].c

typedef struct
{
  union
  {
    z_index_t    z_next[16];
    const uchar *q_last[16];
  } x;

  context c;
} prs;

#define MAGIC_ENCODE   0x53E7C0DE

typedef struct
{
  int magic;
  void *memory;
  prs *p;
  uchar *temp;
  unsigned max_size;
  int chain;
} xpress_info;


#if MAX_CHAIN >= 1
static z_hash_t z_hash_map[MIN_MATCH][256];
static int      z_hash_map_initialized = 0;

static void z_hash_map_init (void)
{
  long v1, v2;
  z_hash_t *m;

  if (z_hash_map_initialized)
    return;

  v1 = 0x13579bdfL; v2 = 0x87654321L;
  for (m = z_hash_map[0]; m < z_hash_map[0] + sizeof (z_hash_map) / sizeof (z_hash_map[0][0]); ++m)
  {
    long vv1 = v2, vv2 = v1, d = 0;
    xint i = 32;
    do
    {
      d += 0x9e3779b9L; vv1 += d; vv2 += d;
      v1 += ((v2<<3) + vv1) ^ (v2 + d) ^ ((v2>>5) + vv2);
      v2 += ((v1<<3) + vv2) ^ (v1 + d) ^ ((v1>>5) + vv1);
      --i;
    }
    while (i);
    *m = (z_hash_t) ((v1 += v2) & (Z_HASH_SIZE - 1));
  }

  z_hash_map_initialized = 1;
}

static void z_hash_insert (prs *p)
{
  const uchar *b, *e;
  xint n, h;
  z_index_t *hash = v.temp.hash;

  e = v.orig.end - (MIN_MATCH-1);
  b = v.orig.ptr;
  n = 0;
  for (; b < e; ++b, ++n)
  {
    h = Z_HASH_SUM (b);
    p->x.z_next[n] = hash[h];
    hash[h] = (z_index_t) n;
  }
  e += MIN_MATCH-1;
  for (; b < e; ++b, ++n)
    p->x.z_next[n] = 0;
}
#endif

#if CODING != CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = v.temp.ptr;
  v.temp.ptr += sizeof (v.temp.tag_mask);
  v.temp.tag_mask = 1;
}

#if CODING == CODING_HUFF_ALL
#define INC_MASKS ++v.stat.masks
#else
#define INC_MASKS
#endif

#define tag_write(p,ptr,n)                       \
{                                                \
  tag_t __n = n | (v.temp.tag_mask << 1);        \
  if (v.temp.tag_mask < 0)                       \
  {                                              \
    *(__unaligned tag_t *) v.temp.tag_ptr = __n; \
    v.temp.tag_ptr = ptr;                        \
    ptr += sizeof (v.temp.tag_mask);             \
    INC_MASKS;                                   \
    __n = 1;                                     \
  }                                              \
  v.temp.tag_mask = __n;                         \
}

static void tag_write_finish (prs *p)
{
  uchar *ptr = v.temp.ptr;
  do
  {
    tag_write (p, ptr, 1);
  }
  while (ptr == v.temp.ptr);
}

#elif CODING == CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = (uchar *) &v.temp.tag_mask;
  v.temp.tag_mask = 0;
  v.stat.bits = 0;
}

#define tag_write(p,ptr,n) do { \
  if (--v.stat.bits < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask; \
    v.temp.tag_mask = n; \
    v.stat.bits = 8 * sizeof (v.temp.tag_mask) - 1; \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  v.temp.tag_mask = (v.temp.tag_mask << 1) + (n); \
} while (0)

#define tag_write_mask(p,ptr,n,b) do { \
  if ((v.stat.bits -= (b)) < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = (v.temp.tag_mask << ((b) + v.stat.bits)) \
      + ((n) >> (-v.stat.bits)); \
    v.stat.bits += 8 * sizeof (v.temp.tag_mask); \
    v.temp.tag_mask = (n); \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  else \
    v.temp.tag_mask = (v.temp.tag_mask << (b)) + (n); \
} while  (0);

static void tag_write_finish (prs *p)
{
  do
    tag_write (p, v.temp.ptr, 1);
  while (v.stat.bits != 0);
  *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask;
}

#define write_lit(p,ptr,ch) do {   \
  tag_write (p, ptr, 0);           \
  *ptr++ = (ch);                   \
} while (0)                      

INLINE uchar *write_ptr (prs *p, uchar *ptr, xint offset, xint length)
{
  uxint k;

  --offset;

  k = 2;
  if (offset > 255) k = 3;
  tag_write_mask (p, ptr, k, 2);
  *ptr++ = (uchar) offset;
  if (offset > 255) *ptr++ = (uchar) (offset >>= 8);

  if (length <= 8)
  {
    length -= MIN_MATCH - 1;
    tag_write_mask (p, ptr, 1, length);
  }
  else
  {
    tag_write_mask (p, ptr, 0, (9 - MIN_MATCH));
    if ((length -= 9) < 15)
    {
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = (uchar) length;
      }
      else
      {
        v.stat.ptr[0] |= length << 4;
        v.stat.ptr = 0;
      }
    }
    else
    {
      length -= 15;
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = 15;
      }
      else
      {
        v.stat.ptr[0] += 0xf0;
        v.stat.ptr = 0;
      }
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }

  return (ptr);
}

#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)

#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  length -= MIN_MATCH;
  --offset;

#if CODING == CODING_DIRECT2
  offset <<= DIRECT2_LEN_LOG;
  if (length < DIRECT2_MAX_LEN)
  {
    offset |= length;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
  }
  else
  {
    offset |= DIRECT2_MAX_LEN;
    length -= DIRECT2_MAX_LEN;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
    if (v.stat.ptr == 0)
    {
      v.stat.ptr = ptr;
      *ptr++ = (uchar) (length < 15 ? length : 15);
    }
    else
    {
      v.stat.ptr[0] |= (uchar) ((length < 15 ? length : 15) << 4);
      v.stat.ptr = 0;
    }
    if ((length -= 15) >= 0)
    {
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        length += DIRECT2_MAX_LEN + 15;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }
#elif CODING == CODING_DIRECT
  if (v.stat.ptr == 0)
  {
    if (length < 7)
    {
      length <<= 5;
      v.stat.ptr = ptr;
    short_len:
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) offset;
      ptr += 2;
      if (offset > 255)
      {
        ptr[0] = (uchar) (offset >>= 8);
        ptr[-2] = (uchar) (length += 16);
        ptr += 1;
      }
    }
    else if (length < 15 + 7)
    {
      length += (14 << 4) - 7;
      goto short_len;
    }
    else
    {
      if (offset > 255)
        ptr[0] = 0xff;
      else
        ptr[0] = 0xef;
    long_len:
      ptr[1] = (uchar) (length -= (7 + 15));
      ptr += 2;
      if (length >= 255)
      {
        length += 7 + 15;
        ptr[-1] = 255;
        ptr[0] = (uchar) (length);
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
      *ptr++ = (uchar) offset;
      if (offset > 255)
        *ptr++ = (uchar) (offset >>= 8);
    }
  }
  else
  {
    if (length < 7)
    {
      length |= v.stat.ptr[0];
      *ptr++ = (uchar) offset;
      if (offset > 255)
      {
        *ptr++ = (uchar) (offset >>= 8);
        length |= 8;
      }
      v.stat.ptr[0] = (uchar) length;
      v.stat.ptr = 0;
    }
    else if (length < 15 + 7)
    {
      length -= 7;
      ptr[1] = (uchar) offset;
      ptr[0] = (uchar) (length <<= 4);
      if (offset > 255)
      {
        v.stat.ptr[0] |= 15;
        v.stat.ptr = ptr;
        ptr[2] = (uchar) (offset >>= 8);
        ptr += 3;
      }
      else
      {
        v.stat.ptr[0] |= 7;
        v.stat.ptr = ptr;
        ptr += 2;
      }
    }
    else
    {
      if (offset > 255)
        v.stat.ptr[0] |= 15;
      else
        v.stat.ptr[0] |= 7;
      v.stat.ptr = ptr;
      ptr[0] = 15 << 4;
      goto long_len;
    }
  }
#endif /* CODING */

  tag_write (p, ptr, 1);

  return (ptr);
}


#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)

#if CODING == CODING_HUFF_ALL
#define write_lit(p,ptr,ch) do {    \
  ++v.stat.freq[*ptr++ = (ch)]; \
  tag_write (p, ptr, 0);            \
} while (0)
#else
#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)
#endif

#define BIOWR(mask,bits) {                                      \
  assert (((mask) >> (bits)) == 0);                             \
  if ((Bits -= (bits)) < 0)                                     \
  {                                                             \
    *(__unaligned bitmask2 *)Ptr1 = (bitmask2) ((Mask << (Bits + (bits))) \
      + ((mask) >> (-Bits)));                                   \
    Mask = (mask);                                              \
    Bits += sizeof (ubitmask2) * 8;                             \
    Ptr1 = Ptr2;                                                \
    Ptr2 = (ubitmask2 *) ptr;                                   \
    ptr += sizeof (ubitmask2);                                  \
  }                                                             \
  else                                                          \
    Mask = (Mask << (bits)) + (mask);                           \
}


#if CODING == CODING_HUFF_LEN

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  ++v.stat.pointers;

  length -= MIN_MATCH;
  --offset;

  k = 0; if (offset > 255) k = 1;

  if (length < MAX_LENGTH - 1)
    ++v.stat.freq[*ptr++ = (uchar) (k |= length << 1)];
  else
  {
    length -= MAX_LENGTH - 1;
    ++v.stat.freq[ptr[0] = (uchar) (k |= (MAX_LENGTH - 1) << 1)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      ptr[-1] = 255;
      length += MAX_LENGTH - 1;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (offset > 255)
    *ptr++ = (uchar) (offset >>= 8);

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  ubitmask4 Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
    *ptr++ = *src++;
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    *(__unaligned tag_t *)ptr = bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
    ptr += sizeof (tag_t);
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[k], v.stat.bits[k]);

  if (k >= ((MAX_LENGTH - 1) << 1))
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  *ptr++ = *src++;
  if (k & 1) *ptr++ = *src++;
  goto next;

done:
  *Ptr1 = (ubitmask2) (Mask <<= Bits);
  *Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)

#define MAX_BITNO_LOG   8
#define MAX_BITNO       (1 << MAX_BITNO_LOG)

static uchar bitno_table[MAX_BITNO];
static int bitno_table_initialized = 0;

static void bitno_init (void)
{
  int i, k, n;
  if (bitno_table_initialized)
    return;
  bitno_table[0] = 255;
  for (i = 0; i < MAX_BITNO_LOG; ++i)
  {
    for (n = (k = 1<<i) << 1; k < n; ++k)
      bitno_table[k] = (uchar) i;
  }
  bitno_table_initialized = 1;
}

static int bitno (uxint n)
{
  assert (n != 0 && (n >> (MAX_BITNO_LOG*2)) == 0);
  if (n >= MAX_BITNO)
    return (bitno_table[n >> MAX_BITNO_LOG] + MAX_BITNO_LOG);
  return (bitno_table[n]);
}

#if CODING == CODING_HUFF_ALL
#define CODING_ADJUST(n) (256 + (n))
#else
#define CODING_ADJUST(n) (n)
#endif

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  k = bitno (offset);
  length -= MIN_MATCH;
  offset ^= 1 << k;

  v.stat.pointers += 2;
  v.stat.extra += k;

  k <<= MAX_LENGTH_LOG;
  if (length < MAX_LENGTH - 1)
  {
    k |= length;
    *ptr++ = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
  }
  else
  {
    k |= MAX_LENGTH - 1;
    length -= MAX_LENGTH - 1;
    ptr[0] = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      length += MAX_LENGTH - 1;
      ptr[-1] = 255;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (k >= (9 << MAX_LENGTH_LOG))
  {
    v.stat.pointers += 1;
    *ptr++ = (uchar) (offset >>= 8);
  }

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  uxint Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
#if CODING == CODING_HUFF_ALL
    k = *src++;
    BIOWR (v.stat.mask[k], v.stat.bits[k]);
#elif CODING == CODING_HUFF_PTR
    *ptr++ = *src++;
#endif
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
#if CODING == CODING_HUFF_PTR
    *(__unaligned tag_t *)ptr = bmask;
    ptr += sizeof (tag_t);
#endif
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[CODING_ADJUST (k)], v.stat.bits[CODING_ADJUST (k)]);

  if ((k & (MAX_LENGTH - 1)) == MAX_LENGTH - 1)
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  k >>= MAX_LENGTH_LOG;
  {
    uxint m = *src++;
    if (k > 8)
      m += *src++ << 8;
    BIOWR (m, k);
  }
  goto next;

done:
#if CODING == CODING_HUFF_ALL
  BIOWR (v.stat.mask[CODING_ADJUST(0)], v.stat.bits[CODING_ADJUST(0)]);
#endif
  *Ptr1 = (ubitmask2) (Mask <<= Bits);
  *Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#endif


/* ------------------ Create canonical Huffman code ------------------- */
/*                    -----------------------------                     */

#define MAX_ALPHABET HUFF_SIZE
static void huffman_create_codes (huff_info *info, uxint *freq, xint n, uxint *mask, uchar *length, uxint maxbits, uchar *encoded, uxint *total)
{
  huff_node
    *p, *q, *r,
    *first_sorted, *first_free;
  xint i, k;

  assert ((uxint) (n-1) <= (MAX_ALPHABET-1));

  /* honestly it is easy enough to create Huffman code in-place */
  /* but the use of explicit data structures makes code simpler */

  /* clean everything up                */
  memset (length, 0, sizeof (length[0]) * n);
  memset (encoded, 0, (n + 1) >> 1);

  if (mask != 0 && mask != freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  /* store frequencies */
  p = info->buff;
  for (i = 0; i < n; ++i)
  {
    if ((p->freq = freq[i]) != 0)
    {
      p->son[0] = p+1; p->son[1] = 0;
      p->ch = (uint16) i;
      ++p;
    }
  }

  /* handle simple case         */
  *total = 0;
  if (p <= info->buff + 1)
  {
    if (p == info->buff)        /* if no symbols do nothing */
      return;
    i = p[-1].ch;               /* single symbol code */
    mask[i] = 0;
    encoded[i >> 1] = 0x11;     /* two symbols has 1-bit length */
    return;
  }

  first_free = p;       /* store location of first unused node  */

  p[-1].son[0] = 0;     /* terminate the list                   */
  /* radix sort the list by frequency */
  p = info->buff;             /* head of the list                     */
  /* initialize */
  for (n = 0; n < 256; ++n)
    *(info->link[n] = info->head + n) = 0;
  for (i = 0; i < (BUFF_SIZE_LOG <= 16 ? 16 : 32); i += 8)
  {
    /* link node to the end of respective bucket        */
    do
    {
      n = (p->freq >> i) & 0xff;
      info->link[n][0] = p; info->link[n] = p->son;
    }
    while ((p = p->son[0]) != 0);

    /* merge buckets into single list                   */
    n = 0;
    while (info->head[n] == 0) ++n;
    p = info->head[n]; info->head[k = n] = 0;
    while (++n < 256)
    {
      if (info->head[n] == 0) continue;
      info->link[k][0] = info->head[n]; info->link[k] = info->head + k; info->head[n] = 0;
      k = n;
    }
    info->link[k][0] = 0; info->link[k] = info->head + k;
  }
  first_sorted = p;      /* store head of sorted symbol's list   */

restart:
  assert (p == first_sorted);
  q = first_free;
  r = q - 1;
  while (p != 0 || q != r)
  {
    ++r;

    /* select left subtree      */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[0] = q; r->freq = q->freq; ++q;
    }
    else
    {
      r->son[0] = p; r->freq = p->freq; p = p->son[0];
    }

    /* select right subtree     */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[1] = q; r->freq += q->freq; ++q;
    }
    else
    {
      r->son[1] = p; r->freq += p->freq; p = p->son[0];
    }
  }

  /* evaluate codewords' length         */
  i = -1;       /* stack pointer        */
  n = 0;        /* current tree depth   */
  p = r;        /* current subtree root */
  for (;;)
  {
    while (p->son[1] != 0)
    {
      /* put right son into stack and set up its depth   */
      (info->head[++i] = p->son[1])->bits = (uint16) (++n);
      (p = p->son[0])->bits = (uint16) n;
    }
    length[p->ch] = (uchar) n;

    if (i < 0) break;   /* nothing's in stack                   */
    n = (p = info->head[i--])->bits;
  }

  p = first_sorted;
#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (q->bits >= r->bits);
#endif
  if (p->bits > maxbits)
  {
    assert (p == first_sorted);
    q = p;
    do
      q->freq = (q->freq + 1) >> 1;
    while ((q = q->son[0]) != 0);
    goto restart;
  }

  /* now sort symbols in a stable way by increasing codeword length     */
  /* initialize */
  memset (info->head, 0, sizeof (info->head[0]) * 32);
  for (n = 0; n < 32; ++n)
    info->link[n] = info->head + n;

  /* link node to the end of respective bucket  */
  p = info->buff;
  do
  {
    n = p->bits;
    info->link[n][0] = p; info->link[n] = p->son;
  }
  while (++p != first_free);

  /* merge buckets into single list             */
  n = 0;
  while (info->head[n] == 0) ++n;
  p = info->head[n]; k = n;
  while (++n < 32)
  {
    if (info->head[n] == 0) continue;
    info->link[k][0] = info->head[n];
    k = n;
  }
  info->link[k][0] = 0;

#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (r->bits > q->bits || (r->bits == q->bits && r->ch > q->ch));
#endif

  /* set up code masks          */
  if (mask == freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  n = 0;        /* mask         */
  i = 1;        /* bit length   */
  k = 1;        /* first index  */
  do
  {
    /* sum a[i] * b[i] may be evaluated without multiplications */
    /* using O(B) memory and O(N+B) time if 0 <= b[i] < B       */
    *total += freq[p->ch] * p->bits;
    encoded[p->ch >> 1] |= p->bits << (p->ch & 1 ? 4 : 0);
    mask[p->ch] = (n <<= p->bits - i);
    i = p->bits;
    ++n;
  }
  while ((p = p->son[0]) != 0);
}

#endif /* CODING */

#define CHAIN 0
#define encode_pass1 encode0_pass1
#include "xencode.i"

#if MAX_CHAIN >= 1
#define CHAIN 1
#define encode_pass1 encode1_pass1
#define find_match find_match1
#include "xencode.i"
#endif

#if MAX_CHAIN >= 2
#define CHAIN 2
#define encode_pass1 encode2_pass1
#define find_match find_match2
#include "xencode.i"
#endif

#if MAX_CHAIN >= 3
#define CHAIN 3
#define encode_pass1 encodeN_pass1
#define find_match find_matchN
#include "xencode.i"
#endif

typedef void encode_pass1_proc (prs *p);

static void encode_pass1_progress (
  prs *p,
  encode_pass1_proc *encode_pass1,
  XpressProgressFn *ProgressFn,     // NULL or progress callback
  void *ProgressContext,        // user-defined context that will be passed to ProgressFn
  int ProgressSize          // call ProgressFn each time ProgressSize bytes processed
)
{
  xint stop;

  if (ProgressFn == 0)
  {
    encode_pass1 (p);
    return;
  }

  stop = v.orig.stop;
  for (;;)
  {
    if (v.orig.pos - v.orig.progress >= ProgressSize)
    {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
      ProgressFn (ProgressContext, v.orig.ptr);
#else
      ProgressFn (ProgressContext, (v.orig.pos * 15) >> 4);
#endif
      v.orig.progress = v.orig.pos;
    }

    v.orig.stop = stop;
    if (v.orig.pos >= stop)
      break;

    if (stop - v.orig.progress > ProgressSize)
      v.orig.stop = v.orig.progress + ProgressSize;
    assert (v.orig.stop > v.orig.pos);

    encode_pass1 (p);
  }
}


int XPRESS_CALL XpressEncode
(
  XpressEncodeStream stream,
  void *comp, 
  int comp_size,
  const void *orig, 
  int orig_size,
  XpressProgressFn *ProgressFn,     // NULL or progress callback
  void *ProgressContext,        // user-defined context that will be passed to ProgressFn
  int ProgressSize          // call ProgressFn each time ProgressSize bytes processed
)
{
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uchar huff_buff [HUFF_SIZE >> 1];
  uxint huff_total;
#endif
  uxint c_size;
  prs *p;
  xpress_info *info = (xpress_info *) stream;
  encode_pass1_proc *encode_pass1;

  if (info == 0 || info->magic != MAGIC_ENCODE)
    return (0);

  if ((unsigned) (orig_size-1) > info->max_size
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
    || comp == 0
    || orig == 0)
  {
    return (orig_size);
  }

  p = info->p;
  memset (&v, 0, sizeof (v));
  v.temp.hash = (z_index_t *) (v.temp.ptr = info->temp);
  v.chain = info->chain;

  v.orig.end = (v.orig.ptr = orig) + (v.orig.size = v.orig.stop = orig_size);
  v.orig.end_16 = v.orig.end - 16;
  v.orig.end_3 = v.orig.end - MIN_MATCH;
  v.comp.ptr = v.comp.beg = comp;
  v.orig.pos = 0;
  v.temp.beg = v.temp.ptr;

  encode_pass1 = encode0_pass1;
  if (v.chain <= 0)
    memset ((void *) (&p->x.q_last[0]), 0, Q_HASH_SIZE * sizeof (p->x.q_last[0]));
#if MAX_CHAIN >= 1
  else if (v.chain == 1)
  {
    encode_pass1 = encode1_pass1;
    memset ((void *) (&p->x.z_next[0]), 0, Z_HASH_SIZE * sizeof (p->x.z_next[0]));
  }
#if MAX_CHAIN >= 2
  else
  {
    encode_pass1 = encode2_pass1;
#if MAX_CHAIN >= 3
    if (v.chain >= 3)
      encode_pass1 = encodeN_pass1;
#endif
    memset (v.temp.hash, 0, sizeof (v.temp.hash[0]) * Z_HASH_SIZE);
    z_hash_insert (p);
  }
#endif
#endif

  if (ProgressSize <= 0 || ProgressSize > orig_size)
    ProgressSize = orig_size;

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, v.orig.progress = 0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  v.temp.beg = v.temp.ptr = v.comp.ptr;
  tag_write_start (p);
  for (;;)
  {
    xint rest = comp_size - (xint) (v.temp.ptr - v.comp.beg) - 2 * sizeof (tag_t);
    rest -= (rest + 7) >> 3;
    if (rest <= (xint) (2 * sizeof (tag_t) + 8))
      goto no_compression;
    if (v.orig.pos >= v.orig.size)
      break;
    v.orig.stop = v.orig.pos + rest;
    if (v.orig.stop > v.orig.size - 8)
    {
      v.orig.stop = v.orig.size - 8;
      if (v.orig.pos >= v.orig.stop)
        break;
    }
    encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
  }
#else
  v.orig.stop -= 7;
  tag_write_start (p);
  encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
#endif
  while (v.orig.pos < v.orig.size)
  {
    write_lit (p, v.temp.ptr, v.orig.ptr[v.orig.pos]);
    ++v.orig.pos;
  }
  tag_write_finish (p);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  c_size = (xint) (v.temp.ptr - v.temp.beg);
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (v.stat.pointers == 0)
    goto no_compression;
#if CODING == CODING_HUFF_ALL
  ++v.stat.freq[CODING_ADJUST(0)];
#endif
  huffman_create_codes (
    &v.stat.info,
    v.stat.freq, HUFF_SIZE,
    v.stat.mask, v.stat.bits, 15, huff_buff, &huff_total);

  c_size = huff_total;
#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
  c_size += v.stat.extra;
#endif
  if (c_size == 0) c_size = 1;
  c_size = (((c_size - 1) & ~(sizeof (bitmask2) * 8 - 1)) >> 3);
  c_size += (int) (v.temp.ptr - v.temp.beg) - v.stat.pointers + 4 + sizeof (huff_buff);
#if CODING == CODING_HUFF_ALL
  for (huff_total = 0; huff_total < 256; ++huff_total)
    c_size -= v.stat.freq[huff_total];
  c_size -= v.stat.masks * sizeof (tag_t);
#endif
#endif /* CODING */

  if (c_size >= (uxint) comp_size)
  {
  no_compression:
    comp_size = orig_size;
  }
  else
  {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    memcpy (v.comp.ptr, huff_buff, sizeof (huff_buff));
    v.comp.ptr += sizeof (huff_buff);
    encode_pass2 (p);
#elif CODING & (CODING_BY_BIT | CODING_DIRECT | CODING_DIRECT2)
    v.comp.ptr += c_size;
#else
#error Unknown CODING
#endif

    comp_size = (int) (v.comp.ptr - v.comp.beg);

#if DEBUG
    if (c_size != (uxint) comp_size)
      printf ("error: c_size = %d, comp_size = %d\n", c_size, comp_size);
#endif
  }

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, orig_size);

  return (comp_size);
}

#define ALIGN   32

XpressEncodeStream XPRESS_CALL XpressEncodeCreate
  (int orig_size, void *context, XpressAllocFn *AllocFn, int chain)
{
  xpress_info *info;
  prs *p;
  uchar *b;
  int temp_size;
  int alloc_size;

  if (AllocFn == 0 || (unsigned) (orig_size-1) > (BUFF_SIZE-1))
    return (0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  temp_size = 0;
#else
  temp_size = orig_size + ((orig_size + 7) >> 3);
#endif

  alloc_size = sizeof (p->x.q_last[0]) * Q_HASH_SIZE;
#if MAX_CHAIN <= 0
  chain = 0;
#else
  if (chain > MAX_CHAIN)
    chain = MAX_CHAIN;
  if (chain >= 1)
  {
    alloc_size = sizeof (p->x.z_next[0]) * Z_HASH_SIZE;
#if MAX_CHAIN >= 2
    if (chain >= 2)
    {
      alloc_size = sizeof (p->x.z_next[0]) * orig_size;
      if (temp_size < sizeof (v.temp.hash[0]) * Z_HASH_SIZE)
        temp_size = sizeof (v.temp.hash[0]) * Z_HASH_SIZE;
    }
#endif
  }
#endif

  temp_size = (temp_size + 256 + sizeof (*p)) & ~(ALIGN-1);
  alloc_size += temp_size + sizeof (*info) + ALIGN;

  b = AllocFn (context, alloc_size);
  if (b == 0)
    return (0);

  info = (xpress_info *) b;
  info->max_size = orig_size - 1;
  info->chain = chain;
  info->magic = MAGIC_ENCODE;
  info->memory = b;

  b = (uchar *) (info + 1);
  b += ALIGN - (((__int64) b) & (ALIGN-1));
  info->p = p = ((prs *) (b + temp_size));
  info->temp = b;

#if MAX_CHAIN >= 1
  z_hash_map_init ();
#endif

#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
  bitno_init ();
#endif

  return ((XpressEncodeStream) info);
}

void XPRESS_CALL XpressEncodeClose
  (XpressEncodeStream stream, void *context, XpressFreeFn *FreeFn)
{
  xpress_info *info = (xpress_info *) stream;
  if (info != 0 && FreeFn != 0 && info->magic == MAGIC_ENCODE)
  {
    info->magic = 0;
    FreeFn (context, info->memory);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module implements user mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

Author:

    David N. Cutler (davec) 13-May-2000

Revision History:

--*/

#include "ntrtlp.h"

#if defined(NTOS_KERNEL_RUNTIME)

#pragma alloc_text(PAGE, RtlInitializeContext)
#pragma alloc_text(PAGE, RtlRemoteCall)

#endif

VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context record so that it can be used in a
    subsequent call to create thread.

Arguments:

    Process - Supplies a handle to the process in which a thread is being
        created.

    Context - Supplies a pointer to a context record.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    STATUS_BAD_INITIAL_STACK is raised if initial stack pointer value is not
    properly aligned.

--*/

{

    RTL_PAGED_CODE();

    //
    // Check stack alignment.
    //

    if (((ULONG64)InitialSp & 0xf) != 0) {
        RtlRaiseStatus(STATUS_BAD_INITIAL_STACK);
    }

    //
    // Initialize the EFflags field.
    //

    Context->EFlags = EFLAGS_IF_MASK | EFLAGS_AC_MASK;

    //
    // Initialize the integer registers.
    //

    Context->Rax = 0L;
    Context->Rcx = 2L;
    Context->Rbx = 1L;
    Context->Rsp = (ULONG64)InitialSp;
    Context->Rbp = 0L;
    Context->Rsi = 4L;
    Context->Rdi = 5L;
    Context->R8 = 8;
    Context->R9 = 9;
    Context->R10 = 10;
    Context->R11 = 11;
    Context->R12 = 12;
    Context->R13 = 13;
    Context->R14 = 14;
    Context->R15 = 15;

    //
    // Initialize the floating registers.
    //

    Context->Xmm0.Low = 0;
    Context->Xmm0.High = 0;
    Context->Xmm1.Low = 1;
    Context->Xmm1.High = 1;
    Context->Xmm2.Low = 2;
    Context->Xmm2.High = 2;
    Context->Xmm3.Low = 3;
    Context->Xmm3.High = 3;
    Context->Xmm4.Low = 4;
    Context->Xmm4.High = 4;
    Context->Xmm5.Low = 5;
    Context->Xmm5.High = 5;
    Context->Xmm6.Low = 6;
    Context->Xmm6.High = 6;
    Context->Xmm7.Low = 7;
    Context->Xmm7.High = 7;
    Context->Xmm8.Low = 8;
    Context->Xmm8.High = 8;
    Context->Xmm9.Low = 9;
    Context->Xmm9.High = 9;
    Context->Xmm10.Low = 10;
    Context->Xmm10.High = 10;
    Context->Xmm11.Low = 11;
    Context->Xmm11.High = 11;
    Context->Xmm12.Low = 12;
    Context->Xmm12.High = 12;
    Context->Xmm13.Low = 13;
    Context->Xmm13.High = 13;
    Context->Xmm14.Low = 14;
    Context->Xmm14.High = 14;
    Context->Xmm15.Low = 15;
    Context->Xmm15.High = 15;

    Context->MxCsr = INITIAL_MXCSR;

    //
    // Initialize the lagacy floatin point.
    //

    Context->FltSave.ControlWord = 0x23f;
    Context->FltSave.StatusWord = 0;
    Context->FltSave.TagWord = 0xffff;
    Context->FltSave.ErrorOffset = 0;
    Context->FltSave.ErrorSelector = 0;
    Context->FltSave.ErrorOpcode = 0;
    Context->FltSave.DataOffset = 0;
    Context->FltSave.DataSelector = 0;

    //
    // Initialize the program counter.
    //

    Context->Rip = (ULONG64)InitialPc;

    //
    // Set context record flags.
    //

    Context->ContextFlags = CONTEXT_FULL;

    //
    // Set the initial context of the thread in a machine specific way.
    //

    Context->Rcx = (ULONG64)Parameter;

    //
    // Unique stamp to tell wow64 that this is an RtlCreateUserThread context
    // rather than BaseCreateThread context.
    //

    Context->R9 = 0xf0e0d0c0a0908070UI64;

    return;
}

NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using the
    system functins NtGetContext and NtSetContext. Parameters are passed
    to the target procedure via the nonvolatile registers ().

Arguments:

    Process - Supplies an open handle to the target process.

    Thread - Supplies an open handle to the target thread within the target
        process.

    CallSite - Supplies the address of the procedure to call in the target
        process.

    ArgumentCount - Supplies the number of parameters to pass to the target
        procedure.

    Arguments - Supplies a pointer to the array of parameters to pass.

    PassContext - Supplies a boolean value that determines whether a parameter
        is to be passed that points to a context record.

    AlreadySuspended - Supplies a boolean value that determines whether the
        target thread is already in a suspended or waiting state.

Return Value:

    Status - Status value

--*/

{

    CONTEXT Context;
    ULONG Index;
    ULONG64 NewSp;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    // Check if too many arguments are specified.
    //

    if (ArgumentCount > 4) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If necessary, suspend the target thread before getting the thread's
    // current state.
    //

    if (AlreadySuspended == FALSE) {
        Status = NtSuspendThread(Thread, NULL);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Get the current context of the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread(Thread, &Context);
    if (!NT_SUCCESS(Status)) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }

        return Status;
    }

    if (AlreadySuspended != FALSE) {
        Context.Rax = STATUS_ALERTED;
    }

    //
    // Write previous thread context into the stack of the target thread.
    //

    NewSp = Context.Rsp - sizeof(CONTEXT);
	Status = NtWriteVirtualMemory(Process,
				                  (PVOID)NewSp,
				                  &Context,
				                  sizeof(CONTEXT),
				                  NULL);

	if (!NT_SUCCESS(Status)) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }

	    return Status;
	}

    //
    // Pass the parameters to the target thread via the nonvolatile registers
    // R11-R15.
    //

    Context.Rsp = NewSp;
    if (PassContext != FALSE) {
        Context.R11 = NewSp;
        for (Index = 0; Index < ArgumentCount; Index += 1) {
            (&Context.R12)[Index] = Arguments[Index];
        }

    } else {
        for (Index = 0; Index < ArgumentCount; Index += 1) {
            (&Context.R11)[Index] = Arguments[Index];
        }
    }

    //
    // Set the address of the target code into RIP and set the thread context
    // to cause the target procedure to be executed.
    //

    Context.Rip = (ULONG64)CallSite;
    Status = NtSetContextThread(Thread, &Context);
    if (AlreadySuspended == FALSE) {
        NtResumeThread(Thread, NULL);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\debugstb.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   debugstb.asm
;
; Abstract:
;
;   This module implements functions to support debugging NT.
;
; Author:
;
;   David N. Cutler (davec) 26-Jun-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

        subttl  "Break Point"
;++
;
; VOID
; DbgBreakPoint (
;     VOID
;     )
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debugger under program control. This breakpoint will always go to
;   the kernel debugger if one is installed, otherwise it will go to the
;   debug subsystem.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DbgBreakPoint, _TEXT$00

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgBreakPoint, _TEXT$00

        subttl  "User Break Point"
;++
;
; VOID
; DbgUserBreakPoint()
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debug subsystem under program control. The kernel debugger will
;   ignore this breakpoint since it will not find the instruction address
;   its breakpoint table.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DbgUserBreakPoint, _TEXT$00

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgUserBreakPoint, _TEXT$00

        subttl  "Break Point With Status"
;++
;
; VOID
; DbgBreakPointWithStatus(
;     IN ULONG Status
;     )
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debugger under program control. This breakpoint will always go to
;   the kernel debugger if one is installed, otherwise it will go to the
;   debug subsystem. This function is identical to DbgBreakPoint, except
;   that it takes an argument which the debugger can see.
;
;   Note: The debugger checks the address of the breakpoint instruction
;   against the address RtlpBreakWithStatusInstruction.  If it matches,
;   we have a breakpoint with status. A breakpoint is normally issued
;   with the break_debug_stop macro which generates two instructions.
;   We can't use the macro here because of the "label on the breakpoint"
;   requirement.
;
; Arguments:
;
;   Status (ecx) - Supplies the break point status code.
;
; Return Value:
;
;    None.
;
;--

        altentry RtlpBreakWithStatusInstruction

        LEAF_ENTRY DbgBreakPointWithStatus, _TEXT$00

        ALTERNATE_ENTRY RtlpBreakWithStatusInstruction

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgBreakPointWithStatus, _TEXT$00

        subttl  "Debug Print"
;++
;
; NTSTATUS
; DebugPrint(
;     IN PSTRING Output,
;     IN ULONG ComponentId,
;     IN ULONG Level
;     )
;
; Routine Description:
;
;   This function executes a debug print breakpoint.
;
; Arguments:
;
;   Output (rcx) - Supplies a pointer to the output string descriptor.
;
;   ComponentId (edx) - Supplies the Id of the calling component.
;
;   Level (r8d) - Supplies the output importance level.
;
; Return Value:
;
;    STATUS_SUCCESS is returned if the debug print was completed successfully.
;
;    STATUS_BREAKPOINT is returned if user typed a Control-C during print.
;
;    STATUS_DEVICE_NOT_CONNECTED is returned if kernel debugger not present.
;
;--

        LEAF_ENTRY DebugPrint, _TEXT$00

        mov     r9d, r8d                ; set importance level
        mov     r8d, edx                ; set component id
        mov     dx, StrLength[rcx]      ; set length of output string
        mov     rcx, StrBuffer[rcx]     ; set address of output string
        mov     eax, BREAKPOINT_PRINT   ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugPrint, _TEXT$00

        subttl  "Debug Prompt"
;++
;
; ULONG
; DebugPrompt(
;     IN PSTRING Output,
;     IN PSTRING Input
;     )
;
; Routine Description:
;
;   This function executes a debug prompt breakpoint.
;
; Arguments:
;
;   Output (rcx) - Supplies a pointer to the output string descriptor.
;
;   Input (rdx) - Supplies a pointer to the input string descriptor.
;
; Return Value:
;
;   The length of the input string is returned as the function value.
;
;--

        LEAF_ENTRY DebugPrompt, _TEXT$00

        mov     r9w, StrMaximumLength[rdx] ; set maximum length of input string
        mov     r8, StrBuffer[rdx]      ; set address of input string
        mov     dx, StrLength[rcx]      ; set length of output string
        mov     rcx, StrBuffer[rcx]     ; set address of output string
        mov     eax, BREAKPOINT_PROMPT  ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugPrompt, _TEXT$00

;++
;
; VOID
; DebugService2(
;     IN PVOID Param1,
;     IN PVOID Param2,
;     IN ULONG Service
;     )
;
; Routine Description:
;
;   This function calls the kernel debugger to execute a command string.
;
; Arguments:
;
;   Param1 (rcx) - Supplies the first parameter to the KD fault handler
;
;   Param2 (rdx) - Supplies the second parameter to the KD fault handler
;
;   Service (r8d) - Supplies a pointer to the command string.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DebugService2, _TEXT$00

        mov     eax, r8d                ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugService2, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\lzntx86.asm ===
title	"Compression and Decompression Engines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    lzntx86.asm
;
; Abstract:
;
;    This module implements the compression and decompression engines needed
;    to support file system compression.  Functions are provided to
;    compress a buffer and decompress a buffer.
;
; Author:
;
;    Mark Zbikowski (markz) 15-Mar-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   15-Mar-1994 markz
;
;           386 version created
;
;--

include ksamd64.inc

        subttl  "Decompression Macros"
;
;**	TestLiteralAt - tests to see if there's a literal at a specific
;	    bit position.  If so, it branches to the appropriate copy code
;	    (decorated by the bit being used).
;
;       This code does no bounds checking

TestLiteralAt	macro	CopyLabel,bit,IsMain
	test	al,1 SHL bit		; is there a copy token at this position?
	jnz	CopyLabel&bit		; yes, go copy it

	mov	dl,[esi+bit+1]		; (dl) = literal byte from compressed stream
ifidn <IsMain>,<Y>
	mov	[edi+bit],dl		; store literal byte
else
	mov	[edi],dl		; store literal byte
	inc	edi			; point to next literal
endif

endm

;	Jump - allow specific jumps with computed labels.

Jump	macro	lab,tag
        jmp     lab&tag
endm

;
;**	DoCopy - perform a copy.  If a bit position is specified
;	    then branch to the appropriate point in the "safe" tail when
;	    the copy takes us too close to the end of the output buffer
;
;       This code checks the bounds of the copy token:  copying before the
;       beginning of the buffer and copying beyond the end of the buffer.

DoCopy	macro	AdjustLabel,bit,IsMain

ifidn	<IsMain>,<Y>
if bit ne 0
	add	edi,bit
endif
endif

Test&AdjustLabel&bit:
	cmp	edi,WidthBoundary
	ja	Adjust&AdjustLabel&bit

	xor	ecx,ecx
	mov	cx,word ptr [esi+bit+1] ; (ecx) = encoded length:offset
	lea	edx,[esi+1]		; (edx) = next token location
	mov	Temp,edx

	mov	esi,ecx 		; (esi) = encoded length:offset
	and	ecx,MaskTab[ebx*4]	; (ecx) = length
	xchg	ebx,ecx 		; (ebx) = length/(ecx) = width
	shr	esi,cl			; (esi) = offset
	xchg	ebx,ecx 		; (ebx) = width, (ecx) = length

	neg	esi			; (esi) = negative real offset
	lea	esi,[esi+edi-1] 	; (esi) = pointer to previous string

        cmp     esi,UncompressedBuffer  ; off front of buffer?
        jb      DOA                     ; yes, error

	add	ecx,3			; (ecx) = real length

	lea	edx,[edi+ecx]		; (edx) = end of copy
ifidn	<IsMain>,<Y>
	cmp	edx,EndOfSpecialDest	; do we exceed buffer?
	jae	TailAdd&bit		; yes, handle in safe tail
else
	cmp	edx,EndOfUncompressedBufferPlus1
					; do we exceed buffer?
	ja	DOA			; yes, error
endif

	rep	movsb			; Copy the bytes

	mov	esi,Temp		; (esi) = next token location

ifidn	<IsMain>,<Y>
	sub	edi,bit+1
endif

endm

;
;**	AdjustWidth - adjust width of length based upon current position of
;	    input buffer (max offset)

AdjustWidth macro   l,i
Adjust&l&i:
	dec	ebx			; (ebx) = new width pointer
	mov	edx,UncompressedBuffer	; (edx) = pointer to dest buffer
	add	edx,WidthTab[ebx*4]	; (edx) = new width boundary
	mov	WidthBoundary,edx	; save boundary for comparison
	jmp	Test&l&i

endm

;
;**	GenerateBlock - generates the unsafe block of copy/literal pieces.
;
;       This code does no checking for simple input/output checking.  Only
;       the data referred to by the copy tokens is checked.

GenerateBlock	macro	bit
Copy&bit:

	DoCopy	Body,bit,Y

	j = bit + 1
	while j lt 8
	    TestLiteralAt   Copy,%(j),Y
	    j = j + 1
	endm

	add	esi,9
	add	edi,8

	jmp	Top

	AdjustWidth Body,bit
endm

;
;**	GenerateTailBlock - generates safe tail block for compression.	This
;	    code checks everything before each byte stored so it is expected
;	    to be executed only at the end of the buffer.

GenerateTailBlock   macro   bit
TailAdd&bit:
	add	EndOfCompressedBufferPlus1,1+2*8
                                        ; restore buffer length to true length
	mov     esi,Temp                ; (esi) = source of copy token block
	dec	esi

Tail&bit:
	lea	ecx,[esi+bit+1]         ; (ecx) = source of next token
	cmp	ecx,EndOfCompressedBufferPlus1	; are we done?
	jz	Done                    ; yes - we exactly match end of buffer
;       ja      DOA                     ; INTERNAL ERROR only

	cmp	edi,EndOfUncompressedBufferPlus1
	jz	Done			; go quit, destination is full
;       ja      DOA                     ; INTERNAL ERROR only

	TestLiteralAt	TailCopy,bit,N

        Jump	Tail,%(bit+1)


;       We expect a copy token to be at [esi+bit+1].  This means that
;       esi+bit+1+tokensize must be <= EndOfCompressedBufferPlus1
TailCopy&bit:
        lea     ecx,[esi+bit+3]         ; (ecx) = next input position
        cmp     ecx,EndOfCompressedBufferPlus1  ; do we go too far
        ja      DOA                     ; yes, we are beyond the end of buffer

	DoCopy	Tail,bit,N		; perform copy

        Jump	Tail,%(bit+1)

	AdjustWidth Tail,bit

endm

	subttl	"Decompress a buffer"
;++
;
; NTSTATUS
; LZNT1DecompressChunk (
;     OUT PUCHAR UncompressedBuffer,
;     IN PUCHAR EndOfUncompressedBufferPlus1,
;     IN PUCHAR CompressedBuffer,
;     IN PUCHAR EndOfCompressedBufferPlus1,
;     OUT PULONG FinalUncompressedChunkSize
;     )
;
; Routine Description:
;
;    This function decodes a stream of compression tokens and places the
;    resultant output into the destination buffer.  The format of the input
;    is described ..\lznt1.c.  As the input is decoded, checks are made to
;    ensure that no data is read past the end of the compressed input buffer
;    and that no data is stored past the end of the output buffer.  Violations
;    indicate corrupt input and are indicated by a status return.
;
;    The following code takes advantage of two distinct observations.
;    First, literal tokens occur at least twice as often as copy tokens.
;    This argues for having a "fall-through" being the case where a literal
;    token is found.  We structure the main decomposition loop in eight
;    pieces where the first piece is a sequence of literal-test fall-throughs
;    and the remainder are a copy token followed by 7,6,...,0 literal-test
;    fall-throughs.  Each test examines a particular bit in the tag byte
;    and jumps to the relevant code piece.
;
;    The second observation involves performing bounds checking only
;    when needed.  Bounds checking the compressed buffer need only be done
;    when fetching the tag byte.  If there is not enough room left in the
;    input for a tag byte and 8 (worst case) copy tokens, a branch is made
;    to a second loop that handles a byte-by-byte "safe" copy to finish
;    up the decompression.  Similarly, at the head of the loop a check is
;    made to ensure that there is enough room in the output buffer for 8
;    literal bytes.  If not enough room is left, then the second loop is
;    used.  Finally, after performing each copy, the output-buffer check
;    is made as well since a copy may take the destination pointer
;    arbitrarily close to the end of the destination.
;
;    The register conventions used in the loops below are:
;
;	    (al)    contains the current tag byte
;	    (ebx)   contains the current width in bits of the length given
;		    the maximum offset
;		    that can be utilized in a copy token.  We update this
;		    value only prior to performing a copy.  This width is used
;		    both to index a mask table (for extracting the length) as
;		    well as shifting (for extracting the copy offset)
;	    (ecx)   is used to contain counts during copies
;	    (edx)   is used as a temp variable during copies
;	    (esi)   is used mainly as the source of the next compressed token.
;		    It is also used for copies.
;	    (edi)   is used as the destination of literals and copies
;	    (ebp)   is used as a frame pointer
;
; Arguments:
;
;    UncompressedBuffer (rcx) - pointer to destination of uncompression.
;
;    EndOfUncompressedBufferPlus1 (rdx) - pointer just beyond the
;	output buffer.	This is used for consistency checking of the stored
;	compressed data.
;
;    CompressedBuffer (r8) - pointer to compressed source.	This pointer
;       has been adjusted by the caller to point past the header word, so
;       the pointer points to the first tag byte describing which of the
;	following tokens are literals and which are copy groups.
;
;    EndOfCompressedBufferPlus1 (r9) - pointer just beyond end of input
;	buffer.  This is used to terminate the decompression.
;
;    FinalUncompressedChunkSize (rsp + 32) - pointer to a returned decompressed
;	size.  This has meaningful data ONLY when LZNT1DecompressChunk returns
;	STATUS_SUCCESS
;
; Return Value:
;
;    STATUS_SUCCESS is returned only if the decompression consumes thee entire
;	input buffer and does not exceed the output buffer.
;
;    STATUS_BAD_COMPRESSION_BUFFER is returned when the output buffer would be
;	overflowed.
;
;--

Temp			      equ qword ptr [rsp + (5 * 8)]
WidthBoundary		      equ rbp
EndOfUncompressedBufferPlus1  equ r8
EndOfCompressedBufferPlus1    equ r9
UncompressedBuffer	      equ r10
EndOfSpecialDest	      equ r11
FinalUncompressedChunkSize    equ qword ptr [rsp + (9 * 8)]


        NESTED_ENTRY _LZNT1DecompressChunk, _TEXT$00

        push_reg rsi                    ; save nonvolatile registers
        push_reg rdi                    ;
        push_reg rbx                    ;
        push_reg rbp                    ;

        END_PROLOGUE

        mov     rdi, rcx                ; set uncompressed destination address
        mov     UncompressedBuffer, rcx ; save uncompressed destination address
        mov     rsi, r8                 ; set compressed source address
        mov     EndOfUncompressedBufferPlus1, rdx ; set end of uncompressed buffer
	sub	EndOfCompressedBufferPlus1, 1 + 2 * 8 ; make room for special source
	sub	rdx, 8			; compute beginning of special
	mov	EndOfSpecialDest, rdx	; set special tail addrsss
	mov	WidthBoundary, rdi	; force initial width mismatch
	mov	ebx, 13			; initial width of output

Top:	cmp	esi,EndOfCompressedBufferPlus1	; Will this be the last tag group in source?
	jae	DoTail			; yes, go handle specially
	cmp	edi,EndOfSpecialDest	; are we too close to end of buffer?
	jae	DoTail			; yes, go skip to end

	mov	al,byte ptr [esi]	; (al) = tag byte, (esi) points to token

	irpc	i,<01234567>
	    TestLiteralAt   Copy,%(i),Y
	endm

	add	esi,9
	add	edi,8

	jmp	Top
;		       ; Width of offset    Width of length
WidthTab    dd	0FFFFh ;	16		   0
	    dd	0FFFFh ;	15		   1
	    dd	0FFFFh ;	14		   2
	    dd	0FFFFh ;	13		   3
	    dd	0FFFFh ;	12		   4
	    dd	2048   ;	11		   5
	    dd	1024   ;	10		   6
	    dd	512    ;	9		   7
	    dd	256    ;	8		   8
	    dd	128    ;	7		   9
	    dd	64     ;	6		   10
	    dd	32     ;	5		   11
	    dd	16     ;	4		   12
	    dd	0      ;	3		   13
	    dd	0      ;	2		   14
	    dd	0      ;	1		   15
	    dd	0      ;	0		   16


;				    ;
MaskTab     dd	0000000000000000b   ;	     0
	    dd	0000000000000001b   ;	     1
	    dd	0000000000000011b   ;	     2
	    dd	0000000000000111b   ;	     3
	    dd	0000000000001111b   ;	     4
	    dd	0000000000011111b   ;	     5
	    dd	0000000000111111b   ;	     6
	    dd	0000000001111111b   ;	     7
	    dd	0000000011111111b   ;	     8
	    dd	0000000111111111b   ;	     9
	    dd	0000001111111111b   ;	     10
	    dd	0000011111111111b   ;	     11
	    dd	0000111111111111b   ;	     12
	    dd	0001111111111111b   ;	     13
	    dd	0011111111111111b   ;	     14
	    dd	0111111111111111b   ;	     15
	    dd	1111111111111111b   ;	     16


	irpc	i,<01234567>
	    GenerateBlock   %(i)
	endm

;	We're handling a tail specially for this.  We must check at all
;	spots for running out of input as well as overflowing output.
;
;	(esi) = pointer to possible next tag

DoTail: add	EndOfCompressedBufferPlus1,1+2*8    ; point to end of compressed input

TailLoop:
	cmp	esi,EndOfCompressedBufferPlus1	; are we totally done?
	jz	Done			; yes, go return
	mov	al,byte ptr [esi]	; (al) = tag byte

	jmp	Tail0

	irpc	i,<01234567>
	    GenerateTailBlock	i
	endm

Tail8:	add	esi,9
	jmp	short TailLoop          ;



DOA:	mov	eax,STATUS_BAD_COMPRESSION_BUFFER
	jmp	Final

Done:	mov	eax,edi 		; (eax) = pointer to next byte to store
	sub	eax,UncompressedBuffer	; (eax) = length of uncompressed
	mov	edi,FinalUncompressedChunkSize	; (edi) = user return value location
	mov	[edi],eax		; return total transfer size to user
	xor	eax,eax 		; (eax) = STATUS_SUCCESS

Final:	pop     rbp                     ; restore nonvolatile registers
        pop     rbx                     ;
        pop     rdi                     ;
        pop     rsi                     ;
        retq                            ;

        NESTED_END LZNT1DecompressChunk, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\misalign.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    miaslign.c

Abstract:

    This module implements __misaligned_access(). 

Author:

    Forrest Foltz (forrestf) 26-Jun-2002

Revision History:


--*/

#include "ntrtlp.h"


VOID
__misaligned_access (
    IN PVOID Address,
    IN LONG Size,
    IN LONG Alignment,
    IN BOOLEAN Write
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\exdsptch.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

Author:

    David N. Cutler (davec) 26-Oct-2000

Environment:

    Any mode.

--*/

#include "ntrtlp.h"

#if defined(NTOS_KERNEL_RUNTIME)

//
// Define function address table for kernel mode.
//
// This table is used to initialize the global history table.
//

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    );

VOID
KiExceptionDispatch (
    VOID
    );

PVOID RtlpFunctionAddressTable[] = {
    &KiExceptionDispatch,
    &KiDispatchException,
    &RtlDispatchException,
    &RtlpExecuteHandlerForException,
    &__C_specific_handler,
    &RtlUnwindEx,
    NULL
    };

#else

VOID
KiUserExceptionDispatch (
    VOID
    );

PVOID RtlpFunctionAddressTable[] = {
    &KiUserExceptionDispatch,
    &RtlDispatchException,
    &RtlpExecuteHandlerForException,
    &__C_specific_handler,
    &RtlUnwindEx,
    NULL
    };

#endif

//
// ****** temp - define elsewhere ******
//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define LEA_OP 0x8d
#define POP_OP 0x58
#define RET_OP 0xc3

//
// Define lookup table for providing the number of slots used by each unwind
// code.
// 

UCHAR RtlpUnwindOpSlotTable[] = {
    1,          // UWOP_PUSH_NONVOL
    2,          // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
    1,          // UWOP_ALLOC_SMALL
    1,          // UWOP_SET_FPREG
    2,          // UWOP_SAVE_NONVOL
    3,          // UWOP_SAVE_NONVOL_FAR
    2,          // UWOP_SAVE_XMM
    3,          // UWOP_SAVE_XMM_FAR
    2,          // UWOP_SAVE_XMM128
    3,          // UWOP_SAVE_XMM128_FAR
    1           // UWOP_PUSH_MACHFRAME
};

//
// Define forward referenced function prototypes.
//

VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    );

BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a frame based
    handler by searching backwards through the stack based call frames.
    The search begins with the frame specified in the context record and
    continues backward until either a handler is found that handles the
    exception, the stack is found to be invalid (i.e., out of limits or
    unaligned), or the end of the call hierarchy is reached.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called. If the
    handler does not handle the exception, then the prologue of the routine
    is executed backwards to "unwind" the effect of the prologue and then
    the next frame is examined.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    CONTEXT ContextRecord1;
    ULONG64 ControlPc;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    ULONG64 EstablisherFrame;
    ULONG ExceptionFlags;
    PEXCEPTION_ROUTINE ExceptionRoutine;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    PUNWIND_HISTORY_TABLE HistoryTable;
    ULONG64 ImageBase;
    ULONG Index;
    ULONG64 LowLimit;
    ULONG64 NestedFrame;
    UNWIND_HISTORY_TABLE UnwindTable;

    //
    // Attempt to dispatch the exception using a vectored exception handler.
    //

#if !defined(NTOS_KERNEL_RUNTIME)

    if (RtlCallVectoredExceptionHandlers(ExceptionRecord, ContextRecord) != FALSE) {
        return TRUE;
    }

#endif

    //
    // Get current stack limits, copy the context record, get the initial
    // PC value, capture the exception flags, and set the nested exception
    // frame pointer.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlpCopyContext(&ContextRecord1, ContextRecord);
    ControlPc = (ULONG64)ExceptionRecord->ExceptionAddress;
    ExceptionFlags = ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE;
    NestedFrame = 0;

    //
    // Initialize the unwind history table.
    //

    HistoryTable = &UnwindTable;
    HistoryTable->Count = 0;
    HistoryTable->Search = UNWIND_HISTORY_TABLE_NONE;
    HistoryTable->LowAddress = - 1;
    HistoryTable->HighAddress = 0;

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handle the exception.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //

        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the current routine to obtain the virtual
        // frame pointer of the establisher and check if there is an exception
        // handler for the frame.
        //

        if (FunctionEntry != NULL) {
            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_EHANDLER,
                                                ImageBase,
                                                ControlPc,
                                                FunctionEntry,
                                                &ContextRecord1,
                                                &HandlerData,
                                                &EstablisherFrame,
                                                NULL);

            //
            // If the establisher frame pointer is not within the specified
            // stack limits or the established frame pointer is unaligned,
            // then set the stack invalid flag in the exception record and
            // return exception not handled. Otherwise, check if the current
            // routine has an exception handler.
            //

            if ((EstablisherFrame < LowLimit) ||
                (EstablisherFrame > HighLimit) ||
                ((EstablisherFrame & 0x7) != 0)) {

                ExceptionFlags |= EXCEPTION_STACK_INVALID;
                break;

            } else if (ExceptionRoutine != NULL) {

                //
                // The frame has an exception handler.
                //
                // A linkage routine written in assembler is used to actually
                // call the actual exception handler. This is required by the
                // exception handler that is associated with the linkage
                // routine so it can have access to two sets of dispatcher
                // context when it is called.
                //

                do {

                    //
                    // Log the exception if exception logging is enabled.
                    //
    
                    ExceptionRecord->ExceptionFlags = ExceptionFlags;
                    if ((NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) != 0) {
                        Index = RtlpLogExceptionHandler(ExceptionRecord,
                                                        &ContextRecord1,
                                                        ControlPc,
                                                        FunctionEntry,
                                                        sizeof(RUNTIME_FUNCTION));
                    }

                    //
                    // Clear collided unwind, set the dispatcher context, and
                    // call the exception handler.
                    //

                    ExceptionFlags &= ~EXCEPTION_COLLIDED_UNWIND;
                    DispatcherContext.ControlPc = ControlPc;
                    DispatcherContext.ImageBase = ImageBase;
                    DispatcherContext.FunctionEntry = FunctionEntry;
                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.ContextRecord = &ContextRecord1;
                    DispatcherContext.LanguageHandler = ExceptionRoutine;
                    DispatcherContext.HandlerData = HandlerData;
                    DispatcherContext.HistoryTable = HistoryTable;
                    Disposition =
                        RtlpExecuteHandlerForException(ExceptionRecord,
                                                       EstablisherFrame,
                                                       ContextRecord,
                                                       &DispatcherContext);
    
                    if ((NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) != 0) {
                        RtlpLogLastExceptionDisposition(Index, Disposition);
                    }
    
                    //
                    // Propagate noncontinuable exception flag.
                    //
    
                    ExceptionFlags |=
                        (ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE);

                    //
                    // If the current scan is within a nested context and the
                    // frame just examined is the end of the nested region,
                    // then clear the nested context frame and the nested
                    // exception flag in the exception flags.
                    //
    
                    if (NestedFrame == EstablisherFrame) {
                        ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
                        NestedFrame = 0;
                    }
    
                    //
                    // Case on the handler disposition.
                    //
    
                    switch (Disposition) {
    
                        //
                        // The disposition is to continue execution.
                        //
                        // If the exception is not continuable, then raise
                        // the exception STATUS_NONCONTINUABLE_EXCEPTION.
                        // Otherwise return exception handled.
                        //
    
                    case ExceptionContinueExecution :
                        if ((ExceptionFlags & EXCEPTION_NONCONTINUABLE) != 0) {
                            RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
    
                        } else {
                            return TRUE;
                        }
    
                        //
                        // The disposition is to continue the search.
                        //
                        // Get next frame address and continue the search.
                        //
    
                    case ExceptionContinueSearch :
                        break;
    
                        //
                        // The disposition is nested exception.
                        //
                        // Set the nested context frame to the establisher frame
                        // address and set the nested exception flag in the
                        // exception flags.
                        //
    
                    case ExceptionNestedException :
                        ExceptionFlags |= EXCEPTION_NESTED_CALL;
                        if (DispatcherContext.EstablisherFrame > NestedFrame) {
                            NestedFrame = DispatcherContext.EstablisherFrame;
                        }
    
                        break;

                        //
                        // The dispostion is collided unwind.
                        //
                        // A collided unwind occurs when an exception dispatch
                        // encounters a previous call to an unwind handler. In
                        // this case the previous unwound frames must be skipped.
                        //

                    case ExceptionCollidedUnwind:
                        ControlPc = DispatcherContext.ControlPc;
                        ImageBase = DispatcherContext.ImageBase;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        RtlpCopyContext(&ContextRecord1,
                                        DispatcherContext.ContextRecord);

                        ExceptionRoutine = DispatcherContext.LanguageHandler;
                        HandlerData = DispatcherContext.HandlerData;
                        HistoryTable = DispatcherContext.HistoryTable;
                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
                        break;

                        //
                        // All other disposition values are invalid.
                        //
                        // Raise invalid disposition exception.
                        //
    
                    default :
                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
                    }

                } while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);
            }

        } else {

            //
            // If the old control PC is the same as the return address,
            // then no progress is being made and the function tables are
            // most likely malformed.
            //
    
            if (ControlPc == *(PULONG64)(ContextRecord1.Rsp)) {
                break;
            }
    
            //
            // Set the point where control left the current function by
            // obtaining the return address from the top of the stack.
            //

            ContextRecord1.Rip = *(PULONG64)(ContextRecord1.Rsp);
            ContextRecord1.Rsp += 8;
        }

        //
        // Set point at which control left the previous routine.
        //

        ControlPc = ContextRecord1.Rip;
    } while ((ULONG64)ContextRecord1.Rsp < HighLimit);

    //
    // Set final exception flags and return exception not handled.
    //

    ExceptionRecord->ExceptionFlags = ExceptionFlags;
    return FALSE;
}

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;

    //
    // Call real unwind routine specifying a local context record and history
    // table address as extra arguments.
    //

    RtlUnwindEx(TargetFrame,
                TargetIp,
                ExceptionRecord,
                ReturnValue,
                &ContextRecord,
                NULL);

    return;
}

VOID
RtlUnwindEx (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue,
    IN PCONTEXT OriginalContext,
    IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

    OriginalContext - Supplies a pointer to a context record that can be used
        to store context druing the unwind operation.

    HistoryTable - Supplies an optional pointer to an unwind history table.

Return Value:

    None.

--*/

{

    ULONG64 ControlPc;
    PCONTEXT CurrentContext;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    ULONG64 EstablisherFrame;
    ULONG ExceptionFlags;
    EXCEPTION_RECORD ExceptionRecord1;
    PEXCEPTION_ROUTINE ExceptionRoutine;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    CONTEXT LocalContext;
    ULONG64 LowLimit;
    PCONTEXT PreviousContext;
    PCONTEXT TempContext;

    //
    // Get current stack limits, capture the current context, virtually
    // unwind to the caller of this routine, get the initial PC value, and
    // set the unwind target address.
    //

    CurrentContext = OriginalContext;
    PreviousContext = &LocalContext;
    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext(CurrentContext);

    //
    // If a history table is specified, then set to search history table.
    //

    if (ARGUMENT_PRESENT(HistoryTable)) {
        HistoryTable->Search = UNWIND_HISTORY_TABLE_GLOBAL;
    }

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = (PVOID)CurrentContext->Rip;
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then a normal unwind
    // is being performed. Otherwise, an exit unwind is being performed.
    //

    ExceptionFlags = EXCEPTION_UNWINDING;
    if (ARGUMENT_PRESENT(TargetFrame) == FALSE) {
        ExceptionFlags |= EXCEPTION_EXIT_UNWIND;
    }

    //
    // Scan backward through the call frame hierarchy and call exception
    // handlers until the target frame of the unwind is reached.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //

        ControlPc = CurrentContext->Rip;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the routine to obtain the virtual frame
        // pointer of the establisher, but don't update the context record.
        //

        if (FunctionEntry != NULL) {
            RtlpCopyContext(PreviousContext, CurrentContext);
            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_UHANDLER,
                                                ImageBase,
                                                ControlPc,
                                                FunctionEntry,
                                                PreviousContext,
                                                &HandlerData,
                                                &EstablisherFrame,
                                                NULL);

            //
            // If the establisher frame pointer is not within the specified
            // stack limits, the establisher frame pointer is unaligned, or
            // the target frame is below the establisher frame and an exit
            // unwind is not being performed, then raise a bad stack status.
            // Otherwise, check to determine if the current routine has an
            // exception handler.
            //

            if ((EstablisherFrame < LowLimit) ||
                (EstablisherFrame > HighLimit) ||
                ((ARGUMENT_PRESENT(TargetFrame) != FALSE) &&
                 ((ULONG64)TargetFrame < EstablisherFrame)) ||
                ((EstablisherFrame & 0x7) != 0)) {

                RtlRaiseStatus(STATUS_BAD_STACK);

            } else if (ExceptionRoutine != NULL) {

                //
                // The frame has a exception handler.
                //
                // A linkage routine written in assembler is used to actually
                // call the actual exception handler. This is required by the
                // exception handler that is associated with the linkage
                // routine so it can have access to two sets of dispatcher
                // context when it is called.
                //

                DispatcherContext.TargetIp = (ULONG64)TargetIp;
                do {

                    //
                    // If the establisher frame is the target of the unwind
                    // operation, then set the target unwind flag.
                    //

                    if ((ULONG64)TargetFrame == EstablisherFrame) {
                        ExceptionFlags |= EXCEPTION_TARGET_UNWIND;
                    }

                    ExceptionRecord->ExceptionFlags = ExceptionFlags;

                    //
                    // Set the specified return value and target IP in case
                    // the exception handler directly continues execution.
                    //

                    CurrentContext->Rax = (ULONG64)ReturnValue;

                    //
                    // Set the dispatcher context and call the termination
                    // handler.
                    //

                    DispatcherContext.ControlPc = ControlPc;
                    DispatcherContext.ImageBase = ImageBase;
                    DispatcherContext.FunctionEntry = FunctionEntry;
                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.ContextRecord = CurrentContext;
                    DispatcherContext.LanguageHandler = ExceptionRoutine;
                    DispatcherContext.HandlerData = HandlerData;
                    DispatcherContext.HistoryTable = HistoryTable;
                    Disposition =
                        RtlpExecuteHandlerForUnwind(ExceptionRecord,
                                                    EstablisherFrame,
                                                    CurrentContext,
                                                    &DispatcherContext);

                    //
                    // Clear target unwind and collided unwind flags.
                    //

                    ExceptionFlags &=
                        ~(EXCEPTION_COLLIDED_UNWIND | EXCEPTION_TARGET_UNWIND);

                    //
                    // Case on the handler disposition.
                    //

                    switch (Disposition) {

                        //
                        // The disposition is to continue the search.
                        //
                        // If the target frame has not been reached, then
                        // swap context pointers.
                        //

                    case ExceptionContinueSearch :
                        if (EstablisherFrame != (ULONG64)TargetFrame) {
                            TempContext = CurrentContext;
                            CurrentContext = PreviousContext;
                            PreviousContext = TempContext;
                        }

                        break;

                        //
                        // The disposition is collided unwind.
                        //
                        // Copy the context of the previous unwind and
                        // virtually unwind to the caller of the extablisher,
                        // then set the target of the current unwind to the
                        // dispatcher context of the previous unwind, and
                        // reexecute the exception handler from the collided
                        // frame with the collided unwind flag set in the
                        // exception record.
                        //

                    case ExceptionCollidedUnwind :
                        ControlPc = DispatcherContext.ControlPc;
                        ImageBase = DispatcherContext.ImageBase;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        RtlpCopyContext(OriginalContext,
                                        DispatcherContext.ContextRecord);

                        CurrentContext = OriginalContext;
                        PreviousContext = &LocalContext;
                        RtlpCopyContext(PreviousContext, CurrentContext);
                        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                         ImageBase,
                                         ControlPc,
                                         FunctionEntry,
                                         PreviousContext,
                                         &HandlerData,
                                         &EstablisherFrame,
                                         NULL);

                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        ExceptionRoutine = DispatcherContext.LanguageHandler;
                        HandlerData = DispatcherContext.HandlerData;
                        HistoryTable = DispatcherContext.HistoryTable;
                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
                        break;

                        //
                        // All other disposition values are invalid.
                        //
                        // Raise invalid disposition exception.
                        //

                    default :
                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
                    }

                } while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

            } else {

                //
                // If the target frame has not been reached, then swap
                // context pointers.
                //

                if (EstablisherFrame != (ULONG64)TargetFrame) {
                    TempContext = CurrentContext;
                    CurrentContext = PreviousContext;
                    PreviousContext = TempContext;
                }
            }

        } else {

            //
            // Set the point where control left the current function by
            // obtaining the return address from the top of the stack.
            //

            CurrentContext->Rip = *(PULONG64)(CurrentContext->Rsp);
            CurrentContext->Rsp += 8;
        }

    } while ((EstablisherFrame < HighLimit) &&
            (EstablisherFrame != (ULONG64)TargetFrame));

    //
    // If the establisher stack pointer is equal to the target frame pointer,
    // then continue execution. Otherwise, an exit unwind was performed or the
    // target of the unwind did not exist and the debugger and subsystem are
    // given a second chance to handle the unwind.
    //

    if (EstablisherFrame == (ULONG64)TargetFrame) {
        CurrentContext->Rax = (ULONG64)ReturnValue;
        if (ExceptionRecord->ExceptionCode != STATUS_UNWIND_CONSOLIDATE) {
            CurrentContext->Rip = (ULONG64)TargetIp;
        }

        RtlRestoreContext(CurrentContext, ExceptionRecord);

    } else {

        //
        // If the old control PC is the same as the new control PC, then
        // no progress is being made and the function tables are most likely
        // malformed. Otherwise, give the debugger and subsystem a second
        // chance to handle the exception.

        if (ControlPc == CurrentContext->Rip) {
            RtlRaiseStatus(STATUS_BAD_FUNCTION_TABLE);

        } else {
            ZwRaiseException(ExceptionRecord, CurrentContext, FALSE);
        }
    }
}

PRUNTIME_FUNCTION
RtlpUnwindPrologue (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN ULONG64 FrameBase,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function processes unwind codes and reverses the state change
    effects of a prologue. If the specified unwind information contains
    chained unwind information, then that prologue is unwound recursively.
    As the prologue is unwound state changes are recorded in the specified
    context structure and optionally in the specified context pointers
    structures.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FrameBase - Supplies the base of the stack frame subject function stack
         frame.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

--*/

{

    PM128 FloatingAddress;
    PM128 FloatingRegister;
    ULONG FrameOffset;
    ULONG Index;
    PULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    BOOLEAN MachineFrame;
    ULONG OpInfo;
    ULONG PrologOffset;
    PULONG64 RegisterAddress;
    PULONG64 ReturnAddress;
    PULONG64 StackAddress;
    PUNWIND_CODE UnwindCode;
    PUNWIND_INFO UnwindInfo;
    ULONG UnwindOp;

    //
    // Process the unwind codes.
    //

    FloatingRegister = &ContextRecord->Xmm0;
    IntegerRegister = &ContextRecord->Rax;
    Index = 0;
    MachineFrame = FALSE;
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    while (Index < UnwindInfo->CountOfCodes) {

        //
        // If the prologue offset is greater than the next unwind code offset,
        // then simulate the effect of the unwind code.
        //

        UnwindOp = UnwindInfo->UnwindCode[Index].UnwindOp;
        OpInfo = UnwindInfo->UnwindCode[Index].OpInfo;
        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            switch (UnwindOp) {

                //
                // Push nonvolatile integer register.
                //
                // The operation information is the register number of the
                // register than was pushed.
                //

            case UWOP_PUSH_NONVOL:
                IntegerAddress = (PULONG64)(ContextRecord->Rsp);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                break;

                //
                // Allocate a large sized area on the stack.
                //
                // The operation information determines if the size is
                // 16- or 32-bits.
                //

            case UWOP_ALLOC_LARGE:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset;
                if (OpInfo != 0) {
                    Index += 1;
                    FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);

                } else {
                    FrameOffset *= 8;
                }

                ContextRecord->Rsp += FrameOffset;
                break;

                //
                // Allocate a small sized area on the stack.
                //
                // The operation information is the size of the unscaled
                // allocation size (8 is the scale factor) minus 8.
                //

            case UWOP_ALLOC_SMALL:
                ContextRecord->Rsp += (OpInfo * 8) + 8;
                break;

                //
                // Establish the the frame pointer register.
                //
                // The operation information is not used.
                //

            case UWOP_SET_FPREG:
                ContextRecord->Rsp = IntegerRegister[UnwindInfo->FrameRegister];
                ContextRecord->Rsp -= UnwindInfo->FrameOffset * 16;
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 16-bit displacment.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_NONVOL:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                IntegerAddress = (PULONG64)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 32-bit displacment.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_NONVOL_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                IntegerAddress = (PULONG64)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                FloatingAddress = (PM128)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = 0;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = (PM128)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = 0;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM128:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 16;
                FloatingAddress = (PM128)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM128_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = (PM128)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Push a machine frame on the stack.
                //
                // The operation information determines whether the machine
                // frame contains an error code or not.
                //

            case UWOP_PUSH_MACHFRAME:
                MachineFrame = TRUE;
                ReturnAddress = (PULONG64)(ContextRecord->Rsp);
                StackAddress = (PULONG64)(ContextRecord->Rsp + (3 * 8));
                if (OpInfo != 0) {
                    ReturnAddress += 1;
                    StackAddress +=  1;
                }

                ContextRecord->Rip = *ReturnAddress;
                ContextRecord->Rsp = *StackAddress;
                break;

                //
                // Unused codes.
                //

            default:
                break;
            }

            Index += 1;

        } else {

            //
            // Skip this unwind operation by advancing the slot index by the
            // number of slots consumed by this operation.
            //

            Index += RtlpUnwindOpSlotTable[UnwindOp];

            //
            // Special case any unwind operations that can consume a variable
            // number of slots.
            // 

            switch (UnwindOp) {

                //
                // A non-zero operation information indicates that an
                // additional slot is consumed.
                //

            case UWOP_ALLOC_LARGE:
                if (OpInfo != 0) {
                    Index += 1;
                }

                break;

                //
                // No other special cases.
                //

            default:
                break;
            }
        }
    }

    //
    // If chained unwind information is specified, then recursively unwind
    // the chained information. Otherwise, determine the return address if
    // a machine frame was not encountered during the scan of the unwind
    // codes.
    //

    if ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) != 0) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        FunctionEntry = (PRUNTIME_FUNCTION)(*(PULONG *)(&UnwindInfo->UnwindCode[Index]) + ImageBase);
        return RtlpUnwindPrologue(ImageBase,
                                  ControlPc,
                                  FrameBase,
                                  FunctionEntry,
                                  ContextRecord,
                                  ContextPointers);

    } else {
        if (MachineFrame == FALSE) {
            ContextRecord->Rip = *(PULONG64)(ContextRecord->Rsp);
            ContextRecord->Rsp += 8;
        }

        return FunctionEntry;
    }
}

PEXCEPTION_ROUTINE
RtlVirtualUnwind (
    IN ULONG HandlerType,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PVOID *HandlerData,
    OUT PULONG64 EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backward or its epilogue code forward.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    HandlerType - Supplies the handler type expected for the virtual unwind.
        This may be either an exception or an unwind handler.

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    HandlerData - Supplies a pointer to a variable that receives a pointer
        the the language handler data.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    If control did not leave the specified function in either the prologue
    or an epilogue and a handler of the proper type is associated with the
    function, then the address of the language specific exception handler
    is returned. Otherwise, NULL is returned.

--*/

{

    ULONG64 BranchTarget;
    LONG Displacement;
    ULONG FrameRegister;
    ULONG Index;
    LOGICAL InEpilogue;
    PULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    PUCHAR NextByte;
    ULONG PrologOffset;
    ULONG RegisterNumber;
    PUNWIND_INFO UnwindInfo;

    //
    // If the specified function does not use a frame pointer, then the
    // establisher frame is the contents of the stack pointer. This may
    // not actually be the real establisher frame if control left the
    // function from within the prologue. In this case the establisher
    // frame may be not required since control has not actually entered
    // the function and prologue entries cannot refer to the establisher
    // frame before it has been established, i.e., if it has not been
    // established, then no save unwind codes should be encountered during
    // the unwind operation.
    //
    // If the specified function uses a frame pointer and control left the
    // function outside of the prologue or the unwind information contains
    // a chained information structure, then the establisher frame is the
    // contents of the frame pointer.
    //
    // If the specified function uses a frame pointer and control left the
    // function from within the prologue, then the set frame pointer unwind
    // code must be looked up in the unwind codes to detetermine if the
    // contents of the stack pointer or the contents of the frame pointer
    // should be used for the establisher frame. This may not atually be
    // the real establisher frame. In this case the establisher frame may
    // not be required since control has not actually entered the function
    // and prologue entries cannot refer to the establisher frame before it
    // has been established, i.e., if it has not been established, then no
    // save unwind codes should be encountered during the unwind operation.
    //
    // N.B. The correctness of these assumptions is based on the ordering of
    //      unwind codes.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    if (UnwindInfo->FrameRegister == 0) {
        *EstablisherFrame = ContextRecord->Rsp;

    } else if ((PrologOffset >= UnwindInfo->SizeOfProlog) ||
               ((UnwindInfo->Flags &  UNW_FLAG_CHAININFO) != 0)) {
        *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
        *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

    } else {
        Index = 0;
        while (Index < UnwindInfo->CountOfCodes) {
            if (UnwindInfo->UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) {
                break;
            }

            Index += 1;
        }

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
            *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

        } else {
            *EstablisherFrame = ContextRecord->Rsp;
        }
    }

    //
    // Check for epilogue.
    //
    // If the point at which control left the specified function is in an
    // epilogue, then emulate the execution of the epilogue forward and
    // return no exception handler.
    //

    IntegerRegister = &ContextRecord->Rax;
    NextByte = (PUCHAR)ControlPc;

    //
    // Check for one of:
    //
    //   add rsp, imm8
    //       or
    //   add rsp, imm32
    //       or
    //   lea rsp, -disp8[fp]
    //       or
    //   lea rsp, -disp32[fp]
    //

    if ((NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM8_OP) &&
        (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm8.
        //

        NextByte += 4;

    } else if ((NextByte[0] == SIZE64_PREFIX) &&
               (NextByte[1] == ADD_IMM32_OP) &&
               (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm32.
        //

        NextByte += 7;

    } else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
               (NextByte[1] == LEA_OP)) {

        FrameRegister = ((NextByte[0] & 0x7) << 3) | (NextByte[2] & 0x7);
        if ((FrameRegister != 0) &&
            (FrameRegister == UnwindInfo->FrameRegister)) {
            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[fp].
                //

                NextByte += 4;

            } else if ((NextByte[2] &0xf8) == 0xa0) {

                //
                // lea rsp, disp32[fp].
                //

                NextByte += 7;
            }
        }
    }

    //
    // Check for any number of:
    //
    //   pop nonvolatile-integer-register[0..15].
    //

    while (TRUE) {
        if ((NextByte[0] & 0xf8) == POP_OP) {
            NextByte += 1;

        } else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
                   ((NextByte[1] & 0xf8) == POP_OP)) {

            NextByte += 2;

        } else {
            break;
        }
    }

    //
    // If the next instruction is a return, then control is currently in
    // an epilogue and execution of the epilogue should be emulated.
    // Otherwise, execution is not in an epilogue and the prologue should
    // be unwound.
    //

    InEpilogue = FALSE;
    if (NextByte[0] == RET_OP) {

        //
        // A return is an unambiguous indication of an epilogue
        //

        InEpilogue = TRUE;

    } else if (NextByte[0] == JMP_IMM8_OP || NextByte[0] == JMP_IMM32_OP) {

        //
        // An unconditional branch to a target that is equal to the start of
        // or outside of this routine is logically a call to another function.
        // 

        BranchTarget = (ULONG64)NextByte - ImageBase;
        if (NextByte[0] == JMP_IMM8_OP) {
            BranchTarget += 2 + (CHAR)NextByte[1];

        } else {
            BranchTarget += 5 + *((LONG UNALIGNED *)&NextByte[1]);
        }

        //
        // Now determine whether the branch target refers to code within this
        // function. If not, then it is an epilogue indicator.
        //

        if (BranchTarget <= FunctionEntry->BeginAddress ||
            BranchTarget > FunctionEntry->EndAddress) {

            InEpilogue = TRUE;
        }
    }

    if (InEpilogue != FALSE) {
        NextByte = (PUCHAR)ControlPc;

        //
        // Emulate one of (if any):
        //
        //   add rsp, imm8
        //       or
        //   add rsp, imm32
        //       or                
        //   lea rsp, disp8[frame-register]
        //       or
        //   lea rsp, disp32[frame-register]
        //

        if ((NextByte[0] & 0xf8) == SIZE64_PREFIX) {
    
            if (NextByte[1] == ADD_IMM8_OP) {
    
                //
                // add rsp, imm8.
                //
    
                ContextRecord->Rsp += (CHAR)NextByte[3];
                NextByte += 4;
    
            } else if (NextByte[1] == ADD_IMM32_OP) {
    
                //
                // add rsp, imm32.
                //
    
                Displacement = NextByte[3] | (NextByte[4] << 8);
                Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                ContextRecord->Rsp += Displacement;
                NextByte += 7;
    
            } else if (NextByte[1] == LEA_OP) {
                if ((NextByte[2] & 0xf8) == 0x60) {
    
                    //
                    // lea rsp, disp8[frame-register].
                    //
    
                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += (CHAR)NextByte[3];
                    NextByte += 4;
    
                } else if ((NextByte[2] & 0xf8) == 0xa0) {
    
                    //
                    // lea rsp, disp32[frame-register].
                    //
    
                    Displacement = NextByte[3] | (NextByte[4] << 8);
                    Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += Displacement;
                    NextByte += 7;
                }
            }
        }

        //
        // Emulate any number of (if any):
        //
        //   pop nonvolatile-integer-register.
        //

        while (TRUE) {
            if ((NextByte[0] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[0..7]
                //

                RegisterNumber = NextByte[0] & 0x7;
                IntegerAddress = (PULONG64)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 1;

            } else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
                       ((NextByte[1] & 0xf8) == POP_OP)) {

                //
                // pop nonvolatile-integer-regiser[8..15]
                //

                RegisterNumber = ((NextByte[0] & 1) << 3) | (NextByte[1] & 0x7);
                IntegerAddress = (PULONG64)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 2;

            } else {
                break;
            }
        }

        //
        // Emulate return and return null exception handler.
        //
        // Note: this instruction might in fact be a jmp, however
        //       we want to emulate a return regardless.
        //

        ContextRecord->Rip = *(PULONG64)(ContextRecord->Rsp);
        ContextRecord->Rsp += 8;
        return NULL;
    }

    //
    // Control left the specified function outside an epilogue. Unwind the
    // subject function and any chained unwind information.
    //

    FunctionEntry = RtlpUnwindPrologue(ImageBase,
                                       ControlPc,
                                       *EstablisherFrame,
                                       FunctionEntry,
                                       ContextRecord,
                                       ContextPointers);

    //
    // If control left the specified function outside of the prologue and
    // the function has a handler that matches the specified type, then
    // return the address of the language specific exception handler.
    // Otherwise, return NULL.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    if ((PrologOffset >= UnwindInfo->SizeOfProlog) &&
        ((UnwindInfo->Flags & HandlerType) != 0)) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        *HandlerData = &UnwindInfo->UnwindCode[Index + 2];
        return (PEXCEPTION_ROUTINE)(*((PULONG)&UnwindInfo->UnwindCode[Index]) + ImageBase);

    } else {
        return NULL;
    }
}

VOID
RtlpGetStackLimits (
    OUT PULONG64 LowLimit,
    OUT PULONG64 HighLimit
    )

/*++

Routine Description:

    This function returns the current stack limits.

Arguments:

    LowLimit - Supplies a pointer to a variable that is to receive
        the low limit of the stack.

    HighLimit - Supplies a pointer to a variable that is to receive
        the high limit of the stack.

Return Value:

     None.

--*/

{

#if defined(NTOS_KERNEL_RUNTIME)

    PKTHREAD Thread;

    Thread = KeGetCurrentThread();
    *LowLimit = (ULONG64)Thread->StackLimit;
    *HighLimit = (ULONG64)Thread->StackBase;

#else

    *LowLimit = __readgsqword(FIELD_OFFSET(NT_TIB, StackLimit));
    *HighLimit = __readgsqword(FIELD_OFFSET(NT_TIB, StackBase));

#endif

    return;
}

#if !defined(NTOS_KERNEL_RUNTIME)

LIST_ENTRY RtlpDynamicFunctionTable;

PLIST_ENTRY
RtlGetFunctionTableListHead (
    VOID
    )

/*++

Routine Description:

    This function returns the address of the dynamic function table list head.

Arguments:

    None.

Return value:

    The address of the dynamic function table list head is returned.

--*/

{

    return &RtlpDynamicFunctionTable;
}

BOOLEAN
RtlAddFunctionTable (
    IN PRUNTIME_FUNCTION FunctionTable,
    IN ULONG EntryCount,
    IN ULONG64 BaseAddress
    )

/*++

Routine Description:

    This function adds a dynamic function table to the dynamic function table
    list. A dynamic function table describe code that is generated at runtime.

    The function table entries need not be sorted, however, if they are sorted
    a binary search can be employed to find a particular entry. The function
    table entries are scanned to determine is they are sorted and a minimum
    and maximum address range is computed.

Arguments:

    FunctionTable - Supplies a pointer to a function table.

    EntryCount - Supplies the number of entries in the function table.

    BaseAddress - Supplies the base address of the image containing the
        described functions.

Return value:

   If the function table is successfuly added, then a value of TRUE is
   returned. Otherwise, FALSE is returned.

--*/

{

    PRUNTIME_FUNCTION FunctionEntry;
    ULONG Index;
    PDYNAMIC_FUNCTION_TABLE NewTable;

    //
    // Allocate a new dynamic function table.
    //

    NewTable = RtlAllocateHeap(RtlProcessHeap(),
                               0,
                               sizeof(DYNAMIC_FUNCTION_TABLE));

    //
    // If the allocation is successful, then add dynamic function table.
    //

    if (NewTable != NULL) {
        NewTable->FunctionTable = FunctionTable;
        NewTable->EntryCount = EntryCount;
        NtQuerySystemTime(&NewTable->TimeStamp);

        //
        // Scan the function table for the minimum/maximum range and determine
        // if the function table entries are sorted.
        //

        FunctionEntry = FunctionTable;
        NewTable->MinimumAddress = FunctionEntry->BeginAddress;
        NewTable->MaximumAddress = FunctionEntry->EndAddress;
        NewTable->Type = RF_SORTED;
        NewTable->BaseAddress = BaseAddress;
        FunctionEntry += 1;

        for (Index = 1; Index < EntryCount; Index += 1) {
            if ((NewTable->Type == RF_SORTED) &&
                (FunctionEntry->BeginAddress < FunctionTable[Index - 1].BeginAddress)) {
                NewTable->Type = RF_UNSORTED;
            }

            if (FunctionEntry->BeginAddress < NewTable->MinimumAddress) {
                NewTable->MinimumAddress = FunctionEntry->BeginAddress;
            }

            if (FunctionEntry->EndAddress > NewTable->MaximumAddress) {
                NewTable->MaximumAddress = FunctionEntry->EndAddress;
            }

            FunctionEntry += 1;
        }

        //
        // Compute the real minimum and maximum addresses and insert the new
        // dyanmic function table in the dynamic function table list.
        //

        NewTable->MinimumAddress += BaseAddress;
        NewTable->MaximumAddress += BaseAddress;
        RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        InsertTailList(&RtlpDynamicFunctionTable, &NewTable->ListEntry);
        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlInstallFunctionTableCallback (
    IN ULONG64 TableIdentifier,
    IN ULONG64 BaseAddress,
    IN ULONG Length,
    IN PGET_RUNTIME_FUNCTION_CALLBACK Callback,
    IN PVOID Context,
    IN PCWSTR OutOfProcessCallbackDll OPTIONAL
    )

/*++

Routine Description:

    This function adds a dynamic function table to the dynamic function table
    list. A dynamic function table describe code that is generated at runtime.

Arguments:

    TableIdentifier - Supplies a value that identifies the dynamic function
        table callback.

        N.B. The two low order bits of this value must be set.

    BaseAddress - Supplies the base address of the code region covered by
        callback function.

    Length - Supplies the length of code region covered by the callback
        function.

    Callback - Supplies the address of the callback function that will be
        called to get function table entries for the functions covered by
        the specified region.

    Context - Supplies a context parameter that will be passed to the callback
        routine.

    OutOfProcessCallbackDll - Supplies an optional pointer to the path name of
        a DLL that can be used by the debugger to obtain function table entries
        from outside the process.

Return Value

    If the function table is successfully installed, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PDYNAMIC_FUNCTION_TABLE NewTable;
    SIZE_T Size;

    //
    // If the table identifier does not have the two low bits set, then return
    // FALSE.
    //
    // N.B. The two low order bits are required to be set in order to ensure
    //      that the table identifier does not collide with an actual address
    //      of a function table, i.e., this value is used to delete the entry.
    //

    if ((TableIdentifier & 0x3) != 3) {
        return FALSE;
    }

    //
    // If the length of the code region is greater than 2gb, then return
    // FALSE.
    //

    if ((LONG)Length < 0) {
        return FALSE;
    }

    //
    // Allocate a new dynamic function table.
    //

    Size = 0;
    if (ARGUMENT_PRESENT(OutOfProcessCallbackDll)) {
        Size = (wcslen(OutOfProcessCallbackDll) + 1) * sizeof(WCHAR);
    }

    NewTable = RtlAllocateHeap(RtlProcessHeap(),
                               0,
                               sizeof(DYNAMIC_FUNCTION_TABLE) + Size);

    //
    // If the allocation is successful, then add dynamic function table.
    //

    if (NewTable != NULL) {

        //
        // Initialize the dynamic function table callback entry.
        //

        NewTable->FunctionTable = (PRUNTIME_FUNCTION)TableIdentifier;
        NtQuerySystemTime(&NewTable->TimeStamp);
        NewTable->MinimumAddress = BaseAddress;
        NewTable->MaximumAddress = BaseAddress + Length;
        NewTable->BaseAddress = BaseAddress;
        NewTable->Callback = Callback;
        NewTable->Context = Context;
        NewTable->Type = RF_CALLBACK;
        NewTable->OutOfProcessCallbackDll = NULL;
        if (ARGUMENT_PRESENT(OutOfProcessCallbackDll)) {
            NewTable->OutOfProcessCallbackDll = (PWSTR)(NewTable + 1);
            wcscpy((PWSTR)(NewTable + 1), OutOfProcessCallbackDll);
        }

        //
        // Insert the new dyanamic function table in the dynamic function table
        // list.
        //

        RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        InsertTailList(&RtlpDynamicFunctionTable, &NewTable->ListEntry);
        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlDeleteFunctionTable (
    IN PRUNTIME_FUNCTION FunctionTable
    )

/*++

Routine Description:

    This function deletes a dynamic function table from the dynamic function
    table list.

Arguments:

   FunctionTable - Supplies a pointer to a function table.

Return Value

    If the function table is successfully deleted, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PDYNAMIC_FUNCTION_TABLE CurrentTable;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    BOOLEAN Status = FALSE;

    //
    // Search the dynamic function table list for a match on the the function
    // table address.
    //

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    ListHead = &RtlpDynamicFunctionTable;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {
        CurrentTable = CONTAINING_RECORD(NextEntry,
                                         DYNAMIC_FUNCTION_TABLE,
                                         ListEntry);

        if (CurrentTable->FunctionTable == FunctionTable) {
            RemoveEntryList(&CurrentTable->ListEntry);
            RtlFreeHeap(RtlProcessHeap(), 0, CurrentTable);
            Status = TRUE;
            break;
         }

         NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    return Status;
}

PRUNTIME_FUNCTION
RtlpLookupDynamicFunctionEntry (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase
    )

/*++

Routine Description:

    This function searches the dynamic function table list for an entry that
    contains the specified control PC. If a dynamic function table is located,
    then its associated function table is search for a function table entry
    that contains the specified control PC.

Arguments:

    ControlPc - Supplies the control PC that is used as the key for the search.

    ImageBase - Supplies the address of a variable that receives the image base
        if a function table entry contains the specified control PC.

Return Value

    If a function table entry cannot be located that contains the specified
    control PC, then NULL is returned. Otherwise, the address of the function
    table entry is returned and the image base is set to the base address of
    the image containing the function.

--*/

{

    ULONG64 BaseAddress;
    PGET_RUNTIME_FUNCTION_CALLBACK Callback;
    PVOID Context;
    PDYNAMIC_FUNCTION_TABLE CurrentTable;
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LONG High;
    ULONG Index;
    PLIST_ENTRY ListHead;
    LONG Low;
    LONG Middle;
    PLIST_ENTRY NextEntry;

    //
    // Search the dynamic function table list. If an entry is found that
    // contains the specified control PC, then search the assoicated function
    // table.
    //

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    ListHead = &RtlpDynamicFunctionTable;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {
        CurrentTable = CONTAINING_RECORD(NextEntry,
                                         DYNAMIC_FUNCTION_TABLE,
                                         ListEntry);

        //
        // If the control PC is within the range of this dynamic function
        // table, then search the associaed function table.
        //

        if ((ControlPc >= CurrentTable->MinimumAddress) &&
            (ControlPc <  CurrentTable->MaximumAddress)) {

            //
            // If this function table is sorted do a binary search. Otherwise,
            // do a linear search.
            //

            FunctionTable = CurrentTable->FunctionTable;
            BaseAddress = CurrentTable->BaseAddress;
            if (CurrentTable->Type == RF_SORTED) {

                //
                // Perform binary search on the function table for a function table
                // entry that contains the specified control PC.
                //

                ControlPc -= BaseAddress;
                Low = 0;
                High = CurrentTable->EntryCount - 1;
                while (High >= Low) {

                    //
                    // Compute next probe index and test entry. If the specified PC
                    // is greater than of equal to the beginning address and less
                    // than the ending address of the function table entry, then
                    // return the address of the function table entry. Otherwise,
                    // continue the search.
                    //

                    Middle = (Low + High) >> 1;
                    FunctionEntry = &FunctionTable[Middle];
                    if (ControlPc < FunctionEntry->BeginAddress) {
                        High = Middle - 1;

                    } else if (ControlPc >= FunctionEntry->EndAddress) {
                        Low = Middle + 1;

                    } else {
                        *ImageBase = BaseAddress;
                        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
                        return FunctionEntry;
                    }
                }

            } else if (CurrentTable->Type == RF_UNSORTED)  {

                //
                // Perform a linear seach on the function table for a function
                // entry that contains the specified control PC.
                //

                ControlPc -= BaseAddress;
                FunctionEntry = CurrentTable->FunctionTable;
                for (Index = 0; Index < CurrentTable->EntryCount; Index += 1) {
                    if ((ControlPc >= FunctionEntry->BeginAddress) &&
                        (ControlPc < FunctionEntry->EndAddress)) {
                        *ImageBase = BaseAddress;
                        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
                        return FunctionEntry;
                    }

                    FunctionEntry += 1;
                }

            } else {

                //
                // Perform a callback to obtain the runtime function table
                // entry that contains the specified control PC.
                //

                Callback = CurrentTable->Callback;
                Context = CurrentTable->Context;
                *ImageBase = BaseAddress;
                RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
                return (Callback)(ControlPc, Context);
            }

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    return NULL;
}

#endif

ULONG HistoryTotal = 0;
ULONG HistoryGlobal = 0;
ULONG HistoryGlobalHits = 0;
ULONG HistorySearch = 0;
ULONG HistorySearchHits = 0;
ULONG HistoryInsert = 0;
ULONG HistoryInsertHits = 0;

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase,
    IN OUT PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function searches the currently active function tables for an entry
    that corresponds to the specified control PC.

Arguments:

    ControlPc - Supplies the address of an instruction within the specified
        function.

    ImageBase - Supplies the address of a variable that receives the image base
        if a function table entry contains the specified control PC.

    HistoryTable - Supplies an optional pointer to an unwind history table.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{

    ULONG64 BaseAddress;
    ULONG64 BeginAddress;
    ULONG64 EndAddress;
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LONG High;
    ULONG Index;
    LONG Low;
    LONG Middle;
    ULONG RelativePc;
    ULONG SizeOfTable;

    //
    // Attempt to find an image that contains the specified control PC. If
    // an image is found, then search its function table for a function table
    // entry that contains the specified control PC. If an image is not found
    // then search the dynamic function table for an image that contains the
    // specified control PC.
    //
    // If a history table is supplied and search is specfied, then the current
    // operation that is being performed is the unwind phase of an exception
    // dispatch followed by a unwind. 
    //

    if ((ARGUMENT_PRESENT(HistoryTable)) &&
        (HistoryTable->Search != UNWIND_HISTORY_TABLE_NONE)) {
        HistoryTotal += 1;

        //
        // Search the global unwind history table if there is a chance of a
        // match.
        //

        if (HistoryTable->Search == UNWIND_HISTORY_TABLE_GLOBAL) {
            if ((ControlPc >= RtlpUnwindHistoryTable.LowAddress) &&
                (ControlPc < RtlpUnwindHistoryTable.HighAddress)) {

                HistoryGlobal += 1;
                for (Index = 0; Index < RtlpUnwindHistoryTable.Count; Index += 1) {
                    BaseAddress = RtlpUnwindHistoryTable.Entry[Index].ImageBase;
                    FunctionEntry = RtlpUnwindHistoryTable.Entry[Index].FunctionEntry;
                    BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                    EndAddress = FunctionEntry->EndAddress + BaseAddress;
                    if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                        *ImageBase = BaseAddress;
                        HistoryGlobalHits += 1;
                        return FunctionEntry;
                    }
                }
            }

            HistoryTable->Search = UNWIND_HISTORY_TABLE_LOCAL;
        }

        //
        // Search the dynamic unwind history table if there is a chance of a
        // match.
        //

        if ((ControlPc >= HistoryTable->LowAddress) &&
            (ControlPc < HistoryTable->HighAddress)) {
    
            HistorySearch += 1;
            for (Index = 0; Index < HistoryTable->Count; Index += 1) {
                BaseAddress = HistoryTable->Entry[Index].ImageBase;
                FunctionEntry = HistoryTable->Entry[Index].FunctionEntry;
                BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                EndAddress = FunctionEntry->EndAddress + BaseAddress;
                if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                    *ImageBase = BaseAddress;
                    HistorySearchHits += 1;
                    return FunctionEntry;
                }
            }
        }
    }

    //
    // There was not a match in either of the unwind history tables so attempt
    // to find a matching entry in the loaded module list.
    //

    FunctionTable = RtlLookupFunctionTable((PVOID)ControlPc,
                                            (PVOID *)ImageBase,
                                            &SizeOfTable);

    //
    // If a function table is located, then search for a function table
    // entry that contains the specified control PC.
    //

    if (FunctionTable != NULL) {
        Low = 0;
        High = (SizeOfTable / sizeof(RUNTIME_FUNCTION)) - 1;
        RelativePc = (ULONG)(ControlPc - *ImageBase);
        while (High >= Low) {

            //
            // Compute next probe index and test entry. If the specified
            // control PC is greater than of equal to the beginning address
            // and less than the ending address of the function table entry,
            // then return the address of the function table entry. Otherwise,
            // continue the search.
            //

            Middle = (Low + High) >> 1;
            FunctionEntry = &FunctionTable[Middle];

            if (RelativePc < FunctionEntry->BeginAddress) {
                High = Middle - 1;

            } else if (RelativePc >= FunctionEntry->EndAddress) {
                Low = Middle + 1;

            } else {
                break;
            }
        }

        if (High < Low) {
            FunctionEntry = NULL;
        }

    } else {

        //
        // There was not a match in the loaded module list so attempt to find
        // a matching entry in the dynamic function table list.
        //
    
#if !defined(NTOS_KERNEL_RUNTIME)
    
        FunctionEntry = RtlpLookupDynamicFunctionEntry(ControlPc, ImageBase);
    
#else
    
        FunctionEntry = NULL;
    
#endif  // NTOS_KERNEL_RUNTIME

    }

    //
    // If a function table entry was located, search is not specified, and
    // the specfied history table is not full, then attempt to make an entry
    // in the history table.
    //

    if (ARGUMENT_PRESENT(HistoryTable) &&
        (HistoryTable->Search == UNWIND_HISTORY_TABLE_NONE)) {

        HistoryInsert += 1;
    }

    if (FunctionEntry != NULL) {
        if (ARGUMENT_PRESENT(HistoryTable) &&
            (HistoryTable->Search == UNWIND_HISTORY_TABLE_NONE) &&
            (HistoryTable->Count < UNWIND_HISTORY_TABLE_SIZE)) {
    
            Index = HistoryTable->Count;
            HistoryTable->Count += 1;
            HistoryTable->Entry[Index].ImageBase = *ImageBase;
            HistoryTable->Entry[Index].FunctionEntry = FunctionEntry;
            BeginAddress = FunctionEntry->BeginAddress + *ImageBase;
            EndAddress = FunctionEntry->EndAddress + *ImageBase;
            if (BeginAddress < HistoryTable->LowAddress) {
                HistoryTable->LowAddress = BeginAddress;
    
            }
    
            if (EndAddress > HistoryTable->HighAddress) {
                HistoryTable->HighAddress = EndAddress;
            }

            HistoryInsertHits += 1;
        }
    }

    return FunctionEntry;
}

VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    )

/*++

Routine Description:

    This function copies the nonvolatile context required for exception
    dispatch and unwind from the specified source context record to the
    specified destination context record.

Arguments:

    Destination - Supplies a pointer to the destination context record.

    Source - Supplies a pointer to the source context record.

Return Value:

    None.

--*/

{

    //
    // Copy nonvolatile context required for exception dispatch and unwind.
    //

    Destination->Rip = Source->Rip;
    Destination->Rbx = Source->Rbx;
    Destination->Rsp = Source->Rsp;
    Destination->Rbp = Source->Rbp;
    Destination->Rsi = Source->Rsi;
    Destination->Rdi = Source->Rdi;
    Destination->R12 = Source->R12;
    Destination->R13 = Source->R13;
    Destination->R14 = Source->R14;
    Destination->R15 = Source->R15;
    Destination->Xmm6 = Source->Xmm6;
    Destination->Xmm7 = Source->Xmm7;
    Destination->Xmm8 = Source->Xmm8;
    Destination->Xmm9 = Source->Xmm9;
    Destination->Xmm10 = Source->Xmm10;
    Destination->Xmm11 = Source->Xmm11;
    Destination->Xmm12 = Source->Xmm12;
    Destination->Xmm13 = Source->Xmm13;
    Destination->Xmm14 = Source->Xmm14;
    Destination->Xmm15 = Source->Xmm15;
    Destination->SegCs = Source->SegCs;
    Destination->SegSs = Source->SegSs;
    Destination->MxCsr = Source->MxCsr;
    Destination->EFlags = Source->EFlags;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\lznt1_amd64.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LZNT1.c

Abstract:

    This module implements the LZNT1 compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:

--*/

#include "ntrtlp.h"

#include <stdio.h>


//
//  Boolean which controls whether the asserts will fire.
//

#if DBG
#if !BLDR_KERNEL_RUNTIME
BOOLEAN Lznt1Break = TRUE;
#else
BOOLEAN Lznt1Break = FALSE;
#endif
#endif

//
//  Declare the internal workspace that we need
//

typedef struct _LZNT1_STANDARD_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

    PUCHAR IndexPTable[4096][2];

} LZNT1_STANDARD_WORKSPACE, *PLZNT1_STANDARD_WORKSPACE;

typedef struct _LZNT1_MAXIMUM_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

} LZNT1_MAXIMUM_WORKSPACE, *PLZNT1_MAXIMUM_WORKSPACE;

typedef struct _LZNT1_FRAGMENT_WORKSPACE {

    UCHAR Buffer[0x1000];

} LZNT1_FRAGMENT_WORKSPACE, *PLZNT1_FRAGMENT_WORKSPACE;

typedef struct _LZNT1_HIBER_WORKSPACE {

    ULONG IndexTable[1<<12];

} LZNT1_HIBER_WORKSPACE, *PLZNT1_HIBER_WORKSPACE;

//
//  Now define the local procedure prototypes.
//

typedef ULONG (*PLZNT1_MATCH_FUNCTION) (
    );

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1CompressChunkHiber (
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    );

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    );

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlCompressBufferLZNT1_HIBER (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );


//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define MAX_UNCOMPRESSED_CHUNK_SIZE (4096)

//
//  USHORT
//  GetCompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  USHORT
//  GetUncompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  VOID
//  SetCompressedChunkHeader (
//      IN OUT COMPRESSED_CHUNK_HEADER ChunkHeader,
//      IN USHORT CompressedChunkSize,
//      IN BOOLEAN IsChunkCompressed
//      );
//

#define GetCompressedChunkSize(CH)   (       \
    (CH).Chunk.CompressedChunkSizeMinus3 + 3 \
)

#define GetUncompressedChunkSize(CH) (MAX_UNCOMPRESSED_CHUNK_SIZE)

#define SetCompressedChunkHeader(CH,CCS,ICC) {        \
    ASSERT((CCS) >= 4 && (CCS) <= 4098);              \
    (CH).Chunk.CompressedChunkSizeMinus3 = (CCS) - 3; \
    (CH).Chunk.ChunkSignature = 3;                    \
    (CH).Chunk.IsChunkCompressed = (ICC);             \
}


//
//  Local macros
//

#define FlagOn(F,SF)    ((F) & (SF))
#define SetFlag(F,SF)   { (F) |= (SF); }
#define ClearFlag(F,SF) { (F) &= ~(SF); }

#define Minimum(A,B)    ((A) < (B) ? (A) : (B))
#define Maximum(A,B)    ((A) > (B) ? (A) : (B))

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

//
// N.B. Several functions below are placed in the PAGELK section
//      because they need to be locked down in memory during Hibernation,
//      since they are used to enable compression of the Hiberfile.
//

#pragma alloc_text(PAGELK, RtlCompressWorkSpaceSizeLZNT1)
#pragma alloc_text(PAGELK, RtlCompressBufferLZNT1)
#pragma alloc_text(PAGELK, RtlCompressBufferLZNT1_HIBER)

#pragma alloc_text(PAGE, RtlDecompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressFragmentLZNT1)
#pragma alloc_text(PAGE, RtlDescribeChunkLZNT1)
#pragma alloc_text(PAGE, RtlReserveChunkLZNT1)

#pragma alloc_text(PAGELK, LZNT1CompressChunk)
#pragma alloc_text(PAGELK, LZNT1CompressChunkHiber)

#if !defined(_X86_)
#pragma alloc_text(PAGE, LZNT1DecompressChunk)
#endif

#pragma alloc_text(PAGELK, LZNT1FindMatchStandard)
#pragma alloc_text(PAGE, LZNT1FindMatchMaximum)

#endif


NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT Engine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_STANDARD_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_MAXIMUM_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
RtlCompressBufferLZNT1_HIBER (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

    This routine is only to be used on the hibernate path.  It is faster than the normal
    compress code but 5% less space efficient.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    // Only supports HIBER ENGINE
    //
    if (Engine != COMPRESSION_ENGINE_HIBER) {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunkHiber( UncompressedChunk,
                                                          EndOfUncompressedBuffer,
                                                          CompressedChunk,
                                                          EndOfCompressedBuffer,
                                                          &CompressedChunkSize,
                                                          WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Get the match function we are to be using
    //

    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        MatchFunction = LZNT1FindMatchStandard;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        MatchFunction = LZNT1FindMatchMaximum;

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunk( MatchFunction,
                                                     UncompressedChunk,
                                                     EndOfUncompressedBuffer,
                                                     CompressedChunk,
                                                     EndOfCompressedBuffer,
                                                     &CompressedChunkSize,
                                                     WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;
    PUCHAR UncompressedChunk = UncompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    LONG SavedChunkSize;

    LONG UncompressedChunkSize;
    LONG CompressedChunkSize;

    //
    //  The following to variables are pointers to the byte following the
    //  end of each appropriate buffer.  This saves us from doing the addition
    //  for each loop check
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, and then get the first chunk header and make sure it
    //  is not an ending chunk header.
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 4);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );

    //
    //  Now while there is space in the uncompressed buffer to store data
    //  we will loop through decompressing chunks
    //

    while (TRUE) {

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  First make sure the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  Decompress a chunk and return if we get an error
            //

            if (!NT_SUCCESS(Status = LZNT1DecompressChunk( UncompressedChunk,
                                                           EndOfUncompressedBuffer,
                                                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                           CompressedChunk + CompressedChunkSize,
                                                           &UncompressedChunkSize ))) {

                *FinalUncompressedSize = UncompressedChunkSize;

                return Status;
            }

        } else {

            //
            //  The chunk does not contain compressed data so we need to simply
            //  copy over the uncompressed data
            //

            UncompressedChunkSize = GetUncompressedChunkSize( ChunkHeader );

            //
            //  Make sure the data will fit into the output buffer
            //

            if (UncompressedChunk + UncompressedChunkSize > EndOfUncompressedBuffer) {

                UncompressedChunkSize = (ULONG)(EndOfUncompressedBuffer - UncompressedChunk);
            }

            //
            //  Check that the compressed chunk has this many bytes to copy.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + UncompressedChunkSize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( UncompressedChunk,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedChunkSize );
        }

        //
        //  Now update the compressed and uncompressed chunk pointers with
        //  the size of the compressed chunk and the number of bytes we
        //  decompressed into, and then make sure we didn't exceed our buffers
        //

        CompressedChunk += CompressedChunkSize;
        UncompressedChunk += UncompressedChunkSize;

        ASSERT( CompressedChunk <= EndOfCompressedBuffer );
        ASSERT( UncompressedChunk <= EndOfUncompressedBuffer );

        //
        //  Now if the uncompressed is full then we are done
        //

        if (UncompressedChunk == EndOfUncompressedBuffer) { break; }

        //
        //  Otherwise we need to get the next chunk header.  We first
        //  check if there is one, save the old chunk size for the
        //  chunk we just read in, get the new chunk, and then check
        //  if it is the ending chunk header
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        SavedChunkSize = GetUncompressedChunkSize(ChunkHeader);

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );
        if (ChunkHeader.Short == 0) { break; }

        //
        //  At this point we are not at the end of the uncompressed buffer
        //  and we have another chunk to process.  But before we go on we
        //  need to see if the last uncompressed chunk didn't fill the full
        //  uncompressed chunk size.
        //

        if (UncompressedChunkSize < SavedChunkSize) {

            LONG t1;
            PUCHAR t2;

            //
            //  Now we only need to zero out data if the really are going
            //  to process another chunk, to test for that we check if
            //  the zero will go beyond the end of the uncompressed buffer
            //

            if ((t2 = (UncompressedChunk +
                       (t1 = (SavedChunkSize -
                              UncompressedChunkSize)))) >= EndOfUncompressedBuffer) {

                break;
            }

            RtlZeroMemory( UncompressedChunk, t1);
            UncompressedChunk = t2;
        }
    }

    //
    //  If we got out of the loop with the compressed chunk pointer beyond the
    //  end of compressed buffer then the compression buffer is ill formed.
    //

    if (CompressedChunk > EndOfCompressedBuffer) {

        *FinalUncompressedSize = PtrToUlong(CompressedChunk);

        return STATUS_BAD_COMPRESSION_BUFFER;
    }

    //
    //  The final uncompressed size is the difference between the start of the
    //  uncompressed buffer and where the uncompressed chunk pointer was left
    //

    *FinalUncompressedSize = (ULONG)(UncompressedChunk - UncompressedBuffer);

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PLZNT1_FRAGMENT_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

    WorkSpace - Stop looking.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    ULONG UncompressedChunkSize;
    ULONG CompressedChunkSize;

    PUCHAR EndOfUncompressedFragment = UncompressedFragment + UncompressedFragmentSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;
    PUCHAR CurrentUncompressedFragment;

    ULONG CopySize;

    ASSERT(UncompressedFragmentSize > 0);

    //
    //  Get the chunk header for the first chunk in the
    //  compressed buffer and extract the uncompressed and
    //  the compressed chunk sizes
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 2);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );
    ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

    UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
    CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

    //
    //  Now we want to skip over chunks that precede the fragment
    //  we're after.  To do that we'll loop until the fragment
    //  offset is within the current chunk.  If it is not within
    //  the current chunk then we'll skip to the next chunk and
    //  subtract the uncompressed chunk size from the fragment offset
    //

    while (FragmentOffset >= UncompressedChunkSize) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  Adjust the fragment offset and move the compressed
        //  chunk pointer to the next chunk
        //

        FragmentOffset -= UncompressedChunkSize;
        CompressedChunk += CompressedChunkSize;

        //
        //  Get the next chunk header and if it is not in use
        //  then the fragment that the user wants is beyond the
        //  compressed data so we'll return a zero sized fragment
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  At this point the current chunk contains the starting point
    //  for the fragment.  Now we'll loop extracting data until
    //  we've filled up the uncompressed fragment buffer or until
    //  we've run out of chunks.  Both test are done near the end of
    //  the loop
    //

    CurrentUncompressedFragment = UncompressedFragment;

    while (TRUE) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }


        //
        //  Now we need to compute the amount of data to copy from the
        //  chunk.  It will be based on either to the end of the chunk
        //  size or the amount of data the user specified
        //

        CopySize = Minimum( UncompressedChunkSize - FragmentOffset, UncompressedFragmentSize );

        //
        //  Now check if the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  The chunk is compressed but now check if the amount
            //  we need to get is the entire chunk and if so then
            //  we can do the decompress straight into the caller's
            //  buffer
            //

            if ((FragmentOffset == 0) && (CopySize == UncompressedChunkSize)) {

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( CurrentUncompressedFragment,
                                                               EndOfUncompressedFragment,
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &CopySize ))) {

                    *FinalUncompressedSize = CopySize;

                    return Status;
                }

            } else {

                //
                //  The caller wants only a portion of this compressed chunk
                //  so we need to read it into our work buffer and then copy
                //  the parts from the work buffer into the caller's buffer
                //

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( (PUCHAR)WorkSpace,
                                                               &WorkSpace->Buffer[0] + sizeof(LZNT1_FRAGMENT_WORKSPACE),
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &UncompressedChunkSize ))) {

                    *FinalUncompressedSize = UncompressedChunkSize;

                    return Status;
                }

                //
                //  If we got less than we were looking for then we are at the
                //  end of the file.  Remember the real uncompressed size and
                //  break out of the loop.
                //

                if ((UncompressedChunkSize - FragmentOffset) < CopySize) {

                    RtlCopyMemory( CurrentUncompressedFragment,
                                   &WorkSpace->Buffer[ FragmentOffset ],
                                   (UncompressedChunkSize - FragmentOffset) );

                    CurrentUncompressedFragment += (UncompressedChunkSize - FragmentOffset);
                    break;
                }

                RtlCopyMemory( CurrentUncompressedFragment,
                               &WorkSpace->Buffer[ FragmentOffset ],
                               CopySize );
            }

        } else {

            //
            //  The chunk is not compressed so we can do a simple copy of the
            //  data.  First verify that the compressed buffer holds this much
            //  data.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset + CopySize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( CurrentUncompressedFragment,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset,
                           CopySize );
        }

        //
        //  Now that we've done at least one copy make sure the fragment
        //  offset is set to zero so the next time through the loop will
        //  start at the right offset
        //

        FragmentOffset = 0;

        //
        //  Adjust the uncompressed fragment information by moving the
        //  pointer up by the copy size and subtracting copy size from
        //  the amount of data the user wants
        //

        CurrentUncompressedFragment += CopySize;
        UncompressedFragmentSize -= CopySize;

        //
        //  Now if the uncompressed fragment size is zero then we're
        //  done
        //

        if (UncompressedFragmentSize == 0) { break; }

        //
        //  Otherwise the user wants more data so we'll move to the
        //  next chunk, and then check if the chunk is is use.  If
        //  it is not in use then we the user is trying to read beyond
        //  the end of compressed data so we'll break out of the loop
        //

        CompressedChunk += CompressedChunkSize;

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) { break; }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  Now either we finished filling up the caller's buffer (and
    //  uncompressed fragment size is zero) or we've exhausted the
    //  compresed buffer (and chunk header is zero).  In either case
    //  we're done and we can now compute the size of the fragment
    //  that we're returning to the caller it is simply the difference
    //  between the start of the buffer and the current position
    //

    *FinalUncompressedSize = (ULONG)(CurrentUncompressedFragment - UncompressedFragment);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    NTSTATUS Status = STATUS_NO_MORE_ENTRIES;

    //
    //  First initialize outputs
    //

    *ChunkBuffer = *CompressedBuffer;
    *ChunkSize = 0;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, otherwise just return a zero chunk.
    //

    if (*CompressedBuffer <= EndOfCompressedBufferPlus1 - 4) {

        RtlRetrieveUshort( &ChunkHeader, *CompressedBuffer );

        //
        //  Check for end of chunks, terminated by USHORT of 0.
        //  First assume there are no more.
        //

        if (ChunkHeader.Short != 0) {

            Status = STATUS_SUCCESS;

            *ChunkSize = GetCompressedChunkSize(ChunkHeader);
            *CompressedBuffer += *ChunkSize;

            //
            //  Check that the chunk actually fits in the buffer supplied
            //  by the caller.  If not, restore *CompressedBuffer for debug!
            //

            if ((*CompressedBuffer > EndOfCompressedBufferPlus1) ||
                (ChunkHeader.Chunk.ChunkSignature != 3)) {

                ASSERTMSG("CompressedBuffer is bad or too small", !Lznt1Break);

                *CompressedBuffer -= *ChunkSize;

                Status = STATUS_BAD_COMPRESSION_BUFFER;

            //
            //  First make sure the chunk contains compressed data
            //

            } else if (!ChunkHeader.Chunk.IsChunkCompressed) {

                //
                //  The uncompressed chunk must be exactly this size!
                //  If not, restore *CompressedBuffer for debug!
                //

                if (*ChunkSize != MAX_UNCOMPRESSED_CHUNK_SIZE + 2) {

                    ASSERTMSG("Uncompressed chunk is wrong size", !Lznt1Break);

                    *CompressedBuffer -= *ChunkSize;

                    Status = STATUS_BAD_COMPRESSION_BUFFER;

                //
                //  The chunk does not contain compressed data so we need to
                //  remove the chunk header from the chunk description.
                //

                } else {

                    *ChunkBuffer += 2;
                    *ChunkSize -= 2;
                }

            //
            //  Otherwise we have a compressed chunk, and we only need to
            //  see if it is all zeros!  Since the header is already interpreted,
            //  we only have to see if there is exactly one literal and if it
            //  is zero - it doesn't matter what the copy token says - we have
            //  a chunk of zeros!
            //

            } else if ((*ChunkSize == 6) && (*(*ChunkBuffer + 2) == 2) && (*(*ChunkBuffer + 3) == 0)) {

                *ChunkSize = 0;
            }
        }
    }

    return Status;
}


NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine reserves space for a chunk of the specified
    size in the buffer, writing in a chunk header if necessary
    (uncompressed or all zeros case).  On return the CompressedBuffer
    pointer points to the next chunk.

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0 and MAX_UNCOMPRESSED_CHUNK_SIZE (4096).
                0 means the chunk should be filled with a pattern that equates
                to 4096 0's.  4096 implies that the compression routine should
                prepare to receive all of the data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    BOOLEAN Compressed;
    PUCHAR Tail, NextChunk, DontCare;
    ULONG Size;
    NTSTATUS Status;

    ASSERT(ChunkSize <= MAX_UNCOMPRESSED_CHUNK_SIZE);

    //
    //  Calculate the address of the tail of this buffer and its
    //  size, so it can be moved before we store anything.
    //

    Tail = NextChunk = *CompressedBuffer;
    while (NT_SUCCESS(Status = RtlDescribeChunkLZNT1( &NextChunk,
                                                      EndOfCompressedBufferPlus1,
                                                      &DontCare,
                                                      &Size))) {

        //
        //  First time through the loop, capture the address of the next chunk.
        //

        if (Tail == *CompressedBuffer) {
            Tail = NextChunk;
        }
    }

    //
    //  The buffer could be invalid.
    //

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        //  The only way to successfully terminate the loop is by finding a USHORT
        //  terminator of 0.  Now calculate the size including the final USHORT
        //  we stopped on.
        //

        Size = (ULONG) (NextChunk - Tail + sizeof(USHORT));

        //
        //  First initialize outputs
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        *ChunkBuffer = *CompressedBuffer;

        //
        //  Make sure that the compressed buffer is at least four bytes long to
        //  start with, otherwise just return a zero chunk.
        //

        if (*CompressedBuffer <= (EndOfCompressedBufferPlus1 - ChunkSize)) {

            //
            //  If the chunk is uncompressed, then we have to adjust the
            //  chunk description for the header.
            //

            if (ChunkSize == MAX_UNCOMPRESSED_CHUNK_SIZE) {

                //
                //  Increase ChunkSize to include header.
                //

                ChunkSize += 2;

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it for an uncompressed chunk.
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              MAX_UNCOMPRESSED_CHUNK_SIZE + 2,
                                              FALSE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Advance to where the uncompressed data goes.
                    //

                    *ChunkBuffer += 2;

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise, if this is a zero chunk we have to build it.
            //

            } else if (ChunkSize == 0) {

                //
                //  It takes 6 bytes to describe a chunk of zeros.
                //

                ChunkSize = 6;

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    //
                    //  Move the tail now that we know where to put it.
                    //

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              6,
                                              TRUE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Now store the mask byte with one literal and the literal
                    //  is 0.
                    //

                    RtlStoreUshort( (*CompressedBuffer + 2), (USHORT)2 );

                    //
                    //  Now store the copy token for copying 4095 bytes from
                    //  the preceding byte (stored as offset 0).
                    //

                    RtlStoreUshort( (*CompressedBuffer + 4), (USHORT)(4095-3));

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise we have a normal compressed chunk.
            //

            } else {

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  Advance the *CompressedBuffer before return
            //

            *CompressedBuffer += ChunkSize;
        }
    }

    return Status;
}




#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGELKCONST")
#endif

//
//  The Copy token is two bytes in size.
//  Our definition uses a union to make it easier to set and retrieve token values.
//
//  Copy Token
//
//          Length            Displacement
//
//      12 bits 3 to 4098    4 bits 1 to 16
//      11 bits 3 to 2050    5 bits 1 to 32
//      10 bits 3 to 1026    6 bits 1 to 64
//       9 bits 3 to 514     7 bits 1 to 128
//       8 bits 3 to 258     8 bits 1 to 256
//       7 bits 3 to 130     9 bits 1 to 512
//       6 bits 3 to 66     10 bits 1 to 1024
//       5 bits 3 to 34     11 bits 1 to 2048
//       4 bits 3 to 18     12 bits 1 to 4096
//

typedef struct _LZNT1_FORMAT {
    ULONG LengthMask;
    ULONG DisplacementMask;
    ULONG MaxLength;
    ULONG MaxDisplacement;
    UCHAR DisplacementShift;
} LZNT1_FORMAT;
typedef const LZNT1_FORMAT *PLZNT1_FORMAT;

#define FORMAT_RECORD(n)        \
    {                           \
        (1 << (n)) - 1,         \
        (1 << (16-(n))) - 1,    \
        (1 << (n)) + 2,         \
        (1 << (16-(n))),        \
        (n)                     \
    }

const LZNT1_FORMAT LZNT1Formats[] = {
    FORMAT_RECORD(12),
    FORMAT_RECORD(11),
    FORMAT_RECORD(10),
    FORMAT_RECORD(9),
    FORMAT_RECORD(8),
    FORMAT_RECORD(7),
    FORMAT_RECORD(6),
    FORMAT_RECORD(5),
    FORMAT_RECORD(4)
};

#undef FORMAT_RECORD

#define FORMAT412 (&LZNT1Formats[0])
#define FORMAT511 (&LZNT1Formats[1])
#define FORMAT610 (&LZNT1Formats[2])
#define FORMAT79  (&LZNT1Formats[3])
#define FORMAT88  (&LZNT1Formats[4])
#define FORMAT97  (&LZNT1Formats[5])
#define FORMAT106 (&LZNT1Formats[6])
#define FORMAT115 (&LZNT1Formats[7])
#define FORMAT124 (&LZNT1Formats[8])


#pragma optimize("t", on)

//
//  USHORT
//  GetLZNT1Length (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  USHORT
//  GetLZNT1Displacement (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  VOID
//  SetLZNT1 (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken,
//      IN USHORT Length,
//      IN USHORT Displacement
//      );
//

USHORT
__forceinline
GetLZNT1Length (
    IN PLZNT1_FORMAT Format,
    IN USHORT CopyRecord
    )
{
    ULONG length;

    length = CopyRecord & Format->LengthMask;
    return (USHORT)(length + 3);
}

USHORT
__forceinline
GetLZNT1Displacement (
    IN PLZNT1_FORMAT Format,
    IN USHORT CopyRecord
    )
{
    ULONG displacement;

    displacement = CopyRecord >> Format->DisplacementShift;
    displacement &= Format->DisplacementMask;

    return (USHORT)(displacement + 1);
}

USHORT
__forceinline
SetLZNT1 (
    IN PLZNT1_FORMAT Format,
    IN ULONG Length,
    IN ULONG Displacement
    )
{
    ULONG result;

    ASSERT(Length <= Format->MaxLength);
    ASSERT(Displacement <= Format->MaxDisplacement);

    result = ((Displacement - 1) << Format->DisplacementShift) | (Length - 3);
    return (USHORT)result;
}


//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunkHiber (
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PLZNT1_HIBER_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    ULONG  IndexOrigin = WorkSpace->IndexTable[0] + 2*MAX_UNCOMPRESSED_CHUNK_SIZE;
    PUCHAR EndOfCompressedChunkPlus1;
    PUCHAR EndOfCompressedChunkPlus1Minus16;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    ULONG Length;

    UCHAR NullCharacter = 0;

    PLZNT1_FORMAT Format;
    ULONG MaxLength;
    PUCHAR MaxInputPointer;


    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }
    EndOfCompressedChunkPlus1Minus16 = EndOfCompressedChunkPlus1 - 16;

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    //
    //  Ensure that there are at least 3 characters in the buffer
    //  It takes at least that many to make a match
    //

    Format = FORMAT412;
    MaxLength = Format->MaxLength;
    MaxInputPointer = UncompressedBuffer + Format->MaxDisplacement;

    if (OutputPointer < EndOfCompressedChunkPlus1Minus16) {
        PUCHAR EndOfUncompressedBufferPlus1Minus3 = EndOfUncompressedBufferPlus1 - 3;
        while (InputPointer <= EndOfUncompressedBufferPlus1Minus3) {

            UCHAR InputPointer0;
            ULONG Index;
            ULONG InputOffset;
            ULONG MatchedOffset;
            ULONG MatchedIndex;
            PUCHAR MatchedString;

            Index = InputPointer[0];
            Index = ( (Index << 8) | (Index >> 4) );
            Index = ( Index ^ InputPointer[1] ^ (InputPointer[2]<<4) ) & 0xfff;

            MatchedIndex = (ULONG)(WorkSpace->IndexTable[Index]);
            InputOffset = (ULONG)(InputPointer - UncompressedBuffer);
            WorkSpace->IndexTable[Index] = (IndexOrigin + InputOffset);
            MatchedOffset = (ULONG)(MatchedIndex - IndexOrigin);

            //
            //  Check whether purported match lies within current buffer
            //  Recall that the hint vector may contain arbitrary garbage
            //

            if ( (MatchedOffset < InputOffset)
              && ( (MatchedString = UncompressedBuffer + MatchedOffset)
                 , (MatchedString[0] == InputPointer[0]) ) //  do at least 3 characters match?
              && (MatchedString[1] == InputPointer[1])
              && (MatchedString[2] == InputPointer[2]) ) {

                ULONG MaxLength1;
                ULONG MaxLength4;

                while (MaxInputPointer < InputPointer) {
                    Format += 1;
                    MaxLength = Format->MaxLength;
                    MaxInputPointer = UncompressedBuffer + Format->MaxDisplacement;
                }

                MaxLength1 = (ULONG)(EndOfUncompressedBufferPlus1 - InputPointer);
                if (MaxLength < MaxLength1) MaxLength1 = MaxLength;
                MaxLength4 = MaxLength1 - (4 - 1);

                Length = 3;

                for (;;) {
                    if ((long)Length < (long)MaxLength4) {
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        continue;
                    } else {
                        while (Length < MaxLength1) {
                            if (InputPointer[Length] != MatchedString[Length]) break;
                            Length++;
                        }
                        break;
                    }
                }

                //
                //  We need to output a two byte copy token
                //  Ensure that there is room in the output buffer
                //

                ASSERT((OutputPointer+1) < EndOfCompressedChunkPlus1);

                //
                //  Compute the displacement from the current pointer
                //  to the matched string
                //

                SetFlag(FlagByte, (1 << FlagBit));

                {
                    ULONG Displacement = (ULONG)(InputPointer - MatchedString);
                    USHORT token;

                    token = SetLZNT1(Format,Length,Displacement);

                    *(PUSHORT)OutputPointer = token;
                    OutputPointer += sizeof(USHORT);
                }

                InputPointer += Length;

            } else {

                //
                //  There is more data to output now make sure the output
                //  buffer is not already full and can contain at least one
                //  more byte
                //

                ASSERT(OutputPointer < EndOfCompressedChunkPlus1);

                ASSERT(!FlagOn(FlagByte, (1 << FlagBit)));

                NullCharacter |= *(OutputPointer++) = *(InputPointer++);

            }

            //
            //  Now adjust the flag bit and check if the flag byte
            //  should now be output.  If so output the flag byte
            //  and scarf up a new byte in the output buffer for the
            //  next flag byte.  Do not advance OutputPointer if we
            //  have no more input anyway!
            //

            FlagBit = (FlagBit + 1) % 8;

            if (!FlagBit) {

                *FlagPointer = FlagByte;
                FlagByte = 0;

                FlagPointer = (OutputPointer++);

                //
                //  Ensure that we have room for the at most 16 bytes
                //  that this flag byte may describe
                //

                if (OutputPointer >= EndOfCompressedChunkPlus1Minus16) { break; }
            }
        }
    }

    //
    //  UNDONE: Could pick up another match or two right at the end of the buffer
    //

    //
    //  Too few characters left for a match, emit them as literals
    //

    if (OutputPointer < EndOfCompressedChunkPlus1Minus16) {
        while (InputPointer < EndOfUncompressedBufferPlus1) {

            while (MaxInputPointer < InputPointer) {
                Format += 1;
                MaxLength = Format->MaxLength;
                MaxInputPointer = UncompressedBuffer + Format->MaxDisplacement;
            }

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            ASSERT(OutputPointer < EndOfCompressedChunkPlus1);

            ASSERT(!FlagOn(FlagByte, (1 << FlagBit)));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

            //
            //  Now adjust the flag bit and check if the flag byte
            //  should now be output.  If so output the flag byte
            //  and scarf up a new byte in the output buffer for the
            //  next flag byte.  Do not advance OutputPointer if we
            //  have no more input anyway!
            //

            FlagBit = (FlagBit + 1) % 8;

            if (!FlagBit) {

                *FlagPointer = FlagByte;
                FlagByte = 0;

                FlagPointer = (OutputPointer++);

                //
                //  Ensure that we have room for the at most 16 bytes
                //  that this flag byte may describe
                //

                if (OutputPointer >= EndOfCompressedChunkPlus1Minus16) { break; }
            }

        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            COMPRESSED_CHUNK_HEADER ChunkHeader;

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            ChunkHeader.Short = 0;

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            WorkSpace->IndexTable[0] = IndexOrigin;

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        WorkSpace->IndexTable[0] = IndexOrigin;

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    {
        COMPRESSED_CHUNK_HEADER ChunkHeader;

        *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

        ChunkHeader.Short = 0;

        SetCompressedChunkHeader( ChunkHeader,
                                  (USHORT)*FinalCompressedChunkSize,
                                  TRUE );

        RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );
    }

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        WorkSpace->IndexTable[0] = IndexOrigin;

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    WorkSpace->IndexTable[0] = IndexOrigin;

    return STATUS_SUCCESS;
}

#pragma optimize("t", off)


//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    PUCHAR EndOfCompressedChunkPlus1;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    LONG Length;
    LONG Displacement;

    USHORT CopyToken;

    COMPRESSED_CHUNK_HEADER ChunkHeader;

    UCHAR NullCharacter = 0;

    PLZNT1_FORMAT Format = FORMAT412;

    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    ChunkHeader.Short = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->UncompressedBuffer = UncompressedBuffer;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->EndOfUncompressedBufferPlus1 = EndOfUncompressedBufferPlus1;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FORMAT412->MaxLength;

    while (InputPointer < EndOfUncompressedBufferPlus1) {

        while (UncompressedBuffer + Format->MaxDisplacement < InputPointer) {

            Format += 1;
            ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = Format->MaxLength;
        }

        //
        //  Search for a string in the Lempel
        //

        Length = 0;
        if ((InputPointer + 3) <= EndOfUncompressedBufferPlus1) {

            Length = (MatchFunction)( InputPointer, WorkSpace );
        }

        //
        //  If the return length is zero then we need to output
        //  a literal.  We clear the flag bit to denote the literal
        //  output the charcter and build up a character bits
        //  composite that if it is still zero when we are done then
        //  we know the uncompressed buffer contained only zeros.
        //

        if (!Length) {

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            if (OutputPointer >= EndOfCompressedChunkPlus1) { break; }

            ClearFlag(FlagByte, (1 << FlagBit));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

        } else {

            //
            //  We need to output two byte, now make sure that
            //  the output buffer can contain at least two more
            //  bytes.
            //

            if ((OutputPointer+1) >= EndOfCompressedChunkPlus1) { break; }

            //
            //  Compute the displacement from the current pointer
            //  to the matched string
            //

            Displacement = (ULONG)(InputPointer - ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MatchedString);

            SetFlag(FlagByte, (1 << FlagBit));

            CopyToken = SetLZNT1(Format, Length, Displacement);

            RtlStoreUshort (OutputPointer, CopyToken);
            OutputPointer += sizeof(USHORT);

            InputPointer += Length;
        }

        //
        //  Now adjust the flag bit and check if the flag byte
        //  should now be output.  If so output the flag byte
        //  and scarf up a new byte in the output buffer for the
        //  next flag byte.  Do not advance OutputPointer if we
        //  have no more input anyway!
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit && (InputPointer < EndOfUncompressedBufferPlus1)) {

            *FlagPointer = FlagByte;
            FlagByte = 0;

            FlagPointer = (OutputPointer++);
        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

    SetCompressedChunkHeader( ChunkHeader,
                              (USHORT)*FinalCompressedChunkSize,
                              TRUE );

    RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    return STATUS_SUCCESS;
}


#if !defined(_X86_)
//
//  Local support routine
//

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed chunk and produces its
    uncompressed equivalent chunk provided the uncompressed data fits
    within the specified destination buffer.

    The compressed buffer must be stored in the LZNT1 format.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        chunk is to be stored.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to the compressed chunk.  (This
        pointer has already been adjusted to point past the chunk header.)

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalUncompressedChunkSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed chunk.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    PUCHAR OutputPointer;
    PUCHAR InputPointer;

    UCHAR FlagByte;
    ULONG FlagBit;

    PLZNT1_FORMAT Format = FORMAT412;

    //
    //  The two pointers will slide through our input and input buffer.
    //  For the input buffer we skip over the chunk header.
    //

    OutputPointer = UncompressedBuffer;
    InputPointer = CompressedBuffer;

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing
    //

    FlagByte = *(InputPointer++);
    FlagBit = 0;

    //
    //  While we haven't exhausted either the input or output buffer
    //  we will do some more decompression
    //

    while ((OutputPointer < EndOfUncompressedBufferPlus1) && (InputPointer < EndOfCompressedBufferPlus1)) {

        while (UncompressedBuffer + Format->MaxDisplacement < OutputPointer) { Format += 1; }

        //
        //  Check the current flag if it is zero then the current
        //  input token is a literal byte that we simply copy over
        //  to the output buffer
        //

        if (!FlagOn(FlagByte, (1 << FlagBit))) {

            *(OutputPointer++) = *(InputPointer++);

        } else {

            USHORT CopyToken;
            LONG Displacement;
            LONG Length;

            //
            //  The current input is a copy token so we'll get the
            //  copy token into our variable and extract the
            //  length and displacement from the token
            //

            if (InputPointer+1 >= EndOfCompressedBufferPlus1) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  Now grab the next input byte and extract the
            //  length and displacement from the copy token
            //

            RtlRetrieveUshort( &CopyToken, InputPointer );
            InputPointer += sizeof(USHORT);

            Displacement = GetLZNT1Displacement(Format, CopyToken);
            Length = GetLZNT1Length(Format, CopyToken);

            //
            //  At this point we have the length and displacement
            //  from the copy token, now we need to make sure that the
            //  displacement doesn't send us outside the uncompressed buffer
            //

            if (Displacement > (OutputPointer - UncompressedBuffer)) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  We also need to adjust the length to keep the copy from
            //  overflowing the output buffer
            //

            if ((OutputPointer + Length) >= EndOfUncompressedBufferPlus1) {

                Length = (ULONG)(EndOfUncompressedBufferPlus1 - OutputPointer);
            }

            //
            //  Now we copy bytes.  We cannot use Rtl Move Memory here because
            //  it does the copy backwards from what the LZ algorithm needs.
            //

            while (Length > 0) {

                *(OutputPointer) = *(OutputPointer-Displacement);

                Length -= 1;
                OutputPointer += 1;
            }
        }

        //
        //  Before we go back to the start of the loop we need to adjust the
        //  flag bit value (it goes from 0, 1, ... 7) and if the flag bit
        //  is back to zero we need to read in the next flag byte.  In this
        //  case we are at the end of the input buffer we'll just break out
        //  of the loop because we're done.
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit) {

            if (InputPointer >= EndOfCompressedBufferPlus1) { break; }

            FlagByte = *(InputPointer++);
        }
    }

    //
    //  The decompression is done so now set the final uncompressed
    //  chunk size and return success to our caller
    //

    *FinalUncompressedChunkSize = (ULONG)(OutputPointer - UncompressedBuffer);

    return STATUS_SUCCESS;
}
#endif // _X86_


//
//  Local support routine
//

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG Index;

    PUCHAR FirstEntry;
    ULONG  FirstLength;

    PUCHAR SecondEntry;
    ULONG  SecondLength;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    Index = ((40543*((((ZivString[0]<<4)^ZivString[1])<<4)^ZivString[2]))>>4) & 0xfff;

    FirstEntry  = WorkSpace->IndexPTable[Index][0];
    FirstLength = 0;

    SecondEntry  = WorkSpace->IndexPTable[Index][1];
    SecondLength = 0;

    //
    //  Check if first entry is good, and if so then get its length
    //

    if ((FirstEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (FirstEntry < ZivString)           &&

        (FirstEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (FirstEntry[1] == ZivString[1])    &&
        (FirstEntry[2] == ZivString[2])) {

        FirstLength = 3;

        while ((FirstLength < MaxLength)

                 &&

               (ZivString + FirstLength < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[FirstLength] == FirstEntry[FirstLength])) {

            FirstLength++;
        }
    }

    //
    //  Check if second entry is good, and if so then get its length
    //

    if ((SecondEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (SecondEntry < ZivString)           &&

        (SecondEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (SecondEntry[1] == ZivString[1])    &&
        (SecondEntry[2] == ZivString[2])) {

        SecondLength = 3;

        while ((SecondLength < MaxLength)

                 &&

               (ZivString + SecondLength< EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[SecondLength] == SecondEntry[SecondLength])) {

            SecondLength++;
        }
    }

    if ((FirstLength >= SecondLength)) {

        WorkSpace->IndexPTable[Index][1] = FirstEntry;
        WorkSpace->IndexPTable[Index][0] = ZivString;

        WorkSpace->MatchedString = FirstEntry;
        return FirstLength;
    }

    WorkSpace->IndexPTable[Index][1] = FirstEntry;
    WorkSpace->IndexPTable[Index][0] = ZivString;

    WorkSpace->MatchedString = SecondEntry;
    return SecondLength;
}


//
//  Local support routine
//

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PLZNT1_MAXIMUM_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

    If the matched string is two or more characters long then this
    routine does not update the lookup state information.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG i;
    ULONG BestMatchedLength;
    PUCHAR q;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    BestMatchedLength = 0;

    for (q = UncompressedBuffer; q < ZivString; q += 1) {

        i = 0;

        while ((i < MaxLength)

                 &&

               (ZivString + i < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[i] == q[i])) {

            i++;
        }

        if (i >= BestMatchedLength) {

            BestMatchedLength = i;
            WorkSpace->MatchedString = q;
        }
    }

    if (BestMatchedLength < 3) {

        return 0;

    } else {

        return BestMatchedLength;
    }
}


#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\ntrtlamd64.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ntrtlamd64.h

Abstract:

    AMD64 specific parts of ntrtlp.h.

Author:

    David N. Cutler (davec) 27-Oct-2000

--*/

#ifndef _NTRTLAMD64_
#define _NTRTLAMD64_

//
// Define exception routine function prototypes.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONG64 EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    );

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONG_PTR EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    );

#endif // _NTRTLAMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\movemem.asm ===
title  "Memory functions"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   movemem.asm
;
; Abstract:
;
;   This module implements functions to fill, copy , and compare blocks of
;   memory.
;
; Author:
;
;   David N. Cutler (davec) 6-Jul-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

        altentry RtlCopyMemoryAlternate

        subttl "Compare Memory"
;++
;
; SIZE_T
; RtlCompareMemory (
;     IN PVOID Source1,
;     IN PVOID Source2,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function compares two unaligned blocks of memory and returns the
;   number of bytes that compared equal.
;
; Arguments:
;
;   Source1 (rcx) - Supplies a pointer to the first block of memory to
;       compare.
;
;   Source2 (rdx) - Supplies a pointer to the second block of memory to
;       compare.
;
;   Length (r8) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;   The number of bytes that compared equal is returned as the function
;   value. If all bytes compared equal, then the length of the orginal
;   block of memory is returned.
;
;--

        NESTED_ENTRY RtlCompareMemory, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;

        END_PROLOGUE

        mov     rsi, rcx                ; set address of first string
        mov     rdi, rdx                ; set address of second string
        xor     edx, ecx                ; check if compatible alignment
        and     edx, 07h                ;
        jnz     short RlCM50            ; if nz, incompatible alignment
        cmp     r8, 8                   ; check if length to align
        jb      short RlCM50            ; if b, insufficient alignment length

;
; Buffer alignment is compatible and there are enough bytes for alignment.
;

        mov     r9, rdi                 ; copy destination address
        neg     ecx                     ; compute alignment length
        and     ecx, 07h                ; 
        jz      short RlCM10            ; if z, buffers already aligned
        sub     r8, rcx                 ; reduce count by align length
   repe cmpsb                           ; compare bytes to alignment
        jnz     short RlCM30            ; if nz, not all bytes matched
RlCM10: mov     rcx, r8                 ;
        and     rcx, -8                 ; check if any quarwords to compare
        jz      short RlCM20            ; if z, no quadwords to compare
        sub     r8, rcx                 ; reduce length by compare count
        shr     rcx, 3                  ; compute number of quadwords
   repe cmpsq                           ; compare quadwords
        jz      short RlCM20            ; if z, all quadwords compared
        inc     rcx                     ; increment remaining count
        sub     rsi, 8                  ; back up source address
        sub     rdi, 8                  ; back up destination address
        shl     rcx, 3                  ; compute uncompared bytes
RlCM20: add     r8, rcx                 ; compute residual bytes to compare
        jz      short RlCM40            ; if z, all bytes compared equal
        mov     rcx, r8                 ; set remaining bytes to compare
   repe cmpsb                           ; compare bytes
        jz      short RlCM40            ; if z, all byte compared equal
RlCM30: dec     rdi                     ; back up destination address
RlCM40: sub     rdi, r9                 ; compute number of bytes matched
        mov     rax, rdi                ;
        pop     rsi                     ; restore nonvolatile register
        pop     rdi                     ;
        ret                             ; return

;
; Buffer alignment is incompatible or there is less than 8 bytes to compare.
;

RlCM50: test    r8, r8                  ; test if any bytes to compare
        jz      short RlCM60            ; if z, no bytes to compare
        mov     rcx, r8                 ; set number of bytes to compare
   repe cmpsb                           ; compare bytes
        jz      short RlCM60            ; if z, all bytes compared equal
        inc     rcx                     ; increment remaining count
        sub     r8, rcx                 ; compute number of bytes matched
RlCM60: mov     rax, r8                 ;
        pop     rsi                     ; restore nonvolatile register
        pop     rdi                     ;
        ret                             ; return

        NESTED_END RtlCompareMemory, _TEXT$00

        subttl  "Compare Memory 32-bits"
;++
;
; SIZE_T
; RtlCompareMemoryUlong (
;     IN PVOID Source,
;     IN SIZE_T Length,
;     IN ULONG Pattern
;     )
;
; Routine Description:
;
;   This function compares a block of dword aligned memory with a specified
;   pattern 32-bits at a time.
;
;   N.B. The low two bits of the length are assumed to be zero and are
;        ignored.
;
; Arguments:
;
;   Source (rcx) - Supplies a pointer to the block of memory to compare.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to compare.       compare.
;
;   Pattern (r8d) - Supplies the pattern to be compared against.
;
; Return Value:
;
;   The number of bytes that compared equal is returned as the function
;   value. If all bytes compared equal, then the length of the orginal
;   block of memory is returned.
;
;--

        NESTED_ENTRY RtlCompareMemoryUlong, _TEXT$00

        push_reg rdi                    ; save nonvolatile register

        END_PROLOGUE

        mov     rdi, rcx                ; set destination address
        shr     rdx, 2                  ; compute number of dwords
        jz      short RlCU10            ; if z, no dwords to compare
        mov     rcx, rdx                ; set length of compare in dwords
        mov     eax, r8d                ; set comparison pattern
   repe scasd                           ; compare memory with pattern
        jz      short RlCU10            ; if z, all dwords compared
        inc     rcx                     ; increment remaining count
        sub     rdx, rcx                ; compute number of bytes matched
RlCU10: lea     rax, [rdx*4]            ; compute successful compare in bytes
        pop     rdi                     ; restore nonvolatile register
        ret                             ; return

        NESTED_END RtlCompareMemoryUlong, _TEXT$00

        subttl  "Copy Memory"
;++
;
; VOID
; RtlCopyMemory (
;     OUT VOID UNALIGNED *Destination,
;     IN CONST VOID UNALIGNED * Sources,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function copies nonoverlapping from one unaligned buffer to another.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the destination buffer.
;
;   Sources (rdx) - Supplies a pointer to the source buffer.
;
;   Length (r8) - Supplies the length, in bytes, of the copy operation.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY RtlCopyMemory, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;

        END_PROLOGUE

        ALTERNATE_ENTRY RtlCopyMemoryAlternate

        mov     rdi, rcx                ; set destination address
        mov     rsi, rdx                ; set source address

;
; Check for quadword alignment compatibility.
;

        xor     edx, ecx                ; check if compatible alignment
        and     edx, 07h                ;
        jnz     short RlCP40            ; is nz, incompatible alignment
        cmp     r8, 8                   ; check if 8 bytes to move
        jb      short RlCP20            ; if b, less than 8 bytes to move

;
; Buffer alignment is compatible and there are enough bytes for alignment.
;

        neg     ecx                     ; compute alignment length
        and     ecx, 07h                ; 
        jz      short RlCP10            ; if z, buffers already aligned
        sub     r8, rcx                 ; reduce count by align length
    rep movsb                           ; move bytes to alignment

;
; Move 8-byte blocks.
;

RlCP10: mov     rcx, r8                 ; compute number of 8-byte blocks
        and     rcx, -8                 ;
        jz      short RlCP20            ; if z, no 8-byte blocks
        sub     r8, rcx                 ; subtract 8-byte blocks from count
        shr     rcx, 3                  ; compute number of 8-byte blocks
    rep movsq                           ; move 8-byte blocks

;
; Move residual bytes.
;

RlCP20: test    r8, r8                  ; test if any bytes to move
        jz      short RlCP30            ; if z, no bytes to move
        mov     rcx, r8                 ; set remaining byte to move
    rep movsb                           ; move bytes to destination
RlCP30: pop     rsi                     ; restore nonvolatile registers
        pop     rdi                     ;
        ret                             ; return

;
; The source and destination are not quadword alignment compatible.
;
; Check for doubleword alignment compatibility.
;

RlCP40: and     edx, 03h                ; check if compatibile alignment
        jnz     short RlCP60            ; is nz, incompatible alignment
        cmp     r8, 4                   ; check if 4 bytes to move
        jb      short RlCP20            ; if b, less than 4 bytes to move

;
; Buffer alignment is compatible and there are enough bytes for alignment.
;

        neg     ecx                     ; compute alignment length
        and     ecx, 03h                ; 
        jz      short RlCP50            ; if z, buffers already aligned
        sub     r8, rcx                 ; reduce count by align length
    rep movsb                           ; move bytes to alignment

;
; Move 4-byte blocks.
;

RlCP50: mov     rcx, r8                 ; compute number of 4-byte blocks
        and     rcx, -4                 ;
        jz      short RlCP20            ; if z, no 4-byte blocks
        sub     r8, rcx                 ; subtract 4-byte blocks from count
        shr     rcx, 2                  ; compute number of 4-byte blocks
    rep movsd                           ; move 4-byte blocks
        jmp     short RlCP20            ; finish in common code

;
; The source and destination are not doubleword alignment compatible.
;
; Check for word alignment compatibility.
;

RlCP60: and     edx, 01h                ; check if compatibile alignment
        jnz     short RlCP20            ; is nz, incompatible alignment
        cmp     r8, 2                   ; check if 2 bytes to move
        jb      short RlCP20            ; if b, less than 2 bytes to move

;
; Buffer alignment is compatible and there are enough bytes for alignment.
;

        neg     ecx                     ; compute alignment length
        and     ecx, 01h                ; 
        jz      short RlCP70            ; if z, buffers already aligned
        sub     r8, rcx                 ; reduce count by align length
    rep movsb                           ; move bytes to alignment

;
; Move 2-byte blocks.
;

RlCP70: mov     rcx, r8                 ; compute number of 2-byte blocks
        and     rcx, -2                 ;
        jz      short RlCP20            ; if z, no 2-byte blocks
        sub     r8, rcx                 ; subtract 2-byte blocks from count
        shr     rcx, 1                  ; compute number of 2-byte blocks
    rep movsw                           ; move 2-byte blocks
        jmp     short RlCP20            ; finish in common code

        NESTED_END RtlCopyMemory, _TEXT$00

        subttl  "Copy Memory NonTemporal"
;++
;
; VOID
; RtlCopyMemoryNonTemporal (
;     OUT VOID UNALIGNED *Destination,
;     IN CONST VOID UNALIGNED * Sources,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another using
;   nontemporal moves that do not polute the cache.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the destination buffer.
;
;   Sources (rdx) - Supplies a pointer to the source buffer.
;
;   Length (r8) - Supplies the length, in bytes, of the copy operation.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY RtlCopyMemoryNonTemporal, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;

        END_PROLOGUE

        mov     rdi, rcx                ; set destination address
        mov     rsi, rdx                ; set source address
        cmp     r8, 16                  ; check if 16 bytes to move
        jb      RlNT50                  ; if b, less than 16 bytes to move

;
; Align the destination to a 16-byte boundary.
;

        neg     ecx                     ; compute alignment length
        and     ecx, 0fh                ; 
        jz      short RlNT10            ; if z, destination already aligned
        sub     r8, rcx                 ; reduce count by align length
    rep movsb                           ; move bytes to alignment

;
; Move 64-byte blocks.
;

RlNT10: mov     rax, r8                 ; compute number of 64-byte blocks
        and     rax, -64                ;
        jz      short RlNT30            ; if z, no 64-byte blocks to move
        sub     r8, rax                 ; subtract 64-byte blocks from count
RlNT20: prefetchnta 0[rsi]              ; prefetch start of source block
        prefetchnta 63[rsi]             ; prefetch end source block
        movdqu  xmm0, [rsi]             ; move 64-byte block
        movdqu  xmm1, 16[rsi]           ;
        movdqu  xmm2, 32[rsi]           ;
        movdqu  xmm3, 48[rsi]           ;
        movntdq [rdi], xmm0             ;
        movntdq 16[rdi], xmm1           ;
        movntdq 32[rdi], xmm2           ;
        movntdq 48[rdi], xmm3           ;
        add     rdi, 64                 ; advance destination address
        add     rsi, 64                 ; advance source address
        sub     rax, 64                 ; subtract number of bytes moved
        jnz     short RlNT20            ; if nz, more 64-byte blocks to move

;
; Move 16-byte blocks.
;

RlNT30: mov     rax, r8                 ; compute number of 16-byte blocks
        and     rax, -16                ;
        jz      short RlNT50            ; if z, no 16-byte blocks
        sub     r8, rax                 ; subract 16-byte blocks from count
RlNT40: movdqu  xmm0, [rsi]             ; move 16-byte block
        movntdq [rdi], xmm0             ;
        add     rdi, 16                 ; advance destination address
        add     rsi, 16                 ; advance source address
        sub     rax, 16                 ; subtract number of bytes moved
        jnz     short RlNT40            ; if nz, more 16-byte blocks to move

;
; Move residual bytes.
;

RlNT50: test    r8, r8                  ; test if any bytes to move
        jz      short RlNT60            ; if z, no bytes to move
        mov     rcx, r8                 ; set residual bytes to move
    rep movsb                           ; move residual bytes
RlNT60: sfence                          ; make sure all stores complete
        pop     rsi                     ; restore nonvolatile registers
        pop     rdi                     ;
        ret                             ; return

        NESTED_END RtlCopyMemoryNonTemporal, _TEXT$00

        subttl  "Fill Memory"
;++
;
; VOID
; RtlFillMemory (
;     IN VOID UNALIGNED *Destination,
;     IN SIZE_T Length,
;     IN UCHAR Fill
;     )
;
; Routine Description:
;
;   This function fills a block of unaligned memory with a specified pattern.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the memory to fill.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to fill.
;
;   Fill (r8d) - Supplies the value to fill memory with.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY RtlFillMemory, _TEXT$00

        push_reg rdi                    ; save nonvolatile register

        END_PROLOGUE

        mov     rdi, rcx                ; set destination address
        mov     eax, r8d                ; set fill pattern
        cmp     rdx, 8                  ; check if 8 bytes to fill
        jb      short RlFM20            ; if b, less than 8 bytes to fill

;
; Fill alignment bytes.
;

        neg     ecx                     ; compute alignment length
        and     ecx, 07h                ; 
        jz      short RlFM10            ; if z, buffers already aligned
        sub     rdx, rcx                ; reduce count by align length
    rep stosb                           ; fill bytes to alignment

;
; Fill 8-byte blocks.
;

RlFM10: mov     rcx, rdx                ; compute number of 8-byte blocks
        and     rcx, -8                 ;
        jz      short RlFM20            ; if z, no 8-byte blocks
        sub     rdx, rcx                ; subtract 8-byte blocks from count
        shr     rcx, 3                  ; compute number of 8-byte blocks
        mov     ah, al                  ; replicate pattern to dword
        shl     eax, 16                 ;
        mov     al, r8b                 ;
        mov     ah, al                  ;
        mov     r9, rax                 ;
        shl     rax, 32                 ;
        or      rax, r9                 ;
    rep stosq                           ; fill 8-byte blocks

;
; Fill residual bytes.
;

RlFM20: test    rdx, rdx                ; test if any bytes to fill
        jz      short RlFM30            ; if z, no bytes to fill
        mov     rcx, rdx                ; set remaining byte to fill
    rep stosb                           ; fill residual bytes
RlFM30: pop     rdi                     ; restore nonvolatile register
        ret                             ; return

        NESTED_END RtlFillMemory, _TEXT$00

        subttl  "Move Memory"
;++
;
; VOID
; RtlMoveMemory (
;     OUT VOID UNALIGNED *Destination,
;     IN CONST VOID UNALIGNED * Sources,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function copies from one unaligned buffer to another.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the destination buffer.
;
;   Sources (rdx) - Supplies a pointer to the source buffer.
;
;   Length (r8) - Supplies the length, in bytes, of the copy operation.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY RtlMoveMemory, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;

        END_PROLOGUE

        cmp     rcx, rdx                ; check if possible buffer overlap
        jbe     RtlCopyMemoryAlternate  ; if be, no overlap possible
        mov     rsi, rdx                ; compute ending source address
        add     rsi, r8                 ;
        dec     rsi                     ;
        cmp     rcx, rsi                ; check for buffer overlap
        ja      RtlCopyMemoryAlternate  ; if g, no overlap possible
        mov     rdi, rcx                ; compute ending destination address
        add     rdi, r8                 ;
        dec     rdi                     ;
        mov     rcx, r8                 ; set count of bytes to move
        std                             ; set direction flag
    rep movsb                           ; move bytes backward to destination
        cld                             ; clear direction flag
        pop     rsi                     ; restore nonvolatile registers
        pop     rdi                     ;
        ret                             ; return

        NESTED_END RtlMoveMemory, _TEXT$00

        subttl  "Prefetch Memory NonTemporal"
;++
;
; VOID
; RtlPrefetchMemoryNonTemporal (
;     IN CONST PVOID Source,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function prefetches memory at Source, for Length bytes into the
;   closest cache to the processor.
;
; Arguments:
;
;   Source (rcx) - Supplies a pointer to the memory to be prefetched.
;
;   Length (rdx) - Supplies the length, in bytes, of the operation.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY RtlPrefetchMemoryNonTemporal, _TEXT$00

RlPF10: prefetchnta 0[rcx]              ; prefetch line
        add     rcx, 64                 ; increment address to prefetch
        sub     rdx, 64                 ; subtract number of bytes prefetched
        ja      RlPF10                  ; if above zero, more bytes to move
        ret                             ; return

        LEAF_END RtlPrefetchMemoryNonTemporal, _TEXT$00

        subttl  "Zero Memory"
;++
;
; VOID
; RtlZeroMemory (
;     IN VOID UNALIGNED *Destination,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function fills a block of unaligned memory with zero.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the memory to fill.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to fill.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY RtlZeroMemory, _TEXT$00

        xor     r8, r8                  ; set fill pattern
        jmp     RtlFillMemory           ; finish in common code

        LEAF_END RtlZeroMemory, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 23-Jun-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        altentry ExpInterlockedFlushSList
        altentry ExpInterlockedPopEntrySList
        altentry ExpInterlockedPopEntrySListEnd
        altentry ExpInterlockedPopEntrySListFault
        altentry ExpInterlockedPopEntrySListResume
        altentry ExpInterlockedPushEntrySList

        subttl  "First Entry SList"
;++
;
; PSINGLE_LIST_ENTRY
; FirstEntrySList (
;     IN PSLIST_HEADER SListHead
;     )
;
; Routine Description:
;
;   This function returns the address of the fisrt entry in the SLIST or
;   NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the first entry address is to be computed.
;
; Return Value:
;
;   The address of the first entry is the specified, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY FirstEntrySList, _TEXT$00

        mov     rax, [rcx]              ; get address, sequence, and depth
        and     rax, 0fe000000H         ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

ifdef NTOS_KERNEL_RUNTIME

        cmp     rax, 1                  ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     rax, 1                  ; rotate carry into high bit
        sar     rax, 63 - 43            ; extract first entry address

else

        shr     rax, 63 - 42            ; extract first entry address

endif

        ret                             ; return

        LEAF_END FirstEntrySList, _TEXT$00

        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedPopEntrySList (
;     IN PSINGLE_LIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This function removes an entry from the front of a sequenced singly
;   linked list so that access to the list is synchronized in an MP system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which an entry is to be removed.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedPopEntrySList, _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedPopEntrySList

;
; N.B. The following code is the continuation address should a fault occur
;      in the rare case described below.
;

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListResume

        mov     rax, [rcx]              ; get address, sequence, and depth
Pop10:  mov     rdx, rax                ; make a copy
        and     rdx, 0fe000000H         ; isolate packed address
        jz      short Pop20             ; if z, list is empty

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

ifdef NTOS_KERNEL_RUNTIME

        or      rdx, 01fffffh           ; sign-extend resultant address

endif

        ror     rdx, 63 - 42            ; extract next entry address

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListFault

        mov     r8, [rdx]               ; get address of successor entry
        shl     r8, 63 - 42             ; shift address into position
        mov     r9, rax                 ; adjust depth but not sequence
        dec     r9w                     ;
        and     r9, 01ffffffh           ; isolate sequence and depth
        or      r8, r9                  ; merge address, sequence, and depth

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListEnd

ifndef NT_UP

   lock cmpxchg [rcx], r8               ; compare and exchange

else

        cmpxchg [rcx], r8               ; compare and exchange

endif

        jnz     short Pop10             ; if nz, exchange failed
Pop20:  mov     rax, rdx                ; set address of next entry
        ret                             ;

        LEAF_END RtlpInterlockedPopEntrySList, _TEXT$00

        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedPushEntrySList (
;     IN PSINGLE_LIST_ENTRY ListHead,
;     IN PSINGLE_LIST_ENTRY ListEntry
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a sequenced singly linked
;   list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead into which
;       an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
; Return Value:
;
;   Previous contents of list head. NULL implies list went from empty to not
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedPushEntrySList,  _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedPushEntrySList

        mov     r9, rdx                 ; make copy of list entry pointer
        shl     r9, 63 - 42             ; shift address into position
        mov     rax, [rcx]              ; get address, sequence, and depth

if DBG

        test    dl, 0fh                 ; test if entry 16-byte aligned
        jz      short Push10            ; if z, entry is 16-byte aligned
        int     3                       ; break into debugger

endif

Push10: mov     r8, rax                 ; make copy
        and     r8, 0fe000000h          ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

ifdef NTOS_KERNEL_RUNTIME

        cmp     r8, 1                   ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     r8, 1                   ; rotate carry into high bit
        sar     r8, 63 - 43             ; extract next entry address

else

        shr     r8, 63 - 42             ; extract next entry address

endif

        mov     [rdx], r8               ; set next entry to previous first
        mov     r10, rax                ;
        inc     r10w                    ; increment depth field
        add     r10d, 010000h           ; increment sequence field
        and     r10, 01ffffffh          ; isolate sequence and depth
        or      r10, r9                 ; merge address, sequence, and depth

ifndef NT_UP

   lock cmpxchg [rcx], r10              ; compare and exchange

else

        cmpxchg [rcx], r10              ; compare and exchange

endif

        jnz     short Push10            ; if nz, exchange failed
        mov     rax, r8                 ; set address of first entry
        ret                             ; return

        LEAF_END RtlpInterlockedPushEntrySList,  _TEXT$00

        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedFlushSList (
;     IN PSINGLE_LIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This function removes the entire list from a sequenced singly
;   linked list so that access to the list is synchronized in an MP system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry at the top of the list is removed
;   and returned as the function value and the list header is set to point
;   to NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the list is to be flushed.
;
; Return Value:
;
;   The address of the entire current list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedFlushSList, _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedFlushSList

        mov     rax, [rcx]              ; get address, sequence, and depth
Fl10:   mov     rdx, rax                ; make copy
        and     rdx, 0fe000000h         ; isolate packed address
        jz      short Fl20              ; if z, list is empty

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

ifdef NTOS_KERNEL_RUNTIME

        or      rdx, 01fffffh           ; sign-extend resultant address

endif

        ror     rdx, 63 - 42            ; extract next entry address
        mov     r8, rax                 ; isolate sequence number
        and     r8, 01ff0000h           ;

ifndef NT_UP

   lock cmpxchg [rcx], r8               ; compare and exchange

else

        cmpxchg [rcx], r8               ; compare and exchange

endif

        jnz     short Fl10              ; if nz, exchange failed
Fl20:   mov     rax, rdx                ; set address of first entry
        ret                             ; return

        LEAF_END RtlpInterlockedFlushSList, _TEXT$00

        subttl  "Interlocked Push List Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; InterlockedPushListSList (
;    IN PSLIST_HEADER ListHead,
;    IN PSINGLE_LIST_ENTRY List,
;    IN PSINGLE_LIST_ENTRY ListEnd,
;    IN ULONG Count
;    )
;
; Routine Description:
;
;   This function pushes the specified singly linked list onto the front of
;   a sequenced list.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead into which
;       the specified list is inserted.
;
;   List (rdx) - Supplies a pointer to the first entry in the list to be
;       pushed onto the front of the specified sequenced list.
;
;   ListEnd (r8) - Supplies a pointer to the last entry in the list to be
;       pushed onto the front of the specified sequence list.
;
;   Count (r9) - Supplies the number of entries in the list.
;
; Return Value:
;
;   Previous contents of list head. NULL implies list went from empty to not
;   empty.
;
;--

        NESTED_ENTRY InterlockedPushListSList, _TEX$00

        push_reg rsi                    ; save nonvolatile register

        END_PROLOGUE

        mov     rax, [rcx]              ; get address, sequence, and depth

if DBG

        test    dl, 0fh                 ; test if entry 16-byte aligned
        jnz     short Pshl10            ; if nz, entry not 16-byte aligned
        test    r8b, 0fh                ; test if entry 16-byte aligned
        jz      short Pshl20            ; if z, entry is 16-byte aligned
Pshl10: int     3                       ; break into debugger

endif

Pshl20: shl     rdx, 63 - 42            ; shift first address into position
Pshl30: mov     r10, rax                ; make a copy
        and     r10, 0fe000000H         ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

ifdef NTOS_KERNEL_RUNTIME

        cmp     r10, 1                  ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     r10, 1                  ; rotate carry into high bit
        sar     r10, 63 - 43            ; extract next entry address

else

        shr     r10, 63 - 42            ; extract next entry address

endif

        mov     [r8], r10               ; link old first to last in list
        lea     r11d, [rax][r9]         ; add length of list to depth
        and     r11d, 0ffffh            ; wrap depth if overlfow
        lea     esi, 010000h[rax]       ; increment sequence
        and     esi, 01ff0000h          ; wrap sequence if overflow
        or      rsi, r11                ; merge address, sequence, and depth
        or      rsi, rdx                ;

ifndef NT_UP

   lock cmpxchg [rcx], rsi              ; compare and exchange

else

        cmpxchg [rcx], rsi              ; compare and exchange

endif

        jnz     short Pshl30            ; if nz, exchange failed
        mov     rax, r10                ; set address of first entry
        pop     rsi                     ; restore volatile register
        ret                             ; return

        NESTED_END InterlockedPushListSList, _TEX$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\raise.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    raise.c

Abstract:

    This module implements functions to raise and exception and to raise
    status.

Author:

    David N. Cutler (davec) 28-Oct-2000

Environment:

    Any mode.

--*/

#include "ntrtlp.h"

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the raise exception system service.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;
    NTSTATUS Status = STATUS_INVALID_DISPOSITION;

    //
    // Capture the current context, unwind to the caller of this routine, set
    // the exception address, and call the appropriate exception dispatcher.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = ContextRecord.Rip;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);
    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ControlPc,
                         FunctionEntry,
                         &ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);

        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.Rip;

#if defined(NTOS_KERNEL_RUNTIME)

        if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
            return;
    
        }

        Status = ZwRaiseException(ExceptionRecord, &ContextRecord, FALSE);

#else

        if (ZwQueryPortInformationProcess() == FALSE) {
            if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
                return;
            }

            Status = ZwRaiseException(ExceptionRecord, &ContextRecord, FALSE);

        } else {
            Status = ZwRaiseException(ExceptionRecord, &ContextRecord, TRUE);
        }

#endif

    }

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
    return;
}

#pragma warning(push)
#pragma warning(disable:4717)       // recursive function
                     
VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as noncontinuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;

    //
    // Capure the current context and construct an exception record.
    //

    RtlCaptureContext(&ContextRecord);
    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Rip;

    //
    // Attempt to dispatch the exception.
    //
    // N.B. This exception is non-continuable.
    //

#if defined(NTOS_KERNEL_RUNTIME)

    RtlDispatchException(&ExceptionRecord, &ContextRecord);
    Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

#else

    if (ZwQueryPortInformationProcess() == FALSE) {
        RtlDispatchException(&ExceptionRecord, &ContextRecord);
        Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

    } else {
        Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, TRUE);
    }

#endif

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
    return;
}

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\trampoln.asm ===
title  "User Mode Dispatch Code"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   trampoln.asm
;
; Abstract:
;
;   This module implements the trampoline code necessary to dispatch user
;   mode APCs and exceptions.
;
; Author:
;
;   David N. Cutler (davec) 4-Jul-2000
;
; Environment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  RtlDispatchException:proc
        extern  RtlRaiseException:proc
        extern  RtlRaiseStatus:proc
        extern  RtlRestoreContext:proc
        extern  Wow64PrepareForException:qword
        extern  ZwCallbackReturn:proc
        extern  ZwContinue:proc
        extern  ZwRaiseException:proc
        extern  ZwTestAlert:proc

        subttl  "User APC Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; KiUserApcHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN UINT_PTR EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PDISPATCHER_CONTEXT DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when an exception occurs in an APC routine or one
;   of its dynamic descendents, or when an unwind through the APC dispatcher
;   is in progress. If an unwind is in progress, then test alert is called to
;   ensure that all currently queued APCs are executed.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   Continue search is returned as the function value.
;
;--

UaFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
UaFrame ends

        NESTED_ENTRY KiUserApcHandler, _TEXT$00

        alloc_stack (sizeof UaFrame)    ; allocate stack frame

        END_PROLOGUE

        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test if unwinding
        jz      short @f                ; if z, unwind not in progress
        call    ZwTestAlert             ; test for alert pending
@@:     mov     eax, ExceptionContinueSearch ; set continue search disposition
        add     rsp, sizeof UaFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END KiUserApcHandler, _TEXT$00

        subttl  "User APC Dispatcher"
;++
;
; The following code is never executed. Its purpose is to support exception
; dispatching and unwinding through the call to the APC dispatcher.
;
;--

        altentry KiUserApcDispatcher

        NESTED_ENTRY KiUserApcDispatch, _TEXT$00, KiUserApcHandler

        .pushframe                      ; push machine frame
        .allocstack CONTEXT_FRAME_LENGTH ; allocate stack frame
        .savereg rbx, CxRbx             ; save nonvolatile integer registers
        .savereg rbp, CxRbp             ;
        .savereg rsi, CxRsi             ;
        .savereg rdi, CxRdi             ;
        .savereg r12, CxR12             ;
        .savereg r13, CxR13             ;
        .savereg r14, CxR14             ;
        .savereg r15, CxR15             ;
        .savexmm128 xmm6, CxXmm6        ; save nonvolatile floating register
        .savexmm128 xmm7, CxXmm7        ;
        .savexmm128 xmm8, CxXmm8        ;
        .savexmm128 xmm9, CxXmm9        ;
        .savexmm128 xmm10, CxXmm10      ;
        .savexmm128 xmm11, CxXmm11      ;
        .savexmm128 xmm12, CxXmm12      ;
        .savexmm128 xmm13, CxXmm13      ;
        .savexmm128 xmm14, CxXmm14      ;
        .savexmm128 xmm15, CxXmm15      ;

        END_PROLOGUE

;++
;
; VOID
; KiUserApcDispatcher (
;     IN PVOID NormalContext,
;     IN PVOID SystemArgument1,
;     IN PVOID SystemArgument2,
;     IN PKNORMAL_ROUTINE NormalRoutine
;     )
;
; Routine Description:
;
;   This routine is entered on return from kernel mode to deliver an APC
;   in user mode. The context frame for this routine was built when the
;   APC interrupt was processed and contains the entire machine state of
;   the current thread. The specified APC routine is called and then the
;   machine state is restored and execution is continued.
;
;   N.B. This function is not called in the typical way. Instead of a normal
;        subroutine call to the nested entry point above, the alternate entry
;        point below is stored into the RIP address of the trap frame. Thus
;        when the kernel returns from the trap, the following code is executed
;        directly.
;
;   N.B. The home addresses for called routine register parameters are
;        allocated in the context record.
;
; Arguments:
;
;   NormalContext (P1Home) - Supplies the normal context parameter that was
;       specified when the APC was initialized.
;
;   SystemArgument1 (P2Home) - Supplies the first argument that was provided by
;       the system when the APC was queued.
;
;   SystemArgument2 (P3Home) - Supplies the second argument that was provided by
;       the system when the APC was queued.
;
;   NormalRoutine (P4Home) - Supplies the address of the function that is to
;       be called.
;
;   N.B. Register RSP supplies a pointer to a context record.
;
; Return Value:
;
;   None.
;
;--

        ALTERNATE_ENTRY KiUserApcDispatcher

        mov     rcx, CxP1Home[rsp]      ; get APC parameters
        mov     rdx, CxP2Home[rsp]      ;
        mov     r8, CxP3Home[rsp]       ;
        call    qword ptr CxP4Home[rsp] ; call APC routine

;
; N.B. The system service to continue execution must be called since test
;      alert must also be executed.
;

        mov     rcx, rsp                ; set address of context record
        mov     dl, TRUE                ; set test alert argument
        call    ZwContinue              ; continue execution

;
; Unsuccessful completion after attempting to continue execution. Use the
; return status as the exception code and attempt to raise another exception.
;

        mov     esi, eax                ; save return status
@@:     mov     ecx, esi                ; set status value
        call    RtlRaiseStatus          ; raise status
        jmp     short @b                ; loop forever

        NESTED_END KiUserApcDispatch, _TEXT$00

        subttl  "User Callback Dispatcher"
;++
;
; The following code is never executed. Its purpose is to support exception
; dispatching and unwinding through the call to the exception dispatcher.
;
;--

        altentry KiUserCallbackDispatcher

        NESTED_ENTRY KiUserCallbackDispatch, _TEXT$00

        .pushframe                      ; push machine frame
        .allocstack (CalloutFrameLength - MachineFrameLength) ; allocate stack frame

        END_PROLOGUE

;++
;
; VOID
; KiUserCallbackDispatcher (
;     IN ULONG ApiNumber,
;     IN PVOID InputBuffer,
;     IN ULONG INputLength
;     )
;
; Routine Description:
;
;   This routine is entered on a callout from kernel mode to execute a user
;   mode callback function. All arguments for this function have been placed
;   on the stack.
;
;   N.B. This function is not called in the typical way. Instead of a normal
;        subroutine call to the nested entry point above, the alternate entry
;        point below is stored into the RIP address of the trap frame. Thus
;        when the kernel returns from the trap, the following code is executed
;        directly.
;
;   N.B. The home addresses for called routine register parameters are
;        allocated in the user callout frame.
;
; Arguments:
;
;   N.B. Register RSP supplies a pointer to a user callout record.
;
; Return Value:
;
;   This function returns to kernel mode.
;
;--

        ALTERNATE_ENTRY KiUserCallbackDispatcher

        mov     rcx, CkBuffer[rsp]      ; set input buffer address
        mov     edx, CkLength[rsp]      ; set input buffer length
        mov     r8d, CkApiNumber[rsp]   ; get API number
        mov     rax, gs:[TePeb]         ; get process environment block address
        mov     r9, PeKernelCallbackTable[rax] ; get callback table address
        call    qword ptr [r9][r8 * 8]  ; call specified function

;
; If a return from the callback function occurs, then the output buffer
; address and length are returned as NULL.
;

        xor     ecx, ecx                ; clear output buffer address
        xor     edx, edx                ; clear output buffer length
        mov     r8d, eax                ; set completion status
        call    ZwCallbackReturn        ; return to kernel mode

;
; Unsuccessful completion after attempting to return to kernel mode. Use the
; return status as the exception code and attempt to raise another exception.
;

        mov     esi, eax                ; save status value
@@:     mov     ecx, esi                ; set status value
        call    RtlRaiseStatus          ; raise exception
        jmp     short @b                ; loop forever

        NESTED_END KiUserCallbackDispatch, _TEXT$00

        subttl  "User Exception Dispatcher"
;++
;
; The following code is never executed. Its purpose is to support exception
; dispatching and unwinding through the call to the exception dispatcher.
;
;--

ExceptionFramelength equ (ExceptionRecordLength + CONTEXT_FRAME_LENGTH)

        altentry KiUserExceptionDispatcher

        NESTED_ENTRY KiUserExceptionDispatch, _TEXT$00

        .pushframe                      ;
        .allocstack (ExceptionRecordLength + CONTEXT_FRAME_LENGTH) ; allocate stack frame
        .savereg rbx, CxRbx             ; save nonvolatile integer registers
        .savereg rbp, CxRbp             ;
        .savereg rsi, CxRsi             ;
        .savereg rdi, CxRdi             ;
        .savereg r12, CxR12             ;
        .savereg r13, CxR13             ;
        .savereg r14, CxR14             ;
        .savereg r15, CxR15             ;
        .savexmm128 xmm6, CxXmm6        ; save nonvolatile floating register
        .savexmm128 xmm7, CxXmm7        ;
        .savexmm128 xmm8, CxXmm8        ;
        .savexmm128 xmm9, CxXmm9        ;
        .savexmm128 xmm10, CxXmm10      ;
        .savexmm128 xmm11, CxXmm11      ;
        .savexmm128 xmm12, CxXmm12      ;
        .savexmm128 xmm13, CxXmm13      ;
        .savexmm128 xmm14, CxXmm14      ;
        .savexmm128 xmm15, CxXmm15      ;

        END_PROLOGUE

;++
;
; VOID
; KiUserExceptionDispatcher (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PCONTEXT ContextRecord
;     )
;
; Routine Description:
;
;   This routine is entered on return from kernel mode to dispatch a user
;   mode exception. If a frame based handler handles the exception, then
;   the execution is continued. Else last chance processing is performed.
;
;   N.B. This function is not called in the typical way. Instead of a normal
;        subroutine call to the nested entry point above, the alternate entry
;        point below is stored into the RIP address of the trap frame. Thus
;        when the kernel returns from the trap, the following code is executed
;        directly.
;
;   N.B. The home addresses for called routine register parameters are
;        allocated in the context record.
;
; Arguments:
;
;   ExceptionRecord (rsi) - Supplies a pointer to an exception record.
;
;   ContextRecord (rdi) - Supplies a pointer to a context record.
;
; Return Value:
;
;   None.
;
;--

        ALTERNATE_ENTRY KiUserExceptionDispatcher

;
; If this is a wow64 process, then give wow64 a chance to clean up before
; dispatching the exception.
;

        mov     rax, Wow64PrepareForException ; get wow64 routine address
        test    rax, rax                ; test if routine specified
        jz      short Ue05              ; if z, routine not specified
        mov     rcx, rsi                ; set exception record address
        mov     rdx, rdi                ; set context record address
        call    rax                     ; call wow64 clean up routine
Ue05:   mov     rcx, rsi                ; set exception record address
        mov     rdx, rdi                ; set context record address
        call    RtlDispatchException    ; dispatch the exception

;
; If the return status is TRUE, then the exception was handled and execution
; should be continued with the continue service in case the context was
; changed. If the return status is FALSE, then the exception was not handled
; and raise exception is called to perform last chance exception processing.
;

        test    al, al                  ; test if the exception was handled
        jz      short Ue10              ; if z, exception was not handled

;
; Restore context and continue execution.
;

        mov     rcx, rdi                ; set context record address
        xor     edx, edx                ; set set exception record address
        call    RtlRestoreContext       ; restore context
        jmp     short Ue20              ; finish in common code

;
; Last chance processing.
;

Ue10:   mov     rcx, rsi                ; set exception record address
        mov     rdx, rdi                ; set context record address
        xor     r8b, r8b                ; set first change argument falue
        call    ZwRaiseException        ; raise exception

;
; Common code for nonsuccessful completion of the continue or raise exception
; services. Use the return status as the exception code and attempt to raise
; another exception.
;

Ue20:   mov     esi, eax                ; save status value
@@:     mov     ecx, esi                ; set status value
        call    RtlRaiseStatus          ; raise exception
        jmp short @b                    ; loop forever

        NESTED_END KiUserExceptionDispatch, _TEXT$00

        subttl  "Raise User Exception Dispatcher"
;++
;
; NTSTATUS
; KiRaiseUserExceptionDispatcher (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered on return from kernel mode to raise a user
;   mode exception.
;
;   N.B. This function is not called in the normal manner. An exception is
;        raised from within the system by placing the address of this
;        function in the RIP of the trap frame. This replaces the normal
;        return to the system service stub.
;
; Arguments:
;
;   None.
;
; Implicit Arguments:
;
;   Status (eax) - Supplies the system service status.
;
; Return Value:
;
;   The exception code that was raised.
;
;--

RuFrame struct                          ;
        P1Home  dq ?                    ; parameter home address
        Xrecord db ExceptionRecordLength dup (?) ; exception record
        Status  dd ?                    ; saved exception code
        Fill1   dd ?                    ; fill to 0 mod 8
        Fill2   dq ?                    ; fill to 8 mod 16
RuFrame ends

        NESTED_ENTRY KiRaiseUserExceptionDispatcher, _TEXT$00

        alloc_stack (sizeof RuFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     RuFrame.Status[rsp], eax ; save the service status
        mov     eax, gs:[TeExceptionCode] ; get exception code
        lea     rcx, RuFrame.Xrecord[rsp] ; get exception record address
        mov     ErExceptionCode[rcx], eax ; set exception code
        xor     eax, eax                ; generate zero value
        mov     ErExceptionFlags[rcx], eax ; zero exception flags
        mov     ErExceptionRecord[rcx], rax ; zero exception record
        mov     rdx, sizeof RuFrame[rsp] ; get the real return address
        mov     ErExceptionAddress[rcx], rdx ; set exception address
        mov     ErNumberParameters[rcx], eax ; zero number of parameters
        call    RtlRaiseException        ; raise exception
        mov     eax, RuFrame.Status[rsp] ; get exception code to return
        add     rsp, sizeof RuFrame     ; dealloate stack frame
        ret                             ; return

        NESTED_END KiRaiseUserExceptionDispatcher, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\byteswap.asm ===
title  "Byte Swap Functions"
;++
;
; Copyright (c) 1997  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to perform byte swapping operations.
;
;
; Author:
;
;    Forrest Foltz (forrestf) 12-Dec-1997
;
; Environment:
;
;    User or Kernel mode.
;
; Revision History:
;
;--
.486p
	.xlist
include ks386.inc
include callconv.inc            ; calling convention macros
	.list

;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
	ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

	PAGE
	SUBTTL "RtlUshortByteSwap"
;++
;
; USHORT
; RtlUshortByteSwap(
;    IN USHORT Source
;    )
;
; /*++
;
; Routine Description:
;
;    The RtlfUshortByteSwap function exchanges bytes 0 and 1 of Source
;    and returns the resulting USHORT.
;
; Arguments:
;
;    (cx) Source - 16-bit value to byteswap.
;
; Return Value:
;
;    Swapped 16-bit value.
;
;--

CODE_ALIGNMENT
				
cPublicFastCall RtlUshortByteSwap  ,1
cPublicFpo 0, 0

	mov     ah, cl
	mov     al, ch
	fstRET  RtlUshortByteSwap

fstENDP RtlUshortByteSwap


	PAGE
	SUBTTL "RtlUlongByteSwap"
;++
;
; ULONG
; RtlUlongByteSwap(
;    IN ULONG Source
;    )
;
; /*++
;
; Routine Description:
;
;    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
;    Source and returns the the resulting ULONG.
;
; Arguments:
;
;    (ecx) Source - 32-bit value to byteswap.
;
; Return Value:
;
;    Swapped 32-bit value.
;
;--

CODE_ALIGNMENT
				
cPublicFastCall RtlUlongByteSwap  ,1
cPublicFpo 0, 0

	mov     eax, ecx
	bswap   eax
	fstRET  RtlUlongByteSwap

fstENDP RtlUlongByteSwap


	PAGE
	SUBTTL "RtlUlonglongByteSwap"
;++
;
; ULONG
; RtlUlonglongByteSwap(
;    IN ULONGLONG Source
;    )
;
; /*++
;
; Routine Description:
;
;    The RtlUlonglongByteSwap function exchanges byte pairs 0:7, 1:6, 2:5,
;    and 3:4 of Source and returns the resulting ULONGLONG.
;
; Arguments:
;
;    (esp + 4) Source - Low half of 64-bit value to byteswap.
;
;    (esp + 8) Source - High half of 64-bit value to byteswap.
;
; Return Value:
;
;    Swapped 64-bit value.
;
;--

CODE_ALIGNMENT
				
cPublicFastCall RtlUlonglongByteSwap  ,2
cPublicFpo 0, 0

	mov     edx, [esp + 8]
	mov     eax, [esp + 4]
	bswap   edx
	bswap   eax
        mov     ecx, eax
        mov     eax, edx
        mov     edx, ecx
	fstRET  RtlUlonglongByteSwap

fstENDP RtlUlonglongByteSwap

_TEXT$00   ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\debug2.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    debug.s
;
; Abstract:
;
;    This module implements functions to support debugging NT.
;
; Author:
;
;    Steven R. Wood (stevewo) 3-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   11 April 90 (and before)    bryanwi
;       Ported to 386, 386 specific support added.
;
;   2  Aug.  90    (tomp)
;       Added _DbgUnLoadImageSymbols routine.
;
;--
.386p


        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT	SEGMENT PUBLIC DWORD 'CODE'
ASSUME  DS:FLAT, ES:FLAT, FS:NOTHING, GS:NOTHING, SS:NOTHING

cPublicProc _DbgBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgBreakPoint
stdENDP _DbgBreakPoint

cPublicProc _DbgUserBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgUserBreakPoint
stdENDP _DbgUserBreakPoint

cPublicProc _DbgBreakPointWithStatus,1
cPublicFpo 1,0
        mov eax,[esp+4]
        public _RtlpBreakWithStatusInstruction@0
_RtlpBreakWithStatusInstruction@0:
        int 3
        stdRET  _DbgBreakPointWithStatus
stdENDP _DbgBreakPointWithStatus


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\stkwalk.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stkwalk.c

Abstract:

    This module implements the routine to get the callers and the callers
    caller address.

Author:

    David N. Cutler (davec) 26-Jun-2000

Revision History:


--*/

#include "ntrtlp.h"

USHORT
RtlCaptureStackBackTrace (
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash OPTIONAL
    )

/*++

Routine Description:

    This routine caputes a stack back trace by walking up the stack and
    recording the information for each frame.

Arguments:

    FramesToSkip - Supplies the number of frames to skip over at the start
        of the back trace.

    FramesToCapture - Supplies the number of frames to be captured.

    BackTrace - Supplies a pointer to the back trace buffer.

    BackTraceHash - Optionally supples a pointer to the computed hash value.

Return Value:

     The number of captured frames is returned as the function value.

--*/

{

    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;
    PVOID Trace[2 * MAX_STACK_DEPTH];

    //
    // If the number of frames to capture plus the number of frames to skip
    // (one additional frame is skipped for the call to walk the chain), then
    // return zero.
    //

    FramesToSkip += 1;
    if ((FramesToCapture + FramesToSkip) >= (2 * MAX_STACK_DEPTH)) {
        return 0;
    }

    //
    // Capture the stack back trace.
    //

    FramesFound = RtlWalkFrameChain(&Trace[0],
                                    FramesToCapture + FramesToSkip,
                                    0);

    //
    // If the number of frames found is less than the number of frames to
    // skip, then return zero.
    //

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    //
    // Compute the hash value and transfer the captured trace to the back
    // trace buffer.
    //

    HashValue = 0;
    for (Index = 0; Index < FramesToCapture; Index += 1) {
        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    if (ARGUMENT_PRESENT(BackTraceHash)) {
        *BackTraceHash = HashValue;
    }

    return (USHORT)Index;
}

#undef RtlGetCallersAddress

VOID
RtlGetCallersAddress (
    OUT PVOID *CallersPc,
    OUT PVOID *CallersCallersPc
    )

/*++

Routine Description:

    This routine returns the address of the call to the routine that called
    this routine, and the address of the call to the routine that called
    the routine that called this routine. For example, if A called B called
    C which called this routine, the return addresses in B and A would be
    returned.

Arguments:

    CallersPc - Supplies a pointer to a variable that receives the address
        of the caller of the caller of this routine (B).

    CallersCallersPc - Supplies a pointer to a variable that receives the
        address of the caller of the caller of the caller of this routine
        (A).

Return Value:

    None.

Note:

    If either of the calling stack frames exceeds the limits of the stack,
    they are set to NULL.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    ULONG64 LowLimit;

    //
    // Assume the function table entries for the various routines cannot be
    // found or there are not three procedure activation records on the stack.
    //

    *CallersPc = NULL;
    *CallersCallersPc = NULL;

    //
    // Get current stack limits, capture the current context, virtually
    // unwind to the caller of this routine, and lookup function table entry.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext(&ContextRecord);
    FunctionEntry = RtlLookupFunctionEntry(ContextRecord.Rip,
                                           &ImageBase,
                                           NULL);

    //
    //  Attempt to unwind to the caller of this routine (C).
    //

    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ContextRecord.Rip,
                         FunctionEntry,
                         &ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);

        //
        // Attempt to unwind to the caller of the caller of this routine (B).
        //

        FunctionEntry = RtlLookupFunctionEntry(ContextRecord.Rip,
                                               &ImageBase,
                                               NULL);

        if ((FunctionEntry != NULL) &&
            (ContextRecord.Rsp < HighLimit)) {

            RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                             ImageBase,
                             ContextRecord.Rip,
                             FunctionEntry,
                             &ContextRecord,
                             &HandlerData,
                             &EstablisherFrame,
                             NULL);

            *CallersPc = (PVOID)ContextRecord.Rip;

            //
            // Attempt to unwind to the caller of the caller of the caller
            // of the caller of this routine (A).
            //

            FunctionEntry = RtlLookupFunctionEntry(ContextRecord.Rip,
                                                   &ImageBase,
                                                   NULL);

            if ((FunctionEntry != NULL) &&
                (ContextRecord.Rsp < HighLimit)) {

                RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                 ImageBase,
                                 ContextRecord.Rip,
                                 FunctionEntry,
                                 &ContextRecord,
                                 &HandlerData,
                                 &EstablisherFrame,
                                 NULL);

                *CallersCallersPc = (PVOID)ContextRecord.Rip;
            }
        }
    }

    return;
}

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function attempts to walk the call chain and capture a vector with
    a specified number of return addresses. It is possible that the function
    cannot capture the requested number of callers, in which case, the number
    of captured return address will be returned.

Arguments:

    Callers - Supplies a pointer to an array that is to received the return
        address values.

    Count - Supplies the number of frames to be walked.

    Flags - Supplies the flags value (unused).

Return value:

    The number of captured return addresses.


--*/

{

    CONTEXT ContextRecord;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    ULONG Index;
    ULONG64 LowLimit;

    //
    // Amd64 code does not support any flags.
    //

    if (Flags != 0) {
        return 0;
    }

    //
    // In kernel mode avoid running at irql levels where we cannot
    // take page faults. The walking code will access various sections
    // from driver and system images and this will cause page faults.
    //

#ifdef NTOS_KERNEL_RUNTIME

    if (KeAreAllApcsDisabled () == TRUE) {
        return 0;
    }

#endif

    //
    // Get current stack limits and capture the current context.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext (&ContextRecord);

    //
    // Capture the requested number of return addresses if possible.
    //

    Index = 0;
    try {
        while ((Index < Count) && (ContextRecord.Rip != 0)) {

            //
            // Check the next PC value to make sure it is valid in the
            // current process.
            //

#if defined(NTOS_KERNEL_RUNTIME)

            if ((MmIsAddressValid((PVOID)ContextRecord.Rip) == FALSE) ||
                ((MmIsSessionAddress((PVOID)ContextRecord.Rip) != FALSE) &&
                 (MmGetSessionId(PsGetCurrentProcess()) == 0))) {
                break;
            }

#endif

            //
            // Lookup the function table entry using the point at which control
            // left the function.
            //

            FunctionEntry = RtlLookupFunctionEntry(ContextRecord.Rip,
                                                   &ImageBase,
                                                   NULL);

            //
            // If there is a function table entry for the routine and the stack is
            // within limits, then virtually unwind to the caller of the routine
            // to obtain the return address. Otherwise, discontinue the stack walk.
            //

            if ((FunctionEntry != NULL) &&
                (ContextRecord.Rsp < HighLimit)) {

                RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                 ImageBase,
                                 ContextRecord.Rip,
                                 FunctionEntry,
                                 &ContextRecord,
                                 &HandlerData,
                                 &EstablisherFrame,
                                 NULL);

                Callers[Index] = (PVOID)ContextRecord.Rip;
                Index += 1;

            } else {
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

#if DBG

        DbgPrint ("Unexpected exception in RtlWalkFrameChain ...\n");
        DbgBreakPoint ();

#endif

        Index = 0;
    }

    return Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\context.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module implements user-mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

Author:

    Mark Lucovsky (markl) 20-Jun-1989

Revision History:

    Bryan Willman (bryanwi) 8-Mar-90

	Ported to the 80386

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlInitializeContext)
#pragma alloc_text(PAGE,RtlRemoteCall)
#endif


VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    RTL_PAGED_CODE();

    Context->Eax = 0L;
    Context->Ebx = 1L;
    Context->Ecx = 2L;
    Context->Edx = 3L;
    Context->Esi = 4L;
    Context->Edi = 5L;
    Context->Ebp = 0L;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    Context->EFlags = 0x200L;	    // force interrupts on, clear all else.

    //
    // Even though these are optional, they are used as is, since NULL
    // is what these would have been initialized to anyway
    //

    Context->Esp = (ULONG) InitialSp;
    Context->Eip = (ULONG) InitialPc;

    //
    // add code to check alignment and raise exception...
    //

    Context->ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS;

    //
    // Set the initial context of the thread in a machine specific way.
    // ie, pass the initial parameter to the start address
    //

    Context->Esp -= sizeof(Parameter);
    ZwWriteVirtualMemory(Process,
			 (PVOID)Context->Esp,
			 (PVOID)&Parameter,
			 sizeof(Parameter),
			 NULL);
    Context->Esp -= sizeof(Parameter); // Reserve room for ret address


}



NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using
    NtGetContext and NtSetContext.  Parameters are passed to the
    target procedure via its stack.

Arguments:

    Process - Handle of the target process

    Thread - Handle of the target thread within that process

    CallSite - Address of the procedure to call in the target process.

    ArgumentCount - Number of 32 bit parameters to pass to the target
                    procedure.

    Arguments - Pointer to the array of 32 bit parameters to pass.

    PassContext - TRUE if an additional parameter is to be passed that
        points to a context record.

    AlreadySuspended - TRUE if the target thread is already in a suspended
                       or waiting state.

Return Value:

    Status - Status value

--*/

{
    NTSTATUS Status;
    CONTEXT Context;
    ULONG NewSp;
    ULONG ArgumentsCopy[5];

    RTL_PAGED_CODE();

    if (ArgumentCount > 4)
        return STATUS_INVALID_PARAMETER;

    //
    // If necessary, suspend the guy before with we mess with his stack.
    //
    if (!AlreadySuspended) {
        Status = NtSuspendThread( Thread, NULL );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }


    //
    // Get the context record for the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread( Thread, &Context );
    if (!NT_SUCCESS( Status )) {
        if (!AlreadySuspended) {
            NtResumeThread( Thread, NULL );
            }
        return( Status );
        }


    //
    //	Pass all parameters on the stack, regardless of whether a
    //	a context record is passed.
    //

    //
    //	Put Context Record on stack first, so it is above other args.
    //
    NewSp = Context.Esp;
    if (PassContext) {
	NewSp -= sizeof( CONTEXT );
	Status = NtWriteVirtualMemory( Process,
				       (PVOID)NewSp,
				       &Context,
				       sizeof( CONTEXT ),
				       NULL
				    );
	if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
	    return( Status );
	    }
        ArgumentsCopy[0] = NewSp;   // pass pointer to context
        RtlCopyMemory(&(ArgumentsCopy[1]),Arguments,ArgumentCount*sizeof( ULONG ));
        ArgumentCount++;
	}
    else {
        RtlCopyMemory(ArgumentsCopy,Arguments,ArgumentCount*sizeof( ULONG ));
        }

    //
    //	Copy the arguments onto the target stack
    //
    if (ArgumentCount) {
        NewSp -= ArgumentCount * sizeof( ULONG );
        Status = NtWriteVirtualMemory( Process,
                                       (PVOID)NewSp,
                                       ArgumentsCopy,
                                       ArgumentCount * sizeof( ULONG ),
                                       NULL
                                     );
        if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
            return( Status );
            }
        }

    //
    // Set the address of the target code into Eip, the new target stack
    // into Esp, and reload context to make it happen.
    //
    Context.Esp = NewSp;
    Context.Eip = (ULONG)CallSite;
    Status = NtSetContextThread( Thread, &Context );
    if (!AlreadySuspended) {
        NtResumeThread( Thread, NULL );
        }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\amd64\xcptmisc.asm ===
title   "Exception Handling Support Routines"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   xcptmisc.asm
;
; Abstract:
;
;   This module implements stub routines to call language specific handlers
;   for exception dispatching and temrination handling.
;
; Author:
;
;   David N. Cutler (davec) 4-Jul-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExceptionHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when a nested exception occurs. Its function
;   is to retrieve the establisher frame pointer from its establisher's
;   call frame, store this information in the dispatcher context record,
;   and return a disposition value of nested exception.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   A disposition value nested exception is returned if an unwind is not in
;   progress. Otherwise a value of continue search is returned.
;
;--

EhFrame struct
        P1Home  dq ?                    ; parameter home addresses for
        P2Home  dq ?                    ; called functions
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Context dq ?                    ; saved dispatcher context address
EhFrame ends

        LEAF_ENTRY RtlpExceptionHandler, _TEXT$00

        mov     eax, ExceptionContinueSearch ; assume unwind in progress
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; check for unwind
        jnz     short Eh10              ; if nz, unwind in progress
        mov     rax, EhFrame.Context[rdx] ; get establisher context address
        mov     rax, DcEstablisherFrame[rax] ; copy the establisher frame
        mov     DcEstablisherFrame[r9], rax ; to current dispatcher context
        mov     eax, ExceptionNestedException ; set nested exception disposition
eH10:   ret                             ; return

        LEAF_END RtlpExceptionHandler, _TEXT$00

        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function allocates a call frame, saves the dispatcher context address,
;   establishes an exception handler, and calls the specified language specific
;   handler routine. If a nested exception occurs, then the exception handler
;   of this function is called and the establisher frame pointer is returned to
;   the exception dispatcher via the dispatcher context parameter.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   The disposition value returned by the specified exception handler is
;   returned as the function value.
;
;--

        NESTED_ENTRY RtlpExecuteHandlerForException, _TEXT$00, RtlpExceptionHandler

        alloc_stack (sizeof EhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     EhFrame.Context[rsp], r9 ; save dispatcher context address
        call    qword ptr DcLanguageHandler[r9] ; call language handler
        nop                             ; required fill for virtual unwind
        add     rsp, sizeof EhFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlpExecuteHandlerForException, _TEXT$00

        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; RtlpUnwindHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when a collided unwind occurs. Its function
;   is to retrieve the establisher dispatcher context, copy it to the
;   current dispatcher context, and return a disposition value of collided
;   unwind.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   A disposition value collided unwind is returned if an unwind is in
;   progress. Otherwise a value of continue search is returned.
;
;--

        LEAF_ENTRY RtlpUnwindHandler, _TEXT$00

        mov     rax, EhFrame.Context[rdx] ; get establisher context address
        mov     r10, DcControlPc[rax]   ; copy control PC
        mov     DcControlPc[r9], r10    ;
        mov     r10, DcImageBase[rax]   ; copy image base
        mov     DcImageBase[r9], r10    ;
        mov     r10, DcFunctionEntry[rax] ; copy function entry
        mov     DcFunctionentry[r9], r10 ;
        mov     r10, DcEstablisherFrame[rax] ; copy establisher frame
        mov     DcEstablisherFrame[r9], r10 ;
        mov     r10, DcContextRecord[rax] ; copy context record address
        mov     DcContextRecord[r9], r10 ;
        mov     r10, DcLanguageHandler[rax] ; copy language handler address
        mov     DcLanguageHandler[r9], r10 ;
        mov     r10, DcHandlerData[rax] ; copy handler data address
        mov     DcHandlerData[r9], r10  ;
        mov     r10, DcHistoryTable[rax] ; copy history table address
        mov     DcHistoryTable[r9], r10  ;
        mov     eax, ExceptionCollidedUnwind ; set collied unwind disposition
        ret                             ; return

        LEAF_END RtlpUnwindHandler, _TEXT$00

        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function allocates a call frame, saves the dispatcher context address,
;   establishes an exception handler, and calls the specified unwind handler.
;   If a collided unwind occurs, then the exception handler of this function is
;   called and the establisher dispatcher context is copied to the current
;   dispatcher context via the dispatcher context parameter.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
;   ExceptionRoutine (5 * 8[rsp]) - Supplies a pointer to the exception
;       handler that is to be called.
;
; Return Value:
;
;   The disposition value returned by the specified exception handler is
;   returned as the function value.
;
;--

        NESTED_ENTRY RtlpExecuteHandlerForUnwind, _TEXT$00, RtlpUnwindHandler

        alloc_stack (sizeof EhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     EhFrame.Context[rsp], r9 ; save dispatcher context address
        call    qword ptr DcLanguageHandler[r9] ; call exception handler
        nop                             ; required fill for virtual unwind
        add     rsp, sizeof EhFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlpExecuteHandlerForUnwind, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\divlarge.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    largediv.c

Abstract:

    This module implements the NT runtime library large integer divide
    routines.

    N.B. These routines use a one bit at a time algorithm and is slow.
         They should be used only when absolutely necessary.

Author:

    David N. Cutler 10-Aug-1992

Revision History:

--*/

#include "ntrtlp.h"

LARGE_INTEGER
RtlLargeIntegerDivide (
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor,
    OUT PLARGE_INTEGER Remainder OPTIONAL
    )

/*++

Routine Description:

    This routine divides an unsigned 64-bit dividend by an unsigned 64-bit
    divisor and returns a 64-bit quotient, and optionally a 64-bit remainder.

Arguments:

    Dividend - Supplies the 64-bit dividend for the divide operation.

    Divisor - Supplies the 64-bit divisor for the divide operation.

    Remainder - Supplies an optional pointer to a variable which receives
        the remainder

Return Value:

    The 64-bit quotient is returned as the function value.

--*/

{

    ULONG Index = 64;
    LARGE_INTEGER Partial = {0, 0};
    LARGE_INTEGER Quotient;

#ifndef BLDR_KERNEL_RUNTIME
    //
    // Check for divide by zero
    //

    if (!(Divisor.LowPart | Divisor.HighPart)) {
        RtlRaiseStatus (STATUS_INTEGER_DIVIDE_BY_ZERO);
    }
#endif

    //
    // Loop through the dividend bits and compute the quotient and remainder.
    //

    Quotient = Dividend;
    do {

        //
        // Shift the next dividend bit into the parital remainder and shift
        // the partial quotient (dividend) left one bit.
        //

        Partial.HighPart = (Partial.HighPart << 1) | (Partial.LowPart >> 31);
        Partial.LowPart = (Partial.LowPart << 1) | ((ULONG)Quotient.HighPart >> 31);
        Quotient.HighPart = (Quotient.HighPart << 1) | (Quotient.LowPart >> 31);
        Quotient.LowPart <<= 1;

        //
        // If the partial remainder is greater than or equal to the divisor,
        // then subtract the divisor from the partial remainder and insert a
        // one bit into the quotient.
        //

        if (((ULONG)Partial.HighPart > (ULONG)Divisor.HighPart) ||
            ((Partial.HighPart == Divisor.HighPart) &&
            (Partial.LowPart >= Divisor.LowPart))) {

            Quotient.LowPart |= 1;
            Partial.HighPart -= Divisor.HighPart;
            if (Partial.LowPart < Divisor.LowPart) {
                Partial.HighPart -= 1;
            }

            Partial.LowPart -= Divisor.LowPart;
        }

        Index -= 1;
    } while (Index > 0);

    //
    // If the remainder is requested, then return the 64-bit remainder.
    //

    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = Partial;
    }

    //
    // Return the 64-bit quotient.
    //

    return Quotient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\ioaccess.asm ===
title  "ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ioaccess.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; I/O memory space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in MEMORY space.
;  (Uses x86 mov instructions)
;
;--



;++
;
;   UCHAR
;   READ_REGISTER_UCHAR(
;       PUCHAR  Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_UCHAR ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     al,[edx]                ; (al) = byte, lock forces real access
        stdRET    _READ_REGISTER_UCHAR

stdENDP _READ_REGISTER_UCHAR



;++
;
;   USHORT
;   READ_REGISTER_USHORT(
;       PUSHORT Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_USHORT ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     ax,[edx]                ; (ax) = word, lock forces real access
        stdRET    _READ_REGISTER_USHORT

stdENDP _READ_REGISTER_USHORT



;++
;
;   ULONG
;   READ_REGISTER_ULONG(
;       PULONG  Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_ULONG ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[edx]               ; (eax) = dword, lock forces real access
        stdRET    _READ_REGISTER_ULONG

stdENDP _READ_REGISTER_ULONG


;++
;
;   VOID
;   READ_REGISTER_BUFFER_UCHAR(
;       PUCHAR  Register,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_UCHAR ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsb

        mov     edi, edx
        mov     esi, eax

        stdRET    _READ_REGISTER_BUFFER_UCHAR

stdENDP _READ_REGISTER_BUFFER_UCHAR


;++
;
;   VOID
;   READ_REGISTER_BUFFER_USHORT(
;       PUSHORT Register,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_USHORT ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsw

        mov     edi, edx
        mov     esi, eax
        stdRET    _READ_REGISTER_BUFFER_USHORT

stdENDP _READ_REGISTER_BUFFER_USHORT


;++
;
;   VOID
;   READ_REGISTER_BUFFER_ULONG(
;       PULONG  Register,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_ULONG ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsd

        mov     edi, edx
        mov     esi, eax
        stdRET    _READ_REGISTER_BUFFER_ULONG

stdENDP _READ_REGISTER_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_REGISTER_UCHAR(
;       PUCHAR  Register,
;       UCHAR   Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_UCHAR ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     al,[esp+8]              ; (al) = Value
        mov     [edx],al                ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_UCHAR

stdENDP _WRITE_REGISTER_UCHAR



;++
;
;   VOID
;   WRITE_REGISTER_USHORT(
;       PUSHORT Register,
;       USHORT  Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_USHORT ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[esp+8]             ; (ax) = Value
        mov     [edx],ax                ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_USHORT

stdENDP _WRITE_REGISTER_USHORT



;++
;
;   VOID
;   WRITE_REGISTER_ULONG(
;       PULONG  Register,
;       ULONG   Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_ULONG ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[esp+8]             ; (eax) = Value
        mov     [edx],eax               ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_ULONG

stdENDP _WRITE_REGISTER_ULONG


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_UCHAR(
;       PUCHAR  Register,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_UCHAR ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsb
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax

        stdRET    _WRITE_REGISTER_BUFFER_UCHAR

stdENDP _WRITE_REGISTER_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_USHORT(
;       PUSHORT Register,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_USHORT ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsw
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax
        stdRET    _WRITE_REGISTER_BUFFER_USHORT

stdENDP _WRITE_REGISTER_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_ULONG(
;       PULONG  Register,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_ULONG ,3
cPublicFpo  0, 3

;FPO ( 0, 3, 0, 0, 0, 0 )

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsd
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax
        stdRET    _WRITE_REGISTER_BUFFER_ULONG

stdENDP _WRITE_REGISTER_BUFFER_ULONG

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\icecap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    icecap.c

Abstract:

    This module implements the probe and support routines for
    kernel icecap tracing.

Author:

    Rick Vicik (rickv) 9-May-2000

Revision History:

--*/

#ifdef _CAPKERN

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <stdio.h>

//
// Kernel Icecap logs to Perfmem (BBTBuffer) using the following format:
//
// BBTBuffer[0] contains the length in 4kpages
// BBTBuffer[1] is a flagword: 1 = RDPMC 0
//                             2 = user stack dump
// BBTBuffer[2] is ptr to beginning of cpu0 buffer
// BBTBuffer[3] is ptr to beginning of cpu1 buffer (also end of cpu0 buffer)
// BBTBuffer[4] is ptr to beginning of cpu2 buffer (also end of cpu1 buffer)
// ...
// BBTBuffer[n+2] is ptr to beginning of cpu 'n' buffer (also end of cpu 'n-1' buffer)
// BBTBuffer[n+3] is ptr the end of cpu 'n' buffer
//
// The area starting with &BBTBuffer[n+4] is divided into private buffers
// for each cpu.  The first dword in each cpu-private buffer points to the
// beginning of freespace in that buffer.  Each one is initialized to point
// just after itself.  Space is claimed using lock xadd on that dword.
// If the resulting value points beyond the beginning of the next cpu's
// buffer, this buffer is considered full and nothing further is logged.
// Each cpu's freespace pointer is in a separate cacheline.

//
// Sizes of trace records
//

#define CAPENTERSIZE 20
#define CAPENTERSIZE2 28
#define CAPEXITSIZE 12
#define CAPEXITSIZE2 20
#define CAPTIDSIZE 28

//
// The pre-call (CAP_Start_Profiling) and post-call (CAP_End_Profiling)
// probe calls are defined in RTL because they must be built twice:
// once for kernel runtime and once for user-mode runtime (because the
// technique for getting the trace buffer address is different).
//

#ifdef NTOS_KERNEL_RUNTIME

//
// Kernel-Mode Probe & Support Routines:
// (BBTBuffer address obtained from kglobal pointer *BBTBuffer,
//  cpu number obtained from PCR)
//

extern unsigned long *BBTBuffer;


VOID
_declspec(naked)
__stdcall
_CAP_Start_Profiling(

    PVOID current,
    PVOID child)

/*++

Routine description:

    Kernel-mode version of before-call icecap probe.  Logs a type 5
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Prcb).  Inserts adrs of current and called functions
    plus RDTSC timestamp into logrecord.  If BBTBuffer flag 1 set,
    also does RDPMC 0 and inserts result into logrecord.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call
    child - address of called routine

--*/

{
    _asm {

      push eax               ; save eax

      mov eax, BBTBuffer     ; get BBTBuffer address
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      push ecx
      bt [eax+4],0           ; if 1st flag bit set,
      jc  pmc1               ; datalen is 28
      mov ecx, CAPENTERSIZE  ; otherwise it is 20
      jmp tsonly1
    pmc1:
      mov ecx, CAPENTERSIZE2
    tsonly1:

      push edx               ; save edx
      movzx edx, _PCR KPCR.Number ; get processor number

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; next per-cpu buffer is EOB for this cpu
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return2            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return2            ;   (also return if both 0)

      push ebx
      lea ebx,[ecx+4]        ; record len is datalen + 4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge return4            ; don't log it

      mov word ptr[ebx],5    ; initialize CapEnter record
      mov word ptr [ebx+2],cx ; insert datalen

      mov eax,[esp+20]       ; p1 (4 saved regs + retadr)
      mov [ebx+4],eax

      mov eax,[esp+24]       ; p2
      mov [ebx+8],eax

      mov eax, _PCR KPCR.PrcbData.CurrentThread
      mov eax, [eax] ETHREAD.Cid.UniqueThread
      mov [ebx+12],eax       ; current Teb

      rdtsc                  ; read timestamp into edx:eax
      mov [ebx+16],eax       ; ts low
      mov [ebx+20],edx       ; ts high

      cmp ecx, CAPENTERSIZE  ; if record length 20,
      jne  pmc2
      jmp  return4           ; skip rdpmc

    pmc2:
      xor  ecx,ecx           ; pmc0
      rdpmc                  ; read pmc into edx:eax
      mov [ebx+24],eax       ; ts low
      mov [ebx+28],edx       ; ts high

    return4:                 ; restore regs & return
      pop ebx
    return2:
      pop edx
      pop ecx
    return1:
      pop eax
      ret 8                  ; 2 input parms
    }
}


VOID
_declspec(naked)
__stdcall
_CAP_End_Profiling(

    PVOID current)

/*++

Routine description:

    Kernel-mode version of after-call icecap probe.  Logs a type 6
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Prcb).  Inserts adr of current function and
    RDTSC timestamp into logrecord.  If BBTBuffer flag 1 set,
    also does RDPMC 0 and inserts result into logrecord.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call

--*/

{
    _asm {

      push eax               ; save eax
      mov eax, BBTBuffer     ; get BBTBuffer address
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      push ecx
      bt [eax+4],0           ; if 1st flag bit set,
      jc  pmc1               ; datalen is 20
      mov ecx, CAPEXITSIZE   ; otherwise it is 12
      jmp tsonly1
    pmc1:
      mov ecx, CAPEXITSIZE2
    tsonly1:

      push edx
      movzx edx, _PCR KPCR.Number ; get processor number

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return2            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return2            ;   (also return if both 0)

      push ebx
      lea ebx,[ecx+4]        ; record len is datalen + 4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge  return4           ; don't log it

      mov word ptr[ebx],6    ; initialize CapExit record
      mov word ptr [ebx+2],cx ; insert datalen

      mov eax,[esp+20]       ; p1 (4 saved regs + retadr)
      mov [ebx+4],eax


      rdtsc                  ; read timestamp into edx:eax
      mov [ebx+8],eax        ; ts low
      mov [ebx+12],edx       ; ts high

      cmp ecx, CAPEXITSIZE   ; if datalen is 16,
      jne  pmc2
      jmp  return4           ; skip rdpmc

    pmc2:
      xor  ecx,ecx           ; pmc0
      rdpmc                  ; read pmc into edx:eax
      mov [ebx+16],eax       ; ts low
      mov [ebx+20],edx       ; ts high


    return4:                 ; restore regs & return
      pop ebx
    return2:
      pop edx
      pop ecx
    return1:
      pop eax
      ret 4                  ; 1 input parm
    }
}

VOID __cdecl CAP_Log_NInt( UCHAR code, UCHAR log_timestamp, USHORT intcount, ...);
VOID __cdecl CAP_Log_NInt_Clothed( ULONG Bcode_Bts_Scount, ...);

VOID CAPKComment(char* Format, ...);


VOID
__stdcall
_CAP_ThreadID( VOID )

/*++

Routine description:

    Called by KiSystemService before executing the service routine.
    Logs a type 14 icecap record containing Pid, Tid & image file name.
    Optionally, if BBTBuffer flag 2 set, runs the stack frame pointers
    in the user-mode call stack starting with the trap frame and copies
    the return addresses to the log record.  The length of the logrecord
    indicates whether user call stack info is included.

--*/

{
    PEPROCESS Process;
    PKTHREAD  Thread;
    PETHREAD  EThread;
    char*     buf;
    int       callcnt;
    ULONG*    cpuptr;
    ULONG     recsize;
    ULONG     RetAddr[7];


    if( !BBTBuffer || !BBTBuffer[0] )
        goto fail;

    _asm {

      call KeGetCurrentThread
      mov  Thread, eax     ; return value
      movzx eax, _PCR KPCR.Number ; get processor number
      mov  callcnt, eax     ; return value
    }

    cpuptr = BBTBuffer + callcnt + 2;
    if( !(*cpuptr) || *(ULONG*)(*cpuptr) >= *(cpuptr+1) )
        goto fail;

    // if trapframe, count call-frames to determine record size
    EThread = CONTAINING_RECORD(Thread,ETHREAD,Tcb);
    if( (BBTBuffer[1] & 2) && EThread->Tcb.PreviousMode != KernelMode ) {

        PTEB  Teb;
        ULONG*    FramePtr;

        recsize = CAPTIDSIZE;
        FramePtr = (ULONG*)EThread->Tcb.TrapFrame;  // get trap frame
        Teb = EThread->Tcb.Teb;
        if( FramePtr && Teb ) {

            ULONG* StackBase = (ULONG*)Teb->NtTib.StackBase;
            ULONG* StackLimit = (ULONG*)Teb->NtTib.StackLimit;

            // first retadr is last thing pushed
            RetAddr[0] = *(ULONG*)(EThread->Tcb.TrapFrame->HardwareEsp);

            // count frames that have a null next frame (may have valid retadr)
            FramePtr = (ULONG*)((PKTRAP_FRAME)FramePtr)->Ebp;  // get stack frame
            for( callcnt=1; callcnt<7 && FramePtr<StackBase
                                      && FramePtr>StackLimit
                                      && *(FramePtr);
                 FramePtr = (ULONG*)*(FramePtr)) {

                RetAddr[callcnt++] = *(FramePtr+1);
            }

            recsize += (callcnt<<2);
        }
    } else {

        recsize = CAPTIDSIZE;
        callcnt=0;
    }

    _asm {

      mov eax, cpuptr
      mov edx, [eax+4]
      mov eax, [eax]

      mov ecx,recsize        ; total size of mark record
      sub edx,ecx            ; adjust EOB to account for newrec
      lock xadd [eax],ecx    ; atomically claim freespace

      cmp ecx,edx            ; if newrec goes beyond EOB
      jge  fail              ; don't log it

      mov buf, ecx           ; export tracerec destination adr
    }

    // initialize CapThreadID record (type 14)
    *((short*)buf) = (short)14;

    // insert data length (excluding 4byte header)
    *((short*)(buf+2)) = (short)(recsize-4);

    // insert Pid & Tid
    *((ULONG*)(buf+4)) = (ULONG)EThread->Cid.UniqueProcess;
    *((ULONG*)(buf+8)) = (ULONG)EThread->Cid.UniqueThread;

    // insert ImageFile name
    Process = CONTAINING_RECORD(Thread->ApcState.Process,EPROCESS,Pcb);
    memcpy(buf+12, Process->ImageFileName, 16 );

    // insert optional user call stack data
    if( recsize > CAPTIDSIZE && callcnt )
        memcpy( buf+28, RetAddr, callcnt<<2 );

    fail:
    ;
}


VOID
__stdcall
_CAP_SetCPU( VOID )

/*++

Routine description:

    Called by KiSystemService before returning to user mode.
    Sets current cpu number in Teb->Spare3 (+0xf78) so user-mode version
    of probe functions know which part of BBTBuffer to use.

--*/

{
    ULONG* cpuptr;
    ULONG  cpu;
    PTEB   Teb;

    if( !BBTBuffer || !BBTBuffer[0] )
        goto fail;

    _asm {

      movzx eax, _PCR KPCR.Number ; get processor number
      mov  cpu, eax               ; return value
    }

    cpuptr = BBTBuffer + cpu + 2;
    if( !(*cpuptr) || *(ULONG*)(*cpuptr) >= *(cpuptr+1) )
        goto fail;

    if( !(Teb = NtCurrentTeb()) )
        goto fail;

    try {
        Teb->Spare3 = cpu;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
    fail:
    ;
}




VOID
_declspec(naked)
__stdcall
_CAP_Log_1Int(

    ULONG code,
    ULONG data)

/*++

Routine description:

    Kernel-mode version of general-purpose log integer probe.
    Logs a type 15 icecap record into the part of BBTBuffer for the
    current cpu (obtained from Prcb).  Inserts code into the byte after
    length, RDTSC timestamp and the value of 'data'.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    code - type-code for trace formatting
    data - ULONG value to be logged

--*/

{
    _asm {
      push eax               ; save eax
      mov eax, BBTBuffer     ; get BBTBuffer address
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      bt [eax+4],2           ; if 0x4 bit not  set,
      jnc  return1           ;   just return

      push edx
      movzx edx, _PCR KPCR.Number ; get processor number

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return2            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return2            ;   (also return if both 0)

      push ebx
      push ecx
      mov ecx, 12            ; datalength is ULONG plus TS (4+8)

      lea ebx,[ecx+4]        ; record len is datalen + 4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge  return4           ; don't log it

      mov eax,[esp+20]       ; p1 = code (4 saved regs + retadr)
      shl eax,8              ; shift the code up 1 byte
      or  eax,15             ; or-in the record type
      mov word ptr [ebx],ax  ; insert record type and code (from p1)
      mov word ptr [ebx+2],cx ; insert datalen

      mov eax,[esp+24]       ; insert data (p2)
      mov [ebx+4],eax

      rdtsc                  ; read timestamp into edx:eax
      mov [ebx+8],eax        ; insert ts low
      mov [ebx+12],edx       ; insert ts high

    return4:                 ; restore regs & return
      pop ecx
      pop ebx
    return2:
      pop edx
    return1:
      pop eax
      ret 8                  ; 2 input parms
    }
}


#ifdef FOOBAR
VOID
_declspec(naked)
__stdcall
_CAP_LogRetries(

    ULONG retries)

/*++

Routine description:

    Logs a type 15 icecap record with specified value.

Arguments:

    retries - value to substitute in type 15 record

--*/

{
    _asm {

      push eax               ; save eax
      mov eax, BBTBuffer     ; get BBTBuffer address
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      bt [eax+4],2           ; if 0x4 bit not  set,
      jnc  return1           ;   just return

      push edx
      movzx edx, _PCR KPCR.Number ; get processor number

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return2            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return2            ;   (also return if both 0)

      push ebx
      push ecx
      mov  ecx,4             ; datalen is 4
      lea ebx,[ecx+4]        ; record len is datalen + 4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge  return4           ; don't log it

      mov word ptr[ebx],15   ; initialize CapRetries record
      mov word ptr [ebx+2],cx ; insert datalen

      mov eax,[esp+20]       ; p1 (4 saved regs + retadr)
      mov [ebx+4],eax        ; copy p1 to logrec

    return4:                 ; restore regs & return
      pop ecx
      pop ebx
    return2:
      pop edx
    return1:
      pop eax
      ret 4                  ; 1 input parm
    }
}
#endif

NTSTATUS
NtSetPMC (
    IN ULONG PMC)

/*++

Routine description:

    Sets PMC and CR4 so RDPMC 0 reads the
    desired performance counter.

Arguments:

    PMC - desired performance counter

--*/

{
    if( PMC == -1 )
        return 0;

    WRMSR(0x186, PMC);

    if( PMC & 0x10000 ) {
        _asm {

        _emit  0Fh
        _emit  20h
        _emit  0E0h          ; mov eax, cr4

        or eax, 100h

        _emit  0Fh
        _emit  22h
        _emit  0E0h          ; mov cr4, eax

        }
    }
    return STATUS_SUCCESS;
}


#else

//
// User-Mode Probe Routines (for ntdll, win32k, etc.)
// (BBTBuffer address & cpu obtained from Teb)
//


VOID
_declspec(naked)
__stdcall
_CAP_Start_Profiling(
    PVOID current,
    PVOID child)

/*++

Routine description:

    user-mode version of before-call icecap probe.  Logs a type 5
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adrs of current and called
    functions plus RDTSC timestamp into logrecord.  If BBTBuffer
    flag 1 set, also does RDPMC 0 and inserts result into logrecord.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call
    child - address of called routine

--*/

{
    _asm {

      push eax               ; save eax
      mov eax, fs:[0x18]
      mov eax, [eax+0xf7c]   ; get adr of BBTBuffer from fs
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      push ecx               ; save ecx
      bt [eax+4],0           ; if 1st flag bit set,
      jc  pmc1               ; datalen is 28
      mov ecx, CAPENTERSIZE  ; otherwise it is 20
      jmp tsonly1
    pmc1:
      mov ecx, CAPENTERSIZE2
   tsonly1:

      push ebx
      push edx               ; save edx
      mov ebx, fs:[0x18]
      xor  edx,edx
      mov dl, byte ptr [ebx+0xf78]

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; next per-cpu buffer is EOB for this cpu
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return4            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return4            ;   (also return if both 0)

      lea ebx, [ecx+4]       ; record len is datalen + 4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge return4            ; don't log it

      mov word ptr[ebx],5    ; initialize CapEnter record
      mov word ptr [ebx+2],cx

      mov eax,[esp+20]       ; p1 (4 saved regs + retadr)
      mov [ebx+4],eax

      mov eax,[esp+24]       ; p2
      mov [ebx+8],eax

      mov eax,fs:[0x18]      ; Teb adr
      mov eax, [eax] TEB.ClientId.UniqueThread
      mov [ebx+12],eax       ;

      rdtsc                  ; read timestamp into edx:eax
      mov [ebx+16],eax       ; ts low
      mov [ebx+20],edx       ; ts high

      cmp ecx, CAPENTERSIZE  ; if record length 20,
      jne  pmc2
      jmp  return4           ; skip rdpmc

    pmc2:
      xor  ecx,ecx           ; pmc0
      rdpmc                  ; read pmc into edx:eax
      mov [ebx+24],eax       ; ts low
      mov [ebx+28],edx       ; ts high

    return4:                 ; restore regs & return
      pop edx
      pop ebx
      pop ecx
    return1:
      pop eax
      ret 8                  ; 2 input parms
    }
}


VOID
_declspec(naked)
__stdcall
_CAP_End_Profiling(
    PVOID current)

/*++

Routine description:

    user-mode version of after-call icecap probe.  Logs a type 6
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adr of current function
    plus RDTSC timestamp into logrecord.  If BBTBuffer flag 1 set,
    also does RDPMC 0 and inserts result into logrecord.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call

--*/

{
    _asm {

      push eax               ; save eax
      mov eax, fs:[0x18]
      mov eax, [eax+0xf7c]     ; get adr of BBTBuffer from fs
      test eax,eax           ; if null, just return
      jz return1             ; (restore eax & return)

      push ecx               ; save ecx
      bt [eax+4],0           ; if 1st flag bit set,
      jc  pmc1               ; datalen is 20
      mov ecx, CAPEXITSIZE   ; otherwise it is 12
      jmp tsonly1
    pmc1:
      mov ecx, CAPEXITSIZE2
    tsonly1:

      push ebx
      push edx

      mov ebx, fs:[0x18]
      xor  edx,edx
      mov dl, byte ptr [ebx+0xf78]

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return4            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return4            ;   (also return if both 0)

      lea ebx, [ecx+4]       ; record len is datalen+4
      sub edx,ebx            ; adjust EOB to account for newrec
      lock xadd [eax],ebx    ; atomically claim freespace

      cmp ebx,edx            ; if newrec goes beyond EOB
      jge  return4           ; don't log it

      mov word ptr[ebx],6    ; initialize CapExit record
      mov word ptr [ebx+2],cx ; insert datalen

      mov eax,[esp+20]       ; p1 (4 saved regs + retadr)
      mov [ebx+4],eax

      rdtsc                  ; read timestamp into edx:eax
      mov [ebx+8],eax        ; ts low
      mov [ebx+12],edx       ; ts high

      cmp ecx, CAPEXITSIZE   ; if datalen is 12,
      jne  pmc2
      jmp  return4           ; skip rdpmc

    pmc2:
      xor  ecx,ecx           ; pmc0
      rdpmc                  ; read pmc into edx:eax
      mov [ebx+16],eax       ; ts low
      mov [ebx+20],edx       ; ts high

    return4:                 ; restore regs & return
      pop edx
      pop ebx
      pop ecx
    return1:
      pop eax
      ret 4                  ; 1 input parm
    }
}

#endif

//
// Common Support Routines
// (method for getting BBTBuffer address & cpu ifdef'ed for kernel & user)
//

VOID
_declspec(naked) 
__cdecl
CAP_Log_NInt(

    UCHAR code,
    UCHAR log_timestamp,
    USHORT intcount, 
    ...)
/*++

Routine description:

    Kernel-mode and User-mode versions of general-purpose log integer probe.
    Logs a type 16 icecap record into the part of BBTBuffer for the
    current cpu (obtained from Prcb).  Inserts lowest byte of code into the 
    byte after length, the RDTSC timestamp (if log_timestamp != 0), and
    intcount DWORDS.  Uses lock xadd to claim buffer space without the need 
    for spinlocks.

Arguments:

    code - type-code for trace formatting (really only a single byte)
    log_timestamp - non-zero if timestamp should be logged
    intcount - number of ULONGs to log
    remaining arguments - ULONG value(s) to be logged

--*/

{

#ifndef NTOS_KERNEL_RUNTIME
    ULONG* BBTBuffer;
#endif

    _asm {
      push ebp
      push eax

#ifdef NTOS_KERNEL_RUNTIME
      mov eax, BBTBuffer
#else
      mov ebp, esp
      sub esp, __LOCAL_SIZE
    }

    BBTBuffer = NtCurrentTeb()->ReservedForPerf;    // stored in ebp-4

    _asm {
      mov eax, BBTBuffer
      add esp, __LOCAL_SIZE
#endif


      test eax,eax           ; if null, just return
      jz return2             ; (restore eax & return)

      push edx
      push ecx

      mov edx, [eax]
      test edx, edx
      jz return4

      bt [eax+4],2           ; if 0x4 bit not  set,
      jnc  return4           ;   just return

#ifdef NTOS_KERNEL_RUNTIME
      movzx edx, _PCR KPCR.Number ; get processor number
#else
      mov ecx, fs:[0x18]
      xor   edx,edx
      mov dl, byte ptr [ecx+0xf78]
#endif

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  return4            ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge return4            ;   (also return if both 0)

      push esi
      push edi

      mov ecx, [esp+28]
      mov esi, ecx
      and esi, 00000FF00h
      shr ecx, 16
      shl ecx, 2
      test esi, esi

      jz skip_timestamp

      add ecx, 8

skip_timestamp:

      lea edi,[ecx+4]        ; record len is datalen + 4
      sub edx,edi            ; adjust EOB to account for newrec
      lock xadd [eax],edi    ; atomically claim freespace

      cmp edi,edx            ; if newrec goes beyond EOB
      jge  return6           ; don't log it

      mov eax,[esp+28] 
      shl eax,8              ; shift the code up 1 byte
      or  eax,16             ; or-in the record type
      mov word ptr [edi],ax  ; insert record type and code
      mov word ptr [edi+2],cx ; insert datalen
      add edi, 4
      test esi, esi
      jz copy_data

      rdtsc                  ; read timestamp into edx:eax
      mov [edi], eax       ; insert ts low
      mov [edi+4], edx       ; insert ts high
      add edi, 8

copy_data:
      mov esi, esp
      add esi, 32
      mov ecx, [esp+28]
      shr ecx, 16
      rep movsd              ; move ecx dwords from esi to edi

return6:
      pop edi
      pop esi
return4:
      pop ecx
      pop edx
return2:
      pop eax
      pop ebp
      ret
    }

}

VOID
__cdecl
CAP_Log_NInt_Clothed(

    ULONG Bcode_Bts_Scount,
/*
    UCHAR code,
    UCHAR log_timestamp,
    USHORT intcount, 
*/
    ...)
/*++

Routine description:

    Kernel-mode and User-mode versions of general-purpose log integer probe.
    Logs a type 16 icecap record into the part of BBTBuffer for the
    current cpu (obtained from Prcb).  Inserts lowest byte of code into the 
    byte after length, the RDTSC timestamp (if log_timestamp != 0), and
    intcount DWORDS.  Uses lock xadd to claim buffer space without the need 
    for spinlocks.

Arguments:

    code - type-code for trace formatting (really only a single byte)
    log_timestamp - non-zero if timestamp should be logged
    intcount - number of ULONGs to log
    remaining arguments - ULONG value(s) to be logged

--*/

{
    _asm {

#ifndef NTOS_KERNEL_RUNTIME
      mov   eax, fs:[0x18]
      mov   eax, [eax+0xf7c]      ; get adr of BBTBuffer from fs
#else
      mov   eax, BBTBuffer        ; get BBTBuffer address
#endif

      test  eax, eax              ; if null, just return
      jz    end

      mov   edx, [eax]            ; if null, just return
      test  edx, edx
      jz    end

      bt    [eax+4], 2            ; if 0x4 bit not set, return
      jnc   end

#ifdef NTOS_KERNEL_RUNTIME
      movzx edx, _PCR KPCR.Number ; get processor number
#else
      mov    ecx, fs:[0x18]
      xor    edx, edx
      mov    dl, byte ptr [ecx+0xf78]
#endif

      lea    eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov    edx, [eax+4]         ; ptr to next buffer is end of this one
      mov    eax, [eax]           ; eax now points to freeptr for this cpu
      or     eax, eax             ; if ptr to freeptr not set up yet,
      jz     end                  ;   just return

      cmp    [eax], edx           ; if freeptr >= EOB, don't trace
      jge    end                  ;   (also return if both 0)

      mov    ecx, Bcode_Bts_Scount

      push   esi
      push   edi

      mov    esi, ecx
      shr    ecx, 16
      shl    ecx, 2
      and    esi, 00000FF00h
      test   esi, esi

      jz     skip_timestamp

      add    ecx, 8

skip_timestamp:

      lea    edi, [ecx+4]         ; record len is datalen + 4
      sub    edx, edi             ; adjust EOB to account for newrec
 lock xadd   [eax], edi           ; atomically claim freespace

      cmp    edi, edx             ; if newrec goes beyond EOB
      jge    end0                 ; don't log it

      mov    eax, Bcode_Bts_Scount
      and    eax, 0xff
      shl    eax, 8               ; shift the code up 1 byte
      or     eax, 16              ; or-in the record type
      mov    word ptr [edi], ax   ; insert record type and code
      mov    word ptr [edi+2], cx ; insert datalen
      add    edi, 4
      test   esi, esi
      jz     copy_data

      rdtsc                       ; read timestamp into edx:eax
      mov    [edi], eax           ; insert ts low
      mov    [edi+4], edx         ; insert ts high
      add    edi, 8

copy_data:
      lea    esi, Bcode_Bts_Scount; compute start of integer list
      add    esi, 4          

      mov    ecx, Bcode_Bts_Scount
      shr    ecx, 16
      rep    movsd                ; move ecx dwords from esi to edi
end0:
      pop    edi
      pop    esi

end:
    }

    return;
}


VOID
CAPKComment(

    char* Format, ...)

/*++

Routine description:

    Logs a free-form comment (record type 13) in the icecap trace

Arguments:

    Format - printf-style format string and substitutional parms

--*/

{
    va_list arglist;
    UCHAR   Buffer[512];
    int cb, insize, outsize;
    char*   buf;
    char*   data;
    ULONG   BufEnd;
    ULONG   FreePtr;
#ifndef NTOS_KERNEL_RUNTIME
    ULONG* BBTBuffer = NtCurrentTeb()->ReservedForPerf;
#endif

    if( !BBTBuffer || !BBTBuffer[0] )
        goto fail;

    _asm {

#ifdef NTOS_KERNEL_RUNTIME
      movzx edx, _PCR KPCR.Number ; get processor number
#else
      mov ecx, fs:[0x18]
      xor   edx,edx
      mov dl, byte ptr [ecx+0xf78]
#endif

      lea eax, [eax][edx*4]+8  ; offset to freeptr ptr = (cpu * 4) + 8

      mov edx, [eax+4]       ; ptr to next buffer is end of this one
      mov eax, [eax]         ; eax now points to freeptr for this cpu
      or  eax,eax            ; if ptr to freeptr not set up yet,
      jz  fail               ;   just return

      cmp [eax],edx          ; if freeptr >= EOB, don't trace
      jge fail               ;   (also return if both 0)

      mov FreePtr,eax        ; save freeptr & buffer end adr
      mov BufEnd,edx
    }

    va_start(arglist, Format);

    //
    //    Do the following call in assembler so it won't get instrumented
    //    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    //

    _asm {

        push arglist         ; arglist
        push Format          ; Format
        push 512             ; sizeof(Buffer)
        lea  eax,Buffer
        push eax             ; Buffer
        call _vsnprintf
        add  esp,16          ; adj stack for 4 parameters
        mov  cb, eax         ; return value
    }

    va_end(arglist);

    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }

    data = &Buffer[0];
    insize = strlen(data);             // save insize for data copy
    outsize = ((insize+7) & 0xfffffffc);  // pad outsize to DWORD boundary
                                       // +4 to account for hdr, +3 to pad

    _asm {

      mov eax, FreePtr       ; restore FreePtr & EOB
      mov edx, BufEnd
      mov ecx,outsize        ; total size of mark record
      sub edx,ecx            ; adjust EOB to account for newrec
      lock xadd [eax],ecx    ; atomically claim freespace

      cmp ecx,edx            ; if newrec goes beyond EOB
      jge  fail              ; don't log it

      mov buf, ecx           ; export tracerec destination adr
    }

    // size in tracerec excludes 4byte hdr
    outsize -= 4;

    // initialize CapkComment record (type 13)
    *((short*)(buf)) = (short)13;

    // insert size
    *((short*)(buf+2)) = (short)outsize;

    // insert sprintf data
    memcpy(buf+4, data, insize );

    // if had to pad, add null terminator to string
    if( outsize > insize )
        *(buf+4+insize) = 0;

  fail:
    return;
}


//
// Constants for CAPKControl
//

#define CAPKStart   1
#define CAPKStop    2
#define CAPKResume  3
#define MAXDUMMY    30
#define CAPK0       4


int CAPKControl(

    ULONG opcode)

/*++

Routine description:

    CAPKControl

Description:

    Starts, stops or pauses icecap tracing

Arguments:

    opcode - 1=start, 2=stop, 3=resume, 4,5,6,7 reserved

Return value:

    1 = success, 0 = BBTBuf not set up

--*/

{
    ULONG i;
    ULONG cpus;
    ULONG percpusize;
    ULONG pwords;
    ULONG* ptr1;


#ifdef NTOS_KERNEL_RUNTIME
    cpus = KeNumberProcessors;
#else
    ULONG* BBTBuffer= NtCurrentTeb()->ReservedForPerf;

    cpus = NtCurrentPeb()->NumberOfProcessors;
#endif


    if( !BBTBuffer || !(BBTBuffer[0]) )
        return 0;

    pwords = CAPK0 + cpus;
    percpusize = ((BBTBuffer[0]*1024) - pwords)/cpus;  // in DWORDs


    if(opcode == CAPKStart) {        // start

        ULONG j;


        // clear freeptr ptrs (including final ptr)
        for( i=0; i<cpus+1; i++ )
            BBTBuffer[2+i] = 0;

        // initialize each freeptr to next dword
        // (and log dummy records to calibrate overhead)
        for( i=0, ptr1 = BBTBuffer+pwords; i<cpus; i++, ptr1+=percpusize) {

            *ptr1 = (ULONG)(ptr1+1);

//            for( j=0; j<MAXDUMMY; j++ ) {
//
//                _CAP_Start_Profiling(ptr, NULL);
//                _CAP_End_Profiling(ptr);
//
//            }
        }
        // set up freeptr ptrs (including final ptr)
        for(i=0, ptr1=BBTBuffer+pwords; i<cpus+1; i++, ptr1+=percpusize)
            BBTBuffer[2+i] = (ULONG)ptr1;

    } else if( opcode == CAPKStop ) {  // stop

        for(i=0; i<cpus+1; i++)
            BBTBuffer[2+i] = 0;

    } else if( opcode == CAPKResume ) { //resume

        // set up freeptr ptrs (including final ptr)
        for(i=0, ptr1=BBTBuffer+pwords; i<cpus+1; i++, ptr1+=percpusize)
            BBTBuffer[2+i] = (ULONG)ptr1;

    } else {
        return 0;                      // invalid opcode
    }
    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\exdsptch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

Author:

    David N. Cutler (davec) 13-Aug-1989

Environment:

    Any mode.

Revision History:

    10 april 90 bryanwi

            Port to the 386.

--*/

#include "ntrtlp.h"

//
// Dispatcher context structure definition.
//

typedef struct _DISPATCHER_CONTEXT {
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;

//
// Execute handler for exception function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

//
// Execute handler for unwind function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

typedef struct {
    PVOID Handler;
    PULONG HandlerTable;
    ULONG HandlerTableLength;
    ULONG MatchedEntry;
} HANDLERLIST;

HANDLERLIST HandlerList[5];
int HandlerCount;

VOID
RtlInvalidHandlerDetected(
    PVOID Handler, 
    PULONG FunctionTable,
    ULONG FunctionTableLength
    )
{
#if 0       // Disable for RTM builds.
    HANDLERLIST *ph = &HandlerList[HandlerCount%5];
    
    ph->Handler = Handler;
    ph->MatchedEntry = 0;
    ph->HandlerTable = FunctionTable;
    ph->HandlerTableLength = FunctionTableLength;
    HandlerCount++;
    DbgPrint("InvalidHandler - call x67289: %x\n", Handler);
    DbgBreakPoint();
#endif
    return;
}


BOOLEAN
RtlIsValidHandler (
    IN PEXCEPTION_ROUTINE Handler
    )
{
    PULONG FunctionTable;
    ULONG FunctionTableLength;
    PVOID Base;

    FunctionTable = RtlLookupFunctionTable(Handler, &Base, &FunctionTableLength);

    if (FunctionTable && FunctionTableLength) {
        PEXCEPTION_ROUTINE FunctionEntry;
        LONG High, Middle, Low;

        if ((FunctionTable == LongToPtr(-1)) && (FunctionTableLength == (ULONG)-1)) {
            // Address is in an image that shouldn't have any handlers (like a resource only dll).
            RtlInvalidHandlerDetected((PVOID)((ULONG)Handler+(ULONG)Base), LongToPtr(-1), -1);
            return FALSE;
        }
    
        // Bias the handler value down by the image base and see if the result
        // is in the table

        (ULONG)Handler -= (ULONG)Base;
        Low = 0;
        High = FunctionTableLength;
        while (High >= Low) {
            Middle = (Low + High) >> 1;
            FunctionEntry = (PEXCEPTION_ROUTINE)FunctionTable[Middle];
            if (Handler < FunctionEntry) {
                High = Middle - 1;
            } else if (Handler > FunctionEntry) {
                Low = Middle + 1;
            } else {
                // found it
                return TRUE;
            }
        }
        // Didn't find it
        RtlInvalidHandlerDetected((PVOID)((ULONG)Handler+(ULONG)Base), FunctionTable, FunctionTableLength);

        return FALSE;
    }

    // Can't verify
    return TRUE;
}


BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a call frame based
    handler by searching backwards through the stack based call frames. The
    search begins with the frame specified in the context record and continues
    backward until either a handler is found that handles the exception, the
    stack is found to be invalid (i.e., out of limits or unaligned), or the end
    of the call hierarchy is reached.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    ULONG Index;

#ifndef NTOS_KERNEL_RUNTIME
    if (RtlCallVectoredExceptionHandlers(ExceptionRecord,ContextRecord)) {
        return TRUE;
    }
#endif // NTOS_KERNEL_RUNTIME

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handler the exception.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    NestedRegistration = 0;

    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then set the stack invalid flag in the
        // exception record and return FALSE. Else check to determine if the
        // frame has an exception handler.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) 
#if !defined(NTOS_KERNEL_RUNTIME)
                ||
             (((ULONG)RegistrationPointer->Handler >= LowLimit) && ((ULONG)RegistrationPointer->Handler < HighLimit))
#endif
           ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart
                    // the loop.
                    //

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            return FALSE;
        }

        // See if the handler is reasonable

        if (!RtlIsValidHandler(RegistrationPointer->Handler)) {
            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            return FALSE;
        }

        //
        // The handler must be executed by calling another routine
        // that is written in assembler. This is required because
        // up level addressing of the handler information is required
        // when a nested exception is encountered.
        //

        if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
            Index = RtlpLogExceptionHandler(
                            ExceptionRecord,
                            ContextRecord,
                            0,
                            (PULONG)RegistrationPointer,
                            4 * sizeof(ULONG));
                    // can't use sizeof(EXCEPTION_REGISTRATION_RECORD
                    // because we need the 2 dwords above it.
        }

        Disposition = RtlpExecuteHandlerForException(
            ExceptionRecord,
            (PVOID)RegistrationPointer,
            ContextRecord,
            (PVOID)&DispatcherContext,
            (PEXCEPTION_ROUTINE)RegistrationPointer->Handler);

        if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
            RtlpLogLastExceptionDisposition(Index, Disposition);
        }

        //
        // If the current scan is within a nested context and the frame
        // just examined is the end of the context region, then clear
        // the nested context frame and the nested exception in the
        // exception flags.
        //

        if (NestedRegistration == RegistrationPointer) {
            ExceptionRecord->ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
            NestedRegistration = 0;
        }

        //
        // Case on the handler disposition.
        //

        switch (Disposition) {

            //
            // The disposition is to continue execution. If the
            // exception is not continuable, then raise the exception
            // STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return
            // TRUE.
            //

        case ExceptionContinueExecution :
            if ((ExceptionRecord->ExceptionFlags &
               EXCEPTION_NONCONTINUABLE) != 0) {
                ExceptionRecord1.ExceptionCode =
                                        STATUS_NONCONTINUABLE_EXCEPTION;
                ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord1.ExceptionRecord = ExceptionRecord;
                ExceptionRecord1.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord1);
            } else {
                return TRUE;
            }

            //
            // The disposition is to continue the search. If the frame isn't
            // suspect/corrupt, get next frame address and continue the search 
            //

        case ExceptionContinueSearch :
            if (ExceptionRecord->ExceptionFlags & EXCEPTION_STACK_INVALID)
                return FALSE;

            break;

            //
            // The disposition is nested exception. Set the nested
            // context frame to the establisher frame address and set
            // nested exception in the exception flags.
            //

        case ExceptionNestedException :
            ExceptionRecord->ExceptionFlags |= EXCEPTION_NESTED_CALL;
            if (DispatcherContext.RegistrationPointer > NestedRegistration) {
                NestedRegistration = DispatcherContext.RegistrationPointer;
            }
            break;

            //
            // All other disposition values are invalid. Raise
            // invalid disposition exception.
            //

        default :
            ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
            ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord1.ExceptionRecord = ExceptionRecord;
            ExceptionRecord1.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord1);
            break;
        }

        //
        // If chain goes in wrong direction or loops, report an
        // invalid exception stack, otherwise go on to the next one.
        //

        RegistrationPointer = RegistrationPointer->Next;
    }
    return FALSE;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    walk through the procedure call frames is then performed to find the target
    of the unwind operation.

    N.B.    The captured context passed to unwinding handlers will not be
            a  completely accurate context set for the 386.  This is because
            there isn't a standard stack frame in which registers are stored.

            Only the integer registers are affected.  The segement and
            control registers (ebp, esp) will have correct values for
            the flat 32 bit environment.

    N.B.    If you change the number of arguments, make sure you change the
            adjustment of ESP after the call to RtlpCaptureContext (for
            STDCALL calling convention)

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{
    PCONTEXT ContextRecord;
    CONTEXT ContextRecord1;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD PriorPointer;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    EXCEPTION_RECORD ExceptionRecord2;

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionFlags = 0;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = _ReturnAddress();
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then set EXCEPTION_UNWINDING
    // flag in the exception flags. Otherwise set both EXCEPTION_EXIT_UNWIND and
    // EXCEPTION_UNWINDING flags in the exception flags.
    //

    if (ARGUMENT_PRESENT(TargetFrame) == TRUE) {
        ExceptionRecord->ExceptionFlags |= EXCEPTION_UNWINDING;
    } else {
        ExceptionRecord->ExceptionFlags |= (EXCEPTION_UNWINDING |
                                                        EXCEPTION_EXIT_UNWIND);
    }

    //
    // Capture the context.
    //

    ContextRecord = &ContextRecord1;
    ContextRecord1.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
    RtlpCaptureContext(ContextRecord);

    //
    // Adjust captured context to pop our arguments off the stack
    //
    ContextRecord->Esp += sizeof(TargetFrame) +
                          sizeof(TargetIp)    +
                          sizeof(ExceptionRecord) +
                          sizeof(ReturnValue);
    ContextRecord->Eax = (ULONG)ReturnValue;

    //
    // Scan backward through the call frame hierarchy, calling exception
    // handlers as they are encountered, until the target frame of the unwind
    // is reached.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If this is the target of the unwind, then continue execution
        // by calling the continue system service.
        //

        if ((ULONG)RegistrationPointer == (ULONG)TargetFrame) {
            ZwContinue(ContextRecord, FALSE);

        //
        // If the target frame is lower in the stack than the current frame,
        // then raise STATUS_INVALID_UNWIND exception.
        //

        } else if ( (ARGUMENT_PRESENT(TargetFrame) == TRUE) &&
                    ((ULONG)TargetFrame < (ULONG)RegistrationPointer) ) {
            ExceptionRecord2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        }

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then raise the exception STATUS_BAD_STACK.
        // Else restore the state from the specified frame to the context
        // record.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) 
#if !defined(NTOS_KERNEL_RUNTIME)
                ||
             (((ULONG)RegistrationPointer->Handler >= LowLimit) && ((ULONG)RegistrationPointer->Handler < HighLimit))
#endif
           ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart
                    // the loop.
                    //

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord2.ExceptionCode = STATUS_BAD_STACK;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        } else {

            //
            // The handler must be executed by calling another routine
            // that is written in assembler. This is required because
            // up level addressing of the handler information is required
            // when a collided unwind is encountered.
            //

            Disposition = RtlpExecuteHandlerForUnwind(
                ExceptionRecord,
                (PVOID)RegistrationPointer,
                ContextRecord,
                (PVOID)&DispatcherContext,
                RegistrationPointer->Handler);

            //
            // Case on the handler disposition.
            //

            switch (Disposition) {

                //
                // The disposition is to continue the search. Get next
                // frame address and continue the search.
                //

            case ExceptionContinueSearch :
                break;

                //
                // The disposition is colided unwind. Maximize the target
                // of the unwind and change the context record pointer.
                //

            case ExceptionCollidedUnwind :

                //
                // Pick up the registration pointer that was active at
                // the time of the unwind, and simply continue.
                //

                RegistrationPointer = DispatcherContext.RegistrationPointer;
                break;


                //
                // All other disposition values are invalid. Raise
                // invalid disposition exception.
                //

            default :
                ExceptionRecord2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord2.ExceptionRecord = ExceptionRecord;
                ExceptionRecord2.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord2);
                break;
            }

            //
            // Step to next registration record
            //

            PriorPointer = RegistrationPointer;
            RegistrationPointer = RegistrationPointer->Next;

            //
            // Unlink the unwind handler, since it's been called.
            //

            RtlpUnlinkHandler(PriorPointer);

            //
            // If chain goes in wrong direction or loops, raise an
            // exception.
            //

        }
    }

    if (TargetFrame == EXCEPTION_CHAIN_END) {

        //
        //  Caller simply wants to unwind all exception records.
        //  This differs from an exit_unwind in that no "exit" is desired.
        //  Do a normal continue, since we've effectively found the
        //  "target" the caller wanted.
        //

        ZwContinue(ContextRecord, FALSE);

    } else {

        //
        //  Either (1) a real exit unwind was performed, or (2) the
        //  specified TargetFrame is not present in the exception handler
        //  list.  In either case, give debugger and subsystem a chance
        //  to see the unwind.
        //

        ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);

    }
    return;
}

#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\largeint.asm ===
TITLE   "Large Integer Arithmetic"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    largeint.s
;
; Abstract:
;
;    This module implements routines for performing extended integer
;    arithmtic.
;
; Author:
;
;    David N. Cutler (davec) 24-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFNDEF BLDR_KERNEL_RUNTIME
        EXTRNP  _RtlRaiseStatus, 1
ENDIF


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlLargeIntegerAdd"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerAdd (
;    IN LARGE_INTEGER Addend1,
;    IN LARGE_INTEGER Addend2
;    )
;
; Routine Description:
;
;    This function adds a signed large integer to a signed large integer and
;    returns the signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Addend1 - first addend value
;    (TOS+12) = Addend2 - second addend value
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerAdd ,4
cPublicFpo 4,0

        mov     eax,[esp]+4             ; (eax)=add1.low
        add     eax,[esp]+12            ; (eax)=sum.low
        mov     edx,[esp]+8             ; (edx)=add1.hi
        adc     edx,[esp]+16            ; (edx)=sum.hi
        stdRET    _RtlLargeIntegerAdd

stdENDP _RtlLargeIntegerAdd


        page
        subttl  "Enlarged Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlEnlargedIntegerMultiply (
;    IN LONG Multiplicand,
;    IN LONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed integer by an signed integer and
;    returns a signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Factor1
;    (TOS+8) = Factor2
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc __RtlEnlargedIntegerMultiply ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = factor1
        imul    dword ptr [esp]+8       ; (edx:eax) = signed result
        stdRET    __RtlEnlargedIntegerMultiply

stdENDP __RtlEnlargedIntegerMultiply


        page
        subttl  "Enlarged Unsigned Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlEnlargedUnsignedMultiply (
;    IN ULONG Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies an un signed integer by an unsigned integer and
;    returns a signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Factor1
;    (TOS+8) = Factor2
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc __RtlEnlargedUnsignedMultiply ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = factor1
        mul     dword ptr [esp]+8       ; (edx:eax) = unsigned result
        stdRET    __RtlEnlargedUnsignedMultiply

stdENDP __RtlEnlargedUnsignedMultiply

        page
        subttl  "Enlarged Unsigned Integer Divide"

;++
;
; ULONG
; RtlEnlargedUnsignedDivide (
;    IN ULARGE_INTEGER Dividend,
;    IN ULONG Divisor,
;    IN PULONG Remainder
;    )
;
;
; Routine Description:
;
;    This function divides an unsigned large integer by an unsigned long
;    and returns the resultant quotient and optionally the remainder.
;
; Arguments:
;
;    Dividend - Supplies the dividend value.
;
;    Divisor - Supplies the divisor value.
;
;    Remainder - Supplies an optional pointer to a variable that
;        receives the remainder.
;
; Return Value:
;
;    The unsigned long integer quotient is returned as the function value.
;
;--

cPublicProc __RtlEnlargedUnsignedDivide,4
cPublicFpo 4,0

        mov     eax, [esp+4]            ; (eax) = Dividend.LowPart
        mov     edx, [esp+8]            ; (edx) = Dividend.HighPart
        mov     ecx, [esp+16]           ; (ecx) = pRemainder
        div     dword ptr [esp+12]      ; divide by Divisor

        or      ecx, ecx                ; return remainder?
        jnz     short @f

        stdRET    __RtlEnlargedUnsignedDivide    ; (eax) = Quotient

align 4
@@:     mov     [ecx], edx              ; save remainder
        stdRET    __RtlEnlargedUnsignedDivide    ; (eax) = Quotient

stdENDP __RtlEnlargedUnsignedDivide

        page
        subttl  "Extended Large Integer Divide"

;++
;
; LARGE_INTEGER
; RtlExtendedLargeIntegerDivide (
;     IN LARGE_INTEGER Dividend,
;     IN ULONG Divisor,
;     OUT PULONG Remainder OPTIONAL
;     )
;
; Routine Description:
;
;     This routine divides an unsigned 64 bit dividend by a 32 bit divisor
;     and returns a 64-bit quotient, and optionally the 32-bit remainder.
;
;
; Arguments:
;
;     Dividend - Supplies the 64 bit dividend for the divide operation.
;
;     Divisor - Supplies the 32 bit divisor for the divide operation.
;
;     Remainder - Supplies an optional pointer to a variable which receives
;         the remainder
;
; Return Value:
;
;     The 64-bit quotient is returned as the function value.
;
;--

cPublicProc _RtlExtendedLargeIntegerDivide, 4
cPublicFpo 4,3

        push    esi
        push    edi
        push    ebx

        mov     eax, [esp+16]       ; (eax) = Dividend.LowPart
        mov     edx, [esp+20]       ; (edx) = Dividend.HighPart

lid00:  mov     ebx, [esp+24]       ; (ebx) = Divisor
        or      ebx, ebx
        jz      short lid_zero      ; Attempted a divide by zero

        push    ebp

        mov     ecx, 64             ; Loop count
        xor     esi, esi            ; Clear partial remainder

; (edx:eax) = Dividend
; (ebx) = Divisor
; (ecx) = Loop count
; (esi) = partial remainder

align 4
lid10:  shl     eax, 1              ; (LowPart << 1)  | 0
        rcl     edx, 1              ; (HighPart << 1) | CF
        rcl     esi, 1              ; (Partial << 1)  | CF

        sbb     edi, edi            ; clone CF into edi (0 or -1)

        cmp     esi, ebx            ; check if partial remainder less then divisor
        cmc
        sbb     ebp, ebp            ; clone CF intp ebp
        or      edi, ebp            ; merge with remainder of high bit

        sub     eax, edi            ; merge quotient bit
        and     edi, ebx            ; Select divisor or 0
        sub     esi, edi

        dec     ecx                 ; dec interration count
        jnz     short lid10         ; go around again

        pop     ebp
        pop     ebx
        pop     edi

        mov     ecx, [esp+20]       ; (ecx) = Remainder
        or      ecx, ecx
        jnz     short lid20

        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

align 4
lid20:
        mov     [ecx], esi          ; store remainder
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

lid_zero:
IFNDEF BLDR_KERNEL_RUNTIME
        stdCall _RtlRaiseStatus, <STATUS_INTEGER_DIVIDE_BY_ZERO>
ENDIF
        pop     ebx
        pop     edi
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

stdENDP     _RtlExtendedLargeIntegerDivide

        page
        subttl  "Extended Magic Divide"
;++
;
; LARGE_INTEGER
; RtlExtendedMagicDivide (
;    IN LARGE_INTEGER Dividend,
;    IN LARGE_INTEGER MagicDivisor,
;    IN CCHAR ShiftCount
;    )
;
; Routine Description:
;
;    This function divides a signed large integer by an unsigned large integer
;    and returns the signed large integer result. The division is performed
;    using reciprocal multiplication of a signed large integer value by an
;    unsigned large integer fraction which represents the most significant
;    64-bits of the reciprocal divisor rounded up in its least significant bit
;    and normalized with respect to bit 63. A shift count is also provided
;    which is used to truncate the fractional bits from the result value.
;
; Arguments:
;
;   (ebp+8) = Dividend
;   (ebp+16) = MagicDivisor value is a 64-bit multiplicative reciprocal
;   (ebp+24) = ShiftCount - Right shift adjustment value.
;
; Return Value:
;
;    The large integer result is stored  in (edx:eax)
;
;--

RemdDiv     equ [ebp+8]             ; Dividend
RemdRec     equ [ebp+16]            ; Reciprocal (magic divisor)
RemdShift   equ [ebp+24]
RemdTmp1    equ [ebp-4]
RemdTmp2    equ [ebp-8]
RemdTmp3    equ [ebp-12]

cPublicProc _RtlExtendedMagicDivide ,5

        push    ebp
        mov     ebp,esp
        sub     esp,12
        push    esi

        mov     esi, RemdDiv+4
        test    esi,80000000h
        jz      remd10                  ; no sign, no need to negate

        neg     dword ptr RemdDiv+4
        neg     dword ptr RemdDiv
        sbb     dword ptr RemdDiv+4,0   ; negate

remd10: mov     eax,RemdRec
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.lo
        mov     RemdTmp1,edx

        mov     eax,RemdRec
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.hi * Rec.lo
        mov     RemdTmp2,eax
        mov     RemdTmp3,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.hi

;
;   Col 0 doesn't matter
;   Col 1 = Hi(Div.lo * Rec.lo) + Low(Div.Hi * Rec.lo) + Low(Div.lo * Rec.hi)
;         = RemdTmp1 + RemdTmp2 + eax
;         -> Only want carry from Col 1
;

        xor     ecx,ecx                 ; (ecx) = 0
        add     eax,RemdTmp1
        adc     ecx, 0                  ; save carry in ecx
        add     eax,RemdTmp2
        adc     ecx, 0                  ; Save Carry, all we want from Col2

        mov     RemdTmp1,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.Hi * Rec.Hi

;
;   TOS = carry flag from Col 1
;
;   Col 2 = Col1 CF +
;           Hi(Div.Hi * Rec.Lo) + Hi(Div.Lo * Rec.Hi) + Low(Div.Hi * Rec.Hi)
;         = CF + RemdTmp3 + RemdTmp1 + eax
;
;   Col 3 = Col2 CF + Hi(Div.Hi * Rec.Hi)
;         = CF + edx
;

        add     eax,RemdTmp1
        adc     edx, 0                  ; add carry to edx
        add     eax,RemdTmp3            ; (eax) = col 2
        adc     edx, 0                  ; add carry to edx
        add     eax, ecx
        adc     edx, 0                  ; (edx) = col 3

;
;   (edx:eax) = the high 64 bits of the multiply, shift it right by
;               shift count to discard bits to right of virtual decimal pt.
;
;   RemdShift could be as large as 63 and still not 0 the result, 386
;   will only shift 31 bits at a time, so must do the sift multiple
;   times to get correct effect.
;

        mov     cl,RemdShift
remd20: cmp     cl,31
        jbe     remd30
        sub     cl,31
        shrd    eax,edx,31
        shr     edx,31
        jmp     remd20

remd30: shrd    eax,edx,cl
        shr     edx,cl

;
;   Negate the result if need be
;

        test    esi,80000000h
        jz      remd40                  ; no sign, go return without negate

        neg     edx
        neg     eax
        sbb     edx,0

;
;   Store the result
;

remd40:
        ; results in (edx:eax)

        pop     esi
        mov     esp,ebp
        pop     ebp
        stdRET    _RtlExtendedMagicDivide

stdENDP _RtlExtendedMagicDivide


        page
        subttl  "Extended Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlExtendedIntegerMultiply (
;    IN LARGE_INTEGER Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed large integer by a signed integer and
;    returns the signed large integer result.
;
; Arguments:
;
;   (ebp+8,12)=multiplican (MCAN)
;   (ebp+16)=multiplier (MPER)
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

ReimMCAN    equ <dword ptr [ebp+8]>
ReimMPER    equ <dword ptr [ebp+16]>

cPublicProc _RtlExtendedIntegerMultiply ,3

        push    ebp
        mov     ebp,esp
        push    esi

        mov     esi,ReimMPER
        xor     esi,ReimMCAN+4              ; (esi) = result sign

        test    ReimMCAN+4,80000000h
        jz      short reim10                ; MCAN pos, go look at MPER

        neg     dword ptr ReimMCAN+4
        neg     dword ptr ReimMCAN
        sbb     dword ptr ReimMCAN+4,0      ; negate multiplican

reim10: test    ReimMPER,80000000h
        jz      short reim20                ; MPER pos, go do multiply

        neg     dword ptr ReimMPER          ; negate multiplier

reim20: mov     eax,ReimMPER
        mul     dword ptr ReimMCAN          ; (edx:eax) = MPER * MCAN.low
        push    edx
        mov     ecx, eax
        mov     eax,ReimMPER
        mul     dword ptr ReimMCAN+4        ; (edx:eax) = MPER * MCAN.high
        add     eax,[esp]                   ; (eax) = hi part of MPER*MCAN.low
                                            ;   plus low part of MPER*MCAN.hi

        test    esi,80000000h
        jz      short reim30                ; result sign is OK, go return

        neg     eax
        neg     ecx
        sbb     eax,0                       ; negate result

reim30: add     esp,4                       ; clean eax off stack
        pop     esi                         ; restore nonvolatile reg
        mov     edx,eax                     ; (edx:ecx) = result
        mov     eax,ecx                     ; (edx:eax) = result

        pop     ebp
        stdRET    _RtlExtendedIntegerMultiply

stdENDP _RtlExtendedIntegerMultiply

        page
        subttl  "Large Integer Shift Left"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerShiftLeft (
;     IN LARGE_INTEGER LargeInteger,
;     IN CCHAR ShiftCount
;     )
;
;
; Routine Description:
;
;     This routine does a left logical shift of a large integer by a
;     specified amount (ShiftCount) modulo 64.
;
; Arguments:
;
;     LargeInteger - Supplies the large integer to be shifted
;
;     ShiftCount - Supplies the left shift count
;
; Return Value:
;
;     LARGE_INTEGER - Receives the shift large integer result
;
;--
cPublicProc _RtlLargeIntegerShiftLeft,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jnc     short sl10
;
;  Shift count is less then 32 bits.
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl

        stdRET  _RtlLargeIntegerShiftLeft

align 4
sl10:
;
;  Shift count is greater than or equal 32 bits - low half of result is zero,
;  high half is the low half shifted left by remaining count.
;
        mov     edx, [esp+4]            ; (edx) = LargeInteger.LowPart
        xor     eax, eax                ; store lowpart
        shl     edx, cl                 ; store highpart

        stdRET  _RtlLargeIntegerShiftLeft

stdENDP _RtlLargeIntegerShiftLeft

        page
        subttl  "Large Integer Shift Right"

;--
;
;LARGE_INTEGER
;RtlLargeIntegerShiftRight (
;    IN LARGE_INTEGER LargeInteger,
;    IN CCHAR ShiftCount
;    )
;
;Routine Description:
;
;    This routine does a right logical shift of a large integer by a
;    specified amount (ShiftCount) modulo 64.
;
;Arguments:
;
;    LargeInteger - Supplies the large integer to be shifted
;
;    ShiftCount - Supplies the right shift count
;
;Return Value:
;
;    LARGE_INTEGER - Receives the shift large integer result
;
;--*/
cPublicProc _RtlLargeIntegerShiftRight,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jnc     short sr10

;
;  Shift count is less then 32 bits.
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl

        stdRET  _RtlLargeIntegerShiftRight

align 4
sr10:
;
;  Shift count is greater than or equal 32 bits - high half of result is zero,
;  low half is the high half shifted right by remaining count.
;
        mov     eax, [esp+8]            ; (eax) = LargeInteger.HighPart
        xor     edx, edx                ; store highpart
        shr     eax, cl                 ; store lowpart

        stdRET  _RtlLargeIntegerShiftRight

stdENDP _RtlLargeIntegerShiftRight

;++
;
;LARGE_INTEGER
;RtlLargeIntegerArithmeticShift (
;    IN LARGE_INTEGER LargeInteger,
;    IN CCHAR ShiftCount
;    )
;
;Routine Description:
;
;    This routine does a right arithmetic shift of a large integer by a
;    specified amount (ShiftCount) modulo 64.
;
;Arguments:
;
;    LargeInteger - Supplies the large integer to be shifted
;
;    ShiftCount - Supplies the right shift count
;
;Return Value:
;
;    LARGE_INTEGER - Receives the shift large integer result
;
;--
cPublicProc _RtlLargeIntegerArithmeticShift,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jc      short sar10

;
;  Shift count is greater than or equal 32 bits - high half of result is sign
;  bit, low half is the high half shifted right by remaining count.
;
        mov     eax, [esp+8]            ; (eax) = LargeInteger.HighPart
        sar     eax, cl                 ; store highpart
        bt      eax, 31                 ; sign bit set?
        sbb     edx, edx                ; duplicate sign bit into highpart

        stdRET  _RtlLargeIntegerArithmeticShift

align 4
sar10:
;
;  Shift count is less then 32 bits.
;
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl

        stdRET  _RtlLargeIntegerArithmeticShift

stdENDP _RtlLargeIntegerArithmeticShift,3


        page
        subttl  "Large Integer Negate"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerNegate (
;    IN LARGE_INTEGER Subtrahend
;    )
;
; Routine Description:
;
;    This function negates a signed large integer and returns the signed
;    large integer result.
;
; Arguments:
;
;   (TOS+4) = Subtrahend
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerNegate  ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = lo
        mov     edx,[esp]+8
        neg     edx                     ; (edx) = 2's comp of hi part
        neg     eax                     ; if ((eax) == 0) CF = 0
                                        ; else CF = 1
        sbb     edx,0                   ; (edx) = (edx) - CF
                                        ; (edx:eax) = result
        stdRET    _RtlLargeIntegerNegate

stdENDP _RtlLargeIntegerNegate


        page
        subttl  "Large Integer Subtract"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerSubtract (
;    IN LARGE_INTEGER Minuend,
;    IN LARGE_INTEGER Subtrahend
;    )
;
; Routine Description:
;
;    This function subtracts a signed large integer from a signed large
;    integer and returns the signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Minuend
;    (TOS+12) = Subtrahend
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerSubtract    ,4
cPublicFpo 4,0

        mov     eax,[esp]+4
        sub     eax,[esp]+12            ; (eax) = result.low
        mov     edx,[esp]+8
        sbb     edx,[esp]+16            ; (edx) = result.high
        stdRET    _RtlLargeIntegerSubtract

stdENDP _RtlLargeIntegerSubtract

        page
        subttl  "Convert Long to Large Integer"
;++
;
; LARGE_INTEGER
; RtlConvertLongToLargeInteger (
;     IN LONG SignedInteger
;     )
;
; Routine Description:
;
;     This function converts the input signed integer to a signed large
;     integer and returns the latter as the result.
;
; Arguments:
;
;   (TOS+4) = SignedInteger
;
; Return Value:
;
;    The large integer result is stored (edx:eax)
;
;--

cPublicProc ___RtlConvertLongToLargeInteger   ,1
cPublicFpo 1,0

        mov     eax,[esp]+4             ; (eax) = SignedInteger
        cdq                             ; (edx:eax) = signed LargeInt
        stdRET    ___RtlConvertLongToLargeInteger

stdENDP ___RtlConvertLongToLargeInteger


        page
        subttl  "Convert Ulong to Large Integer"
;++
;
; LARGE_INTEGER
; RtlConvertUlongToLargeInteger (
;     IN LONG UnsignedInteger
;     )
;
; Routine Description:
;
;     This function converts the input unsigned integer to a signed large
;     integer and returns the latter as the result.
;
; Arguments:
;
;   (TOS+4) = UnsignedInteger
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc ___RtlConvertUlongToLargeInteger  ,1
cPublicFpo 1,0

        mov     eax,[esp]+4             ; store low
        xor     edx,edx                 ; store 0 in high
        stdRET    ___RtlConvertUlongToLargeInteger

stdENDP ___RtlConvertUlongToLargeInteger


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\debug3.c ===
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug3.c
//
// Abstract:
//
//    This module implements architecture specific functions to support debugging NT.
//
// Author:
//
//    Steven R. Wood (stevewo) 3-Aug-1989
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntrtlp.h"

//
// Prototype for local procedure
//

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4
    );

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4
    )

//++
//
//  Routine Description:
//
//      Allocate an ExceptionRecord, fill in data to allow exception
//      dispatch code to do the right thing with the service, and
//      call RtlRaiseException (NOT ExRaiseException!!!).
//
//  Arguments:
//      ServiceClass - which call is to be performed
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//      Arg3 - generic third argument
//      Arg4 - generic fourth argument
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
    NTSTATUS    RetValue;

#if defined(BUILD_WOW6432)

    extern NTSTATUS NtWow64DebuggerCall(ULONG, PVOID, PVOID, PVOID, PVOID);
    RetValue = NtWow64DebuggerCall(ServiceClass, Arg1, Arg2, Arg3, Arg4);

#else
    _asm {
        push    edi
        push    ebx
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2
        mov     ebx, Arg3
        mov     edi, Arg4

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        pop     ebx
        pop     edi
        mov     RetValue, eax

    }

#endif

    return RetValue;
}


VOID
DebugService2(
    PVOID Arg1,
    PVOID Arg2,
    ULONG ServiceClass
    )

//++
//
//  Routine Description:
//
//      Generic exception dispatcher for the debugger
//
//  Arguments:
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//      ServiceClass - which call is to be performed
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
#if defined(BUILD_WOW6432)

    extern NTSTATUS NtWow64DebuggerCall(ULONG, PVOID, PVOID, PVOID, PVOID);
    NtWow64DebuggerCall(ServiceClass, Arg1, Arg2, 0, 0);

#else
    _asm {
        //push    edi
        //push    ebx
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2
        //mov     ebx, Arg3
        //mov     edi, Arg4

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        //pop     ebx
        //pop     edi

    }

#endif

    return;
}



// DebugPrint must appear after DebugSerive.  Moved
// it down below DebugService, so BBT would have a label after DebugService.
// A label after the above _asm  is necessary so BBT can treat DebugService
// as  "KnownDataRange".   Otherwise, the two  'int' instructions could get broken up
// by BBT's optimizer.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output,
    IN ULONG ComponentId,
    IN ULONG Level
    )
{
    return DebugService(BREAKPOINT_PRINT,
                        Output->Buffer,
                        (PVOID)Output->Length,
                        (PVOID)ComponentId,
                        (PVOID)Level);
}


ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    )
{
    return DebugService(BREAKPOINT_PROMPT,
                        Output->Buffer,
                        (PVOID)Output->Length,
                        Input->Buffer,
                        (PVOID)Input->MaximumLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\getcalr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    x86trace.c

Abstract:

    This module contains routines to get runtime stack traces 
    for the x86 architecture.

Author:

    Silviu Calinoiu (silviuc) 18-Feb-2001

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include "ntrtlp.h"
#include <nturtl.h>
#include <zwapi.h>
#include <stktrace.h>
#include <heap.h>
#include <heappriv.h>

//
// Forward declarations.
//

BOOLEAN
RtlpCaptureStackLimits (
    ULONG_PTR HintAddress,
    PULONG_PTR StartStack,
    PULONG_PTR EndStack);

BOOLEAN
RtlpStkIsPointerInDllRange (
    ULONG_PTR Value
    );

BOOLEAN
RtlpStkIsPointerInNtdllRange (
    ULONG_PTR Value
    );

VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    );

//
// Fuzzy stack traces
//

#if !defined(NTOS_KERNEL_RUNTIME)
BOOLEAN RtlpFuzzyStackTracesEnabled;
ULONG RtlpWalkFrameChainFuzzyCalls;
#endif

ULONG
RtlpWalkFrameChainFuzzy (
    OUT PVOID *Callers,
    IN ULONG Count
    );

#if !defined(RtlGetCallersAddress) && (!NTOS_KERNEL_RUNTIME)
VOID
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    )
/*++

Routine Description:

    This routine returns the first two callers on the current stack. It should be
    noted that the function can miss some of the callers in the presence of FPO
    optimization.

Arguments:

    CallersAddress - address to save the first caller.

    CallersCaller - address to save the second caller.

Return Value:

    None. If the function does not succeed in finding the two callers
    it will zero the addresses where it was supposed to write them.

Environment:

    X86, user mode and w/o having a macro with same name defined.

--*/

{
    PVOID BackTrace[ 2 ];
    ULONG Hash;
    USHORT Count;

    Count = RtlCaptureStackBackTrace(
        2,
        2,
        BackTrace,
        &Hash
        );

    if (ARGUMENT_PRESENT( CallersAddress )) {
        if (Count >= 1) {
            *CallersAddress = BackTrace[ 0 ];
        }
        else {
            *CallersAddress = NULL;
        }
    }

    if (ARGUMENT_PRESENT( CallersCaller )) {
        if (Count >= 2) {
            *CallersCaller = BackTrace[ 1 ];
        }
        else {
            *CallersCaller = NULL;
        }
    }

    return;
}

#endif // !defined(RtlGetCallersAddress) && (!NTOS_KERNEL_RUNTIME)



/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// RtlCaptureStackBackTrace
/////////////////////////////////////////////////////////////////////

USHORT
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    This routine walks up the stack frames, capturing the return address from
    each frame requested.

Arguments:

    FramesToSkip - frames detected but not included in the stack trace

    FramesToCapture - frames to be captured in the stack trace buffer.
        One of the frames will be for RtlCaptureStackBackTrace.

    BackTrace - stack trace buffer

    BackTraceHash - very simple hash value that can be used to organize
      hash tables. It is just an arithmetic sum of the pointers in the
      stack trace buffer. If NULL then no hash value is computed.

Return Value:

     Number of return addresses returned in the stack trace buffer.

--*/
{
    PVOID Trace [2 * MAX_STACK_DEPTH];
    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;

    //
    // One more frame to skip for the "capture" function (RtlWalkFrameChain).
    //

    FramesToSkip += 1;

    //
    // Sanity checks.
    //

    if (FramesToCapture + FramesToSkip >= 2 * MAX_STACK_DEPTH) {
        return 0;
    }

#if defined(NTOS_KERNEL_RUNTIME)
    FramesFound = RtlWalkFrameChain (Trace,
                                     FramesToCapture + FramesToSkip,
                                     0);
#else
    if (RtlpFuzzyStackTracesEnabled) {
        
        FramesFound = RtlpWalkFrameChainFuzzy (Trace, 
                                               FramesToCapture + FramesToSkip);
    }
    else {

        FramesFound = RtlWalkFrameChain (Trace,
                                         FramesToCapture + FramesToSkip,
                                         0);
    }
#endif

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

#if defined(NTOS_KERNEL_RUNTIME)
    Index = 0;
#else
    //
    // Mark fuzzy stack traces with a FF...FF value.
    //

    if (RtlpFuzzyStackTracesEnabled) {
        BackTrace[0] = (PVOID)((ULONG_PTR)-1);
        Index = 1;
    }
    else {
        Index = 0;
    }
#endif

    for (HashValue = 0; Index < FramesToCapture; Index++) {

        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    if (BackTraceHash != NULL) {

        *BackTraceHash = HashValue;
    }

    return (USHORT)Index;
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// RtlWalkFrameChain
/////////////////////////////////////////////////////////////////////

#define SIZE_1_KB  ((ULONG_PTR) 0x400)
#define SIZE_1_GB  ((ULONG_PTR) 0x40000000)

#define PAGE_START(address) (((ULONG_PTR)address) & ~((ULONG_PTR)PAGE_SIZE - 1))

#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function tries to walk the EBP chain and fill out a vector of
    return addresses. It is possible that the function cannot fill the
    requested number of callers. In this case the function will just return
    with a smaller stack trace. In kernel mode the function should not take
    any exceptions (page faults) because it can be called at all sorts of
    irql levels.

    The `Flags' parameter is used for future extensions. A zero value will be
    compatible with new stack walking algorithms.
    
    A value of 1 for `Flags' means we are running in K-mode and we want to get
    the user mode stack trace.

Return value:

    The number of identified return addresses on the stack. This can be less
    then the Count requested.

--*/

{

    ULONG_PTR Fp, NewFp, ReturnAddress;
    ULONG Index;
    ULONG_PTR StackEnd, StackStart;
    BOOLEAN Result;
    BOOLEAN InvalidFpValue;

    //
    // Get the current EBP pointer which is supposed to
    // be the start of the EBP chain.
    //

    _asm mov Fp, EBP;

    StackStart = Fp;
    InvalidFpValue = FALSE;

    if (Flags == 0) {
        if (! RtlpCaptureStackLimits (Fp, &StackStart, &StackEnd)) {
            return 0;
        }
    }


    try {

#if defined(NTOS_KERNEL_RUNTIME)

        //
        // If we need to get the user mode stack trace from kernel mode
        // figure out the proper limits.
        //

        if (Flags == 1) {

            PKTHREAD Thread = KeGetCurrentThread ();
            PTEB Teb;
            PKTRAP_FRAME TrapFrame;

            TrapFrame = Thread->TrapFrame;
            Teb = Thread->Teb;

            //
            // If this is a system thread, it has no Teb and no kernel mode
            // stack, so check for it so we don't dereference NULL.
            //
            // If there is no trap frame then we are probably in an APC.
            // User mode stacks for APC's are not important.
            //
            if (Teb == NULL || TrapFrame == NULL || KeIsAttachedProcess()) {
                return 0;
            }

            StackStart = (ULONG_PTR)(Teb->NtTib.StackLimit);
            StackEnd = (ULONG_PTR)(Teb->NtTib.StackBase);
            Fp = (ULONG_PTR)(TrapFrame->Ebp);
            if (StackEnd <= StackStart) {
                return 0;
            }
            ProbeForRead (StackStart, StackEnd - StackStart, sizeof (UCHAR));
        }
#endif
        
        for (Index = 0; Index < Count; Index += 1) {

            if (Fp >= StackEnd || StackEnd - Fp < sizeof(ULONG_PTR) * 2) {
                break;
            }

            NewFp = *((PULONG_PTR)(Fp + 0));
            ReturnAddress = *((PULONG_PTR)(Fp + sizeof(ULONG_PTR)));

            //
            // Figure out if the new frame pointer is ok. This validation
            // should avoid all exceptions in kernel mode because we always
            // read within the current thread's stack and the stack is
            // guaranteed to be in memory (no page faults). It is also guaranteed
            // that we do not take random exceptions in user mode because we always
            // keep the frame pointer within stack limits.
            //

            if (! (Fp < NewFp && NewFp < StackEnd)) {

                InvalidFpValue = TRUE;
            }

            //
            // Figure out if the return address is ok. If return address
            // is a stack address or <64k then something is wrong. There is
            // no reason to return garbage to the caller therefore we stop.
            //

            if (StackStart < ReturnAddress && ReturnAddress < StackEnd) {
                break;
            }

#if defined(NTOS_KERNEL_RUNTIME)
            if (Flags == 0 && ReturnAddress < 0x80000000) {
#else
            // if (ReturnAddress < 0x1000000 || ReturnAddress >= 0x80000000) {
            if (! RtlpStkIsPointerInDllRange(ReturnAddress)) {
#endif

                break;
            }

            //
            // Store new fp and return address and move on.
            // If the new FP value is bogus but the return address
            // looks ok then we still save the address.
            //

            if (InvalidFpValue) {

                Callers[Index] = (PVOID)ReturnAddress;
                Index += 1;
                break;
            }
            else {

                Fp = NewFp;
                Callers[Index] = (PVOID)ReturnAddress;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        Index = 0;
    }

    //
    // Return the number of return addresses identified on the stack.
    //

    return Index;

}


#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif

#if !defined(NTOS_KERNEL_RUNTIME)

ULONG
RtlpWalkFrameChainFuzzy (
    OUT PVOID *Callers,
    IN ULONG Count
    )
/*++

Routine Description:

    This function tries to walk the EBP chain and fill out a vector of
    return addresses. The function works only on x86. If the EBP chain ends
    it will try to pick up the start of the next one. Therefore this will not
    give an accurate stack trace but rather something that a desperate developer
    might find useful in chasing a leak.

Return value:

    The number of identified return addresses on the stack.

--*/

{
    ULONG_PTR Fp, NewFp, ReturnAddress, NextPtr;
    ULONG Index;
    ULONG_PTR StackEnd, StackStart;
    BOOLEAN Result;
    ULONG_PTR Esp, LastEbp;

    //
    // Get the current EBP pointer which is supposed to
    // be the start of the EBP chain.
    //

    _asm mov Fp, EBP;

    if (! RtlpCaptureStackLimits (Fp, &StackStart, &StackEnd)) {
        return 0;
    }

    try {

        for (Index = 0; Index < Count; Index += 1) {

            NextPtr = Fp + sizeof(ULONG_PTR);

            if (NextPtr >= StackEnd) {
                break;
            }

            NewFp = *((PULONG_PTR)Fp);

            if (! (Fp < NewFp && NewFp < StackEnd)) {

                NewFp = NextPtr;
            }

            ReturnAddress = *((PULONG_PTR)NextPtr);

#if defined(NTOS_KERNEL_RUNTIME)
            //
            // If the return address is a stack address it may point to where on the stack
            // the real return address is (FPO) so as long as we are within stack limits lets loop
            // hoping to find a pointer to a real address.
            //

            if (StackStart < ReturnAddress && ReturnAddress < StackEnd) {

                Fp = NewFp;
				Index -= 1;
				continue;
            }

            if (ReturnAddress < 0x80000000) {
#else
            if (! RtlpStkIsPointerInDllRange(ReturnAddress)) {
#endif
                Fp = NewFp;
                Index -= 1;
                continue;
            }

            //
            // Store new fp and return address and move on.
            // If the new FP value is bogus but the return address
            // looks ok then we still save the address.
            //

            Fp = NewFp;
            Callers[Index] = (PVOID)ReturnAddress;

        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

#if DBG
        DbgPrint ("Unexpected exception in RtlpWalkFrameChainFuzzy ...\n");
        DbgBreakPoint ();
#endif

    }

    //
    // Return the number of return addresses identified on the stack.
    //

    return Index;
}

#endif // #if !defined(NTOS_KERNEL_RUNTIME)


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// RtlCaptureStackContext
/////////////////////////////////////////////////////////////////////

#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif

ULONG
RtlCaptureStackContext (
    OUT PULONG_PTR Callers,
    OUT PRTL_STACK_CONTEXT Context,
    IN ULONG Limit
    )
/*++

Routine Description:

    This routine will detect up to `Limit' potential callers from the stack.

    A potential caller is a pointer (PVOID) that points into one of the
    regions occupied by modules loaded into the process space (user mode -- dlls)
    or kernel space (kernel mode -- drivers).

    Note. Based on experiments you need to save at least 64 pointers to be sure you
    get a complete stack.

Arguments:

    Callers - vector to be filled with potential return addresses. Its size is
        expected to be `Limit'. If it is not null then Context should be null.

    Context - if not null the caller wants the stack context to be saved here
        as opposed to the Callers parameter.

    Limit - # of pointers that can be written into Callers and Offsets.

Return value:

    The number of potential callers detected and written into the
    `Callers' buffer.

--*/
{
    ULONG_PTR Current;
    ULONG_PTR Value;
    ULONG Index;
    ULONG_PTR Offset;
    ULONG_PTR StackStart;
    ULONG_PTR StackEnd;
    ULONG_PTR Hint;
    ULONG_PTR Caller;
    ULONG_PTR ContextSize;

#ifdef NTOS_KERNEL_RUNTIME

    //
    // Avoid weird conditions. Doing this in an ISR is never a good idea.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return 0;
    }

#endif

    if (Limit == 0) {
        return 0;
    }

    Caller = (ULONG_PTR)_ReturnAddress();

    if (Context) {
        Context->Entry[0].Data = Caller;
        ContextSize = sizeof(RTL_STACK_CONTEXT) + (Limit - 1) * sizeof (RTL_STACK_CONTEXT_ENTRY);
    }
    else {
        Callers[0] = Caller;
    }

    //
    // Get stack limits
    //

    _asm mov Hint, EBP;


    if (! RtlpCaptureStackLimits (Hint, &StackStart, &StackEnd)) {
        return 0;
    }

    //
    // Synchronize stack traverse pointer to the next word after the first
    // return address.
    //

    for (Current = StackStart; Current < StackEnd; Current += sizeof(ULONG_PTR)) {

        if (*((PULONG_PTR)Current) == Caller) {
            break;
        }
    }

    if (Context) {
        Context->Entry[0].Address = Current;
    }

    //
    // Iterate the stack and pickup potential callers on the way.
    //

    Current += sizeof(ULONG_PTR);

    Index = 1;

    for ( ; Current < StackEnd; Current += sizeof(ULONG_PTR)) {

        //
        // If potential callers buffer is full then wrap this up.
        //

        if (Index == Limit) {
            break;
        }

        //
        // Skip `Callers' buffer because it will give false positives.
        // It is very likely for this to happen because most probably the buffer
        // is allocated somewhere upper in the call chain.
        //

        if (Context) {

            if (Current >= (ULONG_PTR)Context && Current < (ULONG_PTR)Context + ContextSize ) {
                continue;
            }

        }
        else {

            if ((PULONG_PTR)Current >= Callers && (PULONG_PTR)Current < Callers + Limit ) {
                continue;
            }
        }

        Value = *((PULONG_PTR)Current);

        //
        // Skip small numbers.
        //

        if (Value <= 0x10000) {
            continue;
        }

        //
        // Skip stack pointers.
        //

        if (Value >= StackStart && Value <= StackEnd) {
            continue;
        }

        //
        // Check if `Value' points inside one of the loaded modules.
        //

        if (RtlpStkIsPointerInDllRange (Value)) {

            if (Context) {

                Context->Entry[Index].Address = Current;
                Context->Entry[Index].Data = Value;
            }
            else {

                Callers[Index] = Value;
            }

            Index += 1;
        }

    }

    if (Context) {
        Context->NumberOfEntries = Index;
    }

    return Index;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Dll ranges bitmap
/////////////////////////////////////////////////////////////////////

//
// DLL ranges bitmap
//
// This range scheme is needed in order to capture stack contexts on x86
// machines fast. On IA64 there are totally different algorithms for getting
// stack traces.
//
// Every bit represents 1Mb of virtual space. Since we use the code either
// in user mode or kernel mode the first bit of a pointer is not interesting.
// Therefore we have to represent 2Gb / 1Mb regions. This totals 256 bytes.
//
// The bits are set only in loader code paths when a DLL (or driver) gets loaded.
// The writing is protected by the loader lock. The bits are read in stack
// capturing function.The reading does not require lock protection.
//

UCHAR RtlpStkDllRanges [2048 / 8];

#if !defined(NTOS_KERNEL_RUNTIME)

ULONG_PTR RtlpStkNtdllStart;
ULONG_PTR RtlpStkNtdllEnd;

BOOLEAN
RtlpStkIsPointerInNtdllRange (
    ULONG_PTR Value
    )
{
    if (RtlpStkNtdllStart == 0) {
        return FALSE;
    }

    if (RtlpStkNtdllStart <= Value && Value < RtlpStkNtdllEnd) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

#endif

BOOLEAN
RtlpStkIsPointerInDllRange (
    ULONG_PTR Value
    )
{
    ULONG Index;

    Value &= ~0x80000000;
    Index = (ULONG)(Value >> 20);

    if (RtlpStkDllRanges[Index >> 3] & (UCHAR)(1 << (Index & 7))) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

VOID
RtlpStkMarkDllRange (
    PLDR_DATA_TABLE_ENTRY DllEntry
    )
/*++

Routine description:

    This routine marks the corresponding bits for the loaded dll in the
    RtlpStkDllRanges variable. This global is used within RtlpDetectDllReferences
    to save a stack context.

Arguments:

    Loader structure for a loaded dll.

Return value:

    None.

Environment:

    In user mode this function is called from loader code paths. The Peb->LoaderLock
    is always held while executing this function.

--*/
{
    PVOID Base;
    ULONG Size;
    PCHAR Current, Start;
    ULONG Index;
    ULONG_PTR Value;

    Base = DllEntry->DllBase;
    Size = DllEntry->SizeOfImage;

    //
    // Find out where is ntdll loaded if we do not know yet.
    //

#if !defined(NTOS_KERNEL_RUNTIME)

    if (RtlpStkNtdllStart == 0) {

        UNICODE_STRING NtdllName;

        RtlInitUnicodeString (&NtdllName, L"ntdll.dll");

        if (RtlEqualUnicodeString (&(DllEntry->BaseDllName), &NtdllName, TRUE)) {

            RtlpStkNtdllStart = (ULONG_PTR)Base;
            RtlpStkNtdllEnd = (ULONG_PTR)Base + Size;
        }
    }
#endif

    Start = (PCHAR)Base;

    for (Current = Start; Current < Start + Size; Current += 0x100000) {

        Value = (ULONG_PTR)Current & ~0x80000000;

        Index = (ULONG)(Value >> 20);

        RtlpStkDllRanges[Index >> 3] |= (UCHAR)(1 << (Index & 7));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\lzntx86.asm ===
title	"Compression and Decompression Engines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    lzntx86.asm
;
; Abstract:
;
;    This module implements the compression and decompression engines needed
;    to support file system compression.  Functions are provided to
;    compress a buffer and decompress a buffer.
;
; Author:
;
;    Mark Zbikowski (markz) 15-Mar-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   15-Mar-1994 markz
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFDEF NTOS_KERNEL_RUNTIME
_PAGE   SEGMENT DWORD PUBLIC 'CODE'
ELSE
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
	subttl	"Decompress a buffer"
	
;++
;
; NTSTATUS
; LZNT1DecompressChunk (
;     OUT PUCHAR UncompressedBuffer,
;     IN PUCHAR EndOfUncompressedBufferPlus1,
;     IN PUCHAR CompressedBuffer,
;     IN PUCHAR EndOfCompressedBufferPlus1,
;     OUT PULONG FinalUncompressedChunkSize
;     )
;
; Routine Description:
;
;    This function decodes a stream of compression tokens and places the
;    resultant output into the destination buffer.  The format of the input
;    is described ..\lznt1.c.  As the input is decoded, checks are made to
;    ensure that no data is read past the end of the compressed input buffer
;    and that no data is stored past the end of the output buffer.  Violations
;    indicate corrupt input and are indicated by a status return.
;
;    The following code takes advantage of two distinct observations.
;    First, literal tokens occur at least twice as often as copy tokens.
;    This argues for having a "fall-through" being the case where a literal
;    token is found.  We structure the main decomposition loop in eight
;    pieces where the first piece is a sequence of literal-test fall-throughs
;    and the remainder are a copy token followed by 7,6,...,0 literal-test
;    fall-throughs.  Each test examines a particular bit in the tag byte
;    and jumps to the relevant code piece.
;
;    The second observation involves performing bounds checking only
;    when needed.  Bounds checking the compressed buffer need only be done
;    when fetching the tag byte.  If there is not enough room left in the
;    input for a tag byte and 8 (worst case) copy tokens, a branch is made
;    to a second loop that handles a byte-by-byte "safe" copy to finish
;    up the decompression.  Similarly, at the head of the loop a check is
;    made to ensure that there is enough room in the output buffer for 8
;    literal bytes.  If not enough room is left, then the second loop is
;    used.  Finally, after performing each copy, the output-buffer check
;    is made as well since a copy may take the destination pointer
;    arbitrarily close to the end of the destination.
;
;    The register conventions used in the loops below are:
;
;	    (al)    contains the current tag byte
;	    (ebx)   contains the current width in bits of the length given
;		    the maximum offset
;		    that can be utilized in a copy token.  We update this
;		    value only prior to performing a copy.  This width is used
;		    both to index a mask table (for extracting the length) as
;		    well as shifting (for extracting the copy offset)
;	    (ecx)   is used to contain counts during copies
;	    (edx)   is used as a temp variable during copies
;	    (esi)   is used mainly as the source of the next compressed token.
;		    It is also used for copies.
;	    (edi)   is used as the destination of literals and copies
;	    (ebp)   is used as a frame pointer
;
; Arguments:
;
;    UncompressedBuffer (ebp+8) - pointer to destination of uncompression.
;
;    EndOfUncompressedBufferPlus1  (ebp+12) - pointer just beyond the
;	output buffer.	This is used for consistency checking of the stored
;	compressed data.
;
;    CompressedBuffer (ebp+16) - pointer to compressed source.	This pointer
;       has been adjusted by the caller to point past the header word, so
;       the pointer points to the first tag byte describing which of the
;	following tokens are literals and which are copy groups.
;
;    EndOfCompressedBufferPlus1 (ebp+20) - pointer just beyond end of input
;	buffer.  This is used to terminate the decompression.
;
;    FinalUncompressedChunkSize (ebp+24) - pointer to a returned decompressed
;	size.  This has meaningful data ONLY when LZNT1DecompressChunk returns
;	STATUS_SUCCESS
;
; Return Value:
;
;    STATUS_SUCCESS is returned only if the decompression consumes thee entire
;	input buffer and does not exceed the output buffer.
;    STATUS_BAD_COMPRESSION_BUFFER is returned when the output buffer would be
;	overflowed.
;
;--

;    Decompression macros

;**	TestLiteralAt - tests to see if there's a literal at a specific
;	    bit position.  If so, it branches to the appropriate copy code
;	    (decorated by the bit being used).
;
;       This code does no bounds checking

TestLiteralAt	macro	CopyLabel,bit,IsMain
	test	al,1 SHL bit		; is there a copy token at this position?
	jnz	CopyLabel&bit		; yes, go copy it

	mov	dl,[esi+bit+1]		; (dl) = literal byte from compressed stream
ifidn <IsMain>,<Y>
	mov	[edi+bit],dl		; store literal byte
else
	mov	[edi],dl		; store literal byte
	inc	edi			; point to next literal
endif

endm


;	Jump - allow specific jumps with computed labels.

Jump	macro	lab,tag
        jmp     lab&tag
endm



;**	DoCopy - perform a copy.  If a bit position is specified
;	    then branch to the appropriate point in the "safe" tail when
;	    the copy takes us too close to the end of the output buffer
;
;       This code checks the bounds of the copy token:  copying before the
;       beginning of the buffer and copying beyond the end of the buffer.

DoCopy	macro	AdjustLabel,bit,IsMain

ifidn	<IsMain>,<Y>
if bit ne 0
	add	edi,bit
endif
endif

Test&AdjustLabel&bit:
	cmp	edi,WidthBoundary
	ja	Adjust&AdjustLabel&bit

	xor	ecx,ecx
	mov	cx,word ptr [esi+bit+1] ; (ecx) = encoded length:offset
	lea	edx,[esi+1]		; (edx) = next token location
	mov	Temp,edx

	mov	esi,ecx 		; (esi) = encoded length:offset
	and	ecx,MaskTab[ebx*4]	; (ecx) = length
	xchg	ebx,ecx 		; (ebx) = length/(ecx) = width
	shr	esi,cl			; (esi) = offset
	xchg	ebx,ecx 		; (ebx) = width, (ecx) = length

	neg	esi			; (esi) = negative real offset
	lea	esi,[esi+edi-1] 	; (esi) = pointer to previous string

        cmp     esi,UncompressedBuffer  ; off front of buffer?
        jb      DOA                     ; yes, error

	add	ecx,3			; (ecx) = real length

	lea	edx,[edi+ecx]		; (edx) = end of copy
ifidn	<IsMain>,<Y>
	cmp	edx,EndOfSpecialDest	; do we exceed buffer?
	jae	TailAdd&bit		; yes, handle in safe tail
else
	cmp	edx,EndOfUncompressedBufferPlus1
					; do we exceed buffer?
	ja	DOA			; yes, error
endif

	rep	movsb			; Copy the bytes

	mov	esi,Temp		; (esi) = next token location

ifidn	<IsMain>,<Y>
	sub	edi,bit+1
endif

endm





;**	AdjustWidth - adjust width of length based upon current position of
;	    input buffer (max offset)


AdjustWidth macro   l,i
Adjust&l&i:
	dec	ebx			; (ebx) = new width pointer
	mov	edx,UncompressedBuffer	; (edx) = pointer to dest buffer
	add	edx,WidthTab[ebx*4]	; (edx) = new width boundary
	mov	WidthBoundary,edx	; save boundary for comparison
	jmp	Test&l&i

endm


;**	GenerateBlock - generates the unsafe block of copy/literal pieces.
;
;       This code does no checking for simple input/output checking.  Only
;       the data referred to by the copy tokens is checked.

GenerateBlock	macro	bit
Copy&bit:

	DoCopy	Body,bit,Y

	j = bit + 1
	while j lt 8
	    TestLiteralAt   Copy,%(j),Y
	    j = j + 1
	endm

	add	esi,9
	add	edi,8

	jmp	Top

	AdjustWidth Body,bit
endm



;**	GenerateTailBlock - generates safe tail block for compression.	This
;	    code checks everything before each byte stored so it is expected
;	    to be executed only at the end of the buffer.


GenerateTailBlock   macro   bit
TailAdd&bit:
	add	EndOfCompressedBufferPlus1,1+2*8
                                        ; restore buffer length to true length
	mov     esi,Temp                ; (esi) = source of copy token block
	dec	esi

Tail&bit:
	lea	ecx,[esi+bit+1]         ; (ecx) = source of next token
	cmp	ecx,EndOfCompressedBufferPlus1	; are we done?
	jz	Done                    ; yes - we exactly match end of buffer
;       ja      DOA                     ; INTERNAL ERROR only

	cmp	edi,EndOfUncompressedBufferPlus1
	jz	Done			; go quit, destination is full
;       ja      DOA                     ; INTERNAL ERROR only

	TestLiteralAt	TailCopy,bit,N

        Jump	Tail,%(bit+1)


;       We expect a copy token to be at [esi+bit+1].  This means that
;       esi+bit+1+tokensize must be <= EndOfCompressedBufferPlus1
TailCopy&bit:
        lea     ecx,[esi+bit+3]         ; (ecx) = next input position
        cmp     ecx,EndOfCompressedBufferPlus1  ; do we go too far
        ja      DOA                     ; yes, we are beyond the end of buffer

	DoCopy	Tail,bit,N		; perform copy

        Jump	Tail,%(bit+1)

	AdjustWidth Tail,bit

endm



cPublicProc _LZNT1DecompressChunk ,5
	push	ebp			; (tos) = saved frame pointer
	mov	ebp,esp 		; (ebp) = frame pointer to arguments
	sub	esp,12			; Open up room for locals

Temp			      equ dword ptr [ebp-12]
WidthBoundary		      equ dword ptr [ebp-8]
EndOfSpecialDest	      equ dword ptr [ebp-4]

;SavedEBP		      equ dword ptr [ebp]
;ReturnAddress		      equ dword ptr [ebp+4]

UncompressedBuffer	      equ dword ptr [ebp+8]
EndOfUncompressedBufferPlus1  equ dword ptr [ebp+12]
CompressedBuffer	      equ dword ptr [ebp+16]
EndOfCompressedBufferPlus1    equ dword ptr [ebp+20]
FinalUncompressedChunkSize    equ dword ptr [ebp+24]


	push	ebx
	push	esi
	push	edi

	mov	edi,UncompressedBuffer	; (edi) = destination of decompress
	mov	esi,CompressedBuffer	; (esi) = header
	sub	EndOfCompressedBufferPlus1,1+2*8    ; make room for special source

	mov	eax,EndOfUncompressedBufferPlus1    ; (eax) = end of destination
	sub	eax,8			; (eax) = beginning of special tail
	mov	EndOfSpecialDest,eax	; store special tail

	mov	WidthBoundary,edi	; force initial width mismatch
	mov	ebx,13			; initial width of output


Top:	cmp	esi,EndOfCompressedBufferPlus1	; Will this be the last tag group in source?
	jae	DoTail			; yes, go handle specially
	cmp	edi,EndOfSpecialDest	; are we too close to end of buffer?
	jae	DoTail			; yes, go skip to end

	mov	al,byte ptr [esi]	; (al) = tag byte, (esi) points to token

	irpc	i,<01234567>
	    TestLiteralAt   Copy,%(i),Y
	endm

	add	esi,9
	add	edi,8

	jmp	Top
;		       ; Width of offset    Width of length
WidthTab    dd	0FFFFh ;	16		   0
	    dd	0FFFFh ;	15		   1
	    dd	0FFFFh ;	14		   2
	    dd	0FFFFh ;	13		   3
	    dd	0FFFFh ;	12		   4
	    dd	2048   ;	11		   5
	    dd	1024   ;	10		   6
	    dd	512    ;	9		   7
	    dd	256    ;	8		   8
	    dd	128    ;	7		   9
	    dd	64     ;	6		   10
	    dd	32     ;	5		   11
	    dd	16     ;	4		   12
	    dd	0      ;	3		   13
	    dd	0      ;	2		   14
	    dd	0      ;	1		   15
	    dd	0      ;	0		   16


;				    ;
MaskTab     dd	0000000000000000b   ;	     0
	    dd	0000000000000001b   ;	     1
	    dd	0000000000000011b   ;	     2
	    dd	0000000000000111b   ;	     3
	    dd	0000000000001111b   ;	     4
	    dd	0000000000011111b   ;	     5
	    dd	0000000000111111b   ;	     6
	    dd	0000000001111111b   ;	     7
	    dd	0000000011111111b   ;	     8
	    dd	0000000111111111b   ;	     9
	    dd	0000001111111111b   ;	     10
	    dd	0000011111111111b   ;	     11
	    dd	0000111111111111b   ;	     12
	    dd	0001111111111111b   ;	     13
	    dd	0011111111111111b   ;	     14
	    dd	0111111111111111b   ;	     15
	    dd	1111111111111111b   ;	     16


	irpc	i,<01234567>
	    GenerateBlock   %(i)
	endm

;	We're handling a tail specially for this.  We must check at all
;	spots for running out of input as well as overflowing output.
;
;	(esi) = pointer to possible next tag

DoTail: add	EndOfCompressedBufferPlus1,1+2*8    ; point to end of compressed input

TailLoop:
	cmp	esi,EndOfCompressedBufferPlus1	; are we totally done?
	jz	Done			; yes, go return
	mov	al,byte ptr [esi]	; (al) = tag byte

	jmp	Tail0

	irpc	i,<01234567>
	    GenerateTailBlock	i
	endm

Tail8:	add	esi,9
	jmp	TailLoop



DOA:	mov	eax,STATUS_BAD_COMPRESSION_BUFFER
	jmp	Final

Done:	mov	eax,edi 		; (eax) = pointer to next byte to store
	sub	eax,UncompressedBuffer	; (eax) = length of uncompressed
	mov	edi,FinalUncompressedChunkSize	; (edi) = user return value location
	mov	[edi],eax		; return total transfer size to user
	xor	eax,eax 		; (eax) = STATUS_SUCCESS

Final:	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp


	stdRET _LZNT1DecompressChunk

stdENDP _LZNT1DecompressChunk

IFDEF NTOS_KERNEL_RUNTIME
_PAGE           ENDS
ELSE
_TEXT           ENDS
ENDIF
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\movemem.asm ===
title  "User Mode Zero and Move Memory functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to zero and copy blocks of memory
;
;
; Author:
;
;    Steven R. Wood (stevewo) 25-May-1990
;
; Environment:
;
;    User mode only.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

if DBG
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    public _RtlpZeroCount
    public _RtlpZeroBytes

_RtlpZeroCount dd 0
_RtlpZeroBytes dd 0

ifndef BLDR_KERNEL_RUNTIME
_MsgUnalignedPtr    db  'RTL: RtlCompare/FillMemoryUlong called with unaligned pointer (%x)\n',0
_MsgUnalignedCount  db  'RTL: RtlCompare/FillMemoryUlong called with unaligned count (%x)\n',0
endif

_DATA ENDS

ifndef BLDR_KERNEL_RUNTIME
ifdef NTOS_KERNEL_RUNTIME
        extrn   _KdDebuggerEnabled:BYTE
endif
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif
endif

;
; Alignment parameters for zeroing and moving memory.
;

ZERO_MEMORY_ALIGNMENT = 4
ZERO_MEMORY_ALIGNMENT_LOG2 = 2
ZERO_MEMORY_ALIGNMENT_MASK = ZERO_MEMORY_ALIGNMENT - 1

MEMORY_ALIGNMENT = 4
MEMORY_ALIGNMENT_LOG2 = 2
MEMORY_ALIGNMENT_MASK = MEMORY_ALIGNMENT - 1


;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "RtlCompareMemory"
;++
;
; ULONG
; RtlCompareMemory (
;    IN PVOID Source1,
;    IN PVOID Source2,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function compares two blocks of memory and returns the number
;    of bytes that compared equal.
;
; Arguments:
;
;    Source1 (esp+4) - Supplies a pointer to the first block of memory to
;       compare.
;
;    Source2 (esp+8) - Supplies a pointer to the second block of memory to
;       compare.
;
;    Length (esp+12) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;    The number of bytes that compared equal is returned as the function
;    value. If all bytes compared equal, then the length of the orginal
;    block of memory is returned.
;
;--

RcmSource1      equ     [esp+12]
RcmSource2      equ     [esp+16]
RcmLength       equ     [esp+20]

CODE_ALIGNMENT
cPublicProc _RtlCompareMemory,3
cPublicFpo 3,0

        push    esi                     ; save registers
        push    edi                     ;
        cld                             ; clear direction
        mov     esi,RcmSource1          ; (esi) -> first block to compare
        mov     edi,RcmSource2          ; (edi) -> second block to compare

;
;   Compare dwords, if any.
;

rcm10:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        shr     ecx,2                   ; (ecx) = length in dwords
        jz      rcm20                   ; no dwords, try bytes
        repe    cmpsd                   ; compare dwords
        jnz     rcm40                   ; mismatch, go find byte

;
;   Compare residual bytes, if any.
;

rcm20:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        and     ecx,3                   ; (ecx) = length mod 4
        jz      rcm30                   ; 0 odd bytes, go do dwords
        repe    cmpsb                   ; compare odd bytes
        jnz     rcm50                   ; mismatch, go report how far we got

;
;   All bytes in the block match.
;

rcm30:  mov     eax,RcmLength           ; set number of matching bytes
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

;
;   When we come to rcm40, esi (and edi) points to the dword after the
;   one which caused the mismatch.  Back up 1 dword and find the byte.
;   Since we know the dword didn't match, we can assume one byte won't.
;

rcm40:  sub     esi,4                   ; back up
        sub     edi,4                   ; back up
        mov     ecx,5                   ; ensure that ecx doesn't count out
        repe    cmpsb                   ; find mismatch byte

;
;   When we come to rcm50, esi points to the byte after the one that
;   did not match, which is TWO after the last byte that did match.
;

rcm50:  dec     esi                     ; back up
        sub     esi,RcmSource1          ; compute bytes that matched
        mov     eax,esi                 ;
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

stdENDP _RtlCompareMemory


       subttl  "RtlCompareMemory"
EcmlSource       equ     [esp + 4 + 4]
EcmlLength       equ     [esp + 4 + 8]
EcmlPattern      equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlCompareMemoryUlong  ,3

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EcmlSource
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EcmlLength
        mov     eax,EcmlPattern
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to compare is non-zero, then do it.
;

        repe    scasd
        je      @F
        sub     edi,4
@@:
        sub     edi,EcmlSource
        mov     eax,edi
        pop     edi
        stdRET    _RtlCompareMemoryUlong

stdENDP _RtlCompareMemoryUlong


       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemory (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN UCHAR Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a byte value.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the byte value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmDestination  equ     [esp + 4 + 4]
EfmLength       equ     [esp + 4 + 8]
EfmFill         equ     byte ptr [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemory  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmDestination
        mov     ecx,EfmLength
        mov     al,EfmFill
        mov     ah,al
        shl     eax,16
        mov     al,EfmFill
        mov     ah,al
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlFillMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlFillMemory

stdENDP _RtlFillMemory

       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemoryUlonglong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 64-bit value.  The Destination pointer
;    must be aligned on an 8 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 64-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 0ch]
EfmlLength       equ     [esp + 10h]
EfmlFillLow      equ     [esp + 14h]
EfmlFillHigh     equ     [esp + 18h]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlonglong  ,4
cPublicFpo 4,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVSD instruction to zero memory.
;
;   edi -> memory to fill
;   esi -> first 8 byte chunk of the memory destination to fill
;   ecx = number of 32-bit words to zero
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     ecx,EfmlLength              ; # of bytes
        mov     esi,EfmlDestination         ; Destination pointer

if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    ecx,7
        jz      @F
        push    ecx
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
        mov     ecx,EfmlLength              ; # of bytes
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:

        test    esi,3
        jz      @F
        push    esi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     eax,EfmlFillLow             ; get low portion of the fill arg
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2      ; convert bytes to dwords
        sub     ecx,2                       ; doing the 1st one by hand
        mov     [esi],eax                   ; fill 1st highpart
        mov     eax,EfmlFillHigh            ; get high portion of the fill arg
        lea     edi,[esi+08]                ; initialize the dest pointer
        mov     [esi+04],eax                ; fill 1st lowpart

        rep     movsd                       ; ripple the rest

        pop     edi
        pop     esi
        stdRET    _RtlFillMemoryUlonglong

stdENDP _RtlFillMemoryUlonglong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlFillMemoryUlong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 32-bit value.  The Destination pointer
;    must be aligned on a 4 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 32-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 4 + 4]
EfmlLength       equ     [esp + 4 + 8]
EfmlFill         equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlong  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmlDestination
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EfmlLength
        mov     eax,EfmlFill
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

        pop     edi
        stdRET    _RtlFillMemoryUlong

stdENDP _RtlFillMemoryUlong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlZeroMemory (
;    IN PVOID Destination,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function zeros memory.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EzmDestination  equ     [esp + 4 + 4]
EzmLength       equ     [esp + 4 + 8]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlZeroMemory  ,2
cPublicFpo 2,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = zero (value to store in destination)
;   direction flag is clear for auto-increment
;

        mov     edi,EzmDestination
        mov     ecx,EzmLength
        xor     eax,eax
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlZeroMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlZeroMemory

stdENDP _RtlZeroMemory

        page , 132
        subttl  "RtlMoveMemory"
;++
;
; VOID
; RtlMoveMemory (
;    IN PVOID Destination,
;    IN PVOID Source OPTIONAL,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function moves memory either forward or backward, aligned or
;    unaligned, in 4-byte blocks, followed by any remaining bytes.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [esp + 8 + 4]
EmmSource       equ     [esp + 8 + 8]
EmmLength       equ     [esp + 8 + 12]

; End of arguments

CODE_ALIGNMENT
cPublicProc _RtlMoveMemory  ,3
cPublicFpo 3,2

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVS instruction to move memory.
;
;   esi -> memory to move (NULL implies the destination will be zeroed)
;   edi -> destination of move
;   ecx = number of 32-bit words to move
;   edx = number of extra 8-bit bytes to move at the end (0 - 3)
;   direction flag is clear for auto-increment
;

        mov     esi,EmmSource
        mov     edi,EmmDestination
        mov     ecx,EmmLength
if DBG
        inc     _RtlpZeroCount
        add     _RtlpZeroBytes,ecx
endif
        cld

        cmp     esi,edi                 ; Special case if Source > Destination
        jbe     overlap

nooverlap:
        mov     edx,ecx
        and     edx,MEMORY_ALIGNMENT_MASK
        shr     ecx,MEMORY_ALIGNMENT_LOG2

;
; If number of 32-bit words to move is non-zero, then do it.
;

        rep     movsd

;
; If number of extra 8-bit bytes to move is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory
@@:
        rep     movsb

movedone:
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory

;
; Here to handle special case when Source > Destination and therefore is a
; potential overlapping move.  If Source == Destination, then nothing to do.
; Otherwise, increment the Source and Destination pointers by Length and do
; the move backwards, a byte at a time.
;

overlap:
        je      movedone
        mov     eax,edi
        sub     eax,esi
        cmp     ecx,eax
        jbe     nooverlap

        std
        add     esi,ecx
        add     edi,ecx
        dec     esi
        dec     edi
        rep     movsb
        cld
        jmp     short movedone

stdENDP _RtlMoveMemory

       subttl  "RtlCopyMemoryNonTemporal"
;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

MEMORY_ALIGNMENT_MASK0  = 63
MEMORY_ALIGNMENT_LOG2_0 = 6

MEMORY_ALIGNMENT_MASK1  = 3
MEMORY_ALIGNMENT_LOG2_1 = 2

sfence            macro
                   db      0FH, 0AEH, 0F8H
                  endm

prefetchnta_short macro   GeneralReg, Offset
                   db      0FH, 018H,  040H + GeneralReg, Offset
                  endm

prefetchnta_long  macro   GeneralReg, Offset
                   db      0FH, 018H,  080h + GeneralReg
                   dd      Offset
                  endm

movnti_eax        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 040H + GeneralReg, Offset
                  endm

movnti_eax_0_disp macro   GeneralReg
                   db  0FH, 0C3H, 000H + GeneralReg
                  endm

movnti_ebx        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 058H + GeneralReg, Offset
                  endm

;
;
; Macro that moves 64bytes (1 cache line using movnti (eax and ebx registers)
;
;

movnticopy64bytes  macro
                    mov    eax, [esi]
                    mov    ebx, [esi + 4]
                    movnti_eax_0_disp rEDI
                    movnti_ebx rEDI, 4

                    mov    eax, [esi + 8]
                    mov    ebx, [esi + 12]
                    movnti_eax rEDI, 8
                    movnti_ebx rEDI, 12

                    mov    eax, [esi + 16]
                    mov    ebx, [esi + 20]
                    movnti_eax rEDI, 16
                    movnti_ebx rEDI, 20

                    mov    eax, [esi + 24]
                    mov    ebx, [esi + 28]
                    movnti_eax rEDI, 24
                    movnti_ebx rEDI, 28

                    mov    eax, [esi + 32]
                    mov    ebx, [esi + 36]
                    movnti_eax rEDI,32
                    movnti_ebx rEDI, 36

                    mov    eax, [esi + 40]
                    mov    ebx, [esi + 44]
                    movnti_eax rEDI, 40
                    movnti_ebx rEDI,  44

                    mov    eax, [esi + 48]
                    mov    ebx, [esi + 52]
                    movnti_eax rEDI,48
                    movnti_ebx rEDI, 52

                    mov    eax, [esi + 56]
                    mov    ebx, [esi + 60]
                    movnti_eax rEDI, 56
                    movnti_ebx rEDI, 60
                  endm


;++
;
; VOID
; RtlCopyMemoryNonTemporal(
;    IN PVOID Destination,
;    IN PVOID Source ,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another
;   using nontemporal moves that do not polute the cache.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlCopyMemoryNonTemporal ,3  

; Definitions of arguments
; (TOS) = Return address

CPNDestination  equ     [ebp + 4 + 4]
CPNSource       equ     [ebp + 4 + 8]
CPNLength       equ     [ebp + 4 + 12]

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, CPNSource
        mov     edi, CPNDestination
        mov     ecx, CPNLength


;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      Copy4
        dec     edx
        je      copy64

        prefetchnta_short rESI, 128
        dec     edx
        je      copy128

        prefetchnta_short rESI, 192
        dec     edx
        je      copy192


         
copyLoop:

        prefetchnta_long rESI, 256

        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
        
        dec     edx
        jnz     copyLoop


copy192:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
       
copy128:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

copy64:

        movnticopy64bytes

        or     ecx, ecx  ; anything less than 64 to do?
        jz     ExitRoutine

        prefetchnta_short rESI, 0
;
;Update pointer for last copy    
;
        
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

;
;Handle extra bytes here in 32 bit chuncks and then 8-bit bytes    
;

Copy4:
         mov    edx, ecx
         and    ecx, MEMORY_ALIGNMENT_MASK1
         shr    edx, MEMORY_ALIGNMENT_LOG2_1

;
; If the number of 32-bit words to move is non-zero, then do it
;         
         jz     RemainingBytes 

Copy4Loop:
         mov    eax, [esi]
         movnti_eax_0_disp rEDI
         lea    esi, [esi+4]
         lea    edi, [edi+4]
         dec    edx
         jnz    Copy4Loop
         
RemainingBytes:
         or     ecx, ecx
         jz     ExitRoutine
         rep     movsb

ExitRoutine:     

        sfence            ;Make all stores globally visible 
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _RtlCopyMemoryNonTemporal 

stdENDP _RtlCopyMemoryNonTemporal

;++
;
; VOID
; RtlPrefetchCopyMemory(
;    IN PVOID Destination,
;    IN PVOID Source ,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another
;   prefetching the source 256 bytes ahead.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlPrefetchCopyMemory,3  

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, CPNSource
        mov     edi, CPNDestination
        mov     ecx, CPNLength


;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      short pcmCopy4
        dec     edx
        push    ecx
        je      short pcmcopy64

        prefetchnta_short rESI, 128
        dec     edx
        je      short pcmcopy128

        prefetchnta_short rESI, 192
        dec     edx
        je      short pcmcopy192


         
pcmcopyLoop:

        prefetchnta_long rESI, 256

        mov     ecx, 16
        rep     movsd
        
        dec     edx
        jnz     short pcmcopyLoop

pcmcopy192:

        mov     ecx, 16
        rep     movsd
       
pcmcopy128:

        mov     ecx, 16
        rep     movsd

pcmcopy64:

        mov     ecx, 16
        rep     movsd

        pop     ecx
        or      ecx, ecx  ; anything less than 64 to do?
        jz      short pcmExitRoutine

        prefetchnta_short rESI, 0

;
; Copy last part byte by byte.
;

pcmCopy4:
        or      ecx, ecx
        jz      short pcmExitRoutine
        rep     movsb

pcmExitRoutine:     

        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _RtlPrefetchCopyMemory

stdENDP _RtlPrefetchCopyMemory

;++
;
; VOID
; RtlPrefetchCopyMemory32(
;    IN PVOID Destination,
;    IN PVOID Source ,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another
;   prefetching the source 256 bytes ahead.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlPrefetchCopyMemory32,3  

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, CPNSource
        mov     edi, CPNDestination
        mov     ecx, CPNLength


;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      short pcm32Copy4
        dec     edx
        prefetchnta_short rESI, 32
        push    ecx
        je      short pcm32copy64

        prefetchnta_short rESI, 128
        prefetchnta_short rESI, 160
        dec     edx
        je      short pcm32copy128

        prefetchnta_short rESI, 192
        prefetchnta_short rESI, 124
        dec     edx
        je      short pcm32copy192


         
pcm32copyLoop:

        prefetchnta_long rESI, 256
        prefetchnta_long rESI, 288

        mov     ecx, 16
        rep     movsd
        
        dec     edx
        jnz     short pcm32copyLoop

pcm32copy192:

        mov     ecx, 16
        rep     movsd
       
pcm32copy128:

        mov     ecx, 16
        rep     movsd

pcm32copy64:

        mov     ecx, 16
        rep     movsd

        pop     ecx
        or      ecx, ecx  ; anything less than 64 to do?
        jz      short pcm32ExitRoutine

        prefetchnta_short rESI, 0

;
; Copy last part byte by byte.
;

pcm32Copy4:
        or      ecx, ecx
        jz      short pcm32ExitRoutine
        rep     movsb

pcm32ExitRoutine:     

        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _RtlPrefetchCopyMemory32

stdENDP _RtlPrefetchCopyMemory32

       subttl  "RtlPrefetchMemoryNonTemporal"

;++
;
; VOID
; FASTCALL
; RtlPrefetchMemoryNonTemporal(
;    IN PVOID Source,
;    IN SIZE_T Length
;    )
;
; Routine Description:
;
;   This function prefetches memory at Source, for Length bytes into the
;   closest cache to the processor.
;
; Arguments:
;
;    Source - Supplies a pointer to the memory to prefetch.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

ifndef BLDR_KERNEL_RUNTIME
ifdef NTOS_KERNEL_RUNTIME

        extrn   _KePrefetchNTAGranularity:DWORD

cPublicFastCall RtlPrefetchMemoryNonTemporal ,2

;
; The following instruction will be patched out at boot time if
; this processor supports the prefetch instruction.
;

        ret                                 ; patched out at boot.

        mov     eax, _KePrefetchNTAGranularity  ; get d-cache line size
@@:     prefetchnta_short rECX, 0           ; prefetch line
        add     ecx, eax                    ; bump prefetch address
        sub     edx, eax                    ; decrement length
        ja      short @b                    ; loop if more to get

        fstRET  RtlPrefetchMemoryNonTemporal ; return

fstENDP RtlPrefetchMemoryNonTemporal

endif
endif

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\ntcurteb.asm ===
title  "NtCurTeb.asm"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    NtCurTeb.asm
;
; Abstract:
;
;    Efficient NtCurrentTeb code.
;
; Author:
;
;    Bryan Willman (bryanwi) 28 feb 90
;
; Environment:
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        page ,132
        subttl  "NtCurrentTeb"

IFDEF NTOS_KERNEL_RUNTIME
.PAGE   SEGMENT DWORD PUBLIC 'CODE'
ELSE
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; PTEB
; NtCurrentTeb();
;
; Routine Description:
;
;    This routine returns the address of the current TEB.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Address of TEB.
;
;--
cPublicProc ___NtCurrentTeb   ,0
cPublicFpo 0,0

;
;   How this works in both user and kernel mode.
;
;   In user mode, TEB.TIB.Self is flat address of containing structure.
;   In kernel mode, PCR.TIB.Self is flat address of the TEB.
;   Same offset both places, so fs:PcTeb is always the flat address
;   of the TEB.
;

        mov     eax,fs:[PcTeb]
        stdRET    ___NtCurrentTeb

stdENDP ___NtCurrentTeb
IFDEF NTOS_KERNEL_RUNTIME
.PAGE           ENDS
ELSE
_TEXT           ENDS
ENDIF
                end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\raisests.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisests.c

Abstract:

    This module implements the routine that raises an exception given a
    specific status value.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Any mode.

Revision History:

--*/

#include "ntrtlp.h"

VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as continuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{

    EXCEPTION_RECORD ExceptionRecord;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    RtlRaiseException(&ExceptionRecord);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\raise.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    raise.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 april 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _ZwRaiseException,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS


;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; RtlRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlRaiseException  ,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
;   Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
;   Get pointer to exception report record, and set the exceptionaddress
;   field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
;   Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

;
; context record's ESP must have the argument popped off the stack
;

        lea     ecx,[ebp+12]

        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegDs],ds
        mov     dword ptr [eax.CsSegEs],es
        mov     dword ptr [eax.CsSegFs],fs
        mov     dword ptr [eax.CsSegGs],gs
        mov     dword ptr [eax.CsSegSs],ss

;
;   Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
;   _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

; 1 - TRUE
; eax - Context Record
; [ebp+8] - Exception Report Record

        stdCall   _ZwRaiseException,<[ebp+8],eax,1>

;
;   We came back, suggesting some sort of error in the call.  Raise
;   a status exception to report this, return from ZwRaiseException is type.
;

        sub     esp,EXCEPTION_RECORD_LENGTH ; allocate record on stack, esp is base
        mov     [esp.ErExceptionCode],eax   ; set exception type
        mov     dword ptr [esp.ErExceptionFlags],EXCEPTION_NONCONTINUABLE
        mov     dword ptr [esp.ErNumberParameters],0  ; no parms
        mov     eax,[ebp+8]
        mov     [esp.ErExceptionRecord],eax ; point back to first exception
        mov     eax,esp
        stdCall   _RtlRaiseException,<eax>

;
;   We will never come here, because RtlRaiseException will not allow
;   return if exception is non-continuable.
;

stdENDP _RtlRaiseException

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 13-Mar-1996
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; RtlpInterlockedFlushSList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes the entire list from a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry at the top of the list is removed
;    and returned as the function value and the list header is set to point
;    to NULL.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which the list is to be flushed.
;
; Return Value:
;
;    The address of the entire current list, or NULL if the list is
;    empty.
;
;--

;
; These old interfaces just fall into the new ones
;
cPublicFastCall ExInterlockedFlushSList, 1
fstENDP ExInterlockedFlushSList

cPublicFastCall RtlpInterlockedFlushSList, 1

cPublicFpo 0,1

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        xor     ebx, ebx                ; zero out new pointer
        mov     ebp, ecx                ; save listhead address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; N.B. The following code is the retry code should the compare
;      part of the compare exchange operation fail
;
; If the list is empty, then there is nothing that can be removed.
;

Efls10: or      eax, eax                ; check if list is empty
        jz      short Efls20            ; if z set, list is empty
        mov     ecx, edx   		; copy sequence number
        mov     cx, bx                  ; clear depth leaving sequence number

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr [ebp]       ; compare and exchange

endif
.386

        jnz     short Efls10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Efls20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedFlushSList

fstENDP RtlpInterlockedFlushSList

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPopEntrySList (
;    IN PSLIST_HEADER ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

;
; These older interfaces just fall into the new code below
;

cPublicFastCall InterlockedPopEntrySList, 1
fstENDP InterlockedPopEntrySList

cPublicFastCall ExInterlockedPopEntrySList, 2
fstENDP ExInterlockedPopEntrySList


cPublicFastCall RtlpInterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
;
; N.B. The following code is the continuation address should a fault
;      occur in the rare case described below.
;

        public  ExpInterlockedPopEntrySListResume
        public  _ExpInterlockedPopEntrySListResume@0
ExpInterlockedPopEntrySListResume:      ;
_ExpInterlockedPopEntrySListResume@0:   ;

        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

Epop10: or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        lea     ecx, [edx-1]            ; Adjust depth only


;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        public  ExpInterlockedPopEntrySListFault
ExpInterlockedPopEntrySListFault:       ;

        mov     ebx, [eax]              ; get address of successor entry

        public  _ExpInterlockedPopEntrySListEnd@0
_ExpInterlockedPopEntrySListEnd@0:      ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr [ebp]       ; compare and exchange

endif
.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedPopEntrySList

fstENDP RtlpInterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPushEntrySList (
;    IN PSLIST_HEADER ListHead,
;    IN PVOID ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

;
; This old interface just fall into the new code below.
;

cPublicFastCall ExInterlockedPushEntrySList, 3
       pop	[esp]			; Drop the lock argument
fstENDP ExInterlockedPushEntrySList

cPublicFastCall InterlockedPushEntrySList, 2
fstENDP InterlockedPushEntrySList


cPublicFastCall RtlpInterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        lea     ecx, [edx+010001H]      ; increment sequence number and depth

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlpInterlockedPushEntrySList

fstENDP RtlpInterlockedPushEntrySList

;++
;
; SINGLE_LIST_ENTRY
; FASTCALL
; InterlockedPushListSList (
;     IN PSLIST_HEADER ListHead,
;     IN PSINGLE_LIST_ENTRY List,
;     IN PSINGLE_LIST_ENTRY ListEnd,
;     IN ULONG Count
;    )
;
; Routine Description:
;
;    This function will push multiple entries onto an SList at once
;
; Arguments:
;
;     ListHead - List head to push the list to.
;
;     List - The list to add to the front of the SList
;     ListEnd - The last element in the chain
;     Count - The number of items in the chain
;
; Return Value:
;
;     PSINGLE_LIST_ENTRY - The old header pointer is returned
;
;--

cPublicFastCall InterlockedPushListSList, 4

cPublicFpo 0,4
        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epshl10:
        mov     ecx, [esp+4*3]          ; Fetch address of list tail
        mov     [ecx], eax              ; Store new forward pointer in tail entry
        lea     ecx, [edx+010000H]      ; increment sequence number
        add     ecx, [esp+4*4]		; Add in new count to create correct depth
.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386
        jnz     short Epshl10           ; if z clear, exchange failed

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  InterlockedPushListSList

fstENDP InterlockedPushListSList

;++
;
; PSINGLE_LIST_ENTRY
; FirstEntrySList (
;     IN PSLIST_HEADER SListHead
;     )
;
; Routine Description:
;
;   This function returns the address of the fisrt entry in the SLIST or
;   NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the first entry address is to be computed.
;
; Return Value:
;
;   The address of the first entry is the specified, or NULL if the list is
;   empty.
;
;--

cPublicProc _FirstEntrySList, 1
cPublicFpo 1,0

        mov       eax, [esp+4]
        mov       eax, [eax]
        stdRET    _FirstEntrySList

stdENDP _FirstEntrySList

;++
;
; LONGLONG
; FASTCALL
; RtlInterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall RtlInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlInterlockedCompareExchange64

fstENDP RtlInterlockedCompareExchange64

;++
;
; LONGLONG
; InterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN LONGLONG Exchange,
;    IN LONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (esp+4) Destination - Supplies a pointer to the destination variable.
;
;    (esp+8) Exchange - Supplies the exchange value.
;
;    (esp+16) Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicProc _InterlockedCompareExchange64, 5
cPublicFpo 5,0

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, [esp+12]           ; set destination address
        mov     ebx, [esp+16]           ; get exchange value
        mov     ecx, [esp+20]           ;
        mov     eax, [esp+24]           ; get comperand value
        mov     edx, [esp+28]           
.586
   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;
        stdRET    _InterlockedCompareExchange64

stdENDP _InterlockedCompareExchange64

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\ntrtl386.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtl386.h

Abstract:

    i386 specific parts of ntrtlp.h

Author:

    Bryan Willman   10 April 90

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

//
// Exception handling procedure prototypes.
//
VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
RtlpUnlinkHandler (
    PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
    );

PEXCEPTION_REGISTRATION_RECORD
RtlpGetRegistrationHead (
    VOID
    );

//
//  Record dump procedures.
//

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\stkwalk.asm ===
TITLE   "Capture Stack Back Trace"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stkwalk.asm
;
; Abstract:
;
;    This module implements the routine RtlCaptureStackBackTrace.  It will
;    walker the stack back trace and capture a portion of it.
;
; Author:
;
;    Steve Wood (stevewo) 29-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFDEF NTOS_KERNEL_RUNTIME
        EXTRNP  _MmIsAddressValid,1
ENDIF

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

IFDEF NTOS_KERNEL_RUNTIME
        page ,132
        subttl  "RtlGetCallersAddress"
;++
;
; VOID
; RtlGetCallersAddress(
;    OUT PVOID *CallersAddress,
;    OUT PVOID *CallersCaller
;    )
;
; Routine Description:
;
;    This routine walks up the stack frames, capturing the first two return
;    addresses
;
;
; Arguments:
;
;    OUT PVOID CallersAddress - returns callers return address
;    OUT PVOID CallersCaller - returns callers caller return address
;
; Return Value:
;
;     None.
;
;
;--
RgcaCallersAddress      EQU [ebp+08h]
RgcaCallersCaller       EQU [ebp+0Ch]
cPublicProc _RtlGetCallersAddress ,2
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save EBX
        push    esi                     ; Save ESI
        push    edi                     ; Save EDI
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; (eax)->current thread
        push    ThInitialStack[eax]     ;  RcbtInitialStack = base of kernel stack
        push    esp                     ; Save current esp for handler
        push    offset RgcaFault        ; Address of handler
        push    PCR[PcExceptionList]    ; Save current list head
        mov     PCR[PcExceptionList],esp; Put us on list
        xor     esi,esi                 ; (ESI) will contain callers return address
        xor     edi,edi                 ; (EDI) will contain callers caller return address

        mov     edx,ebp                 ; (EDX) = current frame pointer
        mov     edx,[edx]               ; (EDX) = callers frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtInitialStack
        jae     short RgcaCheckForDpcStack
        cmp     edx,ThStackLimit[eax]
        jb      short RgcaCheckForDpcStack

Rgca20:
        mov     esi,[edx].4             ; Get callers return address

        mov     edx,[edx]               ; (EDX) = callers caller frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtInitialStack
        jae     short RgcaExit

        mov     edi,[edx].4             ; Get callers caller return address
RgcaExit:
        mov     ecx,RgcaCallersAddress
        jecxz   @F
        mov     [ecx],esi
@@:
        mov     ecx,RgcaCallersCaller
        jecxz   @F
        mov     [ecx],edi
@@:
        pop     PCR[PcExceptionList]    ; Restore Exception list
        pop     edi                     ; discard handler address
        pop     edi                     ; discard saved esp
        pop     edi                     ; discard RcbtInitialStack
        pop     edi                     ; Restore EDI
        pop     esi                     ; Restore ESI
        pop     ebx                     ; Restore EBX
        pop     ebp
        stdRET  _RtlGetCallersAddress

;
; We may be executing on the DPC stack for this processor which is ok.
;

RgcaCheckForDpcStack:

        ; Check if DPC active.

        cmp     dword ptr PCR[PcPrcbData+PbDpcRoutineActive], 0
        mov     eax, PCR[PcPrcbData+PbDpcStack]
        je      short RgcaExit          ; if no DPC active, must be bad stack.

        ; Check if address if below DPC stack upper bound
        ;
        ; Note: If we ARE on the DPC stack, we need to adjust this funtion's
        ; idea of the initial stack pointer so it will succeed the check at
        ; the next level.   We do not support transitioning across stacks in
        ; this function.

        cmp     edx, eax
        mov     RcbtInitialStack, eax
        jae     short RgcaExit          ; exit if above upper bound

        ; Check if below DPC stack lower bound.

        sub     eax, KERNEL_STACK_SIZE
        cmp     edx, eax
        ja      short Rgca20            ; jif on DPC stack
        jmp     short RgcaExit          ; not on DPC stack.


RgcaFault:
;
; Cheap and sleazy exception handler.  This will not unwind properly, which
; is ok because this function is a leaf except for calling KeGetCurrentIrql,
; which has no exception handler.
;
        mov     eax,[esp+0Ch]           ; (esp)->Context
        mov     edi,CsEdi[eax]          ; restore buffer pointer
        mov     esp,[esp+8]             ; (esp)->ExceptionList
        jmp     RgcaExit                ;
stdENDP _RtlGetCallersAddress
ENDIF

IFDEF NTOS_KERNEL_RUNTIME
RcbtInitialStack        EQU [ebp-10h]
ENDIF

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\bswapi64.s ===
//      TITLE("Byte Swap Functions")
//++
//
// Copyright (c) 1998  Intel Corporation
// Copyright (c) 1997  Microsoft Corporation
//
// Module Name:
//
//    byteswap.s
//
// Abstract:
//
//    This module implements functions to perform byte swapping operations.
//
// Author:
//
//    William Cheung (v-willc) 30-Nov-1998
//
// Environment:
//
//    User or Kernel mode.
//
// Revision History:
//
//--

#include "ksia64.h"

        SBTTL("RtlUshortByteSwap")
//++
//
// USHORT
// RtlUshortByteSwap(
//    IN USHORT Source
//    )
//
// Routine Description:
//
//    The RtlUshortByteSwap function exchanges bytes 0 and 1 of Source
//    and returns the resulting USHORT.
//
// Arguments:
//
//    Source (a0[0..15]) - 16-bit value to byteswap.
//
// Return Value:
//
//    The 16-bit integer result is returned as the function value
//    in v0[0..15].
//
//--

         LEAF_ENTRY(RtlUshortByteSwap)

         shl        t0 = a0, 48
         ;;
         mux1       v0 = t0, @rev
         br.ret.sptk brp

         LEAF_EXIT(RtlUshortByteSwap)

        SBTTL("RtlUlongByteSwap")
//++
//
// ULONG
// RtlUlongByteSwap(
//    IN ULONG Source
//    )
//
// Routine Description:
//
//    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
//    Source and returns the the resulting ULONG.
//
// Arguments:
//
//    Source (a0[0..31]) - 32-bit value to byteswap.
//
// Return Value:
//
//    The 32-bit integer result is returned as the function value
//    in v0[0..31].
//
//--

         LEAF_ENTRY(RtlUlongByteSwap)

         shl        t0 = a0, 32
         ;;
         mux1       v0 = t0, @rev
         br.ret.sptk brp

         LEAF_EXIT(RtlUlongByteSwap)

        SBTTL("RtlUlonglongByteSwap")
//++
//
// ULONG
// RtlUlonglongByteSwap(
//    IN ULONGLONG Source
//    )
//
// /*++
//
// Routine Description:
//
//    The RtlUlonglongByteSwap function exchanges byte pairs 0:7, 1:6, 2:5,
//    and 3:4 of Source and returns the resulting ULONGLONG.
//
// Arguments:
//
//    Source (a0[0..63]) - 64-bit value to byteswap.
//
// Return Value:
//
//    Swapped 64-bit value.
//
//--

         LEAF_ENTRY(RtlUlonglongByteSwap)

         mux1       v0 = a0, @rev
         br.ret.sptk brp

         LEAF_EXIT(RtlUlonglongByteSwap)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\xcptmisc.asm ===
title   "Miscellaneous Exception Handling"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    xcptmisc.asm
;
; Abstract:
;
;    This module implements miscellaneous routines that are required to
;    support exception handling. Functions are provided to call an exception
;    handler for an exception, call an exception handler for unwinding, get
;    the caller's stack pointer, get the caller's frame pointer, get the
;    caller's floating status, get the caller's processor state, get the
;    caller's extended processor status, and get the current stack limits.
;
; Author:
;
;    David N. Cutler (davec) 14-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   6 April 90  bryanwi
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

;
; Unwind flags.
;

Unwind  equ EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an exception
;    handler. If a nested exception occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the exception dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    exception dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForException,5

        mov     edx,offset FLAT:ExceptionHandler    ; Set who to register
        jmp     ExecuteHandler                      ; jump to common code

stdENDP _RtlpExecuteHandlerForException


        page
        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an unwind
;    handler. If a collided unwind occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the unwind dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    unwind dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForUnwind    ,5

        mov     edx,offset FLAT:UnwindHandler

;;  N.B. - FALL into ExecuteHandler

stdENDP _RtlpExecuteHandlerForUnwind



;
;   ExecuteHandler is the common tail for RtlpExecuteHandlerForException
;   and RtlpExecuteHandlerForUnwind - we clean up some registers so they don't
;   leak through the handler, then call the real execute code.
;
;   (edx) = handler (Exception or Unwind) address
;

cPublicProc   ExecuteHandler,5
        push    ebx
	push    esi
	push    edi
	xor     eax, eax
	xor     ebx, ebx
	xor     esi, esi
	xor     edi, edi
	push    [esp+32]          ; ExceptionRoutine
	push    [esp+32]          ; DispatcherContext
	push    [esp+32]          ; ContextRecord
	push    [esp+32]          ; EstablisherFrame
	push    [esp+32]          ; ExceptionRecord
	call    ExecuteHandler2
	pop     edi
	pop     esi
	pop     ebx
        stdRET  ExecuteHandler
stdENDP ExecuteHandler


ExceptionRecord     equ [ebp+8]
EstablisherFrame    equ [ebp+12]
ContextRecord       equ [ebp+16]
DispatcherContext   equ [ebp+20]
ExceptionRoutine    equ [ebp+24]


cPublicProc   ExecuteHandler2,5

        push    ebp
        mov     ebp,esp

        push    EstablisherFrame        ; Save context of exception handler
                                        ; that we're about to call.

    .errnz   ErrHandler-4
        push    edx                     ; Set Handler address

    .errnz   ErrNext-0
        push    fs:PcExceptionList                      ; Set next pointer


        mov     fs:PcExceptionList,esp                  ; Link us on

; Call the specified exception handler.

        push    DispatcherContext
        push    ContextRecord
        push    EstablisherFrame
        push    ExceptionRecord

        mov     ecx,ExceptionRoutine
        call    ecx
        mov     esp,fs:PcExceptionList

; Don't clean stack here, code in front of ret will blow it off anyway

; Disposition is in eax, so all we do is deregister handler and return

    .errnz  ErrNext-0
        pop     fs:PcExceptionList

        mov     esp,ebp
        pop     ebp
        stdRET  ExecuteHandler2

stdENDP ExecuteHandler2

        page
        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a nested exception occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested exception.
;
; Arguments:
;
;    ExceptionRecord (exp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionNestedException is returned if an unwind
;    is not in progress. Otherwise a value of ExceptionContinueSearch is
;    returned.
;
;--

stdPROC   ExceptionHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume unwind
        jnz     eh10                            ; unwind, go return

;
; Unwind is not in progress - return nested exception disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionNestedException

eh10:   stdRET    ExceptionHandler

stdENDP ExceptionHandler

        page
        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; UnwindHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a collided unwind occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested unwind.
;
; Arguments:
;
;    ExceptionRecord (esp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionCollidedUnwind is returned if an unwind is
;    in progress. Otherwise a value of ExceptionContinueSearch is returned.
;
;--

stdPROC   UnwindHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume NOT unwind
        jz      uh10                            ; not unwind, go return


;
; Unwind is in progress - return collided unwind disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionCollidedUnwind

uh10:   stdRET    UnwindHandler

stdENDP UnwindHandler

        page
        subttl  "Unlink Exception Registration Record & Handler"
;++
;
; VOID
; RtlpUnlinkHandler(PEXCEPTION_REGISTRATION_RECORD UnlinkPointer)
;
; Routine Description:
;
;   This function removes the specified exception registration record
;   (and thus the relevent handler) from the exception traversal
;   chain.
;
; Arguments:
;
;    UnlinkPointer (esp+4) - Address of registration record to unlink.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlpUnlinkHandler ,1

        mov     ecx,dword ptr [esp+4]
        mov     ecx,[ecx.ErrNext]
        mov     fs:PcExceptionList,ecx
        stdRET    _RtlpUnlinkHandler

stdENDP _RtlpUnlinkHandler

        page
        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
; RtlpCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
;   RtlpCaptureContext does not capture volitales.
;   RtlCaptureContext captures volitales.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi
        jmp     RtlpCaptureCommon
stdENDP _RtlCaptureContext

cPublicProc _RtlpCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],0
        mov     dword ptr [ebx.CsEcx],0
        mov     dword ptr [ebx.CsEdx],0
        mov     dword ptr [ebx.CsEbx],0

        mov     dword ptr [ebx.CsEsi],0
        mov     dword ptr [ebx.CsEdi],0

RtlpCaptureCommon:
        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegDs],ds
        mov     [ebx.CsSegEs],es
        mov     [ebx.CsSegFs],fs
        mov     [ebx.CsSegGs],gs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _RtlpCaptureContext

stdENDP _RtlpCaptureContext

        page
        subttl  "Capture Context (private)"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This function is similiar too RtlpCaptureContext expect that
;   volitales are captured as well.
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--


        page
        subttl  "Get Stack Limits"
;++
;
; VOID
; RtlpGetStackLimits (
;    OUT PULONG LowLimit,
;    OUT PULONG HighLimit
;    )
;
; Routine Description:
;
;    This function returns the current stack limits based on the current
;    processor mode.
;
; Arguments:
;
;    LowLimit (esp+4) - Supplies a pointer to a variable that is to receive
;       the low limit of the stack.
;
;    HighLimit (esp+8) - Supplies a pointer to a variable that is to receive
;       the high limit of the stack.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlpGetStackLimits ,2
;cPublicFpo 2,0

ifdef NTOS_KERNEL_RUNTIME

        mov     eax,fs:PcPrcbData+PbCurrentThread ; get current thread address
        mov     eax,[eax]+ThStackLimit  ; get thread stack limit

else

        mov     eax,fs:TbStackLimit

endif

        mov     ecx,[esp+4]
        mov     [ecx],eax               ; Save low limit

ifdef NTOS_KERNEL_RUNTIME
        mov     eax,fs:PcPrcbData+PbCurrentThread ; get current thread address
        mov     eax,[eax].ThInitialStack
        sub     eax, NPX_FRAME_LENGTH
else
        mov     eax,fs:PcInitialStack
endif
        mov     ecx,[esp+8]
        mov     [ecx],eax               ; Save high limit

        stdRET    _RtlpGetStackLimits

stdENDP _RtlpGetStackLimits

        page
        subttl  "Get Exception Registration List Head"
;++
;
;   PVOID
;   RtlpGetRegistrationHead()
;
;   Routine Description:
;
;       This function returns the address of the first Exception
;       registration record for the current context.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetRegistrationHead    ,0
;cPublicFpo 0,0

        mov     eax,fs:PcExceptionList
        stdRET    _RtlpGetRegistrationHead

stdENDP _RtlpGetRegistrationHead
_TEXT$01   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\stringsp.asm ===
TITLE   "String support routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stringsup.asm
;
; Abstract:
;
;    This module implements suplimentary routines for performing string
;    operations.
;
; Author:
;
;    Larry Osterman (larryo) 18-Sep-1991
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   Dragos Sambotin (dragoss) 18-Dec-2002
;       Truncate length at MAXUSHORT when source string is bigger than 64K in size
;
;--

.386p

include ks386.inc
include callconv.inc            ; calling convention macros

if DBG
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

ifndef BLDR_KERNEL_RUNTIME
_MsgStringTooLong   db  'RTL: RtlInit*String called with string length: (%x)\n',0
endif

_DATA ENDS

ifndef BLDR_KERNEL_RUNTIME
ifdef NTOS_KERNEL_RUNTIME
    extrn   _KdDebuggerEnabled:BYTE
endif
    EXTRNP  _DbgBreakPoint,0
    extrn   _DbgPrint:near
endif
endif


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitAnsiString(
;     OUT PANSI_STRING DestinationString,
;     IN PSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitAnsiString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        cmp     ecx,0ffffh
        jbe     rtis

;
; spew length and bp if debugger attached.
;
if DBG
ifndef BLDR_KERNEL_RUNTIME
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      nobp1
        call    _DbgBreakPoint@0
nobp1:  pop     edx
endif
endif

        mov     ecx,0ffffh              ; overflow, truncate at MAXUSHORT
rtis:   mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitString

stdENDP _RtlInitString


cPublicProc _RtlInitAnsiString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        cmp     ecx,0ffffh
        jbe     rtias
;
; spew length and bp if debugger attached.
;
if DBG
ifndef BLDR_KERNEL_RUNTIME
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      nobp2
        call    _DbgBreakPoint@0
nobp2:  pop    edx
endif
endif

        mov     ecx,0ffffh              ; overflow, truncate at MAXUSHORT
rtias:  mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitAnsiString

stdENDP _RtlInitAnsiString


        page
        subttl  "RtlInitUnicodeString"
;++
;
; VOID
; RtlInitUnicodeString(
;     OUT PUNICODE_STRING DestinationString,
;     IN PWSTR SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitUnicodeString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitUnicodeString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasw
        not     ecx
        shl     ecx,1
        cmp     ecx,0fffeh
        jbe     rtius

;
; spew length and bp if debugger attached.
;
if DBG
ifndef BLDR_KERNEL_RUNTIME
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      nobp3
        call    _DbgBreakPoint@0
nobp3:  pop     edx
endif
endif

        mov     ecx,0fffeh              ; overflow, truncate at MAX_USTRING
rtius:  mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitUnicodeString

stdENDP _RtlInitUnicodeString

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\capture.s ===
//      TITLE("Capture and Restore Context")
//++
//
// Module Name:
//
//    capture.s
//
// Abstract:
//
//    This module implements the code necessary to capture and restore
//    the context of the caller.
//
// Author:
//
//    William K. Cheung (wcheung) 08-Jan-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "ksia64.h"


        .global     ZwContinue
        .type       ZwContinue, @function


//++
//
// VOID
// RtlCaptureContext (
//    OUT PCONTEXT ContextRecord
//    )
//
// Routine Description:
//
//    This function captures the context of the caller in the specified
//    context record.
//
//    N.B. The context record is not guaranteed to be quadword aligned
//       and, therefore, no double floating store instructions can be
//       used.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies the address of a context record.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlCaptureContext)

//
// Save all integer registers and flush the RSE
//

        .prologue
        .regstk     1, 10, 0, 0

        rbsp        = loc9
        rpfs        = loc8
        rbrp        = loc7
        rpr         = loc6
        runat       = loc4
        flag        = t16
        rpsr        = t22


        alloc       rpfs = ar.pfs, 1, 10, 0, 0
        add         loc0 = CxIntGp, a0
        add         loc1 = CxIntT8, a0
        ;;

        flushrs
        .save       ar.unat, loc4
        mov         runat = ar.unat
        mov         rpr = pr

        PROLOGUE_END

        .mem.offset 0,0
        st8.spill.nta [loc0] = gp, CxIntT0 - CxIntGp
        .mem.offset 8,0
        st8.spill.nta [loc1] = t8, CxIntT9 - CxIntT8
        add         loc2 = CxIntGp, a0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t0, CxIntT1 - CxIntT0
        .mem.offset 8,0
        st8.spill.nta [loc1] = t9, CxIntT10 - CxIntT9
        shr         loc2 = loc2, 3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t1, CxIntS0 - CxIntT1
        .mem.offset 8,0
        st8.spill.nta [loc1] = t10, CxIntT11 - CxIntT10
        and         t0 = 0x3f, loc2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s0, CxIntS1 - CxIntS0
        .mem.offset 8,0
        st8.spill.nta [loc1] = t11, CxIntT12 - CxIntT11
        cmp4.ge     pt1, pt0 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s1, CxIntS2 - CxIntS1
        .mem.offset 8,0
        st8.spill.nta [loc1] = t12, CxIntT13 - CxIntT12
 (pt1)  sub         t1 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s2, CxIntS3 - CxIntS2
        .mem.offset 8,0
        st8.spill.nta [loc1] = t13, CxIntT14 - CxIntT13
 (pt0)  add         t1 = -1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s3, CxIntV0 - CxIntS3
        .mem.offset 8,0
        st8.spill.nta [loc1] = t14, CxIntT15 - CxIntT14
 (pt0)  sub         t8 = 65, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = v0, CxIntTeb - CxIntV0
        .mem.offset 8,0
        st8.spill.nta [loc1] = t15, CxIntT16 - CxIntT15
        nop.i       0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = teb, CxIntT2 - CxIntTeb
        .mem.offset 8,0
        st8.spill.nta [loc1] = t16, CxIntT17 - CxIntT16
        mov         rbrp = brp
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t2, CxIntT3 - CxIntT2
        .mem.offset 8,0
        st8.spill.nta [loc1] = t17, CxIntT18 - CxIntT17
        mov         t11 = bs0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t3, CxIntSp - CxIntT3
        .mem.offset 8,0
        st8.spill.nta [loc1] = t18, CxIntT19 - CxIntT18
        mov         t12 = bs1
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = sp, CxIntT4 - CxIntSp
        .mem.offset 8,0
        st8.spill.nta [loc1] = t19, CxIntT20 - CxIntT19
        mov         t13 = bs2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t4, CxIntT5 - CxIntT4
        .mem.offset 8,0
        st8.spill.nta [loc1] = t20, CxIntT21 - CxIntT20
        mov         t14 = bs3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t5, CxIntT6 - CxIntT5
        .mem.offset 8,0
        st8.spill.nta [loc1] = t21, CxIntT22 - CxIntT21
        mov         t15 = bs4
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t6, CxIntT7 - CxIntT6
        .mem.offset 8,0
        st8.spill.nta [loc1] = t22, CxPreds - CxIntT22
        mov         t16 = bt0
        ;;

        st8.spill.nta [loc0] = t7
        st8.nta     [loc1] = rpr, CxIntNats - CxPreds   // save predicates
        mov         t17 = bt1
        ;;

        mov         t9 = ar.unat
        mov         t4 = ar.fpsr
        add         loc2 = CxBrRp, a0
        ;;

        add         loc3 = CxBrS3, a0
  (pt1) shl         t9 = t9, t1
  (pt0) shr.u       t2 = t9, t1
        ;;

//
// Save branch registers.
//

        st8.nta     [loc2] = rbrp, CxBrS0 - CxBrRp  // save brp
        st8.nta     [loc3] = t14, CxBrS4 - CxBrS3   // save bs3
  (pt0) shl         t3 = t9, t8
        ;;

        st8.nta     [loc2] = t11, CxBrS1 - CxBrS0   // save bs0
        st8.nta     [loc3] = t15, CxBrT0 - CxBrS4   // save bs4
  (pt0) or          t9 = t2, t3
        ;;

        st8.nta     [loc2] = t12, CxBrS2 - CxBrS1   // save bs1
        st8.nta     [loc3] = t16, CxBrT1 - CxBrT0   // save bt0
        add         loc0 = CxStFPSR, a0
        ;;

        st8.nta     [loc2] = t13                    // save bs2
        st8.nta     [loc3] = t17                    // save bt1
        nop.i       0
        ;;

        st8.nta     [loc0] = t4                     // save fpsr
        st8.nta     [loc1] = t9                     // save nat bits
        ;;

#if !defined(NTOS_KERNEL_RUNTIME)
        mov         t0 = ar21
        mov         t1 = ar24
        add         loc0 = CxStFCR, a0
        add         loc1 = CxEflag, a0
        ;;

        mov         t2 = ar25
        mov         t3 = ar26
        st8.nta     [loc0] = t0, 16
        st8.nta     [loc1] = t1, 16
        ;;

        mov         t0 = ar27
        mov         t1 = ar28
        st8.nta     [loc0] = t2, 16
        st8.nta     [loc1] = t3, 16
        ;;

        mov         t2 = ar29
        mov         t3 = ar30
        st8.nta     [loc0] = t0, 16
        st8.nta     [loc1] = t1, 16
        ;;
        st8.nta     [loc0] = t2, 16
        st8.nta     [loc1] = t3, 16
#endif // !defined(NTOS_KERNEL_RUNTIME)

        mov         rbsp = ar.bsp
        add         loc2 = CxFltS0, a0
        add         loc3 = CxFltS1, a0
        ;;

//
// Save floating status and floating registers f0 - f127.
//

        stf.spill.nta [loc2] = fs0, CxFltS2 - CxFltS0
        stf.spill.nta [loc3] = fs1, CxFltS3 - CxFltS1
        shr         t0 = rpfs, 7
        ;;
         
        stf.spill.nta [loc2] = fs2, CxFltT0 - CxFltS2
        stf.spill.nta [loc3] = fs3, CxFltT1 - CxFltS3
        and         t0 = 0x7f, t0
        ;;
         
        stf.spill.nta [loc2] = ft0, CxFltT2 - CxFltT0
        stf.spill.nta [loc3] = ft1, CxFltT3 - CxFltT1
        shr         t1 = rbsp, 3
        ;;
         
        stf.spill.nta [loc2] = ft2, CxFltT4 - CxFltT2
        stf.spill.nta [loc3] = ft3, CxFltT5 - CxFltT3
        and         t1 = 0x3f, t1
        ;;
         
        stf.spill.nta [loc2] = ft4, CxFltT6 - CxFltT4
        stf.spill.nta [loc3] = ft5, CxFltT7 - CxFltT5
        sub         t2 = t0, t1
        ;;
         
        stf.spill.nta [loc2] = ft6, CxFltT8 - CxFltT6
        stf.spill.nta [loc3] = ft7, CxFltT9 - CxFltT7
        cmp4.le     pt1, pt0 = t2, zero
        ;;
         
        stf.spill.nta [loc2] = ft8, CxFltS4 - CxFltT8
        stf.spill.nta [loc3] = ft9, CxFltS5 - CxFltT9
 (pt0)  add         t2 = -1, t2
        ;;

        stf.spill.nta [loc2] = fs4, CxFltS6 - CxFltS4
        stf.spill.nta [loc3] = fs5, CxFltS7 - CxFltS5
 (pt0)  add         t0 = 1, t0
        ;;

        stf.spill.nta [loc2] = fs6, CxFltS8 - CxFltS6
        stf.spill.nta [loc3] = fs7, CxFltS9 - CxFltS7
 (pt0)  add         t2 = -63, t2
        ;;

        stf.spill.nta [loc2] = fs8, CxFltS10 - CxFltS8
        stf.spill.nta [loc3] = fs9, CxFltS11 - CxFltS9
 (pt0)  cmp4.ge.unc pt2, pt3 = t2, zero
        ;;
        
        stf.spill.nta [loc2] = fs10, CxFltS12 - CxFltS10
        stf.spill.nta [loc3] = fs11, CxFltS13 - CxFltS11

        mov         rpsr = psr.um
 (pt1)  br.cond.spnt Rcc20p
        ;;

Rcc10p:
 (pt2)  add         t0 = 1, t0
 (pt2)  add         t2 = -63, t2
 (pt3)  br.cond.sptk Rcc20p
        ;;

        cmp4.ge     pt2, pt3 = t2, zero
        nop.m       0
        br          Rcc10p
        ;;

Rcc20p:
        stf.spill.nta [loc2] = fs12, CxFltS14 - CxFltS12
        stf.spill.nta [loc3] = fs13, CxFltS15 - CxFltS13
        shl         t0 = t0, 3
        ;;

        stf.spill.nta [loc2] = fs14, CxFltS16 - CxFltS14
        stf.spill.nta [loc3] = fs15, CxFltS17 - CxFltS15
        sub         rbsp = rbsp, t0
        ;;

        stf.spill.nta [loc2] = fs16, CxFltS18 - CxFltS16
        stf.spill.nta [loc3] = fs17, CxFltS19 - CxFltS17
        tbit.z      pt2, pt1 = rpsr, PSR_MFH
        ;;

        stf.spill.nta [loc2] = fs18, CxFltF32 - CxFltS18
        stf.spill.nta [loc3] = fs19, CxFltF33 - CxFltS19
        mov         flag = CONTEXT_CONTROL | CONTEXT_LOWER_FLOATING_POINT | CONTEXT_INTEGER
        ;;

#if !defined(NTOS_KERNEL_RUNTIME)

        //
        // there is no need to capture the high fp set if the privilege
        // mode is kernel or the psr.mfh bit is not set in user mode.
        //

 (pt1)  mov          flag = CONTEXT_FULL
 (pt2)  br.cond.sptk  Rcc30p
        ;;

        stf.spill.nta [loc2] = f32, CxFltF34 - CxFltF32
        stf.spill.nta [loc3] = f33, CxFltF35 - CxFltF33
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f34, CxFltF36 - CxFltF34
        stf.spill.nta [loc3] = f35, CxFltF37 - CxFltF35
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f36, CxFltF38 - CxFltF36
        stf.spill.nta [loc3] = f37, CxFltF39 - CxFltF37
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f38, CxFltF40 - CxFltF38
        stf.spill.nta [loc3] = f39, CxFltF41 - CxFltF39
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f40, CxFltF42 - CxFltF40
        stf.spill.nta [loc3] = f41, CxFltF43 - CxFltF41
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f42, CxFltF44 - CxFltF42
        stf.spill.nta [loc3] = f43, CxFltF45 - CxFltF43
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f44, CxFltF46 - CxFltF44
        stf.spill.nta [loc3] = f45, CxFltF47 - CxFltF45
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f46, CxFltF48 - CxFltF46
        stf.spill.nta [loc3] = f47, CxFltF49 - CxFltF47
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f48, CxFltF50 - CxFltF48
        stf.spill.nta [loc3] = f49, CxFltF51 - CxFltF49
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f50, CxFltF52 - CxFltF50
        stf.spill.nta [loc3] = f51, CxFltF53 - CxFltF51
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f52, CxFltF54 - CxFltF52
        stf.spill.nta [loc3] = f53, CxFltF55 - CxFltF53
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f54, CxFltF56 - CxFltF54
        stf.spill.nta [loc3] = f55, CxFltF57 - CxFltF55
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f56, CxFltF58 - CxFltF56
        stf.spill.nta [loc3] = f57, CxFltF59 - CxFltF57
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f58, CxFltF60 - CxFltF58
        stf.spill.nta [loc3] = f59, CxFltF61 - CxFltF59
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f60, CxFltF62 - CxFltF60
        stf.spill.nta [loc3] = f61, CxFltF63 - CxFltF61
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f62, CxFltF64 - CxFltF62
        stf.spill.nta [loc3] = f63, CxFltF65 - CxFltF63
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f64, CxFltF66 - CxFltF64
        stf.spill.nta [loc3] = f65, CxFltF67 - CxFltF65
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f66, CxFltF68 - CxFltF66
        stf.spill.nta [loc3] = f67, CxFltF69 - CxFltF67
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f68, CxFltF70 - CxFltF68
        stf.spill.nta [loc3] = f69, CxFltF71 - CxFltF69
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f70, CxFltF72 - CxFltF70
        stf.spill.nta [loc3] = f71, CxFltF73 - CxFltF71
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f72, CxFltF74 - CxFltF72
        stf.spill.nta [loc3] = f73, CxFltF75 - CxFltF73
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f74, CxFltF76 - CxFltF74
        stf.spill.nta [loc3] = f75, CxFltF77 - CxFltF75
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f76, CxFltF78 - CxFltF76
        stf.spill.nta [loc3] = f77, CxFltF79 - CxFltF77
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f78, CxFltF80 - CxFltF78
        stf.spill.nta [loc3] = f79, CxFltF81 - CxFltF79
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f80, CxFltF82 - CxFltF80
        stf.spill.nta [loc3] = f81, CxFltF83 - CxFltF81
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f82, CxFltF84 - CxFltF82
        stf.spill.nta [loc3] = f83, CxFltF85 - CxFltF83
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f84, CxFltF86 - CxFltF84
        stf.spill.nta [loc3] = f85, CxFltF87 - CxFltF85
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f86, CxFltF88 - CxFltF86
        stf.spill.nta [loc3] = f87, CxFltF89 - CxFltF87
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f88, CxFltF90 - CxFltF88
        stf.spill.nta [loc3] = f89, CxFltF91 - CxFltF89
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f90, CxFltF92 - CxFltF90
        stf.spill.nta [loc3] = f91, CxFltF93 - CxFltF91
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f92, CxFltF94 - CxFltF92
        stf.spill.nta [loc3] = f93, CxFltF95 - CxFltF93
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f94, CxFltF96 - CxFltF94
        stf.spill.nta [loc3] = f95, CxFltF97 - CxFltF95
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f96, CxFltF98 - CxFltF96
        stf.spill.nta [loc3] = f97, CxFltF99 - CxFltF97
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f98, CxFltF100 - CxFltF98
        stf.spill.nta [loc3] = f99, CxFltF101 - CxFltF99
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f100, CxFltF102 - CxFltF100
        stf.spill.nta [loc3] = f101, CxFltF103 - CxFltF101
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f102, CxFltF104 - CxFltF102
        stf.spill.nta [loc3] = f103, CxFltF105 - CxFltF103
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f104, CxFltF106 - CxFltF104
        stf.spill.nta [loc3] = f105, CxFltF107 - CxFltF105
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f106, CxFltF108 - CxFltF106
        stf.spill.nta [loc3] = f107, CxFltF109 - CxFltF107
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f108, CxFltF110 - CxFltF108
        stf.spill.nta [loc3] = f109, CxFltF111 - CxFltF109
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f110, CxFltF112 - CxFltF110
        stf.spill.nta [loc3] = f111, CxFltF113 - CxFltF111
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f112, CxFltF114 - CxFltF112
        stf.spill.nta [loc3] = f113, CxFltF115 - CxFltF113
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f114, CxFltF116 - CxFltF114
        stf.spill.nta [loc3] = f115, CxFltF117 - CxFltF115
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f116, CxFltF118 - CxFltF116
        stf.spill.nta [loc3] = f117, CxFltF119 - CxFltF117
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f118, CxFltF120 - CxFltF118
        stf.spill.nta [loc3] = f119, CxFltF121 - CxFltF119
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f120, CxFltF122 - CxFltF120
        stf.spill.nta [loc3] = f121, CxFltF123 - CxFltF121
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f122, CxFltF124 - CxFltF122
        stf.spill.nta [loc3] = f123, CxFltF125 - CxFltF123
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f124, CxFltF126 - CxFltF124
        stf.spill.nta [loc3] = f125, CxFltF127 - CxFltF125
        nop.i       0
        ;;

        stf.spill.nta [loc2] = f126
        stf.spill.nta [loc3] = f127
        nop.i       0
        ;;

Rcc30p:

#endif //  !defined(NTOS_KERNEL_RUNTIME)

//
// Save application registers, control information and set context flags.
//

        User=pt0
        Krnl=pt1
        rdcr=t1
        sol=t4
        rpsr=t5
        is=t6
        rccv=t7
        rlc=t8
        rec=t9
        rrsc=t10
        rrnat=t11
        addr0=t17
        addr1=t18
        tmp=t19

        mov         rrsc = ar.rsc
        tbit.nz     Krnl, User = sp, 62         // bit 62 is 1 when
        mov         rlc = ar.lc
        ;;

        mov         ar.rsc = r0                 // put RSE in lazy mode
        mov         rccv = ar.ccv
        mov         rec = ar.ec
        ;;                                      // in kernel

 (Krnl) mov         rpsr = psr
 (User) mov         rpsr = psr.um
        add         addr0 = CxApUNAT, a0

        mov         rrnat = ar.rnat
        add         addr1 = CxApLC, a0

 (Krnl) mov         rdcr = cr.dcr
 (Krnl) movl        tmp = 1 << PSR_BN
        ;;

        st8.nta     [addr0] = runat, CxApEC - CxApUNAT
        st8.nta     [addr1] = rlc, CxApCCV - CxApLC
 (Krnl) or          rpsr = tmp, rpsr
        ;;

        st8.nta     [addr0] = rec, CxApDCR - CxApEC
        st8.nta     [addr1] = rccv, CxRsPFS - CxApCCV
        mov         tmp = 1
        ;;

        st8.nta     [addr0] = rdcr, CxRsBSP - CxApDCR
        st8.nta     [addr1] = rpfs, CxRsBSPSTORE - CxRsPFS
        shl         tmp = tmp, 63
        ;;

        st8.nta     [addr0] = rbsp, CxRsRSC - CxRsBSP
        st8.nta     [addr1] = rbsp, CxRsRNAT - CxRsBSPSTORE
        or          rpfs = rpfs, tmp            // validate IFS
        ;;

        st8.nta     [addr0] = rrsc, CxStIIP - CxRsRSC
        st8.nta     [addr1] = rrnat, CxStIFS - CxRsRNAT
        mov         rccv = ar.csd
        mov         rbsp = ar.bsp
        ;;

        st8.nta     [addr0] = rbrp, CxStIPSR - CxStIIP
        st8.nta     [addr1] = rpfs, CxSegCSD - CxStIFS 
        add         tmp = CxContextFlags, a0
        ;;

        st8.nta     [addr0] = rpsr              // save psr
        st8.nta     [addr1] = rccv              // save CxSegCSD
        dep         rbsp = 1, rbsp, 3, 6       // Calculate the address of the NAT collection
        ;;
        mov         ar.rsc = rrsc               // restore RSC
        st4.nta     [tmp] = flag

        st8.nta     [rbsp] = rrnat              // Save the current RNAT in NAT collection for the BSP.
                                                // This handles the case where the collection location is in 
                                                // the middle of the out registers, and never gets written, but
                                                // is read when we do a continue with this context.  

        mov         ar.unat = runat             // restore ar.unat
 (p0)   br.ret.sptk brp                         // return to caller.

        LEAF_EXIT(RtlCaptureContext)


//++
//
// VOID
// RtlCaptureNonVolatileContext (
//    OUT PCONTEXT ContextRecord
//    )
//
// Routine Description:
//
//    This function captures the non-volatile context of the caller in the specified
//    context record.
//
//    N.B. The context record is not guaranteed to be quadword aligned
//       and, therefore, no double floating store instructions can be
//       used.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies the address of a context record.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlCaptureNonVolatileContext)
//
// Save all non-volatile integer registers and flush the RSE
//

        .prologue
        .regstk     1, 10, 0, 0

        rbsp        = loc9
        rpfs        = loc8
        rbrp        = loc7
        rpr         = loc6
        runat       = loc4
        flag        = t16
        rpsr        = t22


        alloc       rpfs = ar.pfs, 1, 10, 0, 0
        add         loc0 = CxIntGp, a0
        add	    loc1 = CxIntS0, a0		
        ;;

        flushrs
        .save       ar.unat, loc4
        mov         runat = ar.unat
        mov         rpr = pr

        PROLOGUE_END

        .mem.offset 0,0
	st8.spill.nta [loc0] = gp, CxIntS1 - CxIntGp
	.mem.offset 8,0
        st8.spill.nta [loc1] = s0, CxIntS2 - CxIntS0
        add         loc2 = CxIntGp, a0
        ;;
	
        .mem.offset 0,0
        st8.spill.nta [loc0] = s1, CxIntV0 - CxIntS1
	.mem.offset 8,0	
        st8.spill.nta [loc1] = s2, CxIntS3 - CxIntS2	
	shr         loc2 = loc2, 3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = v0, CxIntTeb - CxIntV0
	.mem.offset 8,0		
	st8.spill.nta [loc1] = s3, CxPreds - CxIntS3
        and         t0 = 0x3f, loc2
	;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = teb, CxIntSp - CxIntTeb
	.mem.offset 8,0			
        st8.nta     [loc1] = rpr, CxIntNats - CxPreds   // save predicates	
        cmp4.ge     pt1, pt0 = 1, t0
	;;
	
 (pt1)  sub         t1 = 1, t0
 (pt0)  add         t1 = -1, t0 
 (pt0)   sub         t8 = 65, t0
	;;
	
        mov         rbrp = brp	
        mov         t11 = bs0	
        mov         t12 = bs1	
        ;;


        mov         t13 = bs2	 
        mov         t14 = bs3		
        mov         t15 = bs4 		
        ;;

        st8.spill.nta [loc0] = sp
	;;
        mov         t9 = ar.unat 
        mov         t4 = ar.fpsr 
        ;;

        add         loc2 = CxBrRp, a0	
        add         loc3 = CxBrS3, a0	
	add         loc0 = CxStFPSR, a0	
        ;;


  (pt1) shl         t9 = t9, t1	
  (pt0) shr.u       t2 = t9, t1  
        nop.i 	    0
        ;;


//
// Save branch registers.
//

        st8.nta     [loc2] = rbrp, CxBrS0 - CxBrRp  // save brp
        st8.nta     [loc3] = t14, CxBrS4 - CxBrS3   // save bs3
  (pt0) shl         t3 = t9, t8
        ;;

        st8.nta     [loc2] = t11, CxBrS1 - CxBrS0   // save bs0
        st8.nta     [loc3] = t15, CxBrT0 - CxBrS4   // save bs4
  (pt0) or          t9 = t2, t3
        ;;

        st8.nta     [loc2] = t12, CxBrS2 - CxBrS1   // save bs1
        st8.nta     [loc0] = t4                     // save fpsr	
        nop.i	    0 
        ;;

        st8.nta     [loc2] = t13                    // save bs2
        st8.nta     [loc1] = t9                     // save nat bits
        nop.i       0
        ;;


#if !defined(NTOS_KERNEL_RUNTIME)
        mov         t0 = ar21
        mov         t1 = ar24
        add         loc0 = CxStFCR, a0
        add         loc1 = CxEflag, a0
        ;;

        mov         t2 = ar25
        mov         t3 = ar26
        st8.nta     [loc0] = t0, 16
        st8.nta     [loc1] = t1, 16
        ;;

        mov         t0 = ar27
        mov         t1 = ar28
        st8.nta     [loc0] = t2, 16
        st8.nta     [loc1] = t3, 16
        ;;

        mov         t2 = ar29
        mov         t3 = ar30
        st8.nta     [loc0] = t0, 16
        st8.nta     [loc1] = t1, 16
        ;;
        st8.nta     [loc0] = t2, 16
        st8.nta     [loc1] = t3, 16
#endif // !defined(NTOS_KERNEL_RUNTIME)

        mov         rbsp = ar.bsp
        add         loc2 = CxFltS0, a0
        add         loc3 = CxFltS1, a0
        ;;

//
// Save floating status and floating registers f0 - f19.
//

        stf.spill.nta [loc2] = fs0, CxFltS2 - CxFltS0
        stf.spill.nta [loc3] = fs1, CxFltS3 - CxFltS1
        shr         t0 = rpfs, 7
        ;;
         
        stf.spill.nta [loc2] = fs2, CxFltS4 - CxFltS2
        stf.spill.nta [loc3] = fs3, CxFltS5 - CxFltS3
        and         t0 = 0x7f, t0
        ;;
         

        shr         t1 = rbsp, 3
        ;;
         

        and         t1 = 0x3f, t1
        ;;
         


        sub         t2 = t0, t1
        ;;
         


        cmp4.le     pt1, pt0 = t2, zero
        ;;
         


 (pt0)  add         t2 = -1, t2
        ;;

        stf.spill.nta [loc2] = fs4, CxFltS6 - CxFltS4
        stf.spill.nta [loc3] = fs5, CxFltS7 - CxFltS5
 (pt0)  add         t0 = 1, t0
        ;;

        stf.spill.nta [loc2] = fs6, CxFltS8 - CxFltS6
        stf.spill.nta [loc3] = fs7, CxFltS9 - CxFltS7
 (pt0)  add         t2 = -63, t2
        ;;

        stf.spill.nta [loc2] = fs8, CxFltS10 - CxFltS8
        stf.spill.nta [loc3] = fs9, CxFltS11 - CxFltS9
 (pt0)  cmp4.ge.unc pt2, pt3 = t2, zero
        ;;
        
        stf.spill.nta [loc2] = fs10, CxFltS12 - CxFltS10
        stf.spill.nta [loc3] = fs11, CxFltS13 - CxFltS11

        mov         rpsr = psr.um
 (pt1)  br.cond.spnt Rcc20
        ;;

Rcc10:
 (pt2)  add         t0 = 1, t0
 (pt2)  add         t2 = -63, t2
 (pt3)  br.cond.sptk Rcc20
        ;;

        cmp4.ge     pt2, pt3 = t2, zero
        nop.m       0
        br          Rcc10
        ;;

Rcc20:
        stf.spill.nta [loc2] = fs12, CxFltS14 - CxFltS12
        stf.spill.nta [loc3] = fs13, CxFltS15 - CxFltS13
        shl         t0 = t0, 3
        ;;

        stf.spill.nta [loc2] = fs14, CxFltS16 - CxFltS14
        stf.spill.nta [loc3] = fs15, CxFltS17 - CxFltS15
        sub         rbsp = rbsp, t0
        ;;

        stf.spill.nta [loc2] = fs16, CxFltS18 - CxFltS16
        stf.spill.nta [loc3] = fs17, CxFltS19 - CxFltS17
        tbit.z      pt2, pt1 = rpsr, PSR_MFH
        ;;

        stf.spill.nta [loc2] = fs18, CxFltF32 - CxFltS18
        stf.spill.nta [loc3] = fs19, CxFltF33 - CxFltS19
        mov         flag = CONTEXT_CONTROL | CONTEXT_LOWER_FLOATING_POINT | CONTEXT_INTEGER
        ;;


//
// Save application registers, control information and set context flags.
//

        User=pt0
        Krnl=pt1
        rdcr=t1
        sol=t4
        rpsr=t5
        is=t6
        rccv=t7
        rlc=t8
        rec=t9
        rrsc=t10
        rrnat=t11
        addr0=t17
        addr1=t18
        tmp=t19

        mov         rrsc = ar.rsc
        tbit.nz     Krnl, User = sp, 62         // bit 62 is 1 when
        mov         rlc = ar.lc
        ;;

        mov         ar.rsc = r0                 // put RSE in lazy mode
        mov         rccv = ar.ccv
        mov         rec = ar.ec
        ;;                                      // in kernel

 (Krnl) mov         rpsr = psr
 (User) mov         rpsr = psr.um
        add         addr0 = CxApUNAT, a0

        mov         rrnat = ar.rnat
        add         addr1 = CxApLC, a0

 (Krnl) mov         rdcr = cr.dcr
 (Krnl) movl        tmp = 1 << PSR_BN
        ;;

        st8.nta     [addr0] = runat, CxApEC - CxApUNAT
        st8.nta     [addr1] = rlc, CxApCCV - CxApLC
 (Krnl) or          rpsr = tmp, rpsr
        ;;

        st8.nta     [addr0] = rec, CxApDCR - CxApEC
        st8.nta     [addr1] = rccv, CxRsPFS - CxApCCV
        mov         tmp = 1
        ;;

        st8.nta     [addr0] = rdcr, CxRsBSP - CxApDCR
        st8.nta     [addr1] = rpfs, CxRsBSPSTORE - CxRsPFS
        shl         tmp = tmp, 63
        ;;

        st8.nta     [addr0] = rbsp, CxRsRSC - CxRsBSP
        st8.nta     [addr1] = rbsp, CxRsRNAT - CxRsBSPSTORE
        or          rpfs = rpfs, tmp            // validate IFS
        ;;

        st8.nta     [addr0] = rrsc, CxStIIP - CxRsRSC
        st8.nta     [addr1] = rrnat, CxStIFS - CxRsRNAT
        mov         rccv = ar.csd
        ;;

        st8.nta     [addr0] = rbrp, CxStIPSR - CxStIIP
        st8.nta     [addr1] = rpfs, CxSegCSD - CxStIFS 
        add         tmp = CxContextFlags, a0
        mov         rbsp = ar.bsp
        ;;

        st8.nta     [addr0] = rpsr              // save psr
        st8.nta     [addr1] = rccv              // Save CxSegCSD
        dep          rbsp = 1, rbsp, 3, 6       // Calculate the address of the NAT collection
        ;;
        mov         ar.rsc = rrsc               // restore RSC
        st4.nta     [tmp] = flag
        st8.nta     [rbsp] = rrnat              // Save the current RNAT in NAT collection for the BSP.
                                                // This handles the case where the collection location is in 
                                                // the middle of the out registers, and never gets written, but
                                                // is read when we do a continue with this context.  

        mov         ar.unat = runat             // restore ar.unat
 (p0)   br.ret.sptk brp                         // return to caller.

        LEAF_EXIT(RtlCaptureNonVolatileContext)

//++
//
// VOID
// RtlRestoreContext (
//    IN PCONTEXT ContextRecord,
//    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
//    )
//
// Routine Description:
//
//    This function restores the context of the caller to the specified
//    context.
//
//    N.B. The context record is assumed to be 16-byte aligned.
//
//    N.B. This is a special routine that is used by RtlUnwind2 to restore
//       context in the current mode.
//
//    N.B. RFI is used to resume execution in kernel mode.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies the address of a context record.
//
//    ExceptionRecord (a1) - Supplies an optional pointer to an exception
//       record.
//
// Return Value:
//
//    None.
//
//    N.B. There is no return from this routine.
//
//--

        NESTED_ENTRY(RtlRestoreContext)

        dest1=t8
        dest2=t9
        rlc=t10
        rpreds=t11
        rbrp=t12
        rbsp=t13
        rpfs=t14
        runat=t15
        rpreds=t16
        rsp=t17
        rfpsr=t18
        jb=t19
        tmp=t20
        src1=t21
        src2=t22

        NESTED_SETUP(2, 13, 2, 0)

        cmp.eq      pt1, p0 = zero, a1

        PROLOGUE_END

//
// If an exception record is specified and the exception status is the unwind
// consolidation code and there is at least one parameter, then consolidate
// all the frames that have been unwound and call back to a language specified
// routine.
//

        add         t1 = ErNumberParameters, a1
 (pt1)  br.cond.sptk.few Rrc10
        ;;

        ld4         t0 = [t1], ErExceptionCode - ErNumberParameters
        movl        t3 = STATUS_UNWIND_CONSOLIDATE
        ;;

        cmp4.ne     pt1, p0 = 0, t0
        ld4         t2 = [t1], ErExceptionInformation - ErExceptionCode
        ;;

        cmp4.eq.and pt1, p0 = t3, t2            // if ne, not a long jump
        movl        t4 = STATUS_LONGJUMP        
        ;;
        
        ld8         jb = [t1]                   // get address of jump buffer
        add         loc2 = -STACK_SCRATCH_AREA, r32  // Create a vframe for context record.
(pt1)   br.cond.dptk.many  RtlRcConsolidateFrames

//
// If exception status is STATUS_LONGJUMP, then restore the 
// nonvolatile registers to their state at the call to setjmp 
// before restoring the context record.
//

        cmp4.ne     pt1, p0 = t4, t2            // if ne, not a long jump
 (pt1)  br.cond.sptk.few Rrc10
        ;;

//
// restore unat, non-volatile general and branch registers from 
// jump buffer and then save them in the context buffer.
//

        add         src1 = JbIntS0, jb
        add         src2 = JbIntS1, jb
        nop.i       0
        ;;

        ld8.nt1     s0 = [src1], JbIntS2 - JbIntS0
        ld8.nt1     s1 = [src2], JbIntS3 - JbIntS1
        nop.i       0
        ;;

        ld8.nt1     s2 = [src1], JbIntSp - JbIntS2
        ld8.nt1     s3 = [src2], JbIntNats - JbIntS3
        nop.i       0
        ;;

        ld8.nt1     rsp = [src1], JbPreds - JbIntSp
        ld8.nt1     t2 = [src2]
        add         t1 = 0x10f0, r0
        ;;

        ld8.nt1     rpreds = [src1]
        add         loc11 = CxIntNats, a0
        and         t2 = t2, t1
        ;;

        ld8         runat = [loc11]
        add         dest1 = CxIntS0, a0
        add         dest2 = CxIntS1, a0
        ;;

        st8         [dest1] = s0, CxIntS2 - CxIntS0
        st8         [dest2] = s1, CxIntS3 - CxIntS1
        nop.b       0
        ;;

        st8         [dest1] = s2, CxIntSp - CxIntS2
        st8         [dest2] = s3, CxPreds - CxIntS3
        andcm       runat = runat, t1
        ;;

        st8         [dest1] = rsp
        st8         [dest2] = rpreds
        or          runat = runat, t2
        ;;

        st8         [loc11] = runat
        add         src1 = JbFltS0, jb
        add         src2 = JbFltS1, jb
        ;;

        ldf.fill.nt1  fs0 = [src1], JbFltS2 - JbFltS0
        ldf.fill.nt1  fs1 = [src2], JbFltS3 - JbFltS1
        nop.i       0
        ;;

        ldf.fill.nt1  fs2 = [src1], JbFltS4 - JbFltS2
        ldf.fill.nt1  fs3 = [src2], JbFltS5 - JbFltS3
        nop.i       0
        ;;

        ldf.fill.nt1  fs4 = [src1], JbFltS6 - JbFltS4
        ldf.fill.nt1  fs5 = [src2], JbFltS7 - JbFltS5
        nop.i       0
        ;;

        ldf.fill.nt1  fs6 = [src1], JbFltS8 - JbFltS6
        ldf.fill.nt1  fs7 = [src2], JbFltS9 - JbFltS7
        nop.i       0
        ;;

        ldf.fill.nt1  fs8 = [src1], JbFltS10 - JbFltS8
        ldf.fill.nt1  fs9 = [src2], JbFltS11 - JbFltS9
        nop.i       0
        ;;

        ldf.fill.nt1  fs10 = [src1], JbFltS12 - JbFltS10
        ldf.fill.nt1  fs11 = [src2], JbFltS13 - JbFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], JbFltS14 - JbFltS12
        ldf.fill.nt1  fs13 = [src2], JbFltS15 - JbFltS13
        nop.i       0
        ;;

        ldf.fill.nt1  fs14 = [src1], JbFltS16 - JbFltS14
        ldf.fill.nt1  fs15 = [src2], JbFltS17 - JbFltS15
        nop.i       0
        ;;

        ldf.fill.nt1  fs16 = [src1], JbFltS18 - JbFltS16
        ldf.fill.nt1  fs17 = [src2], JbFltS19 - JbFltS17
        nop.i       0
        ;;

        ldf.fill.nt1  fs18 = [src1], JbFPSR - JbFltS18
        ldf.fill.nt1  fs19 = [src2]
        nop.i       0
        ;;

        ld8.nt1     rfpsr = [src1]
        add         dest1 = CxFltS0, a0
        add         dest2 = CxFltS1, a0
        ;;

        stf.spill   [dest1] = fs0, CxFltS2 - CxFltS0
        stf.spill   [dest2] = fs1, CxFltS3 - CxFltS1
        nop.i       0
        ;;

        stf.spill   [dest1] = fs2, CxFltS4 - CxFltS2
        stf.spill   [dest2] = fs3, CxFltS5 - CxFltS3
        nop.i       0
        ;;

        stf.spill   [dest1] = fs4, CxFltS6 - CxFltS4
        stf.spill   [dest2] = fs5, CxFltS7 - CxFltS5
        nop.i       0
        ;;

        stf.spill   [dest1] = fs6, CxFltS8 - CxFltS6
        stf.spill   [dest2] = fs7, CxFltS9 - CxFltS7
        nop.i       0
        ;;

        stf.spill   [dest1] = fs8, CxFltS10 - CxFltS8
        stf.spill   [dest2] = fs9, CxFltS11 - CxFltS9
        nop.i       0
        ;;

        stf.spill   [dest1] = fs10, CxFltS12 - CxFltS10
        stf.spill   [dest2] = fs11, CxFltS13 - CxFltS11
        nop.i       0
        ;;

        stf.spill   [dest1] = fs12, CxFltS14 - CxFltS12
        stf.spill   [dest2] = fs13, CxFltS15 - CxFltS13
        nop.i       0
        ;;

        stf.spill   [dest1] = fs14, CxFltS16 - CxFltS14
        stf.spill   [dest2] = fs15, CxFltS17 - CxFltS15
        nop.i       0
        ;;

        stf.spill   [dest1] = fs16, CxFltS18 - CxFltS16
        stf.spill   [dest2] = fs17, CxFltS19 - CxFltS17
        nop.i       0
        ;;

        stf.spill   [dest1] = fs18
        stf.spill   [dest2] = fs19
        add         dest1 = CxStFPSR, a0
        ;;

        st8         [dest1] = rfpsr
        add         src1 = JbStIIP, jb
        add         src2 = JbBrS0, jb
        ;;

        ld8.nt1     loc11 = [src1], JbBrS1 - JbStIIP
        ld8.nt1     loc12 = [src2], JbBrS2 - JbBrS0
        ;;

        ld8.nt1     loc2 = [src1], JbBrS3 - JbBrS1
        ld8.nt1     loc3 = [src2], JbBrS4 - JbBrS2
        ;;

        ld8.nt1     loc4 = [src1], JbRsBSP - JbBrS3
        ld8.nt1     loc5 = [src2], JbRsPFS - JbBrS4
        ;;

        ld8.nt1     rbsp = [src1], JbApUNAT - JbRsBSP
        ld8.nt1     rpfs = [src2], JbApLC - JbRsPFS
        ;;

        ld8.nt1     runat = [src1]
        add         dest1 = CxStIIP, a0
        add         dest2 = CxBrS0, a0

        ld8.nt1     rlc = [src2]
        movl        t0 = 1 << IFS_V
        ;;

        st8         [dest1] = loc11, CxBrS1 - CxStIIP
        st8         [dest2] = loc12, CxBrS2 - CxBrS0
        or          rpfs = t0, rpfs                 // validate the ifs
        ;;

        st8         [dest1] = loc2, CxBrS3 - CxBrS1
        st8         [dest2] = loc3, CxBrS4 - CxBrS2
        ;;

        st8         [dest1] = loc4, CxApUNAT - CxBrS3
        st8         [dest2] = loc5, CxStIFS - CxBrS4
        ;;

        st8         [dest1] = runat, CxRsBSP - CxApUNAT
        st8         [dest2] = rpfs, CxApLC - CxStIFS
        ;;

        st8         [dest2] = rlc
        st8         [dest1] = rbsp
        ;;

//
// If the call is from user mode, then use the continue system service to
// continue execution. Otherwise, restore the context directly since the
// current mode is kernel and threads can't be arbitrarily interrupted.
//

Rrc10:

#ifndef NTOS_KERNEL_RUNTIME

        mov         out0 = a0
        mov         out1 = zero
        br.call.sptk.few brp = ZwContinue

#else

//
// Kernel mode; simply restore the registers and rfi
//

        add         src1 = CxIntNats, a0
        add         src2 = CxPreds, a0
        add         tmp = CxIntGp, a0
        ;;

        ld8.nt1     t17 = [src1], CxBrRp - CxIntNats
        ld8.nt1     t16 = [src2], CxBrS0 - CxPreds
        shr         tmp = tmp, 3
        ;;

        ld8.nt1     t0 = [src1], CxBrS1 - CxBrRp
        ld8.nt1     t1 = [src2], CxBrS2 - CxBrS0
        and         tmp = 0x3f, tmp
        ;;

        ld8.nt1     t2 = [src1], CxBrS3 - CxBrS1
        ld8.nt1     t3 = [src2], CxBrS4 - CxBrS2
        cmp4.ge     pt1, pt0 = 1, tmp
        ;;

        ld8.nt1     t4 = [src1], CxBrT0 - CxBrS3
        ld8.nt1     t5 = [src2], CxBrT1 - CxBrS4
 (pt1)  sub         loc5 = 1, tmp
        ;;

        ld8.nt1     t6 = [src1], CxApUNAT - CxBrT0
        ld8.nt1     t7 = [src2], CxApLC - CxBrT1
 (pt0)  add         loc5 = -1, tmp
        ;;

        ld8.nt1     loc11 = [src1], CxApEC - CxApUNAT
        ld8.nt1     t8 = [src2], CxApCCV - CxApLC
 (pt0)  sub         loc6 = 65, tmp
        ;; 

        ld8.nt1     t9 = [src1], CxApDCR - CxApEC
        ld8.nt1     t10 = [src2], CxRsPFS - CxApCCV
 (pt1)  shr.u       t17 = t17, loc5
        ;;

        ld8.nt1     loc12 = [src1], CxRsBSP - CxApDCR
        ld8.nt1     t11 = [src2], CxRsRSC - CxRsPFS
 (pt0)  shl         loc7 = t17, loc5
        ;;

        ld8.nt1     loc2 = [src1], CxStIIP - CxRsBSP
        ld8.nt1     loc3 = [src2], CxStIFS - CxRsRSC
 (pt0)  shr.u       loc8 = t17, loc6
        ;;

        ld8.nt1     loc9 = [src1], CxSegCSD - CxStIIP
        ld8.nt1     loc10 = [src2]
 (pt0)  or          t17 = loc7, loc8
        ;;

        mov         ar.unat = t17
        ld8.nt1     t17 = [src1]
        shr         t12 = loc2, 3
        ;;

        add         src1 = CxFltS0, a0
        add         src2 = CxFltS1, a0
        and         t12 = 0x3f, t12             // current rnat save index
        and         t13 = 0x7f, loc10           // total frame size
        ;;

        mov         ar.ccv = t10
        mov         ar.csd = t17
        add         t14 = t13, t12
        mov         ar.pfs = t11
        ;;

Rrc20:
        cmp4.gt     pt1, pt0 = 63, t14
        ;;
 (pt0)  add         t14 = -63, t14
 (pt0)  add         t13 = 1, t13
        ;;

        nop.m       0
 (pt1)  shl         t13 = t13, 3
 (pt0)  br.cond.spnt Rrc20
        ;;

        add         loc2 = loc2, t13
        nop.f       0
        mov         pr = t16, -1

        ldf.fill.nt1  fs0 = [src1], CxFltS2 - CxFltS0
        ldf.fill.nt1  fs1 = [src2], CxFltS3 - CxFltS1
        mov         brp = t0
        ;;
         
        ldf.fill.nt1  fs2 = [src1], CxFltT0 - CxFltS2
        ldf.fill.nt1  fs3 = [src2], CxFltT1 - CxFltS3
        mov         bs0 = t1
        ;;
        
        ldf.fill.nt1  ft0 = [src1], CxFltT2 - CxFltT0
        ldf.fill.nt1  ft1 = [src2], CxFltT3 - CxFltT1
        mov         bs1 = t2
        ;;
        
        ldf.fill.nt1  ft2 = [src1], CxFltT4 - CxFltT2
        ldf.fill.nt1  ft3 = [src2], CxFltT5 - CxFltT3
        mov         bs2 = t3
        ;;
        
        ldf.fill.nt1  ft4 = [src1], CxFltT6 - CxFltT4
        ldf.fill.nt1  ft5 = [src2], CxFltT7 - CxFltT5
        mov         bs3 = t4
        ;;
        
        ldf.fill.nt1  ft6 = [src1], CxFltT8 - CxFltT6
        ldf.fill.nt1  ft7 = [src2], CxFltT9 - CxFltT7
        mov         bs4 = t5
        ;;
        
        ldf.fill.nt1  ft8 = [src1], CxFltS4 - CxFltT8
        ldf.fill.nt1  ft9 = [src2], CxFltS5 - CxFltT9
        mov         bt0 = t6
        ;;

        ldf.fill.nt1  fs4 = [src1], CxFltS6 - CxFltS4
        ldf.fill.nt1  fs5 = [src2], CxFltS7 - CxFltS5
        mov         bt1 = t7
        ;;

        ldf.fill.nt1  fs6 = [src1], CxFltS8 - CxFltS6
        ldf.fill.nt1  fs7 = [src2], CxFltS9 - CxFltS7
        mov         ar.lc = t8
        ;;

        ldf.fill.nt1  fs8 = [src1], CxFltS10 - CxFltS8
        ldf.fill.nt1  fs9 = [src2], CxFltS11 - CxFltS9
        mov         ar.ec = t9
        ;;

        ldf.fill.nt1  fs10 = [src1], CxFltS12 - CxFltS10
        ldf.fill.nt1  fs11 = [src2], CxFltS13 - CxFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], CxFltS14 - CxFltS12
        ldf.fill.nt1  fs13 = [src2], CxFltS15 - CxFltS13
        add         loc6 = CxIntGp, a0
        ;;

        ldf.fill.nt1  fs14 = [src1], CxFltS16 - CxFltS14
        ldf.fill.nt1  fs15 = [src2], CxFltS17 - CxFltS15
        add         loc7 = CxIntT0, a0
        ;;

        ldf.fill.nt1  fs16 = [src1], CxFltS18 - CxFltS16
        ldf.fill.nt1  fs17 = [src2], CxFltS19 - CxFltS17
        add         t19 = CxRsRNAT, a0
        ;;

        ldf.fill.nt1  fs18 = [src1]
        ldf.fill.nt1  fs19 = [src2]
        add         t7 = CxStFPSR, a0
        ;;

        ld8.nt1     loc8 = [t7]                 // load fpsr from context
        ld8.nt1     loc5 = [t19]                // load rnat from context
        nop.i       0

        ld8.fill.nt1 gp = [loc6], CxIntT1 - CxIntGp
        ld8.fill.nt1 t0 = [loc7], CxIntS0 - CxIntT0
        ;;

        ld8.fill.nt1 t1 = [loc6], CxIntS1 - CxIntT1
        ld8.fill.nt1 s0 = [loc7], CxIntS2 - CxIntS0
        ;;

        ld8.fill.nt1 s1 = [loc6], CxIntS3 - CxIntS1
        ld8.fill.nt1 s2 = [loc7], CxIntV0 - CxIntS2
        ;;

        ld8.fill.nt1 s3 = [loc6], CxIntTeb - CxIntS3
        ld8.fill.nt1 v0 = [loc7], CxIntT2 - CxIntV0
        ;;

        ld8.fill.nt1 teb = [loc6], CxIntT3 - CxIntTeb
        ld8.fill.nt1 t2 = [loc7], CxIntSp - CxIntT2
        ;;

        ld8.fill.nt1 t3 = [loc6], CxIntT4 - CxIntT3
        ld8.fill.nt1 loc4 = [loc7], CxIntT5 - CxIntSp
        ;;

        ld8.fill.nt1 t4 = [loc6], CxIntT6 - CxIntT4
        ld8.fill.nt1 t5 = [loc7], CxIntT7 - CxIntT5
        ;;

        ld8.fill.nt1 t6 = [loc6], CxIntT8 - CxIntT6
        ld8.fill.nt1 t7 = [loc7], CxIntT9 - CxIntT7
        ;;

        ld8.fill.nt1 t8 = [loc6], CxIntT10 - CxIntT8
        ld8.fill.nt1 t9 = [loc7], CxIntT11 - CxIntT9
        ;;

        ld8.fill.nt1 t10 = [loc6], CxIntT12 - CxIntT10
        ld8.fill.nt1 t11 = [loc7], CxIntT13 - CxIntT11
        ;;

        ld8.fill.nt1 t12 = [loc6], CxIntT14 - CxIntT12
        ld8.fill.nt1 t13 = [loc7], CxIntT15 - CxIntT13
        ;;

        ld8.fill.nt1 t14 = [loc6], CxIntT16 - CxIntT14
        ld8.fill.nt1 t15 = [loc7], CxIntT17 - CxIntT15
        ;;

        ld8.fill.nt1 t16 = [loc6], CxIntT18 - CxIntT16
        ld8.fill.nt1 t17 = [loc7], CxIntT19 - CxIntT17
        ;;

        ld8.fill.nt1 t18 = [loc6], CxIntT20 - CxIntT18
        ld8.fill.nt1 t19 = [loc7], CxIntT21 - CxIntT19
        ;;

        ld8.fill.nt1 t20 = [loc6], CxIntT22 - CxIntT20
        ld8.fill.nt1 t21 = [loc7]
        ;;

        rsm         1 << PSR_I
        ld8.fill.nt1 t22 = [loc6] 
        ;;

        bsw.0
        ;;

        add         r20 = CxStIPSR, a0
        ;;

        ld8.nt1     r20 = [r20]                  // load IPSR
        movl        r23 = 1 << IFS_V
        ;;

        mov         ar.fpsr = loc8              // set fpsr
        mov         ar.unat = loc11
        ;;

        or          r21 = r23, loc10            // set ifs valid bit
        ;;

        mov         cr.dcr = loc12
        mov         r17 = loc2                  // put BSP in a shadow reg
        or          r16 = 0x3, loc3             // put RSE in eager mode

        mov         ar.rsc = r0                 // put RSE in enforced lazy
        mov         r22 = loc9                  // put iip in a shadow reg
        dep         r21 = 0, r21, IFS_MBZ0, IFS_V-IFS_MBZ0
        ;;

        mov         r18 = loc4                  // put SP in a shadow reg
        mov         r19 = loc5                  // put RNaTs in a shadow reg
        ;;

        alloc       r23 = 0, 0, 0, 0
        mov         sp = r18
        ;;

        loadrs
        ;;

        rsm         1 << PSR_IC
        ;;
        srlz.d
        ;;

        mov         cr.iip = r22
        mov         cr.ifs = r21

        ;;
        mov         ar.bspstore = r17
        mov         cr.ipsr = r20
        nop.i       0
        ;;

        mov         ar.rnat = r19               // set rnat register
        mov         ar.rsc = r16                // restore RSC
        ;;

        invala
        nop.i       0
        rfi
        ;;

#endif // NTOS_KERNEL_RUNTIME

        LEAF_EXIT(RtlRestoreContext)

//++
//
// VOID
// RtlpFlushRSE (
//    OUT PULONGLONG Bsp,
//    OUT PULONGLONG Rnat
//    )
//
// Routine Description:
//
//    This function flushes the RSE, then captures the values of bsp 
//    and rnat into the input buffers.
//
// Arguments:
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlpFlushRSE)

        flushrs
        mov       t2 = ar.rsc
        ;;

        mov       t0 = ar.bsp
        mov       ar.rsc = r0               // put RSE in lazy mode
        ;;

        st8       [a0] = t0
        mov       t1 = ar.rnat
        nop.i     0
        ;;

        st8       [a1] = t1
        mov       ar.rsc = t2
        ;;
        br.ret.sptk brp

        LEAF_EXIT(RtlpFlushRSE)
        
//++
//
// VOID
// RtlRcConsolidateFrames (
//     IN PCONTEXT ContextRecord
//     IN PEXCEPTION_RECORD ExceptionRecord
//     )
//
// Routine Description:
//
//   This routine is called at the end of a  unwind operation to logically
//   remove unwound frames from the stack. This is accomplished by specifing
//   the variable frame pointer and a context ABI unwind.
//
//   The following code calls the language call back function specified in the
//   exception record. If the function returns, then the destination frame
//   context is restored and control transfered to the address returned by the
//   language call back function. If control does not return, then another
//   exception must be raised.
//
// Arguments:
//
//   ContextRecord - Supplies a pointer to the context record.
//
//   ExceptionRecord - Supplies a pointer to an exception record.
//
// Implicit Arguments:
//
//   Virtual frame pointer (r34) - Supplies a pointer to the context record minus the stack area.
//
//   LanguageSpecificHandler (jb) - Supplies a pointer to the language specific handler
//
// Return Value:
//
//   None.
//
//--

        .global RtlRcConsolidateFrames;
        .proc   RtlRcConsolidateFrames;

RtlRcConsolidateFrames::        
        .prologue
        .unwabi  @nt,  CONTEXT_FRAME

        .regstk   2, 13, 2, 0
        .vframe   loc2                  // Specify that r32 content the saved sp
        
        PROLOGUE_END
        
        ld8       t3 = [jb], 8
        add       loc3 = CxStIIP, a0
        ;;
        ld8       gp = [jb]
        mov       bt0 = t3
        ;;
        mov       out0 = a1             // Pass exception record as argument.
        br.call.sptk brp = bt0
        ;;
//
// The language specific handler retuns the address where control
// should be returned using the passed context. Update the context                      
// record with the new address.
//

        st8       [loc3] = r8   
        br.cond.sptk  Rrc10
        ;;
        
        LEAF_EXIT(RtlRcConsolidateFrames)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\i386\userdisp.asm ===
title  "User Mode Dispatcher Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    userdisp.asm
;
; Abstract:
;
;    The module contains procedures to do user mode dispatching
;    ("trampolining") of user apcs and user exceptions.
;
; Author:
;
;    Bryan M Willman (bryanwi) 31-Aug-90
;
; Environment:
;
;    User mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _ZwCallbackReturn,3
        EXTRNP  _ZwContinue,2
        EXTRNP  _RtlDispatchException,2
        EXTRNP  _RtlRaiseStatus,1
        EXTRNP  _ZwRaiseException,3
        EXTRNP  _RtlRaiseException,1
;
; Exception record size definition.
;

ExceptionRecordSize = (ErNumberParameters + 4 + 3) AND 0fffffffcH ;

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "User APC Dispatcher"
;++
;
; VOID
; KiUserApcDispatcher (
;    IN PKNORMAL_ROUTINE NormalRoutine,
;    IN PVOID NormalContext,
;    IN PVOID SystemArgument1,
;    IN PVOID SystemArgument2,
;    IN CONTEXT ContinueContext
;    )
;
; Routine Description:
;
;    This routine is entered on return from kernel mode to deliver an APC
;    in user mode. The context frame for this routine was built when the
;    APC interrupt was processed and contains the entire machine state of
;    the current thread. The specified APC routine is called and then the
;    machine state is restored and execution is continued.
;
; Arguments:
;
;    NormalRoutine - Supplies that address of the function that is to be called.
;
;    NormalContext] - Supplies the normal context parameter that was specified
;       when the APC was initialized.
;
;    SystemArgument1 - Supplies the first argument that was provied by the
;       executive when the APC was queued.
;
;    SystemArgument2 - Supplies the second argument that was provided by
;       the executive when the APC was queued.
;
;    ContinueContext - Context record to pass to Continue call.
;
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KiUserApcDispatcher ,5

        lea     edi, [esp+16]           ; (edi)->context frame
        pop     eax                     ; (eax)->specified function
        call    eax                     ; call the specified function

; 1 - set alert argument true
; ebp - addr of context frame
; execute system service to continue
        stdCall   _ZwContinue, <edi, 1>

stdENDP _KiUserApcDispatcher


        page
        subttl  "User Callback Dispatcher"
;++
;
; VOID
; KiUserCallbackDispatcher (
;    IN ULONG ApiNumber,
;    IN PVOID InputBuffer,
;    IN ULONG INputLength
;    )
;
; Routine Description:
;
;    This routine is entered on a callout from kernel mode to execute a
;    user mode callback function. All arguments for this function have
;    been placed on the stack.
;
; Arguments:
;
;    ApiNumber - Supplies the API number of the callback function that is
;        executed.
;
;    InputBuffer - Supplies a pointer to the input buffer.
;
;    InputLength - Supplies the input buffer length.
;
; Return Value:
;
;    This function returns to kernel mode.
;
;--
cPublicProc _KiUserCallbackDispatcher, 3
.FPO (0, 0, 0, 0, 0, 0)

        add     esp,4                   ; skip over return address
        pop     edx                     ; get address of callback function

                                        ; get peb pointer from teb
        mov     eax,fs:[PcTeb]
        mov     eax,[eax].TebPeb
        mov     eax,[eax].PebKernelCallbackTable    ; get address of callback table

        call    [eax+edx*4]             ; call specified function

;
; If a return from the callback function occurs, then the output buffer
; address and length are returned as NULL.
;

        xor     ecx,ecx                 ; clear output buffer address
ifdef BUILD_WOW6432
        stdCall _ZwCallbackReturn, <ecx, ecx, eax>
else
        xor     edx,edx                 ; clear output buffer length
        int     02bH                    ; return from callback
endif
        int     3                       ; break if return occurs

stdENDP _KiUserCallbackDispatcher

        page
        subttl  "User Exception Dispatcher"
;++
;
; VOID
; KiUserExceptionDispatcher (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PCONTEXT ContextRecord
;    )
;
; Routine Description:
;
;    This routine is entered on return from kernel mode to dispatch a user
;    mode exception. If a frame based handler handles the exception, then
;    the execution is continued. Else last chance processing is performed.
;
;    NOTE:  This procedure is not called, but rather dispatched to.
;           It depends on there not being a return address on the stack
;           (assumption w.r.t. argument offsets.)
;
; Arguments:
;
;    ExceptionRecord (esp+0) - Supplies a pointer to an exception record.
;
;    ContextRecord (esp+4) - Supplies a pointer to a context frame.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiUserExceptionDispatcher      ,2
.FPO (0, 2, 0, 0, 0, 0)

        mov     ecx, [esp+4]            ; (ecx)->context record
        mov     ebx, [esp]              ; (ebx)->exception record

; attempt to dispatch the exception
        stdCall   _RtlDispatchException, <ebx, ecx>

;
; If the return status is TRUE, then the exception was handled and execution
; should be continued with the NtContinue service in case the context was
; changed. If the return statusn is FALSE, then the exception was not handled
; and ZwRaiseException is called to perform last chance exception processing.
;

        or      al,al
        je      short kued10

;
; Continue execution.
;
        pop     ebx                     ; (ebx)->exception record
        pop     ecx                     ; (ecx)->context record

; continue execution
        stdCall   _ZwContinue, <ecx, 0>
        jmp     short kued20            ; join common code

;
; Last chance processing.
;
;   (esp+0) = ExceptionRecord
;   (esp+4) = ContextRecord
;

kued10: pop     ebx                     ; (ebx)->exception record
        pop     ecx                     ; (ecx)->context record

; ecx - context record
; ebx - exception record
; perform last chance processiong
        stdCall   _ZwRaiseException, <ebx, ecx, 0>

;
; Common code for nonsuccessful completion of the continue or raiseexception
; services. Use the return status as the exception code, set noncontinuable
; exception and attempt to raise another exception. Note the stack grows
; and eventually this loop will end.
;

.FPO(0, 0, 0, 0, 0, 0)

kued20: add     esp, -ExceptionRecordSize ; allocate stack space
        mov     [esp]+ErExceptionCode, eax ; set exception code
        mov     dword ptr [esp]+ErExceptionFlags, EXCEPTION_NONCONTINUABLE
        mov     [esp]+ErExceptionRecord,ebx ; set associated exception record
        mov     dword ptr [esp]+ErNumberParameters, 0
                                        ; set number of parameters
; esp - addr of exception record
        stdCall   _RtlRaiseException, <esp>
; never return
        stdRET    _KiUserExceptionDispatcher

stdENDP _KiUserExceptionDispatcher

        page
        subttl  "Raise User Exception Dispatcher"
;++
;
; NTSTATUS
; KiUserExceptionDispatcher (
;    IN PVOID ReturnAddress
;    IN NTSTATUS ExceptionCode
;    )
;
; Routine Description:
;
;    This routine is entered on return from kernel mode to raise a user
;    mode exception.
;
;    NOTE:  This procedure is not called, but rather dispatched to.
;
;    The exception code to be raised is passed in the TEB.
;
; Arguments:
;
;    ExceptionCode (TEB->ExceptionCode) - Supplies the exception code to be raised
;
; Return Value:
;
;    The exception code that was raised.
;
;--

cPublicProc _KiRaiseUserExceptionDispatcher

        push    ebp                     ; make the debugger happy
        mov     ebp, esp
        sub     esp, ExceptionRecordLength      ; allocate exception record
        mov     [esp].ErExceptionAddress, eax   ; set exception address
        mov     eax,fs:[PcTeb]                  ; get exception code to be raised
        mov     eax,[eax].TbExceptionCode       ;
        mov     [esp].ErExceptionCode, eax      ; store exception code
        mov     [esp].ErExceptionFlags, 0       ; set exception flags
        mov     [esp].ErExceptionRecord, 0      ; set exception record
        mov     [esp].ErNumberParameters, 0     ; set number of parameters
; raise the exception
        stdCall   _RtlRaiseException, <esp>
        mov     eax, [esp].ErExceptionCode
        mov     esp,ebp
        pop     ebp                     ; restore return code
        ret

stdENDP _KiRaiseUserExceptionDispatcher

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\chandler.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation
Copyright (c) 1990-2001, Microsoft Corporation

Module Name:

    chandler.c

Abstract:

    This module implements the C specific exception handler that provides
    structured condition handling for the C language.

Author:

    William K. Cheung (wcheung) 29-Dec-1995

    Based on the version by David N. Cutler (davec) 11-Sep-1990

Environment:

    Any mode.

Revision History:

--*/

#ifndef _IA64_
#define _IA64_
#endif

#include "nt.h"
#include <excpt.h>


//
// Define procedure prototypes for exception filter and termination handler
// execution routines defined in jmpunwnd.s
//

VOID _NLG_Notify (
    IN PVOID uoffDestination,
    IN FRAME_POINTERS uoffFramePointer,
    IN ULONG dwCode
);

LONG
__C_ExecuteExceptionFilter (
    ULONGLONG MemoryStack,
    ULONGLONG BackingStore,
    NTSTATUS ExceptionCode,
    PEXCEPTION_POINTERS ExceptionPointers,
    ULONGLONG ExceptionFilter,
    ULONGLONG GlobalPointer
    );

VOID
__C_ExecuteTerminationHandler (
    ULONGLONG MemoryStack,
    ULONGLONG BackingStore,
    BOOLEAN AbnormalTermination,
    ULONGLONG TerminationHandler,
    ULONGLONG GlobalPointer
    );

EXCEPTION_DISPOSITION
__C_specific_handler (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONGLONG MemoryStackFp,
    IN ULONGLONG BackingStoreFp,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN ULONGLONG TargetGp
    )

/*++

Routine Description:

    This function scans the scope tables associated with the specified
    procedure and calls exception and termination handlers as necessary.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    MemoryStackFp - Supplies a pointer to memory stack frame of the
        establisher function.

    BackingStoreFp - Supplies a pointer to RSE stack frame of the
        establisher function.

    ContextRecord - Supplies a pointer to a context record.

    DispatcherContext - Supplies a pointer to the exception dispatcher or
        unwind dispatcher context.

    TargetGp - Global pointer of the current module.

Return Value:

    If the exception is handled by one of the exception filter routines, then
    there is no return from this routine and RtlUnwind is called. Otherwise,
    an exception disposition value of continue execution or continue search is
    returned.

--*/

{
    ULONGLONG ImageBase;
    ULONGLONG ControlPc;
    ULONGLONG TargetPc;
    ULONGLONG Handler;
    ULONG TargetHandler;
    LONG Value;
    EXCEPTION_POINTERS ExceptionPointers;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG Index;
    PSCOPE_TABLE ScopeTable;
    FRAME_POINTERS EstablisherFrame = { MemoryStackFp, BackingStoreFp };


    //
    // Get address of where control left the establisher, the address of the
    // function table entry that describes the function, and the address of
    // the scope table.
    //

    FunctionEntry = DispatcherContext->FunctionEntry;
    ImageBase = DispatcherContext->ImageBase;
    ScopeTable = (PSCOPE_TABLE) (ImageBase + *(PULONG) 
                     GetLanguageSpecificData(FunctionEntry, ImageBase));

    ControlPc = DispatcherContext->ControlPc - ImageBase;

    //
    // If an unwind is not in progress, then scan the scope table and call
    // the appropriate exception filter routines. Otherwise, scan the scope
    // table and call the appropriate termination handlers using the target
    // PC obtained from the context record.
    // are called.
    //

    if (IS_DISPATCHING(ExceptionRecord->ExceptionFlags)) {

        //
        // Scan the scope table and call the appropriate exception filter
        // routines.
        //

        ExceptionPointers.ExceptionRecord = ExceptionRecord;
        ExceptionPointers.ContextRecord = ContextRecord;
        for (Index = 0; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress) &&
                (ScopeTable->ScopeRecord[Index].JumpTarget != 0)) {

                //
                // Call the exception filter routine.
                //

                ULONG Offset = ScopeTable->ScopeRecord[Index].HandlerAddress;

                switch (Offset & 0x7) {

                case 7:
                    Value = EXCEPTION_EXECUTE_HANDLER;
                    break;

                case 5:
                    Value = EXCEPTION_CONTINUE_SEARCH;
                    break;

                case 3:
                    Value = EXCEPTION_CONTINUE_EXECUTION;
                    break;

                default:
                    Value = __C_ExecuteExceptionFilter(
                                MemoryStackFp,
                                BackingStoreFp,
                                ExceptionRecord->ExceptionCode,
                                &ExceptionPointers,
                                (ImageBase + Offset),
                                TargetGp);
                    break;
                }


                //
                // If the return value is less than zero, then dismiss the
                // exception. Otherwise, if the value is greater than zero,
                // then unwind to the target exception handler. Otherwise,
                // continue the search for an exception filter.
                //

                if (Value < 0) {
                    return ExceptionContinueExecution;

                } else if (Value > 0) {

                    //
                    // Tell the debugger we are about to pass control to an 
                    // exception handler and pass the handler's address to
                    // NLG_Notify.
                    //

                    Handler = ImageBase + ScopeTable->ScopeRecord[Index].JumpTarget;

                    _NLG_Notify((PVOID)Handler, EstablisherFrame, 0x1);

                    RtlUnwindEx(EstablisherFrame,
                                (PVOID)Handler,
                                ExceptionRecord,
                                (PVOID)((ULONG64)ExceptionRecord->ExceptionCode),
                                DispatcherContext->ContextRecord,
                                DispatcherContext->HistoryTable);
                }
            }
        }

    } else {

        //
        // Scan the scope table and call the appropriate termination handler
        // routines.
        //

        PUNWIND_INFO Unw;

        Unw = (PUNWIND_INFO)(FunctionEntry->UnwindInfoAddress + ImageBase);
        TargetPc = ContextRecord->StIIP - ImageBase;

        TargetHandler = 0;
        if (Unw->Flags & 0x1000) {
            for (Index = 0; Index < ScopeTable->Count; Index += 1) {
                if ((TargetPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                   (TargetPc < ScopeTable->ScopeRecord[Index].EndAddress)) 
                {
                    TargetHandler = ScopeTable->ScopeRecord[Index].HandlerAddress;
                    break;
                }
            }
        }
        

        for (Index = DispatcherContext->Index; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress)) {

                //
                // If the target PC is within the same scope the control PC
                // is within, then this is an uplevel goto out of an inner try
                // scope or a long jump back into a try scope. Terminate the
                // scan termination handlers.
                //
                // N.B. The target PC can be just beyond the end of the scope,
                //      in which case it is a leave from the scope.
                //


                if ((TargetPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                   (TargetPc < ScopeTable->ScopeRecord[Index].EndAddress)) {
                    break;

                } else {

                    //
                    // If the scope table entry describes an exception filter
                    // and the associated exception handler is the target of
                    // the unwind, then terminate the scan for termination
                    // handlers. Otherwise, if the scope table entry describes
                    // a termination handler, then record the address of the
                    // end of the scope as the new control PC address and call
                    // the termination handler.
                    //

                    if (ScopeTable->ScopeRecord[Index].JumpTarget != 0) {
                        if (TargetPc == ScopeTable->ScopeRecord[Index].JumpTarget) {
                            break;
                        }

                    } else {

                        if (TargetHandler == ScopeTable->ScopeRecord[Index].HandlerAddress) {
                            break;
                        }


                        DispatcherContext->Index = Index + 1;

                        Handler = ImageBase + ScopeTable->ScopeRecord[Index].HandlerAddress;
                        __C_ExecuteTerminationHandler(
                            MemoryStackFp,
                            BackingStoreFp,
                            TRUE,
                            Handler,
                            TargetGp);
                    }
                }
            }
        }
    }

    //
    // Continue search for exception or termination handlers.
    //

    return ExceptionContinueSearch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\debugstb.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//      TITLE("Debug Support Functions")
//++
//
// Module Name:
//
//    debugstb.s
//
// Abstract:
//
//    This module implements functions to support debugging NT.  Each
//    function executes a break instruction with a special immediate
//    value.
//
// Author:
//
//    William K. Cheung (wcheung) 17-Jan-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    08-Feb-1996    Updated to EAS 2.1
//
//--

#include "ksia64.h"


//++
//
// VOID
// DbgBreakPoint()
//
// Routine Description:
//
//    This function executes a breakpoint instruction.  Useful for entering
//    the debugger under program control.  This breakpoint will always go to
//    the kernel debugger if one is installed, otherwise it will go to the
//    debug subsystem.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DbgBreakPoint)

        flushrs
        ;;
        break.i     BREAKPOINT_STOP
        br.ret.sptk.clr brp

        LEAF_EXIT(DbgBreakPoint)

//++
//
// VOID
// DbgBreakPointWithStatus(
//     IN ULONG Status
//     )
//
// Routine Description:
//
//    This function executes a breakpoint instruction.  Useful for entering
//    the debugger under program control.  This breakpoint will always go to
//    the kernel debugger if one is installed, otherwise it will go to the
//    debug subsystem.  This function is identical to DbgBreakPoint, except
//    that it takes an argument which the debugger can see.
//
// Arguments:
//
//    A status code.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DbgBreakPointWithStatus)

        ALTERNATE_ENTRY(RtlpBreakWithStatusInstruction)

        flushrs
        ;;
        add         t0 = zero, a0
        break.i     BREAKPOINT_STOP
        br.ret.sptk.clr brp

        LEAF_EXIT(DbgBreakPointWithStatus)

//++
//
// VOID
// DbgUserBreakPoint()
//
// Routine Description:
//
//    This function executes a breakpoint instruction.  Useful for entering
//    the debug subsystem under program control.  The kernel debug will ignore
//    this breakpoint since it will not find the instruction address in its
//    breakpoint table.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DbgUserBreakPoint)

        flushrs
        ;;
        break.i     BREAKPOINT_STOP
        br.ret.sptk.clr brp

        LEAF_EXIT(DbgUserBreakPoint)

//++
//
// ULONG
// DebugPrompt(
//     IN PSTRING Output,
//     IN PSTRING Input
//     )
//
// Routine Description:
//
//    This function executes a debug prompt breakpoint.
//
// Arguments:
//
//    Output (a0) - Supplies a pointer to the output string descriptor.
//
//    Input (a1) - Supplies a pointer to the input string descriptor.
//
// Return Value:
//
//    The length of the input string is returned as the function value.
//
//--

        LEAF_ENTRY(DebugPrompt)

        flushrs
        add         a0 = StrBuffer, a0
        add         a1 = StrBuffer, a1
        ;;

//
// Set the following 4 arguments into scratch registers t0 - t3;
// they are passed to the KiDebugRoutine() via the context record.
//
// t0 - address of output string
// t1 - length of output string
// t2 - address of input string
// t3 - maximumm length of input string
//

        LDPTRINC(t0, a0, StrLength - StrBuffer)
        LDPTRINC(t2, a1, StrMaximumLength - StrBuffer)
        nop.i       0
        ;;

        ld2.nta     t1 = [a0]
        ld2.nta     t3 = [a1]
        break.i     BREAKPOINT_PROMPT

        nop.m       0
        nop.m       0
        br.ret.sptk.clr brp

        LEAF_EXIT(DebugPrompt)

//++
//
// VOID
// DebugLoadImageSymbols(
//     IN PSTRING ImagePathName,
//     IN PKD_SYMBOLS_INFO SymbolInfo
//     )
//
// Routine Description:
//
//    This function calls the kernel debugger to load the symbol
//    table for the specified image.
//
// Arguments:
//
//    ImagePathName - specifies the fully qualified path name of the image
//       file that has been loaded into an NT address space.
//
//    SymbolInfo - information captured from header of image file.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DebugLoadImageSymbols)

//
// Arguments are passed to the KiDebugRoutine via the context record
// in scratch registers t0 and t1.
//

        flushrs
        add         t0 = zero, a0
        add         t1 = zero, a1
        ;;

        nop.m       0
        break.i     BREAKPOINT_LOAD_SYMBOLS
        br.ret.sptk.clr brp

        LEAF_EXIT(DebugLoadImageSymbols)

//++
//
// VOID
// DebugUnLoadImageSymbols(
//     IN PSTRING ImagePathName,
//     IN PKD_SYMBOLS_INFO SymbolInfo
//     )
//
// Routine Description:
//
//    This function calls the kernel debugger to unload the symbol
//    table for the specified image.
//
// Arguments:
//
//    ImagePathName - specifies the fully qualified path name of the image
//       file that has been unloaded from an NT address space.
//
//    SymbolInfo - information captured from header of image file.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DebugUnLoadImageSymbols)

//
// Arguments are passed to the KiDebugRoutine via the context record
// in scratch registers t0 and t1.
//

        flushrs
        add         t0 = zero, a0
        add         t1 = zero, a1
        ;;

        nop.m       0
        break.i     BREAKPOINT_UNLOAD_SYMBOLS
        br.ret.sptk.clr brp

        LEAF_EXIT(DebugUnLoadImageSymbols)

//++
//
// NTSTATUS
// DebugPrint(
//     IN PSTRING Output,
//     IN ULONG ComponentId,
//     IN ULONG Level
//     )
//
// Routine Description:
//
//    This function executes a debug print breakpoint.
//
// Arguments:
//
//    Output (a0) - Supplies a pointer to the output string descriptor.
//
//    ComponentId (a1) - Supplies the Id of the calling component.
//
//    Level (a2) - Supplies the output importance level.
//
// Return Value:
//
//    Status code.  STATUS_SUCCESS if debug print happened.
//    STATUS_BREAKPOINT if user typed a Control-C during print.
//    STATUS_DEVICE_NOT_CONNECTED if kernel debugger not present.
//
//--

        LEAF_ENTRY(DebugPrint)

        flushrs
        add         t5 = StrBuffer, a0
        ;;

        LDPTRINC(t0, t5, StrLength-StrBuffer)    // set address of output string
        ;;
        ld2.nta     t1 = [t5]               // set length of output string
        add         t2 = zero, a1           // set component id
        add         t3 = zero, a2           // set importance level
        break.i     BREAKPOINT_PRINT        // execute a debug print breakpoint
        br.ret.sptk.clr brp

        LEAF_EXIT(DebugPrint)

//++
//
// VOID
// DebugCommandString(
//     IN PSTRING Name,
//     IN PSTRING Command
//     )
//
// Routine Description:
//
//    This function requests that the kernel debugger execute
//    the given command string.
//
// Arguments:
//
//    Name - Command name to identify the source of the
//       command to the kd user.
//
//    Command - Command string.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(DebugCommandString)

//
// Arguments are passed to the KiDebugRoutine via the context record
// in scratch registers t0 and t1.
//

        flushrs
        add         t0 = zero, a0
        add         t1 = zero, a1
        ;;

        nop.m       0
        break.i     BREAKPOINT_COMMAND_STRING
        br.ret.sptk.clr brp

        LEAF_EXIT(DebugCommandString)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\context.c ===
/*++

Module Name:

    context.c

Abstract:

    This module implements user-mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

Author:


Revision History:

    Ported to the IA64

    27-Feb-1996   Revised to pass arguments to target thread by injecting
                  arguments into the backing store.

--*/

#include "ntrtlp.h"
#include "kxia64.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlInitializeContext)
#pragma alloc_text(PAGE,RtlRemoteCall)
#endif


VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    ULONGLONG Argument;
    ULONG_PTR Wow64Info;
    NTSTATUS Status;
    
    RTL_PAGED_CODE();

    //
    // Check for proper initial stack (0 mod 16).
    //

    if (((ULONG_PTR)InitialSp & 0xf) != 0) {
        RtlRaiseStatus(STATUS_BAD_INITIAL_STACK);
    }

    //
    // Check for proper plabel address alignment.
    // Assumes InitialPc points to a plabel that must be 8-byte aligned.
    //
    if (((ULONG_PTR)InitialPc & 0x7) != 0) {
        //
        // Misaligned, See if we are running in a Wow64 process
        //
        Status = ZwQueryInformationProcess(Process,
                                           ProcessWow64Information,
                                           &Wow64Info,
                                           sizeof(Wow64Info),
                                           NULL);

        if (NT_SUCCESS(Status) && (Wow64Info == 0))
        {
            //
            // Native IA64 process must not be misaligned.
            //
            RtlRaiseStatus(STATUS_BAD_INITIAL_PC);
        }
    }


    //
    // Initialize the integer and floating registers to contain zeroes.
    //

    RtlZeroMemory(Context, sizeof(CONTEXT));

    //
    // Setup integer and control context.
    //

    Context->ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;

    Context->RsBSPSTORE = Context->IntSp = (ULONG_PTR)InitialSp;
    Context->IntSp -= STACK_SCRATCH_AREA;

    //
    // InitialPc is the module entry point which is a function pointer
    // in IA64. StIIP and IntGp are initiailized with actual IP and GP
    // from the plabel in LdrInitializeThunk after the loader runs.
    //

    Context->IntS1 = Context->IntS0 = Context->StIIP = (ULONG_PTR)InitialPc;
    Context->IntGp = 0;

    //
    // Setup FPSR, PSR, and DCR
    // N.B. Values to be determined.
    //

    Context->StFPSR = USER_FPSR_INITIAL;
    Context->StIPSR = USER_PSR_INITIAL;
    Context->ApDCR = USER_DCR_INITIAL;

    //
    // Set the initial context of the thread in a machine specific way.
    // ie, pass the initial parameter to the RSE by saving it at the
    // bottom of the backing store.
    //
    //  Setup Frame Marker after RFI
    //  And other RSE states.
    //

    Argument = (ULONGLONG)Parameter;
    ZwWriteVirtualMemory(Process,
             (PVOID)((ULONG_PTR)Context->RsBSPSTORE),
             (PVOID)&Argument,
             sizeof(Argument),
             NULL);
//
// N.b. The IFS must be reinitialized in LdrInitializeThunk
//

    Context->StIFS = 0x8000000000000081ULL;            // Valid, 1 local register, 0 output register
    Context->RsBSP = Context->RsBSPSTORE;
    Context->RsRSC = USER_RSC_INITIAL;
    Context->ApUNAT = 0xFFFFFFFFFFFFFFFF;
}


NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using
    NtGetContext and NtSetContext.  Parameters are passed to the
    target procedure via its stack.

Arguments:

    Process - Handle of the target process

    Thread - Handle of the target thread within that process

    CallSite - Address of the procedure to call in the target process.

    ArgumentCount - Number of parameters to pass to the target
                    procedure.

    Arguments - Pointer to the array of parameters to pass.

    PassContext - TRUE if an additional parameter is to be passed that
        points to a context record.

    AlreadySuspended - TRUE if the target thread is already in a suspended
                       or waiting state.

Return Value:

    Status - Status value

--*/

{
    NTSTATUS Status;
    CONTEXT Context;
    ULONG_PTR ContextAddress;
    ULONG_PTR NewSp;
    ULONG_PTR NewBsp;
    ULONGLONG ArgumentsCopy[9];
    PVOID ptr;
    ULONG ShiftCount;
    ULONG Count = 0;


    RTL_PAGED_CODE();

    if ((ArgumentCount > 8) || (PassContext && (ArgumentCount > 7))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If necessary, suspend the guy before with we mess with his stack.
    //

    if (AlreadySuspended == FALSE) {
        Status = NtSuspendThread(Thread, NULL);
        if (NT_SUCCESS(Status) == FALSE) {
            return(Status);
        }
    }

    //
    // Get the context record of the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread(Thread, &Context);
    if (NT_SUCCESS(Status) == FALSE) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }
        return(Status);
    }

    if (AlreadySuspended) {
        Context.IntV0 = STATUS_ALERTED;
    }

    //
    // Pass the parameters to the other thread via the backing store (r32-r39).
    // The context record is passed on the stack of the target thread.
    // N.B. Align the context record address, stack pointer, and allocate
    //      stack scratch area.
    //

    ContextAddress = (((ULONG_PTR)Context.IntSp + 0xf) & ~0xfi64) - sizeof(CONTEXT);
    NewSp = ContextAddress - STACK_SCRATCH_AREA;
    Status = NtWriteVirtualMemory(Process, (PVOID)ContextAddress, &Context,
                  sizeof(CONTEXT), NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }
        return(Status);
    }

    RtlZeroMemory((PVOID)ArgumentsCopy, sizeof(ArgumentsCopy));

    NewBsp = RtlpRseGrowBySOF(Context.RsBSP, Context.StIFS);
    Context.RsBSP = NewBsp;

    if (PassContext) {
        ShiftCount = (ULONG)RtlpRseRNatCollectOffset(NewBsp);
        Context.RsRNAT &= ~(0x1i64 << ShiftCount);
        ArgumentsCopy[Count++] = ContextAddress;
        NewBsp += sizeof(ULONGLONG);
    }

    for (; ArgumentCount != 0 ; ArgumentCount--) {
        if (RtlpRseRNatCollectOffset(NewBsp) == 63) {
            ArgumentsCopy[Count++] = Context.RsRNAT;
            Context.RsRNAT = -1i64;
            NewBsp += sizeof(ULONGLONG);
        }
        ShiftCount = (ULONG)RtlpRseRNatCollectOffset(NewBsp);
        Context.RsRNAT &= ~(0x1i64 << ShiftCount);
        ArgumentsCopy[Count++] = (ULONGLONG)(*Arguments++);
        NewBsp += sizeof(ULONGLONG);
    }

    if (RtlpRseRNatCollectOffset(NewBsp) == 63) {
        ArgumentsCopy[Count++] = Context.RsRNAT;
        Context.RsRNAT = -1i64;
        NewBsp += sizeof(ULONGLONG);
    }

    //
    //  Copy the arguments onto the target backing store.
    //

    if (Count) {
        Status = NtWriteVirtualMemory(Process,
                                      (PVOID)Context.RsBSP,
                                      ArgumentsCopy,
                                      Count * sizeof(ULONGLONG),
                                      NULL
                                      );

        if (NT_SUCCESS(Status) == FALSE) {
            if (AlreadySuspended == FALSE) {
                NtResumeThread(Thread, NULL);
            }
            return(Status);
        }
    }

    //
    // set up RSE
    //

    Context.RsRSC = (RSC_MODE_LY<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    Count = ArgumentCount + (PassContext ? 1 : 0);

    //
    // Inject all arguments as local stack registers in the target RSE frame
    //

    Context.StIFS = (0x3i64 << 62) | Count | (Count << PFS_SIZE_SHIFT);

    //
    // Set the address of the target code into IIP, the new target stack
    // into sp, setup ap, and reload context to make it happen.
    //

    Context.IntSp = (ULONG_PTR)NewSp;

    //
    // Set IP to the target call site PLABEL and GP to zero.  IIP and GP
    // will be computed inside NtSetContextThread.
    //

    Context.StIIP = (ULONGLONG)CallSite;
    Context.IntGp = 0;

    //
    // sanitize the floating pointer status register
    //

    SANITIZE_FSR(Context.StFPSR, UserMode);

    Status = NtSetContextThread(Thread, &Context);
    if (!AlreadySuspended) {
        NtResumeThread(Thread, NULL);
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\excepttest.cpp ===
// options: /Oxs /EHa /GX

#include "stdio.h"
#include "windows.h"


typedef void (*PEXCEPTION_TEST) (void (*p)(void), volatile int *State);
typedef struct _EXCEPTION_TEST_INFO {
               PEXCEPTION_TEST ExceptionTest;
               int State;
} EXCEPTION_TEST_INFO;

void TestUnwindFromRecoveryCodeInFinally (void (*p)(void), volatile int *State);
void TestUnwindFromRecoveryCodeTryFinallyBlock (void (*p)(void), volatile int *State);
void TestUnwindFromRecoverCodeDuplicatesScopeEntries (void (*p)(void), volatile int *State);
void TestUnwindFromInfiniteLoop (void (*p)(void), volatile int *State);
void TestExtendedTrySCopeForRecoveryCode (void (*p)(void), volatile int *State);
void TestIPStatesCoverRecoveryCode (void (*p)(void), volatile int *State);
void TestNestedFinally (void (*p)(void), volatile int *State);
EXCEPTION_TEST_INFO ExceptionTests[] = { {TestNestedFinally, 3 },
                                         {TestExtendedTrySCopeForRecoveryCode, 2},
                                         {TestIPStatesCoverRecoveryCode, 2},
                                         {TestUnwindFromInfiniteLoop, 2},
                                         {TestUnwindFromRecoverCodeDuplicatesScopeEntries, 4},
                                         {TestUnwindFromRecoveryCodeTryFinallyBlock, 1},
                                         {TestUnwindFromRecoveryCodeInFinally, 1},
                                       };

const MaxExceptionTests = sizeof(ExceptionTests) / sizeof(EXCEPTION_TEST_INFO);


// 
// Test that recovery code is covered by extended try scope.
void TestExtendedTrySCopeForRecoveryCode (void (*p)(void), volatile int *State)

{ 

   __try

   {
   
       if ((int)p != 1)

       {

          (*p)();

       }

   }
   __finally

   {

       ++*State++;
   }

}


// VSWhidbey:14611
// Test that recovery code for finally block is covered by full pdata range. 
// Inspect code to be sure LD.S/CHK is generated in funclet for (*p).
// Failure will cause bad unwind and program will fail.
void TestUnwindFromRecoveryCodeInFinally (void (*p)(void), volatile int *State)

{ 

   __try

   {
   
       // transfer to finally funclet
   
       (*p)();

   }

   __finally

   {

     // cause speculative load of p (ld.s p) and chk to fail. If recovery code isn't covered by pdata range of 
     // funclet unwind will fail.

       if ((int)p != 1)

       {

          (*p)();

       }

   }

}


// VSWhidbey:10415
// Test that if the extended scope table entry ends at the beginning address of finally funclet that
// the runtime (CRT, RTL) doesn't use it's address as the NextPC after invoking the finally. This leads
// to the finally being called twice and unwinding failing. This bug fixed in CRT and RTL.
void TestUnwindFromRecoveryCodeTryFinallyBlock (void (*p)(void), volatile int *State)

{

   int rg[5];

   rg[1] = 0;   rg[2] = 0;   rg[3] = 0;

   rg[3] = 0xC0000005;   

   __try

   {

      if ((int)p != 1)

      {

         (*p)();

      }

   }

   __finally

   {
   
      RaiseException( rg[3], 0, 0, 0 );

   }

}


// VSWhidbey:10415
// Test that nested scope table entries are duplicated for recover code.
// Failure will cause finally to be called in wrong order
void TestUnwindFromRecoverCodeDuplicatesScopeEntries (void (*p)(void), volatile int *State)

{

   int rg[5];

   rg[1] = 0;   rg[2] = 0;   rg[3] = 0;

   __try

   {

      __try 
      {
        
        rg[3] = 0xC0000005;
 

        if ((int)p != 1)

        {

            (*p)();

        }

      }

      __finally

      {

        ++*State;

        __try 
        {

            RaiseException( rg[3], 0, 0, 0 );

        }
        __finally

        {
            ++*State;

        }
      }
  }
  __finally 
  {

    ++*State;

  }
}


// VSWhidbeg:13074
// Test that infinite loop covers the entire try/except body range.
void TestUnwindFromInfiniteLoop (void (*p)(void), volatile int *State)
{
    __try {

	if (!State)
	{
            
            ++*State;
	    __leave;

	}
	while (1)
	{

	    p();

	}
    }__except(1){

         ++*State;
         p();
    }
}

// VSWhidbey:15700 -  Test Extended IP States cover Recovery Code
void TestIPStatesCoverRecoveryCode (void (*p)(void), volatile int *State)
{

   int rg[5];

   rg[1] = 0;   rg[2] = 0;   rg[3] = 0;

 
   try
   {

       try

       {

           rg[3] = 0xC0000005;

 

           if ((int)p != 1)

           {

               (*p)();

           }

       }

       catch (...)
       {
           ++*State;
           throw;
       }

   }
   catch (...)
   {
     ++*State;
   }
}

// VSWhidbey:14606
void TestNestedFinally (void (*p)(void), volatile int *State)
{
//    __try {
    __try {
        *State += *State / *State;
    } __finally {
        if (_abnormal_termination())
            ++*State;
        __try {

            // This thing is screwed up - IA64 is wrong, the AMD64 compiler chokes, x86's helper routine is just messed up.
            if (_abnormal_termination()) 
                ++*State;
        } __finally
        {
            if (_abnormal_termination()) // On x86 only, this is true, if the outer one is true, or if this on is true
                ++*State;
        }
    }
//    } __except(1){}
}


void main (void)

{
   int i = 0;
   volatile int State = 0;

   printf("Number of tests = %d\n",MaxExceptionTests);
   for (i = 0; i < MaxExceptionTests; i++) 
   {
       __try

       {

          State = 0;
          ExceptionTests[i].ExceptionTest(0, &State);

       }
    
       __except( 1 )
    
       {
          ++State;
       }


       if (ExceptionTests[i].State == State)
           printf("#%d pass\n", i+1);
       else 
           printf("#%d fail, State == %d\n", i+1, State);

   }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\icecap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    icecap.c

Abstract:

    This module implements the probe and support routines for
    kernel icecap tracing.

Author:

    Rick Vicik (rickv) 10-Aug-2001

Revision History:

--*/

#ifdef _CAPKERN


#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <stdio.h>


#define InterlockedExchangeAddPtr _InterlockedExchangeAdd64

#define  GetTS() __getReg(CV_IA64_ApITC)     // Timestamp
#define  GetPMD4() __getReg(CV_IA64_PFD4)     // PMD[4]
#define  GetPMD5() __getReg(CV_IA64_PFD5)     // PMD[5]
#define  PutPMC4() __getReg(CV_IA64_PFC4)     // PMC[4]


//
// Kernel Icecap logs to Perfmem (BBTBuffer) using the following format:
//
// BBTBuffer[0] contains the length in pages (4k or 8k)
// BBTBuffer[1] is a flagword: 1 = trace
//                             2 = RDPMD4
//                             4 = user stack dump
// BBTBuffer[2] is ptr to beginning of cpu0 buffer
// BBTBuffer[3] is ptr to beginning of cpu1 buffer (also end of cpu0 buffer)
// BBTBuffer[4] is ptr to beginning of cpu2 buffer (also end of cpu1 buffer)
// ...
// BBTBuffer[n+2] is ptr to beginning of cpu 'n' buffer (also end of cpu 'n-1' buffer)
// BBTBuffer[n+3] is ptr the end of cpu 'n' buffer
//
// The area starting with &BBTBuffer[n+4] is divided into private buffers
// for each cpu.  The first dword in each cpu-private buffer points to the
// beginning of freespace in that buffer.  Each one is initialized to point
// just after itself.  Space is claimed using lock xadd on that dword.
// If the resulting value points beyond the beginning of the next cpu's
// buffer, this buffer is considered full and nothing further is logged.
// Each cpu's freespace pointer is in a separate cacheline.

//
// Sizes of trace records
//

typedef struct CapEnter
{
    char type;
    char spare;
    short size;
    void* current;
    void* child;
    SIZE_T stack;
    ULONGLONG timestamp;
    ULONGLONG ctr2[1];
} CAPENTER;
typedef struct CapExit
{
    char type;
    char spare;
    short size;
    void* current;
    ULONGLONG timestamp;
    ULONGLONG ctr2[1];
} CAPEXIT;
typedef struct CapTID
{
    char type;
    char spare;
    short size;
    ULONG Pid;
    ULONG Tid;
    char ImageName[20];
} CAPTID;
typedef struct CapNINT
{
    char type;
    char spare;
    short size;
    ULONG_PTR Data[1];
} CAPNINT;


//
// The pre-call (CAP_Start_Profiling) and post-call (CAP_End_Profiling)
// probe calls are defined in RTL because they must be built twice:
// once for kernel runtime and once for user-mode runtime (because the
// technique for getting the trace buffer address is different).
//

#ifdef NTOS_KERNEL_RUNTIME

ULONG RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );

//
// Kernel-Mode Probe & Support Routines:
// (BBTBuffer address obtained from kglobal pointer *BBTBuffer,
//  cpu number obtained from PCR)
//

extern SIZE_T *BBTBuffer;


VOID
__stdcall
_CAP_Start_Profiling(

    PVOID Current,
    PVOID Child)

/*++

Routine description:

    Kernel-mode version of before-call icecap probe.  Logs a type 5
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Prcb).  Inserts adrs of current and called functions
    plus ITC timestamp into logrecord.  If BBTBuffer flag 2 set,
    also copies PMD 4 into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call
    child - address of called routine

--*/

{
    SIZE_T*   CpuPtr;
    CAPENTER* RecPtr;
    int       size = sizeof(CAPENTER) -8;


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + KeGetCurrentProcessorNumber() + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if ( BBTBuffer[1] & 2 )
        size += 8;
    else if ( BBTBuffer[1] & 8 )
        size += 16;

    RecPtr = (CAPENTER*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 5;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->child = Child;
    RecPtr->stack = (SIZE_T)PsGetCurrentThread()->Cid.UniqueThread;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPENTER) )
	    RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPENTER)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

    return;
}


VOID
__stdcall
_CAP_End_Profiling(

    PVOID Current)

/*++

Routine description:

    Kernel-mode version of after-call icecap probe.  Logs a type 6
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Prcb).  Inserts adr of current function and
    ITC timestamp into logrecord.  If BBTBuffer flag 2 set,
    also copies PMD 4 into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call

--*/

{
    SIZE_T*  CpuPtr;
    CAPEXIT* RecPtr;
    int       size = sizeof(CAPEXIT) -8;


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + KeGetCurrentProcessorNumber() + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if( BBTBuffer[1] & 2 )
        size += 8;
    else if( BBTBuffer[1] & 8 )
        size += 16;

    RecPtr = (CAPEXIT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 6;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPEXIT) )
	    RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPEXIT)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

    return;

}


VOID
__stdcall
_CAP_ThreadID( VOID )

/*++

Routine description:

    Called by KiSystemService before executing the service routine.
    Logs a type 14 icecap record containing Pid, Tid & image file name.
    Optionally, if BBTBuffer flag 2 set, runs the stack frame pointers
    in the user-mode call stack starting with the trap frame and copies
    the return addresses to the log record.  The length of the logrecord
    indicates whether user call stack info is included.

--*/

{
    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    {
    PEPROCESS Process;
    PKTHREAD  Thread;
    PETHREAD  EThread;
    CAPTID*   RecPtr;
    SIZE_T*   CpuPtr;
    int       callcnt;
    ULONG     recsize;
    SIZE_T    RetAddr[7];

    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + KeGetCurrentProcessorNumber() + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    callcnt = 0;
    recsize = sizeof(CAPTID);
    Thread = KeGetCurrentThread();
    EThread = CONTAINING_RECORD(Thread,ETHREAD,Tcb);

    // if trapframe, count call-frames to determine record size
    if( (BBTBuffer[1] & 4) && EThread->Tcb.PreviousMode != KernelMode ) {

        PTEB  Teb;
        SIZE_T *FramePtr;

        callcnt =  RtlWalkFrameChain((PVOID*)RetAddr,7,0);

        FramePtr = (SIZE_T*)EThread->Tcb.TrapFrame;  // get trap frame
        Teb = EThread->Tcb.Teb;
        DbgPrint("TrapFrame=%#x, 3rd RetAdr=%p\n",
                  Thread->TrapFrame, RetAddr[2] );

        recsize += (callcnt<<3);
    }

    RecPtr = (CAPTID*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), recsize);

    if( (((SIZE_T)RecPtr)+recsize) >= *(CpuPtr+1) )
        return;

    // initialize CapThreadID record (type 14)
    RecPtr->type = 14;
    RecPtr->spare = 0;

    // insert data length (excluding 4byte header)
    RecPtr->size = (SHORT)recsize-4;

    // insert Pid & Tid
    RecPtr->Pid = HandleToUlong(EThread->Cid.UniqueProcess);
    RecPtr->Tid = HandleToUlong(EThread->Cid.UniqueThread);

    // insert ImageFile name
    Process = CONTAINING_RECORD(Thread->ApcState.Process,EPROCESS,Pcb);
    memcpy(&RecPtr->ImageName, Process->ImageFileName, 16 );

    // insert optional user call stack data
    if( recsize > sizeof(CAPTID) && (callcnt-2) )
        memcpy( ((char*)RecPtr)+sizeof(CAPTID), RetAddr+2, ((callcnt-2)<<3) );
    }
}

VOID
__stdcall
_CAP_SetCPU( VOID )

/*++

Routine description:

    Called by KiSystemService before returning to user mode.
    Sets current cpu number in Teb->Spare3 (+0xf78) so user-mode version
    of probe functions know which part of BBTBuffer to use.

--*/

{
    SIZE_T *CpuPtr;
    ULONG  cpu;
    PTEB   Teb;

    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    cpu = KeGetCurrentProcessorNumber();

    CpuPtr = BBTBuffer + cpu + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) ||
        !(Teb = NtCurrentTeb()) )
        return;

    try {
        Teb->Spare3 = cpu;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
}

#else

//
// User-Mode Probe Routines (for ntdll, win32k, etc.)
// (BBTBuffer address & cpu obtained from Teb)
//


VOID
__stdcall
_CAP_Start_Profiling(
    PVOID Current,
    PVOID Child)

/*++

Routine description:

    user-mode version of before-call icecap probe.  Logs a type 5
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adrs of current and called
    functions plus ITC timestamp into logrecord.  If BBTBuffer
    flag 2 set, also copies PMD 4 into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call
    child - address of called routine

--*/

{
    TEB*      Teb = NtCurrentTeb();
    SIZE_T*   BBTBuffer = Teb->ReservedForPerf;
    SIZE_T*   CpuPtr;
    CAPENTER* RecPtr;
    int       size = sizeof(CAPENTER) -8;


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + Teb->Spare3 + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if( BBTBuffer[1] & 2 )
        size += 8;
    if( BBTBuffer[1] & 8 )
        size += 8;

    RecPtr = (CAPENTER*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 5;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->child = Child;
    RecPtr->stack = (SIZE_T)Teb->ClientId.UniqueThread;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPENTER) )
        RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPENTER)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

}


VOID
__stdcall
_CAP_End_Profiling(
    PVOID Current)

/*++

Routine description:

    user-mode version of after-call icecap probe.  Logs a type 6
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adr of current function
    plus RDTSC timestamp into logrecord.  If BBTBuffer flag 2 set,
    also copies PMD 4 into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.

Arguments:

    current - address of routine which did the call

--*/

{
    TEB*     Teb = NtCurrentTeb();
    SIZE_T*  BBTBuffer = Teb->ReservedForPerf;
    SIZE_T*  CpuPtr;
    CAPEXIT* RecPtr;
    int       size = sizeof(CAPEXIT) -8;


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + Teb->Spare3 + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if( BBTBuffer[1] & 2 )
        size += 8;
    if( BBTBuffer[1] & 8 )
        size += 8;

    RecPtr = (CAPEXIT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 6;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPEXIT) )
        RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPEXIT)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

}


#endif

//
// Common Support Routines
// (method for getting BBTBuffer address & cpu ifdef'ed for kernel & user)
//



VOID
__stdcall
_CAP_Log_1Int(

    ULONG code,
    SIZE_T data)

/*++

Routine description:

    User-mode version of general-purpose log integer probe.
    Logs a type 15 icecap record into the part of BBTBuffer for the
    current cpu (obtained from Prcb).  Inserts code into the byte after
    length, ITC timestamp and the value of 'data'.
    Uses lock xadd to claim buffer space without the need for spinlocks.

Arguments:

    code - type-code for trace formatting
    data - ULONG value to be logged

--*/

{
    SIZE_T* CpuPtr;
    CAPEXIT* RecPtr;
    int       cpu,size;
#ifndef NTOS_KERNEL_RUNTIME
    TEB*     Teb = NtCurrentTeb();
    SIZE_T*  BBTBuffer = Teb->ReservedForPerf;
    cpu = Teb->Spare3;
#else
    cpu = KeGetCurrentProcessorNumber();
#endif


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + cpu + 2;

    CpuPtr = BBTBuffer + KeGetCurrentProcessorNumber() + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    size = sizeof(CAPENTER) -8;
    RecPtr = (CAPEXIT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 15;
    RecPtr->spare = (char)code;
    RecPtr->size = size-4;
    RecPtr->current = (PVOID)data;
    RecPtr->timestamp = GetTS();

    return;
}

VOID
CAPKComment(

    char* Format, ...)

/*++

Routine description:

    Logs a free-form comment (record type 13) in the icecap trace

Arguments:

    Format - printf-style format string and substitutional parms

--*/

{
    SIZE_T* CpuPtr;
    UCHAR   Buffer[512];
    int cb, insize, outsize;
    CAPEXIT* RecPtr;
    char*   data;
    va_list arglist;

#ifndef NTOS_KERNEL_RUNTIME
    TEB*     Teb = NtCurrentTeb();
    SIZE_T*  BBTBuffer = Teb->ReservedForPerf;
    cb = Teb->Spare3;
#else
    cb = KeGetCurrentProcessorNumber();
#endif


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + cb + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;


    va_start(arglist, Format);
    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    va_end(arglist);

    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }

    data = &Buffer[0];
    insize = strlen(data);             // save insize for data copy

    outsize = ((insize+11) & 0xfffffff8);  // pad outsize to SIZE_T boundary
                                           // (+4 for hdr, +3 to pad)

    RecPtr = (CAPEXIT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), outsize);

    if( (((SIZE_T)RecPtr)+outsize) >= *(CpuPtr+1) )
        return;

    // size in tracerec excludes 4byte hdr
    outsize -= 4;

    // initialize CapkComment record (type 13)

    RecPtr->type = 13;
    RecPtr->spare = 0;

    // insert size
    RecPtr->size = (short)outsize;

    // insert sprintf data right after 4byte hdr
    memcpy(((char*)RecPtr)+4, data, insize );

    // if had to pad, add null terminator to string
    if( outsize > insize )
        *( (((char*)RecPtr) + 4) + insize) = 0;
}



VOID
__cdecl
CAP_Log_NInt_Clothed(

    ULONG Bcode_Bts_Scount,
/*
    UCHAR code,
    UCHAR log_timestamp,
    USHORT intcount, 
*/
    ...)
/*++

Routine description:

    Kernel-mode and User-mode versions of general-purpose log integer probe.
    Logs a type 16 icecap record into the part of BBTBuffer for the
    current cpu (obtained from Prcb).  Inserts lowest byte of code into the 
    byte after length, the RDTSC timestamp (if log_timestamp != 0), and
    intcount ULONG_PTRs.  Uses lock xadd to claim buffer space without the need 
    for spinlocks.

Arguments:

    code - type-code for trace formatting (really only a single byte)
    log_timestamp - non-zero if timestamp should be logged
    intcount - number of ULONG_PTRs to log
    remaining arguments - ULONG_PTR value(s) to be logged

--*/

{
    SIZE_T* CpuPtr;
    CAPNINT* RecPtr;
    int       cpu,size;
    BOOLEAN logts;
    ULONG count;
    ULONG i = 0;
    va_list marker;
#ifndef NTOS_KERNEL_RUNTIME
    TEB*     Teb = NtCurrentTeb();
    SIZE_T*  BBTBuffer = Teb->ReservedForPerf;
    cpu = Teb->Spare3;
#else
    cpu = KeGetCurrentProcessorNumber();
#endif

    logts = (Bcode_Bts_Scount & 0xFF00) != 0;
    count = (Bcode_Bts_Scount & 0xFFFF0000) >> 16;


    if( !BBTBuffer || !(BBTBuffer[1]&1) )
        return;

    CpuPtr = BBTBuffer + cpu + 2;

    //CpuPtr = BBTBuffer + KeGetCurrentProcessorNumber() + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    size = sizeof(CAPNINT) + count * sizeof (ULONG_PTR);  
    if (logts)
        size += 8;

    RecPtr = (CAPNINT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 16;
    RecPtr->spare = (char) (Bcode_Bts_Scount & 0xFF);
    RecPtr->size = size - 4;

    if (logts) {
        RecPtr->Data[0] = GetTS();
        i++;
    }

    va_start (marker, Bcode_Bts_Scount);     
    while (count-- > 0)
        RecPtr->Data[i++] = va_arg (marker, ULONG_PTR);
    va_end (marker);
 
    RecPtr->Data[i] = (ULONG_PTR)_ReturnAddress();         
        
    return;

}


//
// Constants for CAPKControl
//

#define CAPKStart   1
#define CAPKStop    2
#define CAPKResume  3
#define MAXDUMMY    30
#define CAPK0       4
#define PAGESIZE    8192

ULONG CpuNumber;


VOID
__stdcall
CAPK_Calibrate_Start_Profiling(
    PVOID Current,
    PVOID Child)

/*++

Routine description:

    Calibration version of before-call icecap probe.  Logs a type 5
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adrs of current and called
    functions plus RDTSC timestamp into logrecord.  If BBTBuffer
    flag 1 set, also does RDPMC 0 and inserts result into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.
    Slightly modified for use here (invert checking of 'GO' bit and
    use global CpuNumber)


Arguments:

    current - address of routine which did the call
    child - address of called routine

--*/

{
    SIZE_T*   CpuPtr;
    CAPENTER* RecPtr;
    int       size = sizeof(CAPENTER) -8;
#ifndef NTOS_KERNEL_RUNTIME
    SIZE_T*  BBTBuffer = NtCurrentTeb()->ReservedForPerf;
#endif


    if( !BBTBuffer || (BBTBuffer[1]&1) )      // note 1 bit is opposite
        return;

    CpuPtr = BBTBuffer + CpuNumber + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if ( BBTBuffer[1] & 2 )
        size += 8;
    else if ( BBTBuffer[1] & 8 )
        size += 16;

    RecPtr = (CAPENTER*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 5;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->child = Child;
    RecPtr->stack = (SIZE_T)PsGetCurrentThread()->Cid.UniqueThread;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPENTER) )
	    RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPENTER)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

}


VOID
__stdcall
CAPK_Calibrate_End_Profiling(
    PVOID Current)

/*++

Routine description:

    Calibration version of after-call icecap probe.  Logs a type 6
    icecap record into the part of BBTBuffer for the current cpu
    (obtained from Teb+0xf78).  Inserts adr of current function
    plus RDTSC timestamp into logrecord.  If BBTBuffer flag 1 set,
    also does RDPMC 0 and inserts result into logrecord.
    Uses InterlockedAdd to claim buffer space without the need for spinlocks.
    Slightly modified for use here (invert checking of 'GO' bit and
    use global CpuNumber)

Arguments:

    current - address of routine which did the call

--*/

{
    SIZE_T*  CpuPtr;
    CAPEXIT* RecPtr;
    int       size = sizeof(CAPENTER) -8;
#ifndef NTOS_KERNEL_RUNTIME
    SIZE_T*  BBTBuffer = NtCurrentTeb()->ReservedForPerf;
#endif


    if( !BBTBuffer || (BBTBuffer[1]&1) )      // note 1 bit is opposite
        return;

    CpuPtr = BBTBuffer + CpuNumber + 2;

    if( !( *CpuPtr ) || *((SIZE_T*)(*CpuPtr)) > *(CpuPtr+1) )
        return;

    if( BBTBuffer[1] & 2 )
        size += 8;
    else if( BBTBuffer[1] & 8 )
        size += 16;

    RecPtr = (CAPEXIT*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);

    if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        return;

    RecPtr->type = 6;
    RecPtr->spare = 0;
    RecPtr->size = size-4;
    RecPtr->current = Current;
    RecPtr->timestamp = GetTS();
    if( size >= sizeof(CAPEXIT) )
	    RecPtr->ctr2[0] = GetPMD4();
    if( size == sizeof(CAPEXIT)+8 )
	    RecPtr->ctr2[1] = GetPMD5();

    return;
}


int CAPKControl(

    ULONG opcode)

/*++

Routine description:

    CAPKControl

Description:

    Starts, stops or pauses icecap tracing

Arguments:

    opcode - 1=start, 2=stop, 3=resume, 4,5,6,7 reserved

Return value:

    1 = success, 0 = BBTBuf not set up

--*/

{
    ULONG cpus,pwords,percpusize;
    SIZE_T* ptr;

#ifndef NTOS_KERNEL_RUNTIME
    SIZE_T*  BBTBuffer = NtCurrentTeb()->ReservedForPerf;
    cpus = NtCurrentPeb()->NumberOfProcessors;
#else
    cpus = KeNumberProcessors;
#endif

    if( !BBTBuffer || !(BBTBuffer[0]) )
        return 0;

    pwords = CAPK0 + cpus;
    percpusize = ( ( *((PULONG)BBTBuffer) * (PAGESIZE/sizeof(SIZE_T)) ) - pwords)/cpus;  // in words

    if(opcode == CAPKStart) {        // start

        ULONG i,j;

        BBTBuffer[1] &= ~1;  // stop


        // initialize the CpuPtrs
        for( i=0, ptr = BBTBuffer+pwords; i<cpus+1; i++, ptr+=percpusize)
            BBTBuffer[2+i] = (SIZE_T)ptr;

        // initialize each freeptr to next dword
        // (and log dummy records to calibrate overhead)
        for( i=0, ptr = BBTBuffer+pwords; i<cpus; i++, ptr+=percpusize)
        {
            *ptr = (SIZE_T) (ptr+1);
            CpuNumber = i;
            for( j=0; j<MAXDUMMY; j++ )
            {
                CAPK_Calibrate_Start_Profiling(NULL, NULL);
                CAPK_Calibrate_End_Profiling(NULL);
            }
        }

        BBTBuffer[1] |= 1;  //start

    } else if( opcode == CAPKStop ) {  // stop

        BBTBuffer[1] &= ~1;

    } else if( opcode == CAPKResume ) { //resume

        BBTBuffer[1] |= 1;  //start

    } else {
        return 0;                      // invalid opcode
    }
    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\icecap2.s ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    icecap2.s

Abstract:

    This module implements the assembler versions of the probe routines
    for kernel icecap tracing of assembler routines in ke\IA64.
    They have to be in assembler because the target routines expect
    registers to be preserved which the C version of these probes
    do not preserve.

Author:

    Rick Vicik (rickv) 10-Aug-2001

Revision History:

--*/

#ifdef _CAPKERN

#include "ksia64.h"

        .file    "icecap2.s"
        .global   BBTBuffer

//++
//
// VOID
// _CAP_Start_Profiling (
//    IN PVOID Current,
//    IN PVOID Child
//    )
//
// Routine Description:
//
//    Kernel-mode version of before-call icecap probe.  Logs a type 5
//    icecap record into the part of BBTBuffer for the current cpu
//    (obtained from Prcb).  Inserts adrs of current and called functions
//    plus ar.itc timestamp into logrecord.
//    If BBTBuffer flag 2 set, also copies PMD4 into logrecord.
//    Uses cmpxchg8 to claim buffer space without the need for spinlocks.
//
// Arguments:
//
//    current - address of routine which did the call
//    child - address of called routine
//
//--

        LEAF_ENTRY(_CAP_Start_Profiling2)
        movl    r31 = BBTBuffer        // adr of ptr to BBTBuffer
        ;;
	    ld8	    r31 = [r31]            // ptr to BBTBuffer
        ;;
	    cmp.eq	p6 = r0, r31           // check if ptr not set up
 (p6)   br.ret.sptk.clr brp
	    adds 	r30 = 8, r31           // BBTBuffer+1
        ;;

	    ld8	    r30 = [r30]            // *(BBTBuffer+1)
        ;;

	    tbit.z	p6 = r30, 0            // (*(BBTBuffer+1)) & 1
 (p6)   br.ret.sptk.clr brp
        movl    r29 = KiPcr + PcNumber  // Get cpu# from Pcr
        ;;

	    ld1     r29 = [r29]            // extract 1 byte cpu#
        tbit.nz p7=r30, 1              // (*(BBTBuffer+1)) & 2
        tbit.nz p8=r30, 3              // (*(BBTBuffer+1)) & 8
        ;;
        mov	    r30 = 40               // size w/o 2nd counter
	    add 	r29 = 2, r29           // cpu+2
        ;;
 (p7)   mov     r30 = 48               // size w/ 2nd counter
	    shladd	r29 = r29, 3, r31      // CpuPtr=BBTBuffer + 8*(cpu+2)
        ;;
 (p8)   mov	    r30 = 56               // size w/ 3rd counter

// r30=size, r29=CpuPtr

	    ld8	    r31 = [r29]            // *CpuPtr
	    add 	r28 = 8, r29           // (CpuPtr+1)
        ;;
	    cmp.eq	p6 = r0, r31           // !(*CpuPtr)
 (p6)   br.ret.sptk.clr brp
	    ld8	    r29 = [r31]            // **CpuPtr
	    ld8	    r28 = [r28]            // *(CpuPtr+1)
        ;;

// loc1=*CpuPtr, loc2=size, loc3=**CpuPtr, loc4=*(CpuPtr+1)

	    cmp.gtu	p6 = r29, r28          // **CpuPtr > *(CpuPtr+1)
 (p6)   br.ret.sptk.clr brp
        ;;

//      RecPtr = (CAPENTER*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);
SP_Retry:
	    ld8	    r29 = [r31]            // refresh **CpuPtr
        ;;
        mov.m   ar.ccv = r29           // save old value
        add     r27 = r29, r30         // loc5 is proposed value
        ;;
        cmpxchg8.acq r27=[r31], r27, ar.ccv   // loc5 now RecPtr
        ;;
        cmp.ne  p6 = r27, r29
 (p6)   br.cond.dptk.few SP_Retry
        add     r31 = r30, r27         // RecPtr+size
        ;;

// r30=size, r27=RecPtr
//      if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        cmp.geu p6 = r31, r28	       // r28 = *(CpuPtr+1)
 (p6)   br.ret.sptk.clr brp
        add     r30 = -4, r30          // RecSize doesn't include header
        ;;

        shl     r30 = r30, 16          // shift up 2 bytes
        ;;
        adds    r30 = 5, r30           // RecType 5 in low byte
        ;;
        st8     [r27] = r30, 8         // copy RecType & size to RecPtr+0(8)
        ;;
        st8     [r27] = r32, 8         // copy A0 (Current) to RecPtr+8(8)
        ;;
        st8     [r27] = r33, 8         // copy A1 (Child) to RecPtr+16(8)
        ;;

//      RecPtr->stack = (SIZE_T)PsGetCurrentThread()->Cid.UniqueThread;
        movl    r30 = KiPcr + PcCurrentThread
        ;;
        ld8     r30 = [r30]
        ;;
        adds    r30 = EtCid + CidUniqueThread, r30  // Ethread->Cid.UniqueThread
        ;;
        ld8     r30 = [r30]
        ;;
        st8     [r27] = r30, 8
        mov.m   r31 = ar.itc           // get TS
 (p7)   mov     r29 = 4                // PMD[4]
        ;;
        st8     [r27] = r31, 8         // copy TS to RecPtr+32(8)
 (p7)   mov     r30 = PMD[r29]         // get PMD[4]
        ;;
 (p7)   st8     [r27] = r30, 8         // copy to RecPtr+40(8)
 (p8)   mov     r29= 5                 // PMD[5]
        ;;
 (p8)   mov     r30 = PMD[r29]         // get PMD[5]
        ;;
 (p8)   st8     [r27] = r30, 8         // copy to RecPtr+48(8)
        br.ret.sptk.clr brp
        LEAF_EXIT(_CAP_Start_Profiling2)

//++
//
// VOID
// _CAP_End_Profiling (
//    IN PVOID Current
//    )
//
// Routine Description:
//
//    Kernel-mode version of after-call icecap probe.  Logs a type 6
//    icecap record into the part of BBTBuffer for the current cpu
//    (obtained from Prcb).  Inserts adr of current function
//    plus ar.itc timestamp into logrecord.
//    If BBTBuffer flag 2 set, also copies PMD4 into logrecord.
//    Uses cmpxchg8 to claim buffer space without the need for spinlocks.
//
// Arguments:
//
//    current - address of routine which did the call
//
//--

        LEAF_ENTRY(_CAP_End_Profiling2)
        movl    r31 = BBTBuffer        // adr of ptr to BBTBuffer
        ;;
	    ld8	    r31 = [r31]            // ptr to BBTBuffer
        ;;
	    cmp.eq	p6 = r0, r31           // check if ptr not set up
 (p6)   br.ret.sptk.clr brp
	    adds 	r30 = 8, r31           // BBTBuffer+1
        ;;

	    ld8	    r30 = [r30]            // *(BBTBuffer+1)
        ;;

	    tbit.z	p6 = r30, 0            // (*(BBTBuffer+1)) & 1
 (p6)   br.ret.sptk.clr brp
        movl    r29 = KiPcr + PcNumber // Get cpu# from Pcr
        ;;

	    ld1     r29 = [r29]            // extract 1 byte cpu#
        tbit.nz p7=r30, 1              // (*(BBTBuffer+1)) & 2
        tbit.nz p8=r30, 3              // (*(BBTBuffer+1)) & 8
        ;;
        mov	    r30 = 24               // size w/o 2nd counter
	    add 	r29 = 2, r29           // cpu+2
        ;;
 (p7)   mov     r30 = 32               // size w/ 2nd counter
	    shladd	r29 = r29, 3, r31      // CpuPtr=BBTBuffer + 8*(cpu+2)
        ;;
 (p8)   mov	    r30 = 40               // size w/ 3rd counter

// r30=size, r29=CpuPtr

	    ld8	    r31 = [r29]            // *CpuPtr
	    add 	r28 = 8, r29           // (CpuPtr+1)
        ;;
	    cmp.eq	p6 = r0, r31           // !(*CpuPtr)
	    ld8	    r29 = [r31]            // **CpuPtr
	    ld8	    r28 = [r28]            // *(CpuPtr+1)
 (p6)   br.ret.sptk.clr brp
        ;;

// r31=*CpuPtr, r30=size, r29=**CpuPtr, r28=*(CpuPtr+1)

	    cmp.gtu	p6 = r29, r28          // **CpuPtr > *(CpuPtr+1)
 (p6)   br.ret.sptk.clr brp
        ;;

//      RecPtr = (CAPENTER*)InterlockedExchangeAddPtr( (SIZE_T*)(*CpuPtr), size);
EP_Retry:
	    ld8	    r29 = [r31]            // refresh **CpuPtr
        ;;
        mov.m   ar.ccv = r29           // save old value
        add     r27 = r29, r30         // r27 is proposed value
        ;;
        cmpxchg8.acq r27=[r31], r27, ar.ccv  // r27 now RecPtr
        ;;
        cmp.ne  p6 = r27, r29
 (p6)   br.cond.dptk.few EP_Retry
        add     r31 = r30, r27         // RecPtr+size
        ;;

// r30=size, r27=RecPtr
//      if( (((SIZE_T)RecPtr)+size) >= *(CpuPtr+1) )
        cmp.geu p6 = r31, r28   	   // r28 = *(CpuPtr+1)
 (p6)   br.ret.sptk.clr brp
        add     r30 = -4, r30          // RecSize doesn't include header
        ;;

        shl     r30 = r30, 16          // shift up 2 bytes
        ;;
        adds    r30 = 6, r30           // RecType 6 in low byte
        ;;
        st8     [r27] = r30, 8         // copy RecType & size to RecPtr+0(8)
        ;;
        st8     [r27] = r32, 8         // copy A0 (Current) to RecPtr+8(8)
        mov.m   r31 = ar.itc           // get TS
 (p7)   mov     r29 = 4                // PMD[4]
        ;;
        st8     [r27] = r31, 8         // copy TS to RecPtr+16(8)
 (p7)   mov     r30 = PMD[r29]         // get PMD[4]
        ;;
 (p7)   st8     [r27] = r30, 8         // copy to RecPtr+24(8)
 (p8)   mov     r29 = 5                // PMD[5]
        ;;
 (p8)   mov     r30 = PMD[r29]         // get PMD[5]
        ;;
 (p8)   st8     [r27] = r30, 8         // copy to RecPtr+32(8)
        br.ret.sptk.clr brp
        LEAF_EXIT(_CAP_End_Profiling2)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\exdsptch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exceptions and the unwinding of
    procedure call frames.

Author:

    William K. Cheung (wcheung) 23-Dec-1995

    based on the version by David N. Cutler (davec) 11-Sep-1990

Environment:

    Any mode.

Revision History:

    ATM Shafiqul Khalid [askhalid] 8-23-99
    Added RtlAddFunctionTable and RtlDeleteFunctionTable

--*/


#include "ntrtlp.h"

#if defined(NTOS_KERNEL_RUNTIME)

//
// Define function address table for kernel mode.
//
// This table is used to initialize the global history table.
//

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    );

VOID
KiExceptionDispatch (
    VOID
    );

PVOID RtlpFunctionAddressTable[] = {
    &KiExceptionDispatch,
    &KiDispatchException,
    &RtlDispatchException,
    &RtlpExecuteEmHandlerForException,
    &__C_specific_handler,
    &RtlUnwindEx,
    NULL
    };

#else

VOID
KiUserExceptionDispatch (
    VOID
    );

PVOID RtlpFunctionAddressTable[] = {
    &KiUserExceptionDispatch,
    &RtlDispatchException,
    &RtlpExecuteEmHandlerForException,
    &__C_specific_handler,
    &RtlUnwindEx,
    NULL
    };

#endif

PRUNTIME_FUNCTION
RtlLookupStaticFunctionEntry(
    IN ULONG_PTR ControlPc,
    OUT PBOOLEAN InImage
    );

PRUNTIME_FUNCTION
RtlLookupDynamicFunctionEntry(
    IN ULONG_PTR ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp
    );



//
// Define local macros.
//
// Raise noncontinuable exception with associated exception record.
//

#define IS_HANDLER_DEFINED(f, base)                                \
    (f->UnwindInfoAddress &&                                       \
        (((PUNWIND_INFO)(base+f->UnwindInfoAddress))->Flags & 0x3))

#define HANDLER(f, base, target)						\
(((PUNWIND_INFO)(base + f->UnwindInfoAddress))->Version <= 2)	   ?            \
    ((PEXCEPTION_ROUTINE)                                                       \
        (*(PULONGLONG) ((LONGLONG)target +                                      \
        (*(PULONGLONG) (base + f->UnwindInfoAddress + sizeof(UNWIND_INFO)  +    \
        (((PUNWIND_INFO) (base + f->UnwindInfoAddress))->DataLength * sizeof(ULONGLONG))))))) : \
    ((PEXCEPTION_ROUTINE)                                                       \
        (base +			                                \
        (*(PULONG) (base + f->UnwindInfoAddress + sizeof(UNWIND_INFO)  +        \
        (((PUNWIND_INFO) (base + f->UnwindInfoAddress))->DataLength * sizeof(ULONGLONG))))))
	
#define RAISE_EXCEPTION(Status, ExceptionRecordt) {                \
    EXCEPTION_RECORD ExceptionRecordn;                             \
                                                                   \
    ExceptionRecordn.ExceptionCode = Status;                       \
    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE;    \
    ExceptionRecordn.ExceptionRecord = ExceptionRecordt;           \
    ExceptionRecordn.NumberParameters = 0;                         \
    RtlRaiseException(&ExceptionRecordn);                          \
    }


#define IS_SAME_FRAME(Frame1, Frame2)                              \
                        ( (Frame1.MemoryStackFp == Frame2.MemoryStackFp) &&            \
                          (Frame1.BackingStoreFp == Frame2.BackingStoreFp) )

#define INITIALIZE_FRAME(Frame)                                    \
    Frame.MemoryStackFp = Frame.BackingStoreFp = 0

#define CHECK_MSTACK_FRAME(Establisher, Target)                            \
    ((Establisher.MemoryStackFp < LowStackLimit) ||                        \
     (Establisher.MemoryStackFp > HighStackLimit) ||                       \
     ((Target.MemoryStackFp != 0) &&                                       \
      (Target.MemoryStackFp < Establisher.MemoryStackFp)) || \
     ((Establisher.MemoryStackFp & 0x3) != 0))

#define CHECK_BSTORE_FRAME(Establisher, Target)                               \
    ((Establisher.BackingStoreFp < LowBStoreLimit) ||                         \
     (Establisher.BackingStoreFp > HighBStoreLimit) ||                        \
     ((Target.BackingStoreFp != 0) &&                                         \
      (Target.BackingStoreFp > Establisher.BackingStoreFp)) ||  \
     ((Establisher.BackingStoreFp & 0x7) != 0))

VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    );

ULONGLONG
RtlpVirtualUnwind (
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    );

PRUNTIME_FUNCTION
RtlpLookupFunctionEntry (
    IN ULONGLONG ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp,
    IN OUT PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONGLONG ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp
    )

/*++

Routine Description:

    This function searches the currently active function tables for an
    entry that corresponds to the specified PC value.

Arguments:

    ControlPc - Supplies the virtual address of an instruction bundle
        within the specified function.

    ImageBase - Returns the base address of the module to which the
                function belongs.

    TargetGp - Returns the global pointer value of the module.


Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{
    return RtlpLookupFunctionEntry ( ControlPc,
                                     ImageBase,
                                     TargetGp,
                                     NULL
                                     );

}

PRUNTIME_FUNCTION
RtlpLookupFunctionEntry (
    IN ULONGLONG ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp,
    IN OUT PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function searches the currently active function tables for an
    entry that corresponds to the specified PC value.

Arguments:

    ControlPc - Supplies the virtual address of an instruction bundle
        within the specified function.

    ImageBase - Returns the base address of the module to which the
                function belongs.

    TargetGp - Returns the global pointer value of the module.

    HistoryTable - Supplies an optional pointer to an unwind history table.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{

    ULONG64 BaseAddress;
    ULONG64 BeginAddress;
    ULONG64 EndAddress;
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LONG High;
    ULONG Index;
    LONG Middle;
    LONG Low;
    ULONG RelativePc;
    ULONG Size;
    ULONG SizeOfExceptionTable;

    //
    // Attempt to find an image that contains the specified control PC. If
    // an image is found, then search its function table for a function table
    // entry that contains the specified control PC. If an image is not found
    // then search the dynamic function table for an image that contains the
    // specified control PC.
    //
    // If a history table is supplied and search is specfied, then the current
    // operation that is being performed is the unwind phase of an exception
    // dispatch followed by a unwind. 
    //

    if ((ARGUMENT_PRESENT(HistoryTable)) &&
        (HistoryTable->Search != UNWIND_HISTORY_TABLE_NONE)) {

        //
        // Search the global unwind history table if there is a chance of a
        // match.
        //

        if (HistoryTable->Search == UNWIND_HISTORY_TABLE_GLOBAL) {
            if ((ControlPc >= RtlpUnwindHistoryTable.LowAddress) &&
                (ControlPc < RtlpUnwindHistoryTable.HighAddress)) {

                for (Index = 0; Index < RtlpUnwindHistoryTable.Count; Index += 1) {
                    BaseAddress = RtlpUnwindHistoryTable.Entry[Index].ImageBase;
                    FunctionEntry = RtlpUnwindHistoryTable.Entry[Index].FunctionEntry;
                    BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                    EndAddress = FunctionEntry->EndAddress + BaseAddress;
                    if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                        *ImageBase = BaseAddress;
                        *TargetGp = RtlpUnwindHistoryTable.Entry[Index].Gp;
                        return FunctionEntry;
                    }
                }
            }

            HistoryTable->Search = UNWIND_HISTORY_TABLE_LOCAL;
        }

        //
        // Search the dynamic unwind history table if there is a chance of a
        // match.
        //

        if ((ControlPc >= HistoryTable->LowAddress) &&
            (ControlPc < HistoryTable->HighAddress)) {
    
            for (Index = 0; Index < HistoryTable->Count; Index += 1) {
                BaseAddress = HistoryTable->Entry[Index].ImageBase;
                FunctionEntry = HistoryTable->Entry[Index].FunctionEntry;
                BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                EndAddress = FunctionEntry->EndAddress + BaseAddress;
                if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                    *ImageBase = BaseAddress;
                    *TargetGp = HistoryTable->Entry[Index].Gp;
                    return FunctionEntry;
                }
            }
        }
    }

    //
    // There was not a match in either of the unwind history tables so attempt
    // to find a matching entry in the loaded module list.
    //

    FunctionTable = RtlLookupFunctionTable(
                                (PVOID)ControlPc,
                                (PVOID *)ImageBase,
                                TargetGp,
                                &SizeOfExceptionTable
                                );

    //
    // If a function table is located, then search the table for a
    // function table entry for the specified PC.
    //

    __try {

        if (FunctionTable != NULL) {

            //
            // Initialize search indices.
            //

            Low = 0;
            High = (SizeOfExceptionTable / sizeof(RUNTIME_FUNCTION)) - 1;
            RelativePc = (ULONG)(ControlPc - *ImageBase);

            //
            // Perform binary search on the function table for a function table
            // entry that subsumes the specified PC.
            //

            while (High >= Low) {

                //
                // Compute next probe index and test entry. If the specified PC
                // is greater than of equal to the beginning address and less
                // than the ending address of the function table entry, then
                // return the address of the function table entry. Otherwise,
                // continue the search.
                //

                Middle = (Low + High) >> 1;
                FunctionEntry = &FunctionTable[Middle];

                if (RelativePc < FunctionEntry->BeginAddress) {
                    High = Middle - 1;

                } else if (RelativePc >= FunctionEntry->EndAddress) {
                    Low = Middle + 1;

                } else {
                    break;
                }
            }

            if (High < Low) {
                FunctionEntry = NULL;
            }

        } else {

            //
            // There was not a match in the loaded module list so attempt to find
            // a matching entry in the dynamic function table list.
            //

    #if !defined(NTOS_KERNEL_RUNTIME)

            FunctionEntry = RtlLookupDynamicFunctionEntry(ControlPc,
                                                          ImageBase,
                                                          TargetGp);

    #else

            FunctionEntry = NULL;

    #endif  // NTOS_KERNEL_RUNTIME

        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          

          DbgPrint("NTDLL:RtlpLookupFunctionEntry exception occured during function lookup. Status = %lx\n", GetExceptionCode());
          FunctionEntry = NULL;
    }

    //
    // If a function table entry was located, search is not specified, and
    // the specfied history table is not full, then attempt to make an entry
    // in the history table.
    //

    if (FunctionEntry != NULL) {
        if (ARGUMENT_PRESENT(HistoryTable) &&
            (HistoryTable->Search == UNWIND_HISTORY_TABLE_NONE) &&
            (HistoryTable->Count < UNWIND_HISTORY_TABLE_SIZE)) {
    
            Index = HistoryTable->Count;
            HistoryTable->Count += 1;
            HistoryTable->Entry[Index].ImageBase = *ImageBase;
            HistoryTable->Entry[Index].Gp = *TargetGp;
            HistoryTable->Entry[Index].FunctionEntry = FunctionEntry;
            BeginAddress = FunctionEntry->BeginAddress + *ImageBase;
            EndAddress = FunctionEntry->EndAddress + *ImageBase;
            if (BeginAddress < HistoryTable->LowAddress) {
                HistoryTable->LowAddress = BeginAddress;
    
            }
    
            if (EndAddress > HistoryTable->HighAddress) {
                HistoryTable->HighAddress = EndAddress;
            }

        }
    }

    return FunctionEntry;
}

VOID
RtlpRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the raise exception system service.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{
    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONGLONG ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONGLONG NextPc;
    NTSTATUS Status;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.  
    //

    RtlCaptureNonVolatileContext(&ContextRecord);
    ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
    FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
                                           &ImageBase,
                                           &TargetGp,
                                           NULL);

    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.StIIP = NextPc + 8;
    ContextRecord.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.StIIP;
#if defined(NTOS_KERNEL_RUNTIME)

        if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
            return;
    
        }

        Status = ZwRaiseException(ExceptionRecord, &ContextRecord, FALSE);

#else

    if (ZwQueryPortInformationProcess() == FALSE) {
        if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
            return;
        }

    } else {
        Status = ZwRaiseException(ExceptionRecord, &ContextRecord, TRUE);
    }

#endif

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
    return;
}


VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the raise exception system service.

    N.B. This routine is a shell routine that simply calls another routine
         to do the real work. The reason this is done is to avoid a problem
         in try/finally scopes where the last statement in the scope is a
         call to raise an exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{
    RtlpRaiseException(ExceptionRecord);
    return;
}

#pragma warning(disable:4717)       // recursive function
VOID
RtlpRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as noncontinuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{
    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONGLONG ControlPc;
    ULONGLONG NextPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    EXCEPTION_RECORD ExceptionRecord;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.
    //

    RtlCaptureNonVolatileContext(&ContextRecord);
    ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
    FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
                                           &ImageBase,
                                           &TargetGp,
                                           NULL);

    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.StIIP = NextPc + 8;
    ContextRecord.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.StIIP;
#if defined(NTOS_KERNEL_RUNTIME)

    RtlDispatchException(&ExceptionRecord, &ContextRecord);
    Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

#else

    //
    // Attempt to dispatch the exception.
    //
    // N.B. This exception is non-continuable.
    //

    if (ZwQueryPortInformationProcess() == FALSE) {
        RtlDispatchException(&ExceptionRecord, &ContextRecord);
        Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

    } else {
        Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, TRUE);
    }

#endif

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
    return;
}

VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as noncontinuable with no parameters.

    N.B. This routine is a shell routine that simply calls another routine
         to do the real work. The reason this is done is to avoid a problem
         in try/finally scopes where the last statement in the scope is a
         call to raise an exception.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{
    RtlpRaiseStatus(Status);
    return;
}


VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

    Obsolete API in IA64.

--*/

{
    return;
}


VOID
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue,
    IN PCONTEXT OriginalContext
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

    OriginalContext - Supplies a pointer to a context record that can be used
        to store context druing the unwind operation.
 
 Return Value:

    None.

--*/

{

    //
    // Call real unwind routine specifying a history table address as an extra
    // argument.
    //

    RtlUnwindEx(TargetFrame,
                TargetIp,
                ExceptionRecord,
                ReturnValue,
                OriginalContext,
                NULL);

    return;
}

VOID
RtlUnwindEx (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue,
    IN PCONTEXT OriginalContext,
    IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

    OriginalContext - Supplies a pointer to a context record that can be used
        to store context druing the unwind operation.

    HistoryTable - Supplies an optional pointer to an unwind history table.

 Return Value:

    None.

--*/

{
    PCONTEXT CurrentContext;
    ULONGLONG TargetGp;
    ULONGLONG ImageBase;
    ULONGLONG ControlPc;
    ULONGLONG NextPc;
    ULONG ExceptionFlags;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    FRAME_POINTERS EstablisherFrame;
    EXCEPTION_RECORD ExceptionRecord1;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONGLONG HighStackLimit;
    ULONGLONG LowStackLimit;
    ULONGLONG HighBStoreLimit;
    ULONGLONG LowBStoreLimit;
    ULONG Size;
    BOOLEAN InFunction;
    PCONTEXT PreviousContext;
    PCONTEXT TempContext;
    CONTEXT LocalContext;
    //
    // Get current memory stack and backing store limits, capture the
    // current context, virtually unwind to the caller of this routine,
    // get the initial PC value, and set the unwind target address.
    //
    // N.B. The target gp value is found in the input context record.
    //      The unwinder guarantees that it will not be destroyed
    //      as it is just a scratch register.
    //

    CurrentContext = OriginalContext;
    PreviousContext = &LocalContext;
    RtlCaptureNonVolatileContext(CurrentContext);

    //
    // If a history table is specified, then set to search history table.
    //

    if (ARGUMENT_PRESENT(HistoryTable)) {
        HistoryTable->Search = UNWIND_HISTORY_TABLE_GLOBAL;
    }

    //
    // Before getting the limits from the TEB, must flush the RSE to have
    // the OS to grow the backing store and update the BStoreLimit.
    //

    Rtlp64GetStackLimits(&LowStackLimit, &HighStackLimit);
    Rtlp64GetBStoreLimits(&LowBStoreLimit, &HighBStoreLimit);

    ControlPc = RtlIa64InsertIPSlotNumber((CurrentContext->BrRp-16), 2);
    FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
                                           &ImageBase,
                                           &TargetGp,
                                           HistoryTable);

    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              CurrentContext,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ControlPc = NextPc;
    CurrentContext->StIIP = (ULONGLONG)TargetIp;

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then a normal unwind
    // is being performed. Otherwise, an exit unwind is being performed.
    //

    ExceptionFlags = EXCEPTION_UNWINDING;
    if (TargetFrame.BackingStoreFp == 0 && TargetFrame.MemoryStackFp == 0) {
        ExceptionRecord->ExceptionFlags |= EXCEPTION_EXIT_UNWIND;
    }

    //
    // Scan backward through the call frame hierarchy and call exception
    // handlers until the target frame of the unwind is reached.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //


        FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               &TargetGp,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then
        // virtually unwind to the caller of the routine to obtain the
        // virtual frame pointer of the establisher, but don't update
        // the context record.
        //

        if (FunctionEntry != NULL) {
            RtlpCopyContext(PreviousContext, CurrentContext);
            NextPc = RtlVirtualUnwind(ImageBase,
                                       ControlPc,
                                       FunctionEntry,
                                       PreviousContext,
                                       &InFunction,
                                       &EstablisherFrame,
                                       NULL);

        //
        // If virtual frame is not within the specified limits, unaligned,
        // or the target frame is below the virtual frame and an exit
        // unwind is not being performed, then raise the exception
        // STATUS_BAD_STACK or STATUS_BAD_BSTORE. Otherwise,
        // check to determine if the current routine has an exception
        // handler.
        //

            if (CHECK_MSTACK_FRAME(EstablisherFrame, TargetFrame)) {

                RAISE_EXCEPTION(STATUS_BAD_STACK, ExceptionRecord);

            } else if (CHECK_BSTORE_FRAME(EstablisherFrame, TargetFrame)) {

                RAISE_EXCEPTION(STATUS_BAD_STACK, ExceptionRecord);

            } else if (InFunction && IS_HANDLER_DEFINED(FunctionEntry, ImageBase)) {

                //
                // The frame has an exception handler.
                //
                // The handler (i.e. personality routine) has to be called to
                // execute any termination routines in this frame.
                //
                // The control PC, establisher frame pointer, the address
                // of the function table entry, and the address of the
                // context record are all stored in the dispatcher context.
                // This information is used by the unwind linkage routine
                // and can be used by the exception handler itself.
                //

                DispatcherContext.ControlPc = ControlPc;
                DispatcherContext.FunctionEntry = FunctionEntry;
                DispatcherContext.ImageBase = ImageBase;
                DispatcherContext.ContextRecord = CurrentContext;
                DispatcherContext.TargetGp = TargetGp;
                DispatcherContext.Index = 0;

                //
                // Call the exception handler.
                //

                do {

                    //
                    // If the establisher frame is the target of the unwind
                    // operation, then set the target unwind flag.
                    //

                    if (IS_SAME_FRAME(EstablisherFrame,TargetFrame)) {
                        ExceptionFlags |= EXCEPTION_TARGET_UNWIND;
                    }

                    ExceptionRecord->ExceptionFlags = ExceptionFlags;

                    //
                    // Set the specified return value in case the exception
                    // handler directly continues execution.
                    //

                    CurrentContext->IntV0 = (ULONGLONG)ReturnValue;

                    //
                    // A linkage routine written in assembler is used to
                    // actually call the actual exception handler. This is
                    // required by the exception handler that is associated
                    // with the linkage routine so it can have access to two
                    // sets of dispatcher context when it is called.
                    //

                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.HistoryTable = HistoryTable;
                    Disposition = RtlpExecuteEmHandlerForUnwind(
                                      ExceptionRecord,
                                      EstablisherFrame.MemoryStackFp,
                                      EstablisherFrame.BackingStoreFp,
                                      CurrentContext,
                                      &DispatcherContext,
                                      TargetGp,
                                      HANDLER(FunctionEntry, ImageBase, TargetGp));

                    //
                    // Clear target unwind and collided unwind flags.
                    //

                    ExceptionFlags &= ~(EXCEPTION_COLLIDED_UNWIND |
                                                EXCEPTION_TARGET_UNWIND);

                    //
                    // Case on the handler disposition.
                    //

                    switch (Disposition) {

                    //
                    // The disposition is to continue the search.
                    //
                    // If the target frame has not been reached, then
                    // swap context pointers.
                    //

                    case ExceptionContinueSearch :

                        if (!IS_SAME_FRAME(EstablisherFrame, TargetFrame)) {
                            TempContext = CurrentContext;
                            CurrentContext = PreviousContext;
                            PreviousContext = TempContext;
                        }
                        break;

                    //
                    // The disposition is collided unwind.
                    //
                    // Set the target of the current unwind to the context
                    // record of the previous unwind, and reexecute the
                    // exception handler from the collided frame with the
                    // collided unwind flag set in the exception record.
                    //
                    // Copy the context of the previous unwind and
                    // virtually unwind to the caller of the extablisher,
                    // then set the target of the current unwind to the
                    // dispatcher context of the previous unwind, and
                    // reexecute the exception handler from the collided
                    // frame with the collided unwind flag set in the
                    // exception record

                    case ExceptionCollidedUnwind :
                        ControlPc = DispatcherContext.ControlPc;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        ImageBase = DispatcherContext.ImageBase;
                        TargetGp = DispatcherContext.TargetGp;
                        RtlpCopyContext(OriginalContext,
                                      DispatcherContext.ContextRecord);
                        
                        CurrentContext = OriginalContext;
                        PreviousContext = &LocalContext;
                        RtlpCopyContext(PreviousContext,
                                      CurrentContext);

                        NextPc = RtlVirtualUnwind(ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  PreviousContext,
                                                  &InFunction,
                                                  &EstablisherFrame,
                                                  NULL);

                        HistoryTable = DispatcherContext.HistoryTable;
                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        break;

                    //
                    // All other disposition values are invalid.
                    //
                    // Raise invalid disposition exception.
                    //

                    default :
                        RAISE_EXCEPTION(STATUS_INVALID_DISPOSITION, ExceptionRecord);
                    }

                } while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

            } else {

                //
                // If the target frame has not been reached, then swap
                // context pointers.
                //

                if (!IS_SAME_FRAME(EstablisherFrame, TargetFrame) ||
                     (IS_SAME_FRAME(EstablisherFrame, TargetFrame) &&
                      CurrentContext->RsBSP != TargetFrame.BackingStoreFp)) {
                    TempContext = CurrentContext;
                    CurrentContext = PreviousContext;
                    PreviousContext = TempContext;                      
                }
            }

        } else {

            //
            // No function table entry was found.
            //

            NextPc = RtlIa64InsertIPSlotNumber((CurrentContext->BrRp-16), 2);
            CurrentContext->StIFS = CurrentContext->RsPFS;
            CurrentContext->RsBSP = RtlpRseShrinkBySOL (CurrentContext->RsBSP, CurrentContext->StIFS);
            CurrentContext->RsBSPSTORE = CurrentContext->RsBSP;
        }

        //
        // Set point at which control left the previous routine.
        //

        ControlPc = NextPc;

    } while (((EstablisherFrame.MemoryStackFp < HighStackLimit) ||
             (EstablisherFrame.BackingStoreFp > LowBStoreLimit)) &&
            !(IS_SAME_FRAME(EstablisherFrame, TargetFrame)));

    //
    // If the establisher stack pointer is equal to the target frame
    // pointer, then continue execution. Otherwise, an exit unwind was
    // performed or the target of the unwind did not exist and the
    // debugger and subsystem are given a second chance to handle the
    // unwind.
    //

    if (IS_SAME_FRAME(EstablisherFrame, TargetFrame)) {
        CurrentContext->IntGp = TargetGp;
        CurrentContext->StIPSR &= ~(0x3i64 << PSR_RI);
        CurrentContext->IntV0 = (ULONGLONG)ReturnValue;
        CurrentContext->StIIP = (ULONGLONG)TargetIp;
        RtlRestoreContext(CurrentContext, ExceptionRecord);
    } else {
        ZwRaiseException(ExceptionRecord, CurrentContext, FALSE);
    }
}

BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a frame based
    handler by searching backwards through the call frames by unwinding
    the RSE backing store as well as the memory stack.  The search begins
    with the frame specified in the context record and continues backward
    until either a handler is found that handles the exception, the stack
    and/or the backing store is found to be invalid (i.e., out of limits
    or unaligned), or the end of the call hierarchy is reached.

    As each frame is encountered, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called. If the
    handler does not handle the exception, then the prologue of the routine
    is undone to "unwind" the effect of the prologue and then the next
    frame is examined.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{
    ULONGLONG TargetGp;
    ULONGLONG ImageBase;
    CONTEXT ContextRecordEm;
    ULONGLONG ControlPc;
    ULONGLONG NextPc;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    ULONG ExceptionFlags;
    PRUNTIME_FUNCTION FunctionEntry;
    FRAME_POINTERS EstablisherFrame;
    FRAME_POINTERS TargetFrame;       // to be removed in the future
    ULONGLONG HighStackLimit;
    ULONGLONG LowStackLimit;
    ULONGLONG HighBStoreLimit;
    ULONGLONG LowBStoreLimit;
    FRAME_POINTERS NestedFrame;
    FRAME_POINTERS NullFrame;
    ULONG Index;
    ULONG Size;
    BOOLEAN InFunction;
    PUNWIND_HISTORY_TABLE HistoryTable;
    UNWIND_HISTORY_TABLE UnwindTable;

#ifndef NTOS_KERNEL_RUNTIME
    if (RtlCallVectoredExceptionHandlers(ExceptionRecord,ContextRecord)) {
        return TRUE;
    }
#endif // NTOS_KERNEL_RUNTIME

    //
    // Get the current stack limits, make a copy of the context record,
    // get the initial PC value, capture the exception flags, and set
    // the nested exception frame pointer.
    //

    Rtlp64GetStackLimits(&LowStackLimit, &HighStackLimit);
    Rtlp64GetBStoreLimits(&LowBStoreLimit, &HighBStoreLimit);
    RtlpCopyContext(&ContextRecordEm, ContextRecord);

    if ( (ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION) &&
         (ExceptionRecord->NumberParameters == 5) &&
         (ExceptionRecord->ExceptionInformation[4] & (1 << ISR_X)) )
    {
        ControlPc = ExceptionRecord->ExceptionInformation[3];
        ControlPc = RtlIa64InsertIPSlotNumber(ControlPc,
                               ((ContextRecordEm.StIPSR >> PSR_RI) & 0x3));
    } else {
        ControlPc = RtlIa64InsertIPSlotNumber(ContextRecordEm.StIIP,
                               ((ContextRecordEm.StIPSR >> PSR_RI) & 0x3));
    }

    ExceptionFlags = ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE;

    INITIALIZE_FRAME(NestedFrame);
    INITIALIZE_FRAME(NullFrame);

    //
    // Initialize the unwind history table.
    //

    HistoryTable = &UnwindTable;
    HistoryTable->Count = 0;
    HistoryTable->Search = UNWIND_HISTORY_TABLE_NONE;
    HistoryTable->LowAddress = - 1;
    HistoryTable->HighAddress = 0;

    //
    // Start with the frame specified by the context record and search
    // backwards through the chain of call frames attempting to find an
    // exception handler that will handle the exception.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //


        FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               &TargetGp,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then
        // virtually unwind to the caller of the current routine to
        // obtain the virtual frame pointer of the establisher and check
        // if there is an exception handler for the frame.
        //

        if (FunctionEntry != NULL) {
            NextPc = RtlVirtualUnwind(ImageBase,
                                      ControlPc,
                                      FunctionEntry,
                                      &ContextRecordEm,
                                      &InFunction,
                                      &EstablisherFrame,
                                      NULL);

            //
            // If either one or both of the two virtual frame pointers are
            // not within the specified stack limits or unaligned,
            // then set the stack invalid flag in the exception record and
            // return exception not handled.  Otherwise, check if the
            // current routine has an exception handler.
            //

            if (CHECK_MSTACK_FRAME(EstablisherFrame, NullFrame)) {

                ExceptionFlags |= EXCEPTION_STACK_INVALID;
                break;

            } else if (CHECK_BSTORE_FRAME(EstablisherFrame, NullFrame)) {

                ExceptionFlags |= EXCEPTION_STACK_INVALID;
                break;

            } else if ((IS_HANDLER_DEFINED(FunctionEntry, ImageBase) && InFunction)) {

                //
                // The handler (i.e. personality routine) has to be called
                // to search for an exception handler in this frame.  The
                // handler must be executed by calling a stub routine that
                // is written in assembler.  This is required because up
                // level addressing of this routine information is required
                // when a nested exception is encountered.
                //

                DispatcherContext.ControlPc = ControlPc;
                DispatcherContext.FunctionEntry = FunctionEntry;
                DispatcherContext.ImageBase = ImageBase;
                DispatcherContext.TargetGp = TargetGp;
                DispatcherContext.Index = 0;

                do {

                    ExceptionRecord->ExceptionFlags = ExceptionFlags;

                    if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
                        Index = RtlpLogExceptionHandler(
                                        ExceptionRecord,
                                        ContextRecord,
                                        (ULONG)ControlPc,
                                        FunctionEntry,
                                        sizeof(RUNTIME_FUNCTION));
                    }

                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.ContextRecord = &ContextRecordEm;
                    DispatcherContext.HistoryTable = HistoryTable;
                    Disposition = RtlpExecuteEmHandlerForException(
                                      ExceptionRecord,
                                      EstablisherFrame.MemoryStackFp,
                                      EstablisherFrame.BackingStoreFp,
                                      ContextRecord,
                                      &DispatcherContext,
                                      TargetGp,
                                      HANDLER(FunctionEntry, ImageBase, TargetGp));

                    if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
                        RtlpLogLastExceptionDisposition(Index, Disposition);
                    }

                    ExceptionFlags |=
                        (ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE);

                    ExceptionFlags &= ~EXCEPTION_COLLIDED_UNWIND;

                    //
                    // If the current scan is within a nested context and the
                    // frame just examined is the end of the nested region,
                    // then clear the nested context frame and the nested
                    // exception flag in the exception flags.
                    //

                    if (IS_SAME_FRAME(NestedFrame, EstablisherFrame)) {
                        ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
                        INITIALIZE_FRAME(NestedFrame);
                    }

                    //
                    // Case on the handler disposition.
                    //

                    switch (Disposition) {

                    //
                    // The disposition is to continue execution.
                    //
                    // If the exception is not continuable, then raise the
                    // exception STATUS_NONCONTINUABLE_EXCEPTION.  Otherwise,
                    // return exception handled.
                    //

                    case ExceptionContinueExecution:
                        if ((ExceptionFlags & EXCEPTION_NONCONTINUABLE) != 0) {
                            RAISE_EXCEPTION(STATUS_NONCONTINUABLE_EXCEPTION,
                                            ExceptionRecord);
                        } else {
                            return TRUE;
                        }

                    //
                    // The disposition is to continue the search.
                    //
                    // Get the next frame address and continue the search.
                    //

                    case ExceptionContinueSearch:
                        break;

                    //
                    // The disposition is nested exception.
                    //
                    // Set the nested context frame to the establisher frame
                    // address and set the nested exception flag in the
                    // exception flags.
                    //

                    case ExceptionNestedException:
                        ExceptionFlags |= EXCEPTION_NESTED_CALL;
                        if (DispatcherContext.EstablisherFrame.MemoryStackFp > NestedFrame.MemoryStackFp) {
                            NestedFrame = DispatcherContext.EstablisherFrame;
                        }
                        break;

                    //
                    // The disposition is hitting a frame processed by a
                    // previous unwind.
                    //
                    // Set the target of the current dispatch to the context
                    // record of the previous unwind
                    //

                    case ExceptionCollidedUnwind:
                        ControlPc = DispatcherContext.ControlPc;
                        NextPc = ControlPc;
                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        ImageBase = DispatcherContext.ImageBase;
                        TargetGp = DispatcherContext.TargetGp;
                        RtlpCopyContext(&ContextRecordEm,
                                      DispatcherContext.ContextRecord);
                        HistoryTable = DispatcherContext.HistoryTable;
                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
                        break;

                    //
                    // All other disposition values are invalid.
                    //
                    // Raise invalid disposition exception.
                    //

                    default:
                        RAISE_EXCEPTION(STATUS_INVALID_DISPOSITION, ExceptionRecord);
                        break;
                    }

                } while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

            }

        } else {

            //
            // No function table entry is found.
            //

            NextPc = RtlIa64InsertIPSlotNumber((ContextRecordEm.BrRp-16), 2);
            ContextRecordEm.StIFS = ContextRecordEm.RsPFS;
            ContextRecordEm.RsBSP = RtlpRseShrinkBySOL (ContextRecordEm.RsBSP, ContextRecordEm.StIFS);
            ContextRecordEm.RsBSPSTORE = ContextRecordEm.RsBSP;

            if (NextPc == ControlPc) {
                break;
            }
        }

        //
        // Set the point at which control left the previous routine.
        //

        ControlPc = NextPc;

    } while ( (ContextRecordEm.IntSp < HighStackLimit) ||
              (ContextRecordEm.RsBSP > LowBStoreLimit) );

    //
    // Could not handle the exception.
    //
    // Set final exception flags and return exception not handled.
    //

    ExceptionRecord->ExceptionFlags = ExceptionFlags;
    return FALSE;
}


ULONGLONG
RtlpVirtualUnwind (
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is place in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

    N.B. This function copies the specified context record and only computes
         the establisher frame and whether control is actually in a function.

Arguments:

    ImageBase - Base address of the module to which the function belongs.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    InFunction - Supplies a pointer to a variable that receives whether the
        control PC is within the current function.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{

    CONTEXT LocalContext;

    //
    // Copy the context record so updates will not be reflected in the
    // original copy and then virtually unwind to the caller of the
    // specified control point.
    //

    RtlCopyMemory((PVOID)&LocalContext, ContextRecord, sizeof(CONTEXT));
    return RtlVirtualUnwind(ImageBase,
                            ControlPc,
                            FunctionEntry,
                            &LocalContext,
                            InFunction,
                            EstablisherFrame,
                            ContextPointers);
}


VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    )

/*++

Routine Description:

    This function copies the nonvolatile context and the volatile integer context 
    required for exception dispatch and unwind from the specified source context 
    record to the specified destination context record.  Note the volatile integer 
    context must be included since leaf function may save some of the non-volatile context in 
    volatile registers. For example the lc register might be saved in a tempoary register by a 
    function like memcpy.  The lc needs to be properly restored when an unwind occurs.

Arguments:

    Destination - Supplies a pointer to the destination context record.

    Source - Supplies a pointer to the source context record.

Return Value:

    None.

--*/

{

    //
    // Copy nonvolatile context required for exception dispatch and unwind.
    //

    Destination->ContextFlags = Source->ContextFlags;

    //
    // Copy FltS0-FltS3
    //

    RtlCopyMemory(&Destination->FltS0, 
                  &Source->FltS0, 
                  FIELD_OFFSET(CONTEXT, FltS3) + sizeof(Source->FltS3) - FIELD_OFFSET(CONTEXT, FltS0));

    //
    // Copy FltS4-FltS19
    //

    RtlCopyMemory(&Destination->FltS4, 
                  &Source->FltS4, 
                  FIELD_OFFSET(CONTEXT, FltS19) + sizeof(Source->FltS19) - FIELD_OFFSET(CONTEXT, FltS4));


    //
    // Copy StFPSR to StFDR, includes all of the interger conext.
    //

    RtlCopyMemory(&Destination->StFPSR, 
              &Source->StFPSR, 
              FIELD_OFFSET(CONTEXT, StFDR) + sizeof(Source->StFDR) - FIELD_OFFSET(CONTEXT, StFPSR));



}


#if !defined(NTOS_KERNEL_RUNTIME)

LIST_ENTRY RtlpDynamicFunctionTable;

PLIST_ENTRY
RtlGetFunctionTableListHead (
    VOID
    )

/*++

Routine Description:

    This function returns the address of the dynamic function table list head.

Arguments:

    None.

Return value:

    The address of the dynamic function table list head is returned.

--*/

{

    return &RtlpDynamicFunctionTable;
}

BOOLEAN
RtlAddFunctionTable(
    IN PRUNTIME_FUNCTION FunctionTable,
    IN ULONG             EntryCount,
    IN ULONGLONG         BaseAddress,
    IN ULONGLONG         TargetGp
    )

/*++

Routine Description:

    Add a dynamic function table to the dynamic function table list. Dynamic
    function tables describe code generated at run-time. The dynamic function
    tables are searched via a call to RtlLookupDynamicFunctionEntry().
    Normally this is only invoked via calls to RtlpLookupFunctionEntry().

    The FunctionTable entries need not be sorted in any particular order. The
    list is scanned for a Min and Max address range and whether or not it is
    sorted. If the latter RtlLookupDynamicFunctionEntry() uses a binary
    search, otherwise it uses a linear search.

    The dynamic function entries will be searched only after a search
    through the static function entries associated with all current
    process images has failed.

Arguments:

   FunctionTable       Address of an array of function entries where
                       each element is of type RUNTIME_FUNCTION.

   EntryCount          The number of function entries in the array

   BaseAddress         Base address to calculate the real address  of the function table entry
   TargetGp            return back to RtlpLookupFunctionEntry for future query.

Return value:

   TRUE                if RtlAddFunctionTable completed successfully
   FALSE               if RtlAddFunctionTable completed unsuccessfully

--*/
{
    PDYNAMIC_FUNCTION_TABLE pNew;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG i;

    if (EntryCount == 0)
        return FALSE;

    //
    //  Allocate memory for this link list entry
    //

    pNew = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(DYNAMIC_FUNCTION_TABLE) );

    if (pNew != NULL) {
        PVOID LockCookie = NULL;

        pNew->FunctionTable = FunctionTable;
        pNew->EntryCount = EntryCount;
        NtQuerySystemTime( &pNew->TimeStamp );

        //
        // Scan the function table for Minimum/Maximum and to determine
        // if it is sorted. If the latter, we can perform a binary search.
        //

        FunctionEntry = FunctionTable;
        pNew->MinimumAddress = RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry);
        pNew->MaximumAddress = RF_END_ADDRESS(BaseAddress, FunctionEntry);
        pNew->Type = RF_SORTED;
        pNew->OutOfProcessCallbackDll = NULL;
        FunctionEntry++;

        for (i = 1; i < EntryCount; FunctionEntry++, i++) {
            if ((pNew->Type == RF_SORTED) &&
                (FunctionEntry->BeginAddress < FunctionTable[i-1].BeginAddress)) {
                pNew->Type = RF_UNSORTED;
            }
            if (RF_BEGIN_ADDRESS(BaseAddress, FunctionEntry) < pNew->MinimumAddress) {
                pNew->MinimumAddress = RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry);
            }
            if (RF_END_ADDRESS( BaseAddress, FunctionEntry) > pNew->MaximumAddress) {
                pNew->MaximumAddress = RF_END_ADDRESS( BaseAddress, FunctionEntry);
            }
        }

        //
        // Insert the new entry in the dynamic function table list.
        // Protect the insertion with the loader lock.
        //

        pNew->BaseAddress = BaseAddress;
        pNew->TargetGp    = TargetGp;

        LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
        __try {
            InsertTailList((PLIST_ENTRY)&RtlpDynamicFunctionTable, (PLIST_ENTRY)pNew);
        } __finally {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
        }

        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
RtlInstallFunctionTableCallback (
    IN ULONG64 TableIdentifier,
    IN ULONG64 BaseAddress,
    IN ULONG Length,
    IN ULONG64 TargetGp,
    IN PGET_RUNTIME_FUNCTION_CALLBACK Callback,
    IN PVOID Context,
    IN PCWSTR OutOfProcessCallbackDll OPTIONAL
    )

/*++

Routine Description:

    This function adds a dynamic function table to the dynamic function table
    list. A dynamic function table describe code that is generated at runtime.

Arguments:

    TableIdentifier - Supplies a value that identifies the dynamic function
        table callback.

        N.B. The two low order bits of this value must be set.

    BaseAddress - Supplies the base address of the code region covered by
        callback function.

    Length - Supplies the length of code region covered by the callback
        function.

    TargetGp - Supplies the target GP value for functions covered by the
        callback function.

    Callback - Supplies the address of the callback function that will be
        called to get function table entries for the functions covered by
        the specified region.

    Context - Supplies a context parameter that will be passed to the callback
        routine.

    OutOfProcessCallbackDll - Supplies an optional pointer to the path name of
        a DLL that can be used by the debugger to obtain function table entries
        from outside the process.

Return Value

    If the function table is successfully installed, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PDYNAMIC_FUNCTION_TABLE NewTable;
    SIZE_T Size;

    //
    // If the table identifier does not have the two low bits set, then return
    // FALSE.
    //
    // N.B. The two low order bits are required to be set in order to ensure
    //      that the table identifier does not collide with an actual address
    //      of a function table, i.e., this value is used to delete the entry.
    //

    if ((TableIdentifier & 0x3) != 3) {
        return FALSE;
    }

    //
    // If the length of the code region is greater than 2gb, then return
    // FALSE.
    //

    if ((LONG)Length < 0) {
        return FALSE;
    }

    //
    // Allocate a new dynamic function table.
    //

    Size = 0;
    if (ARGUMENT_PRESENT(OutOfProcessCallbackDll)) {
        Size = (wcslen(OutOfProcessCallbackDll) + 1) * sizeof(WCHAR);
    }

    NewTable = RtlAllocateHeap(RtlProcessHeap(),
                               0,
                               sizeof(DYNAMIC_FUNCTION_TABLE) + Size);

    //
    // If the allocation is successful, then add dynamic function table.
    //

    if (NewTable != NULL) {

        //
        // Initialize the dynamic function table callback entry.
        //

        NewTable->FunctionTable = (PRUNTIME_FUNCTION)TableIdentifier;
        NtQuerySystemTime(&NewTable->TimeStamp);
        NewTable->MinimumAddress = BaseAddress;
        NewTable->MaximumAddress = BaseAddress + Length;
        NewTable->BaseAddress = BaseAddress;
        NewTable->TargetGp = TargetGp;
        NewTable->Callback = Callback;
        NewTable->Context = Context;
        NewTable->Type = RF_CALLBACK;
        NewTable->OutOfProcessCallbackDll = NULL;
        if (ARGUMENT_PRESENT(OutOfProcessCallbackDll)) {
            NewTable->OutOfProcessCallbackDll = (PWSTR)(NewTable + 1);
            wcsncpy((PWSTR)(NewTable + 1), OutOfProcessCallbackDll, Size/sizeof(WCHAR));
            *((PWSTR)(((PUCHAR)(NewTable))+sizeof(DYNAMIC_FUNCTION_TABLE) + Size - sizeof(WCHAR))) = L'\0';
        }

        //
        // Insert the new dyanamic function table in the dynamic function table
        // list.
        //

        RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        InsertTailList(&RtlpDynamicFunctionTable, &NewTable->Links);
        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlDeleteFunctionTable (
    IN PRUNTIME_FUNCTION FunctionTable
    )
{

/*++

Routine Description:

    Remove a dynamic function table from the dynamic function table list.

Arguments:

   FunctionTable       Address of an array of function entries that
                       was passed in a previous call to RtlAddFunctionTable

Return Value

    TRUE - If function completed successfully
    FALSE - If function completed unsuccessfully

--*/

    PDYNAMIC_FUNCTION_TABLE CurrentEntry;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    BOOLEAN Status = FALSE;
    PVOID LockCookie = NULL;

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {

        //
        // Search the dynamic function table list for a match on the the function
        // table address.
        //

        Head = &RtlpDynamicFunctionTable;
        for (Next = Head->Blink; Next != Head; Next = Next->Blink) {
            CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
            if (CurrentEntry->FunctionTable == FunctionTable) {
                RemoveEntryList((PLIST_ENTRY)CurrentEntry);
                RtlFreeHeap( RtlProcessHeap(), 0, CurrentEntry );
                Status = TRUE;
                break;
            }
        }
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    return Status;
}

PRUNTIME_FUNCTION
RtlLookupDynamicFunctionEntry(
    IN ULONG_PTR ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp
    )

/*++

Routine Description:

  This function searches through the dynamic function entry
  tables and returns the function entry address that corresponds
  to the specified ControlPc. This routine does NOT perform the
  secondary function entry indirection. That is performed
  by RtlpLookupFunctionEntry().

  Argument:

     ControlPc           Supplies a ControlPc.
     ImageBase           OUT Base address for dynamic code

  Return Value

     NULL - No function entry found that contains the ControlPc.

     NON-NULL - Address of the function entry that describes the
                code containing ControlPC.

--*/

{
    PGET_RUNTIME_FUNCTION_CALLBACK Callback;
    PVOID Context;
    PDYNAMIC_FUNCTION_TABLE CurrentEntry;
    PLIST_ENTRY Next,Head;
    PRUNTIME_FUNCTION FunctionTable;
    PRUNTIME_FUNCTION FunctionEntry = NULL;
    LONG High;
    LONG Low;
    LONG Middle;
    SIZE_T BaseAddress;
    PVOID LockCookie = NULL;

    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T
    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T
    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T
    //
    // This code is not publicly documented, but there are clients of this code
    // that rely on the locking behavior of this function.  You cannot change
    // this next line of code to call TryEnter, or change the lock.  Both have
    // been done or considered before, both will break something.
    //
    // The TryEnter idea is bad because if a thread calls RtlAddFunctionTable
    // or RtlDeleteFunctionTable, and another thread is attempting an unwind
    // past a dynamic function, the unwind will fail because it will not be
    // able to find a function entry and its associated unwind information.
    // The specific case where this is fatal is one thread is adding or
    // removing a table, while another thread faults, and RtlDispatchException
    // (which indirectly calls this code) cannot find a handler.
    //
    // The lock change idea is bad because clients may need to suspend another
    // thread and inspect its stack.  In this case, it needs to ensure that
    // the target thread is outside of the lock before calling
    // RtlLookupFunctionEntry, else it will deadlock if the target thread is
    // already inside of the lock.  The unwinding thread can avoid this by
    // entering the lock before suspending the target thread, which is
    // publicly accessible via the PEB.
    //
    // If you need access to the dynamic function table list outside of any
    // locks, you want to either add a NEW api that does this, or use
    // RtlGetFunctionTableListHead and walk through the list yourself.  There
    // are several other examples in the nt source base where the latter has
    // been done before.
    //
    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T
    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T
    // R E A D  T H I S  C O M M E N T        R E A D  T H I S  C O M M E N T

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        //
        //  Search the tree starting from the head, continue until the entry
        //  is found or we reach the end of the list.
        //

        Head = &RtlpDynamicFunctionTable;
        for (Next = Head->Blink; Next != Head; Next = Next->Blink) {
            CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
            FunctionTable = CurrentEntry->FunctionTable;

            //
            // Check if the ControlPC is within the range of this function table
            //

            if ((ControlPc >= CurrentEntry->MinimumAddress) &&
                (ControlPc <  CurrentEntry->MaximumAddress) ) {


                // If this function table is sorted do a binary search.

                BaseAddress = CurrentEntry->BaseAddress;
                if (CurrentEntry->Type == RF_SORTED) {

                    //
                    // Perform binary search on the function table for a function table
                    // entry that subsumes the specified PC.
                    //

                    Low = 0;
                    High = CurrentEntry->EntryCount -1 ;

                    while (High >= Low) {

                        //
                        // Compute next probe index and test entry. If the specified PC
                        // is greater than of equal to the beginning address and less
                        // than the ending address of the function table entry, then
                        // return the address of the function table entry. Otherwise,
                        // continue the search.
                        //


                        Middle = (Low + High) >> 1;
                        FunctionEntry = &FunctionTable[Middle];

                        if (ControlPc < RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry)) {
                            High = Middle - 1;

                        } else if (ControlPc >= RF_END_ADDRESS( BaseAddress, FunctionEntry)) {
                            Low = Middle + 1;

                        } else {

                            *ImageBase = CurrentEntry->BaseAddress;

                            if ( TargetGp != NULL )
                                *TargetGp  = CurrentEntry->TargetGp;

                            __leave;
                        }
                    }

                } else if (CurrentEntry->Type == RF_UNSORTED) {

                    PRUNTIME_FUNCTION LastFunctionEntry = &FunctionTable[CurrentEntry->EntryCount];


                    for (FunctionEntry = FunctionTable; FunctionEntry < LastFunctionEntry; FunctionEntry++) {

                        if ((ControlPc >= RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry)) &&
                            (ControlPc <  RF_END_ADDRESS( BaseAddress, FunctionEntry))) {


                            *ImageBase = CurrentEntry->BaseAddress;

                            if ( TargetGp != NULL )
                                *TargetGp  = CurrentEntry->TargetGp;

                            __leave;
                        }
                    }

                } else {

                    //
                    // Perform a callback to obtain the runtime function table
                    // entry that contains the specified control PC.
                    //
    
                    Callback = CurrentEntry->Callback;
                    Context = CurrentEntry->Context;
                    *ImageBase = BaseAddress;
                    *TargetGp = CurrentEntry->TargetGp;
                    FunctionEntry = (Callback)(ControlPc, Context);
                    __leave;
                }
            } // if in range
        } // for (... Next != Head ...)

        // Didn't find one...
        FunctionEntry = NULL;
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    return FunctionEntry;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\getcalr.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    getcalr.c

Abstract:

    This module implements the routine RtlGetCallerAddress. It will
    return the address of the caller, and the callers caller to the
    specified procedure.

Author:

    William K. Cheung (wcheung) 17-Jan-1996

    based on version by Larry Osterman (larryo) 18-Mar-1991

Revision History:

    18-Feb-2001 (silviuc) : added RtlCaptureStackBackTrace.

--*/
#include "ntrtlp.h"

//
// Undefine get callers address since it is defined as a macro.
//

#undef RtlGetCallersAddress

ULONG
RtlpWalkFrameChainExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    );


PRUNTIME_FUNCTION
RtlpLookupFunctionEntryForStackWalks (
    IN ULONGLONG ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp
    )

/*++

Routine Description:

    This function searches the currently active function tables for an
    entry that corresponds to the specified PC value.

    This code is identical to RtlLookupFunctionEntry, except that it does not
    check the dynamic function table list.

Arguments:

    ControlPc - Supplies the virtual address of an instruction bundle
        within the specified function.

    ImageBase - Returns the base address of the module to which the
                function belongs.

    TargetGp - Returns the global pointer value of the module.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    ULONG SizeOfExceptionTable;
    ULONG Size;
    LONG High;
    LONG Middle;
    LONG Low;
    USHORT i;

    //
    // Search for the image that includes the specified swizzled PC value.
    //

    *ImageBase = (ULONG_PTR)RtlPcToFileHeader((PVOID)ControlPc,
                                              (PVOID *)ImageBase);


    //
    // If an image is found that includes the specified PC, then locate the
    // function table for the image.
    //

    if ((PVOID)*ImageBase != NULL) {

        *TargetGp = (ULONG_PTR)(RtlImageDirectoryEntryToData(
                               (PVOID)*ImageBase,
                               TRUE,
                               IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                               &Size
                               ));

        FunctionTable = (PRUNTIME_FUNCTION)RtlImageDirectoryEntryToData(
                         (PVOID)*ImageBase,
                         TRUE,
                         IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                         &SizeOfExceptionTable);

        //
        // If a function table is located, then search the table for a
        // function table entry for the specified PC.
        //

        if (FunctionTable != NULL) {

            //
            // Initialize search indices.
            //

            Low = 0;
            High = (SizeOfExceptionTable / sizeof(RUNTIME_FUNCTION)) - 1;
            ControlPc = ControlPc - *ImageBase;

            //
            // Perform binary search on the function table for a function table
            // entry that subsumes the specified PC.
            //

            while (High >= Low) {

                //
                // Compute next probe index and test entry. If the specified PC
                // is greater than of equal to the beginning address and less
                // than the ending address of the function table entry, then
                // return the address of the function table entry. Otherwise,
                // continue the search.
                //

                Middle = (Low + High) >> 1;
                FunctionEntry = &FunctionTable[Middle];

                if (ControlPc < FunctionEntry->BeginAddress) {
                    High = Middle - 1;

                } else if (ControlPc >= FunctionEntry->EndAddress) {
                    Low = Middle + 1;

                } else {
                    return FunctionEntry;

                }
            }
        }
    }

    return NULL;
}



VOID
RtlGetCallersAddress (
    OUT PVOID *CallersPc,
    OUT PVOID *CallersCallersPc
    )

/*++

Routine Description:

    This routine returns the address of the routine that called the routine
    that called this routine, and the routine that called the routine that
    called this routine. For example, if A called B called C which called
    this routine, the return addresses in A and B would be returned.

Arguments:

    CallersPc - Supplies a pointer to a variable that receives the address
        of the caller of the caller of this routine (B).

    CallersCallersPc - Supplies a pointer to a variable that receives the
        address of the caller of the caller of the caller of this routine
        (A).

Return Value:

    None.

Note:

    If either of the calling stack frames exceeds the limits of the stack,
    they are set to NULL.

--*/

{
#ifdef REALLY_GET_CALLERS_CALLER
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONG_PTR NextPc;
    ULONGLONG HighStackLimit, LowStackLimit;
    ULONGLONG HighBStoreLimit, LowBStoreLimit;
    ULONGLONG ImageBase;
    ULONGLONG TargetGp;

    //
    // Assume the function table entries for the various routines cannot be
    // found or there are not four procedure activation records on the stack.
    //

    *CallersPc = NULL;
    *CallersCallersPc = NULL;

    //
    // Capture the current context.
    //

    RtlCaptureContext(&ContextRecord);
    NextPc = (ULONG_PTR)ContextRecord.BrRp;

    //
    // Get the high and low limits of the current thread's stack.
    //

    Rtlp64GetStackLimits(&LowStackLimit, &HighStackLimit);
    Rtlp64GetBStoreLimits(&LowBStoreLimit, &HighBStoreLimit);

    //
    // Attempt to unwind to the caller of this routine (C).
    //

    FunctionEntry = RtlpLookupFunctionEntryForStackWalks(NextPc, &ImageBase, &TargetGp);
    if (FunctionEntry != NULL) {

        //
        // A function entry was found for this routine. Virtually unwind
        // to the caller of this routine (C).
        //

        NextPc = RtlVirtualUnwind(NextPc,
                                  FunctionEntry,
                                  &ContextRecord,
                                  &InFunction,
                                  &EstablisherFrame,
                                  NULL);

        //
        // Attempt to unwind to the caller of the caller of this routine (B).
        //

        FunctionEntry = RtlpLookupFunctionEntryForStackWalks(NextPc);
        if ((FunctionEntry != NULL) && (((ULONG_PTR)ContextRecord.IntSp < HighStackLimit) && ((ULONG_PTR)ContextRecord.RsBSP > LowBStoreLimit))) {

            //
            // A function table entry was found for the caller of the caller
            // of this routine (B). Virtually unwind to the caller of the
            // caller of this routine (B).
            //

            NextPc = RtlVirtualUnwind(NextPc,
                                      FunctionEntry,
                                      &ContextRecord,
                                      &InFunction,
                                      &EstablisherFrame,
                                      NULL);

            *CallersPc = (PVOID)NextPc;

            //
            // Attempt to unwind to the caller of the caller of the caller
            // of the caller of this routine (A).
            //

            FunctionEntry = RtlpLookupFunctionEntryForStackWalks(NextPc);
            if ((FunctionEntry != NULL) && (((ULONG_PTR)ContextRecord.IntSp < HighStackLimit) && ((ULONG_PTR)ContextRecord.RsBSP > LowBStoreLimit))) {

                //
                // A function table entry was found for the caller of the
                // caller of the caller of this routine (A). Virtually unwind
                // to the caller of the caller of the caller of this routine
                // (A).
                //

                NextPc = RtlVirtualUnwind(NextPc,
                                          FunctionEntry,
                                          &ContextRecord,
                                          &InFunction,
                                          &EstablisherFrame,
                                          NULL);

                *CallersCallersPc = (PVOID)NextPc;
            }
        }
    }
#else
    *CallersPc = NULL;
    *CallersCallersPc = NULL;
#endif // REALLY_GET_CALLERS_CALLER
    return;
}

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    )
/*++

Routine Description:

    RtlWalkFrameChain

Description:

    This function tries to walk the call chain and fill out a vector of
    return addresses. The function works only on IA64. It is possible that
    the function cannot fill the requested number of callers.
    In this case the function will just return with
    a less then requested count.

    In kernel mode the function should not take
    any exceptions (page faults) because it can be called at all sorts of
    irql levels. It needs to be tested if this is the case.

Return value:

    The number of identified return addresses on the stack. This can be less
    then the Count requested if the stack ends or we encounter an error while
    virtually unwinding the stack.

--*/

{
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONG_PTR NextPc, ControlPc;
    ULONGLONG HighStackLimit, LowStackLimit;
    ULONGLONG HighBStoreLimit, LowBStoreLimit;
    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONG CallersFound;

    //
    // IA64 code does not support any flags.
    //

    if (Flags != 0) {
        return 0;
    }

    //
    // In kernel mode avoid running at irql levels where we cannot
    // take page faults. The walking code will access various sections
    // from driver and system images and this will cause page faults.
    //

#ifdef NTOS_KERNEL_RUNTIME

    if (KeAreAllApcsDisabled () == TRUE) {
        return 0;
    }

#endif

    //
    // Assume the function table entries for the various routines cannot be
    // found or there are not enough procedure activation records on the stack.
    //

    CallersFound = 0;
    RtlZeroMemory (Callers, Count * sizeof(PVOID));

    //
    // Capture the current context.
    //

    RtlCaptureContext (&ContextRecord);
    NextPc = (ULONG_PTR)ContextRecord.BrRp;

    //
    // Get the high and low limits of the current thread's stack.
    //

    Rtlp64GetStackLimits (&LowStackLimit, &HighStackLimit);
    Rtlp64GetBStoreLimits (&LowBStoreLimit, &HighBStoreLimit);

    //
    // Loop to get requested number of callers.
    //

    try {
        while (CallersFound < Count) {

#ifdef NTOS_KERNEL_RUNTIME

            //
            // We need to check the NextPc value that we have got from
            // CaptureContext() or VirtualUnwind(). It can happen that
            // we pick up a bogus value from a session driver but in the
            // current process no session space is mapped. 
            //

            if ((MmIsSessionAddress ((PVOID)NextPc) == TRUE) &&
                (MmGetSessionId (PsGetCurrentProcess()) == 0)) {
                break;
            }
#endif

            FunctionEntry = RtlpLookupFunctionEntryForStackWalks (NextPc,
                                                    &ImageBase,
                                                    &TargetGp);

            //
            // If we cannot find a function table entry or we are not
            // within stack limits or backing store limits anymore
            // we are done.
            //

            if (FunctionEntry == NULL) {
                break;
            }

            if ((ULONG_PTR)(ContextRecord.IntSp) >= HighStackLimit ||
                (ULONG_PTR)(ContextRecord.IntSp) <= LowStackLimit) {

                break;
            }

            if ((ULONG_PTR)(ContextRecord.RsBSP) <= LowBStoreLimit ||
                (ULONG_PTR)(ContextRecord.RsBSP) >= HighBStoreLimit) {

                break;
            }

            //
            // A function table entry was found.
            // Virtually unwind to the caller of this routine.
            //

            NextPc = RtlVirtualUnwind (ImageBase,
                                       NextPc,
                                       FunctionEntry,
                                       &ContextRecord,
                                       &InFunction,
                                       &EstablisherFrame,
                                       NULL);

            Callers[CallersFound] = (PVOID)NextPc;
            CallersFound += 1;
        }

    } except (RtlpWalkFrameChainExceptionFilter (_exception_code(), _exception_info())) {
        
          CallersFound = 0;
    }

    return CallersFound;
}


USHORT
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    This routine walks up the stack frames, capturing the return address from
    each frame requested.

Arguments:

    FramesToSkip - frames detected but not included in the stack trace

    FramesToCapture - frames to be captured in the stack trace buffer.
        One of the frames will be for RtlCaptureStackBackTrace.

    BackTrace - stack trace buffer

    BackTraceHash - very simple hash value that can be used to organize
      hash tables. It is just an arithmetic sum of the pointers in the
      stack trace buffer. If NULL then no hash value is computed.

Return Value:

     Number of return addresses returned in the stack trace buffer.

--*/
{
    PVOID Trace [2 * MAX_STACK_DEPTH];
    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;

    //
    // One more frame to skip for the "capture" function (RtlWalkFrameChain).
    //

    FramesToSkip += 1;

    //
    // Sanity checks.
    //

    if (FramesToCapture + FramesToSkip >= 2 * MAX_STACK_DEPTH) {
        return 0;
    }

    FramesFound = RtlWalkFrameChain (Trace,
                                     FramesToCapture + FramesToSkip,
                                     0);

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    for (Index = 0, HashValue = 0; Index < FramesToCapture; Index += 1) {

        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    if (BackTraceHash != NULL) {

        *BackTraceHash = HashValue;
    }

    return (USHORT)Index;
}


ULONG
RtlpWalkFrameChainExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    )
/*++

Routine Description:

    This routine is the exception filter used by RtlWalkFramechain function.

Arguments:

    ExceptionCode - exception code
    ExceptionRecord - structure with pointers to .exr and .cxr

Return Value:

    Always EXCEPTION_EXECUTE_HANDLER.

--*/
{

#if DBG
        DbgPrint ("Unexpected exception (info %p) in RtlWalkFrameChain ...\n",
                  ExceptionRecord);

        DbgBreakPoint ();
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\fillmem.s ===
//
// Module Name:
//
//    fillmem.s
//
// Abstract:
//
//    This module implements functions to move, zero, and fill blocks
//    of memory. If the memory is aligned, then these functions are
//    very efficient.
//
// Author:
//
//
// Environment:
//
//    User or Kernel mode.
//
//--

#include "ksia64.h"

//++
//
// VOID
// RtlFillMemory (
//    IN PVOID destination,
//    IN SIZE_T length,
//    IN UCHAR fill
//    )
//
// Routine Description:
//
//    This function fills memory by first aligning the destination address to
//    a qword boundary, and then filling 4-byte blocks, followed by any
//    remaining bytes.
//
// Arguments:
//
//    destination (a0) - Supplies a pointer to the memory to fill.
//
//    length (a1) - Supplies the length, in bytes, of the memory to be filled.
//
//    fill (a2) - Supplies the fill byte.
//
//    N.B. The alternate entry memset expects the length and fill arguments
//         to be reversed.  It also returns the Destination pointer
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlFillMemory)

        lfetch.excl [a0]
        mov         t0 = a0
        add         t4 = 64, a0

        cmp.eq      pt0 = zero, a1        // length == 0 ?
        add         t1 = -1, a0
        zxt1        a2 = a2

        cmp.ge      pt1 = 7, a1
        mov         v0 = a0
 (pt0)  br.ret.spnt brp                   // return if length is zero
        ;;

//
// Align address on qword boundary by determining the number of bytes
// before the next qword boundary by performing an AND operation on
// the 2's complement of the address with a mask value of 0x7.
//

        lfetch.excl [t4], 64
        andcm       t1 = 7, t1            // t1 = # bytes before dword boundary
 (pt1)  br.cond.spnt TailSet              // 1 <= length <= 3, br to TailSet
        ;;

        cmp.eq      pt2 = zero, t1        // skip HeadSet if t1 is zero
        mux1        t2 = a2, @brcst       // t2 = all 8 bytes = [fill]
        sub         a1 = a1, t1           // a1 = adjusted length
        ;;

        lfetch.excl [t4], 64
 (pt2)  br.cond.sptk SkipHeadSet

//
// Copy the leading bytes until t1 is equal to zero
//

HeadSet:
        st1         [t0] = a2, 1
        add         t1 = -1, t1
        ;;
        cmp.ne      pt0 = zero, t1

(pt0)   br.cond.sptk HeadSet

//
// now the address is qword aligned;
// fall into the QwordSet loop if remaining length is greater than 8;
// else skip the QwordSet loop
//

SkipHeadSet:

        cmp.gt      pt1 = 16, a1
        add         t4 = 64, t0
        cmp.le      pt2 = 8, a1

        add         t3 = 8, t0
        cmp.gt      pt3 = 64, a1
 (pt1)  br.cond.spnt SkipQwordSet
        ;;

        lfetch.excl [t4], 64
 (pt3)  br.cond.spnt QwordSet

        nop.m       0
        nop.m       0
        nop.i       0

UnrolledQwordSet:

        st8         [t0] = t2, 16
        st8         [t3] = t2, 16
        add         a1 = -64, a1
        ;;
        
        st8         [t0] = t2, 16
        st8         [t3] = t2, 16
        cmp.le      pt0 = 64, a1
        ;;

        st8         [t0] = t2, 16
        st8         [t3] = t2, 16
        cmp.le      pt2 = 8, a1
        ;;

        st8         [t0] = t2, 16
        nop.f       0
        cmp.gt      pt1 = 16, a1

        st8         [t3] = t2, 16
 (pt0)  br.cond.sptk UnrolledQwordSet
 (pt1)  br.cond.spnt SkipQwordSet
        ;;

//
// fill 8 bytes at a time until the remaining length is less than 8
//

QwordSet:
        st8         [t0] = t2, 16
        st8         [t3] = t2, 16
        add         a1 = -16, a1
        ;;

        cmp.le      pt0 = 16, a1
        cmp.le      pt2 = 8, a1
(pt0)   br.cond.sptk QwordSet
        ;;

SkipQwordSet:
(pt2)   st8         [t0] = t2, 8
(pt2)   add         a1 = -8, a1
        ;;

        cmp.eq      pt3 = zero, a1        // return now if length equals 0
(pt3)   br.ret.sptk brp
        ;;

//
// copy the remaining bytes one at a time
//

TailSet:
        st1         [t0] = a2, 1
        add         a1 = -1, a1
        nop.i       0
        ;;

        cmp.ne      pt0, pt3 = 0, a1
(pt0)   br.cond.dptk TailSet
(pt3)   br.ret.dpnt brp
        ;;

        LEAF_EXIT(RtlFillMemory)

//++
//
// VOID
// RtlFillMemoryUlong (
//    IN PVOID Destination,
//    IN SIZE_T Length,
//    IN ULONG Pattern
//    )
//
// Routine Description:
//
//    This function fills memory with the specified longowrd pattern
//    4 bytes at a time.
//
//    N.B. This routine assumes that the destination address is aligned
//         on a longword boundary and that the length is an even multiple
//         of longwords.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the memory to fill.
//
//    Length (a1) - Supplies the length, in bytes, of the memory to be filled.
//
//    Pattern (a2) - Supplies the fill pattern.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlFillMemoryUlong)

        .prologue
        .save       ar.lc, t22
        mov         t22 = ar.lc
        extr.u      a1 = a1, 2, 30
        ;;

        PROLOGUE_END

        cmp.eq      pt0, pt1 = zero, a1
        add         a1 = -1, a1
        ;;

        nop.m       0
(pt1)   mov         ar.lc = a1
(pt0)   br.ret.spnt brp
        ;;
Rfmu10:
        st4         [a0] = a2, 4
        br.cloop.dptk.few Rfmu10
        ;;

        nop.m       0
        mov         ar.lc = t22
        br.ret.sptk brp

        LEAF_EXIT(RtlFillMemoryUlong)

//++
//
// VOID
// RtlFillMemoryUlonglong (
//    IN PVOID Destination,
//    IN SIZE_T Length,
//    IN ULONGLONG Pattern
//    )
//
// Routine Description:
//
//    This function fills memory with the specified pattern
//    8 bytes at a time.
//
//    N.B. This routine assumes that the destination address is aligned
//         on a longword boundary and that the length is an even multiple
//         of longwords.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the memory to fill.
//
//    Length (a1) - Supplies the length, in bytes, of the memory to be filled.
//
//    Pattern (a2,a3) - Supplies the fill pattern.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlFillMemoryUlonglong)

        .prologue
        .save       ar.lc, t22
        mov         t22 = ar.lc
        extr.u      a1 = a1, 3, 29
        ;;

        PROLOGUE_END

        cmp.eq      pt0, pt1 = zero, a1
        add         a1 = -1, a1
        ;;

        nop.m       0
(pt1)   mov         ar.lc = a1
(pt0)   br.ret.spnt brp
        ;;
Rfmul10:
        st8         [a0] = a2, 8
        br.cloop.dptk.few Rfmul10
        ;;

        nop.m       0
        mov         ar.lc = t22
        br.ret.sptk brp
        ;;

        LEAF_EXIT(RtlFillMemoryUlonglong)


//++
//
// VOID
// RtlZeroMemory (
//    IN PVOID Destination,
//    IN SIZE_T Length
//    )
//
// Routine Description:
//
//    This function simply sets up the fill value (out2) and branches
//    directly to RtlFillMemory
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the memory to zero.
//
//    Length (a1) - Supplies the length, in bytes, of the memory to be zeroed.
//
// Return Value:
//
//    None.
//
//--
        LEAF_ENTRY(RtlZeroMemory)

        alloc       t22 = ar.pfs, 0, 0, 3, 0
        mov         out2 = 0
        br          RtlFillMemory

        LEAF_EXIT(RtlZeroMemory)


//++
//
// RtlCompareMemory
//
//--
        LEAF_ENTRY(RtlCompareMemory)

        cmp.eq      pt0 = 0, a2
        mov         v0 = 0
 (pt0)  br.ret.spnt.many brp
        ;;

        add         t2 = -1, a2

Rcmp10:
        ld1         t0 = [a0], 1
        ld1         t1 = [a1], 1
        ;;
        cmp4.eq     pt2 = t0, t1
        ;;

 (pt2)  cmp.ne.unc  pt1 = v0, t2
 (pt2)  add         v0 = 1, v0
 (pt1)  br.cond.dptk.few Rcmp10

        br.ret.sptk.many brp

        LEAF_EXIT(RtlCompareMemory)


//++
//
// VOID
// RtlCopyIa64FloatRegisterContext (
//     PFLOAT128 Destination,
//     PFLOAT128 Source,
//     ULONGLONG Length
//     )
//
// Routine Description:
//
//    This routine copies floating point context from one place to
//    another.  It assumes both the source and the destination are
//    16-byte aligned and the buffer contains only memory image of
//    floating point registers.  Note that Length must be greater
//    than 0 and a multiple of 32.
//
// Arguments:
//
//    a0 - Destination
//    a1 - Source
//    a2 - Length
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(RtlCopyIa64FloatRegisterContext)

        .prologue
        .save       ar.lc, t22
        mov         t22 = ar.lc
        shr         t0 = a2, 5
        ;;

        cmp.gtu     pt0, pt1 = 32, a2
        add         t0 = -1, t0
        add         t1 = 16, a1
        ;;

        PROLOGUE_END
#if DBG
        and         t4 = 0x1f, a2 
        ;;
        cmp.ne      pt2 = 0, t4
        ;;
(pt2)   break.i     BREAKPOINT_STOP                
#endif 
        add         t2 = 16, a0
(pt1)   mov         ar.lc = t0
(pt0)   br.ret.spnt brp

Rcf10:

        ldf.fill    ft0 = [a1], 32
        ldf.fill    ft1 = [t1], 32
        nop.i       0
        ;;

        stf.spill   [a0] = ft0, 32
        stf.spill   [t2] = ft1, 32
        br.cloop.dptk Rcf10
        ;;

        nop.m       0
        mov         ar.lc = t22
        br.ret.sptk brp
        ;;

        NESTED_EXIT(RtlCopyIa64FloatRegisterContext)


//++
//
// VOID
// RtlPrefetchMemoryNonTemporal (
//     IN PVOID Source,
//     IN SIZE_T Length
//     )
//
// Routine Description:
//
//    This routine prefetches memory at Source, for Length bytes into
//    the closest cache to the processor.
//
//    N.B. Currently this code assumes a line size of 32 bytes.  At
//    some stage it should be altered to determine and use the processor's
//    actual line size.
//
// Arguments:
//
//    a0 - Source
//    a1 - Length
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RtlPrefetchMemoryNonTemporal)
        .prologue
        lfetch.nta [a0], 32             // get first line coming
        .save       ar.lc, t0
        mov.i       t0 = ar.lc          // save loop counter
        shr         a1 = a1, 5          // determine loop count
        ;;
        .body        

        add         t2 = -1, a1         // subtract out already fetched line
        cmp.lt      pt0, pt1 = 2, a1    // check if less than one line to fetch
        ;;

 (pt0)  mov         ar.lc = t2          // set loop count
 (pt1)  br.ret.spnt.few brp             // return if no more lines to fetch
        ;;

Rpmnt10:
        lfetch.nta [a0], 32             // fetch next line
        br.cloop.dptk.many Rpmnt10      // loop while more lines to fetch
        ;;

        mov         ar.lc = t0          // restore loop counter
        br.ret.sptk.many brp            // return

        LEAF_EXIT(RtlPrefetchMemoryNonTemporal)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\largeint.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//      TITLE("Large Integer Arithmetic")
//++
//
// Module Name:
//
//    largeint.s
//
// Abstract:
//
//    This module implements routines for performing extended integer
//    arithmetic.
//
// Author:
//
//    William K. Cheung (wcheung) 08-Feb-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    09-Feb-1996    Updated to EAS 2.1
//
//--

#include "ksia64.h"

        .file    "largeint.s"

//++
//
// LARGE_INTEGER
// RtlExtendedMagicDivide (
//    IN LARGE_INTEGER Dividend,
//    IN LARGE_INTEGER MagicDivisor,
//    IN CCHAR ShiftCount
//    )
//
// Routine Description:
//
//    This function divides a signed large integer by an unsigned large integer
//    and returns the signed large integer result. The division is performed
//    using reciprocal multiplication of a signed large integer value by an
//    unsigned large integer fraction which represents the most significant
//    64-bits of the reciprocal divisor rounded up in its least significant bit
//    and normalized with respect to bit 63. A shift count is also provided
//    which is used to truncate the fractional bits from the result value.
//
// Arguments:
//
//    Dividend (a0) - Supplies the dividend value.
//
//    MagicDivisor (a1) - Supplies the magic divisor value which
//      is a 64-bit multiplicative reciprocal.
//
//    Shiftcount (a2) - Supplies the right shift adjustment value.
//
// Return Value:
//
//    The large integer result is returned as the function value in v0.
//
//--

        LEAF_ENTRY(RtlExtendedMagicDivide)

        cmp.gt      pt0, pt1 = r0, a0
        ;;
(pt0)   sub         a0 = r0, a0
        ;;

        setf.sig    ft0 = a0
        setf.sig    ft1 = a1
        ;;
        zxt1        a2 = a2
        xma.hu      ft2 = ft0, ft1, f0
        ;;
        getf.sig    v0 = ft2
        ;;
        shr         v0 = v0, a2
        ;;

(pt0)   sub         v0 = r0, v0
        LEAF_RETURN

        LEAF_EXIT(RtlExtendedMagicDivide)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\miscc.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1990  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This module implements the functions that get the memory stack
    and backing store limits.

Author:

    William K. Cheung (wcheung) 09-Aug-1996

Environment:

    Any mode.

Revision History:

--*/

#include "ntrtlp.h"

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

VOID
DebugUnLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

VOID
DebugCommandString(
    IN PSTRING Name,
    IN PSTRING Command
    );


VOID
RtlpFlushRSE (
    OUT PULONGLONG BackingStore,
    OUT PULONGLONG RNat
    );


VOID
RtlpCaptureRnats (
   IN OUT PCONTEXT ContextRecord
   )

/*++

Routine Description:

    This function captures Nat bits of all the stacked registers in
    the RSE frame specified in the context record.
--*/
{
    ULONGLONG Rnat;
    ULONGLONG Bsp;
    ULONGLONG TopRnatAddress;

    RtlpFlushRSE(&Bsp, &Rnat);

    TopRnatAddress = 
        (ULONGLONG) RtlpRseRNatAddress( 
            RtlpRseGrowBySOF(ContextRecord->RsBSP, ContextRecord->StIFS) - sizeof(ULONGLONG)
            );

    if (TopRnatAddress < Bsp) {
        ContextRecord->RsRNAT = *(PULONGLONG)TopRnatAddress;
    } else {
        ContextRecord->RsRNAT = Rnat;
    }
}


VOID
Rtlp64GetBStoreLimits (
    OUT PULONGLONG LowBStoreLimit,
    OUT PULONGLONG HighBStoreLimit
    )

/*++

Routine Description:

    This function returns the current backing store limits based on the 
    current processor mode.

Arguments:

    LowBStoreLimit - Supplies a pointer to a variable that is to receive
        the low limit of the backing store.

    HighBStoreLimit - Supplies a pointer to a variable that is to receive
        the high limit of the backing store.

Return Value:

    None.

--*/

{
#if defined(NTOS_KERNEL_RUNTIME)

    //
    // Kernel Mode
    //

    *LowBStoreLimit = (ULONGLONG)(PCR->InitialBStore);
    *HighBStoreLimit = (ULONGLONG)(PCR->BStoreLimit);

#else

    //
    // User Mode
    //

    PTEB CurrentTeb = NtCurrentTeb();

    *HighBStoreLimit = (ULONGLONG)CurrentTeb->BStoreLimit;
    *LowBStoreLimit = (ULONGLONG)CurrentTeb->NtTib.StackBase;

#endif // defined(NTOS_KERNEL_RUNTIME)
}
    
VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowStackLimit,
    OUT PULONG_PTR HighStackLimit
    )

/*++

Routine Description:

    This function returns the current memory stack limits based on the 
    current processor mode.

Arguments:

    LowStackLimit - Supplies a pointer to a variable that is to receive
        the low limit of the memory stack.

    HighStackLimit - Supplies a pointer to a variable that is to receive
        the high limit of the memory stack.

Return Value:

    None.

--*/

{

#if defined(NTOS_KERNEL_RUNTIME)

    //
    // Kernel Mode
    //

    *HighStackLimit = (ULONG_PTR)PCR->InitialStack;
    *LowStackLimit = (ULONG_PTR)PCR->StackLimit;

#else

    //
    // User Mode
    //

    PTEB CurrentTeb = NtCurrentTeb();

    *HighStackLimit = (ULONG_PTR)CurrentTeb->NtTib.StackBase;
    *LowStackLimit = (ULONG_PTR)CurrentTeb->NtTib.StackLimit;

#endif // defined(NTOS_KERNEL_RUNTIME)
}

VOID
Rtlp64GetStackLimits (
    OUT PULONGLONG LowStackLimit,
    OUT PULONGLONG HighStackLimit
    )

/*++

Routine Description:

    This function returns the current memory stack limits based on the 
    current processor mode.

Arguments:

    LowStackLimit - Supplies a pointer to a variable that is to receive
        the low limit of the memory stack.

    HighStackLimit - Supplies a pointer to a variable that is to receive
        the high limit of the memory stack.

Return Value:

    None.

--*/

{

#if defined(NTOS_KERNEL_RUNTIME)

    //
    // Kernel Mode
    //

    *HighStackLimit = (ULONG_PTR)PCR->InitialStack;
    *LowStackLimit = (ULONG_PTR)PCR->StackLimit;

#else

    //
    // User Mode
    //

    PTEB CurrentTeb = NtCurrentTeb();

    *HighStackLimit = (ULONGLONG)CurrentTeb->NtTib.StackBase;
    *LowStackLimit = (ULONGLONG)CurrentTeb->NtTib.StackLimit;

#endif // defined(NTOS_KERNEL_RUNTIME)
}

VOID
DebugService2(
    PVOID Arg1,
    PVOID Arg2,
    ULONG ServiceClass
    )

//++
//
//  Routine Description:
//
//      Generic exception dispatcher for the debugger
//
//  Arguments:
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//      ServiceClass - which call is to be performed
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{

    switch (ServiceClass)
    {
    case BREAKPOINT_COMMAND_STRING:
        DebugCommandString(Arg1, Arg2);
        return;
    case BREAKPOINT_LOAD_SYMBOLS:
        DebugLoadImageSymbols(Arg1, Arg2);
        return;
    case BREAKPOINT_UNLOAD_SYMBOLS:
        DebugUnLoadImageSymbols(Arg1, Arg2);
        return;
    default:
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\ntrtli64.h ===
/*++

Module Name:

    ntrtliae.h

Abstract:

    IA64 specific parts of ntrtlp.h

Author:

    William K. Cheung (wcheung) 16-Jan-96

Revision History:

--*/

VOID
Rtlp64GetStackLimits (
    OUT PULONGLONG LowLimit,
    OUT PULONGLONG HighLimit
    );

VOID
Rtlp64GetBStoreLimits(
    OUT PULONGLONG LowBStoreLimit, 
    OUT PULONGLONG HighBStoreLimit
    );

//
// Exception handling procedure prototypes.
//

VOID
RtlpUnlinkHandler (
    PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
    );

PEXCEPTION_REGISTRATION_RECORD
RtlpGetRegistrationHead (
    VOID
    );

EXCEPTION_DISPOSITION
RtlpExecuteEmHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONGLONG MemoryStackFp,
    IN ULONGLONG BackingStoreFp,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN ULONGLONG GlobalPointer,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

EXCEPTION_DISPOSITION
RtlpExecuteEmHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONGLONG MemoryStackFp,
    IN ULONGLONG BackingStoreFp,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN ULONGLONG GlobalPointer,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

EXCEPTION_DISPOSITION
RtlpExecuteX86HandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

EXCEPTION_DISPOSITION
RtlpExecuteX86HandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

NTSYSAPI
VOID
NTAPI
RtlCaptureNonVolatileContext (
    OUT PCONTEXT ContextRecord
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\mp\makefile.inc ===
!if defined(LINK_TIME_CODE_GENERATION)
$(O)\generr.obj: ..\generr.c
    $(C_COMPILER_NAME) ..\generr.c @<<
-Fo$(O)\generr.obj
$(EX_C_COMPILER_FLAGS:/GL=)
<<NOKEEP
!else 
$(O)\generr.obj: ..\generr.c
!endif

$(O)\error.h: $(O)\generr.obj
    generr $? $@

..\error.c: $(O)\error.h

!if $(386)
$(O)\$(TARGETNAME).lib : $(O)\xcptmisc.org

$(O)\xcptmisc.org : $(O)\xcptmisc.obj
   copy $** $@
   sxgen /verbose /in:$@ /out:$** ExceptionHandler@16 UnwindHandler@16
   touch $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\slist.s ===
//       TITLE("Interlocked Support")
//++
//
// Copyright (c) 1998  Intel Corporation
// Copyright (c) 1998  Microsoft Corporation
//
// Module Name:
//
//    slist.s
//
// Abstract:
//
//    This module implements functions to support interlocked S_List
//    operations.
//
// Author:
//
//    William K. Cheung (v-wcheung) 10-Mar-1998
//
// Environment:
//
//    User mode.
//
// Revision History:
//
//--

#include "ksia64.h"

//
// Define how big the depth field. This is the start of the word
//
#define SLIST_DEPTH_BITS_SIZE 16

//
// Define the start of the pointer in an slist
//
#define SLIST_ADR_BITS_START 25

//
// Define the number of alignment bits for an address
//

#define SLIST_ADR_ALIGMENT 4

//
// Define were the sequence bits start and how many there are
//

#define SLIST_SEQ_BITS_START 16
#define SLIST_SEQ_BITS_SIZE 9


//++
//
// PSINGLE_LIST_ENTRY
// RtlpInterlockedFlushSList (
//    IN PSLIST_HEADER ListHead
//    )
//
// Routine Description:
//
//    This function flushes the entire list of entries on a sequenced singly
//    linked list so that access to the list is synchronized in a MP system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the 1st entry on the list is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead from which
//       an current list is to be removed.
//
// Return Value:
//
//    The address of the 1st entry on the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(RtlpInterlockedFlushSList)
        ALTERNATE_ENTRY(ExpInterlockedFlushSList)

        ld8.acq.nt1 t0 = [a0]                       // load next entry & sequence
#if defined (NTOS_KERNEL_RUNTIME)
        add         t1 = 8, a0                      // Get address of region cell
#endif
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
        ld8         t1 = [t1] 			    // Load region bits
#endif
        mov         ar.ccv = t0
        shr.u       v0 = t0, SLIST_ADR_BITS_START
        ;;
Efls10:
        cmp.eq      pt1 = v0, r0                    // if eq, list is empty
        extr.u      t5 = t0, SLIST_SEQ_BITS_START, \
                         SLIST_SEQ_BITS_SIZE        // extract the sequence number
 (pt1)  br.ret.spnt.clr brp                         // return if the list is null
        ;;
#if defined (NTOS_KERNEL_RUNTIME)
	shladd      v0 = v0, SLIST_ADR_ALIGMENT, t1 // merge region & va bits
#else
        shl         v0 = v0, SLIST_ADR_ALIGMENT     // shift address into place
#endif
        shl         t5 = t5, SLIST_SEQ_BITS_START   // shift sequence number into place

        ;;
        cmpxchg8.rel t3 = [a0], t5, ar.ccv          // perform the pop
        ;;

        cmp.eq      pt1, pt2 = t3, t0               // if eq, cmpxchg8 succeeded
        ;;
 (pt2)  mov         ar.ccv = t3
 (pt1)  br.ret.sptk brp
        ;;
        mov         t0 = t3
        shr.u       v0 = t3, SLIST_ADR_BITS_START
        br          Efls10                          // try again


        LEAF_EXIT(RtlpInterlockedFlushSList)

        SBTTL("Interlocked Pop Entry Sequenced List")
//++
//
// PSINGLE_LIST_ENTRY
// RtlpInterlockedPopEntrySList (
//    IN PSLIST_HEADER ListHead
//    )
//
// Routine Description:
//
//    This function removes an entry from the front of a sequenced singly
//    linked list so that access to the list is synchronized in a MP system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead from which
//       an entry is to be removed.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(RtlpInterlockedPopEntrySList)
        ALTERNATE_ENTRY(ExpInterlockedPopEntrySList)
        ALTERNATE_ENTRY(ExpInterlockedPopEntrySListResume)


        ld8.acq.nt1 t0 = [a0]                        // load next entry & sequence
#if defined (NTOS_KERNEL_RUNTIME)
        add         t1 = 8, a0			     // Generate address region bits
#endif
        ;;

Epop10:

#if defined (NTOS_KERNEL_RUNTIME)
        ld8         t1 = [t1]                        // capture region bits
#endif
        mov         ar.ccv = t0
        shr.u       t2 = t0, SLIST_ADR_BITS_START
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
        shladd      v0 = t2, SLIST_ADR_ALIGMENT, t1  // merge region & va bits
#else
        shl         v0 = t2, SLIST_ADR_ALIGMENT      // shift va into place
#endif
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
        cmp.eq      pt2, pt1 = t1, v0                // if eq, list is empty
#else
        cmp.eq      pt2, pt1 = r0, v0                // if eq, list is empty
#endif
        sub         t4 = t0, zero, 1                 // adjust depth
        ;;

//
// N.B. It is possible for the following instruction to fault in the rare
//      case where the first entry in the list is allocated on another
//      processor and free between the time the free pointer is read above
//      and the following instruction. When this happens, the access fault
//      code continues execution by skipping the following instruction slot.
//      This results in the compare failing and the entire operation is
//      retried.
//

        ALTERNATE_ENTRY(ExpInterlockedPopEntrySListFault)

 (pt1)  ld8.acq     t5 = [v0]                       // get addr of successor entry
        extr.u      t4 = t4, 0, SLIST_DEPTH_BITS_SIZE + \
                         SLIST_SEQ_BITS_SIZE        // extract depth & sequence
        ;;
 (pt1)  shl         t5 = t5, SLIST_ADR_BITS_START - \
                         SLIST_ADR_ALIGMENT         // shift va into position dropping alignment bits
 (pt2)  add         v0 = 0, zero		    // The list is empty clear retur value
	;;

 (pt1)  ld8.nt1     t3 = [a0]                       // reload next entry & sequence
 (pt1)  or          t5 = t4, t5                     // merge va, depth & sequence
 (pt2)  br.ret.spnt.clr brp                         // return if the list is null
        ;;
        cmp.eq.unc  pt4, pt1 = t3, t0
        ;;

        ALTERNATE_ENTRY(ExpInterlockedPopEntrySListEnd)

 (pt4)  cmpxchg8.rel t3 = [a0], t5, ar.ccv          // perform the pop
        nop.i       0
        ;;

 (pt4)  cmp.eq.unc  pt3 = t3, t0                    // if eq, cmpxchg8 succeeded
#if defined (NTOS_KERNEL_RUNTIME)
        add	    t1 = 8, a0
#endif
	mov         t0 = t3
 (pt3)  br.ret.sptk brp

        br          Epop10                          // try again

        LEAF_EXIT(RtlpInterlockedPopEntrySList)

//++
//
// PSINGLE_LIST_ENTRY
// RtlpInterlockedPushEntrySList (
//    IN PSLIST_HEADER ListHead,
//    IN PSINGLE_LIST_ENTRY ListEntry
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a sequenced singly linked
//    list so that access to the list is synchronized in an MP system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead into which
//       an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
// Return Value:
//
//    Previous contents of ListHead.  NULL implies list went from empty
//       to not empty.
//
//--

        LEAF_ENTRY(RtlpInterlockedPushEntrySList)
        ALTERNATE_ENTRY(ExpInterlockedPushEntrySList)


        ld8.acq.nt1 t0 = [a0]                   // load next entry & sequence
        mov         t6 = (1<<SLIST_SEQ_BITS_START)+1 // Increment sequence and depth
        ldf.fill    ft0 = [a1]                  // Force alignment check.
        shl         t5 = a1, SLIST_ADR_BITS_START - \
                         SLIST_ADR_ALIGMENT     // shift va into position
        ;;

#if DBG==1
        and         t3 = (1<<SLIST_ADR_ALIGMENT)-1, a1
        add         t2 = 8, a0
        dep         t1 = 0, a1, 0, 61           // capture region bits	
        ;;
	cmp.eq      pt2, pt1 = t3, r0
#if defined (NTOS_KERNEL_RUNTIME)
	ld8         t2 = [t2]
	;;
(pt2)	cmp.eq      pt2, pt1 = t2, t1
#endif
	;;
(pt1)   break.i   0x80016
#endif
        
Epush10:
        mov         ar.ccv = t0                 // set the comparand
        add         t4 = t0, t6
        shr.u       v0 = t0, SLIST_ADR_BITS_START

        ;;
#if defined (NTOS_KERNEL_RUNTIME)
        dep         t1 = 0, a1, 0, 61           // capture region bits
#endif
        cmp.ne      pt3 = zero, v0              // if ne, list not empty
        ;;
#if defined (NTOS_KERNEL_RUNTIME)
 (pt3)  shladd      v0 = v0, SLIST_ADR_ALIGMENT, t1 // merge region & va bits
#else
 (pt3)  shl         v0 = v0, SLIST_ADR_ALIGMENT // shift address into place
#endif
        extr.u      t4 = t4, 0, SLIST_DEPTH_BITS_SIZE + \
                         SLIST_SEQ_BITS_SIZE    // extract depth & sequence
        ;;

        st8         [a1] = v0
        or          t5 = t4, t5                 // merge va, depth & sequence
        ;;

        cmpxchg8.rel t3 = [a0], t5, ar.ccv
        ;;
        cmp.eq      pt2, pt1 = t0, t3
        dep         t5 = 0, t5, 0, SLIST_DEPTH_BITS_SIZE + \
                         SLIST_SEQ_BITS_SIZE    // Zero depth a sequence
        ;;
 (pt2)  br.ret.sptk brp                         // if equal, return
 (pt1)  mov         t0 = t3
 (pt1)  br.spnt     Epush10                     // retry
        ;;

        LEAF_EXIT(RtlpInterlockedPushEntrySList)


//++
//
// SINGLE_LIST_ENTRY
// FASTCALL
// InterlockedPushListSList (
//     IN PSLIST_HEADER ListHead,
//     IN PSINGLE_LIST_ENTRY List,
//     IN PSINGLE_LIST_ENTRY ListEnd,
//     IN ULONG Count
//    )
//
// Routine Description:
//
//    This function will push multiple entries onto an SList at once
//
// Arguments:
//
//     ListHead - List head to push the list to.
//
//     List - The list to add to the front of the SList
//     ListEnd - The last element in the chain
//     Count - The number of items in the chain
//
// Return Value:
//
//     PSINGLE_LIST_ENTRY - The old header pointer is returned
//
//--

        LEAF_ENTRY(InterlockedPushListSList)


        ld8.acq.nt1 t0 = [a0]                   // load next entry & sequence
        mov         t6 = 0x10000		// Generate literal for adjusting depth and count
        ldf.fill    ft0 = [a1]                  // Force alignment check.
        shl         t5 = a1, SLIST_ADR_BITS_START - \
                         SLIST_ADR_ALIGMENT     // shift va into position
        ;;

#if DBG==1
        and         t3 = (1<<SLIST_ADR_ALIGMENT)-1, a1
        add         t2 = 8, a0
        dep         t1 = 0, a1, 0, 61           // capture region bits	
        ;;
	cmp.eq      pt2, pt1 = t3, r0
#if defined (NTOS_KERNEL_RUNTIME)
	ld8         t2 = [t2]
	;;
(pt2)	cmp.eq      pt2, pt1 = t2, t1
#endif
	;;
(pt1)   break.i   0x80016
#endif
        
        
Epushl10:
        mov         ar.ccv = t0                 // set the comparand
        add         t4 = t0, t6
        shr.u       v0 = t0, SLIST_ADR_BITS_START
        ;;
#if defined (NTOS_KERNEL_RUNTIME)
        dep         t1 = 0, a1, 0, 61           // capture region bits
#endif
        cmp.ne      pt3 = zero, v0              // if ne, list not empty
        add         t4 = t4, a3                 // Add in count
        ;;
#if defined (NTOS_KERNEL_RUNTIME)
 (pt3)  shladd      v0 = v0, SLIST_ADR_ALIGMENT, t1 // merge region & va bits
#else
 (pt3)  shl         v0 = v0, SLIST_ADR_ALIGMENT // shift address into place
#endif
        extr.u      t4 = t4, 0, SLIST_DEPTH_BITS_SIZE + \
                         SLIST_SEQ_BITS_SIZE    // extract depth & sequence
        ;;

        st8         [a2] = v0
        or          t5 = t4, t5                 // merge va, depth & sequence
        ;;

        cmpxchg8.rel t3 = [a0], t5, ar.ccv
        ;;
        cmp.eq      pt2, pt1 = t0, t3
        dep         t5 = 0, t5, 0, SLIST_DEPTH_BITS_SIZE + \
                         SLIST_SEQ_BITS_SIZE    // zero depth and sequence        

        mov         t0 = t3
 (pt2)  br.ret.sptk brp                         // if equal, return
 (pt1)  br.spnt     Epushl10                    // retry
        ;;

        LEAF_EXIT(InterlockedPushListSList)

//++
//
// PSINGLE_LIST_ENTRY
// FirstEntrySList (
//     IN PSLIST_HEADER SListHead
//     )
//
// Routine Description:
//
//   This function returns the address of the fisrt entry in the SLIST or
//   NULL.
//
// Arguments:
//
//   ListHead - Supplies a pointer to the sequenced listhead from
//       which the first entry address is to be computed.
//
// Return Value:
//
//   The address of the first entry is the specified, or NULL if the list is
//   empty.
//
//--
        LEAF_ENTRY(FirstEntrySList)

        ld8         t0 = [a0]                   // load next entry & sequence
#if defined (NTOS_KERNEL_RUNTIME)
        add         t1 = 8, a0			// Generate address region bits
#endif
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
        ld8         t1 = [t1]                   // capture region bits
#endif
        shr.u       t2 = t0, SLIST_ADR_BITS_START
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
        cmp.eq      pt0 = t2, r0
        shladd      v0 = t2, SLIST_ADR_ALIGMENT, t1 // merge region & va bits
#else
        shl         v0 = t2, SLIST_ADR_ALIGMENT // shift va into place
#endif
        ;;

#if defined (NTOS_KERNEL_RUNTIME)
(pt0)   mov         v0 = r0
#endif
        br.ret.sptk brp                         // return function value


        LEAF_EXIT(FirstEntrySList)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\xcptmisc.s ===
//      TITLE("Miscellaneous Exception Handling")
//++
//
// Module Name:
//
//    xcptmisc.s
//
// Abstract:
//
//    This module implements miscellaneous routines that are required to
//    support exception handling. Functions are provided to call an exception
//    handler for an exception, call an exception handler for unwinding, call
//    an exception filter, and call a termination handler.
//
// Author:
//
//    William K. Cheung (wcheung) 15-Jan-1996
//
//    based on the version by David N. Cutler (davec) 12-Sep-1990
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Updated to EAS2.1
//
//--

#include "ksia64.h"

        .file "xcptmisc.s"

//++
//
// EXCEPTION_DISPOSITION
// RtlpExceptionHandler (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN FRAME_POINTERS EstablisherFrame,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PDISPATCHER_CONTEXT DispatcherContext
//    )
//
// Routine Description:
//
//    This function is called when a nested exception occurs. Its function
//    is to retrieve the establisher frame pointer from its establisher's
//    call frame, store this information in the dispatcher context record,
//    and return a disposition value of nested exception.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    EstablisherFrame (a1,a2) - Supplies the memory stack and backing store
//       frame pointers of the establisher of this exception handler.
//
//    ContextRecord (a3) - Supplies a pointer to a context record.
//
//    DispatcherContext (a4) - Supplies a pointer to the dispatcher context
//       record.
//
// Return Value:
//
//    A disposition value ExceptionNestedException is returned if an unwind
//    is not in progress. Otherwise a value of ExceptionContinueSearch is
//    returned.
//
//--

        LEAF_ENTRY(RtlpExceptionHandler)

        //
        // register aliases
        //

        pUwnd       = pt0
        pNot        = pt1


//
// Check if unwind is in progress.
//

        add         t0 = ErExceptionFlags, a0
        ;;
        ld4.nt1     t0 = [t0]
        mov         t1 = EXCEPTION_UNWIND
        ;;

        add         t3 = -8, a1
        and         t0 = t0, t1
        add         t2 = DcEstablisherFrame, a4
        ;;

        ld8.nt1     t4 = [t3]                   // get dispatcher context addr
        cmp4.ne     pUwnd, pNot = zero, t0      // if ne, unwind in progress
        ;;
 (pNot) add         t5 = DcEstablisherFrame, t4
        ;;

//
// If unwind is not in progress - return nested exception disposition.
// And copy the establisher frame pointer structure (i.e. FRAME_POINTERS) 
// to the current dispatcher context.
//
// Otherwise, return continue search disposition
//

 (pNot) ld8.nt1     t6 = [t5], 8
 (pNot) mov         v0 = ExceptionNestedException   // set disposition value
(pUwnd) mov         v0 = ExceptionContinueSearch    // set disposition value
        ;;

 (pNot) ld8.nt1     t7 = [t5]
 (pNot) st8         [t2] = t6, 8
        nop.i       0
        ;;

 (pNot) st8         [t2] = t7
        nop.m       0
        br.ret.sptk.clr brp
        ;;

        LEAF_EXIT(RtlpExceptionHandler)

//++
//
// EXCEPTION_DISPOSITION
// RtlpExecuteEmHandlerForException (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN ULONGLONG MemoryStack,
//    IN ULONGLONG BackingStore,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
//    IN ULONGLONG GlobalPointer,
//    IN PEXCEPTION_ROUTINE ExceptionRoutine
//    )
//
// Routine Description:
//
//    This function stores the establisher's dispatcher context in the stack
//    scratch area, establishes an exception handler, and then calls
//    the specified exception handler as an exception handler. If a nested
//    exception occurs, then the exception handler of this function is called
//    and the establisher frame pointer in the saved dispatcher context
//    is returned to the exception dispatcher via the dispatcher context 
//    parameter of this function's exception handler. If control is returned 
//    to this routine, then the disposition status is returned to the 
//    exception dispatcher.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    MemoryStack (a1) - Supplies the memory stack frame pointer of the 
//       activation record whose exception handler is to be called.
//
//    BackingStore (a2) - Supplies the backing store pointer of the 
//       activation record whose exception handler is to be called.
//
//    ContextRecord (a3) - Supplies a pointer to a context record.
//
//    DispatcherContext (a4) - Supplies a pointer to the dispatcher context
//       record.
//
//    GlobalPointer (a5) - Supplies the global pointer value of the module
//       to which the function belongs.
//
//    ExceptionRoutine (a6) - supplies a pointer to the exception handler
//       that is to be called.
//
// Return Value:
//
//    The disposition value returned by the specified exception handler is
//    returned as the function value.
//
//--

        NESTED_ENTRY_EX(RtlpExecuteEmHandlerForException,RtlpExceptionHandler)

        //
        // register aliases
        //

        rpT0        = t8
        rpT1        = t9

        .prologue
        .fframe     32, tg30

        alloc       t1 = ar.pfs, 0, 0, 7, 0
        mov         t0 = brp
        mov         rpT0 = sp

        add         rpT1 = 8, sp
[tg30:] add         sp = -32, sp
        ;;

        .savesp     rp, 32
        st8         [rpT0] = t0, -8             // save brp
        .savesp     ar.pfs, 32+8
        st8         [rpT1] = t1, 8              // save pfs
        ;;

        PROLOGUE_END

//
// Setup global pointer and branch register for the except handler
//

        ld8         t2 = [a6], PlGlobalPointer - PlEntryPoint
        st8.nta     [rpT0] = a4                 // save dispatcher context addr
        ;;

        ld8         gp = [a6]
        mov         bt0 = t2
        br.call.sptk.many brp = bt0             // call except handler

//
// Save swizzled dispatcher context address onto the stack
//

        .restore    tg40
[tg40:] add         sp = 32, sp                 // deallocate stack frame
        ;;
        ld8.nt1     t0 = [sp]
        add         rpT1 = 8, sp
        ;;

        ld8.nt1     t1 = [rpT1]
        nop.f       0
        mov         brp = t0                    // restore return branch
        ;;

        nop.m       0
        mov         ar.pfs = t1                 // restore pfs
        br.ret.sptk.clr brp                     // return

        NESTED_EXIT(RtlpExecuteEmHandlerForException)

//++
//
// EXCEPTION_DISPOSITION
// RtlpEmUnwindHandler (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN FRAME_POINTERS EstablisherFrame,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PVOID DispatcherContext
//    )
//
// Routine Description:
//
//    This function is called when a collided unwind occurs. Its function
//    is to retrieve the establisher dispatcher context, copy it to the
//    current dispatcher context, and return a disposition value of nested
//    unwind.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    EstablisherFrame (a1,a2) - Supplies the memory stack and backing store
//       frame pointers of the establisher of this exception handler.
//
//    ContextRecord (a3) - Supplies a pointer to a context record.
//
//    DispatcherContext (a4) - Supplies a pointer to the dispatcher context
//       record.
//
// Return Value:
//
//    A disposition value ExceptionCollidedUnwind is returned if an unwind is
//    in progress. Otherwise, a value of ExceptionContinueSearch is returned.
//
//--

        LEAF_ENTRY(RtlpEmUnwindHandler)

        //
        // register aliases
        //

        pUwnd       = pt0
        pNot        = pt1

//
// Check if unwind is in progress.
//

        add         t0 = ErExceptionFlags, a0
        ;;
        ld4.nt1     t0 = [t0]
        mov         t1 = EXCEPTION_UNWIND
        ;;
        and         t0 = t0, t1
        ;;

        cmp4.eq     pNot, pUwnd = zero, t0      // if eq, unwind not in progress
 (pNot) br.cond.sptk Ruh10

        add         t2 = -8, a1
        add         t1 = 8, a4                  // -> target dispatch context+8
        ;;

        ld8.nt1     t2 = [t2]                   // -> source dispatch context
        ;;
        add         t3 = 8, t2                  // -> source dispatch context+8
        nop.i       0
        ;;

//
// Copy the establisher dispatcher context (i.e. DISPATCHER_CONTEXT) contents
// to the current dispatcher context.
//

        ld8         t6 = [t2], 16
        ld8         t7 = [t3], 16
        nop.i       0
        ;;

        ld8         t8 = [t2], 16
        ld8         t9 = [t3], 16
        nop.i       0
        ;;
        
        st8         [a4] = t6, 16
        st8         [t1] = t7, 16
        nop.i       0

        ld8         t10 = [t2], 16
        ld8         t11 = [t3], 16
        nop.i       0
        ;;
 
        ld8         t12 = [t2], 16
        ld8         t13 = [t3]
        nop.i       0
        ;;

        st8         [a4] = t8, 16
        st8         [t1] = t9, 16
        mov         v0 = ExceptionCollidedUnwind    // set disposition value
        ;;

        ld8         t8 = [t2]
        
        st8         [a4] = t10, 16
        st8         [t1] = t11, 16 
        nop.i       0
        ;;

        st8	    [a4] = t12, 16
        st8         [t1] = t13
        ;;
        st8         [a4] = t8
        br.ret.sptk.clr brp                         // return
        ;;


Ruh10:     

//
// If branched to here,
// unwind is not in progress - return continue search disposition.
//

        nop.m       0
(pNot)  mov         v0 = ExceptionContinueSearch    // set disposition value
        br.ret.sptk.clr brp                         // return

        LEAF_EXIT(RtlpEmUnwindHandler)

//++
//
// EXCEPTION_DISPOSITION
// RtlpExecuteEmHandlerForUnwind (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN ULONGLONG MemoryStack,
//    IN ULONGLONG BackingStore,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PVOID DispatcherContext,
//    IN ULONGLONG GlobalPointer,
//    IN PEXCEPTION_ROUTINE ExceptionRoutine
//    )
//
// Routine Description:
//
//    This function allocates a call frame, stores the establisher frame
//    pointer and the context record address in the frame, establishes an
//    exception handler, and then calls the specified exception handler as
//    an unwind handler. If a collided unwind occurs, then the exception
//    handler of of this function is called and the establisher frame pointer
//    and context record address are returned to the unwind dispatcher via
//    the dispatcher context parameter. If control is returned to this routine,
//    then the frame is deallocated and the disposition status is returned to
//    the unwind dispatcher.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    MemoryStack (a1) - Supplies the memory stack frame pointer of the 
//       activation record whose exception handler is to be called.
//
//    BackingStore (a2) - Supplies the backing store pointer of the 
//       activation record whose exception handler is to be called.
//
//    ContextRecord (a3) - Supplies a pointer to a context record.
//
//    DispatcherContext (a4) - Supplies a pointer to the dispatcher context
//       record.
//
//    GlobalPointer (a5) - Supplies the global pointer value of the module
//       to which the function belongs.
//
//    ExceptionRoutine (a6) - supplies a pointer to the exception handler
//       that is to be called.
//
// Return Value:
//
//    The disposition value returned by the specified exception handler is
//    returned as the function value.
//
//--


        NESTED_ENTRY_EX(RtlpExecuteEmHandlerForUnwind, RtlpEmUnwindHandler)

        //
        // register aliases
        //

        .prologue
        .fframe     32, tg10

        rpT0        = t8
        rpT1        = t9


        alloc       t1 = ar.pfs, 0, 0, 7, 0
        mov         t0 = brp
        mov         rpT0 = sp

        add         rpT1 = 8, sp
[tg10:] add         sp = -32, sp
        ;;

        .savepsp     rp, 0
        st8         [rpT0] = t0, -8             // save brp
        .savepsp     ar.pfs, -8
        st8         [rpT1] = t1, 8              // save pfs
        ;;

        PROLOGUE_END

//
// Setup global pointer and branch register for the except handler
//

        ld8         t2 = [a6], PlGlobalPointer - PlEntryPoint
        st8.nta     [rpT0] = a4                 // save dispatcher context addr
        ;;

        ld8         gp = [a6]
        mov         bt0 = t2
 (p0)   br.call.sptk.many brp = bt0             // call except handler

//
// Save swizzled dispatcher context address onto the stack
//

        .restore    tg20
[tg20:] add         sp = 32, sp // deallocate stack frame
        ;;
        ld8.nt1     t0 = [sp]
        add         rpT1 = 8, sp
        ;;

        ld8.nt1     t1 = [rpT1]
        nop.f       0
        mov         brp = t0                    // restore return branch
        ;;

        nop.m       0
        mov         ar.pfs = t1                 // restore pfs
        br.ret.sptk.clr brp                     // return
        ;;

        NESTED_EXIT(RtlpExecuteEmHandlerForUnwind)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\vunwind.c ===
/**
***  Copyright  (C) 1996-1999 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****************************************************************************
***
*** WARNING: ntos\rtl\ia64\vunwind.c and sdktools\imagehlp\vwndia64.c are
***          identical. For sake of maintenance and for debug purposes, 
**           please keep them as this. Thank you.
***
****************************************************************************
**/

#if !defined(BUILD_DBGHELP) && !defined(BUILD_IMAGEHLP)

#include "ntrtlp.h"

#else  // !BUILD_DBGHELP && !BUILD_IMAGEHLP

#define TARGET_IA64
#define _CROSS_PLATFORM_
#define _IA64REG_
#include "walk.h"
#include "private.h"
#include <stdlib.h>

#endif // !BUILD_DBGHELP && !BUILD_IMAGEHLP

#ifdef _IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E)
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwindIa64
#define PRUNTIME_FUNCTION PIMAGE_RUNTIME_FUNCTION_ENTRY
#define RUNTIME_FUNCTION IMAGE_RUNTIME_FUNCTION_ENTRY
#define VUW_DEBUG_PRINT OutputDebugString

#else  // !_IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E) E
#define VUW_DEBUG_PRINT DbgPrint

#endif // !_IMAGEHLP_SOURCE_

#ifdef MASK
#undef MASK
#endif // MASK
#define MASK(bp,value)  (value << bp)

//
// ABI values
//

#define SVR4_ABI      0
#define HPUX_ABI      1
#define NT_ABI        2


#ifdef KERNEL_DEBUGGER
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwind
#endif

#define STATE_RECORD_STACK_SIZE 32

#define SPILLSIZE_OF_FLOAT128_IN_DWORDS   4
#define SPILLSIZE_OF_ULONGLONG_IN_DWORDS  2

#define REGISTER_SIZE                sizeof(ULONGLONG)
#define STATIC_REGISTER_SET_SIZE     32
#define SLOTS_PER_BUNDLE             3

#define R1_MASK              0xC0
#define R1_PREFIX            0x0
#define R1_REGION_TYPE_MASK  0x20
#define R1_LENGTH_MASK       0x1F

#define R2_MASK              0xE0
#define R2_PREFIX            0x40

#define R3_MASK              0xE0
#define R3_PREFIX            0x60
#define R3_REGION_TYPE_MASK  0x3

#define P1_MASK              0xE0
#define P1_PREFIX            0x80
#define P2_MASK              0xF0
#define P2_PREFIX            0xA0
#define P3_MASK              0xF8
#define P3_PREFIX            0xB0
#define P4_MASK              0xFF
#define P4_PREFIX            0xB8
#define P5_MASK              0xFF
#define P5_PREFIX            0xB9
#define P6_MASK              0xE0
#define P6_PREFIX            0xC0
#define P7_MASK              0xF0
#define P7_PREFIX            0xE0
#define P8_MASK              0xFF
#define P8_PREFIX            0xF0
#define P9_MASK              0xFF
#define P9_PREFIX            0xF1
#define P10_MASK             0xFF
#define P10_PREFIX           0xFF

#define B1_MASK              0xC0
#define B1_PREFIX            0x80
#define B1_TYPE_MASK         0x20
#define B1_LABEL_MASK        0x1F
#define B2_MASK              0xE0
#define B2_PREFIX            0xC0
#define B2_ECOUNT_MASK       0x1F
#define B3_MASK              0xF0
#define B3_PREFIX            0xE0
#define B4_MASK              0xF0
#define B4_PREFIX            0xF0
#define B4_TYPE_MASK         0x08

//
// P3 descriptor type
//

#define PSP_GR               0
#define RP_GR                1
#define PFS_GR               2
#define PREDS_GR             3
#define UNAT_GR              4
#define LC_GR                5
#define RP_BR                6
#define RNAT_GR              7
#define BSP_GR               8
#define BSPSTORE_GR          9
#define FPSR_GR              10
#define PRIUNAT_GR           11

//
// P7 descriptor type
//

#define MEM_STACK_F          0
#define MEM_STACK_V          1
#define SPILL_BASE           2
#define PSP_SPREL            3
#define RP_WHEN              4
#define RP_PSPREL            5
#define PFS_WHEN             6
#define PFS_PSPREL           7
#define PREDS_WHEN           8
#define PREDS_PSPREL         9
#define LC_WHEN              10
#define LC_PSPREL            11
#define UNAT_WHEN            12
#define UNAT_PSPREL          13
#define FPSR_WHEN            14
#define FPSR_PSPREL          15

//
// P8 descriptor type
//

#define PSP_PSPREL           0
#define RP_SPREL             1
#define PFS_SPREL            2
#define PREDS_SPREL          3
#define LC_SPREL             4
#define UNAT_SPREL           5
#define FPSR_SPREL           6
#define BSP_WHEN             7
#define BSP_PSPREL           8
#define BSP_SPREL            9
#define BSPSTORE_WHEN        10
#define BSPSTORE_PSPREL      11
#define BSPSTORE_SPREL       12
#define RNAT_WHEN            13
#define RNAT_PSPREL          14
#define RNAT_SPREL           15
#define PRIUNAT_WHEN         16
#define PRIUNAT_PSPREL       17
#define PRIUNAT_SPREL        18


#define STACK_POINTER_GR     12

#define FIRST_PRESERVED_GR                4
#define LAST_PRESERVED_GR                 7
#define NUMBER_OF_PRESERVED_GR            4
#define NUMBER_OF_SCRATCH_GR              24

#define FIRST_LOW_PRESERVED_FR            2
#define LAST_LOW_PRESERVED_FR             5
#define NUMBER_OF_LOW_PRESERVED_FR        4

#define FIRST_HIGH_PRESERVED_FR           16
#define LAST_HIGH_PRESERVED_FR            31
#define NUMBER_OF_HIGH_PRESERVED_FR       16
#define NUMBER_OF_PRESERVED_FR            (NUMBER_OF_LOW_PRESERVED_FR+NUMBER_OF_HIGH_PRESERVED_FR)

#define FIRST_PRESERVED_BR                1
#define LAST_PRESERVED_BR                 5
#define NUMBER_OF_PRESERVED_BR            5

#define NUMBER_OF_PRESERVED_MISC          8

#define NUMBER_OF_PRESERVED_REGISTERS     (NUMBER_OF_PRESERVED_MISC+NUMBER_OF_PRESERVED_BR)


#define REG_MISC_BASE        0
#define REG_PREDS            (REG_MISC_BASE+0)
#define REG_SP               (REG_MISC_BASE+1)
#define REG_PFS              (REG_MISC_BASE+2)
#define REG_RP               (REG_MISC_BASE+3)
#define REG_UNAT             (REG_MISC_BASE+4)
#define REG_LC               (REG_MISC_BASE+5)
#define REG_NATS             (REG_MISC_BASE+6)
#define REG_FPSR             (REG_MISC_BASE+7)

#define REG_BR_BASE          (REG_MISC_BASE+NUMBER_OF_PRESERVED_MISC)

#define REG_BSP              0xff // REG_MISC_BASE+8
#define REG_BSPSTORE         0xff // REG_MISC_BASE+9
#define REG_RNAT             0xff // REG_MISC_BASE+10

//
// Where is a preserved register saved?
//
//     1. stack general register
//     2. memory stack (pspoff)
//     3. memory stack (spoff)
//     4. branch register
//

#define GENERAL_REG          0
#define PSP_RELATIVE         1
#define SP_RELATIVE          2
#define BRANCH_REG           3


#define ADD_STATE_RECORD(States, RegionLength, DescBeginIndex)       \
    States.Top++;                                                    \
    States.Top->IsTarget = FALSE;                                    \
    States.Top->MiscMask = 0;                                        \
    States.Top->FrMask = 0;                                          \
    States.Top->GrMask = 0;                                          \
    States.Top->Label = (LABEL)0;                                    \
    States.Top->Ecount = 0;                                          \
    States.Top->RegionLen = RegionLength;                            \
    States.Top->RegionBegin = UnwindContext.SlotCount;               \
    States.Top->SpWhen = 0;                                          \
    States.Top->SpAdjustment = 0;                                    \
    States.Top->SpillBase = (States.Top-1)->SpillPtr;                \
    States.Top->SpillPtr = (States.Top-1)->SpillPtr;                 \
    States.Top->Previous = States.Current;                           \
    States.Top->DescBegin = DescBeginIndex;                          \
    States.Current = States.Top


#define VALID_LABEL_BIT_POSITION    15

#define LABEL_REGION(Region, Label)                                    \
    Region->Label = Label;                                             \
    Region->MiscMask |= (1 << VALID_LABEL_BIT_POSITION)

#define IS_REGION_LABELED(Region)  \
    (Region->MiscMask & (1 << VALID_LABEL_BIT_POSITION))

#define CHECK_LABEL(State, Label) \
    ( (IS_REGION_LABELED(State)) && (Label == State->Label) )


#define EXTRACT_NAT_FROM_UNAT(NatBit)  \
    NatBit = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);


#if DBG
int UnwindDebugLevel = 0;
# ifdef _IMAGEHLP_SOURCE_
#  define UW_DEBUG(x) if (UnwindDebugLevel) dbPrint##x
# else
#  define UW_DEBUG(x) if (UnwindDebugLevel) DbgPrint##x
# endif
#else
# define UW_DEBUG(x)
#endif // DBG



typedef struct _REGISTER_RECORD {
    ULONG Where : 2;                  // 2-bit field
    ULONG SaveOffset : 30;            // 30 bits for offset, big enough?
    ULONG When;                       // slot offset relative to region
} REGISTER_RECORD, *PREGISTER_RECORD;

typedef ULONG LABEL;

typedef struct _STATE_RECORD {
    struct _STATE_RECORD *Previous;   // pointer to outer nested prologue
    BOOLEAN IsTarget;       // TRUE if the control pc is in this prologue
    UCHAR GrMask;           // Mask that specifies which GRs to be restored
    USHORT MiscMask;        // Mask that specifies which BRs and misc. registers
                            // are to be restored.
                            // N.B. MSBit indicates Label is valid or not.
    ULONG FrMask;           // Mask that specifies which FRs to be restored
    ULONG SpAdjustment;     // size of stack frame allocated in the prologue
    ULONG SpWhen;           // slot offset relative to region
    ULONG SpillPtr;         // current spill location
    ULONG SpillBase;        // spill base of the region
    ULONG RegionBegin;      // first slot of region relative to function entry
    ULONG RegionLen;        // number of slots in the region
    LABEL Label;            // label that identifies a post-prologue state
    ULONG Ecount;           // number of prologue regions to pop
    ULONG DescBegin;        // first prologue descriptor for the region
    ULONG DescEnd;          // last prologue descriptor for the region
} STATE_RECORD, *PSTATE_RECORD;

typedef struct _UNWIND_CONTEXT {
    REGISTER_RECORD MiscRegs[NUMBER_OF_PRESERVED_REGISTERS];
    REGISTER_RECORD Float[NUMBER_OF_PRESERVED_FR];
    REGISTER_RECORD Integer[NUMBER_OF_PRESERVED_GR];
    BOOLEAN ActiveRegionFound;
    UCHAR AlternateRp;
    USHORT Version;
    PUCHAR Descriptors;               // beginning of descriptor data
    ULONG Size;                       // total size of all descriptors
    ULONG DescCount;                  // number of descriptor bytes processed
    ULONG TargetSlot;
    ULONG SlotCount;
} UNWIND_CONTEXT, *PUNWIND_CONTEXT;

typedef struct _STATE_RECORD_STACK {
    ULONG Size;
    PSTATE_RECORD Current;
    PSTATE_RECORD Top;
    PSTATE_RECORD Base;
} STATE_RECORD_STACK, *PSTATE_RECORD_STACK;

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

static USHORT MiscContextOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(CONTEXT, Preds),
    OFFSET(CONTEXT, IntSp),
    OFFSET(CONTEXT, RsPFS),
    OFFSET(CONTEXT, BrRp),
    OFFSET(CONTEXT, ApUNAT),
    OFFSET(CONTEXT, ApLC),
    0,
    0,
    OFFSET(CONTEXT, BrS0),
    OFFSET(CONTEXT, BrS1),
    OFFSET(CONTEXT, BrS2),
    OFFSET(CONTEXT, BrS3),
    OFFSET(CONTEXT, BrS4)
};

static USHORT MiscContextPointersOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, Preds),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, IntSp),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, RsPFS),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrRp),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, ApUNAT),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, ApLC),
    0,
    0,
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrS0),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrS1),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrS2),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrS3),
    OFFSET(KNONVOLATILE_CONTEXT_POINTERS, BrS4)
};

static UCHAR P3RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_UNAT, REG_LC, REG_RP,
     REG_RNAT, REG_BSP, REG_BSPSTORE, REG_FPSR};

static UCHAR P7RecordTypeToRegisterIndex[] =
    {0, REG_SP, 0, REG_SP, REG_RP, REG_RP, REG_PFS, REG_PFS, REG_PREDS,
     REG_PREDS, REG_LC, REG_LC, REG_UNAT, REG_UNAT, REG_FPSR, REG_FPSR};

static UCHAR P8RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_LC, REG_UNAT, REG_FPSR,
     REG_BSP, REG_BSP, REG_BSP, REG_BSPSTORE, REG_BSPSTORE, REG_BSPSTORE,
     REG_RNAT, REG_RNAT, REG_RNAT, REG_NATS, REG_NATS, REG_NATS};

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord,
    IN OUT PUCHAR AbiImmContext
    );

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord
    );


VOID
SrInitialize (
    IN PSTATE_RECORD_STACK StateTable,
    IN PSTATE_RECORD StateRecord,
    IN ULONG Size
    )
{
    StateTable->Size = Size;
    StateTable->Base = StateRecord;
    StateTable->Top = StateRecord;
    StateTable->Current = StateRecord;
    RtlZeroMemory(StateTable->Top, sizeof(STATE_RECORD));
}


ULONG
ReadLEB128 (
    IN PUCHAR Descriptors,
    IN OUT PULONG CurrentDescIndex
    )
{
    PUCHAR Buffer;
    ULONG Value;
    ULONG ShiftCount = 7;
    ULONG Count;

    Buffer = Descriptors + *CurrentDescIndex;
    Count = 1;

    Value = Buffer[0] & 0x7F;
    if (Buffer[0] & 0x80) {
        while (TRUE) {
            Value += ((Buffer[Count] & 0x7F) << ShiftCount);
            if (Buffer[Count++] & 0x80) {
                ShiftCount += 7;
            } else {
                break;
            }
        }
    }

    *CurrentDescIndex += Count;

    return Value;
}


ULONGLONG
RestorePreservedRegisterFromGR (
    IN PCONTEXT Context,
    IN SHORT GrNumber,
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    OUT BOOL *Succeed,
#else
    OUT ULONG64 *SourceAddress,
#endif // _IMAGEHLP_SOURCE_
    OUT PUCHAR Nat OPTIONAL
    )
{
    ULONGLONG Result;
    SHORT Offset;
    IA64_PFS TempIFS;
    ULONG64 TempBsp;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#endif // _IMAGEHLP_SOURCE_

#ifdef _IMAGEHLP_SOURCE_
    *Succeed = FALSE;
#endif // _IMAGEHLP_SOURCE_

    if (GrNumber >= STATIC_REGISTER_SET_SIZE) {

        Offset = GrNumber - STATIC_REGISTER_SET_SIZE;
        TempIFS.ull = Context->StIFS;
        if ( Offset < TempIFS.sb.pfs_sof ) {

            TempBsp = RtlpRseGrowByNumber (Context->RsBSP, Offset);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = ReadMemory(hProcess, TempBsp,
                                  &Result, sizeof(ULONGLONG), &Size);
#else
            *SourceAddress = TempBsp;
            Result = *(PULONGLONG)TempBsp;
#endif // _IMAGEHLP_SOURCE_

        } else {

            UW_DEBUG(("ERROR: Invalid GR!\n"));
        }

    } else {

        if (GrNumber == 0 || GrNumber == 12) {

            //
            // Invalid GR number -> Invalid Unwind Descriptor
            //

            UW_DEBUG(("ERROR: Invalid GR!\n"));

        } else {

            UW_DEBUG(("WARNING: Target register is not a stacked GR!\n"));
            Offset = GrNumber - 1;
            NOT_IMAGEHLP(*SourceAddress = (ULONG64)(&Context->IntGp + Offset));
            Result = *(&Context->IntGp + Offset);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = TRUE;
#endif // _IMAGEHLP_SOURCE_

        }
    }

    if (ARGUMENT_PRESENT(Nat)) {

        //
        // TBD: Pick up the corresponding Nat bit
        //

        *Nat = (UCHAR) 0;

    }

    return (Result);
}


UCHAR
ParseBodyRegionDescriptors (
    IN PUNWIND_CONTEXT UnwindContext,
    IN PSTATE_RECORD_STACK StateTable,
    IN ULONG RegionLen
    )
{
    LABEL Label;
    UCHAR FirstByte;
    BOOLEAN EcountDefined;
    BOOLEAN CopyLabel;
    ULONG Ecount;
    ULONG SlotOffset;
    PSTATE_RECORD StateTablePtr;
    PUCHAR Descriptors;

    CopyLabel = EcountDefined = FALSE;
    Descriptors = UnwindContext->Descriptors;

    while (UnwindContext->DescCount < UnwindContext->Size) {

        FirstByte = Descriptors[UnwindContext->DescCount++];

        if ( (FirstByte & B1_MASK) == B1_PREFIX ) {

            Label = (LABEL)(FirstByte & B1_LABEL_MASK);
            if (FirstByte & B1_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the entry state
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B1: copy=%d, label_num=%d\n",
                     FirstByte & B1_TYPE_MASK ? TRUE : FALSE, Label));

        } else if ( (FirstByte & B2_MASK) == B2_PREFIX ) {

            Ecount = FirstByte & B2_ECOUNT_MASK;
            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B2: ecount=%d, LEB128(slot)=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B3_MASK) == B3_PREFIX ) {

            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            Ecount = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B3: ecount=%d, LEB128 val=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B4_MASK) == B4_PREFIX ) {

            Label = ReadLEB128(Descriptors, &UnwindContext->DescCount);

            if (FirstByte & B4_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the current top of stack
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B4: copy=%d, label_num=%d\n",
                     FirstByte & B4_TYPE_MASK, Label));

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    if (CopyLabel) {
        StateTablePtr = StateTable->Top;
        while (TRUE) {
            if (CHECK_LABEL(StateTablePtr, Label)) {
                StateTable->Current = StateTablePtr;
                break;
            } else if ((StateTablePtr == StateTable->Base)) {
                UW_DEBUG(("Undefined Label %d\n", Label));
                break;
            }
            StateTablePtr--;
        }
    }

    if (EcountDefined) {

        Ecount++;    // Ecount specifies additional level of prologue
                     // regions to undo (i.e. a value of 0 implies 1
                     // prologue region)

        if (UnwindContext->ActiveRegionFound == FALSE) {
            while (Ecount-- > 0) {
                if (StateTable->Current->Previous) {
                    StateTable->Current = StateTable->Current->Previous;
                }

#if DBG
                else {
                    UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                }
#endif // DBG

            }
        } else {

            //
            // control PC is in this body/epilog region
            //

            if ((UnwindContext->SlotCount + RegionLen - SlotOffset)
                    <= UnwindContext->TargetSlot)
            {
                PSTATE_RECORD SrPointer;

                StateTable->Current->Ecount = Ecount;
                SrPointer = StateTable->Current;
                while (Ecount > 0) {

                    if (SrPointer->Previous) {
                        SrPointer->Ecount = Ecount;
                        SrPointer->SpWhen = 0;
                        SrPointer->SpAdjustment = 0;
                        SrPointer = SrPointer->Previous;
                    }

#if DBG
                    else {
                        UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                    }
#endif // DBG
                    Ecount--;

                }
            }
        }
    }

    return FirstByte;
}


ULONGLONG
ProcessInterruptRegion (
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
#else
    IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    OUT PFRAME_POINTERS EstablisherFrame,
#endif _IMAGEHLP_SOURCE_
    IN PUNWIND_CONTEXT UnwindContext,
    IN PCONTEXT Context,
    IN UCHAR AbiImmContext
    )
{
    //
    // no prologue descriptor in interrupt region.
    //

    PCONTEXT PrevContext;
    ULONGLONG NextPc;
    ULONG Index;
    BOOLEAN Success;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#else
    PVOID *Source;
    PVOID Address;
#endif _IMAGEHLP_SOURCE_


    if (AbiImmContext != CONTEXT_FRAME) {

        PKTRAP_FRAME TrapFrame;
        PKEXCEPTION_FRAME ExFrame;
#ifdef _IMAGEHLP_SOURCE_
        KTRAP_FRAME TF;
        KEXCEPTION_FRAME ExF;
#endif // _IMAGEHLP_SOURCE_

        TrapFrame = (PKTRAP_FRAME) Context->IntSp;
#ifdef _IMAGEHLP_SOURCE_
        if (!ReadMemory(hProcess, Context->IntSp, &TF, sizeof(KTRAP_FRAME), &Size))
        {
            return 0;
        }
        TrapFrame = &TF;
#endif // _IMAGEHLP_SOURCE_

        Context->ApUNAT = TrapFrame->ApUNAT;
        Context->StFPSR = TrapFrame->StFPSR;
        Context->Preds = TrapFrame->Preds;
        Context->IntSp = TrapFrame->IntSp;
        Context->StIPSR = TrapFrame->StIPSR;
        Context->StIFS = TrapFrame->StIFS;
        Context->BrRp = TrapFrame->BrRp;
        Context->RsPFS = TrapFrame->RsPFS;

        if (TRAP_FRAME_TYPE(TrapFrame) != SYSCALL_FRAME) {

            //
            // The temporary registers need to be preserved,
            // becuase a leaf function may save a perserved 
            // register tempoary register.
            //

            Context->ApCCV = TrapFrame->ApCCV;
            Context->SegCSD = TrapFrame->SegCSD;
            Context->IntT0 = TrapFrame->IntT0;
            Context->IntT1 = TrapFrame->IntT1;
            Context->IntT2 = TrapFrame->IntT2;
            Context->IntT3 = TrapFrame->IntT3;
            Context->IntT4 = TrapFrame->IntT4;

            //
            // t5 - t22
            //

            memcpy(&Context->IntT5, &TrapFrame->IntT5, 18*sizeof(ULONGLONG));

            //
            // Set branch registers from trap frame & exception frame
            //

            Context->BrT0 = TrapFrame->BrT0;
            Context->BrT1 = TrapFrame->BrT1;


        }

#ifndef _IMAGEHLP_SOURCE_
        if (ARGUMENT_PRESENT(ContextPointers)) {
            ContextPointers->ApUNAT = &TrapFrame->ApUNAT;
            ContextPointers->IntSp = &TrapFrame->IntSp;
            ContextPointers->BrRp = &TrapFrame->BrRp;
            ContextPointers->RsPFS = &TrapFrame->RsPFS;
            ContextPointers->Preds = &TrapFrame->Preds;
        }

        //
        // Inorder for top level exception handers such as KiSystemServiceHandler,
        // the establisher frame must look like it is part of the kernel stack
        // not the user stack.  
        //

        EstablisherFrame->MemoryStackFp = (ULONGLONG) TrapFrame + sizeof(KTRAP_FRAME);
        EstablisherFrame->BackingStoreFp = Context->RsBSP;

#endif // _IMAGEHLP_SOURCE_

        switch (AbiImmContext) {

        case SYSCALL_FRAME:

            //
            // System Call Handler Frame
            //

            Context->RsBSP = RtlpRseShrinkBySOL(TrapFrame->RsBSP, TrapFrame->StIFS);

            
            break;

        case INTERRUPT_FRAME:
        case EXCEPTION_FRAME:

            //
            // External Interrupt Frame / Exception Frame
            //

            Context->RsBSP = RtlpRseShrinkBySOF(TrapFrame->RsBSP, TrapFrame->StIFS);
            break;

        default:

            //
            // should not happen
            //

            UW_DEBUG(("Invalid AbiImmContext type!\n"));
            break;
        }

        Context->RsBSPSTORE = Context->RsBSP;
        Context->RsRNAT = TrapFrame->RsRNAT;

        NextPc = RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                     ((TrapFrame->StIPSR >> PSR_RI) & 0x3));

        return (NextPc);
    }

    //
    // Kernel-to-User thunk, context of the previous frame can be
    // found on the user stack (i.e. context's address = sp+SCRATCH_AREA)
    //

    PrevContext = (PCONTEXT)(Context->IntSp + STACK_SCRATCH_AREA);
#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory(hProcess, (DWORD64)PrevContext, Context, sizeof(CONTEXT), &Size))
    {
        return 0;
    }
    NextPc = RtlIa64InsertIPSlotNumber(Context->StIIP,
                                       ((Context->StIPSR >> PSR_RI) & 0x3));
#else

    RtlCopyMemory(&Context->BrRp, &PrevContext->BrRp,
                  (NUMBER_OF_PRESERVED_BR+3) * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->FltS0, &PrevContext->FltS0,
                  NUMBER_OF_LOW_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->FltS4, &PrevContext->FltS4,
                  NUMBER_OF_HIGH_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->IntS0, &PrevContext->IntS0,
                  NUMBER_OF_PRESERVED_GR * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->IntV0, &PrevContext->IntV0,                  
                  NUMBER_OF_SCRATCH_GR * sizeof(ULONGLONG));
    Context->IntT0 = PrevContext->IntT0;    
    Context->IntT1 = PrevContext->IntT1;    
    
    Context->IntSp = PrevContext->IntSp;
    Context->IntNats = PrevContext->IntNats;
    Context->ApUNAT = PrevContext->ApUNAT;
    Context->ApLC = PrevContext->ApLC;
    Context->ApEC = PrevContext->ApEC;
    Context->Preds = PrevContext->Preds;
    Context->RsPFS = PrevContext->RsPFS;
    Context->RsBSP = PrevContext->RsBSP;
    Context->RsBSPSTORE = PrevContext->RsBSPSTORE;
    Context->RsRSC = PrevContext->RsRSC;
    Context->RsRNAT = PrevContext->RsRNAT;
    Context->StIFS = PrevContext->StIFS;
    Context->StIPSR = PrevContext->StIPSR;

    NextPc = RtlIa64InsertIPSlotNumber(PrevContext->StIIP,
                 ((PrevContext->StIPSR >> PSR_RI) & 0x3));

    EstablisherFrame->MemoryStackFp = Context->IntSp;
    EstablisherFrame->BackingStoreFp = Context->RsBSP;

#endif // _IMAGEHLP_SOURCE_

    return(NextPc);
}


ULONGLONG
RtlVirtualUnwind (
#ifdef _IMAGEHLP_SOURCE_
    HANDLE hProcess,
    ULONGLONG ImageBase,
    ULONGLONG ControlPc,
    PRUNTIME_FUNCTION FunctionEntry,
    PCONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
#define ContextPointers ((PKNONVOLATILE_CONTEXT_POINTERS)0)
#else
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
#endif
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and an especially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the module to which the
        function belongs.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    InFunction - Supplies a pointer to a variable that receives whether the
        control PC is within the current function.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
#ifdef _IMAGEHLP_SOURCE_
    BOOL Succeed;
#endif // _IMAGEHLP_SOURCE_
    PUCHAR Descriptors = NULL;
    UCHAR AbiImmContext = 0xFF;
    ULONG Mask;
    ULONGLONG NextPc;
    ULONG RegionLen;
    UCHAR FirstByte;
    UCHAR Nat;
    SHORT LocalFrameSize;                  // in 8-byte units
    ULONG i;
    PULONG Buffer;
    BOOLEAN IsPrologueRegion;
    BOOLEAN PspRestored;
    ULONGLONG PreviousIntSp;
    PVOID Destination;
    ULONG64 Source;
    ULONG64 *CtxPtr;
    ULONG64 *NatCtxPtr;
    ULONG64 IntNatsSource;
    ULONG64 IntNats;
    ULONG Size;
    PULONGLONG OldTopRnat;
    PULONGLONG NewTopRnat;
    UNWIND_INFO UnwindInfo;
    ULONG64 UnwindInfoPtr;
    UNWIND_CONTEXT UnwindContext;
    PSTATE_RECORD SrPointer;
    STATE_RECORD_STACK StateTable;
    STATE_RECORD StateRecords[STATE_RECORD_STACK_SIZE];

    UnwindInfoPtr = ImageBase + FunctionEntry->UnwindInfoAddress;
#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory( hProcess, (ULONG64)UnwindInfoPtr,
                     &UnwindInfo, sizeof(UNWIND_INFO), &Size))
    {
        return 0;
    }

    UnwindContext.Version = UnwindInfo.Version;
    Size = UnwindInfo.DataLength * sizeof(ULONGLONG);
    if (Size) {
        Descriptors = (PUCHAR) MemAlloc (Size);
        if (!ReadMemory(hProcess,(ULONG64)(UnwindInfoPtr+sizeof(UNWIND_INFO)), Descriptors, Size, &Size)) {
            return 0;
        }
    }
#else
    UnwindContext.Version = ((PUNWIND_INFO)UnwindInfoPtr)->Version;
    Size = ((PUNWIND_INFO)UnwindInfoPtr)->DataLength * sizeof(ULONGLONG);
    Descriptors = (PUCHAR)UnwindInfoPtr + sizeof(UNWIND_INFO);
#endif // _IMAGEHLP_SOURCE_

    UnwindContext.Size = Size;
    UnwindContext.ActiveRegionFound = FALSE;
    UnwindContext.AlternateRp = 0;
    UnwindContext.DescCount = 0;
    UnwindContext.SlotCount = 0;
    UnwindContext.TargetSlot = (ULONG)(((ControlPc - FunctionEntry->BeginAddress - ImageBase) >> 4) * SLOTS_PER_BUNDLE + ((ControlPc >> 2) & 0x3));
    UnwindContext.Descriptors = Descriptors;

    SrInitialize(&StateTable, StateRecords, STATE_RECORD_STACK_SIZE);

    if (Size) {
        FirstByte = Descriptors[UnwindContext.DescCount++];
    }


    while ( (UnwindContext.DescCount < UnwindContext.Size) &&
            (!UnwindContext.ActiveRegionFound) )
    {

        //
        // Assume a prologue region but not an interrupt region.
        //

        IsPrologueRegion = TRUE;

        //
        // Based on the type of region header, dispatch
        // to the corresponding routine that processes
        // the succeeding descriptors until the next
        // region header record.
        //

        if ((FirstByte & R1_MASK) == R1_PREFIX) {

            //
            // region header record in short format
            //

            RegionLen = FirstByte & R1_LENGTH_MASK;

            if (FirstByte & R1_REGION_TYPE_MASK) {
                IsPrologueRegion = FALSE;
            } else {
                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
            }

            UW_DEBUG(("Region R1 format: body=%x, length=%d\n",
                     IsPrologueRegion ? 0 : 1, RegionLen));

        } else if ((FirstByte & R2_MASK) == R2_PREFIX) {

            //
            // general prologue region header
            // N.B. Skip the 2nd byte of the header and proceed to read
            //      the region length; the header descriptors will be
            //      processed again in phase 1.
            //

            ULONG R2DescIndex;

            R2DescIndex = UnwindContext.DescCount - 1;
            UnwindContext.DescCount++;
            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);
            ADD_STATE_RECORD(StateTable, RegionLen, R2DescIndex);
            UW_DEBUG(("Region R2: body=0, length=%d\n", RegionLen));

        } else if ((FirstByte & R3_MASK) == R3_PREFIX) {

            //
            // region header record in long format
            //

            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);

            switch (FirstByte & R3_REGION_TYPE_MASK) {

            case 0:      // prologue region header

                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
                break;

            case 1:      // body region header

                IsPrologueRegion = FALSE;
                break;

            }

            UW_DEBUG(("Region R3: body=%x, length=%d\n",
                      IsPrologueRegion ? 0 : 1, RegionLen));

        } else {

            //
            // Not a region header record -> Invalid unwind descriptor.
            //

            UW_DEBUG(("Invalid unwind descriptor!\n"));

        }

        if (UnwindContext.TargetSlot < (UnwindContext.SlotCount + RegionLen)) {
            UnwindContext.ActiveRegionFound = TRUE;
            StateTable.Current->IsTarget = IsPrologueRegion;
        }

        if (IsPrologueRegion) {
            FirstByte = NewParsePrologueRegionPhase0(&UnwindContext,
                                                     StateTable.Current,
                                                     &AbiImmContext);
        } else {
            FirstByte = ParseBodyRegionDescriptors(&UnwindContext,
                                                   &StateTable,
                                                   RegionLen);
        }

        UnwindContext.SlotCount += RegionLen;
    }

    //
    // Restore the value of psp and save the current NatCr.
    // N.B. If the value is restored from stack/bstore, turn off the
    //      corresponding sp bit in the saved mask associated with the
    //      prologue region in which psp is saved.
    //

    if (ARGUMENT_PRESENT(ContextPointers)) {
        IntNatsSource = (ULONG64)ContextPointers->ApUNAT;
    } 
    IntNats = ContextRecord->ApUNAT;
    PreviousIntSp = ContextRecord->IntSp;
    PspRestored = FALSE;

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {
        NewParsePrologueRegionPhase1(&UnwindContext, SrPointer);

        if (SrPointer->MiscMask & (1 << REG_SP)) {
            if (UnwindContext.MiscRegs[REG_SP].Where == GENERAL_REG) {
                PreviousIntSp = RestorePreservedRegisterFromGR (
                                    ContextRecord,
                                   (SHORT)UnwindContext.MiscRegs[REG_SP].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                                    hProcess,
                                    ReadMemory,
                                    &Succeed,
#else
                                    &Source,
#endif // _IMAGEHLP_SOURCE_
                                    &Nat
                                    );
#ifdef _IMAGEHLP_SOURCE_
                if (!Succeed) {
                    return 0;
                }
#endif // _IMAGEHLP_SOURCE_

            } else {

                Source = ContextRecord->IntSp + UnwindContext.MiscRegs[REG_SP].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                if (!ReadMemory(hProcess, (ULONG64)(Source), &PreviousIntSp, sizeof(ULONGLONG), &Size)) {
                    return 0;
                }
#else
                PreviousIntSp = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                EXTRACT_NAT_FROM_UNAT(Nat);

            }
            ContextRecord->IntNats &= ~(0x1 << STACK_POINTER_GR);
            ContextRecord->IntNats |= (Nat << STACK_POINTER_GR);
            SrPointer->MiscMask &= ~(1 << REG_SP);
            if (ARGUMENT_PRESENT(ContextPointers)) {
                CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                   MiscContextPointersOffset[REG_SP]);
                *CtxPtr = Source;
            }
            PspRestored = TRUE;
        }
        if (PspRestored == FALSE) {
            PreviousIntSp += SrPointer->SpAdjustment * 4;
        }
        SrPointer = SrPointer->Previous;
    }

    if (AbiImmContext != 0xFF) {

        ContextRecord->IntSp = PreviousIntSp;  // trap/context frame address
        NextPc = ProcessInterruptRegion(
#ifdef _IMAGEHLP_SOURCE_
                     hProcess,
                     ReadMemory,
#else
                     ContextPointers,
                     EstablisherFrame,
#endif _IMAGEHLP_SOURCE_
                     &UnwindContext,
                     ContextRecord,
                     AbiImmContext);

        goto FastExit;
    }

    //
    // Restore the contents of any preserved registers saved in this frame.
    //

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {

        Mask = SrPointer->MiscMask;
        UW_DEBUG(("MiscMask = 0x%x\n", Mask));

        for (i = 0; i < NUMBER_OF_PRESERVED_REGISTERS; i++) {
            Destination = (PVOID)((ULONG_PTR)ContextRecord + MiscContextOffset[i]);
            if (Mask & 0x1) {

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                       MiscContextPointersOffset[i]);
                    Source = *CtxPtr;
                }

                if (UnwindContext.MiscRegs[i].Where == GENERAL_REG) {

                    *(PULONGLONG)Destination =
                        RestorePreservedRegisterFromGR (
                            ContextRecord,
                            (SHORT)UnwindContext.MiscRegs[i].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                            hProcess,
                            ReadMemory,
                            &Succeed,
#else
                            &Source,
#endif // _IMAGEHLP_SOURCE_
                            NULL
                            );
#ifdef _IMAGEHLP_SOURCE_
                    if (!Succeed) {
                        return 0;
                    }
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == BRANCH_REG) {

                    //
                    // restore return pointer from branch register
                    //

                    USHORT Offset;

                    Offset = (USHORT)UnwindContext.MiscRegs[i].SaveOffset-FIRST_PRESERVED_BR;
                    Source = (ULONG64)(&ContextRecord->BrS0 + Offset);
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == PSP_RELATIVE) {

                    if ((SrPointer->Ecount == 0) || (UnwindContext.MiscRegs[i].SaveOffset <= (STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                        Source = PreviousIntSp + STACK_SCRATCH_AREA
                                     - UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }


#ifdef _IMAGEHLP_SOURCE_
                        if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                            return 0;
                        }
#else
                        *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                    }

                } else if (UnwindContext.MiscRegs[i].Where == SP_RELATIVE) {

                    //
                    // Make the necessary adjustment depending on whether
                    // the preserved register is saved before or after the
                    // stack pointer has been adjusted in this prologue.
                    //

                    if (UnwindContext.MiscRegs[i].When >= SrPointer->SpWhen && (SrPointer->RegionLen != 0))
                        Source = ContextRecord->IntSp
                                     + UnwindContext.MiscRegs[i].SaveOffset*4;
                    else
                        Source = ContextRecord->IntSp+SrPointer->SpAdjustment*4
                                     + UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                }

                if (ARGUMENT_PRESENT(ContextPointers) && (i != REG_NATS)) {
                    *CtxPtr = Source;
                }

            } else if (Mask == 0) {

                //
                // No more registers to restore
                //

                break;
            }

            Mask = Mask >> 1;
        }

        //
        // Restore preserved FRs (f2 - f5, f16 - f31)
        //

        Mask = SrPointer->FrMask;
        Destination = (PVOID)&ContextRecord->FltS0;
        CtxPtr = (ULONG64 *)&ContextPointers->FltS0;

        UW_DEBUG(("FrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_FR; i++) {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Float[i].SaveOffset <= (STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + STACK_SCRATCH_AREA
                                 - UnwindContext.Float[i].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(FLOAT128), &Size)) {
                        return 0;
                    }
#else
                    *(FLOAT128 *)Destination = *(FLOAT128 *)Source;
#endif // _IMAGEHLP_SOURCE_

                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                    }
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;

            if (i == (NUMBER_OF_LOW_PRESERVED_FR - 1)) {
                Destination = (PVOID)&ContextRecord->FltS4;
                CtxPtr = (ULONG64 *)(&ContextPointers->FltS4);
            } else {
                Destination = (PVOID)((FLOAT128 *)Destination+1);
                CtxPtr++;
            }
        }

        //
        // Restore preserved GRs (r4 - r7)
        //

        Mask = SrPointer->GrMask;
        Destination = (PVOID)&ContextRecord->IntS0;
        CtxPtr = (ULONG64 *)&ContextPointers->IntS0;
        NatCtxPtr = (ULONG64 *)&ContextPointers->IntS0Nat;

        UW_DEBUG(("GrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_GR; i++)
        {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Integer[i].SaveOffset <= (STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + STACK_SCRATCH_AREA
                                 - UnwindContext.Integer[i].SaveOffset*4;

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                    EXTRACT_NAT_FROM_UNAT(Nat);
                    Nat = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);
                    ContextRecord->IntNats &= ~(0x1 << (i+FIRST_PRESERVED_GR));
                    ContextRecord->IntNats |= (Nat << (i+FIRST_PRESERVED_GR));

#ifndef _IMAGEHLP_SOURCE_
                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                        *NatCtxPtr = IntNatsSource;
                    }
#endif
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;
            Destination = (PVOID)((PULONGLONG)Destination+1);
            CtxPtr++;
            NatCtxPtr++;
        }

        ContextRecord->IntSp += SrPointer->SpAdjustment * 4;
        SrPointer = SrPointer->Previous;
    }

    ContextRecord->IntSp = PreviousIntSp;

    //
    // Restore the value of the epilogue count from the PFS
    //

    ContextRecord->ApEC = (ContextRecord->RsPFS >> PFS_EC_SHIFT) &
                               ~(((ULONGLONG)1 << PFS_EC_SIZE) - 1);
    if (ARGUMENT_PRESENT(ContextPointers)) {
        ContextPointers->ApEC = ContextPointers->RsPFS;
    }


FastExit:

    NOT_IMAGEHLP(*InFunction = TRUE);

    if (AbiImmContext == 0xFF) {
        
        //
        // ProcessInterruptRegion fills in these values for traps.
        //

        NOT_IMAGEHLP(EstablisherFrame->MemoryStackFp = ContextRecord->IntSp);
        NOT_IMAGEHLP(EstablisherFrame->BackingStoreFp = ContextRecord->RsBSP);

    }

#ifdef _IMAGEHLP_SOURCE_
    if (Descriptors)
        MemFree(Descriptors);
#endif // _IMAGEHLP_SOURCE_

    if (AbiImmContext == 0xFF) {

        NextPc = *(&ContextRecord->BrRp + UnwindContext.AlternateRp);
#ifndef _IMAGEHLP_SOURCE_
        NextPc = RtlIa64InsertIPSlotNumber((NextPc-0x10), 2);
#endif // _IMAGEHLP_SOURCE_

        //
        // determine the local frame size of previous frame and compute
        // the new bsp.
        //


        OldTopRnat = RtlpRseRNatAddress (RtlpRseGrowBySOF(ContextRecord->RsBSP, ContextRecord->StIFS) - 8);

        ContextRecord->StIFS = MASK(IFS_V, (ULONGLONG)1) | ContextRecord->RsPFS;
        ContextRecord->RsBSP = RtlpRseShrinkBySOL(ContextRecord->RsBSP, ContextRecord->StIFS);
        ContextRecord->RsBSPSTORE = ContextRecord->RsBSP;

        //
        // determine if the RNAT field needs to be updated.
        //

        NewTopRnat = RtlpRseRNatAddress(RtlpRseGrowBySOF(ContextRecord->RsBSP, ContextRecord->StIFS) - 8);

        if (NewTopRnat < OldTopRnat) {

#ifdef _IMAGEHLP_SOURCE_
            Destination = &ContextRecord->RsRNAT;
            Source = NewTopRnat;
            if (!ReadMemory(hProcess, (ULONG64)Source, Destination, 8, &Size)) {
                return 0;
            }
#else
            ContextRecord->RsRNAT = *NewTopRnat;
#endif // _IMAGEHLP_SOURCE_

        }
    }

#ifdef _IMAGEHLP_SOURCE_
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               (ULONGLONG)ContextRecord->IntSp,
               (ULONGLONG)ContextRecord->RsBSP));
#else
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               EstablisherFrame->MemoryStackFp,
               EstablisherFrame->BackingStoreFp));
#endif // _IMAGEHLP_SOURCE_
    return (NextPc);
}


UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State,
    IN OUT PUCHAR AbiImmContext
    )
{
    PUCHAR Desc = UwContext->Descriptors;
    ULONG Offset;
    ULONG FrameSize;
    ULONG Index;
    UCHAR RecType;
    UCHAR FirstByte;
    UCHAR SecondByte;
    ULONG GrSave;
    ULONG TempMask;
    ULONG i;

    while (UwContext->DescCount < UwContext->Size) {

        FirstByte = Desc[UwContext->DescCount++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            continue;

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            UwContext->DescCount += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            UwContext->DescCount += 3;

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            continue;

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                FrameSize = ReadLEB128(Desc, &UwContext->DescCount);

                if (UwContext->TargetSlot > (UwContext->SlotCount+Offset) || State->RegionLen == 0)
                {
                    State->SpAdjustment += FrameSize*4;
                    State->SpWhen = Offset;
                }
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &UwContext->DescCount);
                State->SpillPtr = State->SpillBase;
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d slot= %d\n", RecType, Offset));
                break;

            case PSP_SPREL:
            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P7!\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[UwContext->DescCount++];

            switch (RecType) {

            case PSP_PSPREL:
            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_PSPREL:
            case BSP_SPREL:
            case BSPSTORE_PSPREL:
            case BSPSTORE_SPREL:
            case RNAT_PSPREL:
            case RNAT_SPREL:
            case PRIUNAT_PSPREL:
            case PRIUNAT_SPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            UwContext->DescCount += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[UwContext->DescCount++];
            UCHAR Context = Desc[UwContext->DescCount++];

            *AbiImmContext = Context;

            if (Abi != NT_ABI) {
                VUW_DEBUG_PRINT("Unknown ABI unwind descriptor\n");
            }

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    State->DescEnd = UwContext->DescCount - 2;

    return FirstByte;
}

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State
    )
{
    ULONG FrameSize;
    ULONG Offset;
    ULONG GrSave;
    ULONG BrBase;
    ULONG Index;
    ULONG Count;
    UCHAR RecType;
    UCHAR FirstByte, SecondByte;   // 1st & 2nd bytes of a region header record
    ULONG DescIndex;
    ULONG ImaskBegin;
    UCHAR NextBr, NextGr, NextFr;
    USHORT MiscMask;
    ULONG TempMask;
    ULONG FrMask = 0;
    UCHAR BrMask = 0;
    UCHAR GrMask = 0;
    PUCHAR Desc = UwContext->Descriptors;
    BOOLEAN SpillMaskOmitted = TRUE;

    DescIndex = State->DescBegin;

    FirstByte = Desc[DescIndex];

    if ((FirstByte & R2_MASK) == R2_PREFIX) {

        //
        // general prologue region header; need to process it first
        //

        ULONG GrSave, Count;
        UCHAR MiscMask;
        UCHAR SecondByte;
        USHORT i;

        DescIndex++;
        SecondByte = Desc[DescIndex++];
        MiscMask = ((FirstByte & 0x7) << 1) | ((SecondByte & 0x80) >> 7);
        GrSave = SecondByte & 0x7F;
        ReadLEB128(Desc, &DescIndex);    // advance the descriptor index

        if (GrSave < STATIC_REGISTER_SET_SIZE) {
            UW_DEBUG(("Invalid unwind descriptor!\n"));
        }

        UW_DEBUG(("Region R2: rmask=%x,grsave=%d,length=%d\n",
                  MiscMask, GrSave, State->RegionLen));

        Count = 0;
        for (Index = REG_PREDS; Index <= REG_RP; Index++) {
            if (MiscMask & 0x1) {
                if (!(State->IsTarget) ||
                    (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = GENERAL_REG;
                    UwContext->MiscRegs[Index].SaveOffset = GrSave+Count;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                Count++;
            }
            MiscMask = MiscMask >> 1;
        }
    }

    while (DescIndex <= State->DescEnd) {

        FirstByte = Desc[DescIndex++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            BrMask = FirstByte & ~P1_MASK;
            State->MiscMask |= (BrMask << REG_BR_BASE);

            UW_DEBUG(("Prolog P1: brmask=%x\n", BrMask));

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Count].When = State->RegionLen;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            GrSave = SecondByte & 0x7F;
            BrMask = ((FirstByte & ~P2_MASK) << 1) | ((SecondByte & 0x80) >> 7);
            UW_DEBUG(("Prolog P2: brmask=%x reg base=%d\n", BrMask, GrSave));

            State->MiscMask |= (BrMask << REG_BR_BASE);

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = GENERAL_REG;
                    UwContext->MiscRegs[Count].SaveOffset = GrSave++;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            RecType = ((SecondByte & 0x80) >> 7) | ((FirstByte & 0x7) << 1);
            Index = P3RecordTypeToRegisterIndex[RecType];

            if (RecType == RP_BR) 
            {
                UwContext->AlternateRp = SecondByte & 0x7F;
            } 
            else if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
            {
                UwContext->MiscRegs[Index].Where = GENERAL_REG;
                UwContext->MiscRegs[Index].SaveOffset = SecondByte & 0x7F;
                UwContext->MiscRegs[Index].When = 0;
                State->MiscMask |= MASK(Index,1);

                UW_DEBUG(("Prolog P3: type=%d reg=%d\n",
                          RecType, UwContext->MiscRegs[Index].SaveOffset));
            }

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            SpillMaskOmitted = FALSE;
            ImaskBegin = DescIndex;
            DescIndex += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            GrMask = (Desc[DescIndex] & 0xF0) >> 4;
            FrMask = ((ULONG)(Desc[DescIndex] & 0xF) << 16) |
                         ((ULONG)Desc[DescIndex+1] << 8) |
                         ((ULONG)Desc[DescIndex+2]);

            DescIndex += 3;    // increment the descriptor index

            State->GrMask |= GrMask;
            State->FrMask |= FrMask;

            UW_DEBUG(("Prolog P5: grmask = %x, frmask = %x\n",
                      State->GrMask, State->FrMask));

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            if (FirstByte & 0x10) {

                GrMask = FirstByte & 0xF;
                State->GrMask |= GrMask;

            } else {

                FrMask = FirstByte & 0xF;
                State->FrMask |= FrMask;

            }

            UW_DEBUG(("Prolog P6: is_gr = %d, mask = %x\n",
                      (FirstByte & 0x10) ? 1 : 0,
                      (FirstByte & 0x10) ? State->GrMask : State->FrMask));

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case PSP_SPREL:

                //
                // sp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When = State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d spoff = %d\n", RecType, Offset));
                break;


            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                //
                // psp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P7: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &DescIndex);
                FrameSize = ReadLEB128(Desc, &DescIndex);

                UW_DEBUG(("Prolog P7: type=%d Slot=%d FrameSize=%d\n",
                          RecType, Offset, FrameSize));
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &DescIndex);
                State->SpillPtr = State->SpillBase;
                UW_DEBUG(("Prolog P7: type=%d, spillbase=%d\n",
                          RecType, State->SpillBase));
                break;

            default:

                UW_DEBUG(("invalid unwind descriptors\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[DescIndex++];

            switch (RecType) {

            case PSP_PSPREL:
                 VUW_DEBUG_PRINT("Unsupported Unwind Descriptor!\n");
                 break;

            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_SPREL:
            case BSPSTORE_SPREL:
            case RNAT_SPREL:
            case PRIUNAT_SPREL:

                //
                // sp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When=State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d spoff= %d\n", RecType, Offset));
                break;

            case BSP_PSPREL:
            case BSPSTORE_PSPREL:
            case RNAT_PSPREL:
            case PRIUNAT_PSPREL:

                //
                // psp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P8: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            DescIndex += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[DescIndex++];
            UCHAR Context = Desc[DescIndex++];

        } else {

            UW_DEBUG(("Invalid descriptor!\n"));

        }
    }

    GrMask = State->GrMask;
    FrMask = State->FrMask;
    BrMask = State->MiscMask >> REG_BR_BASE;

    if (!(GrMask | FrMask | BrMask)) {

        return;

    } else if (SpillMaskOmitted && !(State->IsTarget)) {

        //
        // When spillmask is omitted, floating point registers, general
        // registers, and then branch regisers are spilled in order.
        // They are not modified in the prologue region; therefore, there
        // is no need to restore their contents when the control ip is
        // in this prologue region.
        //

        // 1. floating point registers

        State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        while (FrMask & 0xFFFFF) {
            if (FrMask & 0x80000) {
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;
            }
            FrMask = FrMask << 1;
            NextFr--;
        }

        // 2. branch registers

        NextBr = REG_BR_BASE + NUMBER_OF_PRESERVED_BR - 1;
        while (BrMask & 0x1F) {
            if (BrMask & 0x10) {
                if (UwContext->MiscRegs[NextBr].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[NextBr].SaveOffset = State->SpillPtr;
                }
            }
            BrMask = BrMask << 1;
            NextBr--;
        }

        // 3. general registers

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        while (GrMask & 0xF) {
            if (GrMask & 0x8) {
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;
            }
            GrMask = GrMask << 1;
            NextGr--;
        }

    } else if (SpillMaskOmitted && State->IsTarget) {

        State->GrMask = 0;
        State->FrMask = 0;
        State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;

    } else if (SpillMaskOmitted == FALSE) {

        ULONG Length;

        if (State->IsTarget) {

            //
            // control ip is in the prologue region; clear the masks
            // and then process the imask to determine which preserved
            // Gr/Fr/Br have been saved and set the corresponding bits.
            //

            State->GrMask = 0;
            State->FrMask = 0;
            State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;
            Length = UwContext->TargetSlot - State->RegionBegin;
        } else {
            Length = State->RegionLen;
        }

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        NextBr = NUMBER_OF_PRESERVED_BR - 1;
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        for (Count = 0; Count < Length; Count++) {

            if ((Count % 4) == 0) {
                FirstByte = Desc[ImaskBegin++];
            } else {
                FirstByte = FirstByte << 2;
            }

            switch (FirstByte & 0xC0) {

            case 0x40:                  // 0x01 - save next fr

                while ( !(FrMask & 0x80000) && (NextFr > 0) ) {
                    NextFr--;
                    FrMask = FrMask << 1;
                }

                UW_DEBUG(("spilled register FS%lx\n", (ULONG)NextFr));

                State->FrMask |= MASK(NextFr,1);
                UwContext->Float[NextFr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;

                NextFr--;
                FrMask = FrMask << 1;
                break;

            case 0x80:                  // 0x10 - save next gr

                while ( !(GrMask & 0x8) && (NextGr > 0) ) {
                    NextGr--;
                    GrMask = GrMask << 1;
                }

                UW_DEBUG(("spilled register S%lx\n", (ULONG)NextGr));

                State->GrMask |= MASK(NextGr,1);
                UwContext->Integer[NextGr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;

                NextGr--;
                GrMask = GrMask << 1;
                break;

            case 0xC0:                  // 0x11 - save next br

                while ( !(BrMask & 0x10) && (NextBr > 0) ) {
                    NextBr--;
                    BrMask = BrMask << 1;
                }

                UW_DEBUG(("spilled register BS%lx\n", (ULONG)NextBr));

                Index = REG_BR_BASE + NextBr;
                State->MiscMask |= MASK(Index,1);
                UwContext->MiscRegs[Index].When = Count;
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[Index].SaveOffset = State->SpillPtr;
                }

                NextBr--;
                BrMask = BrMask << 1;
                break;

            default:                    // 0x00 - save no register
                break;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\ia64\trampoln.s ===
//++
//
// Module Name:
//
//    trampoln.s
//
// Abstract:
//
//    This module implements the trampoline code necessary to dispatch user
//    mode APCs.
//
// Author:
//
//    William K. Cheung  25-Oct-1995
//
// Environment:
//
//    User mode only.
//
// Revision History:
//
//    08-Feb-1996    Updated to EAS 2.1
//
//--

#include "ksia64.h"

        .file   "trampoln.s"

        PublicFunction(RtlpCaptureRnats)
        PublicFunction(RtlDispatchException)
        PublicFunction(RtlRaiseException)
        PublicFunction(RtlRaiseStatus)
        PublicFunction(ZwContinue)
        PublicFunction(ZwCallbackReturn)
        PublicFunction(ZwRaiseException)
        PublicFunction(ZwTestAlert)
        .global     Wow64PrepareForException


//++
//
// EXCEPTION_DISPOSITION
// KiUserApcHandler (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN ULONG EstablisherFrame,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PDISPATCHER_CONTEXT DispatcherContext
//
// Routine Description:
//
//    This function is called when an exception occurs in an APC routine
//    or one of its dynamic descendents and when an unwind through the
//    APC dispatcher is in progress. If an unwind is in progress, then test
//    alert is called to ensure that all currently queued APCs are executed.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    EstablisherFrame (a1) - Supplies the frame pointer of the establisher
//       of this exception handler.
//
//    ContextRecord (a2) - Supplies a pointer to a context record.
//
//    DispatcherContext (a3) - Supplies a pointer to the dispatcher context
//       record.
//
// Return Value:
//
//    ExceptionContinueSearch is returned as the function value.
//
//--

        NESTED_ENTRY (KiUserApcHandler)

        //
        // register aliases
        //

        pUwnd       = pt1
        pNot        = pt2


        NESTED_SETUP(1, 2, 0, 0)
        add         t0 = ErExceptionFlags, a0
        ;;

        PROLOGUE_END

        ld4         t2 = [t0]                   // get exception flags
        ;;
        and         t2 = EXCEPTION_UNWIND, t2   // check if unwind in progress
        ;;

        cmp4.ne     pUwnd, pNot = zero, t2
        ;;

 (pNot) add         v0 = ExceptionContinueSearch, zero
 (pNot) br.ret.sptk.clr brp                     // return
(pUwnd) br.call.spnt.many brp = ZwTestAlert

//
// restore preserved states and set the disposition value to continue search
//

        add         v0 = ExceptionContinueSearch, zero
        mov         brp = savedbrp              // restore return link
        nop.b       0
     
        nop.m       0
        mov         ar.pfs = savedpfs           // restore pfs
        br.ret.sptk.clr brp                     // return

        NESTED_EXIT (KiUserApcHandler)

//++
//
// VOID
// KiUserApcDispatcher (
//    IN PVOID NormalContext,
//    IN PVOID SystemArgument1,
//    IN PVOID SystemArgument2,
//    IN PKNORMAL_ROUTINE NormalRoutine
//    )
//
// Routine Description:
//
//    This routine is entered on return from kernel mode to deliver an APC
//    in user mode. The stack frame for this routine was built when the
//    APC interrupt was processed and contains the entire machine state of
//    the current thread. The specified APC routine is called and then the
//    machine state is restored and execution is continued.
//
// Arguments:
//
//
// Transfer the context information to the user stack, initialize the
// APC routine parameters, and modify the trap frame so execution will
// continue in user mode at the user mode APC dispatch routine.
//
// We build the following structure on the user stack:
//
//             |                               |  
//             |-------------------------------|
//             |                               |
//             |   Interrupted user's          |
//             |   stack frame                 |
//             |                               |
//             |                               |
//             |-------------------------------|
//             |   Slack Space due to the      |
//             |   16-byte stack alignment     |
//             | - - - - - - - - - - - - - - - |
//             |     NormalRoutine             |
//             |     SystemArgument2           |
//             |     SystemArgument1           |
//             |     NormalContext             |
//             | - - - - - - - - - - - - - - - |
//             |   Context Frame               |
//             |      Filled in with state     |
//             |      of interrupted user      |
//             |      program                  |
//             | - - - - - - - - - - - - - - - |
//             |   Stack Scratch Area          |
//             |-------------------------------|
//             |                               |
//
// Return Value:
//
//    None.
//
//
// N.B. On entry, sp points to the stack scratch area at the top of the 
//      memory stack.
//
//--

        NESTED_ENTRY_EX (KiUserApcDispatch, KiUserApcHandler)
        ALTERNATE_ENTRY (KiUserApcDispatcher)

        .prologue
        .unwabi  @nt,  CONTEXT_FRAME

        .regstk     0, 0, 3, 0

        rBsp        = t10                       // BspStore
        rpCr        = t11                       // pointer to context record
        rpT1        = t12                       // temporary pointer

        alloc       t22 = ar.pfs, 0, 0, 3, 0    // 3 outputs
        add         t10 = STACK_SCRATCH_AREA+ContextFrameLength+24, sp
        add         t11 = STACK_SCRATCH_AREA+ContextFrameLength, sp
        ;;

        PROLOGUE_END

        ld8.nta     t12 = [t10], -8
        movl        s1 = _gp
        ;;

        ld8.nta     out0 = [t11], 8
        ld8.nta     t13 = [t12], PlGlobalPointer-PlEntryPoint
        ;;

        ld8.nta     out1 = [t11], 8
        ld8.nta     out2 = [t10]
        mov         bt0 = t13

        ld8.nta     gp = [t12]
        br.call.sptk.many brp = bt0             // call APC routine
        ;;

//
// On return, setup global pointer and branch register to call ZwContinue.
// Also, flush the RSE to sync up the bsp and bspstore pointers.  The 
// corresponding field in the context record is updated too.
//

        flushrs
        mov         out1 = 1                    // set TestAlert to TRUE
        ;;

        add         out0 = STACK_SCRATCH_AREA, sp   // context record address
        mov         gp = s1                     // restore gp
        br.call.sptk.many brp = ZwContinue
        ;;

//
// if successful, ZwContinue does not return here;
// otherwise, error happened.
//

        mov         gp = s1                     // restore gp
        mov         s0 = v0                     // save the return status
        ;;

Kuad10:
        mov         out0 = s0                   // setup 1st argument
        br.call.sptk.many brp = RtlRaiseStatus
        ;;
        
        nop.m       0
        nop.i       0
        br          Kuad10                      // loop on return

        NESTED_EXIT(KiUserApcDispatch)


//++
//
// VOID
// KiUserCallbackDispatcher (
//    VOID
//    )
//
// Routine Description:
//
//    This routine is entered on a callout from kernel mode to execute a
//    user mode callback function. All arguments for this function have
//    been placed on the stack.
//
// Arguments:
//
//    (sp + 32 + CkApiNumber) - Supplies the API number of the callback 
//                              function that is to be executed.
//
//    (sp + 32 + CkBuffer) - Supplies a pointer to the input buffer.
//
//    (sp + 32 + CkLength) - Supplies the input buffer length.
//
// Return Value:
//
//    This function returns to kernel mode.
//
// N.B. Preserved register s1 is used to save ZwCallbackReturn plabel address.
//      On entry, gp is set to the global pointer value of NTDLL
//
//--

        NESTED_ENTRY(KiUserCallbackDispatch)

        .prologue
        .savesp     rp, STACK_SCRATCH_AREA+CkBrRp
        .savesp     ar.pfs, STACK_SCRATCH_AREA+CkRsPFS
        .vframesp   STACK_SCRATCH_AREA+CkIntSp

        nop.m       0
        nop.m       0
        nop.i       0
        ;;

        PROLOGUE_END

        ALTERNATE_ENTRY(KiUserCallbackDispatcher)


        //
        // register aliases
        //

        rpT0        = t0                        // temporary pointer
        rpT1        = t1                        // temporary pointer
        rT0         = t2                        // temporary value
        rFunc       = t3                        // callback function entry
        rApi        = t4


        alloc       t22 = ar.pfs, 0, 0, 3, 0    // 3 outputs max.
        mov         teb = kteb                  // sanitize teb
        add         rpT0 = STACK_SCRATCH_AREA + CkApiNumber, sp
        movl        gp = _gp
        ;;
  
        ld4         rApi = [rpT0], CkBuffer - CkApiNumber   // get API number
        add         rpT1 = TePeb, teb
        mov         s0 = gp
        ;;

//
// load both input buffer address and length into scratch register t2
// and then deposit them into registers out0 & out1 respectively.
//
// N.B. t0 is 8-byte aligned.
//

        LDPTRINC(out0, rpT0, CkLength-CkBuffer) // input buffer address
        LDPTR(t11, rpT1)                        // get address of PEB
#if defined(_WIN64)
        shl         rApi = rApi, 3              // compute offset to table entry
#else
        shl         rApi = rApi, 2              // compute offset to table entry
#endif
        ;;

        ld4         out1 = [rpT0]               // get input buffer length
        add         t5 = PeKernelCallbackTable, t11
        ;;
        LDPTR(rFunc, t5)                        // address of callback table
        ;;

        add         rFunc = rApi, rFunc         // compute addr of table entry
        ;;
        LDPTR(t6, rFunc)                        // get plabel's address
        ;;

        ld8.nt1     t9 = [t6], PlGlobalPointer-PlEntryPoint  // load entry point address
        ;;

        ld8.nt1     gp = [t6]                   // load callee's GP
        mov         bt0 = t9
        br.call.sptk.many brp = bt0             // invoke the callback func
  
//
// If a return from the callback function occurs, then the output buffer
// address and length are returned as NULL.
//

        mov         out0 = zero                 // NULL output buffer addr
        mov         out1 = zero                 // zero output buffer len

        mov         out2 = v0                   // set completion status
        mov         gp = s0
        br.call.sptk.many brp = ZwCallbackReturn

//
// Unsuccessful completion after attempting to return to kernel mode. Use
// the return status as the exception code, set noncontinuable exception and
// attempt to raise another exception. Note there is no return from raise
// status.
//

        nop.m       0
        mov         gp = s0                     // restore our own GP
        mov         s0 = v0                     // save status value
        ;;
  
Kucd10:
        mov         out0 = s0                   // set status value
        br.call.sptk.many brp = RtlRaiseStatus
        
        nop.m       0
        nop.m       0
        br          Kucd10                      // jump back to Kucd10

        NESTED_EXIT(KiUserCallbackDispatch)

//++
//
// VOID
// KiUserExceptionDispatcher (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN PCONTEXT ContextRecord
//    )
//
// Routine Description:
//
//    This routine is entered on return from kernel mode to dispatch a user
//    mode exception. If a frame based handler handles the exception, then
//    the execution is continued. Else last chance processing is performed.
//
// Arguments:
//
//    s0 - Supplies a pointer to an exception record.
//
//    s1 - Supplies a pointer to a context record.
//
// Return Value:
//
//    None.
//
// N.B. preserved register s3 is used to save the current global pointer.
//
//--

        NESTED_ENTRY (KiUserExceptionDispatch)
        ALTERNATE_ENTRY(KiUserExceptionDispatcher)

        .prologue
        .unwabi  @nt,  CONTEXT_FRAME

        alloc       t0 = ar.pfs, 0, 1, 3, 0
        mov         teb = kteb                  // sanitize teb
        mov         s3 = gp                     // save global pointer
        ;;

        PROLOGUE_END

        flushrs                                 // flush the RSE
        ;;
        mov         out0 = s1
        br.call.sptk.many brp = RtlpCaptureRnats
        ;;

        add         t1 = @gprel(Wow64PrepareForException), gp
        ;;
        ld8         t1 = [t1]
        ;;
        cmp.ne      pt1, pt0 = zero, t1         // Wow64PrepareForException != NULL?
        ;;
 (pt1)  ld8         t2 = [t1], PlGlobalPointer - PlEntryPoint
        ;;
 (pt1)  ld8         gp = [t1]
 (pt1)  mov         bt0 = t2
 (pt1)  br.call.spnt.few brp = bt0
        ;;

        mov         gp = s3

        mov         out0 = s0
        mov         out1 = s1
        br.call.sptk.many brp = RtlDispatchException

        cmp4.eq     pt1, pt0 = zero, v0         // result is FALSE ?
        ;;
 (pt1)  mov         out2 = zero
        mov         gp = s3

 (pt0)  add         out0 = 0, s1
 (pt0)  mov         out1 = zero                 // set test alert to FALSE.
 (pt0)  br.call.sptk.many brp = ZwContinue
        ;;

 (pt1)  add         out0 = 0, s0
 (pt1)  mov         out1 = s1
 (pt1)  br.call.sptk.many brp = ZwRaiseException
        ;;

//
// Common code for nonsuccessful completion of the continue or last chance
// processing service.  Use the return status as the exception code, set
// noncontinuable exception and attempt to raise another exception.  Note
// that the stack grows and eventually this loop will end.
//

Kued10:

//
// allocate space for exception record
//

        nop.m       0
        movl        s2 = EXCEPTION_NONCONTINUABLE   // set noncontinuable flag.

        add         sp = -ExceptionRecordLength, sp
        nop.f       0
        mov         gp = s3                     // restore gp
        ;;

        add         out0 = STACK_SCRATCH_AREA, sp   // get except record addr
        add         t2 = ErExceptionFlags+STACK_SCRATCH_AREA, sp
        add         t3 = ErExceptionCode+STACK_SCRATCH_AREA, sp
        ;;

//
// Set exception flags and exception code.
//

        st4         [t2] = s2, ErExceptionRecord - ErExceptionFlags
        st4         [t3] = v0, ErNumberParameters - ErExceptionCode
        ;;

//
// Set exception record and number of parameters.
// Then call RtlRaiseException
//

        st4         [t2] = s0
        st4         [t3] = zero
        br.call.sptk.many brp = RtlRaiseException

        nop.m       0
        nop.m       0
        br          Kued10                      // loop on return

        NESTED_EXIT(KiUserExceptionDispatch)


//++
//
// NTSTATUS
// KiRaiseUserExceptionDispatcher (
//    IN NTSTATUS ExceptionCode
//    )
//
// Routine Description:
//
//    This routine is entered on return from kernel mode to raise a user
//    mode exception.
//
// Arguments:
//
//    v0 - Supplies the status code to be raised.
//
// Return Value:
//
//    ExceptionCode
//
//--

//
// N.B. This function is not called in the typical way. Instead of a normal
// subroutine call to the nested entry point above, the alternate entry point
// address below is stuffed into the Fir address of the trap frame. Thus when
// the kernel returns from the trap, the following code is executed directly.
//


        NESTED_ENTRY(KiRaiseUserExceptionDispatch)

        .prologue
        .savepsp    ar.pfs, -8
        nop.m       0
        .savepsp    rp, 0
        nop.m       0
        nop.i       0
        ;;

        ALTERNATE_ENTRY(KiRaiseUserExceptionDispatcher)

//
// ar.pfs and brp have been saved on the stack in the scratch area.
//

        alloc       t22 = ar.pfs, 8, 1, 1, 0
        ld8.nta     t3 = [sp]
        .fframe     ExceptionRecordLength+STACK_SCRATCH_AREA, tg10
[tg10:] add         sp = -ExceptionRecordLength-STACK_SCRATCH_AREA, sp
        ;;
 
        PROLOGUE_END

        add         t1 = STACK_SCRATCH_AREA+ErExceptionRecord, sp
        add         t2 = STACK_SCRATCH_AREA+ErExceptionFlags, sp
        add         t5 = TeExceptionCode, teb
        ;;

        //
        // set exception code and exception flags
        //

        ld4         t4 = [t5]
        movl        gp = _gp                // setup gp to ntdll's

        st8         [t1] = zero, ErExceptionCode - ErExceptionRecord
        st4         [t2] = zero, ErExceptionAddress - ErExceptionFlags
        mov         loc0 = v0
        ;;
        st4         [t1] = t4, ErNumberParameters - ErExceptionCode
        add         out0 = STACK_SCRATCH_AREA, sp
        ;;

        //
        // set exception record and exception address
        //

        st4         [t1] = zero               // set number of parameters
        STPTR(t2, t3)
        br.call.sptk.many brp = RtlRaiseException

        add         t1 = ExceptionRecordLength+STACK_SCRATCH_AREA, sp
        add         t2 = ExceptionRecordLength+STACK_SCRATCH_AREA+8, sp
        mov         v0 = loc0
        ;;

        ld8.nta     t3 = [t1]
        ld8.nta     t4 = [t2]
        ;;
        mov         brp = t3

        .restore    tg20
[tg20:] add         sp = ExceptionRecordLength+STACK_SCRATCH_AREA, sp
        mov         ar.pfs = t4
        br.ret.sptk.clr brp

        NESTED_EXIT(KiRaiseUserExceptionDispatcher)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\array.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    array.c

Abstract:

    This module contains some slightly higher level functions
    for dealing the arrays.

Author:

    Jay Krell (JayKrell) April 2001

Revision History:

Environment:

    anywhere
--*/

#include "ntrtlp.h"

//
// the type of the comparison callback used by qsort and bsearch,
// and optionally RtlMergeSortedArrays and RtlRemoveAdjacentEquivalentArrayElements
//
typedef
int
(__cdecl  *
RTL_QSORT_BSEARCH_COMPARISON_FUNCTION)(
    CONST VOID * Element1,
    CONST VOID * Element2
    );

//
// the type of the comparison callback usually used by
// RtlMergeSortedArrays and RtlRemoveAdjacentEquivalentArrayElements
//
typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *
RTL_COMPARE_ARRAY_ELEMENT_FUNCTION)(
    PVOID Context,
    IN CONST VOID * Element1,
    IN CONST VOID * Element2,
    IN SIZE_T       ElementSize
    );

//
// the callback to RtlMergeSortedArrays and RtlRemoveAdjacentEquivalentArrayElements
// to copy an elmement, if not via RtlCopyMemory
//
typedef
VOID
(NTAPI *
RTL_COPY_ARRAY_ELEMENT_FUNCTION)(
    PVOID        Context,
    PVOID        To,
    CONST VOID * From,
    IN SIZE_T    ElementSize
    );


#define \
RTL_MERGE_SORTED_ARRAYS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE \
    (0x00000001)

// deliberately not NTSYSAPI, so it can be linked to statically w/o warning
NTSTATUS
NTAPI
RtlMergeSortedArrays(
    IN ULONG                                Flags,
    IN CONST VOID *                         VoidArray1,
    IN SIZE_T                               Count1,
    IN CONST VOID *                         VoidArray2,
    IN SIZE_T                               Count2,
    // VoidResult == NULL is useful for getting the count first.
    OUT PVOID                               VoidResult      OPTIONAL,
    OUT PSIZE_T                             OutResultCount,
    IN SIZE_T                               ElementSize,
    IN RTL_COMPARE_ARRAY_ELEMENT_FUNCTION   CompareCallback,
    PVOID                                   CompareContext  OPTIONAL,
    IN RTL_COPY_ARRAY_ELEMENT_FUNCTION      CopyCallback    OPTIONAL,
    PVOID                                   CopyContext     OPTIONAL
    );

#define \
RTL_REMOVE_ADJACENT_EQUIVALENT_ARRAY_ELEMENTS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE \
    (0x00000001)

// deliberately not NTSYSAPI, so it can be linked to statically w/o warning
NTSTATUS
NTAPI
RtlRemoveAdjacentEquivalentArrayElements(
    IN ULONG                                Flags,
    IN OUT PVOID                            VoidArray,
    IN SIZE_T                               Count,
    OUT PSIZE_T                             OutCount,
    IN SIZE_T                               ElementSize,
    IN RTL_COMPARE_ARRAY_ELEMENT_FUNCTION   CompareCallback,
    PVOID                                   CompareContext  OPTIONAL,
    IN RTL_COPY_ARRAY_ELEMENT_FUNCTION      CopyCallback    OPTIONAL,
    PVOID                                   CopyContext     OPTIONAL
    );

typedef CONST VOID* PCVOID;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
RtlpQsortBsearchCompareAdapter(
    PVOID       VoidContext,
    IN PCVOID   VoidElement1,
    IN PCVOID   VoidElement2,
    IN SIZE_T   ElementSize
    )
/*++

Routine Description:

    This function is an "adapter" used so people can use comparison functions intended
    for use with qsort and bsearch with RtlMergeSortedArrays
    and RtlRemoveAdjacentEquivalentArrayElements.

Arguments:

    VoidContext - the actual qsort/bsearch comparison callback function
    VoidElement1 - an elment to compare
    VoidElement2 - another elment to compare


Return Value:

    GenericLessThan
    GenericGreaterThan
    GenericEqual

--*/
{
    CONST RTL_QSORT_BSEARCH_COMPARISON_FUNCTION QsortBsearchCompareCallback =
        (RTL_QSORT_BSEARCH_COMPARISON_FUNCTION)VoidContext;

    CONST int i = (*QsortBsearchCompareCallback)(VoidElement1, VoidElement2);

    return (i < 0) ? GenericLessThan : (i > 0) ? GenericGreaterThan : GenericEqual;
}

VOID
NTAPI
RtlpDoNothingCopyArrayElement(
    PVOID           Context,
    OUT PVOID       To,
    IN CONST VOID * From,
    IN SIZE_T       ElementSize
    )
/*++

Routine Description:

    RtlMergeSortedArrays uses this for CopyCallback when ResultArray==NULL, which
    is useful for a two pass sequence that first determines
    the size of the result, then allocates it, then writes it.

Arguments:

    Context - ignored
    To - ignored
    From - ignored

Return Value:

    none

--*/
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(To);
    UNREFERENCED_PARAMETER(From);
    // do nothing, deliberately
}

NTSTATUS
NTAPI
RtlRemoveAdjacentEquivalentArrayElements( // aka "unique" (if sorted)
    IN ULONG                                Flags,
    IN OUT PVOID                            VoidArray,
    IN SIZE_T                               Count,
    OUT PSIZE_T                             OutCount,
    IN SIZE_T                               ElementSize,
    IN RTL_COMPARE_ARRAY_ELEMENT_FUNCTION   CompareCallback,
    PVOID                                   CompareContext  OPTIONAL,
    IN RTL_COPY_ARRAY_ELEMENT_FUNCTION      CopyCallback    OPTIONAL, // defaults to RtlCopyMemory
    PVOID                                   CopyContext     OPTIONAL
    )
/*++

Routine Description:

    remove ajdacent equivalent elements from an array
    aka "unique", if the array is sorted

Arguments:

    VoidArray - the start of a array

    Count - the number of elements in the array

    ElementSize - the sizes of the elements in the array, in bytes

    CompareCallback - a tristate comparison function in the style of qsort/bsearch

Return Value:

    The return value is the number of elements contained
    in the resulting array.

--*/
{
    CONST PUCHAR Base = (PUCHAR)VoidArray;
    CONST PUCHAR End = (PUCHAR)(Base + Count * ElementSize);
    PUCHAR LastAccepted = Base;
    PUCHAR NextAccepted = (Base + ElementSize);
    PUCHAR Iterator = NextAccepted;
    NTSTATUS Status;

    if (OutCount == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    *OutCount = 0;

    if ((Flags & ~RTL_REMOVE_ADJACENT_EQUIVALENT_ARRAY_ELEMENTS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & RTL_REMOVE_ADJACENT_EQUIVALENT_ARRAY_ELEMENTS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE) != 0) {
        CompareCallback = (RTL_COMPARE_ARRAY_ELEMENT_FUNCTION)RtlpQsortBsearchCompareAdapter;
        CompareContext = (PVOID)CompareCallback;
    }

    if (Count < 2) {
        *OutCount = 1;
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    Count = 1; // always take the first element
    for ( ; Iterator != End ; Iterator += ElementSize) {
        if ((*CompareCallback)(CompareContext, Iterator, LastAccepted, ElementSize) != 0) {
            if (Iterator != NextAccepted) {
                if (CopyCallback != NULL) {
                    (*CopyCallback)(CopyContext, NextAccepted, Iterator, ElementSize);
                } else {
                    RtlCopyMemory(NextAccepted, Iterator, ElementSize);
                }
            } else {
                // do not bother copying until we have skipped any elements
            }
            LastAccepted = NextAccepted;
            NextAccepted += ElementSize;
            Count += 1;
        }
    }
    *OutCount = Count;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlMergeSortedArrays(
    IN ULONG                                Flags,
    IN PCVOID                               VoidArray1,
    IN SIZE_T                               Count1,
    IN PCVOID                               VoidArray2,
    IN SIZE_T                               Count2,
    OUT PVOID                               VoidResult      OPTIONAL,
    OUT PSIZE_T                             OutResultCount,
    IN SIZE_T                               ElementSize,
    IN RTL_COMPARE_ARRAY_ELEMENT_FUNCTION   CompareCallback,
    PVOID                                   CompareContext  OPTIONAL,
    IN RTL_COPY_ARRAY_ELEMENT_FUNCTION      CopyCallback,
    PVOID                                   CopyContext     OPTIONAL
    )
/*++

Routine Description:

    Merge two sorted arrays into a third array.
    The third array must be preallocated to the size of the sum
    of the sizes of the two input arrays

Arguments:

    VoidArray1 - the start of an array

    Count1 - the number of elements in the array that starts at VoidArray1

    VoidArray2 - the start of another array

    Count2 - the number of elements in the array that starts at VoidArray2

    VoidResult - the resulting array, must be capable of holding Count1+Count2 elements
        if this parameter is not supplied, no copying is done and the just the
        resulting required size is returned

    ElementSize - the sizes of the elements in all the arrays, in bytes

    CompareCallback - a tristate comparison function in the style of qsort/bsearch, plus it takes an additional parameter for context

Return Value:

    The return value is the number of elements contained
    in the resulting array VoidResult.

--*/
{
    PUCHAR Array1 = (PUCHAR)VoidArray1;
    PUCHAR Array2 = (PUCHAR)VoidArray2;
    PUCHAR ResultArray = (PUCHAR)VoidResult;
    SIZE_T ResultCount = 0;
    NTSTATUS Status;

    if (OutResultCount == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    *OutResultCount = 0;

    if ((Flags & ~RTL_MERGE_SORTED_ARRAYS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // This is useful to get back the resulting count, before allocating
    // the space.
    //
    if (VoidResult == NULL) {
        CopyCallback = RtlpDoNothingCopyArrayElement;
    }

    if ((Flags & RTL_MERGE_SORTED_ARRAYS_FLAG_COMPARE_IS_QSORT_BSEARCH_SIGNATURE) != 0) {
        CompareCallback = RtlpQsortBsearchCompareAdapter;
        CompareContext = (PVOID)CompareCallback;
    }

    for ( ; Count1 != 0 && Count2 != 0 ; ) {

        CONST int CompareResult = (*CompareCallback)(CompareContext, Array1, Array2, ElementSize);

        if (CompareResult < 0) {
            if (CopyCallback != NULL) {
                (*CopyCallback)(CopyContext, ResultArray, Array1, ElementSize);
            } else {
                RtlCopyMemory(ResultArray, Array1, ElementSize);
            }
            Array1 += ElementSize;
            Count1 -= 1;
        }
        else if (CompareResult > 0) {
            if (CopyCallback != NULL) {
                (*CopyCallback)(CopyContext, ResultArray, Array2, ElementSize);
            } else {
                RtlCopyMemory(ResultArray, Array2, ElementSize);
            }
            Array2 += ElementSize;
            Count2 -= 1;
        }
        else /* CompareResult == 0 */ {
            //
            // move past the elements in both arrays, chosing arbitrarily
            // which one to take (Array1)
            //
            if (CopyCallback != NULL) {
                (*CopyCallback)(CopyContext, ResultArray, Array1, ElementSize);
            } else {
                RtlCopyMemory(ResultArray, Array1, ElementSize);
            }
            Array1 += ElementSize;
            Array2 += ElementSize;
            Count1 -= 1;
            Count2 -= 1;
        }
        ResultCount += 1;
        ResultArray += ElementSize;
    }
    //
    // now pick up the tail of whichever one has any left, if either
    //
    if (VoidResult == NULL) {
        ResultCount += Count1 + Count2;
    } else if (Count1 != 0) {
        ResultCount += Count1;
        if (CopyCallback != NULL) {
            while (Count1 != 0) {
                //
                // perhaps CopyCallback should be copy_n instead of copy_1,
                // so we might gain an efficiency over the loop with an uninlinable
                // calback..
                //
                (*CopyCallback)(CopyContext, ResultArray, Array1, ElementSize);

                Count1 -= 1;
                ResultArray += ElementSize;
                Array1 += ElementSize;
            }
        } else {
            RtlCopyMemory(ResultArray, Array1, Count1 * ElementSize);
            ResultArray += Count1 * ElementSize;
        }
    } else if (Count2 != 0) {
        ResultCount += Count2;
        if (CopyCallback != NULL) {
            while (Count2 != 0) {
                //
                // perhaps CopyCallback should be copy_n instead of copy_1
                //
                (*CopyCallback)(CopyContext, ResultArray, Array2, ElementSize);

                Count2 -= 1;
                ResultArray += ElementSize;
                Array2 += ElementSize;
            }
        } else {
            RtlCopyMemory(ResultArray, Array2, Count2 * ElementSize);
            //optimize away ResultArray += Count2 * ElementSize;
        }
    }
    *OutResultCount = ResultCount;
    Status = STATUS_SUCCESS;
Exit:
    return ResultCount;
}

#if 0 // test cases

int __cdecl CompareULONG(PCVOID v1, PCVOID v2)
{
    ULONG i1 = *(ULONG*)v1;
    ULONG i2 = *(ULONG*)v2;
    if (i1 > i2)
        return 1;
    if (i1 < i2)
        return -1;
    return 0;
}

void RtlpTestUnique(const char * s)
{
	ULONG rg[64];
	ULONG i;
	ULONG len = strlen(s);
	for (i = 0 ; i != len ; ++i) rg[i] = s[i];
	len = RtlRemoveAdjacentEquivalentArrayElements(1, rg, len, sizeof(rg[0]), (PVOID)CompareULONG, NULL, NULL, NULL);
	printf("---");
	for (i = 0 ; i != len ; ++i) printf("%lu ", rg[i]);
	printf("---\n");
}

void RtlpTestMerge(const char * s, const char * t)
{
	ULONG rg1[64];
	ULONG rg2[64];
    ULONG rg[128];
	ULONG i;
	ULONG slen = strlen(s);
	ULONG tlen = strlen(t);
    ULONG len;

    printf("merge(");
	for (i = 0 ; i != slen ; ++i) rg1[i] = s[i];
	for (i = 0 ; i != slen ; ++i) printf("%lu ", rg1[i]);

	printf(",");
	for (i = 0 ; i != tlen ; ++i) rg2[i] = t[i];
	for (i = 0 ; i != tlen ; ++i) printf("%lu ", rg2[i]);

	len = RtlMergeSortedArrays(1, rg1, slen, rg2, tlen, rg, sizeof(rg[0]), (PVOID)CompareULONG, NULL, NULL, NULL);
	printf(")=(---");
	for (i = 0 ; i != len ; ++i) printf("%lu ", rg[i]);
	printf(")\n");
}

int __cdecl main()
{
	RtlpTestUnique("");
	RtlpTestUnique("\1");
	RtlpTestUnique("\1\2");
	RtlpTestUnique("\1\2\3");
	RtlpTestUnique("\1\1\2\3");
	RtlpTestUnique("\1\2\2\3");
	RtlpTestUnique("\1\2\3\3");

	RtlpTestUnique("\1\1\1\2\2\2\2\2\3");
	RtlpTestUnique("\1\1\1\2\3\3\3\3\3\3\3\3");
	RtlpTestUnique("\1\2\2\2\2\2\2\3\3\3\3\3\3\3\3");

	RtlpTestUnique("\1\1\1\1\1\2\2\2\2\2\3\3\3\3\3\3");

	RtlpTestUnique("\1\1\1\1\1\2\2\2\2\2\3\3\3\3\3\3\1");

    RtlpTestMerge("\1\2\3", "\4\5\6");
    RtlpTestMerge("\1\3\5", "\2\4\6");
    RtlpTestMerge("\1\2\3", "\2\4\6");

    RtlpTestMerge("\1\1\1\2\3", "\2\4\6\6\6");

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\tbitmap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tbitmap.c

Abstract:

    Test program for the Bitmap Procedures

Author:

    Gary Kimura     [GaryKi]    30-Jan-1989

Revision History:

--*/

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"

ULONG Buffer[512];
RTL_BITMAP BitMapHeader;
PRTL_BITMAP BitMap;

int
main(
    int argc,
    char *argv[]
    )
{
    ULONG j;

    DbgPrint("Start BitMapTest()\n");

    //
    //  First create a new bitmap
    //

    BitMap = &BitMapHeader;
    RtlInitializeBitMap( BitMap, Buffer, 2048*8 );

    //
    //  >>>> Test setting bits
    //

    //
    //  Now clear all bits
    //

    RtlClearAllBits( BitMap );
    if (RtlNumberOfClearBits( BitMap ) != 2048*8) { DbgPrint("Number of Clear bits error 1\n" ); }
    if (RtlNumberOfSetBits( BitMap ) != 0)        { DbgPrint("Number of Set bits error 1\n" ); }

    //
    //  Now set some bit patterns, and test them
    //

    RtlSetBits( BitMap,   0,  1 );
    RtlSetBits( BitMap,  63,  1 );
    RtlSetBits( BitMap,  65, 30 );
    RtlSetBits( BitMap, 127,  2 );
    RtlSetBits( BitMap, 191, 34 );

    if ((BitMap->Buffer[0] != 0x00000001) ||
        (BitMap->Buffer[1] != 0x80000000) ||
        (BitMap->Buffer[2] != 0x7ffffffe) ||
        (BitMap->Buffer[3] != 0x80000000) ||
        (BitMap->Buffer[4] != 0x00000001) ||
        (BitMap->Buffer[5] != 0x80000000) ||
        (BitMap->Buffer[6] != 0xffffffff) ||
        (BitMap->Buffer[7] != 0x00000001)) {

        DbgPrint("RtlSetBits Error\n");
        return FALSE;
    }

    if (RtlNumberOfClearBits( BitMap ) != 2048*8 - 68) { DbgPrint("Number of Clear bits error 2\n" ); }
    if (RtlNumberOfSetBits( BitMap ) != 68)        { DbgPrint("Number of Set bits error 2\n" ); }

    //
    //  Now test some RtlFindClearBitsAndSet
    //

    RtlSetAllBits( BitMap );

    RtlClearBits( BitMap, 0 +  10*32,  1 );
    RtlClearBits( BitMap, 5 +  11*32,  1 );
    RtlClearBits( BitMap, 7 +  12*32,  1 );

    RtlClearBits( BitMap, 0 +  13*32,  9 );
    RtlClearBits( BitMap, 4 +  14*32,  9 );
    RtlClearBits( BitMap, 7 +  15*32,  9 );

    RtlClearBits( BitMap, 0 +  16*32, 10 );
    RtlClearBits( BitMap, 4 +  17*32, 10 );
    RtlClearBits( BitMap, 6 +  18*32, 10 );
    RtlClearBits( BitMap, 7 +  19*32, 10 );

    RtlClearBits( BitMap, 0 + 110*32, 14 );
    RtlClearBits( BitMap, 1 + 111*32, 14 );
    RtlClearBits( BitMap, 2 + 112*32, 14 );

    RtlClearBits( BitMap, 0 + 113*32, 15 );
    RtlClearBits( BitMap, 1 + 114*32, 15 );
    RtlClearBits( BitMap, 2 + 115*32, 15 );

    //DbgPrint("ClearBits = %08lx, ", RtlNumberOfClearBits( BitMap ));
    //DbgPrint("SetBits   = %08lx\n", RtlNumberOfSetBits( BitMap ));

//    {
//        ULONG i;
//        for (i = 0; i < 16; i++) {
//            DbgPrint("%2d: ", i);
//            DbgPrint("%08lx\n", BitMap->Buffer[i]);
//        }
//    }

    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 0 + 113*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 113*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 1 + 114*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    1 + 114*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 2 + 115*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    2 + 115*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 0 + 110*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 110*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 1 + 111*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    1 + 111*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 2 + 112*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    2 + 112*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 0 + 16*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 16*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 4 + 17*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    4 + 17*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 6 + 18*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    6 + 18*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 7 + 19*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 19*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 0 + 13*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 13*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 4 + 14*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    4 + 14*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 7 + 15*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 15*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 0 + 10*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 10*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 5 + 11*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    5 + 11*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 7 + 12*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 12*32\n");
        return FALSE;
    }

    if (RtlNumberOfClearBits( BitMap ) != 0) { DbgPrint("Number of Clear bits error 3\n" ); }
    if (RtlNumberOfSetBits( BitMap ) != 2048*8)        { DbgPrint("Number of Set bits error 3\n" ); }

    //
    //  Now test some RtlFindClearBitsAndSet
    //

    RtlSetAllBits( BitMap );

    RtlClearBits( BitMap, 0 +  0*32,  1 );
    RtlClearBits( BitMap, 5 +  1*32,  1 );
    RtlClearBits( BitMap, 7 +  2*32,  1 );

    RtlClearBits( BitMap, 0 +  3*32,  9 );
    RtlClearBits( BitMap, 4 +  4*32,  9 );
    RtlClearBits( BitMap, 7 +  5*32,  9 );

    RtlClearBits( BitMap, 0 +  6*32, 10 );
    RtlClearBits( BitMap, 4 +  7*32, 10 );
    RtlClearBits( BitMap, 6 +  8*32, 10 );
    RtlClearBits( BitMap, 7 +  9*32, 10 );

    RtlClearBits( BitMap, 0 + 10*32, 14 );
    RtlClearBits( BitMap, 1 + 11*32, 14 );
    RtlClearBits( BitMap, 2 + 12*32, 14 );

    RtlClearBits( BitMap, 0 + 13*32, 15 );
    RtlClearBits( BitMap, 1 + 14*32, 15 );
    RtlClearBits( BitMap, 2 + 15*32, 15 );

    //DbgPrint("ClearBits = %08lx, ", RtlNumberOfClearBits( BitMap ));
    //DbgPrint("SetBits   = %08lx\n", RtlNumberOfSetBits( BitMap ));

//    {
//        ULONG i;
//        for (i = 0; i < 16; i++) {
//            DbgPrint("%2d: ", i);
//            DbgPrint("%08lx\n", BitMap->Buffer[i]);
//        }
//    }

    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 0 + 13*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 13*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 1 + 14*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    1 + 14*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 15, 0) != 2 + 15*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    2 + 15*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 0 + 10*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 10*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 1 + 11*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    1 + 11*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 14, 0) != 2 + 12*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    2 + 12*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 0 + 6*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 6*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 4 + 7*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    4 + 7*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 6 + 8*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    6 + 8*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap, 10, 0) != 7 + 9*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 9*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 0 + 3*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 3*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 4 + 4*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    4 + 4*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  9, 0) != 7 + 5*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 5*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 0 + 0*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    0 + 0*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 5 + 1*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    5 + 1*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet(BitMap,  1, 0) != 7 + 2*32) {
        DbgPrint("RtlFindClearBitsAndSet Error    7 + 2*32\n");
        return FALSE;
    }

    if (RtlNumberOfClearBits( BitMap ) != 0) { DbgPrint("Number of Clear bits error 4\n" ); }
    if (RtlNumberOfSetBits( BitMap ) != 2048*8)        { DbgPrint("Number of Set bits error 4\n" ); }

    //
    //  Test RtlAreBitsClear and AreBitsSet
    //

    DbgPrint("Start bit query tests\n");

    RtlClearAllBits( BitMap );
    if (!RtlAreBitsClear( BitMap, 0, 2048*8 )) { DbgPrint("RtlAreBitsClear  Error 0\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 8, 8 )) { DbgPrint("AreBitsClear Error 1\n"); }
    RtlClearBits( BitMap, 9, 6 );
    if (RtlAreBitsClear( BitMap, 8, 8 )) { DbgPrint("AreBitsClear Error 2\n"); }
    RtlClearBits( BitMap, 8, 1 );
    if (RtlAreBitsClear( BitMap, 8, 8 )) { DbgPrint("AreBitsClear Error 3\n"); }
    RtlClearBits( BitMap, 15, 1 );
    if (!RtlAreBitsClear( BitMap, 8, 8 )) { DbgPrint("AreBitsClear Error 4\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 8, 7 )) { DbgPrint("AreBitsClear Error 5\n"); }
    RtlClearBits( BitMap, 9, 5 );
    if (RtlAreBitsClear( BitMap, 8, 7 )) { DbgPrint("AreBitsClear Error 6\n"); }
    RtlClearBits( BitMap, 8, 1 );
    if (RtlAreBitsClear( BitMap, 8, 7 )) { DbgPrint("AreBitsClear Error 7\n"); }
    RtlClearBits( BitMap, 14, 1 );
    if (!RtlAreBitsClear( BitMap, 8, 7 )) { DbgPrint("AreBitsClear Error 8\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 9, 7 )) { DbgPrint("AreBitsClear Error 9\n"); }
    RtlClearBits( BitMap, 10, 5 );
    if (RtlAreBitsClear( BitMap, 9, 7 )) { DbgPrint("AreBitsClear Error 10\n"); }
    RtlClearBits( BitMap, 9, 1 );
    if (RtlAreBitsClear( BitMap, 9, 7 )) { DbgPrint("AreBitsClear Error 11\n"); }
    RtlClearBits( BitMap, 15, 1 );
    if (!RtlAreBitsClear( BitMap, 9, 7 )) { DbgPrint("AreBitsClear Error 12\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 9, 5 )) { DbgPrint("AreBitsClear Error 13\n"); }
    RtlClearBits( BitMap, 10, 3 );
    if (RtlAreBitsClear( BitMap, 9, 5 )) { DbgPrint("AreBitsClear Error 14\n"); }
    RtlClearBits( BitMap, 9, 1 );
    if (RtlAreBitsClear( BitMap, 9, 5 )) { DbgPrint("AreBitsClear Error 15\n"); }
    RtlClearBits( BitMap, 13, 1 );
    if (!RtlAreBitsClear( BitMap, 9, 5 )) { DbgPrint("AreBitsClear Error 16\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 8, 24 )) { DbgPrint("AreBitsClear Error 17\n"); }
    RtlClearBits( BitMap, 9, 22 );
    if (RtlAreBitsClear( BitMap, 8, 24 )) { DbgPrint("AreBitsClear Error 18\n"); }
    RtlClearBits( BitMap, 8, 1 );
    if (RtlAreBitsClear( BitMap, 8, 24 )) { DbgPrint("AreBitsClear Error 19\n"); }
    RtlClearBits( BitMap, 31, 1 );
    if (!RtlAreBitsClear( BitMap, 8, 24 )) { DbgPrint("AreBitsClear Error 20\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 8, 23 )) { DbgPrint("AreBitsClear Error 21\n"); }
    RtlClearBits( BitMap, 9, 21 );
    if (RtlAreBitsClear( BitMap, 8, 23 )) { DbgPrint("AreBitsClear Error 22\n"); }
    RtlClearBits( BitMap, 8, 1 );
    if (RtlAreBitsClear( BitMap, 8, 23 )) { DbgPrint("AreBitsClear Error 23\n"); }
    RtlClearBits( BitMap, 30, 1 );
    if (!RtlAreBitsClear( BitMap, 8, 23 )) { DbgPrint("AreBitsClear Error 24\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 9, 23 )) { DbgPrint("AreBitsClear Error 25\n"); }
    RtlClearBits( BitMap, 10, 21 );
    if (RtlAreBitsClear( BitMap, 9, 23 )) { DbgPrint("AreBitsClear Error 26\n"); }
    RtlClearBits( BitMap, 9, 1 );
    if (RtlAreBitsClear( BitMap, 9, 23 )) { DbgPrint("AreBitsClear Error 27\n"); }
    RtlClearBits( BitMap, 31, 1 );
    if (!RtlAreBitsClear( BitMap, 9, 23 )) { DbgPrint("AreBitsClear Error 28\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 9, 21 )) { DbgPrint("AreBitsClear Error 29\n"); }
    RtlClearBits( BitMap, 10, 19 );
    if (RtlAreBitsClear( BitMap, 9, 21 )) { DbgPrint("AreBitsClear Error 30\n"); }
    RtlClearBits( BitMap, 9, 1 );
    if (RtlAreBitsClear( BitMap, 9, 21 )) { DbgPrint("AreBitsClear Error 31\n"); }
    RtlClearBits( BitMap, 29, 1 );
    if (!RtlAreBitsClear( BitMap, 9, 21 )) { DbgPrint("AreBitsClear Error 32\n"); }

    RtlSetAllBits( BitMap );
    if (RtlAreBitsClear( BitMap, 10, 1 )) { DbgPrint("AreBitsClear Error 33\n"); }
    RtlClearBits( BitMap, 9, 1 );
    if (RtlAreBitsClear( BitMap, 10, 1 )) { DbgPrint("AreBitsClear Error 34\n"); }
    RtlClearBits( BitMap, 11, 1 );
    if (RtlAreBitsClear( BitMap, 10, 1 )) { DbgPrint("AreBitsClear Error 35\n"); }
    RtlClearBits( BitMap, 10, 1 );
    if (!RtlAreBitsClear( BitMap, 10, 1 )) { DbgPrint("AreBitsClear Error 36\n"); }


    RtlSetAllBits( BitMap );
    if (!RtlAreBitsSet( BitMap, 0, 2048*8 )) { DbgPrint("RtlAreBitsSet  Error 0\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 8, 8 )) { DbgPrint("AreBitsSet Error 1\n"); }
    RtlSetBits( BitMap, 9, 6 );
    if (RtlAreBitsSet( BitMap, 8, 8 )) { DbgPrint("AreBitsSet Error 2\n"); }
    RtlSetBits( BitMap, 8, 1 );
    if (RtlAreBitsSet( BitMap, 8, 8 )) { DbgPrint("AreBitsSet Error 3\n"); }
    RtlSetBits( BitMap, 15, 1 );
    if (!RtlAreBitsSet( BitMap, 8, 8 )) { DbgPrint("AreBitsSet Error 4\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 8, 7 )) { DbgPrint("AreBitsSet Error 5\n"); }
    RtlSetBits( BitMap, 9, 5 );
    if (RtlAreBitsSet( BitMap, 8, 7 )) { DbgPrint("AreBitsSet Error 6\n"); }
    RtlSetBits( BitMap, 8, 1 );
    if (RtlAreBitsSet( BitMap, 8, 7 )) { DbgPrint("AreBitsSet Error 7\n"); }
    RtlSetBits( BitMap, 14, 1 );
    if (!RtlAreBitsSet( BitMap, 8, 7 )) { DbgPrint("AreBitsSet Error 8\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 9, 7 )) { DbgPrint("AreBitsSet Error 9\n"); }
    RtlSetBits( BitMap, 10, 5 );
    if (RtlAreBitsSet( BitMap, 9, 7 )) { DbgPrint("AreBitsSet Error 10\n"); }
    RtlSetBits( BitMap, 9, 1 );
    if (RtlAreBitsSet( BitMap, 9, 7 )) { DbgPrint("AreBitsSet Error 11\n"); }
    RtlSetBits( BitMap, 15, 1 );
    if (!RtlAreBitsSet( BitMap, 9, 7 )) { DbgPrint("AreBitsSet Error 12\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 9, 5 )) { DbgPrint("AreBitsSet Error 13\n"); }
    RtlSetBits( BitMap, 10, 3 );
    if (RtlAreBitsSet( BitMap, 9, 5 )) { DbgPrint("AreBitsSet Error 14\n"); }
    RtlSetBits( BitMap, 9, 1 );
    if (RtlAreBitsSet( BitMap, 9, 5 )) { DbgPrint("AreBitsSet Error 15\n"); }
    RtlSetBits( BitMap, 13, 1 );
    if (!RtlAreBitsSet( BitMap, 9, 5 )) { DbgPrint("AreBitsSet Error 16\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 8, 24 )) { DbgPrint("AreBitsSet Error 17\n"); }
    RtlSetBits( BitMap, 9, 22 );
    if (RtlAreBitsSet( BitMap, 8, 24 )) { DbgPrint("AreBitsSet Error 18\n"); }
    RtlSetBits( BitMap, 8, 1 );
    if (RtlAreBitsSet( BitMap, 8, 24 )) { DbgPrint("AreBitsSet Error 19\n"); }
    RtlSetBits( BitMap, 31, 1 );
    if (!RtlAreBitsSet( BitMap, 8, 24 )) { DbgPrint("AreBitsSet Error 20\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 8, 23 )) { DbgPrint("AreBitsSet Error 21\n"); }
    RtlSetBits( BitMap, 9, 21 );
    if (RtlAreBitsSet( BitMap, 8, 23 )) { DbgPrint("AreBitsSet Error 22\n"); }
    RtlSetBits( BitMap, 8, 1 );
    if (RtlAreBitsSet( BitMap, 8, 23 )) { DbgPrint("AreBitsSet Error 23\n"); }
    RtlSetBits( BitMap, 30, 1 );
    if (!RtlAreBitsSet( BitMap, 8, 23 )) { DbgPrint("AreBitsSet Error 24\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 9, 23 )) { DbgPrint("AreBitsSet Error 25\n"); }
    RtlSetBits( BitMap, 10, 21 );
    if (RtlAreBitsSet( BitMap, 9, 23 )) { DbgPrint("AreBitsSet Error 26\n"); }
    RtlSetBits( BitMap, 9, 1 );
    if (RtlAreBitsSet( BitMap, 9, 23 )) { DbgPrint("AreBitsSet Error 27\n"); }
    RtlSetBits( BitMap, 31, 1 );
    if (!RtlAreBitsSet( BitMap, 9, 23 )) { DbgPrint("AreBitsSet Error 28\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 9, 21 )) { DbgPrint("AreBitsSet Error 29\n"); }
    RtlSetBits( BitMap, 10, 19 );
    if (RtlAreBitsSet( BitMap, 9, 21 )) { DbgPrint("AreBitsSet Error 30\n"); }
    RtlSetBits( BitMap, 9, 1 );
    if (RtlAreBitsSet( BitMap, 9, 21 )) { DbgPrint("AreBitsSet Error 31\n"); }
    RtlSetBits( BitMap, 29, 1 );
    if (!RtlAreBitsSet( BitMap, 9, 21 )) { DbgPrint("AreBitsSet Error 32\n"); }

    RtlClearAllBits( BitMap );
    if (RtlAreBitsSet( BitMap, 10, 1 )) { DbgPrint("AreBitsSet Error 33\n"); }
    RtlSetBits( BitMap, 9, 1 );
    if (RtlAreBitsSet( BitMap, 10, 1 )) { DbgPrint("AreBitsSet Error 34\n"); }
    RtlSetBits( BitMap, 11, 1 );
    if (RtlAreBitsSet( BitMap, 10, 1 )) { DbgPrint("AreBitsSet Error 35\n"); }
    RtlSetBits( BitMap, 10, 1 );
    if (!RtlAreBitsSet( BitMap, 10, 1 )) { DbgPrint("AreBitsSet Error 36\n"); }

    DbgPrint("End BitMapTest()\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\tacl.c ===
//////////////////////////////////////////////////////////////////////////
// WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING  //
//                                                                      //
// This test file is not current with the security implementation.      //
// This file contains references to data types and APIs that do not     //
// exist.                                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tacl.c

Abstract:

    Test program for the acl editing package

Author:

    Gary Kimura     [GaryKi]    19-Nov-1989

Revision History:

    v4: robertre
        updated ACL_REVISION
    RichardW  - updated ACE_HEADER

--*/

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"

VOID
RtlDumpAcl(
    IN PACL Acl
    );

UCHAR FredAclBuffer[128];
UCHAR WilmaAclBuffer[128];
UCHAR PebbleAclBuffer[128];
UCHAR DinoAclBuffer[128];
UCHAR BarneyAclBuffer[128];
UCHAR BettyAclBuffer[128];
UCHAR BambamAclBuffer[128];

UCHAR GuidMaskBuffer[512];
STANDARD_ACE AceListBuffer[2];

int
main(
    int argc,
    char *argv[]
    )
{
    PACL FredAcl = (PACL)FredAclBuffer;
    PACL WilmaAcl = (PACL)WilmaAclBuffer;
    PACL PebbleAcl = (PACL)PebbleAclBuffer;
    PACL DinoAcl = (PACL)DinoAclBuffer;
    PACL BarneyAcl = (PACL)BarneyAclBuffer;
    PACL BettyAcl = (PACL)BettyAclBuffer;
    PACL BambamAcl = (PACL)BambamAclBuffer;

    PMASK_GUID_PAIRS GuidMasks = (PMASK_GUID_PAIRS)GuidMaskBuffer;

    ACL_REVISION_INFORMATION AclRevisionInfo;
    ACL_SIZE_INFORMATION AclSizeInfo;

    //
    //  We're starting the test
    //

    DbgPrint("Start Acl Test\n");

    //
    //  test create acl
    //

    if (!NT_SUCCESS(RtlCreateAcl(FredAcl, 128, 1))) {
        DbgPrint("RtlCreateAcl Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  test add ace to add two aces to an empty acl
    //

    AceListBuffer[0].Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AceListBuffer[0].Header.AceSize = sizeof(STANDARD_ACE);
    AceListBuffer[0].Header.AceFlags = 0;
    AceListBuffer[0].Mask = 0x22222222;
    CopyGuid(&AceListBuffer[0].Guid, &FredGuid);

    AceListBuffer[1].Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AceListBuffer[1].Header.AceSize = sizeof(STANDARD_ACE);
    AceListBuffer[1].Header.AceFlags = 0;
    AceListBuffer[1].Mask = 0x44444444;
    CopyGuid(&AceListBuffer[1].Guid, &WilmaGuid);

    if (!NT_SUCCESS(RtlAddAce(FredAcl, 1, 0, AceListBuffer, 2*sizeof(STANDARD_ACE)))) {
        DbgPrint("RtlAddAce Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  test add ace to add one to the beginning of an acl
    //

    AceListBuffer[0].Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AceListBuffer[0].Header.AceSize = sizeof(STANDARD_ACE);
    AceListBuffer[0].Header.AceFlags = 0;
    AceListBuffer[0].Mask = 0x11111111;
    CopyGuid(&AceListBuffer[0].Guid, &PebbleGuid);

    if (!NT_SUCCESS(RtlAddAce(FredAcl, 1, 0, AceListBuffer, sizeof(STANDARD_ACE)))) {
        DbgPrint("RtlAddAce Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  test add ace to add one to the middle of an acl
    //

    AceListBuffer[0].Header.AceType = ACCESS_DENIED_ACE_TYPE;
    AceListBuffer[0].Header.AceSize = sizeof(STANDARD_ACE);
    AceListBuffer[0].Header.AceFlags = 0;
    AceListBuffer[0].Mask = 0x33333333;
    CopyGuid(&AceListBuffer[0].Guid, &DinoGuid);

    if (!NT_SUCCESS(RtlAddAce(FredAcl, 1, 2, AceListBuffer, sizeof(STANDARD_ACE)))) {
        DbgPrint("RtlAddAce Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  test add ace to add one to the end of an acl
    //

    AceListBuffer[0].Header.AceType = ACCESS_DENIED_ACE_TYPE;
    AceListBuffer[0].Header.AceSize = sizeof(STANDARD_ACE);
    AceListBuffer[0].Header.AceFlags = 0;
    AceListBuffer[0].Mask = 0x55555555;
    CopyGuid(&AceListBuffer[0].Guid, &FlintstoneGuid);

    if (!NT_SUCCESS(RtlAddAce(FredAcl, 1, MAXULONG, AceListBuffer, sizeof(STANDARD_ACE)))) {
        DbgPrint("RtlAddAce Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  Test get ace
    //

    {
        PSTANDARD_ACE Ace;

        if (!NT_SUCCESS(RtlGetAce(FredAcl, 2, (PVOID *)(&Ace)))) {
            DbgPrint("RtlGetAce Error\n");
        }

        if ((Ace->Header.AceType != ACCESS_DENIED_ACE_TYPE) ||
            (Ace->Mask != 0x33333333)) {
            DbgPrint("Got bad ace from RtlGetAce\n");
        }
    }

    //
    //  test delete ace middle ace
    //

    if (!NT_SUCCESS(RtlDeleteAce(FredAcl, 2))) {
        DbgPrint("RtlDeleteAce Error\n");
    }

    RtlDumpAcl(FredAcl);
    DbgPrint("\n");

    //
    //  Test query information acl
    //

    if (!NT_SUCCESS(RtlQueryInformationAcl( FredAcl,
                                         (PVOID)&AclRevisionInfo,
                                         sizeof(ACL_REVISION_INFORMATION),
                                         AclRevisionInformation))) {
        DbgPrint("RtlQueryInformationAcl Error\n");
    }
    if (AclRevisionInfo.AclRevision != ACL_REVISION) {
        DbgPrint("RtlAclRevision Error\n");
    }

    if (!NT_SUCCESS(RtlQueryInformationAcl( FredAcl,
                                         (PVOID)&AclSizeInfo,
                                         sizeof(ACL_SIZE_INFORMATION),
                                         AclSizeInformation))) {
        DbgPrint("RtlQueryInformationAcl Error\n");
    }
    if ((AclSizeInfo.AceCount != 4) ||
        (AclSizeInfo.AclBytesInUse != (sizeof(ACL)+4*sizeof(STANDARD_ACE))) ||
        (AclSizeInfo.AclBytesFree != 128 - AclSizeInfo.AclBytesInUse)) {
        DbgPrint("RtlAclSize Error\n");
        DbgPrint("AclSizeInfo.AceCount = %8lx\n", AclSizeInfo.AceCount);
        DbgPrint("AclSizeInfo.AclBytesInUse = %8lx\n", AclSizeInfo.AclBytesInUse);
        DbgPrint("AclSizeInfo.AclBytesFree = %8lx\n", AclSizeInfo.AclBytesFree);
        DbgPrint("\n");
    }

    //
    //  Test make Mask from Acl
    //

    GuidMasks->PairCount = 11;
    CopyGuid(&GuidMasks->MaskGuid[ 0].Guid, &FredGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 1].Guid, &WilmaGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 2].Guid, &PebbleGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 3].Guid, &DinoGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 4].Guid, &BarneyGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 5].Guid, &BettyGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 6].Guid, &BambamGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 7].Guid, &FlintstoneGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 8].Guid, &RubbleGuid);
    CopyGuid(&GuidMasks->MaskGuid[ 9].Guid, &AdultGuid);
    CopyGuid(&GuidMasks->MaskGuid[10].Guid, &ChildGuid);
    if (!NT_SUCCESS(RtlMakeMaskFromAcl(FredAcl, GuidMasks))) {
        DbgPrint("RtlMakeMaskFromAcl Error\n");
    }
    if ((GuidMasks->MaskGuid[ 0].Mask != 0x22222222) ||
        (GuidMasks->MaskGuid[ 1].Mask != 0x44444444) ||
        (GuidMasks->MaskGuid[ 2].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 3].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 4].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 5].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 6].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 7].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 8].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[ 9].Mask != 0x00000000) ||
        (GuidMasks->MaskGuid[10].Mask != 0x00000000)) {
        DbgPrint("Make Mask Error\n");
        DbgPrint("Fred gets       %8lx\n", GuidMasks->MaskGuid[ 0].Mask);
        DbgPrint("Wilma gets      %8lx\n", GuidMasks->MaskGuid[ 1].Mask);
        DbgPrint("Pebble gets     %8lx\n", GuidMasks->MaskGuid[ 2].Mask);
        DbgPrint("Dino gets       %8lx\n", GuidMasks->MaskGuid[ 3].Mask);
        DbgPrint("Barney gets     %8lx\n", GuidMasks->MaskGuid[ 4].Mask);
        DbgPrint("Betty gets      %8lx\n", GuidMasks->MaskGuid[ 5].Mask);
        DbgPrint("Banbam gets     %8lx\n", GuidMasks->MaskGuid[ 6].Mask);
        DbgPrint("Flintstone gets %8lx\n", GuidMasks->MaskGuid[ 7].Mask);
        DbgPrint("Rubble gets     %8lx\n", GuidMasks->MaskGuid[ 8].Mask);
        DbgPrint("Adult gets      %8lx\n", GuidMasks->MaskGuid[ 9].Mask);
        DbgPrint("Child gets      %8lx\n", GuidMasks->MaskGuid[10].Mask);
    }

    //
    //  test make acl from mask
    //

    GuidMasks->PairCount = 2;
    GuidMasks->MaskGuid[0].Mask = 0x55555555;
    CopyGuid(&GuidMasks->MaskGuid[0].Guid, &BarneyGuid);
    GuidMasks->MaskGuid[1].Mask = 0xaaaa5555;
    CopyGuid(&GuidMasks->MaskGuid[1].Guid, &RubbleGuid);

    //
    //  Initialize and dump a posix style acl
    //

    if (!NT_SUCCESS(RtlMakeAclFromMask(GuidMasks, AclPosixEnvironment, BarneyAcl, 128, 1))) {
        DbgPrint("RtlMakeAclFromMask Error\n");
    }

    RtlDumpAcl(BarneyAcl);
    DbgPrint("\n");

    //
    //  Initialize and dump a OS/2 style acl
    //

    if (!NT_SUCCESS(RtlMakeAclFromMask(GuidMasks, AclOs2Environment, BettyAcl, 128, 1))) {
        DbgPrint("RtlMakeAclFromMask Error\n");
    }

    RtlDumpAcl(BettyAcl);
    DbgPrint("\n");

    //
    //  We're done with the test
    //

    DbgPrint("End Acl Test\n");

    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\toverflow.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    toverflow.c

Abstract:

    Test program for overflow functions

Author:

    Jay Krell (Jaykrell)

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

const unsigned __int32 numbers[]=
{
    0, 0,
    1, 1,
    0x7fff, 0x7fff,
    0x7fff, 0x8000,
    0x8000, 0x8000,
    0x7fffffff, 0x7fffffff,
    0x80000000, 0x7fffffff,
    0x80000000, 0x80000000,
    0x80000000, 0xffffffff,
    0x7fffffff, 0xffffffff,
    0xffffffff, 0xffffffff,

    0x80000001, 0xffffffff,
    0x80000001, 0x7fffffff,
};

void
F(
    __int32 *p
 );

void
TestOverflow(
             )
{
    SIZE_T i = 0;
    unsigned __int32 ua32 = 0;
    unsigned __int32 ub32 = 0;
    unsigned __int32 uc32 = 0;
    unsigned __int64 ua64 = 0;
    unsigned __int64 ub64 = 0;
    unsigned __int64 uc64 = 0;
    __int32 a32 = 0;
    __int32 b32 = 0;
    __int32 c32 = 0;
    __int64 a64 = 0;
    __int64 b64 = 0;
    __int64 c64 = 0;
    BOOLEAN carry = 0;
    BOOLEAN overflow = 0;

    for (i = 0 ; i != RTL_NUMBER_OF(numbers) ; i += 2)
    {
        ua32 = numbers[i];
        ub32 = numbers[i+1];
        ua64 = ua32;
        ub64 = ub32;
        carry = RtlUnsignedAddWithCarryOut32(&uc32, ua32, ub32);
        printf("unsigned add32: 0x%I64x + 0x%I64x => carry=%d\n", ua64, ub64, (int)carry);

        a32 = (__int32)ua32;
        b32 = (__int32)ub32;
        a64 = a32;
        b64 = b32;
        overflow = RtlSignedAddWithOverflowOut32(&c32, a32, b32);
        printf("signed add32: %I64d + %I64d => overflow=%d\n", a64, b64, (int)overflow);
    }
}

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    TestOverflow();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\tprefix.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tprefix.c

Abstract:

    Test program for the Prefix table package

Author:

    Gary Kimura     [GaryKi]    03-Aug-1989

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#include "nt.h"
#include "ntrtl.h"

//
//  Routines and types for generating random prefixes
//

ULONG RtlRandom ( IN OUT PULONG Seed );
ULONG Seed;

PSZ AnotherPrefix(IN ULONG MaxNameLength);
ULONG AlphabetLength;

//PSZ Alphabet = "AlphaBravoCharlieDeltaEchoFoxtrotGolfHotelIndiaJuliettKiloLimaMikeNovemberOscarPapaQuebecRomeoSierraTangoUniformVictorWhiskeyXrayYankeeZulu";

PSZ Alphabet = "\
Aa\
BBbb\
CCCccc\
DDDDdddd\
EEEEEeeeee\
FFFFFFffffff\
GGGGGGGggggggg\
HHHHHHHHhhhhhhhh\
IIIIIIIIIiiiiiiiii\
JJJJJJJJJJjjjjjjjjjj\
KKKKKKKKKKKkkkkkkkkkkk\
LLLLLLLLLLLLllllllllllll\
MMMMMMMMMMMMMmmmmmmmmmmmmm\
NNNNNNNNNNNNNNnnnnnnnnnnnnnn\
OOOOOOOOOOOOOOOooooooooooooooo\
PPPPPPPPPPPPPPPPpppppppppppppppp\
QQQQQQQQQQQQQQQQQqqqqqqqqqqqqqqqqq\
RRRRRRRRRRRRRRRRRRrrrrrrrrrrrrrrrrrr\
SSSSSSSSSSSSSSSSSSSsssssssssssssssssss\
TTTTTTTTTTTTTTTTTTTTtttttttttttttttttttt\
UUUUUUUUUUUUUUUUUUUUUuuuuuuuuuuuuuuuuuuuuu\
VVVVVVVVVVVVVVVVVVVVVVvvvvvvvvvvvvvvvvvvvvvv\
WWWWWWWWWWWWWWWWWWWWWWWwwwwwwwwwwwwwwwwwwwwwww\
XXXXXXXXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxxxxxxxxxxx\
YYYYYYYYYYYYYYYYYYYYYYYYYyyyyyyyyyyyyyyyyyyyyyyyyy\
ZZZZZZZZZZZZZZZZZZZZZZZZZZzzzzzzzzzzzzzzzzzzzzzzzzzz";

#define BUFFER_LENGTH 8192

CHAR Buffer[BUFFER_LENGTH];
ULONG NextBufferChar = 0;

//
//  record structure and variables for the prefix table and it
//  elements
//

typedef struct _PREFIX_NODE {
    PREFIX_TABLE_ENTRY PfxEntry;
    STRING String;
} PREFIX_NODE;
typedef PREFIX_NODE *PPREFIX_NODE;

#define PREFIXES 512

PREFIX_NODE Prefixes[PREFIXES];

PREFIX_TABLE PrefixTable;

int
main(
    int argc,
    char *argv[]
    )
{
    ULONG i;
    PSZ Psz;

    PPREFIX_TABLE_ENTRY PfxEntry;
    PPREFIX_NODE PfxNode;

    STRING String;

    //
    //  We're starting the test
    //

    DbgPrint("Start Prefix Test\n");

    //
    //  Calculate the alphabet size for use by AnotherPrefix
    //

    AlphabetLength = strlen(Alphabet);

    //
    //  Initialize the prefix table
    //

    PfxInitialize(&PrefixTable);

    //
    //  Insert the root prefix
    //

    RtlInitString( &Prefixes[i].String, "\\" );
    if (PfxInsertPrefix( &PrefixTable,
                         &Prefixes[0].String,
                         &Prefixes[0].PfxEntry )) {
        DbgPrint("Insert root prefix\n");
    } else {
        DbgPrint("error inserting root prefix\n");
    }

    //
    //  Insert prefixes
    //

    Seed = 0;

    for (i = 1, Psz = AnotherPrefix(3);
         (i < PREFIXES) && (Psz != NULL);
         i += 1, Psz = AnotherPrefix(3)) {

        DbgPrint("[0x%x] = ", i);
        DbgPrint("\"%s\"", Psz);

        RtlInitString(&Prefixes[i].String, Psz);

        if (PfxInsertPrefix( &PrefixTable,
                             &Prefixes[i].String,
                             &Prefixes[i].PfxEntry )) {

            DbgPrint(" inserted in table\n");

        } else {

            DbgPrint(" already in table\n");

        }

    }

    //
    //  Enumerate the prefix table
    //

    DbgPrint("Enumerate Prefix Table the first time\n");

    for (PfxEntry = PfxNextPrefix(&PrefixTable, TRUE);
         PfxEntry != NULL;
         PfxEntry = PfxNextPrefix(&PrefixTable, FALSE)) {

        PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

        DbgPrint("%s\n", PfxNode->String.Buffer);

    }

    DbgPrint("Start Prefix search 0x%x\n", NextBufferChar);

    //
    //  Search for prefixes
    //

    for (Psz = AnotherPrefix(4); Psz != NULL; Psz = AnotherPrefix(4)) {

        DbgPrint("0x%x ", NextBufferChar);

        RtlInitString(&String, Psz);

        PfxEntry = PfxFindPrefix( &PrefixTable, &String, FALSE );

        if (PfxEntry == NULL) {

            PfxEntry = PfxFindPrefix( &PrefixTable, &String, TRUE );

            if (PfxEntry == NULL) {

                DbgPrint("Not found      \"%s\"\n", Psz);

                NOTHING;

            } else {

                PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

                DbgPrint("Case blind     \"%s\" is \"%s\"\n", Psz, PfxNode->String.Buffer);

                PfxRemovePrefix( &PrefixTable, PfxEntry );

            }

        } else {

            PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

            DbgPrint(    "Case sensitive \"%s\" is \"%s\"\n", Psz, PfxNode->String.Buffer);

            if (PfxNode != &Prefixes[0]) {

                PfxRemovePrefix( &PrefixTable, PfxEntry );

            }

        }

    }

    //
    //  Enumerate the prefix table
    //

    DbgPrint("Enumerate Prefix Table a second time\n");

    for (PfxEntry = PfxNextPrefix(&PrefixTable, TRUE);
         PfxEntry != NULL;
         PfxEntry = PfxNextPrefix(&PrefixTable, FALSE)) {

        PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

        DbgPrint("%s\n", PfxNode->String.Buffer);

    }

    //
    //  Now enumerate and zero out the table
    //

    for (PfxEntry = PfxNextPrefix(&PrefixTable, TRUE);
         PfxEntry != NULL;
         PfxEntry = PfxNextPrefix(&PrefixTable, FALSE)) {

        PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

        DbgPrint("Delete %s\n", PfxNode->String.Buffer);

        PfxRemovePrefix( &PrefixTable, PfxEntry );

    }

    //
    //  Enumerate again but this time the table should be empty
    //

    for (PfxEntry = PfxNextPrefix(&PrefixTable, TRUE);
         PfxEntry != NULL;
         PfxEntry = PfxNextPrefix(&PrefixTable, FALSE)) {

        PfxNode = CONTAINING_RECORD(PfxEntry, PREFIX_NODE, PfxEntry);

        DbgPrint("This Node should be gone \"%s\"\n", PfxNode->String.Buffer);

    }

    DbgPrint("End PrefixTest()\n");

    return TRUE;
}


PSZ
AnotherPrefix(IN ULONG MaxNameLength)
{
    ULONG AlphabetPosition;

    ULONG NameLength;
    ULONG IndividualNameLength;

    ULONG StartBufferPosition;
    ULONG i;
    ULONG j;

    //
    //  Check if there is enough room for another name
    //

    if (NextBufferChar > (BUFFER_LENGTH - (MaxNameLength * 4))) {
        return NULL;
    }

    //
    //  Where in the alphabet soup we start
    //

    AlphabetPosition = RtlRandom(&Seed) % AlphabetLength;

    //
    //  How many names we want in our prefix
    //

    NameLength = (RtlRandom(&Seed) % MaxNameLength) + 1;

    //
    //  Compute each name
    //

    StartBufferPosition = NextBufferChar;

    for (i = 0; i < NameLength; i += 1) {

        Buffer[NextBufferChar++] = '\\';

        IndividualNameLength = (RtlRandom(&Seed) % 3) + 1;

        for (j = 0; j < IndividualNameLength; j += 1) {

            Buffer[NextBufferChar++] = Alphabet[AlphabetPosition];
            AlphabetPosition = (AlphabetPosition + 1) % AlphabetLength;

        }

    }

    Buffer[NextBufferChar++] = '\0';

    return &Buffer[StartBufferPosition];

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\tnlsxlat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tnlsxlat.c

Abstract:

    Test program for the Nlsxlat Procedures

Author:

    Ian James     [IanJa]    03-Feb-1994

Revision History:

--*/

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"

#define NELEM(p) (sizeof(p) / sizeof(*(p)))

char OEMBuff[1000];
char ABuff[1000];
WCHAR UBuff[2000];

int
main(
    int argc,
    char *argv[]
    )
{
    ULONG j;
    ULONG cb;
    char *pch;

    printf("Start NlsXlatTest()\n");

    //
    //  First initialize the buffers
    //

    for (j = 0; j < sizeof(OEMBuff); j++) {
        OEMBuff[j] = (char)(j * 17);
        ABuff[j] = (char)(j * 19);
    }

    //
    //  TEST 1
    //  RtlMultiByteToUnicodeN, RtlUnicodeToMultiByteN
    //

    printf("Test 1: MultiByteToUnicodeN & RtlUnicodeToMultiByteN\n");

    // TEST 1.1
    //
    printf("  Test 1.1: A->U U->A\n");

    RtlMultiByteToUnicodeN(UBuff, sizeof(UBuff), &cb, ABuff, sizeof(ABuff));
    printf("    %d bytes converted to Unicode\n", cb);
    RtlUnicodeToMultiByteN(ABuff, sizeof(ABuff), &cb, UBuff, sizeof(UBuff));
    printf("    %d bytes converted back to ANSI\n", cb);

    for (j = 0; j < sizeof(ABuff); j++) {
        if (ABuff[j] != (char)(j * 19)) {
            printf("ABuff[%d] was 0x%02x, now 0x%02x\n",
                    j, (char)(j * 19), ABuff[j]);
            return FALSE;
        }
    }
    printf("    Test 1.1 OK\n");

    // TEST 1.2
    //
    printf("  Test 1.2: A->U U->A (source & dest buffers the same)\n");
    RtlCopyMemory(UBuff, ABuff, sizeof(ABuff));
    
    RtlMultiByteToUnicodeN(UBuff, sizeof(UBuff), &cb, UBuff, sizeof(ABuff));
    printf("    %d bytes converted to Unicode\n", cb);
    RtlUnicodeToMultiByteN(UBuff, sizeof(ABuff), &cb, UBuff, sizeof(UBuff));
    printf("    %d bytes converted back to ANSI\n", cb);

    pch = (LPSTR)UBuff;
    for (j = 0; j < sizeof(ABuff); j++) {
        if (pch[j] != ABuff[j]) {
            printf("    ABuff[%d] was 0x%02x, was turned into 0x%02x\n",
                    j, ABuff[j], pch[j]);
            printf("    Test 1.2 FAILED!\n");
            return FALSE;
        }
    }

    printf("    Test 1.2 OK!\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\recip.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recip.c

Abstract:

    This module generates reciprocol fractions for implementing integer
    division by multiplication.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    User mode.

Revision History:

--*/

#include <stdio.h>

typedef struct _large_integer {
    unsigned long LowPart;
    long HighPart;
    } large_integer;

//long Divisors[] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 0};
long Divisors[] = {10, 10000, 10000000, 86400000, 0};

void
main (argc, argv)
    int argc;
    char *argv[];
{

    large_integer Fraction;
    long Index;
    long NumberBits;
    long Remainder;

    long i;

    //
    // Compute first few reciprocols.
    //

    for (Index = Divisors[i = 0]; Index != 0L; Index = Divisors[++i]) {
        NumberBits = 0L;
        Remainder = 1L;
        Fraction.LowPart = 0L;
        Fraction.HighPart = 0L;
        while (Fraction.HighPart >= 0L) {
            NumberBits += 1L;
            Fraction.HighPart <<= 1L;
            if ((Fraction.LowPart & 0x80000000) != 0L) {
                Fraction.HighPart += 1L;
            }
            Fraction.LowPart <<= 1L;
            Remainder <<= 1L;
            if (Remainder >= Index) {
                Remainder -= Index;
                Fraction.LowPart |= 1L;
            }
        }
        if (Remainder) {
            if ((Fraction.LowPart == -1L) && (Fraction.HighPart == -1L)) {
                Fraction.LowPart = 0L;
                Fraction.HighPart = 0x80000000;
                NumberBits -= 1L;
            } else {
                if (Fraction.LowPart == -1L) {
                    Fraction.LowPart = 0L;
                    Fraction.HighPart += 1L;
                } else {
                    Fraction.LowPart += 1L;
                }
            }
        }

        printf("Divisor %2ld,  Fraction %8lx, %8lx Shift  %ld\n", Index,
               Fraction.HighPart, Fraction.LowPart, NumberBits - 64L);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\trandom.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trandom.c

Abstract:

    Test program for the random number generator

Author:

    Gary Kimura     [GaryKi]    26-May-1989

Revision History:

--*/

#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>

int
_CDECL
main(
    int argc,
    char *argv[]
    )
{
    ULONG Seed;
    ULONG Temp;
    ULONG i;
    CHAR Str[64];

    DbgPrint("Start IntegerToChar and CharToInteger Test\n");

    Seed = 0x12345678;
    RtlIntegerToChar(Seed, 2, sizeof(Str), Str);
    DbgPrint("Seed = 0b%s\n", Str);
    RtlCharToInteger(Str, 2, &Temp);
    ASSERTMSG( "RtlCharToInteger(2)", (Seed == Temp) );

    RtlIntegerToChar(Seed, 8, sizeof(Str), Str);
    DbgPrint("Seed = 0o%s\n", Str);
    RtlCharToInteger(Str, 8, &Temp);
    ASSERTMSG( "RtlCharToInteger(8)", (Seed == Temp) );

    RtlIntegerToChar(Seed, 10, sizeof(Str), Str);
    DbgPrint("Seed = %s\n", Str);
    RtlCharToInteger(Str, 10, &Temp);
    ASSERTMSG( "RtlCharToInteger(10)", (Seed == Temp) );

    RtlIntegerToChar(Seed, 16, -8, Str);
    Str[ 8 ] = '\0';
    DbgPrint("Seed = 0x%s\n", Str);
    RtlCharToInteger(Str, 16, &Temp);
    ASSERTMSG( "RtlCharToInteger(16)", (Seed == Temp) );

    DbgPrint("End IntegerToChar and CharToInteger Test\n");

    DbgPrint("Start RandomTest()\n");

    Seed = 0;
    for (i=0; i<2048; i++) {
        if ((i % 3) == 0) {
            DbgPrint("\n");
        }

        RtlRandom(&Seed);
        DbgPrint("%p ", Seed);

        RtlIntegerToChar(Seed, 16, sizeof(Str), Str);
        DbgPrint("= %s ", Str);

    }

    DbgPrint("\n");

    DbgPrint("End RandomTest()\n");

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\ucli.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ucli.c

Abstract:

    Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsm.h>

#include <string.h>

NTSTATUS
main(
    IN int argc,
    IN char *argv[],
    IN char *envp[],
    IN ULONG DebugParameter OPTIONAL
    )
{
    PCH InitialCommandLine = NULL;
    CHAR Buffer[ 256 ];

    if (argc-- > 1) {
        InitialCommandLine = Buffer;
        *Buffer = '\0';
        while (argc--) {
            strcat( Buffer, *++argv );
            strcat( Buffer, " " );
            }
        }

    RtlCommandLineInterpreter( "UCLI> ", envp, InitialCommandLine );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\tsplay.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tsplay.c

Abstract:

    Test program for the Splay Procedures

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"

ULONG RtlRandom ( IN OUT PULONG Seed );

typedef struct _TREE_NODE {
    CLONG Data;
    RTL_SPLAY_LINKS Links;
} TREE_NODE;
typedef TREE_NODE *PTREE_NODE;

TREE_NODE Buffer[2048];

PTREE_NODE
TreeInsert (
    IN PTREE_NODE Root,
    IN PTREE_NODE Node
    );

VOID
PrintTree (
    IN PTREE_NODE Node
    );

int
_CDECL
main(
    int argc,
    char *argv[]
    )
{
    PTREE_NODE Root;
    ULONG i;
    ULONG Seed;

    DbgPrint("Start SplayTest()\n");

    Root = NULL;
    Seed = 0;
    for (i=0; i<2048; i++) {
        Buffer[i].Data = RtlRandom(&Seed);
        Buffer[i].Data = Buffer[i].Data % 512;
        RtlInitializeSplayLinks(&Buffer[i].Links);
        Root  = TreeInsert(Root, &Buffer[i]);
    }

    PrintTree(Root);

    DbgPrint("End SplayTest()\n");

    return TRUE;

}

PTREE_NODE
TreeInsert (
    IN PTREE_NODE Root,
    IN PTREE_NODE Node
    )

{
    PRTL_SPLAY_LINKS Temp;

    if (Root == NULL) {

        //DbgPrint("Add as root %u\n", Node->Data);
        return Node;

    }

    while (TRUE) {

        if (Root->Data == Node->Data) {

            //DbgPrint("Delete %u\n", Node->Data);

            Temp = RtlDelete(&Root->Links);
            if (Temp == NULL) {
                return NULL;
            } else {
                return CONTAINING_RECORD(Temp, TREE_NODE, Links);
            }

        }

        if (Root->Data < Node->Data) {

            //
            //  Go right
            //

            if (RtlRightChild(&Root->Links) == NULL) {

                //DbgPrint("Add as right child %u\n", Node->Data);
                RtlInsertAsRightChild(&Root->Links, &Node->Links);
                return CONTAINING_RECORD(RtlSplay(&Node->Links), TREE_NODE, Links);

            } else {

                Root = CONTAINING_RECORD(RtlRightChild(&Root->Links), TREE_NODE, Links);

            }

        } else {

            //
            //  Go Left
            //

            if (RtlLeftChild(&Root->Links) == NULL) {

                //DbgPrint("Add as left child %u\n", Node->Data);
                RtlInsertAsLeftChild(&Root->Links, &Node->Links);
                return CONTAINING_RECORD(RtlSplay(&Node->Links), TREE_NODE, Links);

            } else {

                Root = CONTAINING_RECORD(RtlLeftChild(&Root->Links), TREE_NODE, Links);

            }

        }
    }
}

VOID
PrintTree (
    IN PTREE_NODE Node
    )

{
    PRTL_SPLAY_LINKS Temp;
    ULONG LastValue;

    if (Node == NULL) {
        return;
    }

    //
    //  find smallest value
    //

    while (RtlLeftChild(&Node->Links) != NULL) {
        Node = CONTAINING_RECORD(RtlLeftChild(&Node->Links), TREE_NODE, Links);
    }
    LastValue = Node->Data;
    //DbgPrint("%u\n", Node->Data);

    //
    //  while the is a real successor we print the successor value
    //

    while ((Temp = RtlRealSuccessor(&Node->Links)) != NULL) {
        Node = CONTAINING_RECORD(Temp, TREE_NODE, Links);
        if (LastValue >= Node->Data) {
            DbgPrint("TestSplay Error\n");
        }
        LastValue = Node->Data;
        //DbgPrint("%u\n", Node->Data);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\ttime.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ttime.c

Abstract:

    Test program for the time conversion package

Author:

    Gary Kimura     [GaryKi]    27-Aug-1989

Revision History:

--*/

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"

VOID
PrintTimeFields(
    IN PTIME_FIELDS TimeFields
    );

LARGE_INTEGER Zero;
LARGE_INTEGER OneSecond;
LARGE_INTEGER OneMinute;
LARGE_INTEGER OneHour;
LARGE_INTEGER OneDay;
LARGE_INTEGER OneWeek;
LARGE_INTEGER OneNormalYear;
LARGE_INTEGER OneLeapYear;
LARGE_INTEGER OneCentury;
LARGE_INTEGER TwoCenturies;
LARGE_INTEGER ThreeCenturies;
LARGE_INTEGER FourCenturies;

LARGE_INTEGER Sum;

TIME_FIELDS TimeFields;
LARGE_INTEGER Time;

LARGE_INTEGER StartOf1970;
LARGE_INTEGER StartOf1980;

int
main(
    int argc,
    char *argv[]
    )
{
    ULONG i;

    //
    //  We're starting the test
    //

    DbgPrint("Start Time Test\n");

    //
    //  Start by initializing some constants and making sure they
    //  are correct
    //

    Zero.QuadPart = 0;
    OneSecond.QuadPart = 10000000;
    OneMinute.QuadPart = OneSecond.QuadPart * 60;
    OneHour.QuadPart = OneMinute.QuadPart * 60;
    OneDay.QuadPart = OneHour.QuadPart * 24;
    OneWeek.QuadPart = OneDay.QuadPart * 7;
    OneNormalYear.QuadPart = OneDay.QuadPart * 365;
    OneLeapYear.QuadPart = OneDay.QuadPart * 366;
    OneCentury.QuadPart =  (OneNormalYear.QuadPart * 76) + (OneLeapYear.QuadPart * 24);
    TwoCenturies.QuadPart = OneCentury.QuadPart * 2;
    ThreeCenturies.QuadPart = OneCentury.QuadPart * 3;
    FourCenturies.QuadPart = (OneCentury.QuadPart * 4) + OneDay.QuadPart;

    Sum.QuadPart   = Zero.QuadPart +
                     OneSecond.QuadPart +
                     OneMinute.QuadPart +
                     OneHour.QuadPart +
                     OneDay.QuadPart +
                     OneWeek.QuadPart +
                     OneNormalYear.QuadPart +
                     ThreeCenturies.QuadPart;


    RtlTimeToTimeFields( (PLARGE_INTEGER)&Zero, &TimeFields );
    DbgPrint("StartOf1601     = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to Zero\n");
    }
    if ((Time.LowPart != Zero.LowPart) || (Time.HighPart != Zero.HighPart)) {
        DbgPrint("****ERROR Time != Zero\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneSecond, &TimeFields );
    DbgPrint(" + 1 Second     = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneSecond\n");
    }
    if ((Time.LowPart != OneSecond.LowPart) || (Time.HighPart != OneSecond.HighPart)) {
        DbgPrint("****ERROR Time != OneSecond\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneMinute, &TimeFields );
    DbgPrint(" + 1 Minute     = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneMinute\n");
    }
    if ((Time.LowPart != OneMinute.LowPart) || (Time.HighPart != OneMinute.HighPart)) {
        DbgPrint("****ERROR Time != OneMinute\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneHour, &TimeFields );
    DbgPrint(" + 1 Hour       = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneHour\n");
    }
    if ((Time.LowPart != OneHour.LowPart) || (Time.HighPart != OneHour.HighPart)) {
        DbgPrint("****ERROR Time != OneHour\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneDay, &TimeFields );
    DbgPrint(" + 1 Day        = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneDay\n");
    }
    if ((Time.LowPart != OneDay.LowPart) || (Time.HighPart != OneDay.HighPart)) {
        DbgPrint("****ERROR Time != OneDay\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneWeek, &TimeFields );
    DbgPrint(" + 1 Week       = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneWeek\n");
    }
    if ((Time.LowPart != OneWeek.LowPart) || (Time.HighPart != OneWeek.HighPart)) {
        DbgPrint("****ERROR Time != OneWeek\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneNormalYear, &TimeFields );
    DbgPrint(" + 1 NormalYear = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneNormalYear\n");
    }
    if ((Time.LowPart != OneNormalYear.LowPart) || (Time.HighPart != OneNormalYear.HighPart)) {
        DbgPrint("****ERROR Time != OneNormalYear\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneLeapYear, &TimeFields );
    DbgPrint(" + 1 LeapYear   = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneLeapYear\n");
    }
    if ((Time.LowPart != OneLeapYear.LowPart) || (Time.HighPart != OneLeapYear.HighPart)) {
        DbgPrint("****ERROR Time != OneLeapYear\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&OneCentury, &TimeFields );
    DbgPrint(" + 1 Century    = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to OneCentury\n");
    }
    if ((Time.LowPart != OneCentury.LowPart) || (Time.HighPart != OneCentury.HighPart)) {
        DbgPrint("****ERROR Time != OneCentury\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&TwoCenturies, &TimeFields );
    DbgPrint(" + 2 Centuries  = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to TwoCenturies\n");
    }
    if ((Time.LowPart != TwoCenturies.LowPart) || (Time.HighPart != TwoCenturies.HighPart)) {
        DbgPrint("****ERROR Time != TwoCenturies\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&ThreeCenturies, &TimeFields );
    DbgPrint(" + 3 Centuries  = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to ThreeCenturies\n");
    }
    if ((Time.LowPart != ThreeCenturies.LowPart) || (Time.HighPart != ThreeCenturies.HighPart)) {
        DbgPrint("****ERROR Time != ThreeCenturies\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&FourCenturies, &TimeFields );
    DbgPrint(" + 4 Centuries  = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to FourCenturies\n");
    }
    if ((Time.LowPart != FourCenturies.LowPart) || (Time.HighPart != FourCenturies.HighPart)) {
        DbgPrint("****ERROR Time != FourCenturies\n");
    }

    RtlTimeToTimeFields( (PLARGE_INTEGER)&Sum, &TimeFields );
    DbgPrint(" + sum          = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to Sum\n");
    }
    if ((Time.LowPart != Sum.LowPart) || (Time.HighPart != Sum.HighPart)) {
        DbgPrint("****ERROR Time != Sum\n");
    }

    DbgPrint("\n");

    //
    //  Setup and test the start 1970 time
    //

    RtlSecondsSince1970ToTime( 0, &StartOf1970 );
    RtlTimeToTimeFields( &StartOf1970, &TimeFields );
    DbgPrint(" Start of 1970  = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to start of 1970\n");
    }
    if ((Time.LowPart != StartOf1970.LowPart) || (Time.HighPart != StartOf1970.HighPart)) {
        DbgPrint("****ERROR Time != StartOf1970\n");
    }
    if (!RtlTimeToSecondsSince1970( &StartOf1970, &i )) {
        DbgPrint("****ERROR converting time to seconds since 1970\n");
    }
    if (i != 0) {
        DbgPrint("****ERROR seconds since 1970 != 0\n");
    }

    //
    //  Setup and test the start 1980 time
    //

    RtlSecondsSince1980ToTime( 0, &StartOf1980 );
    RtlTimeToTimeFields( &StartOf1980, &TimeFields );
    DbgPrint(" Start of 1980  = "); PrintTimeFields( &TimeFields ); DbgPrint("\n");
    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
        DbgPrint("****ERROR converting TimeFields back to start of 1980\n");
    }
    if ((Time.LowPart != StartOf1980.LowPart) || (Time.HighPart != StartOf1980.HighPart)) {
        DbgPrint("****ERROR Time != StartOf1980\n");
    }
    if (!RtlTimeToSecondsSince1980( &StartOf1980, &i )) {
        DbgPrint("****ERROR converting time to seconds since 1980\n");
    }
    if (i != 0) {
        DbgPrint("****ERROR seconds since 1980 != 0\n");
    }

    //
    //  Lets try to print the Christmas when Santa arrives for 1901 to 2001
    //  every 10 years
    //

    TimeFields.Month = 12;
    TimeFields.Day = 25;
    TimeFields.Hour = 3;
    TimeFields.Minute = 30;
    TimeFields.Second = 15;
    TimeFields.Milliseconds = 250;

    for (i = 1901; i < 2002; i += 10) {

        TimeFields.Year = i;

        if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
            DbgPrint("****ERROR converting TimeFields to Christmas %4d\n", TimeFields.Year);
        }
        RtlTimeToTimeFields( &Time, &TimeFields );
        DbgPrint(" Christmas %4d = ", i); PrintTimeFields( &TimeFields ); DbgPrint("\n");

    }

    //
    //  Let's see how old I really am, when I turn 10, 20, 30, ...
    //

    TimeFields.Month = 12;
    TimeFields.Day = 5;
    TimeFields.Hour = 3;
    TimeFields.Minute = 14;
    TimeFields.Second = 0;
    TimeFields.Milliseconds = 0;

    for (i = 1956; i <= 1956+60; i += 10) {

        TimeFields.Year = i;

        if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {
            DbgPrint("****ERROR converting TimeFields to DOB %4d\n", TimeFields.Year);
        }
        RtlTimeToTimeFields( &Time, &TimeFields );
        DbgPrint(" DOB + %4d = ", i-1956); PrintTimeFields( &TimeFields ); DbgPrint("\n");

    }

    DbgPrint("End Time Test\n");

    return TRUE;
}

VOID
PrintTimeFields (
    IN PTIME_FIELDS TimeFields
    )
{
    static PCHAR Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    static PCHAR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    DbgPrint(" %d", TimeFields->Year);
    DbgPrint("-%s", Months[TimeFields->Month-1]);
    DbgPrint("-%d", TimeFields->Day);

    DbgPrint(" %2d", TimeFields->Hour);
    DbgPrint(":%2d", TimeFields->Minute);
    DbgPrint(":%2d", TimeFields->Second);
    DbgPrint(".%3d", TimeFields->Milliseconds);

    DbgPrint(" (%s)", Days[TimeFields->Weekday]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\ttri.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tsplay.c

Abstract:

    Test program for the Splay Procedures

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

#define DbgPrint DbgPrint

#include <stdio.h>

#include "nt.h"
#include "ntrtl.h"
#include "triangle.h"

ULONG RtlRandom (IN OUT PULONG Seed);

typedef struct _TREE_NODE {
    CLONG Data;
    TRI_SPLAY_LINKS Links;
} TREE_NODE;
typedef TREE_NODE *PTREE_NODE;

TREE_NODE Buffer[2048];

PTREE_NODE
TreeInsert (
    IN PTREE_NODE Root,
    IN PTREE_NODE Node
    );

VOID
PrintTree (
    IN PTREE_NODE Node
    );

int
_CDECL
main(
    int argc,
    char *argv[]
    )
{
    PTREE_NODE Root;
    ULONG i;
    ULONG Seed;

    DbgPrint("Start TriangleTest()\n");

    Root = NULL;
    Seed = 0;
    for (i=0; i<2048; i++) {
        Buffer[i].Data = RtlRandom(&Seed);
        Buffer[i].Data = Buffer[i].Data % 512;
        TriInitializeSplayLinks(&Buffer[i].Links);
        Root  = TreeInsert(Root, &Buffer[i]);
    }

    PrintTree(Root);

    DbgPrint("End TriangleTest()\n");

    return TRUE;

}

PTREE_NODE
TreeInsert (
    IN PTREE_NODE Root,
    IN PTREE_NODE Node
    )

{
    PTRI_SPLAY_LINKS Temp;

    if (Root == NULL) {

        //DbgPrint("Add as root %u\n", Node->Data);
        return Node;

    }

    while (TRUE) {

        if (Root->Data == Node->Data) {

            //DbgPrint("Delete %u\n", Node->Data);

            Temp = TriDelete(&Root->Links);
            if (Temp == NULL) {
                return NULL;
            } else {
                return CONTAINING_RECORD(Temp, TREE_NODE, Links);
            }

        }

        if (Root->Data < Node->Data) {

            //
            //  Go right
            //

            if (TriRightChild(&Root->Links) == NULL) {

                //DbgPrint("Add as right child %u\n", Node->Data);
                TriInsertAsRightChild(&Root->Links, &Node->Links);
                return CONTAINING_RECORD(TriSplay(&Node->Links), TREE_NODE, Links);

            } else {

                Root = CONTAINING_RECORD(TriRightChild(&Root->Links), TREE_NODE, Links);

            }

        } else {

            //
            //  Go Left
            //

            if (TriLeftChild(&Root->Links) == NULL) {

                //DbgPrint("Add as left child %u\n", Node->Data);
                TriInsertAsLeftChild(&Root->Links, &Node->Links);
                return CONTAINING_RECORD(TriSplay(&Node->Links), TREE_NODE, Links);

            } else {

                Root = CONTAINING_RECORD(TriLeftChild(&Root->Links), TREE_NODE, Links);

            }

        }
    }
}

VOID
PrintTree (
    IN PTREE_NODE Node
    )

{
    PTRI_SPLAY_LINKS Temp;
    ULONG LastValue;

    if (Node == NULL) {
        return;
    }

    //
    //  find smallest value
    //

    while (TriLeftChild(&Node->Links) != NULL) {
        Node = CONTAINING_RECORD(TriLeftChild(&Node->Links), TREE_NODE, Links);
    }
    LastValue = Node->Data;
    //DbgPrint("%u\n", Node->Data);

    //
    //  while the is a real successor we print the successor value
    //

    while ((Temp = TriRealSuccessor(&Node->Links)) != NULL) {
        Node = CONTAINING_RECORD(Temp, TREE_NODE, Links);
        if (LastValue >= Node->Data) {
            DbgPrint("TestSplay Error\n");
        }
        LastValue = Node->Data;
        //DbgPrint("%u\n", Node->Data);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\uexec1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tUEXEC1.c

Abstract:

    Sub-Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ULONG i;

    DbgPrint( "Entering UEXEC1 User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }

    DbgPrint( "Leaving UEXEC1 User Mode Test Program\n" );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\uexec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    uexec.c

Abstract:

    Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <string.h>

PVOID MyHeap = NULL;

NTSTATUS
main(
    IN ULONG argc,
    IN PCH argv[],
    IN PCH envp[],
    IN ULONG DebugParameter OPTIONAL
    )
{
    NTSTATUS Status;
    STRING ImagePathName;
    PCHAR PathVariable, *pp;
    CHAR ImageNameBuffer[ 128 ];
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    ULONG i, CountBytes, envc, Bogus;
    PSTRING DstString;
    PCH Src, Dst;
    PCH Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG+2 ];

    Parameters[ RTL_USER_PROC_PARAMS_IMAGEFILE ] =
         "Full Path Specification of Image File goes here";

    Parameters[ RTL_USER_PROC_PARAMS_CMDLINE ] =
         "Complete Command Line goes here";

    Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG ] =
         "Debugging String goes here";

    Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG+1 ] = NULL;

    MyHeap = RtlProcessHeap();

#if DBG
    DbgPrint( "Entering UEXEC User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }

#endif

    PathVariable = "\\SystemRoot";
    if (envp != NULL) {
        pp = envp;
        while (Src = *pp++) {
            if (!_strnicmp( Src, "PATH=", 5 )) {
                PathVariable = Src+5;
                break;
                }
            }
        }

    DbgPrint( "PATH=%s\n", PathVariable );

    ProcessParameters = (PRTL_USER_PROCESS_PARAMETERS)
                            RtlAllocateHeap( MyHeap, 0, 2048 );
    ProcessParameters->MaximumLength = 2048;

    argv[ argc ] = NULL;
    Status = RtlVectorsToProcessParameters(
                argv,
                envp,
                Parameters,
                ProcessParameters
                );

    ImagePathName.Buffer = ImageNameBuffer;
    ImagePathName.Length = 0;
    ImagePathName.MaximumLength = sizeof( ImageNameBuffer );
    if (RtlSearchPath( PathVariable, "uexec1.exe", NULL, &ImagePathName )) {
        Status = RtlCreateUserProcess( &ImagePathName,
                                       NULL,
                                       NULL,
                                       NULL,
                                       TRUE,
                                       NULL,
                                       NULL,
                                       ProcessParameters,
                                       &ProcessInformation,
                                       NULL
                                     );
        if (NT_SUCCESS( Status )) {
            Status = NtResumeThread( ProcessInformation.Thread, &Bogus );
            if (NT_SUCCESS( Status )) {
#if DBG
                DbgPrint( "UEXEC waiting for UEXEC1...\n" );
#endif
                Status = NtWaitForSingleObject( ProcessInformation.Process,
                                                TRUE,
                                                NULL
                                              );
                }
            }
        }
    else {
        DbgPrint( "UEXEC1.EXE not found in %s\n", PathVariable );
        Status = STATUS_UNSUCCESSFUL;
        }

#if DBG
    DbgPrint( "Leaving UEXEC User Mode Test Program\n" );
#endif

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\uexec2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    uexec.c

Abstract:

    Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Mark Lucovsyt (markl) 14-Jun-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    IN ULONG argc,
    IN PCH argv[],
    IN PCH envp[],
    IN ULONG DebugParameter OPTIONAL
    )
{
    NTSTATUS st;
    STRING ImagePathName;
    UNICODE_STRING ConfigFilePathname;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PEB_SM_DATA PebSessionInformation;
    HANDLE FileHandle;
    ULONG FileIndexNumber;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    FILE_INTERNAL_INFORMATION FileInformation;
    PPEB Peb;

    Peb = NtCurrentPeb();
    RtlZeroMemory(&PebSessionInformation,sizeof(PebSessionInformation));

    //
    // If we started from cli then do all this work to
    // pass thru stdin
    //

    if ( !Peb->Sm.StandardInput.FileHandle ) {

        RtlInitUnicodeString(&ConfigFilePathname,L"\\SystemRoot\\nt.cfg");

        //
        // Open the file
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &ConfigFilePathname,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        st = NtOpenFile(
                &FileHandle,
                SYNCHRONIZE | FILE_READ_DATA,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ,
                0
                );

        if (!NT_SUCCESS( st )) {
            DbgPrint("NtOpenFile: %wZ failed 0x%lx\n",&ConfigFilePathname,st);
            ASSERT(NT_SUCCESS(st));
        }

        //
        // get the file serial number
        //

        st = NtQueryInformationFile(
                FileHandle,
                &IoStatus,
                (PVOID) &FileInformation,
                sizeof(FileInformation),
                FileInternalInformation
                );

        if (!NT_SUCCESS( st )) {
            DbgPrint("NtQueryInformationFile: %wZ failed 0x%lx\n",&ConfigFilePathname,st);
            ASSERT(NT_SUCCESS(st));
        }

        PebSessionInformation.Length = sizeof(PebSessionInformation);
        PebSessionInformation.StandardInput.FileHandle = FileHandle;
        PebSessionInformation.StandardInput.Context = (PVOID) FileInformation.IndexNumber;

        RtlInitString(&ImagePathName,"\\A:\\uexec2.exe");

        st = RtlCreateUserProcess(
                &ImagePathName,
                NULL,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                NULL,
                &ProcessInformation,
                &PebSessionInformation
                );

        ASSERT(NT_SUCCESS(st));

        NtResumeThread(ProcessInformation.Thread,NULL);
        NtWaitForSingleObject(ProcessInformation.Process,FALSE,NULL);
        NtClose(ProcessInformation.Process);
        NtClose(ProcessInformation.Thread);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);

    } else {

        if ( !Peb->Sm.StandardOutput.FileHandle ) {

            //
            // Started from this program. Stdin is inherited
            //

            st = NtQueryInformationFile(
                    Peb->Sm.StandardInput.FileHandle,
                    &IoStatus,
                    (PVOID) &FileInformation,
                    sizeof(FileInformation),
                    FileInternalInformation
                    );

            if (!NT_SUCCESS( st )) {
                DbgPrint("NtQueryInformationFile: failed 0x%lx\n",st);
                ASSERT(NT_SUCCESS(st));
            }

            ASSERT(Peb->Sm.StandardInput.Context == (PVOID) FileInformation.IndexNumber);

            PebSessionInformation.Length = sizeof(PebSessionInformation);
            PebSessionInformation.StandardInput.FileHandle = (HANDLE)PEB_STDIO_HANDLE_SUBSYS;
            PebSessionInformation.StandardOutput.FileHandle = Peb->Sm.StandardInput.FileHandle;
            PebSessionInformation.StandardOutput.Context = (PVOID) FileInformation.IndexNumber;

            RtlInitString(&ImagePathName,"\\A:\\uexec2.exe");

            st = RtlCreateUserProcess(
                    &ImagePathName,
                    NULL,
                    NULL,
                    NULL,
                    FALSE,
                    NULL,
                    NULL,
                    NULL,
                    &ProcessInformation,
                    &PebSessionInformation
                    );

            ASSERT(NT_SUCCESS(st));

            NtResumeThread(ProcessInformation.Thread,NULL);
            NtWaitForSingleObject(ProcessInformation.Process,FALSE,NULL);
            NtClose(ProcessInformation.Process);
            NtClose(ProcessInformation.Thread);
            NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);

        } else {

            ASSERT(Peb->Sm.StandardInput.FileHandle == (HANDLE)PEB_STDIO_HANDLE_SUBSYS);

            if ( !Peb->Sm.StandardError.FileHandle ) {

                //
                // Started by this program with StandardOutput Inherited
                //

                st = NtQueryInformationFile(
                        Peb->Sm.StandardOutput.FileHandle,
                        &IoStatus,
                        (PVOID) &FileInformation,
                        sizeof(FileInformation),
                        FileInternalInformation
                        );

                if (!NT_SUCCESS( st )) {
                    DbgPrint("NtQueryInformationFile: failed 0x%lx\n",st);
                    ASSERT(NT_SUCCESS(st));
                }

                ASSERT(Peb->Sm.StandardOutput.Context == (PVOID) FileInformation.IndexNumber);

                PebSessionInformation.Length = sizeof(PebSessionInformation);
                PebSessionInformation.StandardInput.FileHandle = (HANDLE)PEB_STDIO_HANDLE_SUBSYS;
                PebSessionInformation.StandardOutput.FileHandle = (HANDLE)PEB_STDIO_HANDLE_PM;
                PebSessionInformation.StandardError.FileHandle = Peb->Sm.StandardOutput.FileHandle;
                PebSessionInformation.StandardError.Context = (PVOID) FileInformation.IndexNumber;

                RtlInitString(&ImagePathName,"\\A:\\uexec2.exe");

                st = RtlCreateUserProcess(
                        &ImagePathName,
                        NULL,
                        NULL,
                        NULL,
                        FALSE,
                        NULL,
                        NULL,
                        NULL,
                        &ProcessInformation,
                        &PebSessionInformation
                        );

                ASSERT(NT_SUCCESS(st));

                NtResumeThread(ProcessInformation.Thread,NULL);
                NtWaitForSingleObject(ProcessInformation.Process,FALSE,NULL);
                NtClose(ProcessInformation.Process);
                NtClose(ProcessInformation.Thread);
                NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);

            } else {

                ASSERT(Peb->Sm.StandardOutput.FileHandle == (HANDLE)PEB_STDIO_HANDLE_PM);

                //
                // Started by this program with StandardError Inherited
                //

                st = NtQueryInformationFile(
                        Peb->Sm.StandardError.FileHandle,
                        &IoStatus,
                        (PVOID) &FileInformation,
                        sizeof(FileInformation),
                        FileInternalInformation
                        );

                if (!NT_SUCCESS( st )) {
                    DbgPrint("NtQueryInformationFile: failed 0x%lx\n",st);
                    ASSERT(NT_SUCCESS(st));
                }

                ASSERT(Peb->Sm.StandardError.Context == (PVOID) FileInformation.IndexNumber);
                NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\trtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trtl.c

Abstract:

    Test program for the NT OS Runtime Library (RTL)

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#include <os2.h>
#include <stdio.h>
#include <process.h>
#include "nt.h"
#include "ntrtl.h"

char *TestMemoryStrings[] = {
    "",
    "1",
    "12",
    "123",
    "1234",
    "12345",
    "123456",
    "1234567",
    "12345678",
    "123456789",
    "123456789A",
    NULL
};


BOOLEAN
StringCompare(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive,
    IN LONG ExpectedResult
    )
{
    LONG Result = RtlCompareString( String1, String2, CaseInSensitive );

    if (Result < 0) {
        Result = -1L;
        }
    else {
        if (Result > 0) {
            Result = 1L;
            }
        }

    if (Result != ExpectedResult) {
        DbgPrint( "RtlCompareString( \"%.*s\", \"%.*s\", %d ) == %ld (%ld)\n",
                String1->Length, String1->Buffer,
                String2->Length, String2->Buffer,
                CaseInSensitive,
                Result, ExpectedResult
                );
        return( FALSE );
        }
    else {
        return( TRUE );
        }
}

BOOLEAN
StringEqual(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive,
    IN BOOLEAN ExpectedResult
    )
{
    BOOLEAN Result = RtlEqualString( String1, String2, CaseInSensitive );

    if (Result != ExpectedResult) {
        DbgPrint( "RtlEqualString( \"%.*s\", \"%.*s\", %d ) == %d (%d)\n",
                String1->Length, String1->Buffer,
                String2->Length, String2->Buffer,
                CaseInSensitive,
                Result, ExpectedResult );
        return( FALSE );
        }
    else {
        return( TRUE );
        }
}

VOID
DumpString(
    IN PCH StringTitle,
    IN PSTRING String
    )
{
    DbgPrint( "%s: (%d, %d) \"%.*s\"\n", StringTitle,
                                       String->MaximumLength,
                                       String->Length,
                                       String->Length,
                                       String->Buffer );
}


BOOLEAN
TestString( void )
{
    BOOLEAN Result;
    char buffer5[ 80 ], buffer6[ 15 ], buffer7[ 3 ];
    STRING String1, String2, String3, String4;
    STRING String5, String6, String7, String8;
                            //         1         2
                            //12345678901234567890
                            //
    RtlInitString( &String1, " One" );
    RtlInitString( &String2, " Two" );
    RtlInitString( &String3, " Three" );
    RtlInitString( &String4, " Four" );
    String5.Buffer = buffer5;
    String5.MaximumLength = sizeof( buffer5 );
    String5.Length = 0;
    String6.Buffer = buffer6;
    String6.MaximumLength = sizeof( buffer6 );
    String6.Length = 0;
    String7.Buffer = buffer7;
    String7.MaximumLength = sizeof( buffer7 );
    String7.Length = 0;
    String8.Buffer = NULL;
    String8.MaximumLength = 0;
    String8.Length = 0;
    RtlCopyString( &String5, &String1 );
    RtlCopyString( &String6, &String2 );
    RtlCopyString( &String7, &String3 );
    RtlCopyString( &String8, &String4 );

    DumpString( "String1", &String1 );
    DumpString( "String2", &String2 );
    DumpString( "String3", &String3 );
    DumpString( "String4", &String4 );
    DumpString( "String5", &String5 );
    DumpString( "String6", &String6 );
    DumpString( "String7", &String7 );
    DumpString( "String8", &String8 );

    Result = TRUE;
    Result &= StringCompare( &String1, &String1, FALSE, 0L );
    Result &= StringCompare( &String1, &String2, FALSE, -1L);
    Result &= StringCompare( &String1, &String3, FALSE, -1L);
    Result &= StringCompare( &String1, &String4, FALSE, 1L );
    Result &= StringCompare( &String1, &String5, FALSE, 0L );
    Result &= StringCompare( &String1, &String6, FALSE, -1L);
    Result &= StringCompare( &String1, &String7, FALSE, -1L);
    Result &= StringCompare( &String1, &String8, FALSE, 1L );

    Result &= StringEqual( &String1, &String1, FALSE, 1 );
    Result &= StringEqual( &String1, &String2, FALSE, 0 );
    Result &= StringEqual( &String1, &String3, FALSE, 0 );
    Result &= StringEqual( &String1, &String4, FALSE, 0 );
    Result &= StringEqual( &String1, &String5, FALSE, 1 );
    Result &= StringEqual( &String1, &String6, FALSE, 0 );
    Result &= StringEqual( &String1, &String7, FALSE, 0 );
    Result &= StringEqual( &String1, &String8, FALSE, 0 );

    return( Result );
}


int
_CDECL
main(
    int argc,
    char *argv[]
    )
{
    if (!TestString()) {
        DbgPrint( "TRTL: TestString failed\n" );
        exit( 1 );
        }

    exit( 0 );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\utxcpt3.c ===
//  utxcpt3.c - user mode seh test #3.

#include <ntos.h>

BOOLEAN EndTest = FALSE;

main()
{

    while (EndTest == FALSE) {
        try {
            try {
                DbgPrint("doing return\n");
                return;
            }
            finally {
                DbgPrint("in inner finally\n");
                break;
            }
        }
        finally {
	    DbgPrint("in last finally\n");
            continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\utxcpt1.c ===
//  utxcpt1.c - user mode structured exception handling test 1

#include <ntos.h>

main()
{
    LONG i, j;
    PULONG p4, p3, p2, p1;
    ULONG Size1, Size2, Size3;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG ViewSize, Offset;

    CurrentProcessHandle = NtCurrentProcess();

    for(i=0;i<3;i++){
        DbgPrint("Hello World...\n\n");
    }

    DbgPrint("allocating virtual memory\n");

    p1 = (PULONG)NULL;
    Size1 = 5*4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID)&p1,
                        0, &Size1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm status %X start %lx size %lx\n",
            status, (ULONG)p1, Size1);

    p2 = p1;

    *p2 = 99;
    Size2 = 4;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID)&p2,
                        &Size2, PAGE_GUARD | PAGE_READONLY, &OldProtect);

    DbgPrint("protected VM status %X, base %lx, size %lx, old protect %lx\n",
                    status, p2, Size2, OldProtect);

    p3 = p1 + 1024;

    *p3 =91;
    Size2 = 4;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID)&p3,
                        &Size2, PAGE_NOACCESS, &OldProtect);

    DbgPrint("protected VM status %X, base %lx, size %lx, old protect %lx\n",
                    status, p3, Size2, OldProtect);
    try {
        *p2 = 94;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DbgPrint("got an exception of %X\n",status);
    }

    try {
        i = *p2;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DbgPrint("got an exception of %X\n",status);
    }

    DbgPrint("value of p2 should be 94 is %ld\n",*p2);

    try {
        *p3 = 94;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DbgPrint("got an exception of %X\n",status);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\up\makefile.inc ===
!if defined(LINK_TIME_CODE_GENERATION)
$(O)\generr.obj: ..\generr.c
    $(C_COMPILER_NAME) ..\generr.c @<<
-Fo$(O)\generr.obj
$(EX_C_COMPILER_FLAGS:/GL=)
<<NOKEEP
!else 
$(O)\generr.obj: ..\generr.c
!endif

$(O)\error.h: $(O)\generr.obj
    generr $? $@

..\error.c: $(O)\error.h

!if $(386)
$(O)\$(TARGETNAME).lib : $(O)\xcptmisc.org

$(O)\xcptmisc.org : $(O)\xcptmisc.obj
   copy $** $@
   sxgen /verbose /in:$@ /out:$** ExceptionHandler@16 UnwindHandler@16
   touch $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\user\theap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    theap.c

Abstract:

    Test program for the Heap Procedures

Author:

    Steven R. Wood  [stevewo]

Revision History:

--*/

#define THEAP
#include "..\heap.c"
#include "..\heapdll.c"
#include "..\heapdbg.c"
#include "..\heappage.c"
#include <windows.h>

#include <stdlib.h>

ULONG NtGlobalFlag = FLG_HEAP_ENABLE_TAIL_CHECK |
                     FLG_HEAP_ENABLE_FREE_CHECK |
                     FLG_HEAP_VALIDATE_PARAMETERS |
                     FLG_HEAP_VALIDATE_ALL |
                     FLG_HEAP_ENABLE_TAGGING;

BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    )
{
    return TRUE;
}

PRTL_INITIALIZE_LOCK_ROUTINE RtlInitializeLockRoutine =
    (PRTL_INITIALIZE_LOCK_ROUTINE)RtlInitializeCriticalSection;
PRTL_ACQUIRE_LOCK_ROUTINE RtlAcquireLockRoutine =
    (PRTL_ACQUIRE_LOCK_ROUTINE)RtlEnterCriticalSection;
PRTL_RELEASE_LOCK_ROUTINE RtlReleaseLockRoutine =
    (PRTL_RELEASE_LOCK_ROUTINE)RtlLeaveCriticalSection;
PRTL_DELETE_LOCK_ROUTINE RtlDeleteLockRoutine =
    (PRTL_DELETE_LOCK_ROUTINE)RtlDeleteCriticalSection;
PRTL_OKAY_TO_LOCK_ROUTINE RtlOkayToLockRoutine =
    (PRTL_OKAY_TO_LOCK_ROUTINE)NtdllOkayToLockRoutine;

RTL_HEAP_PARAMETERS HeapParameters;

ULONG RtlpHeapValidateOnCall;
ULONG RtlpHeapStopOnFree;
ULONG RtlpHeapStopOnReAlloc;


typedef struct _TEST_HEAP_ENTRY {
    PVOID AllocatedBlock;
    ULONG Size;
} TEST_HEAP_ENTRY, *PTEST_HEAP_ENTRY;

ULONG NumberOfHeapEntries;
PTEST_HEAP_ENTRY HeapEntries;

ULONG Seed = 14623;

#define MAX_HEAP_ALLOC 0x120000
#define REASONABLE_HEAP_ALLOC 0x200

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    PVOID Heap, AllocatedBlock;
    ULONG i, n;
    PTEST_HEAP_ENTRY p;
    BOOLEAN Result;
    NTSTATUS Status;
    RTL_HEAP_USAGE Usage;
    PRTL_HEAP_USAGE_ENTRY pEntries;
    ULONG TagBaseIndex, Tag;
    ULONG TotalAllocated;

    RtlInitializeHeapManager();
    memset( &Usage, 0, sizeof( Usage ) );

#if 0
    HeapParameters.Length = sizeof( HeapParameters );
    HeapParameters.DeCommitFreeBlockThreshold = 0x1000;
    HeapParameters.DeCommitTotalFreeThreshold = 0x4000;
    Heap = RtlCreateHeap( HEAP_GROWABLE | HEAP_NO_SERIALIZE,
                          NULL,
                          256 * 4096,
                          4096,
                          NULL,
                          &HeapParameters
                        );
#endif
    Heap = RtlCreateHeap( HEAP_GROWABLE | HEAP_NO_SERIALIZE | HEAP_CLASS_3,
                          NULL,
                          0x100000,
                          0x1000,
                          NULL,
                          NULL
                        );
    if (Heap == NULL) {
        fprintf( stderr, "THEAP: Unable to create heap.\n" );
        exit( 1 );
        }
    fprintf( stderr, "THEAP: Created heap at %x\n", Heap );
    DebugBreak();
    TagBaseIndex = RtlCreateTagHeap( Heap, 0, L"THEAP!",
                                     L"!HeapName\0"
                                     L"Tag1\0"
                                     L"Tag2\0"
                                     L"Tag3\0"
                                     L"Tag4\0"
                                     L"Tag5\0"
                                     L"Tag6\0"
                                     L"Tag7\0"
                                     L"Tag8\0"
                                     L"Tag9\0"
                                     L"Tag10\0"
                                     L"Tag11\0"
                                     L"Tag12\0"
                                     L"Tag13\0"
                                     L"Tag14\0"
                                     L"Tag15\0"
                                     L"Tag16\0"
                                     L"Tag17\0"
                                     L"Tag18\0"
                                     L"Tag19\0"
                                     L"Tag20\0"
                                     L"Tag21\0"
                                     L"Tag22\0"
                                     L"Tag23\0"
                                     L"Tag24\0"
                                     L"Tag25\0"
                                     L"Tag26\0"
                                     L"Tag27\0"
                                     L"Tag28\0"
                                     L"Tag29\0"
                                     L"Tag30\0"
                                     L"Tag31\0"
                                     L"Tag32\0"
                                     L"Tag33\0"
                                     L"Tag34\0"
                                     L"Tag35\0"
                                     L"Tag36\0"
                                     L"Tag37\0"
                                     L"Tag38\0"
                                     L"Tag39\0"
                                     L"Tag40\0"
                                     L"Tag41\0"
                                     L"Tag42\0"
                                     L"Tag43\0"
                                     L"Tag44\0"
                                     L"Tag45\0"
                                     L"Tag46\0"
                                     L"Tag47\0"
                                     L"Tag48\0"
                                     L"Tag49\0"
                                     L"Tag50\0"
                                     L"Tag51\0"
                                     L"Tag52\0"
                                     L"Tag53\0"
                                     L"Tag54\0"
                                     L"Tag55\0"
                                     L"Tag56\0"
                                     L"Tag57\0"
                                     L"Tag58\0"
                                     L"Tag59\0"
                                     L"Tag60\0"
                                   );

    NumberOfHeapEntries = 1000;
    HeapEntries = VirtualAlloc( NULL,
                                NumberOfHeapEntries * sizeof( *HeapEntries ),
                                MEM_COMMIT,
                                PAGE_READWRITE
                              );
    if (HeapEntries == NULL) {
        fprintf( stderr, "THEAP: Unable to allocate space.\n" );
        exit( 1 );
        }

    RtlpHeapValidateOnCall=TRUE;
    // RtlpHeapStopOnAllocate=0x350f88;
    // RtlpHeapStopOnReAlloc=0x710040;

    TotalAllocated = 0;
    while (TotalAllocated < (2 * 1024 * 1024)) {
        i = RtlUniform( &Seed ) % NumberOfHeapEntries;
        if (RtlUniform( &Seed ) % 100) {
            n = RtlUniform( &Seed ) % REASONABLE_HEAP_ALLOC;
            }
        else {
            n = RtlUniform( &Seed ) % MAX_HEAP_ALLOC;
            }

#if 0
        Usage.Length = sizeof( Usage );
        Status = RtlUsageHeap( Heap, HEAP_USAGE_ALLOCATED_BLOCKS , &Usage );
        if (NT_SUCCESS( Status )) {
            if (Status == STATUS_MORE_ENTRIES) {
                pEntries = Usage.AddedEntries;
                while (pEntries) {
                    fprintf( stderr,
                             "Added: %08x %06x\n",
                             pEntries->Address,
                             pEntries->Size
                           );
                    pEntries = pEntries->Next;
                    }

                pEntries = Usage.RemovedEntries;
                while (pEntries) {
                    fprintf( stderr,
                             "Freed: %08x %06x\n",
                             pEntries->Address,
                             pEntries->Size
                           );
                    pEntries = pEntries->Next;
                    }
                }

            fprintf( stderr, "%08x  %08x  %08x  %08x  ",
                             Usage.BytesAllocated, Usage.BytesCommitted,
                             Usage.BytesReserved, Usage.BytesReservedMaximum
                   );
            }
        else {
            fprintf( stderr, "RtlUsageHeap failed with status %x\n", Status );
            DebugBreak();
            }

        if (i < 60) {
            Tag = (TagBaseIndex + i + 1) << 16;
            }
        else {
            Tag = 0;
            }
#endif
        Tag = 0;
        p = &HeapEntries[ i ];
        if (p->AllocatedBlock == NULL) {
            TotalAllocated += n;
            p->AllocatedBlock = RtlAllocateHeap( Heap, Tag, n );
            fprintf( stderr, "Allocated %06x bytes at %08x\n", n, p->AllocatedBlock );
            if (p->AllocatedBlock != NULL) {
                p->Size = n;
                }
            else {
                DebugBreak();
                }
            }
        else
        if (RtlUniform( &Seed ) & 1) {
            TotalAllocated -= p->Size;
            TotalAllocated += n;
            AllocatedBlock = RtlReAllocateHeap( Heap, Tag, p->AllocatedBlock, n );
            fprintf( stderr, "ReAlloced %06x bytes at %08x to %06x bytes at %08x\n",
                     p->Size,
                     p->AllocatedBlock,
                     n,
                     AllocatedBlock
                   );
            if (AllocatedBlock != NULL) {
                p->AllocatedBlock = AllocatedBlock;
                p->Size = n;
                }
            else {
                DebugBreak();
                }
            }
        else {
            TotalAllocated -= p->Size;
            Result = RtlFreeHeap( Heap, 0, p->AllocatedBlock );
            fprintf( stderr, "Freed     %06x bytes at %08x\n",
                     p->Size,
                     p->AllocatedBlock
                   );
            if (Result) {
                p->AllocatedBlock = NULL;
                p->Size = 0;
                }
            else {
                DebugBreak();
                }
            }

        }

    RtlResetHeap( Heap, 0 );
    RtlValidateHeap( Heap, 0, NULL );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\utxcpt2.c ===
//  utxcpt2.c - user mode structured exception handling test 2
//
//  Exception test from Markl.
//

#include <ntos.h>

VOID
ExceptionTest (
    )

//
// This routine tests the structured exception handling capabilities of the
// MS C compiler and the NT exception handling facilities.
//

{

    EXCEPTION_RECORD ExceptionRecord;
    LONG Counter;
    ULONG rv;

    //
    // Announce start of exception test.
    //

    DbgPrint("Start of exception test\n");

    //
    // Initialize exception record.
    //

    ExceptionRecord.ExceptionCode = (NTSTATUS)49;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 1;
    ExceptionRecord.ExceptionInformation[0] = 9;

    //
    // Simply try statement with a finally clause that is entered sequentially.
    //
    DbgPrint("t1...");
    Counter = 0;
    try {
        Counter += 1;
    } finally {
        if (abnormal_termination() == 0) {
            Counter += 1;
        }
    }
    if (Counter != 2) {
        DbgPrint("BUG  Finally clause executed as result of unwind\n");
    }
    DbgPrint("done\n");

    //
    // Simple try statement with an exception clause that is never executed
    // because there is no exception raised in the try clause.
    //
//  goto a;
    DbgPrint("t2...");
    Counter = 0;
    try {
//a:	    Counter += 1;
	  Counter += 1;
    } except (Counter) {
        Counter += 1;
    }
    if (Counter != 1) {
        DbgPrint("BUG  Exception clause executed when it shouldn't be\n");
    }
    DbgPrint("done\n");

    //
    // Simple try statement with an exception handler that is never executed
    // because the exception expression continues execution.
    //
    DbgPrint("t3...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = 0;
    try {
        Counter -= 1;
        RtlRaiseException(&ExceptionRecord);
    } except (Counter) {
        Counter -= 1;
    }
    if (Counter != - 1) {
        DbgPrint("BUG  Exception clause executed when it shouldn't be\n");
    }
    DbgPrint("done\n");

    //
    // Simple try statement with an exception clause that is always executed.
    //
    DbgPrint("t4...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {
        Counter += 1;
        RtlRaiseException(&ExceptionRecord);
    } except (Counter) {
        Counter += 1;
    }
    if (Counter != 2) {
        DbgPrint("BUG  Exception clause not executed when it should be\n");
    }
    DbgPrint("done\n");

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    DbgPrint("t5...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = 0;
    try {
        try {
            Counter += 1;
            RtlRaiseException(&ExceptionRecord);
        } finally {
            if (abnormal_termination() != 0) {
                Counter += 1;
            }
        }
    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }
    if (Counter != 3) {
        DbgPrint("BUG  Finally clause executed as result of sequential exit\n");
    }
    DbgPrint("done\n");

    //
    // Simple try that calls a function which raises an exception.
    //
    DbgPrint("t6...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {
        VOID foo(IN NTSTATUS Status);

        Counter += 1;
        foo(STATUS_ACCESS_VIOLATION);
    } except (exception_code() == STATUS_ACCESS_VIOLATION) {
        Counter += 1;
    }
    if (Counter != 2) {
        DbgPrint("BUG  Exception clause not executed when it should be\n");
    }
    DbgPrint("done\n");

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //
    DbgPrint("t7...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {
        VOID bar(IN NTSTATUS Status, IN PULONG Counter);

        bar(STATUS_ACCESS_VIOLATION, &Counter);

    } except (exception_code() == STATUS_ACCESS_VIOLATION) {
        if (Counter != 99) {
            DbgPrint("BUG  finally in called procedure not executed\n");
        }
    }
    DbgPrint("done\n");

    //
    // A try within an except
    //
    DbgPrint("t8...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {

        foo(STATUS_ACCESS_VIOLATION);

    } except (exception_code() == STATUS_ACCESS_VIOLATION) {

        Counter++;

        try {

            foo(STATUS_SUCCESS);

        } except (exception_code() == STATUS_SUCCESS) {
            if ( Counter != 1 ) {
                DbgPrint("BUG  Previous Handler not Entered\n");
            }
            Counter++;

        }
    }
    if (Counter != 2) {
        DbgPrint("BUG Both Handlers not entered\n");
    }
    DbgPrint("done\n");

    //
    // A goto from an exception clause that needs to pass
    // through a finally
    //
    DbgPrint("t9...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {
        try {
            foo(STATUS_ACCESS_VIOLATION);
        } except (exception_code() == STATUS_ACCESS_VIOLATION) {
            Counter++;
            goto t9;
        }
    } finally {
        Counter++;
    }
t9:
    if (Counter != 2) {
        DbgPrint("BUG Finally and Exception Handlers not entered\n");
    }
    DbgPrint("done\n");

    //
    // A goto from an exception clause that needs to pass
    // through a finally
    //
    DbgPrint("t10...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    try {
        try {
            Counter++;
        } finally {
            Counter++;
            goto t10;
        }
    } finally {
        Counter++;
    }
t10:
    if (Counter != 3) {
        DbgPrint("BUG Both Finally Handlers not entered\n");
    }
    DbgPrint("done\n");

    //
    // A return from an except clause
    //
    DbgPrint("t11...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

    try {
        ULONG eret(IN NTSTATUS Status, IN PULONG Counter);

        Counter++;
        rv = eret(STATUS_ACCESS_VIOLATION, &Counter);
    } finally {
        Counter++;
    }

    if (Counter != 4) {
        DbgPrint("BUG Both Finally Handlers and Exception Handler not entered\n");
    }
    if (rv != 0xDEADBEEF) {
        DbgPrint("BUG rv is wrong\n");
    }
    DbgPrint("done\n");

    //
    // A return from a finally clause
    //
    DbgPrint("t12...");
    Counter = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

    try {
        VOID fret(IN PULONG Counter);

        Counter++;
        fret(&Counter);
    } finally {
        Counter++;
    }

    if (Counter != 5) {
        DbgPrint("BUG All three Finally Handlers not entered\n");
    }
    DbgPrint("done\n");
    //
    // Announce end of exception test.
    //

    DbgPrint("End of exception test\n");

    return;
}

main()
{
    ExceptionTest ();
}


NTSTATUS
ZwLastChance (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )
{
    DbgPrint("ZwLastChance Entered\n");;
}


VOID
fret(
    IN PULONG Counter
    )
{

    try {

        try {
            *Counter += 1;
        } finally {
            *Counter += 1;
            return;
        }
    } finally {
        *Counter += 1;
    }
}
ULONG
eret(
    IN NTSTATUS Status,
    IN PULONG Counter
    )
{

    EXCEPTION_RECORD ExceptionRecord;

    try {

        try {
            foo(Status);
        } except (exception_code() == Status) {
            *Counter += 1;
            return 0xDEADBEEF;
        }
    } finally {
        *Counter += 1;
    }
}
VOID
bar(
    IN NTSTATUS Status,
    IN PULONG Counter
    )
{

    EXCEPTION_RECORD ExceptionRecord;

    try {
        foo(Status);
    }

    finally {
        if (abnormal_termination() != 0) {
            *Counter = 99;
        } else {
            *Counter = 100;
        }
    }
}

VOID
foo(
    IN NTSTATUS Status
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    LONG Counter;

    //
    // Initialize exception record.
    //

    ExceptionRecord.ExceptionFlags = 0;
    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    RtlRaiseException(&ExceptionRecord);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\urtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    urtl.c

Abstract:

    Usermode test program for rtl

Author:

    Mark Lucovsky (markl) 22-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

PVOID MyHeap = NULL;

DumpIt(
    IN PRTL_USER_PROCESS_PARAMETERS ArgBase
    )
{
    ULONG Base;
    PSTRING Vector;
    PCH *ParmVector;
    ULONG i;

    (VOID) RtlNormalizeProcessParameters( ArgBase );
    (VOID) RtlDeNormalizeProcessParameters( ArgBase );

    Base = (ULONG) ArgBase;

    DbgPrint("DumpIt: ArgBase       %lx\n",ArgBase);
    DbgPrint("DumpIt: MaximumLength %lx\n",ArgBase->MaximumLength);
    DbgPrint("DumpIt: Length        %lx\n",ArgBase->Length);
    DbgPrint("DumpIt: ArgumentCount %lx\n",ArgBase->ArgumentCount);
    DbgPrint("DumpIt: Arguments     %lx\n",ArgBase->Arguments    );
    DbgPrint("DumpIt: VariableCount %lx\n",ArgBase->VariableCount);
    DbgPrint("DumpIt: Variables     %lx\n",ArgBase->Variables    );
    DbgPrint("DumpIt: ParameterCount%lx\n",ArgBase->ParameterCount);
    DbgPrint("DumpIt: Parameters    %lx\n",ArgBase->Parameters    );

    if ( ArgBase->ArgumentCount ) {
        Vector = (PSTRING)((PCH)ArgBase->Arguments + Base);
        i = ArgBase->ArgumentCount;
        while(i--){
            DbgPrint("DumpIt: Argument %s\n",Vector->Buffer + Base);
            Vector++;
        }
    }

    if ( ArgBase->VariableCount ) {
        Vector = (PSTRING)((PCH)ArgBase->Variables + Base);
        i = ArgBase->VariableCount;
        while(i--){
            DbgPrint("DumpIt: Variable %s\n",Vector->Buffer + Base);
            Vector++;
        }
    }

    if ( ArgBase->ParameterCount ) {
        ParmVector = (PCH *)((PCH)ArgBase->Parameters + Base);
        i = ArgBase->ParameterCount;
        while(i--) {
            DbgPrint("DumpIt: Parameter %s\n",*ParmVector + Base);
            ParmVector++;
        }
    }
}

BOOLEAN
VectorTest(
    IN PCH Arguments[],
    IN PCH Variables[],
    IN PCH Parameters[]
    )
{

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    NTSTATUS st;

    DbgPrint("VectorTest:++\n");

    ProcessParameters = RtlAllocateHeap(MyHeap, 0, 2048);
    ProcessParameters->MaximumLength = 2048;

    st = RtlVectorsToProcessParameters(
            Arguments,
            Variables,
            Parameters,
            ProcessParameters
            );

    DumpIt(ProcessParameters);

    DbgPrint("VectorTest:--\n");

    return TRUE;
}

NTSTATUS
main(
    IN ULONG argc,
    IN PCH argv[],
    IN PCH envp[],
    IN ULONG DebugParameter OPTIONAL
    )

{
    ULONG i;
    char c, *s;
    PCH *Arguments;
    PCH *Variables;
    PCH Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG+2 ];

    ULONG TestVector = 0;

    Arguments = argv;
    Variables = envp;
    Parameters[ RTL_USER_PROC_PARAMS_IMAGEFILE ] =
         "Full Path Specification of Image File goes here";

    Parameters[ RTL_USER_PROC_PARAMS_CMDLINE ] =
         "Complete Command Line goes here";

    Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG ] =
         "Debugging String goes here";

    Parameters[ RTL_USER_PROC_PARAMS_DEBUGFLAG+1 ] = NULL;

    MyHeap = RtlProcessHeap();


#if DBG
    DbgPrint( "Entering URTL User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }
#endif
    i = 1;
    if (argc > 1 ) {
        while (--argc) {
            s = *++argv;
            while ((c = *s++) != '\0') {
                switch (c) {

                case 'V':
                case 'v':
                    TestVector = i++;
                    break;
                default:
                    DbgPrint( "urtl: invalid test code - '%s'", *argv );
                    break;
                }
            }
        }
    }

    if ( TestVector ) {
        VectorTest(Arguments,Variables,Parameters);
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\test\utxcpt4.c ===
//  utxcpt4.c - user mode seh test #3.

#include <ntos.h>
//
// Define function prototypes.
//

VOID
bar (
    IN NTSTATUS Status,
    IN PULONG Counter
    );

VOID
eret (
    IN NTSTATUS Status,
    IN PULONG Counter
    );

VOID
foo (
    IN NTSTATUS Status
    );

VOID
fret (
    IN PULONG Counter
    );

BOOLEAN
Tkm (
    VOID
    );

//
// Define static storage.
//

PTESTFCN TestFunction = Tkm;

main()
{
    Tkm();
}

BOOLEAN
Tkm (
    )

{

    EXCEPTION_RECORD ExceptionRecord;
    LONG Counter;

    //
    // Announce start of exception test.
    //

    DbgPrint("Start of exception test\n");

    //
    // Initialize exception record.
    //

    ExceptionRecord.ExceptionCode = STATUS_INTEGER_OVERFLOW;
    ExceptionRecord.ExceptionFlags = 0;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.NumberParameters = 0;

    //
    // Simply try statement with a finally clause that is entered sequentially.
    //

    DbgPrint("    test1...");
    Counter = 0;
    try {
        Counter += 1;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 1;
        }
    }

    if (Counter != 2) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is never executed
    // because there is no exception raised in the try clause.
    //

    DbgPrint("    test2...");
    Counter = 0;
    try {
        Counter += 1;

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 1) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception handler that is never executed
    // because the exception expression continues execution.
    //

    DbgPrint("    test3...");
    Counter = 0;
    try {
        Counter -= 1;
        RtlRaiseException(&ExceptionRecord);

    } except (Counter) {
        Counter -= 1;
    }

    if (Counter != - 1) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is always executed.
    //

    DbgPrint("    test4...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    DbgPrint("    test5...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            RtlRaiseException(&ExceptionRecord);

        } finally {
            if (abnormal_termination() != FALSE) {
                Counter += 1;
            }
        }

    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }

    if (Counter != 3) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which raises an exception.
    //

    DbgPrint("    test6...");
    Counter = 0;
    try {
        Counter += 1;
        foo(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //

    DbgPrint("    test7...");
    Counter = 0;
    try {
        bar(STATUS_ACCESS_VIOLATION, (PULONG)&Counter);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter -= 1;
    }

    if (Counter != 98) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A try within an except
    //

    DbgPrint("    test8...");
    Counter = 0;
    try {
        foo(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
        try {
            foo(STATUS_SUCCESS);

        } except ((GetExceptionCode() == STATUS_SUCCESS) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            if (Counter != 1) {
                DbgPrint("failed...");

            } else {
                DbgPrint("succeeded...");
            }

            Counter += 1;
        }
    }

    if (Counter != 2) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally
    //

    DbgPrint("    test9...");
    Counter = 0;
    try {
        try {
            foo(STATUS_ACCESS_VIOLATION);

        } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            Counter += 1;
            goto t9;
        }

    } finally {
        Counter += 1;
    }

t9:;
    if (Counter != 2) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally
    //

    DbgPrint("    test10...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
	      goto t10;
        }

    } finally {
        Counter += 1;
    }

t10:;
    if (Counter != 3) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally into the outer finally clause.
    //

    DbgPrint("    test11...");
    Counter = 0;
    try {
        try {
            try {
                Counter += 1;
                foo(STATUS_INTEGER_OVERFLOW);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 1;
                goto t11;
            }

        } finally {
            Counter += 1;
        }
t11:;
    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally into the outer finally clause.
    //

    DbgPrint("    test12...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            goto t12;
        }
t12:;
    } finally {
        Counter += 1;
    }

    if (Counter != 3) {
        DbgPrint("failed\n");

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A return from an except clause
    //

    DbgPrint("    test13...");
    Counter = 0;
    try {
        Counter += 1;
        eret(STATUS_ACCESS_VIOLATION, (PULONG)&Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        DbgPrint("failed\n");
    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A return from a finally clause
    //

    DbgPrint("    test14...");
    Counter = 0;
    try {
        Counter += 1;
        fret((PULONG)&Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 5) {
        DbgPrint("failed\n");
    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Announce end of exception test.
    //

    DbgPrint("End of exception test\n");
    return TRUE;
}

VOID
fret(
    IN PULONG Counter
    )

{

    try {
        try {
            *Counter += 1;

        } finally {
            *Counter += 1;
            return;
        }
    } finally {
        *Counter += 1;
    }

    return;
}

VOID
eret(
    IN NTSTATUS Status,
    IN PULONG Counter
    )

{

    try {
        try {
            foo(Status);

        } except ((GetExceptionCode() == Status) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            *Counter += 1;
            return;
        }

    } finally {
        *Counter += 1;
    }

    return;
}

VOID
bar (
    IN NTSTATUS Status,
    IN PULONG Counter
    )
{

    try {
        foo(Status);

    } finally {
        if (abnormal_termination() != FALSE) {
            *Counter = 99;

        } else {
            *Counter = 100;
        }
    }

    return;
}

VOID
foo(
    IN NTSTATUS Status
    )

{

    //
    // Raise exception.
    //

    RtlRaiseStatus(Status);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\user\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

theap.c: ..\heap.c ..\heapdbg.c ..\heapdll.c

t.c: ..\handle.c ..\atom.c

!if defined(LINK_TIME_CODE_GENERATION)
$(O)\generr.obj: ..\generr.c
    $(C_COMPILER_NAME) ..\generr.c @<<
-Fo$(O)\generr.obj
$(EX_C_COMPILER_FLAGS:/GL=)
<<NOKEEP
!else 
$(O)\generr.obj: ..\generr.c
!endif

$(O)\error.h: $(O)\generr.obj
    generr $? $@

..\error.c: $(O)\error.h

$(O)\ldrreloc_rebase.w : ..\ldrreloc.c makefile.inc
   type << > $@
/**

$(COPYRIGHT_STRING)

Module Name:

    ldrreloc_rebase.c
    
Abstract:

    Extract the LdrProcessRelocationBlock code from ldrreloc.c so rebase can use it
    w/o duplication of effort.  This file is generated - don't edit by hand.
    
Revision History:

--*/

#ifndef IMAGE_REL_BASED_SECTION
#define IMAGE_REL_BASED_SECTION               6
#endif
#ifndef IMAGE_REL_BASED_REL32
#define IMAGE_REL_BASED_REL32                 7
#endif
#define RTL_PAGED_CODE() NOP_FUNCTION()

#define LdrProcessRelocationBlockLongLong xxLdrProcessRelocationBlock64

<<
   hextract -o $@ -bt begin_rebase end_rebase $**
   $(PUBLISH_CMD) {$@=$(PROJECT_INC_PATH)\ldrreloc_rebase.c}
   
!if $(386)
$(O)\$(TARGETNAME).lib : $(O)\xcptmisc.org

$(O)\xcptmisc.org : $(O)\xcptmisc.obj
   copy $** $@
   sxgen /verbose /in:$@ /out:$** ExceptionHandler@16 UnwindHandler@16
   touch $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\userlib\makefile.inc ===
SLIST_DEPENDS = ..\lookasid.c

########################################################################
# ntslist.h
#

$(O)\ntslist.h: $(SLIST_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntslist.h

Abstract:

    This file exposes the internal s-list functionality for projects that need
    to run on down-level platforms.

Revision History:

--*/

#ifndef _NTSLIST_
#define _NTSLIST_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -f2 -o $@ -lt ntslist -bt begin_ntslist end_ntslist $(SLIST_DEPENDS)
    type << >> $@

#ifdef __cplusplus
}
#endif

#endif /* _NTSLIST_ */
<<
    $(PUBLISH_CMD) {$@=$(PROJECT_INC_PATH)\ntslist.h}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\wow6432\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

theap.c: ..\heap.c ..\heapdbg.c ..\heapdll.c

t.c: ..\handle.c ..\atom.c

!if defined(LINK_TIME_CODE_GENERATION)
$(O)\generr.obj: ..\generr.c
	$(C_COMPILER_NAME) ..\generr.c @<<
-Fo$(O)\generr.obj
$(EX_C_COMPILER_FLAGS:/GL=)
<<NOKEEP
!else
$(O)\generr.obj: ..\generr.c
!endif

$(O)\error.h: $(O)\generr.obj
    generr $? $@

..\error.c: $(O)\error.h

!if $(386)
$(O)\$(TARGETNAME).lib : $(O)\xcptmisc.org

$(O)\xcptmisc.org : $(O)\xcptmisc.obj
   copy $** $@
   sxgen /verbose /in:$@ /out:$** ExceptionHandler@16 UnwindHandler@16
   touch $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\adt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adt.h

Abstract:

    Auditing - Defines, Fuction Prototypes and Macro Functions.
               These are public to the Security Component only.

Author:

    Scott Birrell       (ScottBi)       January 17, 1991

Environment:

Revision History:

--*/

#include <ntlsa.h>


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Auditing Routines visible to rest of Security Component outside Auditing //
// subcomponent.                                                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


BOOLEAN
SepAdtInitializePhase0();

BOOLEAN
SepAdtInitializePhase1();

VOID
SepAdtLogAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
SepAdtCopyToLsaSharedMemory(
    IN HANDLE LsaProcessHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *LsaBufferAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\accessck.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Accessck.c

Abstract:

    This Module implements the access check procedures.  Both NtAccessCheck
    and SeAccessCheck check to is if a user (denoted by an input token) can
    be granted the desired access rights to object protected by a security
    descriptor and an optional object owner.  Both procedures use a common
    local procedure to do the test.

Author:

    Robert Reichel  (RobertRe)    11-30-90

Environment:

    Kernel Mode

Revision History:

    Richard Ward     (RichardW)     14-Apr-92   Changed ACE_HEADER
--*/

#include "pch.h"

#pragma hdrstop

#include <sertlp.h>


//
//  Define the local macros and procedure for this module
//

#if DBG

extern BOOLEAN SepDumpSD;
extern BOOLEAN SepDumpToken;
BOOLEAN SepShowAccessFail;

#endif // DBG



VOID
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex
    );

typedef enum {
    UpdateRemaining,
    UpdateCurrentGranted,
    UpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;

VOID
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

NTSTATUS
SeAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList
    );

VOID
SepMaximumAccessCheck(
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    );

VOID
SepNormalAccessCheck(
    IN ACCESS_MASK Remaining,
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    );

BOOLEAN
SepSidInTokenEx (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce,
    IN BOOLEAN Restricted
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeCaptureObjectTypeList)
#pragma alloc_text(PAGE,SeFreeCapturedObjectTypeList)
#pragma alloc_text(PAGE,SepUpdateParentTypeList)
#pragma alloc_text(PAGE,SepObjectInTypeList)
#pragma alloc_text(PAGE,SepAddAccessTypeList)
#pragma alloc_text(PAGE,SepSidInToken)
#pragma alloc_text(PAGE,SepSidInTokenEx)
#pragma alloc_text(PAGE,SepAccessCheck)
#pragma alloc_text(PAGE,NtAccessCheck)
#pragma alloc_text(PAGE,NtAccessCheckByType)
#pragma alloc_text(PAGE,NtAccessCheckByTypeResultList)
#pragma alloc_text(PAGE,SeAccessCheckByType)
#pragma alloc_text(PAGE,SeFreePrivileges)
#pragma alloc_text(PAGE,SeAccessCheck)
#pragma alloc_text(PAGE,SePrivilegePolicyCheck)
#pragma alloc_text(PAGE,SepTokenIsOwner)
#pragma alloc_text(PAGE,SeFastTraverseCheck)
#pragma alloc_text(PAGE,SepMaximumAccessCheck)
#pragma alloc_text(PAGE,SepNormalAccessCheck)
#pragma alloc_text(PAGE,SeMaximumAuditMask)
#endif


NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
)
/*++

Routine Description:

    This routine probes and captures a copy of any object type list
    that might have been provided via the ObjectTypeList argument.

    The object type list is converted to the internal form that explicitly
    specifies the hierarchical relationship between the entries.

    The object typs list is validated to ensure a valid hierarchical
    relationship is represented.

Arguments:

    ObjectTypeList - The object type list from which the type list
        information is to be retrieved.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    RequestorMode - Indicates the processor mode by which the access
        is being requested.

    CapturedObjectTypeList - Receives the captured type list which
        must be freed using SeFreeCapturedObjectTypeList().

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    PIOBJECT_TYPE_LIST LocalTypeList = NULL;

    ULONG Levels[ACCESS_MAX_LEVEL+1];

    PAGED_CODE();

    //
    //  Set default return
    //

    *CapturedObjectTypeList = NULL;

    if (RequestorMode != UserMode) {
        return STATUS_NOT_IMPLEMENTED;
    }

    try {

        if ( ObjectTypeListLength == 0 ) {

            // Drop through

        } else if ( !ARGUMENT_PRESENT(ObjectTypeList) ) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            if ( !IsValidElementCount( ObjectTypeListLength, IOBJECT_TYPE_LIST ) )
            {
                Status = STATUS_INVALID_PARAMETER ;

                //
                // No more to do, get out of the try statement:
                //

                leave ;
            }

            ProbeForRead( ObjectTypeList,
                          sizeof(OBJECT_TYPE_LIST) * ObjectTypeListLength,
                          sizeof(ULONG)
                          );

            //
            // Allocate a buffer to copy into.
            //

            LocalTypeList = ExAllocatePoolWithTag( PagedPool, sizeof(IOBJECT_TYPE_LIST) * ObjectTypeListLength, 'tOeS' );

            if ( LocalTypeList == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Copy the callers structure to the local structure.
            //

            } else {
                GUID * CapturedObjectType;
                for ( i=0; i<ObjectTypeListLength; i++ ) {
                    USHORT CurrentLevel;

                    //
                    // Limit ourselves
                    //
                    CurrentLevel = ObjectTypeList[i].Level;
                    if ( CurrentLevel > ACCESS_MAX_LEVEL ) {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // Copy data the caller passed in
                    //
                    LocalTypeList[i].Level = CurrentLevel;
                    LocalTypeList[i].Flags = 0;
                    CapturedObjectType = ObjectTypeList[i].ObjectType;
                    ProbeForReadSmallStructure(
                        CapturedObjectType,
                        sizeof(GUID),
                        sizeof(ULONG)
                        );
                    LocalTypeList[i].ObjectType = *CapturedObjectType;
                    LocalTypeList[i].Remaining = 0;
                    LocalTypeList[i].CurrentGranted = 0;
                    LocalTypeList[i].CurrentDenied = 0;

                    //
                    // Ensure that the level number is consistent with the
                    //  level number of the previous entry.
                    //

                    if ( i == 0 ) {
                        if ( CurrentLevel != 0 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                    } else {

                        //
                        // The previous entry is either:
                        //  my immediate parent,
                        //  my sibling, or
                        //  the child (or grandchild, etc.) of my sibling.
                        //
                        if ( CurrentLevel > LocalTypeList[i-1].Level + 1 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                        //
                        // Don't support two roots.
                        //
                        if ( CurrentLevel == 0 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                    }

                    //
                    // If the above rules are maintained,
                    //  then my parent object is the last object seen that
                    //  has a level one less than mine.
                    //

                    if ( CurrentLevel == 0 ) {
                        LocalTypeList[i].ParentIndex = -1;
                    } else {
                        LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
                    }

                    //
                    // Save this obect as the last object seen at this level.
                    //

                    Levels[CurrentLevel] = i;

                }

            }

        } // end_if

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

    } // end_try


    if ( NT_SUCCESS( Status ) ) {

        *CapturedObjectTypeList = LocalTypeList;

    } else {

        //
        // If we captured any proxy data, we need to free it now.
        //

        if ( LocalTypeList != NULL ) {
            ExFreePool( LocalTypeList );
        }
    }

    return Status;
}


VOID
SeFreeCapturedObjectTypeList(
    IN PVOID ObjectTypeList
    )

/*++

Routine Description:

    This routine frees the data associated with a captured ObjectTypeList
    structure.

Arguments:

    ObjectTypeList - Points to a captured object type list structure.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( ObjectTypeList != NULL ) {
        ExFreePool( ObjectTypeList );
    }

    return;
}




BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    OUT PULONG ReturnedIndex
)
/*++

Routine Description:

    This routine searches an ObjectTypeList to determine if the specified
    object type is in the list.

Arguments:

    ObjectType - Object Type to search for.

    ObjectTypeList - The object type list to search.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    ReturnedIndex - Index to the element ObjectType was found in


Return Value:

    TRUE: ObjectType was found in list.
    FALSE: ObjectType was not found in list.

--*/

{
    ULONG Index;
    GUID *LocalObjectType;

    PAGED_CODE();

    ASSERT( sizeof(GUID) == sizeof(ULONG) * 4 );
    for ( Index=0; Index<ObjectTypeListLength; Index++ ) {

        LocalObjectType = &ObjectTypeList[Index].ObjectType;

        if  ( RtlpIsEqualGuid( ObjectType, LocalObjectType ) ) {
            *ReturnedIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex
)
/*++

Routine Description:

    Update the Access fields of the parent object of the specified object.


        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.


--*/

{
    ULONG Index;
    ULONG ParentIndex;
    ULONG Level;
    ACCESS_MASK NewRemaining = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;
    ACCESS_MASK NewCurrentDenied = 0;

    PAGED_CODE();

    //
    // If the target node is at the root,
    //  we're all done.
    //

    if ( ObjectTypeList[StartIndex].ParentIndex == -1 ) {
        return;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for ( Index=ParentIndex+1; Index<ObjectTypeListLength; Index++ ) {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level ) {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if ( ObjectTypeList[Index].Level != Level ) {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ( NewRemaining == ObjectTypeList[ParentIndex].Remaining &&
         NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted &&
        NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied ) {
        return;
    }


    //
    // Change the parent.
    //

    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    SepUpdateParentTypeList( ObjectTypeList,
                             ObjectTypeListLength,
                             ParentIndex );
}


VOID
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
)
/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its decendents

    FieldToUpdate - Indicate which fields to update in object type list

Return Value:

    None.

--*/

{
    ULONG Index;
    ACCESS_MASK OldRemaining;
    ACCESS_MASK OldCurrentGranted;
    ACCESS_MASK OldCurrentDenied;
    BOOLEAN AvoidParent = FALSE;

    PAGED_CODE();

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits,
    //  early out.
    //

    switch (FieldToUpdate ) {
    case UpdateRemaining:

        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if ( OldRemaining == ObjectTypeList[StartIndex].Remaining ) {
            return;
        }
        break;

    case UpdateCurrentGranted:

        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if ( OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted ) {
            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //
            AvoidParent = TRUE;
        }
        break;

    case UpdateCurrentDenied:

        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if ( OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied ) {
            return;
        }
        break;

    default:
        return;
    }


    //
    // Go update parent of the target.
    //

    if ( !AvoidParent ) {
        SepUpdateParentTypeList( ObjectTypeList,
                                 ObjectTypeListLength,
                                 StartIndex );
    }

    //
    // Loop handling all children of the target.
    //

    for ( Index=StartIndex+1; Index<ObjectTypeListLength; Index++ ) {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level ) {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate) {
        case UpdateRemaining:

            ObjectTypeList[Index].Remaining &= ~AccessMask;
            break;

        case UpdateCurrentGranted:

            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;
            break;

        case UpdateCurrentDenied:

            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;
            break;

        default:
            return;
        }
    }
}

BOOLEAN
SepSidInToken (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce
    )

/*++

Routine Description:

    Checks to see if a given SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    Token - Pointer to the token to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{

    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PTOKEN Token;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;
    USHORT TargetShort;

    C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
    C_ASSERT (sizeof (((SID *)Sid)->Revision) + sizeof (((SID *)Sid)->SubAuthorityCount) == sizeof (USHORT));


    PAGED_CODE();

#if DBG

    SepDumpTokenInfo(AToken);

#endif

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //
    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // To speed up processing we compare the sub authority count and the revision at the same time.
    //
    TargetShort = *(USHORT *)&((PISID)Sid)->Revision;

    //
    // Get address of user/group array and number of user/groups.
    //

    Token = (PTOKEN)AToken;
    TokenSid = Token->UserAndGroups;
    UserAndGroupCount = Token->UserAndGroupCount;

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < UserAndGroupCount ; i += 1) {
        MatchSid = (PISID)TokenSid->Sid;

        //
        // If revision and sub authority count matches, then compare the SIDs
        // for equality.
        //

        if (*(USHORT *) &MatchSid->Revision == TargetShort) {
            if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                //
                // If this is the first one in the list, then it is the User,
                // and return success immediately.
                //
                // If this is not the first one, then it represents a group,
                // and we must make sure the group is currently enabled before
                // we can say that the group is "in" the token.
                //

                if ((i == 0) || (TokenSid->Attributes & SE_GROUP_ENABLED) ||
                    (DenyAce && (TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY))) {
                    return TRUE;

                } else {
                    return FALSE;
                }
            }
        }

        TokenSid += 1;
    }

    return FALSE;
}

BOOLEAN
SepSidInTokenEx (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce,
    IN BOOLEAN Restricted
    )

/*++

Routine Description:

    Checks to see if a given restricted SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    Token - Pointer to the token to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

    DenyAce - The ACE being evaluated is a DENY or ACCESS DENIED ace

    Restricted - The access check being performed uses the restricted sids.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{

    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PTOKEN Token;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;
    USHORT TargetShort;

    C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
    C_ASSERT (sizeof (((SID *)Sid)->Revision) + sizeof (((SID *)Sid)->SubAuthorityCount) == sizeof (USHORT));

    PAGED_CODE();

#if DBG

    SepDumpTokenInfo(AToken);

#endif

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //
    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // To speed up processing we compare the sub authority count and the revision at the same time.
    //
    TargetShort = *(USHORT *)&((PISID)Sid)->Revision;

    //
    // Get address of user/group array and number of user/groups.
    //

    Token = (PTOKEN)AToken;
    if (Restricted) {
        TokenSid = Token->RestrictedSids;
        UserAndGroupCount = Token->RestrictedSidCount;
    } else {
        TokenSid = Token->UserAndGroups;
        UserAndGroupCount = Token->UserAndGroupCount;
    }

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0; i < UserAndGroupCount ; i += 1) {
        MatchSid = (PISID)TokenSid->Sid;

        //
        // If the SID revision and length matches, then compare the SIDs
        // for equality.
        //

        if (*(USHORT *) &MatchSid->Revision == TargetShort) {
            if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                //
                // If this is the first one in the list and not deny-only it
                // is not a restricted token then it is the User, and return
                // success immediately.
                //
                // If this is not the first one, then it represents a group,
                // and we must make sure the group is currently enabled before
                // we can say that the group is "in" the token.
                //

                if ((!Restricted && (i == 0) && ((TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY) == 0)) ||
                    (TokenSid->Attributes & SE_GROUP_ENABLED) ||
                    (DenyAce && (TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY))) {
                    return TRUE;

                } else {
                    return FALSE;
                }

            }
        }

        TokenSid += 1;
    }

    return FALSE;
}

VOID
SepMaximumAccessCheck(
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    )
/*++

Routine Description:

    Does an access check for maximum allowed or with a result list. If the
    Restricted flag is set, it is done for a restricted token. The sids
    checked are the restricted sids, not the users and groups. The current
    granted access is stored in the Remaining access and then another access
    check is run.

Arguments:

    EToken - Effective token of caller.

    PrimaryToken - Process token of calling process

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

Return Value:

    none

--*/

{
    ULONG i,j;
    PVOID Ace;
    ULONG AceCount;
    ULONG Index;
    ULONG ResultListIndex;

    //
    // The remaining bits are the granted bits for each object type on a
    // restricted check
    //

    if ( Restricted ) {
        for ( j=0; j<LocalTypeListLength; j++ ) {
            LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
            LocalTypeList[j].CurrentGranted = 0;
        }
    }


    AceCount = Dacl->AceCount;

    //
    // granted == NUL
    // denied == NUL
    //
    //  for each ACE
    //
    //      if grant
    //          for each SID
    //              if SID match, then add all that is not denied to grant mask
    //
    //      if deny
    //          for each SID
    //              if SID match, then add all that is not granted to deny mask
    //

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if (SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart, FALSE, Restricted )) {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) {
                        LocalTypeList->CurrentGranted |=
                           (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } else {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted );
                    }
                 }


             //
             // Handle an object specific Access Allowed ACE
             //
             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {
                 GUID *ObjectTypeInAce;

                 //
                 // If no object type is in the ACE,
                 //  treat this as an ACCESS_ALLOWED_ACE.
                 //

                 ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                 if ( ObjectTypeInAce == NULL ) {

                     if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                         // Optimize 'normal' case
                         if ( LocalTypeListLength == 1 ) {
                             LocalTypeList->CurrentGranted |=
                                (((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                         } else {
                             SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,    // Length of list
                                 0,                      // Element to update
                                 ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                 UpdateCurrentGranted );
                         }
                     }

                 //
                 // If no object type list was passed,
                 //  don't grant access to anyone.
                 //

                 } else if ( ObjectTypeListLength == 0 ) {

                     // Drop through


                //
                // If an object type is in the ACE,
                //   Find it in the LocalTypeList before using the ACE.
                //
                } else {

                     if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                         if ( SepObjectInTypeList( ObjectTypeInAce,
                                                   LocalTypeList,
                                                   LocalTypeListLength,
                                                   &Index ) ) {
                             SepAddAccessTypeList(
                                  LocalTypeList,          // List to modify
                                  LocalTypeListLength,   // Length of list
                                  Index,                  // Element already updated
                                  ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                  UpdateCurrentGranted );
                         }
                     }
                }

             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                 //
                 //  If we're impersonating, EToken is set to the Client, and if we're not,
                 //  EToken is set to the Primary.  According to the DSA architecture, if
                 //  we're asked to evaluate a compound ACE and we're not impersonating,
                 //  pretend we are impersonating ourselves.  So we can just use the EToken
                 //  for the client token, since it's already set to the right thing.
                 //


                 if ( SepSidInTokenEx(EToken, PrincipalSelfSid, RtlCompoundAceClientSid( Ace ), FALSE, Restricted) &&
                      SepSidInTokenEx(PrimaryToken, NULL, RtlCompoundAceServerSid( Ace ), FALSE, FALSE)
                    ) {

                     //
                     // Only grant access types from this mask that have
                     // not already been denied
                     //

                     // Optimize 'normal' case
                     if ( LocalTypeListLength == 1 ) {
                         LocalTypeList->CurrentGranted |=
                            (((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                     } else {
                        //
                        // The zeroeth object type represents the object itself.
                        //
                        SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                             UpdateCurrentGranted );
                     }

                 }


             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

                 if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart, TRUE, Restricted )) {

                      //
                      // Only deny access types from this mask that have
                      // not already been granted
                      //

                     // Optimize 'normal' case
                     if ( LocalTypeListLength == 1 ) {
                         LocalTypeList->CurrentDenied |=
                             (((PACCESS_DENIED_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                     } else {
                         //
                         // The zeroeth object type represents the object itself.
                         //
                         SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PACCESS_DENIED_ACE)Ace)->Mask, // Access denied
                             UpdateCurrentDenied );
                    }
                 }


             //
             // Handle an object specific Access Denied ACE
             //
             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) {

                 if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), TRUE, Restricted ) ) {
                     GUID *ObjectTypeInAce;

                     //
                     // If there is no object type in the ACE,
                     //  or if the caller didn't specify an object type list,
                     //  apply this deny ACE to the entire object.
                     //

                     ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                     if ( ObjectTypeInAce == NULL ) {

                         if ( LocalTypeListLength == 1 ) {
                             LocalTypeList->CurrentDenied |=
                                 (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                         } else {

                             //
                             // The zeroeth object type represents the object itself.
                             //

                             SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,    // Length of list
                                 0,
                                 ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                 UpdateCurrentDenied );
                         }
                     //
                     // If no object type list was passed,
                     //  don't grant access to anyone.
                     //

                     } else if ( ObjectTypeListLength == 0 ) {

                         LocalTypeList->CurrentDenied |=
                             (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);


                     //
                     // If an object type is in the ACE,
                     //   Find it in the LocalTypeList before using the ACE.
                     //

                     } else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                          LocalTypeList,
                                                          LocalTypeListLength,
                                                          &Index ) ) {

                            SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                Index,                  // Element to update
                                ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                UpdateCurrentDenied );

                    }
                }
            }
        }
    }
}

VOID
SepNormalAccessCheck(
    IN ACCESS_MASK Remaining,
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    )
/*++

Routine Description:

    Does an access check when the caller isn't asking for MAXIMUM_ALLOWED or
    a type result list. If the Restricted flag is set, the sids checked are
    the restricted sids, not the users and groups. The Remaining field is
    reset to the original remaining value and then another access check is run.

Arguments:

    Remaining - Remaining access desired after special checks

    EToken - Effective token of caller.

    PrimaryToken - Process token of calling process

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

    Restricted - Use the restricted sids for the access check.

Return Value:

    none

--*/
{
    ULONG i,j;
    PVOID Ace;
    ULONG AceCount;
    ULONG Index;

    AceCount = Dacl->AceCount;

    //
    // The remaining bits are "remaining" at all levels
    //

    for ( j=0; j<LocalTypeListLength; j++ ) {
        LocalTypeList[j].Remaining = Remaining;
    }

    //
    // Process the DACL handling individual access bits.
    //

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          ( i < AceCount ) && ( LocalTypeList->Remaining != 0 )  ;
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            //
            // Handle an Access Allowed ACE
            //

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

               if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE   )Ace)->SidStart, FALSE, Restricted ) ) {

                   // Optimize 'normal' case
                   if ( LocalTypeListLength == 1 ) {
                       LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                   } else {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateRemaining );
                   }

               }


            //
            // Handle an object specific Access Allowed ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {
                GUID *ObjectTypeInAce;

                //
                // If no object type is in the ACE,
                //  treat this as an ACCESS_ALLOWED_ACE.
                //

                ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                if ( ObjectTypeInAce == NULL ) {

                    if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                       // Optimize 'normal' case
                       if ( LocalTypeListLength == 1 ) {
                           LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                       } else {
                           SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                0,                      // Element to update
                                ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                UpdateRemaining );
                       }
                    }

                //
                // If no object type list was passed,
                //  don't grant access to anyone.
                //

                } else if ( ObjectTypeListLength == 0 ) {

                    // Drop through


               //
               // If an object type is in the ACE,
               //   Find it in the LocalTypeList before using the ACE.
               //
               } else {

                    if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                        if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {
                            SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,   // Length of list
                                 Index,                  // Element already updated
                                 ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                 UpdateRemaining );
                        }
                    }
               }


            //
            // Handle a compound Access Allowed ACE
            //

            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                //
                // See comment in MAXIMUM_ALLOWED case as to why we can use EToken here
                // for the client.
                //

                if ( SepSidInTokenEx(EToken, PrincipalSelfSid, RtlCompoundAceClientSid( Ace ), FALSE, Restricted) &&
                     SepSidInTokenEx(PrimaryToken, NULL, RtlCompoundAceServerSid( Ace ), FALSE, Restricted) ) {

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) {
                        LocalTypeList->Remaining &= ~((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask;
                    } else {
                        SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                             UpdateRemaining );
                    }
                }



            //
            // Handle an Access Denied ACE
            //

            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

                if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart, TRUE, Restricted ) ) {

                    //
                    // The zeroeth element represents the object itself.
                    //  Just check that element.
                    //
                    if (LocalTypeList->Remaining & ((PACCESS_DENIED_ACE)Ace)->Mask) {

                        break;
                    }
                }


            //
            // Handle an object specific Access Denied ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) {

                if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), TRUE, Restricted ) ) {
                    GUID *ObjectTypeInAce;

                    //
                    // If there is no object type in the ACE,
                    //  or if the caller didn't specify an object type list,
                    //  apply this deny ACE to the entire object.
                    //

                    ObjectTypeInAce = RtlObjectAceObjectType(Ace);
                    if ( ObjectTypeInAce == NULL ||
                         ObjectTypeListLength == 0 ) {

                        //
                        // The zeroeth element represents the object itself.
                        //  Just check that element.
                        //
                        if (LocalTypeList->Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    //
                    // Otherwise apply the deny ACE to the object specified
                    //  in the ACE.
                    //

                    } else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {

                        if (LocalTypeList[Index].Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    }
               }
            }

        }
    }
}


VOID
SeMaximumAuditMask(
    IN PACL Sacl,
    IN ACCESS_MASK GrantedAccess,
    IN PACCESS_TOKEN Token,
    OUT PACCESS_MASK pAuditMask
    )
/*++

Routine Description:

    This routine takes the passed security descriptor and applies the
    "MAXIMUM_ALLOWED" algorithm to the SACL contained in the security
    descriptor if one exists.  This mask represents all the success audits
    that can occur from the passed subject context accessing the passed
    security descriptor.

    The code walks the SACL and for each SYSTEM_AUDIT_ACE found that
    matches the passed subject context, keeps a running total of the
    access bits in the ACE.  The resulting mask is then masked by the
    passed GrantedAccess mask, since we're only interested in the
    bits that the object is actually being opened for.

Arguments:

    Sacl - The Sacl to be examined.

    GrantedAccess - The access that has been granted to the object.

    Token - Supplies to effective token for the access attempt.

    pAuditMask - Returns the mask of bits to be audited (if any).

Return Value:

    None


--*/
{
    USHORT AceCount        = 0;
    PACE_HEADER Ace        = NULL;
    ACCESS_MASK AccessMask = (ACCESS_MASK)0;
    UCHAR AceFlags         = 0;

    USHORT i;

    //
    // Initialize OUT parameters
    //

    *pAuditMask = (ACCESS_MASK)0;

    //
    // Determine if there is an SACL in the security descriptor.
    // If not, nothing to do.
    //

    if (0 == (AceCount = Sacl->AceCount)) {
        return;
    }

    //
    // Iterate through the ACEs on the Sacl until either we reach
    // the end or discover that we have to take all possible actions,
    // in which case it doesn't pay to look any further
    //

    for ( i = 0, Ace = FirstAce( Sacl ) ;
          (i < AceCount) ;
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == SYSTEM_AUDIT_ACE_TYPE) ) {

                AccessMask = ((PSYSTEM_AUDIT_ACE)Ace)->Mask;
                AceFlags   = ((PACE_HEADER)Ace)->AceFlags;

                if ((AccessMask & GrantedAccess) && (AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)) {

                    if ( SepSidInToken( (PACCESS_TOKEN)Token, NULL, &((PSYSTEM_AUDIT_ACE)Ace)->SidStart, FALSE ) ) {

                        *pAuditMask |= (AccessMask & GrantedAccess);
                    }
                }
            }
        }
    }
}



BOOLEAN
SepAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN PTOKEN PrimaryToken,
    IN PTOKEN ClientToken OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList,
    OUT PBOOLEAN ReturnSomeAccessGranted,
    OUT PBOOLEAN ReturnSomeAccessDenied
    )

/*++

Routine Description:

    Worker routine for SeAccessCheck and NtAccessCheck.  We actually do the
    access checking here.

    Whether or not we actually evaluate the DACL is based on the following
    interaction between the SE_DACL_PRESENT bit in the security descriptor
    and the value of the DACL pointer itself.


                          SE_DACL_PRESENT

                        SET          CLEAR

                   +-------------+-------------+
                   |             |             |
             NULL  |    GRANT    |    GRANT    |
                   |     ALL     |     ALL     |
     DACL          |             |             |
     Pointer       +-------------+-------------+
                   |             |             |
            !NULL  |  EVALUATE   |    GRANT    |
                   |    ACL      |     ALL     |
                   |             |             |
                   +-------------+-------------+

Arguments:

    SecurityDescriptor - Pointer to the security descriptor from the object
        being accessed.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    Token - Pointer to user's token object.

    TokenLocked - Boolean describing whether or not there is a read lock
        on the token.

    DesiredAccess - Access mask describing the user's desired access to the
        object.  This mask is assumed not to contain generic access types.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    PreviouslyGrantedAccess - Access mask indicating any access' that have
        already been granted by higher level routines

    PrivilgedAccessMask - Mask describing access types that may not be
        granted without a privilege.

    GrantedAccess - Returns an access mask describing all granted access',
        or NULL.

    Privileges - Optionally supplies a pointer in which will be returned
        any privileges that were used for the access.  If this is null,
        it will be assumed that privilege checks have been done already.

    AccessStatus - Returns STATUS_SUCCESS or other error code to be
        propogated back to the caller

    ReturnResultList - If true, GrantedAccess and AccessStatus is actually
        an array of entries ObjectTypeListLength elements long.

    ReturnSomeAccessGranted - Returns a value of TRUE to indicate that some access'
        were granted, FALSE otherwise.

    ReturnSomeAccessDenied - Returns a value of FALSE if some of the requested
        access was not granted.  This will alway be an inverse of SomeAccessGranted
        unless ReturnResultList is TRUE.  In that case,

Return Value:

    A value of TRUE indicates that some access' were granted, FALSE
    otherwise.

--*/
{
    NTSTATUS Status;
    ACCESS_MASK Remaining;
    BOOLEAN RetVal = TRUE;

    PACL Dacl;

    PVOID Ace;
    ULONG AceCount;

    ULONG i;
    ULONG j;
    ULONG Index;
    ULONG PrivilegeCount = 0;
    BOOLEAN Success = FALSE;
    BOOLEAN SystemSecurity = FALSE;
    BOOLEAN WriteOwner = FALSE;
    PTOKEN EToken;

    IOBJECT_TYPE_LIST FixedTypeList;
    PIOBJECT_TYPE_LIST LocalTypeList;
    ULONG LocalTypeListLength;
    ULONG ResultListIndex;

    PAGED_CODE();

#if DBG

    SepDumpSecurityDescriptor(
        SecurityDescriptor,
        "Input to SeAccessCheck\n"
        );

    if (ARGUMENT_PRESENT( ClientToken )) {
        SepDumpTokenInfo( ClientToken );
    }

    SepDumpTokenInfo( PrimaryToken );

#endif


    EToken = ARGUMENT_PRESENT( ClientToken ) ? ClientToken : PrimaryToken;

    //
    // Assert that there are no generic accesses in the DesiredAccess
    //

    SeAssertMappedCanonicalAccess( DesiredAccess );

    Remaining = DesiredAccess;


    //
    // Check for ACCESS_SYSTEM_SECURITY here,
    // fail if he's asking for it and doesn't have
    // the privilege.
    //

    if ( Remaining & ACCESS_SYSTEM_SECURITY ) {

        //
        // Bugcheck if we weren't given a pointer to return privileges
        // into.  Our caller was supposed to have taken care of this
        // in that case.
        //

        ASSERT( ARGUMENT_PRESENT( Privileges ));

        Success = SepSinglePrivilegeCheck (
                    SeSecurityPrivilege,
                    EToken,
                    PreviousMode
                    );

        if (!Success) {
            PreviouslyGrantedAccess = 0;
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto ReturnOneStatus;
        }

        //
        // Success, remove ACCESS_SYSTEM_SECURITY from remaining, add it
        // to PreviouslyGrantedAccess
        //

        Remaining &= ~ACCESS_SYSTEM_SECURITY;
        PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;

        PrivilegeCount++;
        SystemSecurity = TRUE;

        if ( Remaining == 0 ) {
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;
        }

    }


    //
    // Get pointer to client SID's
    //

    Dacl = RtlpDaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor );

    //
    //  If the SE_DACL_PRESENT bit is not set, the object has no
    //  security, so all accesses are granted.  If he's asking for
    //  MAXIMUM_ALLOWED, return the GENERIC_ALL field from the generic
    //  mapping.
    //
    //  Also grant all access if the Dacl is NULL.
    //

    if ( !RtlpAreControlBitsSet(
             (PISECURITY_DESCRIPTOR)SecurityDescriptor,
             SE_DACL_PRESENT) || (Dacl == NULL)) {


        //
        // Restricted tokens treat a NULL dacl the same as a DACL with no
        // ACEs.
        //
#ifdef SECURE_NULL_DACLS
        if (SeTokenIsRestricted( EToken )) {
            //
            // We know that Remaining != 0 here, because we
            // know it was non-zero coming into this routine,
            // and we've checked it against 0 every time we've
            // cleared a bit.
            //

            ASSERT( Remaining != 0 );

            //
            // There are ungranted accesses.  Since there is
            // nothing in the DACL, they will not be granted.
            // If, however, the only ungranted access at this
            // point is MAXIMUM_ALLOWED, and something has been
            // granted in the PreviouslyGranted mask, return
            // what has been granted.
            //

            if ( (Remaining == MAXIMUM_ALLOWED) && (PreviouslyGrantedAccess != (ACCESS_MASK)0) ) {
                Status = STATUS_SUCCESS;
                goto ReturnOneStatus;

            } else {
                PreviouslyGrantedAccess = 0;
                Status = STATUS_ACCESS_DENIED;
                goto ReturnOneStatus;
            }
        }
#endif //SECURE_NULL_DACLS
        if (DesiredAccess & MAXIMUM_ALLOWED) {

            //
            // Give him:
            //   GenericAll
            //   Anything else he asked for
            //

            PreviouslyGrantedAccess =
                GenericMapping->GenericAll |
                (DesiredAccess | PreviouslyGrantedAccess) & ~MAXIMUM_ALLOWED;

        } else {

            PreviouslyGrantedAccess |= DesiredAccess;
        }

        Status = STATUS_SUCCESS;
        goto ReturnOneStatus;
    }

    //
    // There is security on this object.  Check to see
    // if he's asking for WRITE_OWNER, and perform the
    // privilege check if so.
    //

    if ( (Remaining & WRITE_OWNER) && ARGUMENT_PRESENT( Privileges ) ) {

        Success = SepSinglePrivilegeCheck (
                    SeTakeOwnershipPrivilege,
                    EToken,
                    PreviousMode
                    );

        if (Success) {

            //
            // Success, remove WRITE_OWNER from remaining, add it
            // to PreviouslyGrantedAccess
            //

            Remaining &= ~WRITE_OWNER;
            PreviouslyGrantedAccess |= WRITE_OWNER;

            PrivilegeCount++;
            WriteOwner = TRUE;

            if ( Remaining == 0 ) {
                Status = STATUS_SUCCESS;
                goto ReturnOneStatus;
            }
        }
    }


    //
    // If the DACL is empty,
    // deny all access immediately.
    //

    if ((AceCount = Dacl->AceCount) == 0) {

        //
        // We know that Remaining != 0 here, because we
        // know it was non-zero coming into this routine,
        // and we've checked it against 0 every time we've
        // cleared a bit.
        //

        ASSERT( Remaining != 0 );

        //
        // There are ungranted accesses.  Since there is
        // nothing in the DACL, they will not be granted.
        // If, however, the only ungranted access at this
        // point is MAXIMUM_ALLOWED, and something has been
        // granted in the PreviouslyGranted mask, return
        // what has been granted.
        //

        if ( (Remaining == MAXIMUM_ALLOWED) && (PreviouslyGrantedAccess != (ACCESS_MASK)0) ) {
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;

        } else {
            PreviouslyGrantedAccess = 0;
            Status = STATUS_ACCESS_DENIED;
            goto ReturnOneStatus;
        }
    }

    //
    // Fake out a top level ObjectType list if none is passed by the caller.
    //

    if ( ObjectTypeListLength == 0 ) {
        LocalTypeList = &FixedTypeList;
        LocalTypeListLength = 1;
        RtlZeroMemory( &FixedTypeList, sizeof(FixedTypeList) );
        FixedTypeList.ParentIndex = -1;
    } else {
        LocalTypeList = ObjectTypeList;
        LocalTypeListLength = ObjectTypeListLength;
    }

    //
    // If the caller wants the MAXIMUM_ALLOWED or the caller wants the
    //  results on all objects and subobjects, use a slower algorithm
    //  that traverses all the ACEs.
    //

    if ( (DesiredAccess & MAXIMUM_ALLOWED) != 0 ||
         ReturnResultList ) {

        //
        // Do the normal maximum-allowed access check
        //

        SepMaximumAccessCheck(
            EToken,
            PrimaryToken,
            Dacl,
            PrincipalSelfSid,
            LocalTypeListLength,
            LocalTypeList,
            ObjectTypeListLength,
            FALSE
            );

        //
        // If this is a restricted token, do the additional access check
        //

        if (SeTokenIsRestricted( EToken ) ) {
            SepMaximumAccessCheck(
                EToken,
                PrimaryToken,
                Dacl,
                PrincipalSelfSid,
                LocalTypeListLength,
                LocalTypeList,
                ObjectTypeListLength,
                TRUE
                );
        }


        //
        // If the caller wants to know the individual results of each sub-object,
        //  sub-object,
        //  break it down for him.
        //

        if ( ReturnResultList ) {
            ACCESS_MASK GrantedAccessMask;
            ACCESS_MASK RequiredAccessMask;
            BOOLEAN SomeAccessGranted = FALSE;
            BOOLEAN SomeAccessDenied = FALSE;

            //
            // Compute mask of Granted access bits to tell the caller about.
            //  If he asked for MAXIMUM_ALLOWED,
            //      tell him everything,
            //  otherwise
            //      tell him what he asked about.
            //

            if (DesiredAccess & MAXIMUM_ALLOWED) {
                GrantedAccessMask = (ACCESS_MASK) ~MAXIMUM_ALLOWED;
                RequiredAccessMask = (DesiredAccess | PreviouslyGrantedAccess) & ~MAXIMUM_ALLOWED;
            } else {
                GrantedAccessMask = DesiredAccess | PreviouslyGrantedAccess;
                RequiredAccessMask = DesiredAccess | PreviouslyGrantedAccess;
            }




            //
            // Loop computing the access granted to each object and sub-object.
            //
            for ( ResultListIndex=0;
                  ResultListIndex<LocalTypeListLength;
                  ResultListIndex++ ) {

                //
                // Return the subset of the access granted that the caller
                //  expressed interest in.
                //

                GrantedAccess[ResultListIndex] =
                    (LocalTypeList[ResultListIndex].CurrentGranted |
                     PreviouslyGrantedAccess ) &
                    GrantedAccessMask;

                //
                // If absolutely no access was granted,
                //  indicate so.
                //
                if ( GrantedAccess[ResultListIndex] == 0 ) {
                    AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                    SomeAccessDenied = TRUE;
                } else {

                    //
                    // If some requested access is still missing,
                    //  the bottom line is that access is denied.
                    //
                    // Note, that ByTypeResultList actually returns the
                    // partially granted access mask even though the caller
                    // really has no access to the object.
                    //

                    if  ( ((~GrantedAccess[ResultListIndex]) & RequiredAccessMask ) != 0 ) {
                        AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                        SomeAccessDenied = TRUE;
                    } else {
                        AccessStatus[ResultListIndex] = STATUS_SUCCESS;
                        SomeAccessGranted = TRUE;
                    }
                }
            }

            if ( SomeAccessGranted && PrivilegeCount != 0 ) {

                SepAssemblePrivileges(
                    PrivilegeCount,
                    SystemSecurity,
                    WriteOwner,
                    Privileges
                    );

                if ( ( Privileges != NULL ) && ( *Privileges == NULL ) ) {

                    RetVal = FALSE;
                    SomeAccessGranted = FALSE;
                    SomeAccessDenied = TRUE;

                    for ( ResultListIndex=0;
                          ResultListIndex<LocalTypeListLength;
                          ResultListIndex++ ) {

                        AccessStatus[ResultListIndex] = STATUS_NO_MEMORY;
                        GrantedAccess[ResultListIndex] = 0;
                    }

                }
            }

            if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
                *ReturnSomeAccessGranted = SomeAccessGranted;
            }
            if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
                *ReturnSomeAccessDenied = SomeAccessDenied;
            }

            return RetVal;

        //
        // If the caller is only interested in the access to the object itself,
        //  just summarize.
        //

        } else {

            //
            // Turn off the MAXIMUM_ALLOWED bit and whatever we found that
            // he was granted.  If the user passed in extra bits in addition
            // to MAXIMUM_ALLOWED, make sure that he was granted those access
            // types.  If not, he didn't get what he wanted, so return failure.
            //

            Remaining &= ~(MAXIMUM_ALLOWED | LocalTypeList->CurrentGranted);

            if (Remaining != 0) {

                Status = STATUS_ACCESS_DENIED;
                PreviouslyGrantedAccess = 0;
                goto ReturnOneStatus;

            }



            PreviouslyGrantedAccess |= LocalTypeList->CurrentGranted;
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;

        }

    } // if MAXIMUM_ALLOWED...


#ifdef notdef
    //
    // The remaining bits are "remaining" at all levels

    for ( j=0; j<LocalTypeListLength; j++ ) {
        LocalTypeList[j].Remaining = Remaining;
    }

    //
    // Process the DACL handling individual access bits.
    //

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          ( i < AceCount ) && ( LocalTypeList->Remaining != 0 )  ;
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            //
            // Handle an Access Allowed ACE
            //

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

               if ( SepSidInToken( EToken, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart, FALSE ) ) {

                   // Optimize 'normal' case
                   if ( LocalTypeListLength == 1 ) {
                       LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                   } else {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateRemaining );
                   }

               }


            //
            // Handle an object specific Access Allowed ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {
                GUID *ObjectTypeInAce;

                //
                // If no object type is in the ACE,
                //  treat this as an ACCESS_ALLOWED_ACE.
                //

                ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                if ( ObjectTypeInAce == NULL ) {

                    if ( SepSidInToken( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE ) ) {

                       // Optimize 'normal' case
                       if ( LocalTypeListLength == 1 ) {
                           LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                       } else {
                           SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                0,                      // Element to update
                                ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                UpdateRemaining );
                       }
                    }

                //
                // If no object type list was passed,
                //  don't grant access to anyone.
                //

                } else if ( ObjectTypeListLength == 0 ) {

                    // Drop through


               //
               // If an object type is in the ACE,
               //   Find it in the LocalTypeList before using the ACE.
               //
               } else {

                    if ( SepSidInToken( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE ) ) {

                        if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {
                            SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,   // Length of list
                                 Index,                  // Element already updated
                                 ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                 UpdateRemaining );
                        }
                    }
               }


            //
            // Handle a compound Access Allowed ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                //
                // See comment in MAXIMUM_ALLOWED case as to why we can use EToken here
                // for the client.
                //

                if ( SepSidInToken(EToken, PrincipalSelfSid, RtlCompoundAceClientSid( Ace ), FALSE) &&
                     SepSidInToken(PrimaryToken, NULL, RtlCompoundAceServerSid( Ace ), FALSE) ) {

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) {
                        LocalTypeList->Remaining &= ~((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask;
                    } else {
                        SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                             UpdateRemaining );
                    }
                }



            //
            // Handle an Access Denied ACE
            //

            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

                if ( SepSidInToken( EToken, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart, TRUE ) ) {

                    //
                    // The zeroeth element represents the object itself.
                    //  Just check that element.
                    //
                    if (LocalTypeList->Remaining & ((PACCESS_DENIED_ACE)Ace)->Mask) {

                        break;
                    }
                }


            //
            // Handle an object specific Access Denied ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) {

                if ( SepSidInToken( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), TRUE ) ) {
                    GUID *ObjectTypeInAce;

                    //
                    // If there is no object type in the ACE,
                    //  or if the caller didn't specify an object type list,
                    //  apply this deny ACE to the entire object.
                    //

                    ObjectTypeInAce = RtlObjectAceObjectType(Ace);
                    if ( ObjectTypeInAce == NULL ||
                         ObjectTypeListLength == 0 ) {

                        //
                        // The zeroeth element represents the object itself.
                        //  Just check that element.
                        //
                        if (LocalTypeList->Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    //
                    // Otherwise apply the deny ACE to the object specified
                    //  in the ACE.
                    //

                    } else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {

                        if (LocalTypeList[Index].Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    }
               }
            }

        }
    }

#endif

    //
    // Do the normal access check first
    //

    SepNormalAccessCheck(
        Remaining,
        EToken,
        PrimaryToken,
        Dacl,
        PrincipalSelfSid,
        LocalTypeListLength,
        LocalTypeList,
        ObjectTypeListLength,
        FALSE
        );

    if (LocalTypeList->Remaining != 0) {
        Status = STATUS_ACCESS_DENIED;
        PreviouslyGrantedAccess = 0;
        goto ReturnOneStatus;
    }

    //
    // If this is a restricted token, do the additional access check
    //

    if (SeTokenIsRestricted( EToken ) ) {
        SepNormalAccessCheck(
            Remaining,
            EToken,
            PrimaryToken,
            Dacl,
            PrincipalSelfSid,
            LocalTypeListLength,
            LocalTypeList,
            ObjectTypeListLength,
            TRUE
            );
    }


    if (LocalTypeList->Remaining != 0) {
        Status = STATUS_ACCESS_DENIED;
        PreviouslyGrantedAccess = 0;
        goto ReturnOneStatus;
    }

    Status = STATUS_SUCCESS;
    PreviouslyGrantedAccess |= DesiredAccess;

    //
    // Return a single status code to the caller.
    //

    ReturnOneStatus:
    if ( Status == STATUS_SUCCESS && PreviouslyGrantedAccess == 0 ) {
        Status = STATUS_ACCESS_DENIED;
    }

    if ( NT_SUCCESS(Status) ) {
        if ( PrivilegeCount > 0 ) {
            SepAssemblePrivileges(
                PrivilegeCount,
                SystemSecurity,
                WriteOwner,
                Privileges
                );

            if ( ( Privileges != NULL ) && ( *Privileges == NULL ) ) {
                RetVal = FALSE;
                Status = STATUS_NO_MEMORY;
                PreviouslyGrantedAccess = 0;
            }
        }
    }
    //
    // If the caller asked for a list of status',
    //  duplicate the status all over.
    //
    if ( ReturnResultList ) {
        for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
            AccessStatus[ResultListIndex] = Status;
            GrantedAccess[ResultListIndex] = PreviouslyGrantedAccess;
        }
    } else {
        *AccessStatus = Status;
        *GrantedAccess = PreviouslyGrantedAccess;
    }

    if ( NT_SUCCESS(Status) ) {
        if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
            *ReturnSomeAccessGranted = TRUE;
        }
        if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
            *ReturnSomeAccessDenied = FALSE;
        }
    } else {
        if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
            *ReturnSomeAccessGranted = FALSE;
        }
        if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
            *ReturnSomeAccessDenied = TRUE;
        }
    }
    return RetVal;

}




NTSTATUS
NtAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 NULL,      // No Principal Self sid
                 ClientToken,
                 DesiredAccess,
                 NULL,      // No ObjectType List
                 0,         // No ObjectType List
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 FALSE );  // Return a single GrantedAccess and AccessStatus


}






NTSTATUS
NtAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 PrincipalSelfSid,
                 ClientToken,
                 DesiredAccess,
                 ObjectTypeList,
                 ObjectTypeListLength,
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 FALSE );  // Return a single GrantedAccess and AccessStatus
}





NTSTATUS
NtAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 PrincipalSelfSid,
                 ClientToken,
                 DesiredAccess,
                 ObjectTypeList,
                 ObjectTypeListLength,
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 TRUE );  // Return an array of GrantedAccess and AccessStatus
}






NTSTATUS
SeAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    ReturnResultList - If true, GrantedAccess and AccessStatus are actually
        arrays of entries ObjectTypeListLength elements long.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{
    ACCESS_MASK LocalGrantedAccess;
    PACCESS_MASK LocalGrantedAccessPointer = NULL;
    NTSTATUS LocalAccessStatus;
    PNTSTATUS LocalAccessStatusPointer = NULL;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status = STATUS_SUCCESS;
    PTOKEN Token = NULL;
    PSECURITY_DESCRIPTOR CapturedSecurityDescriptor = NULL;
    PSID CapturedPrincipalSelfSid = NULL;
    ACCESS_MASK PreviouslyGrantedAccess = 0;
    GENERIC_MAPPING LocalGenericMapping;
    PIOBJECT_TYPE_LIST LocalObjectTypeList = NULL;
    PPRIVILEGE_SET Privileges = NULL;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ULONG LocalPrivilegeSetLength = 0;
    ULONG ResultListIndex = 0;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode == KernelMode) {
        ASSERT( !ReturnResultList );
        *AccessStatus = STATUS_SUCCESS;
        *GrantedAccess = DesiredAccess;
        return(STATUS_SUCCESS);
    }

    try {

        if ( ReturnResultList ) {

            if ( ObjectTypeListLength == 0 ) {
                Status = STATUS_INVALID_PARAMETER;
                leave ;
            }

            if ( !IsValidElementCount( ObjectTypeListLength, OBJECT_TYPE_LIST ) )
            {
                Status = STATUS_INVALID_PARAMETER ;

                leave ;
            }

            ProbeForWrite(
                AccessStatus,
                sizeof(NTSTATUS) * ObjectTypeListLength,
                sizeof(ULONG)
                );

            ProbeForWrite(
                GrantedAccess,
                sizeof(ACCESS_MASK) * ObjectTypeListLength,
                sizeof(ULONG)
                );

        } else {
            ProbeForWriteUlong((PULONG)AccessStatus);
            ProbeForWriteUlong((PULONG)GrantedAccess);
        }

        LocalPrivilegeSetLength = ProbeAndReadUlong( PrivilegeSetLength );
        ProbeForWriteUlong(
            PrivilegeSetLength
            );

        ProbeForWrite(
            PrivilegeSet,
            LocalPrivilegeSetLength,
            sizeof(ULONG)
            );

        //
        // initialize PrivilegeCount in case the caller passed in an
        // uninitialized PrivilegeSet
        //

        if ( PrivilegeSet &&
             ( LocalPrivilegeSetLength >= sizeof(PRIVILEGE_SET) )) {

            PrivilegeSet->PrivilegeCount = 0;
        }

        ProbeForReadSmallStructure(
            GenericMapping,
            sizeof(GENERIC_MAPPING),
            sizeof(ULONG)
            );

        LocalGenericMapping = *GenericMapping;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS( Status ) ) {
        return( Status );
    }

    if (DesiredAccess &
        ( GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL )) {


        Status = STATUS_GENERIC_NOT_MAPPED;
        goto Cleanup;
    }

    //
    // Obtain a pointer to the passed token
    //

    Status = ObReferenceObjectByHandle(
                 ClientToken,                  // Handle
                 (ACCESS_MASK)TOKEN_QUERY,     // DesiredAccess
                 SeTokenObjectType,           // ObjectType
                 PreviousMode,                 // AccessMode
                 (PVOID *)&Token,              // Object
                 0                             // GrantedAccess
                 );

    if (!NT_SUCCESS(Status)) {
        Token = NULL;
        goto Cleanup;
    }

    //
    // It must be an impersonation token, and at impersonation
    // level of Identification or above.
    //

    if (Token->TokenType != TokenImpersonation) {
        Status = STATUS_NO_IMPERSONATION_TOKEN;
        goto Cleanup;
    }

    if ( Token->ImpersonationLevel < SecurityIdentification ) {
        Status = STATUS_BAD_IMPERSONATION_LEVEL;
        goto Cleanup;
    }

    //
    // Capture any Object type list
    //

    Status = SeCaptureObjectTypeList( ObjectTypeList,
                                      ObjectTypeListLength,
                                      PreviousMode,
                                      &LocalObjectTypeList );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Compare the DesiredAccess with the privileges in the
    // passed token, and see if we can either satisfy the requested
    // access with a privilege, or bomb out immediately because
    // we don't have a privilege we need.
    //

    Status = SePrivilegePolicyCheck(
                 &DesiredAccess,
                 &PreviouslyGrantedAccess,
                 NULL,
                 (PACCESS_TOKEN)Token,
                 &Privileges,
                 PreviousMode
                 );

    if (!NT_SUCCESS( Status )) {

        try {

            if ( ReturnResultList ) {
                for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                    AccessStatus[ResultListIndex] = Status;
                    GrantedAccess[ResultListIndex] = 0;
                }

            } else {
                *AccessStatus = Status;
                *GrantedAccess = 0;
            }

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        goto Cleanup;
    }

    //
    // Make sure the passed privileges buffer is large enough for
    // whatever we have to put into it.
    //

    if (Privileges != NULL) {

        if ( ((ULONG)SepPrivilegeSetSize( Privileges )) > LocalPrivilegeSetLength ) {

            try {

                *PrivilegeSetLength = SepPrivilegeSetSize( Privileges );
                Status = STATUS_BUFFER_TOO_SMALL;

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            SeFreePrivileges( Privileges );

            goto Cleanup;

        } else {

            try {

                RtlCopyMemory(
                    PrivilegeSet,
                    Privileges,
                    SepPrivilegeSetSize( Privileges )
                    );

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                SeFreePrivileges( Privileges );
                Status = GetExceptionCode();
                goto Cleanup;
            }

        }
        SeFreePrivileges( Privileges );

    } else {

        //
        // No privileges were used, construct an empty privilege set
        //

        if ( LocalPrivilegeSetLength < sizeof(PRIVILEGE_SET) ) {

            try {

                *PrivilegeSetLength = sizeof(PRIVILEGE_SET);
                Status = STATUS_BUFFER_TOO_SMALL;

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            goto Cleanup;
        }

        try {

            PrivilegeSet->PrivilegeCount = 0;
            PrivilegeSet->Control = 0;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            goto Cleanup;

        }

    }

    //
    // Capture the PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL ) {
        Status = SeCaptureSid(
                     PrincipalSelfSid,
                     PreviousMode,
                     NULL, 0,
                     PagedPool,
                     TRUE,
                     &CapturedPrincipalSelfSid );

        if (!NT_SUCCESS(Status)) {
            CapturedPrincipalSelfSid = NULL;
            goto Cleanup;
        }
    }


    //
    // Capture the passed security descriptor.
    //
    // SeCaptureSecurityDescriptor probes the input security descriptor,
    // so we don't have to
    //

    Status = SeCaptureSecurityDescriptor (
                SecurityDescriptor,
                PreviousMode,
                PagedPool,
                FALSE,
                &CapturedSecurityDescriptor
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // If there's no security descriptor, then we've been
    // called without all the parameters we need.
    // Return invalid security descriptor.
    //

    if ( CapturedSecurityDescriptor == NULL ) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    //
    // A valid security descriptor must have an owner and a group
    //

    if ( RtlpOwnerAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ||
         RtlpGroupAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ) {

        SeReleaseSecurityDescriptor (
            CapturedSecurityDescriptor,
            PreviousMode,
            FALSE
            );

        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }


    SeCaptureSubjectContext( &SubjectContext );

    SepAcquireTokenReadLock( Token );

    //
    // If the user in the token is the owner of the object, we
    // must automatically grant ReadControl and WriteDac access
    // if desired.  If the DesiredAccess mask is empty after
    // these bits are turned off, we don't have to do any more
    // access checking (ref section 4, DSA ACL Arch)
    //


    if ( DesiredAccess & (WRITE_DAC | READ_CONTROL | MAXIMUM_ALLOWED) ) {

        if (SepTokenIsOwner( Token, CapturedSecurityDescriptor, TRUE )) {

            if ( DesiredAccess & MAXIMUM_ALLOWED ) {

                PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);

            } else {

                PreviouslyGrantedAccess |= (DesiredAccess & (WRITE_DAC | READ_CONTROL));
            }

            DesiredAccess &= ~(WRITE_DAC | READ_CONTROL);
        }

    }

    if (DesiredAccess == 0) {

        try {


            if ( ReturnResultList ) {
                for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {

                    //
                    // Do not allow the request to go thru if the granted access
                    // evaluated to ZERO.
                    //

                    if (PreviouslyGrantedAccess == 0) {
                        AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                        GrantedAccess[ResultListIndex] = 0;
                    } else {
                        AccessStatus[ResultListIndex] = STATUS_SUCCESS;
                        GrantedAccess[ResultListIndex] = PreviouslyGrantedAccess;
                    }
                }

            } else {

                //
                // Do not allow the request to go thru if the granted access
                // evaluated to ZERO.
                //

                if (PreviouslyGrantedAccess == 0) {
                    *AccessStatus = STATUS_ACCESS_DENIED;
                    *GrantedAccess = 0;
                } else {
                    *AccessStatus = STATUS_SUCCESS;
                    *GrantedAccess = PreviouslyGrantedAccess;
                }
            }
            Status = STATUS_SUCCESS;

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

        }

        SepReleaseTokenReadLock( Token );

        SeReleaseSubjectContext( &SubjectContext );

        SeReleaseSecurityDescriptor (
            CapturedSecurityDescriptor,
            PreviousMode,
            FALSE
            );

        goto Cleanup;

    }


    //
    // Finally, handle the case where we actually have to check the DACL.
    //

    if ( ReturnResultList ) {
        LocalGrantedAccessPointer =
            ExAllocatePoolWithTag( PagedPool, (sizeof(ACCESS_MASK)+sizeof(NTSTATUS)) * ObjectTypeListLength, 'aGeS' );

        if (LocalGrantedAccessPointer == NULL) {

            SepReleaseTokenReadLock( Token );

            SeReleaseSubjectContext( &SubjectContext );

            SeReleaseSecurityDescriptor (
                CapturedSecurityDescriptor,
                PreviousMode,
                FALSE
                );

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        LocalAccessStatusPointer = (PNTSTATUS)(LocalGrantedAccessPointer + ObjectTypeListLength);
    } else {
        LocalGrantedAccessPointer = &LocalGrantedAccess;
        LocalAccessStatusPointer =  &LocalAccessStatus;
    }

    //
    // This does not ask for privilege set to be returned so we can ignore
    // the return value of the call.
    //

    (VOID) SepAccessCheck (
               CapturedSecurityDescriptor,
               CapturedPrincipalSelfSid,
               SubjectContext.PrimaryToken,
               Token,
               DesiredAccess,
               LocalObjectTypeList,
               ObjectTypeListLength,
               &LocalGenericMapping,
               PreviouslyGrantedAccess,
               PreviousMode,
               LocalGrantedAccessPointer,
               NULL,
               LocalAccessStatusPointer,
               ReturnResultList,
               NULL,
               NULL );

    SepReleaseTokenReadLock( Token );

    SeReleaseSubjectContext( &SubjectContext );

    SeReleaseSecurityDescriptor (
        CapturedSecurityDescriptor,
        PreviousMode,
        FALSE
        );

    try {

        if ( ReturnResultList ) {
            for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                AccessStatus[ResultListIndex] = LocalAccessStatusPointer[ResultListIndex];
                GrantedAccess[ResultListIndex] = LocalGrantedAccessPointer[ResultListIndex];
            }

        } else {
            *AccessStatus = *LocalAccessStatusPointer;
            *GrantedAccess = *LocalGrantedAccessPointer;
        }

        Status = STATUS_SUCCESS;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if ( ReturnResultList ) {
        if ( LocalGrantedAccessPointer != NULL ) {
            ExFreePool( LocalGrantedAccessPointer );
        }
    }


    //
    // Free locally used resources.
    //
Cleanup:

    if ( Token != NULL ) {
        ObDereferenceObject( Token );
    }

    if ( LocalObjectTypeList != NULL ) {
        SeFreeCapturedObjectTypeList( LocalObjectTypeList );
    }

    if (CapturedPrincipalSelfSid != NULL) {
        SeReleaseSid( CapturedPrincipalSelfSid, PreviousMode, TRUE);
    }

    return Status;
}



VOID
SeFreePrivileges(
    IN PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This routine frees a privilege set returned by SeAccessCheck.

Arguments:

    Privileges - Supplies a pointer to the privilege set to be freed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( Privileges );
}



BOOLEAN
SeAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN BOOLEAN SubjectContextLocked,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    See module abstract

    This routine MAY perform tests for the following
    privileges:

                SeTakeOwnershipPrivilege
                SeSecurityPrivilege

    depending upon the accesses being requested.

    This routine may also check to see if the subject is the owner
    of the object (to grant WRITE_DAC access).

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the
         object being accessed

    SubjectSecurityContext - A pointer to the subject's captured security
         context

    SubjectContextLocked - Supplies a flag indiciating whether or not
        the user's subject context is locked, so that it does not have
        to be locked again.

    DesiredAccess - Supplies the access mask that the user is attempting to
         acquire

    PreviouslyGrantedAccess - Supplies any accesses that the user has
        already been granted, for example, as a result of holding a
        privilege.

    Privileges - Supplies a pointer in which will be returned a privilege
        set indicating any privileges that were used as part of the
        access validation.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    AccessMode - Supplies the access mode to be used in the check

    GrantedAccess - Pointer to a returned access mask indicatating the
         granted access

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.


Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN Success;

    PAGED_CODE();

    if (AccessMode == KernelMode) {

        if (DesiredAccess & MAXIMUM_ALLOWED) {

            //
            // Give him:
            //   GenericAll
            //   Anything else he asked for
            //

            *GrantedAccess = GenericMapping->GenericAll;
            *GrantedAccess |= (DesiredAccess & ~MAXIMUM_ALLOWED);
            *GrantedAccess |= PreviouslyGrantedAccess;

        } else {

            *GrantedAccess = DesiredAccess | PreviouslyGrantedAccess;
        }
        *AccessStatus = STATUS_SUCCESS;
        return(TRUE);
    }

    //
    // If the object doesn't have a security descriptor (and it's supposed
    // to), return access denied.
    //

    if ( SecurityDescriptor == NULL) {

       *AccessStatus = STATUS_ACCESS_DENIED;
       return( FALSE );

    }

    //
    // If we're impersonating a client, we have to be at impersonation level
    // of SecurityImpersonation or above.
    //

    if ( (SubjectSecurityContext->ClientToken != NULL) &&
         (SubjectSecurityContext->ImpersonationLevel < SecurityImpersonation)
       ) {
           *AccessStatus = STATUS_BAD_IMPERSONATION_LEVEL;
           return( FALSE );
    }

    if ( DesiredAccess == 0 ) {

        if ( PreviouslyGrantedAccess == 0 ) {
            *AccessStatus = STATUS_ACCESS_DENIED;
            return( FALSE );
        }

        *GrantedAccess = PreviouslyGrantedAccess;
        *AccessStatus = STATUS_SUCCESS;
        *Privileges = NULL;
        return( TRUE );

    }

    SeAssertMappedCanonicalAccess( DesiredAccess );


    //
    // If the caller did not lock the subject context for us,
    // lock it here to keep lower level routines from having
    // to lock it.
    //

    if ( !SubjectContextLocked ) {
        SeLockSubjectContext( SubjectSecurityContext );
    }

    //
    // If the user in the token is the owner of the object, we
    // must automatically grant ReadControl and WriteDac access
    // if desired.  If the DesiredAccess mask is empty after
    // these bits are turned off, we don't have to do any more
    // access checking (ref section 4, DSA ACL Arch)
    //

    if ( DesiredAccess & (WRITE_DAC | READ_CONTROL | MAXIMUM_ALLOWED) ) {

        if ( SepTokenIsOwner(
                 EffectiveToken( SubjectSecurityContext ),
                 SecurityDescriptor,
                 TRUE
                 ) ) {

            if ( DesiredAccess & MAXIMUM_ALLOWED ) {

                PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);

            } else {

                PreviouslyGrantedAccess |= (DesiredAccess & (WRITE_DAC | READ_CONTROL));
            }

            DesiredAccess &= ~(WRITE_DAC | READ_CONTROL);
        }
    }

    if (DesiredAccess == 0) {

        if ( !SubjectContextLocked ) {
            SeUnlockSubjectContext( SubjectSecurityContext );
        }

        *GrantedAccess = PreviouslyGrantedAccess;
        *AccessStatus = STATUS_SUCCESS;
        return( TRUE );

    } else {

        BOOLEAN b = SepAccessCheck(
                        SecurityDescriptor,
                        NULL,   // No PrincipalSelfSid
                        SubjectSecurityContext->PrimaryToken,
                        SubjectSecurityContext->ClientToken,
                        DesiredAccess,
                        NULL,   // No object type list
                        0,      // No object type list
                        GenericMapping,
                        PreviouslyGrantedAccess,
                        AccessMode,
                        GrantedAccess,
                        Privileges,
                        AccessStatus,
                        FALSE,   // Don't return a list
                        &Success,
                        NULL
                        );
#if DBG
          if (!Success && SepShowAccessFail) {
              DbgPrint("SE: Access check failed, DesiredAccess = 0x%x\n",
                DesiredAccess);
              SepDumpSD = TRUE;
              SepDumpSecurityDescriptor(
                  SecurityDescriptor,
                  "Input to SeAccessCheck\n"
                  );
              SepDumpSD = FALSE;
              SepDumpToken = TRUE;
              SepDumpTokenInfo( EffectiveToken( SubjectSecurityContext ) );
              SepDumpToken = FALSE;
          }
#endif

        //
        // If we locked it in this routine, unlock it before we
        // leave.
        //

        if ( !SubjectContextLocked ) {
            SeUnlockSubjectContext( SubjectSecurityContext );
        }

        //
        // We return failure if any of the following is TRUE
        //   1. The user was really not granted access.
        //   2. The resource manager asked for the list of privileges used to
        //      determine granted access and we failed to allocate memory
        //      required to return these.
        //

        return( b && Success );
    }
}



NTSTATUS
SePrivilegePolicyCheck(
    IN OUT PACCESS_MASK RemainingDesiredAccess,
    IN OUT PACCESS_MASK PreviouslyGrantedAccess,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL,
    IN PACCESS_TOKEN ExplicitToken OPTIONAL,
    OUT PPRIVILEGE_SET *PrivilegeSet,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine implements privilege policy by examining the bits in
    a DesiredAccess mask and adjusting them based on privilege checks.

    Currently, a request for ACCESS_SYSTEM_SECURITY may only be satisfied
    by the caller having SeSecurityPrivilege.  WRITE_OWNER may optionally
    be satisfied via SeTakeOwnershipPrivilege.

Arguments:

    RemainingDesiredAccess - The desired access for the current operation.
        Bits may be cleared in this if the subject has particular privileges.

    PreviouslyGrantedAccess - Supplies an access mask describing any
        accesses that have already been granted.  Bits may be set in
        here as a result of privilge checks.

    SubjectSecurityContext - Optionally provides the subject's security
        context.

    ExplicitToken - Optionally provides the token to be examined.

    PrivilegeSet - Supplies a pointer to a location in which will be
        returned a pointer to a privilege set.

    PreviousMode - The previous processor mode.

Return Value:

    STATUS_SUCCESS - Any access requests that could be satisfied via
        privileges were done.

    STATUS_PRIVILEGE_NOT_HELD - An access type was being requested that
        requires a privilege, and the current subject did not have the
        privilege.



--*/

{
    BOOLEAN Success;
    PTOKEN Token;
    BOOLEAN WriteOwner = FALSE;
    BOOLEAN SystemSecurity = FALSE;
    ULONG PrivilegeNumber = 0;
    ULONG PrivilegeCount = 0;
    ULONG SizeRequired;

    PAGED_CODE();

    if (ARGUMENT_PRESENT( SubjectSecurityContext )) {

        Token = (PTOKEN)EffectiveToken( SubjectSecurityContext );

    } else {

        Token = (PTOKEN)ExplicitToken;
    }


    if (*RemainingDesiredAccess & ACCESS_SYSTEM_SECURITY) {

        Success = SepSinglePrivilegeCheck (
                    SeSecurityPrivilege,
                    Token,
                    PreviousMode
                    );

        if (!Success) {

            return( STATUS_PRIVILEGE_NOT_HELD );
        }

        PrivilegeCount++;
        SystemSecurity = TRUE;

        *RemainingDesiredAccess &= ~ACCESS_SYSTEM_SECURITY;
        *PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (*RemainingDesiredAccess & WRITE_OWNER) {

        Success = SepSinglePrivilegeCheck (
                    SeTakeOwnershipPrivilege,
                    Token,
                    PreviousMode
                    );

        if (Success) {

            PrivilegeCount++;
            WriteOwner = TRUE;

            *RemainingDesiredAccess &= ~WRITE_OWNER;
            *PreviouslyGrantedAccess |= WRITE_OWNER;

        }
    }

    if (PrivilegeCount > 0) {
        SizeRequired = sizeof(PRIVILEGE_SET) +
                        (PrivilegeCount - ANYSIZE_ARRAY) *
                        (ULONG)sizeof(LUID_AND_ATTRIBUTES);

        *PrivilegeSet = ExAllocatePoolWithTag( PagedPool, SizeRequired, 'rPeS' );

        if ( *PrivilegeSet == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        (*PrivilegeSet)->PrivilegeCount = PrivilegeCount;
        (*PrivilegeSet)->Control = 0;

        if (WriteOwner) {
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Luid = SeTakeOwnershipPrivilege;
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
            PrivilegeNumber++;
        }

        if (SystemSecurity) {
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Luid = SeSecurityPrivilege;
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
        }
    }

    return( STATUS_SUCCESS );
}



BOOLEAN
SepTokenIsOwner(
    IN PACCESS_TOKEN EffectiveToken,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN TokenLocked
    )

/*++

Routine Description:

    This routine will determine of the Owner of the passed security descriptor
    is in the passed token. If the token is restricted it cannot be the
    owner.


Arguments:

    Token - The token representing the current user.

    SecurityDescriptor - The security descriptor for the object being
        accessed.

    TokenLocked - A boolean describing whether the caller has taken
        a read lock for the token.


Return Value:

    TRUE - The user of the token is the owner of the object.

    FALSE - The user of the token is not the owner of the object.

--*/

{
    PSID Owner;
    BOOLEAN rc;

    PISECURITY_DESCRIPTOR ISecurityDescriptor;
    PTOKEN Token;

    PAGED_CODE();

    ISecurityDescriptor = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
    Token = (PTOKEN)EffectiveToken;


    Owner = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );
    ASSERT( Owner != NULL );

    if (!TokenLocked) {
        SepAcquireTokenReadLock( Token );
    }

    rc = SepSidInToken( Token, NULL, Owner, FALSE );

    //
    // For restricted tokens, check the restricted sids too.
    //

    if (rc && (Token->TokenFlags & TOKEN_IS_RESTRICTED) != 0) {
        rc = SepSidInTokenEx( Token, NULL, Owner, FALSE, TRUE );

    }

    if (!TokenLocked) {
        SepReleaseTokenReadLock( Token );
    }

    return( rc );
}


#define WORLD_TRAVERSAL_INCLUDES_ANONYMOUS 1

BOOLEAN
SeFastTraverseCheck(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN ACCESS_MASK TraverseAccess,
    IN KPROCESSOR_MODE AccessMode
    )
/*++

Routine Description:

    This routine will perform a fast check against the DACL of the passed
    Security Descriptor to see if Traverse access would be granted. If so, no
    further access checking is necessary.

    Note that the SubjectContext for the client process does not have
    to be locked to make this call, since it does not examine any data
    structures in the Token.

    The caller has the following responsibilities:
    1. It is the job of the caller to verify AccessMode is not KernelMode!
    2. The *caller* is expected to check AccessState for
       TOKEN_HAS_TRAVERSE_PRIVILEGE if the override is applicable!

Arguments:

    SecurityDescriptor - The Security Descriptor protecting the container
        object being traversed.

    AccessState - Running security access state containing caller token
        information for operation.

    TraverseAccess - Access mask describing Traverse access for this
        object type. There must be only one bit specified in the mask.

    AccessMode - Supplies the access mode to be used in the check


Return Value:

    TRUE - if Traverse access to this container can be granted. FALSE otherwise.

--*/

{
    PACL Dacl;
    ULONG i;
    PVOID Ace;
    ULONG AceCount;
#if !WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
    LOGICAL FoundWorld;
    LOGICAL FoundAnonymous;
#endif

    PAGED_CODE();

    //
    // Note that I/O calls this function even if the traverse bypass privilege
    // is set. This is done as I/O doesn't want the performance override to
    // apply to the DeviceObject->FileName boundary, as not all filesystems
    // supply file-level security.
    //
    // ASSERT( (!ARGUMENT_PRESENT(AccessState)) ||
    //        (!(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE)) );
    //

    ASSERT ( AccessMode != KernelMode );

    if (SecurityDescriptor == NULL) {
        return( FALSE );
    }

    //
    // See if there is a valid DACL in the passed Security Descriptor.
    // No DACL, no security, all is granted. Note that this function returns
    // NULL if SE_DACL_PRESENT isn't set.
    //

    Dacl = RtlpDaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor );

    //
    // If no DACL is supplied, the object has no security, so all accesses are
    // granted.
    //

    if ( Dacl == NULL ) {

        return(TRUE);
    }

    //
    // There is security on this object.  If the DACL is empty, deny all access
    // immediately
    //

    if ((AceCount = Dacl->AceCount) == 0) {

        return( FALSE );
    }

    //
    // A restricted token is a token with two lists of SIDs. Access checks are
    // done against each list, passing only if both lists grant access. The
    // second "restricting SID" list can contain *any allow* SID.
    //
    // This routine doesn't walk a restricted token's restricting-SID list. As
    // such, restricted tokens require a full access check.
    //
    if (AccessState->Flags & TOKEN_IS_RESTRICTED) {

        return FALSE;
    }

    //
    // There's stuff in the DACL, walk down the list and see
    // if both Everyone and Anonymous have been granted TraverseAccess
    //
#if !WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
    FoundWorld = FALSE;
    FoundAnonymous = FALSE;
#endif

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if (((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE) {

            continue;
        }

        if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

            if ( (TraverseAccess & ((PACCESS_ALLOWED_ACE)Ace)->Mask) ) {

                if ( RtlEqualSid( SeWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {
#if WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
                    return( TRUE );
                }
#else
                    if (FoundAnonymous) {

                        return( TRUE );

                    } else {

                        FoundWorld = TRUE;
                    }

                } else if ( RtlEqualSid( SeAnonymousLogonSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {

                    if (FoundWorld) {

                        return( TRUE );

                    } else {

                        FoundAnonymous = TRUE;
                    }
                }
#endif
            }

        } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

            if ( (TraverseAccess & ((PACCESS_DENIED_ACE)Ace)->Mask) ) {

                //
                // This ACE might refer to a group the user belongs to
                // (or could be the user). Force a full access check.
                //

                return( FALSE );
            }
        }
    }

    return( FALSE );
}

#ifdef SE_NTFS_WORLD_CACHE

/*++

Note: Do not delete SeGetWorldRights. It might be used by NTFS in future.

      When that happens:

          - Add this line to #ifdef ALLOC_PRAGMA.
                #pragma alloc_text(PAGE,SeGetWorldRights)

          - Uncomment the function prototype declaration in ntos\inc\se.h

    KedarD - 07/05/2000

--*/



VOID
SeGetWorldRights (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK GrantedAccess
    )
/*++

Routine Descriptions:

    This call acquires the minimum rights that are available to all tokens.
    This takes into account all deny access ACE(s) that would reduce the
    rights granted to an ACE for Everyone.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the
        object being accessed

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    GrantedAccess - Returns an access mask describing the granted access.

Return Value:

    None.


--*/

{
    ACCESS_MASK AlreadyDenied;
    PACL Dacl;
    PVOID Ace;
    ULONG AceCount = 0;
    ULONG Index;

    PAGED_CODE();

    *GrantedAccess = 0;

    //
    // Get a pointer to the ACL.
    //

    Dacl = RtlpDaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor );

    //
    //  If the SE_DACL_PRESENT bit is not set, the object has no
    //  security, so all accesses are granted.  If he's asking for
    //  MAXIMUM_ALLOWED, return the GENERIC_ALL field from the generic
    //  mapping.
    //
    //  Also grant all access if the Dacl is NULL.
    //

    if ( (Dacl == NULL) ||
         !RtlpAreControlBitsSet( (PISECURITY_DESCRIPTOR)SecurityDescriptor,
                                 SE_DACL_PRESENT) ) {

#ifndef SECURE_NULL_DACLS

        //
        // Grant all access.
        //

        *GrantedAccess = GenericMapping->GenericAll;

#endif //!SECURE_NULL_DACLS

    } else {

        AceCount = Dacl->AceCount;
    }

    for ( Index = 0, Ace = FirstAce( Dacl ), AlreadyDenied = 0 ;
          Index < AceCount ;
          Index += 1, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if ( RtlEqualSid( SeWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    *GrantedAccess |=
                        (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~AlreadyDenied);
                }

             //
             // Handle an object specific Access Allowed ACE
             //
             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {

                 //
                 // If no object type is in the ACE,
                 //  treat this as an ACCESS_ALLOWED_ACE.
                 //

                 if ( RtlObjectAceObjectType( Ace ) == NULL ) {

                     if ( RtlEqualSid( SeWorldSid, RtlObjectAceSid(Ace) ) ) {

                         *GrantedAccess |=
                             (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~AlreadyDenied);
                     }

                 }

             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                 if ( RtlEqualSid( SeWorldSid, RtlCompoundAceClientSid(Ace) ) &&
                      RtlEqualSid( SeWorldSid, RtlCompoundAceServerSid(Ace) ) ) {

                     //
                     // Only grant access types from this mask that have
                     // not already been denied
                     //

                     *GrantedAccess |=
                         (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~AlreadyDenied);
                 }


             } else if ( ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) ||
                         ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) ) {

                 //
                 // We include all of the deny access ACE(s), regardless of to
                 // what SID they apply.
                 //

                 //
                 // Only deny access types from this mask that have
                 // not already been granted
                 //

                 AlreadyDenied |= (((PACCESS_DENIED_ACE)Ace)->Mask & ~*GrantedAccess);

            }
        }
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\adtutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    adtutil.c - Security Auditing - Utility Routines

Abstract:

    This Module contains miscellaneous utility routines private to the
    Security Auditing Component.

Author:

    Robert Reichel      (robertre)     September 10, 1991

Environment:

    Kernel Mode

Revision History:

--*/

#include "pch.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepRegQueryDwordValue)
#endif



NTSTATUS
SepRegQueryHelper(
    IN  PCWSTR KeyName,
    IN  PCWSTR ValueName,
    IN  ULONG  ValueType,
    IN  ULONG  ValueLength,
    OUT PVOID  ValueBuffer,
    OUT PULONG LengthRequired
    )
/*++

Routine Description:

    Open regkey KeyName, read the value specified by ValueName
    and return the value.

Arguments:

    KeyName        - name of key to open

    ValueName      - name of value to read

    ValueType      - type of value to read (REG_DWORD etc.)

    ValueLength    - size in bytes of the value to read

    ValueBuffer    - pointer to returned value

    LengthRequired - if the passed buffer is not sufficient to hold
                     the value, this param will return the actual size
                     in