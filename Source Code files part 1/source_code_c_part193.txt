LL; // want to get WM_ERASEBKGND messages
            wc.lpszMenuName = NULL;
            wc.lpszClassName = szActionItemListClassName;

            if(b = (RegisterClass(&wc) != 0)) {
                Registered = TRUE;
            }
        }
    } else {
        if(Registered) {
            if(b = UnregisterClass(szActionItemListClassName,MyModuleHandle)) {
                Registered = FALSE;
            }
        } else {
            b = TRUE;
        }
    }

    return(b);
}

typedef struct _SPREG_TO_TEXT {
    DWORD FailureCode;
    PCWSTR FailureText;
} SPREG_TO_TEXT, *PSPREG_TO_TEXT;

SPREG_TO_TEXT RegErrorToText[] = {
    { SPREG_SUCCESS,     L"Success"           },
    { SPREG_LOADLIBRARY, L"LoadLibrary"       },
    { SPREG_GETPROCADDR, L"GetProcAddress"    },
    { SPREG_REGSVR,      L"DllRegisterServer" },
    { SPREG_DLLINSTALL,  L"DllInstall"        },
    { SPREG_TIMEOUT,     L"Timed out"         },
    { SPREG_UNKNOWN,     L"Unknown"           },
    { 0,                 NULL                 }
};


UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
/*++

Routine Description:

    Callback routine that is called each time we self-register a file.

Arguments:

    Context - context message passed from parent to caller.

    Notification - specifies an SPFILENOTIFY_*** code, which tells us how
                   to interpret Param1 and Param2.

    Param1 - dependent on notification.

    Param2 - dependent on notification.


Return Value:

    FILEOP_*** code dependent on Notification code.

--*/
{
    PSP_REGISTER_CONTROL_STATUS Status = (PSP_REGISTER_CONTROL_STATUS)Param1;
    PREGISTRATION_CONTEXT RegistrationContext = (PREGISTRATION_CONTEXT) Context;
    DWORD i, ErrorMessageId;
    PCWSTR p;

    if (Notification == SPFILENOTIFY_STARTREGISTRATION) {
        //
        // log that we're starting registration and update the progress
        // guage as well.
        //
        SetupDebugPrint1(
                L"SETUP: file to register is %s...",
                Status->FileName);

        if (RegistrationContext->hWndProgress) {
            SendMessage(
                    RegistrationContext->hWndProgress,
                    PBM_STEPIT,
                    0,
                    0 );
        }
        return FILEOP_DOIT;

    }

    if (Notification == SPFILENOTIFY_ENDREGISTRATION) {
        //
        // the file has been registered, so log failure if necessary
        // Note that we have a special code for timeouts
        //
        switch(Status->FailureCode) {
            case SPREG_SUCCESS:

                SetupDebugPrint1(
                    L"SETUP: %s registered successfully",
                    Status->FileName);
                break;
            case SPREG_TIMEOUT:
                SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_OLE_REGISTRATION_HUNG,
                         Status->FileName,
                         NULL,NULL);
                SetupDebugPrint1(
                    L"SETUP: %s timed out during registration",
                    Status->FileName);
                break;
            default:
                //
                // log an error
                //
                for (i = 0;RegErrorToText[i].FailureText != NULL;i++) {
                    if (RegErrorToText[i].FailureCode == Status->FailureCode) {
                        p = RegErrorToText[i].FailureText;
                        if ((Status->FailureCode == SPREG_LOADLIBRARY) &&
                            (Status->Win32Error == ERROR_MOD_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_MOD_NOT_FOUND;
                        else 
                        if ((Status->FailureCode == SPREG_GETPROCADDR) &&
                            (Status->Win32Error == ERROR_PROC_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_PROC_NOT_FOUND;
                        else
                            ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;

                        break;
                    }
                }

                if (!p) {
                    p = L"Unknown";
                    ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;
                }
                SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OLE_CONTROL_NOT_REGISTERED,
                        Status->FileName,
                        NULL,
                        SETUPLOG_USE_MESSAGEID,
                        ErrorMessageId,
                        p,
                        Status->Win32Error,
                        NULL,
                        NULL
                        );

                SetupDebugPrint1(
                    L"SETUP: %s did not register successfully",
                    Status->FileName);
        }

        //
        // Verify that the DLL didn't change our unhandled exception filter.
        //
        if( MyUnhandledExceptionFilter !=
            SetUnhandledExceptionFilter(MyUnhandledExceptionFilter)) {

            SetupDebugPrint1(
                    L"SETUP: %ws broke the exception handler.",
                    Status->FileName );
#if 0
            //
            // We'll put this in after all the currently broken DLLs are fixed.
            //
            MessageBoxFromMessage(
                RegistrationContext->hwndParent,
                MSG_EXCEPTION_FILTER_CHANGED,
                NULL,
                IDS_WINNT_SETUP,
                MB_OK | MB_ICONWARNING,
                Status->FileName );
#endif
        }

        return FILEOP_DOIT;
    }


    MYASSERT(FALSE);

    return(FILEOP_DOIT);
}



BOOL
RegisterOleControls(
    IN HWND     hwndParent,
    IN HINF     hInf,
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent,
    IN PWSTR    SectionName
    )
/*++

Routine Description:

    This routine runs down the entries in the specified INF section, and
    self-registers each file.

Arguments:

    hwndParent - supplies the window handle used for the PRERELEASE message
        box that indicates an OLE registration has hung.

    InfHandle - supplies handle to inf containing the specified SectionName.

    hProgress - handle to progress gauge that gets ticked every time we
        process a file.

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).

    SectionName - Supplies the name of the section contained in the INF
        specified by InfHandle that lists OLE control DLLs to be
        registered/installed.

Return Value:

    Boolean value indicating outcome. If a file to be registered is
    not present, that is NOT reason for returning false.

--*/
{
    UINT GaugeRange;
    DWORD SectionCount,LineCount, i;
    INFCONTEXT InfContext;
    BOOL RetVal = TRUE;
    REGISTRATION_CONTEXT RegistrationContext;

    RegistrationContext.hWndParent   = hwndParent;
    RegistrationContext.hWndProgress = hProgress;
    LineCount = 0;

    //
    // Initialize the progress indicator control.
    //
    if (hProgress) {


        //
        // find out how many files we have to register
        //
        if (SetupFindFirstLine(hInf,
                               SectionName,
                               TEXT("RegisterDlls"),
                               &InfContext)) {


            do {
                SectionCount = SetupGetFieldCount(&InfContext);
                for (i = 1; i<=SectionCount; i++) {
                    PCWSTR IndividualSectionName = pSetupGetField(&InfContext,i);

                    if (IndividualSectionName) {
                        LineCount += SetupGetLineCount(hInf, IndividualSectionName);
                    }
                }

            } while(SetupFindNextMatchLine(
                                &InfContext,
                                TEXT("RegisterDlls"),
                                &InfContext));
        }

        MYASSERT((StopAtPercent-StartAtPercent) != 0);
        GaugeRange = (LineCount*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, LineCount, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    //
    // now allow Setup API to register the files, using our callback to log
    // errors if and when they occur.
    //
    if (!SetupInstallFromInfSection(
                 hwndParent,
                 hInf,
                 SectionName,
                 SPINST_REGSVR| SPINST_REGISTERCALLBACKAWARE,
                 NULL,
                 NULL,
                 0,
                 RegistrationQueueCallback,
                 (PVOID)&RegistrationContext,
                 NULL,
                 NULL
                 )) {
        DWORD d;
        RetVal = FALSE;
        d = GetLastError();
        SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_OLE_REGISTRATION_SECTION_FAILURE,
                SectionName,
                L"syssetup.inf",
                d,
                NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szSetupInstallFromInfSection,
                d,
                NULL,
                NULL
                );
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\dll.c ===
#include "setupp.h"
#pragma hdrstop

HANDLE MyModuleHandle;
WCHAR  MyModuleFileName[MAX_PATH];


BOOL
CommonProcessAttach(
    IN BOOL Attach
    );

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
#define FUNCTION L"DllMain"
    ULONG   MyModuleFileNameLength;
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = DllHandle;

        MyModuleFileNameLength =
            GetModuleFileNameW(MyModuleHandle, MyModuleFileName, RTL_NUMBER_OF(MyModuleFileName));
        if (MyModuleFileNameLength == 0) {
            SetupDebugPrint1(L"SETUP: GetModuleFileNameW failed in " FUNCTION L", LastError is %d\n", GetLastError());
            b = FALSE;
            goto Exit;
        }
        if (MyModuleFileNameLength > RTL_NUMBER_OF(MyModuleFileName)) {
            SetupDebugPrint(L"SETUP: GetModuleFileNameW failed in " FUNCTION L", LastError is ERROR_INSUFFICIENT_BUFFER\n");
            b = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        b = CommonProcessAttach(TRUE);
        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        CommonProcessAttach(FALSE);
        break;

    case DLL_THREAD_DETACH:

        break;
    }
Exit:
    return(b);
}


BOOL
CommonProcessAttach(
    IN BOOL Attach
    )
{
    BOOL b;

    //
    // Assume success for detach, failure for attach
    //
    b = !Attach;

    if(Attach) {

        b = pSetupInitializeUtils();
        if (b)
        {
            b = RegisterActionItemListControl(TRUE) && (PlatformSpecificInit() == NO_ERROR);
        }

    } else {
        RegisterActionItemListControl(FALSE);
        pSetupUninitializeUtils();

    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\dynupdt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    Routines to handle dynamic update support during GUI setup phase

Author:

    Ovidiu Temereanca (ovidiut) 15-Aug-2000

Revision History:

--*/

#include "setupp.h"
#include "hwdb.h"
#include "newdev.h"
#pragma hdrstop


#define STR_UPDATES_INF         TEXT("updates.inf")
#define STR_DEFAULTINSTALL      TEXT("DefaultInstall")
#define STR_DEFAULTINSTALLFINAL TEXT("DefaultInstallFinal")
#define STR_DRIVERCACHEINF      TEXT("drvindex.inf")
#define STR_VERSION             TEXT("Version")
#define STR_CABFILES            TEXT("CabFiles")
#define STR_CABS                TEXT("Cabs")
#define S_HWCOMP_DAT            TEXT("hwcomp.dat")


static TCHAR g_DuShare[MAX_PATH];


BOOL
BuildPath (
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )

/*++

Routine Description:

    This function builds a path given the 2 components, assumed not to contain
    trailing or heading wacks

Arguments:

    PathBuffer - Receives the full path

    PathBuferSize - The size in chars of PathBuffer

    Path1 - Specifies the head path

    Path2 - Specifies the tail path

Return Value:

    TRUE to indicate success; FALSE in case of failure; it means the supplied buffer
    was too small to fit the whole new path

--*/

{
    if (!PathBuffer || !PathBufferSize || !Path1 || !Path2) {
        MYASSERT (FALSE);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (_sntprintf (PathBuffer, PathBufferSize, TEXT("%s\\%s"), Path1, Path2) < 0) {
        PathBuffer[0] = 0;
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    return TRUE;
}

BOOL
pDoesFileExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
pDoesDirExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


DWORD
CreateMultiLevelDirectory (
    IN LPCTSTR Directory
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It can handle either paths of form x:... or \\?\Volume{...

Arguments:

    Directory - supplies fully-qualified Win32 pathspec of directory to create

Return Value:

    Win32 error code indicating outcome.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTSTR p,q;
    TCHAR c;
    BOOL Done;
    DWORD d = ERROR_SUCCESS;

    if (FAILED (StringCchCopy (Buffer, ARRAYSIZE(Buffer), Directory))) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // If it already exists do nothing. (We do this before syntax checking
    // to allow for remote paths that already exist. This is needed for
    // remote boot machines.)
    //
    d = GetFileAttributes(Buffer);
    if(d != (DWORD)(-1)) {
        return((d & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    //
    // Check path format
    //
    c = (TCHAR)CharUpper((LPTSTR)Buffer[0]);
    if (c < TEXT('A') || c > TEXT('Z') || Buffer[1] != TEXT(':')) {
        return ERROR_INVALID_PARAMETER;
    }

    if(Buffer[2] != TEXT('\\')) {
        return(Buffer[2] ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS);
    }
    q = Buffer + 3;
    if(*q == 0) {
        return(ERROR_SUCCESS);
    }

    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if(p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(CreateDirectory(Buffer,NULL)) {
            d = ERROR_SUCCESS;
        } else {
            d = GetLastError();
            if(d == ERROR_ALREADY_EXISTS) {
                d = ERROR_SUCCESS;
            }
        }

        if(d == ERROR_SUCCESS) {
            //
            // Put back the path sep and move to the next component.
            //
            if(!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while(!Done);

    return(d);
}

DWORD
GetDriverCacheSourcePath (
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    )

/*++

Routine Description:

    This routine returns the source path to the local driver cache.

    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        DriverCachePath : REG_EXPAND_SZ :

Arguments:

    Buffer - Receives the path.

    BufChars - Specifies the size of Buffer, in chars

Return Value:

    If the function succeeds, the return value is TRUE

    If the function fails, the return value is FALSE.

--*/

{
    HKEY hKey;
    DWORD rc, DataType, DataSize;
    TCHAR Value[MAX_PATH];

    rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_SETUP TEXT("\\Setup"),
                0,
                KEY_READ,
                &hKey
                );
    if(rc == ERROR_SUCCESS) {
        //
        // Attempt to read the "DriverCachePath" value.
        //
        DataSize = sizeof (Value);
        rc = RegQueryValueEx (hKey, REGSTR_VAL_DRIVERCACHEPATH, NULL, &DataType, (PBYTE)Value, &DataSize);

        RegCloseKey(hKey);

        if(rc == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (Value, Buffer, BufChars - 6);

            if (Buffer[0]) {
                _tcscat (
                    Buffer,
#if   defined(_AMD64_)
                    TEXT("\\amd64")
#elif defined(_X86_)
                    IsNEC_98 ? TEXT("\\nec98") : TEXT("\\i386")
#elif defined(_IA64_)
                    TEXT("\\ia64")
#else
#error "No Target Architecture"
#endif
                    );
                return ERROR_SUCCESS;
            } else {
                rc = ERROR_INVALID_DATA;
            }
        }
    }

    return rc;
}


PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    )

/*++

Routine Description:

    This function looks for a substring of a given string, only if found
    between the specified separator chars

Arguments:

    String - Specifies the full string

    Separator - Specifies the separator

    SubStr - Specifies the sub string to look for

    CaseSensitive - Specifies if the comparison should be case sensitive or not

Return Value:

    NULL if the substring was not found; a pointer to the SubString inside String
    if it was found

--*/

{
    SIZE_T len1, len2;
    PCTSTR end;

    MYASSERT (Separator);
    MYASSERT (SubStr);
    MYASSERT (!_tcschr (SubStr, Separator));

    len1 = lstrlen (SubStr);
    MYASSERT (SubStr[len1] == 0);

    while (String) {
        end = _tcschr (String, Separator);
        if (end) {
            len2 = end - String;
        } else {
            len2 = lstrlen (String);
        }
        if ((len1 == len2) &&
            (CaseSensitive ?
                !_tcsncmp (String, SubStr, len1) :
                !_tcsnicmp (String, SubStr, len1)
            )) {
            break;
        }
        if (end) {
            String = end + 1;
        } else {
            String = NULL;
        }
    }

    return String;
}


BOOL
UpdateDrvIndex (
    IN      PCTSTR InfPath,
    IN      PCTSTR CabFilename,
    IN      PCTSTR SourceSifPath
    )

/*++

Routine Description:

    This function fixes drvindex.inf such that SetupApi
    will pick up the file from the right cabinet

Arguments:

    InfPath - Specifies the full path to drvindex.inf

    CabFilename - Specifies the filename of the
                  updates cabinet (basically it's "updates.cab")

    SourceSifPath - Specifies the full path to the associated
                    updates.sif containing the list of files in updates.cab

Return Value:

    TRUE to indicate success; FALSE in case of failure; use GetLastError()
    to find the reason of failure

--*/

{
    HANDLE sectFile = INVALID_HANDLE_VALUE;
    HANDLE concatFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    PTSTR section = NULL;
    PBYTE base = NULL;
    TCHAR tempPath[MAX_PATH];
    TCHAR tempFile[MAX_PATH];
    TCHAR temp[MAX_PATH];
    PTSTR p;
    DWORD sectSize;
    DWORD concatSize;
    DWORD rc;
    DWORD bytes;
    BOOL b = FALSE;

    //
    // create a temp file to put the new section in it
    //
    if (!GetTempPath (ARRAYSIZE(tempPath), tempPath) ||
        !GetTempFileName (tempPath, TEXT("STP"), 0, tempFile)
        ) {
        return FALSE;
    }

    __try {

        if (!CopyFile (InfPath, tempFile, FALSE)) {
            __leave;
        }
        SetFileAttributes (tempFile, FILE_ATTRIBUTE_NORMAL);

        section = pSetupDuplicateString (CabFilename);
        if (!section) {
            __leave;
        }
        p = _tcsrchr (section, TEXT('.'));
        if (p) {
            *p = 0;
        }

        if (GetPrivateProfileString (
                        STR_CABS,
                        section,
                        TEXT(""),
                        temp,
                        ARRAYSIZE(temp),
                        tempFile
                        )) {
            if (lstrcmpi (temp, CabFilename) == 0) {
                if (GetPrivateProfileString (
                                STR_VERSION,
                                STR_CABFILES,
                                TEXT(""),
                                tempPath,
                                ARRAYSIZE(tempPath),
                                tempFile
                                )) {
                    if (FindSubString (tempPath, TEXT(','), section, FALSE)) {
                        //
                        // setup restarted, but drvindex.inf is already patched; nothing to do
                        //
                        b = TRUE;
                        __leave;
                    }
                }
            }
        }

        if (!WritePrivateProfileString (
                        STR_CABS,
                        section,
                        CabFilename,
                        tempFile
                        )) {
            __leave;
        }
        if (!GetPrivateProfileString (
                        STR_VERSION,
                        STR_CABFILES,
                        TEXT(""),
                        tempPath,
                        ARRAYSIZE(tempPath),
                        tempFile
                        )) {
            __leave;
        }
        if (!FindSubString (tempPath, TEXT(','), section, FALSE)) {
            wsprintf (temp, TEXT("%s,%s"), section, tempPath);
            if (!WritePrivateProfileString (
                            STR_VERSION,
                            STR_CABFILES,
                            temp,
                            tempFile
                            )) {
                __leave;
            }
        }

        sectFile = CreateFile (
                        SourceSifPath,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (sectFile == INVALID_HANDLE_VALUE) {
            __leave;
        }

        sectSize = GetFileSize (sectFile, NULL);
        if (sectSize == INVALID_FILE_SIZE) {
            __leave;
        }

        concatFile = CreateFile (
                        tempFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (concatFile == INVALID_HANDLE_VALUE) {
            __leave;
        }
        concatSize = GetFileSize (concatFile, NULL);
        if (concatSize == INVALID_FILE_SIZE) {
            __leave;
        }

        hMap = CreateFileMapping (concatFile, NULL, PAGE_READWRITE, 0, concatSize + sectSize, NULL);
        if (!hMap) {
            __leave;
        }

        base = MapViewOfFile (
                    hMap,
                    FILE_MAP_ALL_ACCESS,
                    0,
                    0,
                    0
                    );
        if (!base) {
            __leave;
        }

        //
        // make sure concatFile file didn't end in end-of-file
        //
        if (base[concatSize - 1] == 0x1A) {
            base[concatSize - 1] = ' ';
        }
        //
        // now append the other file
        //
        if (!ReadFile (sectFile, (LPVOID)(base + concatSize), sectSize, &bytes, NULL) || bytes != sectSize) {
            __leave;
        }
        //
        // now try to commit changes
        //
        if (!UnmapViewOfFile (base)) {
            __leave;
        }
        base = NULL;
        if (!CloseHandle (hMap)) {
            __leave;
        }
        hMap = NULL;
        //
        // close the handle to the temporary file and overwrite the real one
        //
        if (!CloseHandle (concatFile)) {
            __leave;
        }
        concatFile = INVALID_HANDLE_VALUE;
        SetFileAttributes (InfPath, FILE_ATTRIBUTE_NORMAL);
        b = MoveFileEx (tempFile, InfPath, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);
    }
    __finally {
        rc = b ? ERROR_SUCCESS : GetLastError ();
        DeleteFile (tempFile);
        if (base) {
            UnmapViewOfFile (base);
        }
        if (hMap) {
            CloseHandle (hMap);
        }
        if (concatFile != INVALID_HANDLE_VALUE) {
            CloseHandle (concatFile);
        }
        if (sectFile != INVALID_HANDLE_VALUE) {
            CloseHandle (sectFile);
        }
        if (section) {
            MyFree (section);
        }
        SetLastError (rc);
    }

    return b;
}


UINT
pExpandUpdatesCab (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            //
            // extract the file name
            //
            PCTSTR p = _tcsrchr (FileInCabInfo->NameInCabinet, TEXT('\\'));
            if (p) {
                p++;
            } else {
                p = FileInCabInfo->NameInCabinet;
            }

            lstrcpy (FileInCabInfo->FullTargetName, (PCTSTR)Context);
            pSetupConcatenatePaths (
                FileInCabInfo->FullTargetName,
                p,
                SIZECHARS (FileInCabInfo->FullTargetName),
                NULL
                );
            return FILEOP_DOIT;
        }

    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_SYSSETUP_CAB_MISSING,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber,
                NULL,
                NULL
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}

VOID
pInstallUpdatesInf (
    IN      PCTSTR SectionToInstall
    )

/*++

Routine Description:

    This function installs the specified section of STR_UPDATES_INF
    if this file is found inside updates.cab

Arguments:

    SectionToInstall - Specifies what section to install

Return Value:

    none

--*/

{
    TCHAR infPath[MAX_PATH];
    TCHAR commandLine[MAX_PATH + 30];
/*
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
*/

    MYASSERT (!MiniSetup && !OobeSetup);

    MYASSERT (g_DuShare[0]);

    if (BuildPath (infPath, ARRAYSIZE(infPath), g_DuShare, STR_UPDATES_INF) &&
        pDoesFileExist (infPath)) {
        //
        // install this INF as if the user chose "Install" on the right-click popup menu
        //
        if (SUCCEEDED (StringCchPrintf (
                            commandLine,
                            ARRAYSIZE(commandLine),
                            TEXT("RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection %s %u %s"),
                            SectionToInstall,
                            128,           // don't reboot
                            infPath
                            ))) {
            InvokeExternalApplicationEx (NULL, commandLine, NULL, INFINITE, FALSE);
        } else {
            MYASSERT (FALSE);
        }
/*
        ZeroMemory (&si, sizeof (si));
        si.cb = sizeof (si);
        if (CreateProcess (
                NULL,
                commandLine,
                NULL,
                NULL,
                FALSE,
                CREATE_NO_WINDOW | ABOVE_NORMAL_PRIORITY_CLASS,
                NULL,
                NULL,
                &si,
                &pi
                )) {
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);
*/
    } else {
        SetuplogError (
                LogSevInformation,
                TEXT("DUInfo: No %1 to install"),
                0,
                STR_UPDATES_INF,
                NULL,
                NULL
                );
    }
}


BOOL
DuInitialize (
    VOID
    )

/*++

Routine Description:

    This function initializes DU in GUI setup

Arguments:

    none

Return Value:

    TRUE to indicate success; FALSE in case of failure; use GetLastError()
    to find the reason of failure

--*/

{
    PTSTR cabFilename;
    TCHAR sourceCabPath[MAX_PATH];
    TCHAR workingDir[MAX_PATH];
    DWORD rc;

    MYASSERT (!MiniSetup && !OobeSetup);

    MYASSERT (AnswerFile[0]);

    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDSOURCES,
            TEXT(""),
            sourceCabPath,
            ARRAYSIZE(sourceCabPath),
            AnswerFile
            )) {
        return TRUE;
    }

    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_DYNUPDTWORKINGDIR,
            TEXT(""),
            workingDir,
            ARRAYSIZE(workingDir),
            AnswerFile
            )) {

        MYASSERT (FALSE);

        if (!GetWindowsDirectory (workingDir, ARRAYSIZE(workingDir))) {
            return FALSE;
        }
        if (!pSetupConcatenatePaths (workingDir, TEXT("setupupd"), ARRAYSIZE(workingDir), NULL)) {
            return FALSE;
        }

        WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTWORKINGDIR,
                workingDir,
                AnswerFile
                );
    }

    MYASSERT (workingDir[0]);
    if (!pSetupConcatenatePaths (workingDir, TEXT("updates"), ARRAYSIZE(workingDir), NULL) ||
        !pSetupConcatenatePaths (
            workingDir,
#if   defined(_AMD64_)
            TEXT("amd64"),
#elif defined(_X86_)
            TEXT("i386"),
#elif defined(_IA64_)
            TEXT("ia64"),
#else
#error "No Target Architecture"
#endif
            ARRAYSIZE(workingDir),
            NULL
            )) {
        return FALSE;
    }

    if (CreateMultiLevelDirectory (workingDir) != ERROR_SUCCESS) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: DuInitialize: failed to create %1 (%2!u!)\r\n"),
                0,
                workingDir,
                rc,
                NULL,
                NULL
                );
        return FALSE;
    }

    //
    // expand updates.cab in this folder
    //
    if (!SetupIterateCabinet (sourceCabPath, 0, pExpandUpdatesCab, (PVOID)workingDir)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: DuInitialize: failed to expand %1 to %2 (%3!u!)\r\n"),
                0,
                sourceCabPath,
                workingDir,
                rc,
                NULL,
                NULL
                );
        return FALSE;
    }

    //
    // OK, everything is set up; go ahead and set the global variable
    //
    MYASSERT (ARRAYSIZE(g_DuShare) >= ARRAYSIZE(workingDir));
    lstrcpy (g_DuShare, workingDir);

    return TRUE;
}


DWORD
DuInstallCatalogs (
    OUT     SetupapiVerifyProblem* Problem,
    OUT     PTSTR ProblemFile,
    IN      PCTSTR DescriptionForError         OPTIONAL
    )

/*++

Routine Description:

    This function installs any catalogs found inside updates.cab

Arguments:

    same as InstallProductCatalogs

Return Value:

    If successful, the return value is ERROR_SUCCESS, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/

{
    TCHAR catPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE h;
    UINT ErrorMessageId;
    DWORD rc = ERROR_SUCCESS;

    MYASSERT (!MiniSetup && !OobeSetup);

    if (!g_DuShare[0]) {
        return ERROR_SUCCESS;
    }

    if (!BuildPath (catPath, ARRAYSIZE(catPath), g_DuShare, TEXT("*.cat"))) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    h = FindFirstFile (catPath, &fd);
    if (h != INVALID_HANDLE_VALUE) {

        do {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                if (!BuildPath (catPath, ARRAYSIZE(catPath), g_DuShare, fd.cFileName)) {
                    SetuplogError (
                            LogSevWarning,
                            TEXT("DUWarning: ignoring catalog [%1\\%2] - path too long\r\n"),
                            0,
                            g_DuShare,
                            fd.cFileName,
                            NULL,
                            NULL
                            );
                    continue;
                }

                rc = pSetupVerifyCatalogFile (catPath);
                if (rc == NO_ERROR) {
                    rc = pSetupInstallCatalog(catPath, fd.cFileName, NULL);
                    if(rc != NO_ERROR) {
                        ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
                    }
                } else {
                    ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
                }

                if(rc != NO_ERROR) {

                    SetuplogError (
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            ErrorMessageId,
                            catPath,
                            rc,
                            NULL,
                            NULL
                            );
                    //
                    // Also, add an entry about this failure to setupapi's PSS
                    // exception logfile.
                    //
                    pSetupHandleFailedVerification (
                            MainWindowHandle,
                            SetupapiVerifyCatalogProblem,
                            catPath,
                            DescriptionForError,
                            pSetupGetCurrentDriverSigningPolicy(FALSE),
                            TRUE,  // no UI!
                            rc,
                            NULL,  // log context
                            NULL, // optional flags
                            NULL
                            );
                    break;
                }
            }
        } while (FindNextFile (h, &fd));

        FindClose (h);
    } else {
        SetuplogError (
                LogSevWarning,
                TEXT("DUWarning: no catalogs found in %1\r\n"),
                0,
                g_DuShare,
                NULL,
                NULL
                );
    }

    return rc;
}

DWORD
DuInstallUpdates (
    VOID
    )

/*++

Routine Description:

    This routine updates drvindex.inf to point setupapi to the new binaries.

Arguments:

    none

Return Value:

    If successful, the return value is ERROR_SUCCESS, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/

{
    PTSTR cabFilename;
    TCHAR sourceCabPath[MAX_PATH];
    TCHAR sourceSifPath[MAX_PATH];
    TCHAR cabPath[MAX_PATH];
    TCHAR infPath[MAX_PATH];
    TCHAR tmpPath[MAX_PATH];
    DWORD rc;

    MYASSERT (!MiniSetup && !OobeSetup);

    if (!g_DuShare[0]) {
        return ERROR_SUCCESS;
    }

    //
    // make sure updates.sif is available
    //
    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDSOURCES,
            TEXT(""),
            sourceCabPath,
            ARRAYSIZE(sourceCabPath),
            AnswerFile
            )) {
        return GetLastError ();
    }

    MYASSERT (ARRAYSIZE(sourceSifPath) >= ARRAYSIZE(sourceCabPath));
    lstrcpy (sourceSifPath, sourceCabPath);
    cabFilename = _tcsrchr (sourceSifPath, TEXT('.'));
    if (!cabFilename || _tcschr (cabFilename, TEXT('\\'))) {
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVALID_UPDATESCAB_NAME,
                sourceCabPath,
                NULL,
                NULL
                );
        return ERROR_INVALID_DATA;
    }
    lstrcpyn (cabFilename + 1, TEXT("sif"), (INT)(sourceSifPath + ARRAYSIZE(sourceSifPath) - (cabFilename + 1)));
    if (!pDoesFileExist (sourceSifPath)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_UPDATESSIF_NOT_FOUND,
                sourceSifPath,
                sourceCabPath,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    //
    // copy this where source cabs reside
    //
    rc = GetDriverCacheSourcePath (cabPath, ARRAYSIZE(cabPath));
    if (rc != ERROR_SUCCESS) {
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DRIVER_CACHE_NOT_FOUND,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    cabFilename = _tcsrchr (sourceCabPath, TEXT('\\'));
    if (cabFilename) {
        cabFilename++;
    } else {
        cabFilename = cabPath;
    }
    if (!pSetupConcatenatePaths (cabPath, cabFilename, ARRAYSIZE(cabPath), NULL)) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    //
    // GUI setup should be restartable; copy file, don't move it
    //
    SetFileAttributes (cabPath, FILE_ATTRIBUTE_NORMAL);
    if (!CopyFile (sourceCabPath, cabPath, FALSE)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FAILED_TO_COPY_UPDATES,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    //
    // now make sure the file attributes are set to RHS to protect it
    //
    SetFileAttributes (cabPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);

    //
    // temp folder for expanded files
    //
    if (!GetTempPath (ARRAYSIZE(tmpPath), tmpPath)) {
        rc = GetLastError ();
        return rc;
    }
    //
    // full path to drvindex.inf, assuming the file is in %windir%\inf
    //
    if (!GetWindowsDirectory (infPath, ARRAYSIZE(infPath))) {
        rc = GetLastError ();
        return rc;
    }
    if (FAILED (StringCchCat (infPath, ARRAYSIZE(infPath), TEXT("\\inf\\"))) ||
        FAILED (StringCchCat (infPath, ARRAYSIZE(infPath), STR_DRIVERCACHEINF)) ||
        GetFileAttributes (infPath) == (DWORD)-1) {

        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: %1 not found (rc=%2!u!)\r\n"),
                0,
                infPath,
                rc,
                NULL,
                NULL
                );
        return rc;
    }

    //
    // now patch drvindex.inf
    //
    if (!UpdateDrvIndex (infPath, cabFilename, sourceSifPath)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FAILED_TO_UPDATE_DRVINDEX,
                rc,
                NULL,
                NULL
                );
        SetFileAttributes (cabPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (cabPath);
        return rc;
    }

    //
    // finally run updates.inf (first part)
    //
    pInstallUpdatesInf (STR_DEFAULTINSTALL);

    return rc;
}


BOOL
DuInstallEndGuiSetupDrivers (
    VOID
    )

/*++

Routine Description:

    This routine installs any WU drivers not approved for the beginning of GUI setup.

Arguments:

    none

Return Value:

    If successful, the return value is TRUE

--*/

{
    DWORD chars;
    TCHAR datPath[MAX_PATH];
    TCHAR infPath[MAX_PATH];
    TCHAR buf[MAX_PATH * 16];
    PTSTR source, p, next;
    BOOL bRebootRequired;
    HWDBINF_ENUM e;
    PCTSTR pnpId;
    HMODULE hNewDev;
    HINF hGuiDrvsInf;
    INFCONTEXT ic;
    UINT line;
    BOOL (WINAPI* pfnUpdateDriver) (
        HWND hwndParent,
        LPCWSTR HardwareId,
        LPCWSTR FullInfPath,
        DWORD InstallFlags,
        PBOOL bRebootRequired OPTIONAL
        );

    //
    // try to append any additional POST GUI setup drivers
    // in the DevicePath
    //
    if (!SpSetupLoadParameter (
            WINNT_SP_DYNUPDTADDITIONALPOSTGUIDRIVERS,
            buf,
            ARRAYSIZE(buf)
            )) {
        return TRUE;
    }

    chars = lstrlen (buf);
    if (!chars) {
        return TRUE;
    }

    //
    // load the support library newdev.dll
    //
    hNewDev = LoadLibrary (TEXT("newdev.dll"));
    if (!hNewDev) {
        return FALSE;
    }
    (FARPROC)pfnUpdateDriver = GetProcAddress (hNewDev, "UpdateDriverForPlugAndPlayDevicesW");
    if (!pfnUpdateDriver) {
        FreeLibrary (hNewDev);
        return FALSE;
    }

    if (!HwdbInitializeW (NULL)) {
        SetuplogError (
                LogSevWarning,
                TEXT("DUWarning: HwdbInitialize failed (rc=%1!u!); no DU drivers will be installed\r\n"),
                0,
                GetLastError (),
                NULL,
                NULL
                );
        FreeLibrary (hNewDev);
        return FALSE;
    }

    //
    // look for driver-controlling inf
    //
    hGuiDrvsInf = INVALID_HANDLE_VALUE;
    if (SpSetupLoadParameter (
            WINNT_SP_DYNUPDTDRIVERINFOFILE,
            infPath,
            ARRAYSIZE(infPath)
            )) {
        if (pDoesFileExist (infPath)) {
            hGuiDrvsInf = SetupOpenInfFile (infPath, NULL, INF_STYLE_WIN4, &line);
            if (hGuiDrvsInf == INVALID_HANDLE_VALUE) {
                SetuplogError (
                        LogSevWarning,
                        TEXT("DUWarning: SetupOpenInfFile(%1) failed (rc=%2!u!); all DU drivers will be installed\r\n"),
                        0,
                        infPath,
                        GetLastError (),
                        NULL,
                        NULL
                        );
            }
        } else {
            SetuplogError (
                    LogSevWarning,
                    TEXT("DUWarning: File %1 missing; all DU drivers will be installed\r\n"),
                    0,
                    infPath,
                    NULL,
                    NULL
                    );
        }
    } else {
        SetuplogError (
                LogSevInformation,
                TEXT("DUInfo: File %1 missing; all DU drivers will be installed\r\n"),
                0,
                infPath,
                NULL,
                NULL
                );
    }
    source = buf;
    while (source) {
        next = _tcschr (source, TEXT(','));
        if (next) {
            *next = 0;
        }
        p = source;
        if (*p == TEXT('\"')) {
            p = ++source;
        }
        while (*p && *p != TEXT('\"')) {
            p++;
        }
        *p = 0;
        if (pDoesDirExist (source)) {
            if (BuildPath (datPath, ARRAYSIZE(datPath), source, S_HWCOMP_DAT) &&
                pDoesFileExist (datPath)) {

                //
                // OK, we have the file with hardware info
                //
                if (HwdbEnumFirstInf (&e, datPath)) {
                    do {
                        if (!BuildPath (infPath, ARRAYSIZE(infPath), source, e.InfFile) ||
                            !pDoesFileExist (infPath)) {
                            continue;
                        }
                        //
                        // iterate through all PNPIDs in this INF
                        //
                        for (pnpId = e.PnpIds; *pnpId; pnpId = _tcschr (pnpId, 0) + 1) {
                            //
                            // excluded PNPID are NOT in hwcomp.dat
                            // guidrvs.inf was already processed during winnt32
                            //
                            if (!pfnUpdateDriver (
                                    NULL,
                                    pnpId,
                                    infPath,
                                    0, // BUGBUG - if we specify INSTALLFLAG_NONINTERACTIVE and there is a driver signing problem, the API will fail!
                                    &bRebootRequired
                                    )) {
                                if (GetLastError() != ERROR_SUCCESS) {
                                    //
                                    // well, if the device we wanted to update the driver for
                                    // doesn't actually exist on this machine, don't log anything
                                    //
                                    if (GetLastError() != ERROR_NO_SUCH_DEVINST) {
                                        SetuplogError (
                                                LogSevWarning,
                                                TEXT("DUWarning: UpdateDriverForPlugAndPlayDevices failed (rc=%3!u!) for PNPID=%1 (INF=%2)\r\n"),
                                                0,
                                                pnpId,
                                                infPath,
                                                GetLastError (),
                                                NULL,
                                                NULL
                                                );
                                    }
                                } else {
                                    SetuplogError (
                                            LogSevInformation,
                                            TEXT("DUInfo: UpdateDriverForPlugAndPlayDevices did not update the driver for PNPID=%1\r\n"),
                                            0,
                                            pnpId,
                                            NULL,
                                            NULL
                                            );
                                }
                                continue;
                            }
                            //
                            // SUCCESS! - log this information
                            //
                            SetuplogError (
                                    LogSevInformation,
                                    TEXT("DUInfo: UpdateDriverForPlugAndPlayDevices succeeded for PNPID=%1\r\n"),
                                    0,
                                    pnpId,
                                    NULL,
                                    NULL
                                    );
                            //
                            // also update the PNF with the info that this is an INTERNET driver
                            //
                            if (!SetupCopyOEMInf (
                                    infPath,
                                    NULL,
                                    SPOST_URL,
                                    SP_COPY_REPLACEONLY,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL
                                    )) {
                                SetuplogError (
                                        LogSevInformation,
                                        TEXT("DUInfo: SetupCopyOEMInf failed to update OEMSourceMediaType for INF=%1\r\n"),
                                        0,
                                        infPath,
                                        NULL,
                                        NULL
                                        );
                            }
                        }
                    } while (HwdbEnumNextInf (&e));
                }
            }
        }
        if (next) {
            source = next + 1;
        } else {
            source = NULL;
        }
    }

    HwdbTerminate ();

    FreeLibrary (hNewDev);

    return TRUE;
}


VOID
DuCleanup (
    VOID
    )

/*++

Routine Description:

    This routine performs DU cleanup

Arguments:

    none

Return Value:

    none

--*/

{
    TCHAR buf[MAX_PATH * 16];
    DWORD chars;
    HKEY key;
    PTSTR devicePath;
    PTSTR p;
    DWORD rc;
    DWORD size;
    DWORD type;

    //
    // cleanup the file system
    //
    MYASSERT (AnswerFile[0]);
    if (GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_DYNUPDTWORKINGDIR,
            TEXT(""),
            buf,
            ARRAYSIZE(buf),
            AnswerFile
            )) {
        Delnode (buf);
    }
    //
    // cleanup the registry
    //
    chars = GetPrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS,
                TEXT(""),
                buf,
                ARRAYSIZE(buf),
                AnswerFile
                );
    if (chars > 0) {
        //
        // got it; now remove it from DevicePath
        //
        rc = RegOpenKey (HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &key);
        if (rc == ERROR_SUCCESS) {
            rc = RegQueryValueEx (key, REGSTR_VAL_DEVICEPATH, NULL, NULL, NULL, &size);
            if (rc == ERROR_SUCCESS) {
                devicePath = (PTSTR) MyMalloc (size);
                if (devicePath) {
                    rc = RegQueryValueEx (key, REGSTR_VAL_DEVICEPATH, NULL, &type, (LPBYTE)devicePath, &size);
                    if (rc == ERROR_SUCCESS && size / sizeof (TCHAR) >= chars + 1) {
                        p = _tcsstr (devicePath, buf);
                        if (p &&
                            (p == devicePath || *(p - 1) == TEXT(';')) &&
                            (!p[chars] || p[chars] == TEXT(';'))
                            ) {
                            if (p == devicePath) {
                                _tcscpy (p, p[chars] == TEXT(';') ? p + chars + 1 : p + chars);
                            } else {
                                _tcscpy (p - 1, p + chars);
                            }
                            size = (_tcslen (devicePath) + 1) * sizeof (TCHAR);
                            rc = RegSetValueEx (key, REGSTR_VAL_DEVICEPATH, 0, type, (PBYTE)devicePath, size);
                        }
                    }
                    MyFree (devicePath);
                }
            }
            RegCloseKey (key);
        }
    }

    g_DuShare[0] = 0;
}


BOOL
DuInstallDuAsms (
    VOID
    )

/*++

Routine Description:

    This routine installs additional DU assemblies

Arguments:

    none

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    TCHAR duasmsRoot[MAX_PATH];
    TCHAR duasmsSource[MAX_PATH];
    DWORD chars;
    SIDE_BY_SIDE SideBySide = {0};
    BOOL b1;
    BOOL b2;
    PTSTR p;
    PCTSTR source;
    BOOL fSuccess = TRUE;

    //
    // look for any assemblies root specified in the answer file
    //

    MYASSERT (AnswerFile[0]);
    if (GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDDUASMS,
            TEXT(""),
            duasmsRoot,
            ARRAYSIZE(duasmsRoot),
            AnswerFile
            )) {

        //
        // make sure this directory exists; remove any existing quotes first
        //
        p = duasmsRoot;
        if (*p == TEXT('\"')) {
            p++;
        }
        source = p;
        while (*p && *p != TEXT('\"')) {
            p++;
        }
        *p = 0;
        if (pDoesDirExist (source)) {
            //
            // root directory found
            // first copy them in a protected location, then install assemblies from there
            //
            DWORD rc;

            rc = GetDriverCacheSourcePath (duasmsSource, ARRAYSIZE(duasmsSource));
            if (rc != ERROR_SUCCESS) {
                SetuplogError (
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DRIVER_CACHE_NOT_FOUND,
                        rc,
                        NULL,
                        NULL
                        );
                return FALSE;
            }
            if (!pSetupConcatenatePaths (duasmsSource, TEXT("duasms"), ARRAYSIZE(duasmsSource), NULL)) {
                return FALSE;
            }

            //
            // first remove any already existing duasms "backup source" previously downloaded
            //
            Delnode (duasmsSource);
            //
            // now tree copy from the temp location to this "backup source"
            //
            rc = TreeCopy (source, duasmsSource);
            if (rc != ERROR_SUCCESS) {
                SetuplogError(
                        LogSevError,
                        TEXT("Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n"),
                        0,
                        rc,
                        source,
                        duasmsSource,
                        NULL,
                        NULL
                        );
                return FALSE;
            }

            //
            // install duasms from there
            //
            b1 = SideBySidePopulateCopyQueue (&SideBySide, NULL, duasmsSource);
            b2 = SideBySideFinish (&SideBySide, b1);

            if (!b1 || !b2) {
                fSuccess = FALSE;
                SetuplogError (
                        LogSevError,
                        TEXT("DUError: DuInstallDuAsms failed (rc=%1!u!)\r\n"),
                        0,
                        GetLastError (),
                        NULL,
                        NULL
                        );
            }
        } else {
            fSuccess = FALSE;
            SetuplogError (
                    LogSevError,
                    TEXT("DUError: Invalid directory %1; DuInstallDuAsms failed\r\n"),
                    0,
                    source,
                    NULL,
                    NULL
                    );
        }
    }

    return fSuccess;
}


BOOL
BuildPathToInstallationFileEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      BOOL UseDuShare
    )

/*++

Routine Description:

    This routine returns the path to the updated DU file, if one exists
    and the caller wanted this. Otherwise it will simply return the path
    to the CD file.

Arguments:

    Filename - Specifies the filename to look for

    PathBuffer - Receives the full path to the file

    PathBufferSize - Specifies the size in chars of the above buffer

    UseDuShare - Specifies TRUE if the function should check the DU
                 location first

Return Value:

    TRUE if building the path was successful. This does not guarantee the file exist.

--*/

{
    if (g_DuShare[0] && UseDuShare) {
        if (BuildPath (PathBuffer, PathBufferSize, g_DuShare, Filename) &&
            pDoesFileExist (PathBuffer)
            ) {
            return TRUE;
        }
    }
    return BuildPath (PathBuffer, PathBufferSize, LegacySourcePath, Filename);
}


PCTSTR
DuGetUpdatesPath (
    VOID
    )
{
    return g_DuShare[0] ? g_DuShare : NULL;
}

BOOL
DuDoesUpdatedFileExistEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,       OPTIONAL
    IN      DWORD PathBufferSize
    )

/*++

Routine Description:

    This routine checks if there exists an updated file with the given name.

Arguments:

    Filename - Specifies the filename to look for

    PathBuffer - Receives the full path to the file; optional

    PathBufferSize - Specifies the size in chars of the above buffer

Return Value:

    TRUE if a DU file with this name exists, FALSE otherwise

--*/

{
    TCHAR path[MAX_PATH];

    if (g_DuShare[0] &&
        BuildPath (path, ARRAYSIZE(path), g_DuShare, Filename) &&
        pDoesFileExist (path)
        ) {
        if (PathBuffer) {
            return SUCCEEDED (StringCchCopy (PathBuffer, PathBufferSize, path));
        }
        return TRUE;
    }
    return FALSE;
}


UINT
DuSetupPromptForDisk (
    HWND hwndParent,         // parent window of the dialog box
    PCTSTR DialogTitle,      // optional, title of the dialog box
    PCTSTR DiskName,         // optional, name of disk to insert
    PCTSTR PathToSource,   // optional, expected source path
    PCTSTR FileSought,       // name of file needed
    PCTSTR TagFile,          // optional, source media tag file
    DWORD DiskPromptStyle,   // specifies dialog box behavior
    PTSTR PathBuffer,        // receives the source location
    DWORD PathBufferSize,    // size of the supplied buffer
    PDWORD PathRequiredSize  // optional, buffer size needed
    )
{
    TCHAR buffer[MAX_PATH];
    DWORD size;

    if ((DiskPromptStyle & IDF_CHECKFIRST) &&
        PathBuffer &&
        PathBufferSize &&
        FileSought &&
        g_DuShare[0]
        ) {

        if (BuildPath (buffer, ARRAYSIZE(buffer), g_DuShare, FileSought) &&
            pDoesFileExist (buffer)
            ) {

            size = lstrlen (buffer) + 1;
            if (size > PathBufferSize) {
                if (PathRequiredSize) {
                    *PathRequiredSize = size;
                }
                return DPROMPT_BUFFERTOOSMALL;
            }
            CopyMemory (PathBuffer, buffer, size * sizeof (buffer[0]));
            return DPROMPT_SUCCESS;
        }
    }

    return SetupPromptForDisk (
                hwndParent,
                DialogTitle,
                DiskName,
                PathToSource,
                FileSought,
                TagFile,
                DiskPromptStyle,
                PathBuffer,
                PathBufferSize,
                PathRequiredSize
                );
}

VOID
DuInstallUpdatesInfFinal (
    VOID
    )

/*++

Routine Description:

    This function installs the final installation section of STR_UPDATES_INF
    if this file is found inside updates.cab

Arguments:

    none

Return Value:

    none

--*/

{
    if (!g_DuShare[0]) {
        SetuplogError (
                LogSevInformation,
                TEXT("DUInfo: %1 is disabled"),
                0,
                TEXT(__FUNCTION__),
                NULL,
                NULL
                );
        return;
    }
    pInstallUpdatesInf (STR_DEFAULTINSTALLFINAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\dynupdt.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Prototype of routines to handle dynamic update support during GUI setup phase

Author:

    Ovidiu Temereanca (ovidiut) 15-Aug-2000

Revision History:

--*/


BOOL
DuDoesUpdatedFileExistEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,       OPTIONAL
    IN      DWORD PathBufferSize
    );

#define DuDoesUpdatedFileExist(f) DuDoesUpdatedFileExistEx(f,NULL,0)

PCTSTR
DuGetUpdatesPath (
    VOID
    );

BOOL
BuildPathToInstallationFileEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      BOOL UseDuShare
    );

#define BuildPathToInstallationFile(f,p,s)  BuildPathToInstallationFileEx(f,p,s,TRUE)


BOOL
DuInitialize (
    VOID
    );

DWORD
DuInstallCatalogs (
    OUT     SetupapiVerifyProblem* Problem,
    OUT     PTSTR ProblemFile,
    IN      PCTSTR DescriptionForError         OPTIONAL
    );

DWORD
DuInstallUpdates (
    VOID
    );

VOID
DuInstallUpdatesInfFinal (
    VOID
    );

BOOL
DuInstallEndGuiSetupDrivers (
    VOID
    );

BOOL
DuInstallDuAsms (
    VOID
    );

VOID
DuCleanup (
    VOID
    );

UINT
DuSetupPromptForDisk (
    HWND hwndParent,         // parent window of the dialog box
    PCTSTR DialogTitle,      // optional, title of the dialog box
    PCTSTR DiskName,         // optional, name of disk to insert
    PCTSTR PathToSource,   // optional, expected source path
    PCTSTR FileSought,       // name of file needed
    PCTSTR TagFile,          // optional, source media tag file
    DWORD DiskPromptStyle,   // specifies dialog box behavior
    PTSTR PathBuffer,        // receives the source location
    DWORD PathBufferSize,    // size of the supplied buffer
    PDWORD PathRequiredSize  // optional, buffer size needed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\external.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    external.c

Abstract:

    Routines for handling external INFs

Author:

    Andrew Ritz (andrewr) 20-Nov-1998

Revision History:

    stole a bunch of code from optional.c for this

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>
#include <shlobj.h>



VOID
ReportError (
    IN  LogSeverity Severity,
    IN  PTSTR       MessageString,
    IN  UINT        MessageId,
    ...
    )

/*++

Routine Description:

    Records an error message in the setup action log if we're in Setup,
    or puts the message in a dialog box if we're in the cpl.

Arguments:

    Severity - the type of message being written

    ... - the message id and its arguments

Return Value:

    nothing.

--*/

{
    va_list arglist;

    va_start (arglist, MessageId);

    SetuplogErrorV(
        Severity,
        MessageString,
        MessageId,
        &arglist);

    va_end (arglist);
}


VOID
DoRunonce (
    )

/*++

Routine Description:

    Invokes runonce.

Arguments:

    none.

Return Value:

    nothing.

--*/

{
#define RUNONCE_TIMEOUT  60*1000*30  //30 minutes
    DWORD reRet = NO_ERROR;

    if((reRet = pSetupInstallStopEx( FALSE, INSTALLSTOP_NO_UI, NULL)) == NO_ERROR) {
        //
        // We successfully setup the registry values - now do runonce
        //
        InvokeExternalApplicationEx(NULL, L"RUNONCE -r", &reRet, RUNONCE_TIMEOUT, FALSE);

    } else {
        //
        // Log/report an error that registry mods failed for optional compononent.
        //
        ReportError(LogSevError,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_INF_REGISTRY_ERROR,
                    TEXT("HKEY_LOCAL_MACHINE\\") REGSTR_PATH_RUNONCE,
                    NULL,
                    SETUPLOG_USE_MESSAGEID,
                    reRet,
                    NULL,
                    NULL
                   );
    }

#ifdef _WIN64
    //
    // on win64, invoke the 32 bit version of runonce as well
    //
    {
        WCHAR Path[MAX_PATH+50];

        ExpandEnvironmentStrings(
                    L"%systemroot%\\SysWOW64\\RUNONCE.EXE -r",
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

        InvokeExternalApplicationEx(NULL, Path , &reRet, RUNONCE_TIMEOUT, FALSE);

    }
#endif
}



BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    )
{
    HINF *hInfs = NULL;
    PCWSTR *Sections = NULL, *InfNames = NULL;
    PCWSTR Inf,Section;
    PVOID p;
    INFCONTEXT Context;
    PVOID QContext = NULL;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    DWORD ScanQueueResult;
    LONG NumInfs, InfCount, i;
    DWORD LastErrorValue = ERROR_SUCCESS;
    BOOL b = FALSE;
    REGISTRATION_CONTEXT RegistrationContext;

    RtlZeroMemory(&RegistrationContext,sizeof(RegistrationContext));

    //
    // initialize a file queue
    //
    FileQueue = SetupOpenFileQueue();
    if (FileQueue == INVALID_HANDLE_VALUE) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
        goto e0;
    }

    //
    // Initialize the default queue callback.
    //
    QContext = InitSysSetupQueueCallbackEx(
                                hwndParent,
                                hProgress,
                                ProgressMessage,
                                0,NULL);
    if (!QContext) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
        goto e1;
    }

    //
    // process 'mandatory' component infs.
    //
    NumInfs = SetupGetLineCount(InfHandle, InfSection);
    if (NumInfs <= 0)
    {
        //
        // nothing in section.  return success for doing nothing
        //
        b = TRUE;
        goto e2;
    }

    hInfs = MyMalloc( sizeof(HINF) * NumInfs );
    Sections = MyMalloc( sizeof(PCWSTR) * NumInfs );
    InfNames = MyMalloc( sizeof(PCWSTR) * NumInfs );

    if (!hInfs) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
        goto e2;
    }

    if (!Sections) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
        goto e3;
    }

    if (!InfNames) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
        goto e4;
    }

    RemainingTime = CalcTimeRemaining(Phase_InstallComponentInfs);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing component files");
    InfCount = 0;
    if(SetupFindFirstLine(InfHandle,InfSection,NULL,&Context)) {
        do {
            if((Inf = pSetupGetField(&Context,1)) && (Section = pSetupGetField(&Context,2))) {
                MYASSERT(InfCount < NumInfs);

                //
                // save away the section name for later on
                //
                Sections[InfCount] = pSetupDuplicateString(Section);
                if (!Sections[InfCount]) {
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_INF_ALWAYS_ERROR, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
                    goto e6;
                }

                InfNames[InfCount] = pSetupDuplicateString(Inf);
                if (!InfNames[InfCount]) {
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_INF_ALWAYS_ERROR, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        ERROR_NOT_ENOUGH_MEMORY, NULL,NULL);
                    goto e6;
                }

                BEGIN_SECTION((PWSTR)Section);
                SetupDebugPrint2( TEXT("Installing Section [%s] from %s\n"), Section, Inf );

                //
                // queue files and save away the inf handle for later on
                //
                hInfs[InfCount] = SetupOpenInfFile(Inf,NULL,INF_STYLE_OLDNT|INF_STYLE_WIN4,NULL);
                if(hInfs[InfCount] && (hInfs[InfCount] != INVALID_HANDLE_VALUE)) {
                    PCWSTR Signature;
                    INFCONTEXT Cntxt;
                    HINF layout = NULL;
                    if (SetupFindFirstLine( hInfs[InfCount], L"Version",L"Signature", &Cntxt)) {
                        Signature = pSetupGetField(&Cntxt,1);
                        MYASSERT(Signature);
                        if (lstrcmpi(Signature,L"$Windows NT$") == 0) {
                            SetupOpenAppendInfFile(NULL,hInfs[InfCount],NULL);
                        } else {
                            layout = InfCacheOpenLayoutInf(hInfs[InfCount]);
                        }
                    }

                    b = SetupInstallFilesFromInfSection(
                                            hInfs[InfCount],
                                            layout,
                                            FileQueue,
                                            Section,
                                            NULL,
                                            SP_COPY_NEWER
                                            );
                    if (!b) {
                        //
                        // report error but continue with the rest of the infs
                        //
                        ReportError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_BAD_SECTION,
                            Section,
                            Inf,
                            NULL,
                            SETUPLOG_USE_MESSAGEID,
                            GetLastError(),
                            NULL,
                            NULL
                            );
                        SetupCloseInfFile(hInfs[InfCount]);
                        hInfs[InfCount] = INVALID_HANDLE_VALUE;
                    }
                } else {
                    //
                    // failed to open inf file
                    //
                    ReportError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_CANT_OPEN_INF, Inf,
                            NULL,NULL);
                    END_SECTION((PWSTR)Section);
                    goto e5;
                }
            }

            InfCount++;
            END_SECTION((PWSTR)Section);
        } while(SetupFindNextLine(&Context,&Context));
    } else {
        // We should have caught this case when we created the buffers!
        MYASSERT(FALSE);
    }

    //
    // queued all the files.  check if we really have to install any files. if not, we can save
    // the time required to commit the queue to disk
    //

    if(!SetupScanFileQueue(
           FileQueue,
           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
           hwndParent,
           NULL,
           NULL,
           &ScanQueueResult)) {
        //
        // SetupScanFileQueue should really never
        // fail when you don't ask it to call a
        // callback routine, but if it does, just
        // go ahead and commit the queue.
        //
        ScanQueueResult = 0;
    }

    if( ScanQueueResult != 1 ){
        b = SetupCommitFileQueue(
                hwndParent,
                FileQueue,
                SysSetupQueueCallback,
                QContext
                );

    }
    LastErrorValue = b ? NO_ERROR : GetLastError();
    END_SECTION(L"Installing component files");

    TermSysSetupQueueCallback(QContext);
    QContext = NULL;

    //
    // Delete the file queue.
    //
    if(FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
        FileQueue = INVALID_HANDLE_VALUE;
    }

    if (!b) {
        //
        // error commiting the queue.  we can't continue at this point since the next operations
        // might require the files that we (didn't) copy
        //
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, NULL,
            SETUPLOG_USE_MESSAGEID,
            LastErrorValue, NULL,NULL);
        goto e6;
    }

    BEGIN_SECTION(L"Installing component reg settings");
    for (i = 0; i< InfCount; i++) {
        INFCONTEXT Cntxt;
        TCHAR ScratchSectionName[100];
        if (hInfs[i] != INVALID_HANDLE_VALUE) {

            //
            // if the section contains an Addservice or DelService directive,
            // we must explicitly install it since SetupInstallFromInfSection
            // does not process services.  Note that we create the service
            // BEFORE we do the other stuff in the section, in case that
            // "other stuff" wants to use the service.
            //
            lstrcpy( ScratchSectionName, Sections[i]);
            lstrcat( ScratchSectionName, TEXT(".Services"));
            if (SetupFindFirstLine(
                        hInfs[i],
                        ScratchSectionName,
                        L"AddService",
                        &Cntxt) ||
                SetupFindFirstLine(
                        hInfs[i],
                        Sections[i],
                        ScratchSectionName,
                        &Cntxt)) {

                b = SetupInstallServicesFromInfSectionEx(
                                                    hInfs[i],
                                                    ScratchSectionName,
                                                    0,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL);
                if (!b) {
                    //
                    // log an error and continue
                    //
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_BAD_SECTION,
                        Sections[i],InfNames[i], NULL,
                        SETUPLOG_USE_MESSAGEID,
                        GetLastError(), NULL,NULL);
                }
            }


            b = SetupInstallFromInfSection(
                                hwndParent,
                                hInfs[i],
                                Sections[i],
                                (SPINST_ALL & ~SPINST_FILES) | SPINST_REGISTERCALLBACKAWARE,
                                NULL,
                                NULL,
                                0,
                                RegistrationQueueCallback,
                                (PVOID)&RegistrationContext,
                                NULL,
                                NULL
                                );
            if (!b) {
                //
                // log an error and continue
                //
                ReportError(
                    LogSevError,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_BAD_SECTION,
                    Sections[i],InfNames[i], NULL,
                    SETUPLOG_USE_MESSAGEID,
                    GetLastError(), NULL,NULL);
            }

        }
    }
    END_SECTION(L"Installing component reg settings");

    b = TRUE;

e6:
    for (i = 0; i < InfCount; i++) {

        MYASSERT(Sections != NULL);
        MYASSERT(InfNames != NULL);
        MYASSERT(hInfs != INVALID_HANDLE_VALUE);

        if (Sections[i]) {
            MyFree(Sections[i]);
        }

        if (InfNames[i]) {
            MyFree(InfNames[i]);
        }

        if (hInfs[i] != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(hInfs[i]);
        }

    }

e5:
    if (InfNames) {
        MyFree(InfNames);
    }
e4:
    if (Sections) {
        MyFree(Sections);
    }
e3:
    if (hInfs) {
        MyFree(hInfs);
    }
e2:
    if (QContext) {
        TermSysSetupQueueCallback(QContext);
    }
e1:
    if (FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
    }
e0:
    return(b);

}


BOOL
SetupCreateOptionalComponentsPage(
    IN LPFNADDPROPSHEETPAGE AddPageCallback,
    IN LPARAM               Context
    )
{

    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );

    return( FALSE );

}

BOOL
ProcessCompatibilityInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage
    )
{
    WCHAR UnattendFile[MAX_PATH];
    PCWSTR SectionName = pwCompatibility;
    HINF UnattendInf;


    GetSystemDirectory(UnattendFile,MAX_PATH);
    pSetupConcatenatePaths(UnattendFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    UnattendInf = SetupOpenInfFile(UnattendFile,NULL,INF_STYLE_OLDNT,NULL);
    if(UnattendInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DoInstallComponentInfs(hwndParent,
                           hProgress,
                           ProgressMessage,
                           UnattendInf,
                           SectionName );

    SetupCloseInfFile( UnattendInf );

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\extprog.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    extprog.c

Abstract:

    Routines for invoking external applications.
    Entry points in this module:

        InvokeExternalApplication
        InvokeControlPanelApplet

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

PCWSTR szWaitOnApp = L"WaitOnApp";


DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode,
    IN  DWORD  Timeout
    )
{
    DWORD dw;
    BOOL Done;

    MYASSERT( ExitCode != NULL );

    //
    // Process any messages that may already be in the queue.
    //
    PumpMessageQueue();

    //
    // Wait for process to terminate or more messages in the queue.
    //
    Done = FALSE;
    do {
        switch(MsgWaitForMultipleObjects(1,&Process,FALSE,Timeout,QS_ALLINPUT)) {

        case WAIT_OBJECT_0:
            //
            // Process has terminated.
            //
            dw = GetExitCodeProcess(Process,ExitCode) ? NO_ERROR : GetLastError();
            Done = TRUE;
            break;

        case WAIT_OBJECT_0+1:
            //
            // Messages in the queue.
            //
            PumpMessageQueue();
            break;

        case WAIT_TIMEOUT:
            dw = WAIT_TIMEOUT;
            *ExitCode = WAIT_TIMEOUT;
            Done = TRUE;
            break;

        default:
            //
            // Error.
            //
            dw = GetLastError();
            Done = TRUE;
            break;
        }
    } while(!Done);

    return(dw);
}


BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    )

/*++

Routine Description:

    See InvokeExternalApplicationEx

--*/

{
    //
    // infinite timeout
    //
    return(InvokeExternalApplicationEx(
                            ApplicationName,
                            CommandLine,
                            ExitCode,
                            INFINITE,
                            FALSE));

}

BOOL
InvokeExternalApplicationEx(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode,         OPTIONAL
    IN     DWORD  Timeout,
    IN     BOOL   Hidden
    )

/*++

Routine Description:

    Invokes an external program, which is optionally detached.

Arguments:

    ApplicationName - supplies app name. May be a partial or full path,
        or just a filename, in which case the standard win32 path search
        is performed. If not specified then the first element in
        CommandLine must specify the binary to execute.

    CommandLine - supplies the command line to be passed to the
        application.

    ExitCode - If specified, the execution is synchronous and this value
        receives the exit code of the application. If not specified,
        the execution is asynchronous.

    Timeout - specifies how long to wait for the app to complete.

    Hidden - if TRUE, indicates that the application should be invoked with
             the SW_HIDE attribute set.

Return Value:

    Boolean value indicating whether the process was started successfully.

--*/

{
    PWSTR FullCommandLine;
    BOOL b;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    DWORD d;

    b = FALSE;
    //
    // Form the command line to be passed to CreateProcess.
    //
    if(ApplicationName) {
        FullCommandLine = MyMalloc((lstrlen(ApplicationName)+lstrlen(CommandLine)+2)*sizeof(WCHAR));
        if(!FullCommandLine) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPP_FAIL,
                ApplicationName,NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
            goto err0;
        }

        lstrcpy(FullCommandLine,ApplicationName);
        lstrcat(FullCommandLine,L" ");
        lstrcat(FullCommandLine,CommandLine);
    } else {
        FullCommandLine = pSetupDuplicateString(CommandLine);
        if(!FullCommandLine) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPP_FAIL,
                CommandLine, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
            goto err0;
        }
    }

    //
    // Initialize startup info.
    //
    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);
    if (Hidden) {
        //
        // no UI
        //
        GetStartupInfo(&StartupInfo);
        StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_HIDE;
    }

    //
    // Create the process.
    //
    b = CreateProcess(
            NULL,
            FullCommandLine,
            NULL,
            NULL,
            FALSE,
            ExitCode ? 0 : DETACHED_PROCESS,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInfo
            );

    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_FAIL,
            FullCommandLine, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szCreateProcess,
            GetLastError(),
            NULL,NULL);
        goto err1;
    }

    //
    // If execution is asynchronus, we're done.
    //
    if(!ExitCode) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_SUCCEED,
            FullCommandLine,
            NULL,NULL);
        goto err2;
    }

    //
    // Need to wait for the app to finish.
    // If the wait failed don't return an error but log a warning.
    //
    d = WaitOnApp(ProcessInfo.hProcess,ExitCode,Timeout);
    if(d != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_FAIL,
            FullCommandLine, 0,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szWaitOnApp,
            d,
            NULL,NULL);
    } else {
        SetuplogError(
            LogSevInformation | SETUPLOG_SINGLE_MESSAGE,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_SUCCEED_STATUS,
            FullCommandLine,
            *ExitCode,
            NULL,
            NULL);
    }

    //
    // Put setup back in the foreground.
    //
    SetForegroundWindow(MainWindowHandle);

err2:
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
err1:
    MyFree(FullCommandLine);
err0:
    return(b);
}


BOOL
InvokeControlPanelApplet(
    IN PCWSTR CplSpec,
    IN PCWSTR AppletName,           OPTIONAL
    IN UINT   AppletNameStringId,
    IN PCWSTR CommandLine
    )
{
    PWSTR FullCommandLine;
    BOOL b;
    BOOL LoadedAppletName;
    DWORD ExitCode;

    b = FALSE;

    LoadedAppletName = FALSE;
    if(!AppletName) {
        if(AppletName = MyLoadString(AppletNameStringId)) {
            LoadedAppletName = TRUE;
        }
    }

    if(AppletName) {

        FullCommandLine = MyMalloc((lstrlen(CplSpec)+lstrlen(AppletName)+lstrlen(CommandLine)+3) * sizeof(WCHAR));
        if(FullCommandLine) {
            lstrcpy(FullCommandLine,CplSpec);
            lstrcat(FullCommandLine,L",");
            lstrcat(FullCommandLine,AppletName);
            lstrcat(FullCommandLine,L",");
            lstrcat(FullCommandLine,CommandLine);
            b = InvokeExternalApplication(L"RUNDLL32 shell32,Control_RunDLL",FullCommandLine,&ExitCode);
            MyFree(FullCommandLine);
        } else {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPPLET_FAIL,
                AppletName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
        }
    } else {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPPLET_FAIL,
            L"", NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
    }

    if(LoadedAppletName) {
        MyFree(AppletName);
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\fileops.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fileops.c

Abstract:

    Miscellaneous file operations.

    Entry points:

        Delnode

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"

//
//  This include is needed for ValidateAndChecksumFile()
//
#include <imagehlp.h>
#include <shlwapi.h>

#pragma hdrstop



VOID
pSetInstallAttributes(
    VOID
    )

/*++

Routine Description:

    Set default attributes on a huge list of files.  The shell
    had been doing this, but it's probably better to do it here
    so that the the user doesn't have his attributes reset everytime
    he logs in.

Arguments:

    None.

Return Value:

    None.

--*/

{
#define _R   (FILE_ATTRIBUTE_READONLY)
#define _S   (FILE_ATTRIBUTE_SYSTEM)
#define _H   (FILE_ATTRIBUTE_HIDDEN)
#define _SH  (_S | _H)
#define _SHR (_S | _H | _R)

struct {
    WCHAR   FileName[20];
    BOOL    DeleteIfEmpty;
    DWORD   Attributes;
} FilesToFix[] = {
//    { L"X:\\autoexec.bat",   TRUE,   _H  }, 16bit apps break if hidden: jarbats bug148787
    { L"X:\\autoexec.000",   TRUE,   _SH },
    { L"X:\\autoexec.old",   TRUE,   _SH },
    { L"X:\\autoexec.bak",   TRUE,   _SH },
    { L"X:\\autoexec.dos",   TRUE,   _SH },
    { L"X:\\autoexec.win",   TRUE,   _SH },
//    { L"X:\\config.sys",     TRUE,   _H  }, 16bit apps break if hidden: jarbats bug 148787
    { L"X:\\config.dos",     TRUE,   _SH },
    { L"X:\\config.win",     TRUE,   _SH },
    { L"X:\\command.com",    FALSE,  _SH },
    { L"X:\\command.dos",    FALSE,  _SH },
    { L"X:\\logo.sys",       FALSE,  _SH },
    { L"X:\\msdos.---",      FALSE,  _SH },  // Win9x backup of msdos.*
    { L"X:\\boot.ini",       FALSE,  _SH },
    { L"X:\\boot.bak",       FALSE,  _SH },
    { L"X:\\boot.---",       FALSE,  _SH },
    { L"X:\\bootsect.dos",   FALSE,  _SH },
    { L"X:\\bootlog.txt",    FALSE,  _SH },  // Win9x first boot log
    { L"X:\\bootlog.prv",    FALSE,  _SH },
    { L"X:\\ffastun.ffa",    FALSE,  _SH },  // Office 97 only used hidden, O2K uses SH
    { L"X:\\ffastun.ffl",    FALSE,  _SH },
    { L"X:\\ffastun.ffx",    FALSE,  _SH },
    { L"X:\\ffastun0.ffx",   FALSE,  _SH },
    { L"X:\\ffstunt.ffl",    FALSE,  _SH },
    { L"X:\\sms.ini",        FALSE,  _SH },  // SMS
    { L"X:\\sms.new",        FALSE,  _SH },
    { L"X:\\sms_time.dat",   FALSE,  _SH },
    { L"X:\\smsdel.dat",     FALSE,  _SH },
    { L"X:\\mpcsetup.log",   FALSE,  _H  },  // Microsoft Proxy Server
    { L"X:\\detlog.txt",     FALSE,  _SH },  // Win9x PNP detection log
    { L"X:\\detlog.old",     FALSE,  _SH },  // Win9x PNP detection log
    { L"X:\\setuplog.txt",   FALSE,  _SH },  // Win9x setup log
    { L"X:\\setuplog.old",   FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.dat",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.---",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.bak",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\system.1st",     FALSE,  _SH },  // Win95 system.dat backup
    { L"X:\\netlog.txt",     FALSE,  _SH },  // Win9x network setup log file
    { L"X:\\setup.aif",      FALSE,  _SH },  // NT4 unattended setup script
    { L"X:\\catlog.wci",     FALSE,  _H  },  // index server folder
    { L"X:\\cmsstorage.lst", FALSE,  _SH },  // Microsoft Media Manager
};

WCHAR   szWinDir[MAX_PATH];
DWORD   i, j;
DWORD   Result;

    //
    // Get the drive letter that we installed on.
    //
    Result = GetWindowsDirectory(szWinDir, MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return;
    }

    for( i = 0; i < (sizeof(FilesToFix)/sizeof(FilesToFix[0])); i++ ) {
        //
        // First we need to fixup the path.  This is really gross, but lots
        // of these files will be on the system partition and lots will be
        // on the partition where we installed, which may not be the same.
        // Rather than figuring out which of these live on which partition
        // and ensuring that this is true for all flavors of NT, just
        // process both locations.
        //
        for( j = 0; j < 2; j++ ) {
            if( j & 1 ) {
                FilesToFix[i].FileName[0] = szWinDir[0];
            } else {
#if defined(_AMD64_) || defined(_X86_)
                FilesToFix[i].FileName[0] = x86SystemPartitionDrive;
#else
                FilesToFix[i].FileName[0] = L'C';
#endif
            }

            //
            // Now set the attributes.
            //
            SetFileAttributes( FilesToFix[i].FileName, FilesToFix[i].Attributes );
        }

    }

}



DWORD
TreeCopy(
    IN PCWSTR SourceDir,
    IN PCWSTR TargetDir
    )
{
    DWORD d;
    WCHAR Pattern[MAX_PATH];
    WCHAR NewTarget[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // First create the target directory if it doesn't already exist.
    //
    if(!CreateDirectory(TargetDir,NULL)) {
        d = GetLastError();
        if(d != ERROR_ALREADY_EXISTS) {
            return(d);
        }
    }

    //
    // Copy each file in the source directory to the target directory.
    // If any directories are encountered along the way recurse to copy them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <sourcedir>\*.
    //
    lstrcpyn(Pattern,SourceDir,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {

        d = NO_ERROR;

    } else {

        do {

            //
            // Form the full name of the file or directory we just found
            // as well as its name in the target.
            //
            lstrcpyn(Pattern,SourceDir,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            lstrcpyn(NewTarget,TargetDir,MAX_PATH);
            pSetupConcatenatePaths(NewTarget,FindData.cFileName,MAX_PATH,NULL);

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    d = TreeCopy(Pattern,NewTarget);
                } else {
                    d = NO_ERROR;
                }

            } else {

                //
                // The current match is not a directory -- so copy it.
                //
                SetFileAttributes(NewTarget,FILE_ATTRIBUTE_NORMAL);
                d = CopyFile(Pattern,NewTarget,FALSE) ? NO_ERROR : GetLastError();
            }
        } while((d==NO_ERROR) && FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    return(d);
}


VOID
DelSubNodes(
    IN PCWSTR Directory
    )
{
    WCHAR Pattern[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // Delete each file in the given directory, but DO NOT remove the directory itself.
    // If any directories are encountered along the way recurse to delete them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <currentdir>\*.
    //
    lstrcpyn(Pattern,Directory,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //
            lstrcpyn(Pattern,Directory,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            //
            // Remove read-only atttribute if it's there.
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    Delnode(Pattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                if(!DeleteFile(Pattern)) {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DELNODE_FAIL,
                        Pattern, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szDeleteFile,
                        GetLastError(),
                        Pattern,
                        NULL,NULL);
                }
            }
        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

}


VOID
Delnode(
    IN PCWSTR Directory
    )
{
    WCHAR Pattern[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // Delete each file in the given directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <currentdir>\*.
    //
    lstrcpyn(Pattern,Directory,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //
            lstrcpyn(Pattern,Directory,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            //
            // Remove read-only atttribute if it's there.
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if( (FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
                    if( !RemoveDirectory(Pattern)) {
                        SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DELNODE_FAIL,
                        Pattern, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szRemoveDirectory,
                        GetLastError(),
                        Pattern,
                        NULL,NULL);
                    }
                } else {
                    //
                    // The current match is a directory.  Recurse into it unless
                    // it's . or ...
                    //
                    if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                        Delnode(Pattern);
                    }
                }
    
            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                if(!DeleteFile(Pattern)) {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DELNODE_FAIL,
                        Pattern, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szDeleteFile,
                        GetLastError(),
                        Pattern,
                        NULL,NULL);
                }
            }
        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //
    SetFileAttributes(Directory,FILE_ATTRIBUTE_NORMAL);
    RemoveDirectory(Directory);
}


VOID
RemoveServicePackEntries(
    HKEY hKey
    )
/*
    This routine takes in the Handle to the Software\Microsoft\Windows NT\CurrentVersion\Hotfix\ServicePackUninstall
    key and then enumerates each value entry under it.

    It then takes the value data and appends that to the

    "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" and delnodes that key. This
    way we have an extensible mechanism to always cleanup the Uninstall keys for ServicePacks.


*/
{

#define UNINSTALLKEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\"
#define UNINSTALLKEYLEN     (sizeof(UNINSTALLKEY) / sizeof(WCHAR) - 1)

    DWORD Status,MaxValueName=0,MaxValue=0,Values=0,i;
    DWORD TempMaxNameSize, TempMaxDataSize;
    PWSTR ValueName, ValueData;


    Status = RegQueryInfoKey( hKey,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &Values,
                            &MaxValueName,
                            &MaxValue,
                            NULL,
                            NULL );

     //Account forterminating null

     if( Status == ERROR_SUCCESS ){

         MaxValueName += 2;
         MaxValue = MaxValue + 2 + lstrlen(UNINSTALLKEY);

         ValueName = MyMalloc( MaxValueName * sizeof(WCHAR) );
         ValueData = MyMalloc( MaxValue * sizeof(WCHAR) );

         if( !ValueName || !ValueData )
             return;

         lstrcpy( ValueData, UNINSTALLKEY );


         for (i=0; i < Values; i++){

             TempMaxNameSize = MaxValueName;
             TempMaxDataSize = MaxValue;

             Status = RegEnumValue( hKey,
                                    i,
                                    ValueName,
                                    &TempMaxNameSize,
                                    NULL,
                                    NULL,
                                    (LPBYTE)(ValueData+lstrlen(UNINSTALLKEY)),
                                    &TempMaxDataSize
                                    );

             // Don't do delnode if valuedata is null
             if( Status == ERROR_SUCCESS && ValueData[lstrlen(UNINSTALLKEY)] ){

                 pSetupRegistryDelnode( HKEY_LOCAL_MACHINE, ValueData );

              }

          }

      }
      MyFree( ValueName );
      MyFree( ValueData );
      return;

}







VOID
RemoveHotfixData(
    VOID
    )
{
    WCHAR Path[MAX_PATH];
    WCHAR KBNumber[64];
    WCHAR UninstallKey[MAX_PATH];
    DWORD i = 0;
    DWORD prefixSize = 0;
    DWORD Status, SubKeys;
    HKEY hKey, SvcPckKey;
    REGVALITEM SoftwareKeyItems[1];

    //
    //For each hotfix, the registry info is stored under
    //                 HKLM\Software\Microsoft\Windows NT\CurrentVersion\Hotfix\<KB#>
    //                 and the files are stored under
    //                 %windir%\$NtUninstall<KB#>$

    //
    //Enumerate the hotfix key and remove the files and registry entries for each hotfix.
    //
#define HOTFIXAPPKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix"

    Status = RegOpenKey(HKEY_LOCAL_MACHINE, HOTFIXAPPKEY, &hKey);
    if( Status != ERROR_SUCCESS ) {
        return;
    }

    Status = RegQueryInfoKey( hKey,
                              NULL,
                              NULL,
                              NULL,
                              &SubKeys,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if(Status == ERROR_SUCCESS) {

       Status = GetWindowsDirectory(Path, MAX_PATH);
       if(Status == 0) {
           MYASSERT(FALSE);
           return;
       }
       pSetupConcatenatePaths(Path,L"$NtUninstall",MAX_PATH,&prefixSize);
       lstrcpy(UninstallKey, UNINSTALLKEY);

       for( i = 0; i < SubKeys; i++ ) {

              Status = RegEnumKey(hKey, i, KBNumber, sizeof(KBNumber) / sizeof(KBNumber[0]));

              if (Status == ERROR_SUCCESS) {

                  if( !lstrcmpi( KBNumber, TEXT("ServicePackUninstall") ) ){
                      Status = RegOpenKey(hKey,KBNumber,&SvcPckKey);
                      if( Status == ERROR_SUCCESS ){
                        RemoveServicePackEntries(SvcPckKey);
                        RegCloseKey(SvcPckKey);
                      }

                  }else{
                      lstrcpyn(Path + prefixSize - 1, KBNumber, MAX_PATH - prefixSize);
                      lstrcat(Path, L"$");
                      Delnode(Path);
                      //
                      // Remove the entry from the Add/Remove Programs key.
                      // UNINSTALLKEY ends with '\\'
                      //
                      lstrcpy(UninstallKey + UNINSTALLKEYLEN, KBNumber);
                      pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, UninstallKey);
                  }
              }
       }

    }

    RegCloseKey(hKey);
    pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, HOTFIXAPPKEY);

    //
    // delete HKLM\SOFTWARE\Microsoft\Updates\Windows 2000 key since it contains entries for SPs/QFEs for win2k
    //
    pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Updates\\Windows 2000");

    //
    // We need to hack something for Exchange because they check for
    // a hotfix (irregardless of the OS version...
    //
    i = 1;
    SoftwareKeyItems[0].Name = L"Installed";
    SoftwareKeyItems[0].Data = &i;
    SoftwareKeyItems[0].Size = sizeof(DWORD);
    SoftwareKeyItems[0].Type = REG_DWORD;
    SetGroupOfValues(HKEY_LOCAL_MACHINE,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q147222",SoftwareKeyItems,1);

}




VOID
DeleteLocalSource(
    VOID
    )
{
    WCHAR str[4];

    if(WinntBased && !AllowRollback) {
        if(SourcePath[0] && (SourcePath[1] == L':') && (SourcePath[2] == L'\\')) {

            lstrcpyn(str,SourcePath,4);
            if(GetDriveType(str) != DRIVE_CDROM) {
                Delnode(SourcePath);
#ifdef _X86_
                if (IsNEC_98 && !lstrcmpi(&SourcePath[2], pwLocalSource)) {
                    HKEY hkey;
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,MAXIMUM_ALLOWED,&hkey) == NO_ERROR) {
                        RegDeleteValue(hkey, L"ForcePlatform");
                        RegCloseKey(hkey);
                    }
                }
#endif
            }
        }

        //
        // Remove %systemroot%\winsxs\setuppolicies before rebooting
        //
        {
            WCHAR SetupPoliciesPath[MAX_PATH];
            GetSystemWindowsDirectoryW(SetupPoliciesPath, MAX_PATH);
            pSetupConcatenatePaths(SetupPoliciesPath, L"WinSxS\\SetupPolicies", MAX_PATH, NULL);
            Delnode(SetupPoliciesPath);
        }


#if defined(_AMD64_) || defined(_X86_)
        //
        // Get rid of floppyless boot stuff.
        //
        if(FloppylessBootPath[0]) {

            WCHAR Path[MAX_PATH];

            //
            // NEC98 should back boot related files in \$WIN_NT$.~BU,
            // to restore boot files for keep original OS in each partition.
            //
            if (IsNEC_98) { //NEC98
                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"$WIN_NT$.~BU",MAX_PATH,NULL);
                Delnode(Path);
            } //NEC98

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"$WIN_NT$.~BT",MAX_PATH,NULL);
            Delnode(Path);

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"$LDR$",MAX_PATH,NULL);
            SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Path);

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"TXTSETUP.SIF",MAX_PATH,NULL);
            SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Path);

            //
            // Get rid of arc loader files.
            //
            if( !IsArc() ) {

                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"ARCLDR.EXE",MAX_PATH,NULL);
                SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Path);

                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"ARCSETUP.EXE",MAX_PATH,NULL);
                SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Path);

            }
        }

        //
        // get rid of the boot.bak file
        //
        {
            WCHAR szBootBak[] = L"?:\\BOOT.BAK";

            szBootBak[0] = x86SystemPartitionDrive;
            SetFileAttributes(szBootBak,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szBootBak);
        }
#endif  // defined(_AMD64_) || defined(_X86_)

#if defined(_IA64_)
        //
        // Get rid of SETUPLDR
        //
        {
            WCHAR Path[MAX_PATH];
            UNICODE_STRING UnicodeString;
            WCHAR Buffer[MAX_PATH];
            PWCHAR pwChar;
            PWSTR NtPath;
            BOOLEAN OldPriv, DontCare;
            OBJECT_ATTRIBUTES ObjAttrib;


            Buffer[0] = UNICODE_NULL;

            //
            // Make sure we have privilege to get/set nvram vars.
            //
            RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &OldPriv
                );

            RtlInitUnicodeString(&UnicodeString,L"SYSTEMPARTITION");
            NtQuerySystemEnvironmentValue(
               &UnicodeString,
               Buffer,
               sizeof(Buffer)/sizeof(WCHAR),
               NULL
               );

            //
            // Restore previous privilege.
            //
            RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                OldPriv,
                FALSE,
                &DontCare
                );

            //
            // Strip everything from ';' to end of string since previous strings
            // are appended to the current string and are separated by ';'.
            //
            pwChar = Buffer;
            while ((*pwChar != L'\0') && (*pwChar != L';')) {
                pwChar++;
            }
            *pwChar = L'\0';

            NtPath = ArcDevicePathToNtPath(Buffer);
            if (NtPath) {

                lstrcpy(Path,NtPath);
                pSetupConcatenatePaths(Path,SETUPLDR,MAX_PATH,NULL);
                RtlInitUnicodeString(&UnicodeString,Path);
                InitializeObjectAttributes(
                    &ObjAttrib,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );
                NtDeleteFile(&ObjAttrib);

                MyFree( NtPath );

            }
        }
#endif  // defined(_IA64_)

    }
}


BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage - Receives flag indicating whether the file is an
                NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
            image (for nt images) and that we can read the image.

Return Value:

    BOOL - Returns TRUE if the flie was validated, and in this case,
           IsNtImage, Checksum, and Valid will contain the result of
           the validation.
           This function will return FALSE, if the file could not be
           validated, and in this case, the caller should call GetLastError()
           to find out why this function failed.

--*/

{
    DWORD  Error;
    PVOID BaseAddress;
    ULONG FileSize;
    HANDLE hFile,hSection;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;

    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //

    Error = pSetupOpenAndMapFileForRead( Filename,
                                    &FileSize,
                                    &hFile,
                                    &hSection,
                                    &BaseAddress );

    if( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        return(FALSE);
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return(TRUE);
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    pSetupUnmapAndCloseFile( hFile, hSection, BaseAddress );
    return( TRUE );
}


DWORD
QueryHardDiskNumber(
    IN  UCHAR   DriveLetter
    )

{
    WCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


BOOL
ExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    )

/*++

Routine Description:

    This function will extend a partition.

    We'll do this in the following way:
    1. Figure out if the partition is NTFS.
    2. Figure out if there's any unpartitioned space behind
       the partition the user is asking us to extend.
    3. How much space is available?
    4. Extend the partition
    5. Extend the filesystem (inform him the partition is bigger).



Arguments:

    DriveLetter - Supplies the driveletter for the partition
                  that we'll be extending.

    SizeMB      - if specified, indicates the size in MB by which
                  the partition will grow. If not specified, the
                  partition grows to encompass all the free space
                  in the adjacent free space.

Return Value:

    Boolean value indicating whether anything actually changed.

--*/

{
#define                     LEAVE_FREE_BUFFER (5 * (1024*1024))
HANDLE                      h;
PARTITION_INFORMATION_EX    PartitionInfo;
BOOL                        b;
DWORD                       Bytes;
DISK_GEOMETRY               Geometry;
DISK_GROW_PARTITION         GrowInfo;
TCHAR                       PhysicalName[MAX_PATH];
TCHAR                       DosName[10];
LARGE_INTEGER               BytesAvailable;
LARGE_INTEGER               OurPartitionEndingLocation;
DWORD                       i;
PDRIVE_LAYOUT_INFORMATION_EX  DriveLayout;

    //
    // =====================================
    // 1. Figure out if the partition is NTFS.
    // =====================================
    //
    DosName[0] = DriveLetter;
    DosName[1] = TEXT(':');
    DosName[2] = TEXT('\\');
    DosName[3] = TEXT('\0');
    b = GetVolumeInformation(
            DosName,
            NULL,0,                 // don't care about volume name
            NULL,                   // ...or serial #
            &i,                     // ...or max component length
            &i,                     // ... or flags
            PhysicalName,
            sizeof(PhysicalName)/sizeof(TCHAR)
            );
    if( !b ) {
        return FALSE;
    }

    if(lstrcmpi(PhysicalName,TEXT("NTFS"))) {
        //
        // Our partition isn't NTFS.  Bail.
        //
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %ws is not NTFS volume\n",
            DosName);
            
        return FALSE;
    }



    //
    // Now initialize the name for this partition and
    // the name for this drive.
    //
    wsprintf( DosName, TEXT("\\\\.\\%c:"), DriveLetter );
    wsprintf( PhysicalName, TEXT("\\\\.\\PhysicalDrive%u"), QueryHardDiskNumber( (UCHAR)DriveLetter) );


    //
    // =====================================
    // 2. Figure out if there's any unpartitioned space behind
    //    the partition the user is asking us to extend.
    // =====================================
    //

    //
    // Get a handle to the disk so we can start examination.
    //
    h = CreateFile( PhysicalName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                    NULL );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            PhysicalName);
            
        return FALSE;
    }



    //
    // Get the disk's layout information.  We aren't
    // sure how big of a buffer we need, so brute-force it.
    //
    {
    DWORD   DriveLayoutSize = 1024;
    PVOID   p;

        DriveLayout = MyMalloc(DriveLayoutSize);
        if( !DriveLayout ) {
            CloseHandle( h );
            return FALSE;
        }

retry:

        b = DeviceIoControl( h,
                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                             NULL,
                             0,
                             (PVOID)DriveLayout,
                             DriveLayoutSize,
                             &Bytes,
                             NULL );

        if( !b ) {
            DWORD LastError = GetLastError();
            
            if (LastError == ERROR_INSUFFICIENT_BUFFER) {
                DriveLayoutSize += 1024;
                
                if(p = MyRealloc((PVOID)DriveLayout,DriveLayoutSize)) {
                    (PVOID)DriveLayout = p;
                } else {
                    goto cleanexit0;
                }
                goto retry;
            } else {
                DbgPrintEx( DPFLTR_SETUP_ID, 
                    DPFLTR_INFO_LEVEL, 
                    "ExtendPartition: %X Error while getting drive layout for %ws\n",
                    LastError,
                    PhysicalName);
            
                goto cleanexit0;
            }
        }
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;



    //
    // DriveLayout now is full of most of the information we
    // need, including an array of partition information.  But
    // we aren't sure which partition is ours.  We need to
    // get info on our specific partition, then match it
    // against the entry inside DriveLayout.
    //


    //
    // Open a handle to the partition.
    //
    h = CreateFile( DosName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            DosName);
            
        return FALSE;
    }

    //
    // Load info about our partition.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_PARTITION_INFO_EX,
                         NULL,
                         0,
                         &PartitionInfo,
                         sizeof(PartitionInfo),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's partition information\n",
            GetLastError(),
            DosName);
    
        goto cleanexit0;
    }


    //
    // Might as well get the geometry info on the disk too.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                         NULL,
                         0,
                         &Geometry,
                         sizeof(Geometry),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's drive geometry\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;



    //
    // =====================================
    // 3. How much space is available?
    // =====================================
    //

    //
    // We're ready to actually verify that there's rooom for us to grow.
    // If we're the last partition on the disk, we need to see if there's
    // any room behind us (i.e. any unpartitioned space).  If we're not
    // the last partition, we need to see if there's any space between where
    // our partition ends and the next partition begins.
    //
    // This is really gross, but DriveLayout->PartitionCount will likely be 4
    // even if there's really only 1 formatted partition on the disk.  We also
    // don't want to take the chance that the partitions aren't ordered by their
    // location on the disk.  So we need to go cycle through the partitions
    // again and manually find the one that starts right after ours.
    //
    OurPartitionEndingLocation.QuadPart = PartitionInfo.StartingOffset.QuadPart + PartitionInfo.PartitionLength.QuadPart;

    //
    // Initialize BytesAvailable based on the space from where our partition ends to where
    // the disk ends.  This is the best case and we can only get smaller sizes, so this
    // is safe.
    //
    BytesAvailable.QuadPart = UInt32x32To64( Geometry.BytesPerSector, Geometry.SectorsPerTrack );
    BytesAvailable.QuadPart = BytesAvailable.QuadPart * (ULONGLONG)(Geometry.TracksPerCylinder);
    BytesAvailable.QuadPart = BytesAvailable.QuadPart * Geometry.Cylinders.QuadPart;

    //
    // Check if the value of End of Partition is beyond the Disk size.
    // If we do not have this check we find that the partition gets corrupted as
    // IOCTL_DISK_GROW_PARTITION does not check the validity of the value
    // passed to it. This condition (of a negative grow) would arise because of a 
    // rounding off(to the lower value) up to a cylinder by 
    // IOCTL_DISK_GET_DRIVE_GEOMETRY.
    //
    if (BytesAvailable.QuadPart <= OurPartitionEndingLocation.QuadPart) {
        b = FALSE;
        goto cleanexit0;
    }

    BytesAvailable.QuadPart = BytesAvailable.QuadPart - OurPartitionEndingLocation.QuadPart;

    for( i = 0; i < DriveLayout->PartitionCount; i++ ) {
        if( (DriveLayout->PartitionEntry[i].StartingOffset.QuadPart > OurPartitionEndingLocation.QuadPart) &&
            ((DriveLayout->PartitionEntry[i].StartingOffset.QuadPart - OurPartitionEndingLocation.QuadPart) < BytesAvailable.QuadPart) ) {

            //
            // This partition is starting after ours and it's also the closest one we've found
            // to our ending location.
            //
            BytesAvailable.QuadPart = DriveLayout->PartitionEntry[i].StartingOffset.QuadPart - OurPartitionEndingLocation.QuadPart;
        }
    }


    //
    // Reserve the space at the disk end only for MBR disks
    //
    if (DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
        //
        // If we don't have at least 5MB available, don't even bother.  If we do, leave the last
        // 5MB free for later use as a dynamic volume.
        //
        if( BytesAvailable.QuadPart < (ULONGLONG)(LEAVE_FREE_BUFFER) ) {
            goto cleanexit0;
        } else {
            BytesAvailable.QuadPart = BytesAvailable.QuadPart - (ULONGLONG)(LEAVE_FREE_BUFFER);
        }
    }        

    //
    // See if the user has asked us to extend by some known value...
    //
    if( SizeMB ) {
        //
        // Yes.  Make sure we have atleast this much space to extend.
        //
        if( (LONGLONG)(SizeMB * (1024*1024)) < BytesAvailable.QuadPart ) {
            BytesAvailable.QuadPart = UInt32x32To64( SizeMB, (1024*1024) );
        }
    }





    //
    // =====================================
    // 4. Extend the partition
    // =====================================
    //

    //
    // Get a handle to the disk.
    //
    h = CreateFile( PhysicalName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                    NULL );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            PhysicalName);
            
        return FALSE;
    }


    //
    // Fill in the datastructure we'll be sending to the IOCTL.
    //
    GrowInfo.PartitionNumber = PartitionInfo.PartitionNumber;
    GrowInfo.BytesToGrow = BytesAvailable;


    //
    // Do it.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GROW_PARTITION,
                         &GrowInfo,
                         sizeof(GrowInfo),
                         NULL,
                         0,
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while growing %ws partition\n",
            GetLastError(),
            PhysicalName);
            
        goto cleanexit0;
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;





    //
    // =====================================
    // 5. Extend the filesystem (inform him the partition is bigger).
    // =====================================
    //



    //
    // Get a handle to the partition.
    //
    h = CreateFile( DosName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            DosName);

        goto cleanexit0;
    }



    //
    // Gather some info on the partition.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_PARTITION_INFO_EX,
                         NULL,
                         0,
                         &PartitionInfo,
                         sizeof(PartitionInfo),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's partition information\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }


    //
    // Grow the volume.
    //
    BytesAvailable.QuadPart = PartitionInfo.PartitionLength.QuadPart / Geometry.BytesPerSector;

    b = DeviceIoControl( h,
                         FSCTL_EXTEND_VOLUME,
                         &BytesAvailable,
                         sizeof(BytesAvailable),
                         NULL,
                         0,
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while extending volume %ws\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }

cleanexit0:
    if( h != INVALID_HANDLE_VALUE ) {
        CloseHandle( h );
    }


    //
    // If we successfully extended the partition
    // then mark the global flag to remove any
    // stale volume information, at the end of setup.
    //
    if (b) {
        PartitionExtended = TRUE;
    }

    return b;
}



BOOL
SetupExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    )
{
    BOOL b;

    if ( b = ExtendPartition(DriveLetter, SizeMB) )
    {
        RemoveStaleVolumes();
        PartitionExtended = FALSE;
    }

    return b;
}


BOOL
DoFilesMatch(
    IN PCWSTR File1,
    IN PCWSTR File2
    )
/*++

Routine Description:

    Compares two files to each other to see if they are identical.

Arguments:

    File1 - First file to compare
    File2 - Second file to compare


Return Value:

    BOOL - Returns TRUE if the files match.  If the both of the files are zero
    length, then we still return TRUE.

--*/
{
    DWORD FirstFileSize, SecondFileSize;
    HANDLE FirstFileHandle, FirstMappingHandle;
    HANDLE SecondFileHandle, SecondMappingHandle;
    PVOID FirstBaseAddress, SecondBaseAddress;

    BOOL RetVal = FALSE;

    if(   (pSetupOpenAndMapFileForRead(
                     File1,
                     &FirstFileSize,
                     &FirstFileHandle,
                     &FirstMappingHandle,
                     &FirstBaseAddress) == NO_ERROR)
       && (pSetupOpenAndMapFileForRead(
                     File1,
                     &SecondFileSize,
                     &SecondFileHandle,
                     &SecondMappingHandle,
                     &SecondBaseAddress) == NO_ERROR) ) {

        if (FirstFileSize == SecondFileSize ) {
            if (FirstFileSize != 0) {
                //
                // protect against inpage IO error
                //
                try {
                    RetVal = !memcmp(
                                 FirstBaseAddress,
                                 SecondBaseAddress,
                                 FirstFileSize
                                 );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                      RetVal = FALSE;
                }
            }
        }

        pSetupUnmapAndCloseFile(
                    FirstFileHandle,
                    FirstMappingHandle,
                    FirstBaseAddress
                    );

        pSetupUnmapAndCloseFile(
                    SecondFileHandle,
                    SecondMappingHandle,
                    SecondBaseAddress
                    );

    }

    return (RetVal);
}

DWORD
RemoveStaleVolumes(
    VOID
    )
/*++

Routine Description:

    This routine walks through all the volumes and deletes the one 
    which are marked for reinstall. 

    NOTE : Use the function carefully because it will nuke all
    the entries related to the volume from the registry, iff the volume
    says it needs to be reinstalled.

Arguments:

    None.
    
Return Value:

    Appropriate Win32 error code.

--*/
{
    const TCHAR *VolumeKeyName = TEXT("System\\CurrentControlSet\\Enum\\Storage\\Volume");
    const TCHAR *ClassKeyName = TEXT("System\\CurrentControlSet\\Control\\Class");

    DWORD   ErrorCode;
    HKEY    VolumeKey = NULL;
    HKEY    ClassKey = NULL;
    ULONG   Index = 0;
    ULONG   VolumesFixedCount = 0;
    TCHAR   SubKeyName[MAX_PATH*2];
    DWORD   SubKeyLength;
    FILETIME SubKeyTime;

    //
    // Open the Volume key
    //
    ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    VolumeKeyName,
                    0,
                    KEY_ALL_ACCESS,
                    &VolumeKey);

    if (VolumeKey == NULL) {
        ErrorCode = ERROR_INVALID_HANDLE;
    }        
    
    if (ErrorCode != ERROR_SUCCESS) {
        return ErrorCode;
    }

    //
    // Open the Class key
    //
    ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    ClassKeyName,
                    0,
                    KEY_ALL_ACCESS,
                    &ClassKey);

    if (ClassKey == NULL) {
        ErrorCode = ERROR_INVALID_HANDLE;
    }        
    
    if (ErrorCode != ERROR_SUCCESS) {
        RegCloseKey(VolumeKey);
        
        return ErrorCode;
    }

    //
    // Enumerate each subkey of the opened key
    //
    while (TRUE) {        
        SubKeyName[0] = 0;
        SubKeyLength = sizeof(SubKeyName) / sizeof(SubKeyName[0]);
        
        ErrorCode = RegEnumKeyEx(VolumeKey,
                        Index,
                        SubKeyName,
                        &SubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        &SubKeyTime);

        if (ErrorCode == ERROR_SUCCESS) {
            TCHAR   FullSubKeyName[MAX_PATH*4];
            DWORD   SubErrorCode;
            HKEY    CurrentSubKey = NULL;
            GUID    VolumeGuid = {0};
            TCHAR   VolumeGuidStr[MAX_PATH] = {0};
            DWORD   DrvInstance = -1;            
            BOOL    DeleteKey = FALSE;
            BOOL    DeleteClassInstance = FALSE;
            BOOL    IncrementKeyIndex = TRUE;
            
            _tcscpy(FullSubKeyName, VolumeKeyName);
            _tcscat(FullSubKeyName, TEXT("\\"));
            _tcscat(FullSubKeyName, SubKeyName);

            SubErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                FullSubKeyName,
                                0,
                                KEY_ALL_ACCESS,
                                &CurrentSubKey);

            if (SubErrorCode == ERROR_SUCCESS) {
                //
                // Read the ConfigFlags value
                //
                DWORD   ConfigFlags = 0;
                DWORD   Type = REG_DWORD;
                DWORD   BufferSize = sizeof(DWORD);

                SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                    TEXT("ConfigFlags"),
                                    NULL,
                                    &Type,
                                    (PBYTE)&ConfigFlags,
                                    &BufferSize);

                if (SubErrorCode == ERROR_SUCCESS) {     

                    DeleteKey = (ConfigFlags & (CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL));

                    if (DeleteKey) {                        
                        Type = REG_BINARY;
                        BufferSize = sizeof(VolumeGuid);

                        //
                        // Read the GUID & DrvInst values
                        //                        
                        SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                            TEXT("GUID"),
                                            NULL,
                                            &Type,
                                            (PBYTE)&VolumeGuid,
                                            &BufferSize);

                        if (SubErrorCode == ERROR_SUCCESS) {                            
                            Type = REG_DWORD;
                            BufferSize = sizeof(DWORD);
                            
                            SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                                TEXT("DrvInst"),
                                                NULL,
                                                &Type,
                                                (PBYTE)&DrvInstance,
                                                &BufferSize);

                            DeleteClassInstance = 
                                (SubErrorCode == ERROR_SUCCESS) &&
                                (DrvInstance != -1);
                        }
                    }
                }

                //
                // Close the current subkey since we don't need it anymore
                //
                RegCloseKey(CurrentSubKey);

                //
                // Delete after we close the current key
                //
                if (DeleteKey) {
                    SubErrorCode = SHDeleteKey(HKEY_LOCAL_MACHINE,
                                        FullSubKeyName);

                    if (SubErrorCode == ERROR_SUCCESS) {
                        VolumesFixedCount++;
                        IncrementKeyIndex = FALSE;
                    } 
                }                                    

                //
                // Delete the instance key under class also if needed
                //
                if (DeleteClassInstance && 
                    (pSetupStringFromGuid(&VolumeGuid,
                            VolumeGuidStr,
                            sizeof(VolumeGuidStr)/sizeof(VolumeGuidStr[0])) == ERROR_SUCCESS)) {                                                                        
                    _stprintf(FullSubKeyName,
                        TEXT("System\\CurrentControlSet\\Control\\Class\\%ws\\%04d"),
                        VolumeGuidStr, 
                        DrvInstance);

                    SubErrorCode = SHDeleteKey(HKEY_LOCAL_MACHINE,
                                        FullSubKeyName);                           
                }
            } 
            
            if (IncrementKeyIndex) {
                Index++;
            }                
        } else {
            break;  // we couldn't enumerate further sub keys
        }            
    }

    RegCloseKey(ClassKey);
    RegCloseKey(VolumeKey);    

    //
    // If we fixed at least a single volume then assume things
    // went fine
    //
    if (VolumesFixedCount > 0) {
        ErrorCode = ERROR_SUCCESS;
    }        

    return ErrorCode;
}

#define MAX_NT_PATH (MAX_PATH + 4)//"\\??\\"
#define UNDO_FILE_NAME  L"UNDO_GUIMODE.TXT"

VOID 
RemoveAllPendingOperationsOnRestartOfGUIMode(
    VOID
    )
{
    WCHAR undoFilePath[MAX_PATH];

    if(!GetWindowsDirectoryW(undoFilePath, ARRAYSIZE(undoFilePath))){
        ASSERT(FALSE);
        return;
    }
    wcscat(undoFilePath, L"\\system32\\");
    wcscat(undoFilePath, UNDO_FILE_NAME);

    SetFileAttributes(undoFilePath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(undoFilePath);
}

BOOL 
RenameOnRestartOfGUIMode(
    IN PCWSTR pPathName, 
    IN PCWSTR pPathNameNew
    )
{
    DWORD Size;
    BOOL result;
    WCHAR undoFilePath[MAX_PATH];
    WCHAR RenameOperationBuffer[2 * (MAX_NT_PATH + 2/*'\r\n'*/)];
    HANDLE fileUndo;
    BYTE signUnicode[] = {0xff, 0xfe};

    if(!pPathName){
        return FALSE;
    }

    if(!GetWindowsDirectoryW(undoFilePath, ARRAYSIZE(undoFilePath))){
        return FALSE;
    }
    wcscat(undoFilePath, L"\\system32\\" UNDO_FILE_NAME);

    wsprintfW(RenameOperationBuffer, L"\\??\\%s\r\n", pPathName);
    if(pPathNameNew){
        wsprintfW(RenameOperationBuffer + wcslen(RenameOperationBuffer), 
                  L"\\??\\%s", 
                  pPathNameNew);
    }
    wcscat(RenameOperationBuffer, L"\r\n");

    fileUndo = CreateFileW(undoFilePath, 
                           GENERIC_WRITE, 
                           FILE_SHARE_READ, 
                           NULL, 
                           OPEN_ALWAYS, 
                           FILE_ATTRIBUTE_NORMAL, 
                           NULL);
    if(INVALID_HANDLE_VALUE == fileUndo){
        return FALSE;
    }

    if(!SetFilePointer(fileUndo, 0, NULL, FILE_END)){
        result = WriteFile(fileUndo, signUnicode, sizeof(signUnicode), &Size, NULL);
    }
    else {
        result = TRUE;
    }
    
    if(result){
        result = WriteFile(fileUndo, 
                           RenameOperationBuffer, 
                           wcslen(RenameOperationBuffer) * sizeof(WCHAR), 
                           &Size, 
                           NULL);
    }
    
    CloseHandle(fileUndo);
    
    return result;
}

BOOL 
DeleteOnRestartOfGUIMode(
    IN PCWSTR pPathName
    )
{
    return RenameOnRestartOfGUIMode(pPathName, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\helpids.h ===
#define IDH_APPWIZ_WINSETUP_LIST    5621   // Components box
#define IDH_SPACE_REQ               5622  // Space Required and Space Available
#define IDH_APPWIZ_DETAILS          5623  // Details button
#define IDH_APPWIZ_HAVEDISK_BUTTON  5624  // Have Disk button

#define IDH_IRQ_ENABLE      401000           // Enable IRQ Routing  
#define IDH_IRQ_MSSPEC      401100           // Use $PIR table
#define IDH_IRQ_REALMODE    401200           // Use table from Real-mode BIOS call
#define IDH_IRQ_SETDEFAULTS 401300           // Set defaults for options
#define IDH_IRQ_RESULTS     401400           // Status information
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\intl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    intl.c

Abstract:

    Module with code for NLS-related stuff.
    This module is designed to be used with intl.inf and font.inf
    by control panel applets.

Author:

    Ted Miller (tedm) 15-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// This structure and the callback function below are used to set the
// hidden attribute bit on certain font files. That bit causes the font folder
// app to not autoinstall these files.
//
typedef struct _FONTQCONTEXT {
    PVOID SetupQueueContext;
    HINF FontInf;
} FONTQCONTEXT, *PFONTQCONTEXT;

PCWSTR szHiddenFontFiles = L"HiddenFontFiles";

VOID
pSetLocaleSummaryText(
    IN HWND hdlg
    );

VOID
pSetKeyboardLayoutSummaryText(
    IN HWND hdlg
    );


void
pSetupRunRegApps()
{
    HKEY hkey;
    BOOL bOK = TRUE;
    DWORD cbData, cbValue, dwType, ctr;
    TCHAR szValueName[32], szCmdLine[MAX_PATH];
    STARTUPINFO startup;
    PROCESS_INFORMATION pi;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun"),
                    &hkey ) == ERROR_SUCCESS)
    {
        startup.cb = sizeof(STARTUPINFO);
        startup.lpReserved = NULL;
        startup.lpDesktop = NULL;
        startup.lpTitle = NULL;
        startup.dwFlags = 0L;
        startup.cbReserved2 = 0;
        startup.lpReserved2 = NULL;
    //  startup.wShowWindow = wShowWindow;

        for (ctr = 0; ; ctr++)
        {
            LONG lEnum;

            cbValue = sizeof(szValueName) / sizeof(TCHAR);
            cbData = sizeof(szCmdLine);

            if ((lEnum = RegEnumValue( hkey,
                                       ctr,
                                       szValueName,
                                       &cbValue,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)szCmdLine,
                                       &cbData )) == ERROR_MORE_DATA)
            {
                //
                //  ERROR_MORE_DATA means the value name or data was too
                //  large, so skip to the next item.
                //
                continue;
            }
            else if (lEnum != ERROR_SUCCESS)
            {
                //
                //  This could be ERROR_NO_MORE_ENTRIES, or some kind of
                //  failure.  We can't recover from any other registry
                //  problem anyway.
                //
                break;
            }

            //
            //  Found a value.
            //
            if (dwType == REG_SZ)
            {
                //
                //  Adjust for shift in value index.
                //
                ctr--;

                //
                //  Delete the value.
                //
                RegDeleteValue(hkey, szValueName);

                //
                //  Only run things marked with a "*" in clean boot.
                //
                if (CreateProcess( NULL,
                                   szCmdLine,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   CREATE_NEW_PROCESS_GROUP,
                                   NULL,
                                   NULL,
                                   &startup,
                                   &pi ))
                {
                    WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);

                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
        RegCloseKey(hkey);
    }
}


VOID
InstallServerNLSFiles(
    IN  HWND    Window
    )

/*++

Routine Description:

    Installs a bunch of code pages for servers.  We install sections in intl.inf
    named [CODEPAGE_INSTALL_<n>], where the values for <n> are listed in the
    section [CodePages].

Arguments:

    Window - handle to parent window

Return Value:

    None.

--*/

{
    HINF    hInf;
    INFCONTEXT InfContext;
    BOOL b;
    PCWSTR  CodePage;
    WCHAR   InstallSection[30];
    HSPFILEQ    FileQueue;
    DWORD       QueueFlags;
    PVOID       pQueueContext;


    hInf = SetupOpenInfFile(L"INTL.INF",NULL,INF_STYLE_WIN4,NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to open intl.inf" );
        return;
    }

    if(!SetupOpenAppendInfFile( NULL, hInf, NULL )) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to open intl.inf layout" );
        return;
    }

    if(!SetupFindFirstLine(hInf,L"CodePages",NULL,&InfContext)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to find [CodePages] section" );
        goto c1;
    }

    //
    // Create a setup file queue and initialize default Setup copy queue
    // callback context.
    //
    QueueFlags = SP_COPY_FORCE_NOOVERWRITE;
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupOpenFileQueue failed" );
        goto c1;
    }

    //
    // Disable the file-copy progress dialog.
    //
    pQueueContext = InitSysSetupQueueCallbackEx(
        Window,
        INVALID_HANDLE_VALUE,
        0,0,NULL);
    if(!pQueueContext) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: InitSysSetupQueueCallbackEx failed" );
        goto c2;
    }

    do {
        if(CodePage = pSetupGetField(&InfContext,0)) {
            wsprintf( InstallSection, L"CODEPAGE_INSTALL_%s", CodePage );

            //
            // Enqueue locale-related files for copy.
            //
            b = SetupInstallFilesFromInfSection(
                    hInf,
                    NULL,
                    FileQueue,
                    InstallSection,
                    NULL,
                    QueueFlags
                    );
            if(!b) {
                SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupInstallFilesFromInfSection failed" );
                goto c3;
            }
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    // Copy enqueued files.
    //
    b = SetupCommitFileQueue(
            Window,
            FileQueue,
            SysSetupQueueCallback,
            pQueueContext
            );
    if(!b) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupCommitFileQueue failed" );
        goto c3;
    }

    if(!SetupFindFirstLine(hInf,L"CodePages",NULL,&InfContext)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to find [CodePages] section (2nd pass)" );
        goto c3;
    }

    do {
        if(CodePage = pSetupGetField(&InfContext,0)) {
            wsprintf( InstallSection, L"CODEPAGE_INSTALL_%s", CodePage );

            //
            // Complete installation of locale stuff.
            //
            b = SetupInstallFromInfSection(
                    Window,
                    hInf,
                    InstallSection,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
            if(!b) {
                SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupInstallFromInfSection failed" );
                goto c3;
            }
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

c3:
    TermSysSetupQueueCallback(pQueueContext);
c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(hInf);
    return;
}


DWORD
pSetupInitRegionalSettings(
    IN  HWND    Window
    )
{
    HINF IntlInf;
    LONG l;
    HKEY hKey;
    DWORD d;
    BOOL  b;
    DWORD Type;
    INFCONTEXT LineContext;
    WCHAR IdFromRegistry[9];
    WCHAR KeyName[9];
    WCHAR LanguageGroup[9];
    WCHAR LanguageInstallSection[25];
    LCID  SystemLocale;
    HSPFILEQ    FileQueue;
    DWORD       QueueFlags;
    PVOID       pQueueContext;

    //
    // Open intl.inf. The locale descriptions are in there.
    // Lines in the [Locales] section have keys that are 32-bit
    // locale ids but the sort part is always 0, so they're more like
    // zero-extended language ids.
    //
    IntlInf = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);

    if(IntlInf == INVALID_HANDLE_VALUE) {
        SetupDebugPrint( L"SETUP: pSetupInitRegionalSettings: Unable to open intl.inf" );
        l = GetLastError();
        goto c0;
    }

    if(!SetupOpenAppendInfFile( NULL, IntlInf, NULL )) {
        SetupDebugPrint( L"SETUP: pSetupInitRegionalSettings: Unable to open intl.inf layout" );
        l = GetLastError();
        goto c0;
    }

    //
    // Read the system locale from the registry. and look up in intl.inf.
    // The value in the registry is a 16-bit language id, so we need to
    // zero-extend it to index intl.inf.
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Nls\\Language",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    if(l == NO_ERROR) {
        d = sizeof(IdFromRegistry);
        l = RegQueryValueEx(hKey,L"Default",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
        RegCloseKey(hKey);
        if((l == NO_ERROR) && ((Type != REG_SZ) || (d != 10))) {
            l = ERROR_INVALID_DATA;
        }
    }

    if(l == NO_ERROR) {

        l = ERROR_INVALID_DATA;

        wsprintf(KeyName,L"0000%s",IdFromRegistry);

        if(SetupFindFirstLine(IntlInf,L"Locales",KeyName,&LineContext)
        && SetupGetStringField(&LineContext,3,LanguageGroup,
            sizeof(LanguageGroup)/sizeof(WCHAR),NULL)) {

            l = NO_ERROR;
        }
    }

    if(l == NO_ERROR) {
        wsprintf(LanguageInstallSection,L"LG_INSTALL_%s",LanguageGroup);

        //
        // We copy the files in textmode setup now, so we don't need to do that
        // here anymore.
        //
#define DO_COPY_FILES
#ifdef DO_COPY_FILES
        //
        // Create a setup file queue and initialize default Setup copy queue
        // callback context.
        //
        QueueFlags = SP_COPY_FORCE_NOOVERWRITE;
        FileQueue = SetupOpenFileQueue();
        if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
            l = ERROR_OUTOFMEMORY;
            goto c1;
        }

        //
        // Disable the file-copy progress dialog.
        //
        pQueueContext = InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);
        if(!pQueueContext) {
            l = ERROR_OUTOFMEMORY;
            goto c2;
        }

        //
        // Enqueue locale-related files for copy.  We install locales for the
        // system default and the Western language group, which is group 1.
        //
        b = SetupInstallFilesFromInfSection(
                IntlInf,
                NULL,
                FileQueue,
                LanguageInstallSection,
                NULL,
                QueueFlags
                );
        if(!b) {
            l = GetLastError();
            goto c3;
        }

        if(wcscmp(LanguageGroup,L"1")) {
            b = SetupInstallFilesFromInfSection(
                    IntlInf,
                    NULL,
                    FileQueue,
                    L"LG_INSTALL_1",
                    NULL,
                    QueueFlags
                    );
        }
        if(!b) {
            l = GetLastError();
            goto c3;
        }

        //
        // Determine whether the queue actually needs to be committed.
        //
        b = SetupScanFileQueue(
                FileQueue,
                SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                Window,
                NULL,
                NULL,
                &d
                );

        if(!b) {
            l = GetLastError();
            goto c3;
        }

        //
        // d = 0: User wants new files or some files were missing;
        //        Must commit queue.
        //
        // d = 1: User wants to use existing files and queue is empty;
        //        Can skip committing queue.
        //
        // d = 2: User wants to use existing files but del/ren queues not empty.
        //        Must commit queue. The copy queue will have been emptied,
        //        so only del/ren functions will be performed.
        //
        if(d == 1) {

            b = TRUE;

        } else {

            //
            // Copy enqueued files.
            //
            b = SetupCommitFileQueue(
                    Window,
                    FileQueue,
                    SysSetupQueueCallback,
                    pQueueContext
                    );
        }

        if(!b) {
            l = GetLastError();
            goto c3;
        }
#endif
        //
        // Complete installation of locale stuff.
        //
        b = SetupInstallFromInfSection(
                Window,
                IntlInf,
                LanguageInstallSection,
                SPINST_ALL & ~SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
        if(!b) {
            l = GetLastError();
#ifdef DO_COPY_FILES
            goto c3;
#else
            goto c1;
#endif
        }

        if(wcscmp(LanguageGroup,L"1")) {
            b = SetupInstallFromInfSection(
                    Window,
                    IntlInf,
                    L"LG_INSTALL_1",
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        }
        if(!b) {
            l = GetLastError();
#ifdef DO_COPY_FILES
            goto c3;
#else
            goto c1;
#endif
        }

    }
    pSetupRunRegApps();

    SystemLocale = wcstol(IdFromRegistry,NULL,16);
    if (l == NO_ERROR) {
        l = SetupChangeLocaleEx(
            Window,
            SystemLocale,
            SourcePath,
            SP_INSTALL_FILES_QUIETLY,
            NULL,0);

#ifdef DO_COPY_FILES
c3:
        TermSysSetupQueueCallback(pQueueContext);
c2:
        SetupCloseFileQueue(FileQueue);
#endif
    }
c1:
    SetupCloseInfFile(IntlInf);
c0:
    SetupDebugPrint2( L"SETUP: pSetupInitRegionalSettings returned %d (0x%08x)", l, l);
    return l;
}


UINT
pSetupFontQueueCallback(
    IN PFONTQCONTEXT Context,
    IN UINT          Notification,
    IN UINT_PTR      Param1,
    IN UINT_PTR      Param2
    )
{
    PFILEPATHS FilePaths;
    PWCHAR p;
    INFCONTEXT InfContext;

    //
    // If a file is finished being copied, set its attributes
    // to include the hidden attribute if necessary.
    //
    if((Notification == SPFILENOTIFY_ENDCOPY)
    && (FilePaths = (PFILEPATHS)Param1)
    && (FilePaths->Win32Error == NO_ERROR)
    && (p = wcsrchr(FilePaths->Target,L'\\'))
    && SetupFindFirstLine(Context->FontInf,szHiddenFontFiles,p+1,&InfContext)) {

        SetFileAttributes(FilePaths->Target,FILE_ATTRIBUTE_HIDDEN);
    }

    return( IsSetup ?
        SysSetupQueueCallback(Context->SetupQueueContext,Notification,Param1,Param2) :
        SetupDefaultQueueCallback(Context->SetupQueueContext,Notification,Param1,Param2)
        );
}


VOID
pSetupMarkHiddenFonts(
    VOID
    )
{
    HINF hInf;
    INFCONTEXT InfContext;
    BOOL b;
    WCHAR Path[MAX_PATH];
    PWCHAR p;
    PCWSTR q;
    int Space;

    hInf = SetupOpenInfFile(L"FONT.INF",NULL,INF_STYLE_WIN4,NULL);
    if(hInf != INVALID_HANDLE_VALUE) {

        GetWindowsDirectory(Path,MAX_PATH);
        lstrcat(Path,L"\\FONTS\\");
        p = Path + lstrlen(Path);
        Space = MAX_PATH - (int)(p - Path);

        if(SetupFindFirstLine(hInf,szHiddenFontFiles,NULL,&InfContext)) {

            do {
                if(q = pSetupGetField(&InfContext,0)) {

                    lstrcpyn(p,q,Space);
                    if(FileExists(Path,NULL)) {
                        SetFileAttributes(Path,FILE_ATTRIBUTE_HIDDEN);
                    }
                }

            } while(SetupFindNextLine(&InfContext,&InfContext));
        }

        SetupCloseInfFile(hInf);
    }
}


DWORD
pSetupNLSInstallFonts(
    IN HWND     Window,
    IN HINF     InfHandle,
    IN PCWSTR   OemCodepage,
    IN PCWSTR   FontSize,
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SourcePath,     OPTIONAL
    IN DWORD    QueueFlags
    )
{
    BOOL b;
    WCHAR SectionName[64];

    //
    // Form section name.
    //
    wsprintf(SectionName,L"Font.CP%s.%s",OemCodepage,FontSize);

    if(FileQueue) {
        //
        // First pass: just enqueue files for copy.
        //
        b = SetupInstallFilesFromInfSection(
                InfHandle,
                NULL,
                FileQueue,
                SectionName,
                SourcePath,
                QueueFlags
                );
    } else {
        //
        // Second pass: do registry munging, etc.
        //
        b = SetupInstallFromInfSection(
                Window,
                InfHandle,
                SectionName,
                SPINST_ALL & ~SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
    }

    return(b ? NO_ERROR : GetLastError());
}


DWORD
pSetupNLSLoadInfs(
    OUT HINF *FontInfHandle,
    OUT HINF *IntlInfHandle     OPTIONAL
    )
{
    HINF fontInfHandle;
    HINF intlInfHandle;
    DWORD d;

    fontInfHandle = SetupOpenInfFile(L"font.inf",NULL,INF_STYLE_WIN4,NULL);
    if(fontInfHandle == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        goto c0;
    }

    if(!SetupOpenAppendInfFile(NULL,fontInfHandle,NULL)) {
        d = GetLastError();
        goto c1;
    }

    if(IntlInfHandle) {
        intlInfHandle = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);
        if(intlInfHandle == INVALID_HANDLE_VALUE) {
            d = GetLastError();
            goto c1;
        }

        if(!SetupOpenAppendInfFile(NULL,intlInfHandle,NULL)) {
            d = GetLastError();
            goto c2;
        }

        *IntlInfHandle = intlInfHandle;
    }

    *FontInfHandle = fontInfHandle;
    return(NO_ERROR);

c2:
    SetupCloseInfFile(intlInfHandle);
c1:
    SetupCloseInfFile(fontInfHandle);
c0:
    return(d);
}


DWORD
SetupChangeLocale(
    IN HWND Window,
    IN LCID NewLocale
    )
{
    return(SetupChangeLocaleEx(Window,NewLocale,NULL,0,NULL,0));
}


DWORD
SetupChangeLocaleEx(
    IN HWND   Window,
    IN LCID   NewLocale,
    IN PCWSTR SourcePath,   OPTIONAL
    IN DWORD  Flags,
    IN PVOID  Reserved1,
    IN DWORD  Reserved2
    )
{
    DWORD d;
    BOOL b;
    HINF IntlInfHandle;
    INFCONTEXT InfContext;
    WCHAR Codepage[24];
    WCHAR NewLocaleString[24];
    FONTQCONTEXT QueueContext;
    HSPFILEQ FileQueue;
    PCWSTR SizeSpec;
    HDC hdc;
    PCWSTR p;
    DWORD QueueFlags;
    HKEY hKey;
    DWORD DataType;
    DWORD SizeDword;
    DWORD DataSize;


    SizeSpec = L"96";
#if 0
    // This is no longer reliable.
    if(hdc = CreateDC(L"DISPLAY",NULL,NULL,NULL)) {
        if(GetDeviceCaps(hdc,LOGPIXELSY) > 108) {
            SizeSpec = L"120";
        }

        DeleteDC(hdc);
    }
#else
    //
    // Determine the current font size. Default to 96.
    //
    d = (DWORD)RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts",
        0,
        KEY_QUERY_VALUE,
        &hKey
        );

    if(d == NO_ERROR) {

        DataSize = sizeof(DWORD);
        d = (DWORD)RegQueryValueEx(
            hKey,
            L"LogPixels",
            NULL,
            &DataType,
            (LPBYTE)&SizeDword,
            &DataSize
            );

        if( (d == NO_ERROR) && (DataType == REG_DWORD) &&
            (DataSize == sizeof(DWORD)) && (SizeDword > 108) ) {

            SizeSpec = L"120";
        }
        RegCloseKey(hKey);
    }
#endif

    QueueFlags = SP_COPY_NEWER | BaseCopyStyle;
    if(Flags & SP_INSTALL_FILES_QUIETLY) {
        QueueFlags |= SP_COPY_FORCE_NOOVERWRITE;
    }

    //
    // Load inf files.
    //
    d = pSetupNLSLoadInfs(&QueueContext.FontInf,&IntlInfHandle);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Get oem codepage for the locale. This is also a sanity check
    // to see that the locale is supported.
    //
    wsprintf(NewLocaleString,L"%.8x",NewLocale);
    if(!SetupFindFirstLine(IntlInfHandle,L"Locales",NewLocaleString,&InfContext)) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    p = pSetupGetField(&InfContext,2);
    if(!p) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }
    //
    // Copy into local storage since p points into internal structures
    // that could move as we call INF APIs
    //
    lstrcpyn(Codepage,p,sizeof(Codepage)/sizeof(Codepage[0]));

    //
    // Create a setup file queue and initialize default Setup copy queue
    // callback context.
    //
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        d = ERROR_OUTOFMEMORY;
        goto c1;
    }

    QueueContext.SetupQueueContext = IsSetup ?
        InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL) :
        SetupInitDefaultQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

    if(!QueueContext.SetupQueueContext) {
        d = ERROR_OUTOFMEMORY;
        goto c2;
    }

    //
    // Enqueue locale-related files for copy.
    //
    b = SetupInstallFilesFromInfSection(
            IntlInfHandle,
            NULL,
            FileQueue,
            NewLocaleString,
            SourcePath,
            QueueFlags
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Enqueue font-related files for copy.
    //
    d = pSetupNLSInstallFonts(
            Window,
            QueueContext.FontInf,
            Codepage,
            SizeSpec,
            FileQueue,
            SourcePath,
            QueueFlags
            );

    if(d != NO_ERROR) {
        goto c3;
    }

    //
    // Determine whether the queue actually needs to be committed.
    //
    b = SetupScanFileQueue(
            FileQueue,
            SPQ_SCAN_FILE_VALIDITY | ((Flags & SP_INSTALL_FILES_QUIETLY) ? SPQ_SCAN_PRUNE_COPY_QUEUE : SPQ_SCAN_INFORM_USER),
            Window,
            NULL,
            NULL,
            &d
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // d = 0: User wants new files or some files were missing;
    //        Must commit queue.
    //
    // d = 1: User wants to use existing files and queue is empty;
    //        Can skip committing queue.
    //
    // d = 2: User wants to use existing files but del/ren queues not empty.
    //        Must commit queue. The copy queue will have been emptied,
    //        so only del/ren functions will be performed.
    //
    if(d == 1) {

        b = TRUE;

    } else {

        //
        // Copy enqueued files.
        //
        b = SetupCommitFileQueue(
                Window,
                FileQueue,
                pSetupFontQueueCallback,
                &QueueContext
                );
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Complete installation of locale stuff.
    //
    b = SetupInstallFromInfSection(
            Window,
            IntlInfHandle,
            NewLocaleString,
            SPINST_ALL & ~SPINST_FILES,
             NULL,
            NULL,
            0,
            NULL,
            NULL,
            NULL,
            NULL
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Perform font magic associated with the new locale's codepage(s).
    //
    d = pSetupNLSInstallFonts(Window,QueueContext.FontInf,Codepage,SizeSpec,NULL,NULL,0);

c3:
    if(IsSetup) {
        TermSysSetupQueueCallback(QueueContext.SetupQueueContext);
    } else {
        SetupTermDefaultQueueCallback(QueueContext.SetupQueueContext);
    }

c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(QueueContext.FontInf);
    SetupCloseInfFile(IntlInfHandle);
c0:
    if (IsSetup) {
        SetupDebugPrint2( L"SETUP: SetupChangeLocaleEx returned %d (0x%08x)", d, d);
    }
    return(d);
}


DWORD
SetupChangeFontSize(
    IN HWND   Window,
    IN PCWSTR SizeSpec
    )
{
    DWORD d;
    WCHAR cp[24];
    FONTQCONTEXT QueueContext;
    HSPFILEQ FileQueue;
    BOOL b;

    //
    // Get the current OEM CP
    //
    wsprintf(cp,L"%u",GetOEMCP());

    //
    // Load NLS inf.
    //
    d = pSetupNLSLoadInfs(&QueueContext.FontInf,NULL);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Create queue and initialize default callback routine.
    //
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        d = ERROR_OUTOFMEMORY;
        goto c1;
    }

    QueueContext.SetupQueueContext = IsSetup ?
        InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL) :
        SetupInitDefaultQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

    if(!QueueContext.SetupQueueContext) {
        d = ERROR_OUTOFMEMORY;
        goto c2;
    }

    //
    // First pass: copy files.
    //
    d = pSetupNLSInstallFonts(
            Window,
            QueueContext.FontInf,
            cp,
            SizeSpec,
            FileQueue,
            NULL,
            SP_COPY_NEWER | BaseCopyStyle
            );
    if(d != NO_ERROR) {
        goto c3;
    }

    //
    // Determine whether the queue actually needs to be committed.
    //
    b = SetupScanFileQueue(
            FileQueue,
            SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_INFORM_USER,
            Window,
            NULL,
            NULL,
            &d
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // d = 0: User wants new files or some files were missing;
    //        Must commit queue.
    //
    // d = 1: User wants to use existing files and queue is empty;
    //        Can skip committing queue.
    //
    // d = 2: User wants to use existing files but del/ren queues not empty.
    //        Must commit queue. The copy queue will have been emptied,
    //        so only del/ren functions will be performed.
    //
    if(d == 1) {

        b = TRUE;

    } else {

        b = SetupCommitFileQueue(
                Window,
                FileQueue,
                pSetupFontQueueCallback,
                &QueueContext
                );
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Second pass: perform registry munging, etc.
    //
    d = pSetupNLSInstallFonts(Window,QueueContext.FontInf,cp,SizeSpec,NULL,NULL,0);

c3:
    if(IsSetup) {
        TermSysSetupQueueCallback(QueueContext.SetupQueueContext);
    } else {
        SetupTermDefaultQueueCallback(QueueContext.SetupQueueContext);
    }
c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(QueueContext.FontInf);
c0:
    return(d);
}


////////////////////////////////////////////////////////////////////
//
// Code below here is for regional settings stuff that occurs during
// gui mode setup
//
////////////////////////////////////////////////////////////////////


INT_PTR
CALLBACK
RegionalSettingsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    NMHDR *NotifyParams;
    WCHAR CmdLine[MAX_PATH];


    b = TRUE;

    switch(msg) {

    case WM_SIMULATENEXT:
        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        // Empty page
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(502);
            BEGIN_SECTION(L"Regional Settings Page");
            SetWizardButtons(hdlg,WizPageRegionalSettings);

            //
            // Set message text.
            //
            pSetLocaleSummaryText(hdlg);
            pSetKeyboardLayoutSummaryText(hdlg);

            //
            // Allow activation.
            //

            //
            // Show unless OEMSkipRegional = 1
            //
            if( Preinstall ) {
                //
                // Always show the page in a Preinstall, unless the user
                // has sent us OEMSkipRegional.
                //
                if (GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipRegional",0,AnswerFile))
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1 );
                }
                else
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT,0);
                }
            } else {
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                if(Unattended) {
                    if (!UnattendSetActiveDlg(hdlg,IDD_REGIONAL_SETTINGS))
                    {
                        break;
                    }
                }
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow next page to be activated.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,FALSE);
            END_SECTION(L"Regional Settings Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageRegionalSettings);
            break;

        default:
            b = FALSE;
            break;
        }

        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDB_LOCALE:
        case IDB_KBDLAYOUT:

            if(HIWORD(wParam) == BN_CLICKED) {

                PropSheet_SetWizButtons(GetParent(hdlg),0);
                EnableWindow(GetParent(hdlg),FALSE);

                wsprintf(
                    CmdLine,
                    L"/%c /s:\"%s\"",
                    (LOWORD(wParam) == IDB_LOCALE) ? L'R' : L'I',
                    LegacySourcePath
                    );

                InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);

                if(LOWORD(wParam) == IDB_LOCALE) {
                    pSetLocaleSummaryText(hdlg);
                }
                pSetKeyboardLayoutSummaryText(hdlg);

                EnableWindow(GetParent(hdlg),TRUE);
                SetWizardButtons(hdlg,WizPageRegionalSettings);
                // Get the focus tot he wizard and set it to the button the user selected.
                SetForegroundWindow(GetParent(hdlg));
                SetFocus(GetDlgItem(hdlg,LOWORD(wParam)));

            } else {
                b = FALSE;
            }
            break;

        default:
            b = FALSE;
            break;
        }

        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


VOID
pSetLocaleSummaryText(
    IN HWND hdlg
    )
{
    HINF IntlInf;
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Type;
    INFCONTEXT LineContext;
    WCHAR IdFromRegistry[9];
    WCHAR KeyName[9];
    WCHAR UserLocale[100],GeoLocation[100];
    WCHAR FormatString[300];
    WCHAR MessageText[500];
    LPCWSTR args[2];
    DWORD   dwGeoID;


    //
    // Open intl.inf. The locale descriptions are in there.
    // Lines in the [Locales] section have keys that are 32-bit
    // locale ids but the sort part is always 0, so they're more like
    // zero-extended language ids.
    //
    IntlInf = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);

    if(IntlInf == INVALID_HANDLE_VALUE) {
        LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,UserLocale,sizeof(UserLocale)/sizeof(WCHAR));
        lstrcpy(GeoLocation,UserLocale);
    } else {
        //
        // Read the user locale, which is stored as a full 32-bit LCID.
        // We have to chop off the sort id part to index intl.inf.
        //
        l = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Control Panel\\International",
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {
            d = sizeof(IdFromRegistry);
            l = RegQueryValueEx(hKey,L"Locale",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
            RegCloseKey(hKey);
            if((l == NO_ERROR) && ((Type != REG_SZ) || (d != 18))) {
                l = ERROR_INVALID_DATA;
            }
        }

        if(l == NO_ERROR) {

            l = ERROR_INVALID_DATA;

            wsprintf(KeyName,L"0000%s",IdFromRegistry+4);

            if(SetupFindFirstLine(IntlInf,L"Locales",KeyName,&LineContext)
            && SetupGetStringField(&LineContext,1,UserLocale,sizeof(UserLocale)/sizeof(WCHAR),NULL)) {

                l = NO_ERROR;
            }
        }

        if(l != NO_ERROR) {
            LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,UserLocale,sizeof(UserLocale)/sizeof(WCHAR));
        }

        SetupCloseInfFile(IntlInf);

        //
        // Read the GEO location
        //
        l = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Control Panel\\International\\Geo",
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {
            d = sizeof(IdFromRegistry);
            l = RegQueryValueEx(hKey,L"Nation",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
            RegCloseKey(hKey);
            if((l == NO_ERROR) && (Type != REG_SZ)) {
                l = ERROR_INVALID_DATA;
            }
        }

        if(l == NO_ERROR) {

            l = ERROR_INVALID_DATA;

            dwGeoID = wcstoul ( IdFromRegistry, NULL, 10 );
            if (GetGeoInfo (
                dwGeoID,
                GEO_FRIENDLYNAME,
                GeoLocation,
                sizeof(GeoLocation)/sizeof(WCHAR),
                0 )
                ) {

                l = NO_ERROR;
            }
        }

        if(l != NO_ERROR) {
            LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,GeoLocation,sizeof(GeoLocation)/sizeof(WCHAR));
        }
    }

    args[0] = UserLocale;
    args[1] = GeoLocation;

    LoadString(MyModuleHandle,IDS_LOCALE_MSG,FormatString,sizeof(FormatString)/sizeof(WCHAR));

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        FormatString,
        0,0,
        MessageText,
        sizeof(MessageText)/sizeof(WCHAR),
        (va_list *)args
        );

    SetDlgItemText(hdlg,IDT_LOCALE,MessageText);
}


VOID
pSetKeyboardLayoutSummaryText(
    IN HWND hdlg
    )
{
    LONG l;
    HKEY hKey;
    BOOL MultipleLayouts;
    DWORD d;
    DWORD Type;
    WCHAR IdFromRegistry[9];
    WCHAR Substitute[9];
    WCHAR Name[200];
    WCHAR FormatString[300];
    WCHAR MessageText[500];

    //
    // Open the Preload key in the registry.
    //
    l = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            L"Keyboard Layout\\Preload",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    MultipleLayouts = FALSE;
    if(l == NO_ERROR) {
        //
        // Pull out 2=. If it's there, then we're in a "complex" config
        // situation, which will change our message text a little.
        //
        d = sizeof(IdFromRegistry);
        if(RegQueryValueEx(hKey,L"2",NULL,&Type,(LPBYTE)IdFromRegistry,&d) == NO_ERROR) {
            MultipleLayouts = TRUE;
        }

        //
        // Get 1=, which is the main layout.
        //
        d = sizeof(IdFromRegistry);
        l = RegQueryValueEx(hKey,L"1",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
        if((l == NO_ERROR) && (Type != REG_SZ)) {
            l = ERROR_INVALID_DATA;
        }

        RegCloseKey(hKey);

        //
        // Now we look in the substitutes key to see whether there is a
        // substitute there.
        //
        if(RegOpenKeyEx(HKEY_CURRENT_USER,L"Keyboard Layout\\Substitutes",0,KEY_QUERY_VALUE,&hKey) == NO_ERROR) {

            d = sizeof(Substitute);
            if((RegQueryValueEx(hKey,IdFromRegistry,NULL,&Type,(LPBYTE)Substitute,&d) == NO_ERROR)
            && (Type == REG_SZ)) {

                lstrcpy(IdFromRegistry,Substitute);
            }

            RegCloseKey(hKey);
        }

        //
        // Form the name of the subkey that contains layout data.
        //
        wsprintf(
            Name,
            L"System\\CurrentControlSet\\Control\\Keyboard Layouts\\%s",
            IdFromRegistry
            );

        //
        // Open the key and retrieve the layout name.
        //
        l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,Name,0,KEY_QUERY_VALUE,&hKey);
        if(l == NO_ERROR) {

            d = sizeof(Name);
            l = RegQueryValueEx(hKey,L"Layout Text",NULL,&Type,(LPBYTE)Name,&d);
            if((l == NO_ERROR) && (Type != REG_SZ)) {
                l = ERROR_INVALID_DATA;
            }

            RegCloseKey(hKey);
        }
    }

    if(l != NO_ERROR) {
        LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,Name,sizeof(Name)/sizeof(WCHAR));
    }

    LoadString(
        MyModuleHandle,
        IDS_KBDLAYOUT_MSG,
        FormatString,
        sizeof(FormatString)/sizeof(WCHAR)
        );

    wsprintf(MessageText,FormatString,Name);

    SetDlgItemText(hdlg,IDT_KBD_LAYOUT,MessageText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\log.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Routines for logging actions performed during setup.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#include "setuplog.h"

//
// Severity descriptions. Initialized in InitializeSetupActionLog.
//
PCSTR SeverityDescriptions[LogSevMaximum];

//
// Constant strings used for logging in various places.
//
PCWSTR szWaitForSingleObject        = L"WaitForSingleObject";
PCWSTR szFALSE                      = L"FALSE";
PCWSTR szSetGroupOfValues           = L"SetGroupOfValues";
PCWSTR szSetArrayToMultiSzValue     = L"pSetupSetArrayToMultiSzValue";
PCWSTR szCreateProcess              = L"CreateProcess";
PCWSTR szRegOpenKeyEx               = L"RegOpenKeyEx";
PCWSTR szRegQueryValueEx            = L"RegQueryValueEx";
PCWSTR szRegSetValueEx              = L"RegSetValueEx";
PCWSTR szDeleteFile                 = L"DeleteFile";
PCWSTR szRemoveDirectory            = L"RemoveDirectory";
PCWSTR szSetupInstallFromInfSection = L"SetupInstallFromInfSection";

//
// This structure is passed as the parameter to DialogBoxParam to provide
// initialization data.
//

typedef struct _LOGVIEW_DIALOG_DATA {
    PCWSTR  LogFileName;                        // actual file used
    PCWSTR  WindowHeading;                      // actual title of main window
} LOGVIEW_DIALOG_DATA, *PLOGVIEW_DIALOG_DATA;

//
// The following SETUP_LOG_HANDLE_TYPE and SETUP_LOG_HANDLES
// are used as a means to keep track of setup logging paths.
// This way, the setup logs can be Tee'd between the files
// and their corresponding headless SAC channels.
//
// Instead of passing around file handles, we pass around
// the SETUP_LOG_HANDLES structure.  When we go to write
// the log data, we see if we can write to the corresponding
// SAC channel as well.
//
//
typedef enum {

    ActionLogType,
    ErrorLogType,
    UnknownLogType

} SETUP_LOG_HANDLE_TYPE;

typedef struct _SETUP_LOG_HANDLES {

    PVOID                   hFile;
    SETUP_LOG_HANDLE_TYPE   LogType;

} SETUP_LOG_HANDLES, *PSETUP_LOG_HANDLES;


PVOID
pOpenFileCallback(
    IN  PCTSTR  Filename,
    IN  BOOL    WipeLogFile
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    WCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;
    DWORD   Result;
    PSETUP_LOG_HANDLES  logHandles;

    //
    // Form the pathname of the logfile.
    //
    Result = GetWindowsDirectory(CompleteFilename,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return INVALID_HANDLE_VALUE;
    }
    pSetupConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    //
    // don't continue if the file handle is invalid
    //
    if (hFile == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }

    //
    // populate the log structure based on if the Filename
    // refers to the action log or to the error log
    //
    logHandles = MyMalloc(sizeof(SETUP_LOG_HANDLES));
    ASSERT(logHandles);
    if (!logHandles) {
        return INVALID_HANDLE_VALUE;
    }

    logHandles->hFile = hFile;
    
    if (_tcscmp(Filename, SETUPLOG_ACTION_FILENAME) == 0) {
        logHandles->LogType = ActionLogType;
    } else if(_tcscmp(Filename, SETUPLOG_ERROR_FILENAME) == 0) {
        logHandles->LogType = ErrorLogType;
    } else {
        //
        // one of these should match!
        //
        ASSERT(0);
        logHandles->LogType = UnknownLogType;
    }

    return (PVOID)logHandles;
}

UINT
pCloseFileCallback(
    IN  PVOID   LogHandles
    )
/*++

Routine Description:

    cleanup SETUP_LOG_HANDLE structure - close file and release memory

    Note: we don't release the SacChannelHandle because it's a pointer
          to a global
    
Arguments:

    LogHandles - SETUP_LOG_HANDLE structure   

Return Value:

    Note: UINT is used as BOOL (See CloseHandle())
    0 = failure
    1 = success

--*/
{
    PSETUP_LOG_HANDLES   p;  

    //
    // don't do anything if there isn't a valid logHandles
    // Note: This means we probably failed in pOpenFileCallback.
    //
    if (LogHandles == INVALID_HANDLE_VALUE) {
        return 0;
    }

    p = (PSETUP_LOG_HANDLES)LogHandles;

    CloseHandle(p->hFile);

    MyFree(LogHandles);

    return 1;
}

BOOL
pWriteFile (
    IN  PVOID   LogHandles,
    IN  LPCTSTR Buffer
    )
/*++

Routine Description:

    Instead of passing around file handles, we pass around
    the SETUP_LOG_HANDLES structure.  When we go to write
    the log data, we see if we can write to the corresponding
    SAC channel as well.

Arguments:

    LogHandles - SETUP_LOG_HANDLE structure   
    Buffer     - data to send  

Return Value:

    TRUE = data was written
    FALSE = data was not successfully written

--*/

{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;
    PSETUP_LOG_HANDLES   p;

    //
    // don't do anything if there isn't a valid logHandles
    // Note: This means we probably failed in pOpenFileCallback.
    //
    if (LogHandles == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    p = (PSETUP_LOG_HANDLES)LogHandles;
    
#if defined(_ENABLE_SAC_CHANNEL_LOGGING_)
    //
    // Tee the buffer output to the appropriate SAC Channel
    //
    switch(p->LogType) {
    case ActionLogType: {  
        if (SacChannelActionLogEnabled) {
            SacChannelUnicodeWrite(
                SacChannelActionLogHandle, 
                (PCWSTR)Buffer
                );
        }
        break;
    }
    case ErrorLogType: {
        if (SacChannelErrorLogEnabled) {
            SacChannelUnicodeWrite(
                SacChannelErrorLogHandle, 
                (PCWSTR)Buffer
                );
        }
        break;
    }
    default: {
        //
        // one of these should match!
        //
        ASSERT(0);
        break;
    }
    }
#endif

    //
    // Write message to log file
    //
    if(AnsiBuffer = pSetupUnicodeToAnsi (Buffer)) {
        SetFilePointer (p->hFile, 0, NULL, FILE_END);

        Status = WriteFile (
            p->hFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    //
    // Write log message to debugging log
    //
    SetupDebugPrint((LPWSTR)Buffer);

    return Status;

}

BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;
    PWSTR   p;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = pCloseFileCallback;
    Context->AllocMem = MyMalloc;
    Context->FreeMem = MyFree;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;
    Context->Lock = pAcquireMutex;
    Context->Unlock = ReleaseMutex;

    Context->Mutex = CreateMutex(NULL,FALSE,L"SetuplogMutex");

    //
    // Initialize the log severity descriptions.
    //
    for(i=0; i<LogSevMaximum; i++) {
        Context->SeverityDescriptions[i] = MyLoadString(IDS_LOGSEVINFO+i);
    }

    SetuplogInitialize (Context, FALSE);

    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_START,
        NULL,NULL);

}

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

    Close the Setup log and free resources.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    None.

--*/

{
    UINT    i;

    if(Context->Mutex) {
        CloseHandle(Context->Mutex);
        Context->Mutex = NULL;
    }

    for (i=0; i<LogSevMaximum; i++) {
        if (Context->SeverityDescriptions[i]) {
            MyFree (Context->SeverityDescriptions[i]);
        }
    }

    SetuplogTerminate();
}

DWORD CALLBACK
EditStreamCallback (
    IN HANDLE   hLogFile,
    IN LPBYTE   Buffer,
    IN LONG     cb,
    IN PLONG    pcb
    )

/*++

Routine Description:

    Callback routine used by the rich edit control to read in the log file.

Arguments:

    hLogFile - handle of file to read.  This module provides the value through
        the EDITSTREAM structure.

    Buffer - address of buffer that receives the data

    cb - number of bytes to read

    pcb - address of number of bytes actually read

Return Value:

    0 to continue the stream operation, or nonzero to abort it.

--*/

{
    DWORD error;

    if (!ReadFile (hLogFile, Buffer, cb, pcb, NULL)) {
        error = GetLastError();
        return error;
    }

    return 0;
}

BOOL
FormatText (
    IN HWND hWndRichEdit
    )

/*++

Routine Description:

    Modify the contents of the rich edit control to make the log file look
    prettier.  The modifications are driven by the array FormatStrings.  It
    contains a list of strings to search for, and modifications to make when
    a target string is found.

Arguments:

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{

    //
    // separate items in the log with a horizontal line
    //

    PCWSTR      NewTerm = L"----------------------------------------"
        L"----------------------------------------\r\n\r\n";

    FINDTEXT    FindText;       // target text to change
    INT         Position;       // start of where target was found
    INT         LineIndex;      // index of line containing target
    CHARRANGE   SelectRange;    // range where target was found
    CHARFORMAT  NewFormat;      // structure to hold our format changes
    INT         i;              // loop counter
    PWSTR       pw;             // temporary pointer
    BOOL        Status;         // return status

    //
    // An array of changes we're going to make
    //

    struct tagFormatStrings {
        PCWSTR      Find;       // target string
        PCWSTR      Replace;    // change the target to this
        COLORREF    Color;      // make target text this color
        DWORD       Effects;    // modifications to target's font
    }
    FormatStrings[] = {
        {NULL,  NULL,   RGB(0,150,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(150,150,0), CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE|CFE_ITALIC},
        {NULL,  NULL,   RGB(0,0,255),   0}
    };

    //
    // Number of elements in FormatStrings array
    //

    #define FORMATSTRINGSCOUNT  \
        (sizeof(FormatStrings) / sizeof(struct tagFormatStrings))
    MYASSERT(FORMATSTRINGSCOUNT == LogSevMaximum + 1);


    //
    // Initialize those parts of our data structures that won't change
    //

    Status = TRUE;

    NewFormat.cbSize = sizeof(NewFormat);
    FindText.chrg.cpMax = -1;   // search to the end
    for (i=0; i<LogSevMaximum; i++) {   // load severity strings
        if (!(pw = MyLoadString (IDS_LOGSEVINFO+i))) {
            Status = FALSE;
            goto cleanup;
        }
        FormatStrings[i].Find = MyMalloc((lstrlen(pw)+4)*sizeof(WCHAR));
        if(!FormatStrings[i].Find) {
            MyFree(pw);
            Status = FALSE;
            goto cleanup;
        }
        lstrcpy ((PWSTR)FormatStrings[i].Find, pw);
        lstrcat ((PWSTR)FormatStrings[i].Find, L":\r\n");
        MyFree(pw);

        if(pw = MyMalloc((lstrlen(FormatStrings[i].Find)+3)*sizeof(WCHAR))) {
            lstrcpy(pw,FormatStrings[i].Find);
            lstrcat(pw,L"\r\n");
            FormatStrings[i].Replace = pw;
        } else {
            Status = FALSE;
            goto cleanup;
        }
    }

    FormatStrings[LogSevMaximum].Find =
        pSetupDuplicateString(SETUPLOG_ITEM_TERMINATOR);
    if (!FormatStrings[LogSevMaximum].Find) {
        Status = FALSE;
        goto cleanup;
    }
    FormatStrings[LogSevMaximum].Replace = pSetupDuplicateString (NewTerm);
    if (!FormatStrings[LogSevMaximum].Replace) {
        Status = FALSE;
        goto cleanup;
    }

    //
    // Change 1 string at a time in the rich edit control
    //

    for (i=0; i<FORMATSTRINGSCOUNT; i++) {
        FindText.chrg.cpMin = 0;    // start search at beginning
        FindText.lpstrText = (PWSTR) FormatStrings[i].Find;

         //
        // Search for current target until we've found each instance
        //

        while ((Position = (INT)SendMessage
            (hWndRichEdit, EM_FINDTEXT, FR_MATCHCASE, (LPARAM) &FindText))
            != -1) {

            //
            // Verify that the target is at the beginning of the line
            //

            LineIndex = (INT)SendMessage (hWndRichEdit, EM_LINEFROMCHAR,
                Position, 0);

            if (SendMessage (hWndRichEdit, EM_LINEINDEX, LineIndex, 0) !=
                Position) {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
                continue;
            }

            //
            // Select the target text and get its format
            //

            SelectRange.cpMin = Position;
            SelectRange.cpMax = Position + lstrlen (FindText.lpstrText);
            SendMessage (hWndRichEdit, EM_EXSETSEL, 0, (LPARAM) &SelectRange);
            SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
                (LPARAM) &NewFormat);

            //
            // Modify the target's format
            //

            NewFormat.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_ITALIC;
            NewFormat.dwEffects &= ~CFE_AUTOCOLOR;
            NewFormat.crTextColor = FormatStrings[i].Color;
            NewFormat.dwEffects |= FormatStrings[i].Effects;
            SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,
                (LPARAM) &NewFormat);

            //
            // Replace the target with new text.  Set the starting point for
            // the next search at the end of the current string
            //

            if (FormatStrings[i].Replace != NULL) {
                SendMessage (hWndRichEdit, EM_REPLACESEL, FALSE,
                    (LPARAM) FormatStrings[i].Replace);
                FindText.chrg.cpMin = Position +
                    lstrlen (FormatStrings[i].Replace);
            } else {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
            }
        }
    }

cleanup:

    for (i=0; i<=LogSevMaximum; i++) {
        if (FormatStrings[i].Find) {
            MyFree (FormatStrings[i].Find);
        }
        if (FormatStrings[i].Replace) {
            MyFree (FormatStrings[i].Replace);
        }
    }
    return Status;
}

BOOL
ReadLogFile (
    PCWSTR  LogFileName,
    HWND    hWndRichEdit
    )

/*++

Routine Description:

    This routine reads the log file and initializes the contents of the Rich
    Edit control.

Arguments:

    LogFileName - path to the file we're going to read.

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{
    HANDLE      hLogFile;       // handle to log file
    EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

    hLogFile = CreateFile(
        LogFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hLogFile == INVALID_HANDLE_VALUE) {
        hLogFile = NULL;
        return FALSE;
    }

    //
    // Read the file into the Rich Edit control.
    //

    eStream.dwCookie = (DWORD_PTR) hLogFile;
    eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
    eStream.dwError = 0;
    SendMessage (hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream);
    CloseHandle (hLogFile);

    if (!FormatText (hWndRichEdit)) {
        return FALSE;
    }
    SendMessage (hWndRichEdit, EM_SETMODIFY, TRUE, 0);
    return TRUE;
}

INT_PTR
DialogProc (
    IN HWND     hDialog,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    This is the window proc for the dialog box.

Arguments:

    Standard window proc arguments.

Return Value:

    Bool that indicates whether we handled the message.

--*/

{
    HWND    hWndRichEdit;       // handle to rich edit window

    switch (message) {

    case WM_INITDIALOG:
        SetWindowText (hDialog,
            ((LOGVIEW_DIALOG_DATA *)lParam)->WindowHeading);
        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        if (!ReadLogFile (((LOGVIEW_DIALOG_DATA *)lParam)->LogFileName,
            hWndRichEdit)) {
            MessageBoxFromMessage (hDialog, MSG_UNABLE_TO_SHOW_LOG, NULL,
                IDS_ERROR, MB_OK|MB_ICONSTOP);
            EndDialog (hDialog, FALSE);
        }
        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(hDialog, MainWindowHandle, FALSE);
        else
            pSetupCenterWindowRelativeToParent(hDialog);
        PostMessage(hDialog,WM_APP,0,0);
        break;

    case WM_APP:

        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        SendMessage(hWndRichEdit,EM_SETSEL,0,0);
        SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog (hDialog, TRUE);
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
ViewSetupActionLog (
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    )

/*++

Routine Description:

    Formats the setup action log and displays it in a window.
    The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    hOwnerWindow - handle to window that owns the dialog box

    OptionalFileName - full path of the file to be displayed.

    OptionalHeading - text to be shown at the top of the window.

Return Value:

    Boolean value indicating whether the routine was sucessful.

--*/

{
    LOGVIEW_DIALOG_DATA  Global;        // initialization data for dialog box
    WCHAR       TmpFileName[MAX_PATH];  // used to create the log file name
    PCWSTR      TmpHeading;             // used to create the heading
    HANDLE      hRichedDLL;             // DLL used for rich edit
    INT         Status;                 // what we're going to return
    DWORD       Result;

    //
    // Form the pathname of the logfile.
    //

    if (!ARGUMENT_PRESENT(OptionalFileName)) {
        Result = GetWindowsDirectory (TmpFileName,MAX_PATH);
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        pSetupConcatenatePaths (TmpFileName,SETUPLOG_ERROR_FILENAME,MAX_PATH,NULL);
        Global.LogFileName = pSetupDuplicateString (TmpFileName);
    } else {
        if (wcslen(OptionalFileName) > MAX_PATH) {
            Status = 0;
            goto err0;
        }
        Global.LogFileName = pSetupDuplicateString (OptionalFileName);
    }

    if (!Global.LogFileName) {
        Status = FALSE;
        goto err0;
    }

    //
    // Form the heading for the dialog box.
    //

    if (!ARGUMENT_PRESENT(OptionalHeading)) {
        TmpHeading = MyLoadString (IDS_LOG_DEFAULT_HEADING);
    } else {
        TmpHeading = pSetupDuplicateString (OptionalHeading);
    }
    if (!TmpHeading) {
        Status = FALSE;
        goto err1;
    }

    Global.WindowHeading = FormatStringMessage (IDS_LOG_WINDOW_HEADING,
        TmpHeading, Global.LogFileName);
    if (!Global.WindowHeading) {
        Status = FALSE;
        goto err2;
    }

    //
    // Create the dialog box.
    //

    if (!(hRichedDLL = LoadLibrary (L"RICHED20.DLL"))) {
        Status = FALSE;
        goto err3;
    }
    Status = (BOOL)DialogBoxParam (MyModuleHandle, MAKEINTRESOURCE(IDD_VIEWLOG),
        hOwnerWindow, DialogProc, (LPARAM) &Global);

    //
    // Clean up and return.
    //

    FreeLibrary (hRichedDLL);
err3:
    MyFree (Global.WindowHeading);
err2:
    MyFree (TmpHeading);
err1:
    MyFree (Global.LogFileName);
err0:
    return Status;
}

VOID
LogRepairInfo(
    IN  PCWSTR  Source,
    IN  PCWSTR  Target
    )
{
    static WCHAR    RepairLog[MAX_PATH];
    static DWORD    WinDirLength;
    static DWORD    SourcePathLength;
    PWSTR           SourceName;
    DWORD           LastSourceChar, LastTargetChar;
    DWORD           LastSourcePeriod, LastTargetPeriod;
    WCHAR           Filename[MAX_PATH];
    WCHAR           Line[MAX_PATH];
    WCHAR           tmp[MAX_PATH];
    BOOLEAN         IsNtImage;
    ULONG           Checksum;
    BOOLEAN         Valid;
    DWORD           Result;


    if(!RepairLog[0]) {
        //
        // We haven't calculated the path to setup.log yet
        //
        Result = GetWindowsDirectory( RepairLog, MAX_PATH );
        if( Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        WinDirLength = lstrlen( RepairLog );
        pSetupConcatenatePaths( RepairLog, L"repair\\setup.log", MAX_PATH, NULL );
        SourcePathLength = lstrlen( SourcePath );
    }

    //
    // Only log the file if it's inside the Windows directory.
    //
    if( !wcsncmp( Target, RepairLog, WinDirLength )) {

        //
        // If we're installing an OEM driver, we shouldn't log it because we can't
        // repair it.  Make sure the file comes from either the local source or
        // the windows directory (for files from driver.cab).
        //
        if (wcsncmp( Source, SourcePath, SourcePathLength ) &&
            wcsncmp( Source, RepairLog, WinDirLength )
            ) {

            SetupDebugPrint2(L"SETUP: oem driver not logged: %ws -> %ws.",
                Source, Target);
            return;
        }

        if( ValidateAndChecksumFile( Target, &IsNtImage, &Checksum, &Valid )) {

            //
            // Strip off drive letter.
            //
            swprintf(
                Filename,
                L"\"%s\"",
                Target+2
                );

            //
            // Convert source name to uncompressed form.
            //
            SourceName = pSetupDuplicateString( wcsrchr( Source, (WCHAR)'\\' ) + 1 );
            if(!SourceName) {
                SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in LogRepairInfo." );
                return;
            }
            LastSourceChar = wcslen (SourceName) - 1;

            if(SourceName[LastSourceChar] == L'_') {
                LastSourcePeriod = (DWORD)(wcsrchr( SourceName, (WCHAR)'.' ) - SourceName);
                MYASSERT(LastSourceChar - LastSourcePeriod < 4);

                if(LastSourceChar - LastSourcePeriod == 1) {
                    //
                    // No extension - just truncate the "._"
                    //
                    SourceName[LastSourceChar-1] = L'\0';
                } else {
                    //
                    // Make sure the extensions on source and target match.
                    // If this fails, we can't log the file copy
                    //
                    LastTargetChar = wcslen (Target) - 1;
                    LastTargetPeriod = (ULONG)(wcsrchr( Target, (WCHAR)'.' ) - Target);

                    if( _wcsnicmp(
                        SourceName + LastSourcePeriod,
                        Target + LastTargetPeriod,
                        LastSourceChar - LastSourcePeriod - 1 )) {

                        SetupDebugPrint2(L"SETUP: unable to log the following file copy: %ws -> %ws.",
                            Source, Target);
                        MyFree (SourceName);
                        return;
                    }

                    if(LastTargetChar - LastTargetPeriod < 3) {
                        //
                        // Short extension - just truncate the "_"
                        //
                        SourceName[LastSourceChar] = L'\0';
                    } else {
                        //
                        // Need to replace "_" with last character from target
                        //
                        MYASSERT(LastTargetChar - LastTargetPeriod == 3);
                        SourceName[LastSourceChar] = Target[LastTargetChar];
                    }
                }
            }

            swprintf(
                Line,
                L"\"%s\",\"%x\"",
                SourceName,
                Checksum);


            if (GetPrivateProfileString(L"Files.WinNt",Filename,L"",tmp,sizeof(tmp)/sizeof(tmp[0]),RepairLog)) {
                //
                // there is already an entry for this file present (presumably
                // from textmode phase of setup.) Favor this entry over what we
                // are about to add
                //
                SetupDebugPrint1(L"SETUP: skipping log of %ws since it's already present in setup.log.", Target);
            } else {
                WritePrivateProfileString(
                    L"Files.WinNt",
                    Filename,
                    Line,
                    RepairLog);
            }

            MyFree (SourceName);

        } else {
            SetupDebugPrint1(L"SETUP: unable to compute checksum for %ws.", Target);
        }
    }
}


BOOL
WINAPI
pSetuplogSfcError(
    IN PCWSTR String,
    IN DWORD Index
    )
/*++

Routine Description:

   This function is used by sfc.dll to log any file signature problems when sfc
   is run during setup.  if you change this you MUST change the caller in
   \nt\private\sm\sfc\dll\eventlog.c


Arguments:

    String - pointer to a filename string for the problem file.
    Index  - this identifies what message should be logged onto the system.

Return Value:

    TRUE for success (the message was added to the errorlog), FALSE for failure.

--*/
{
    DWORD MessageId;
    DWORD Severity;

#if PRERELEASE
    SfcErrorOccurred = TRUE;
#endif

    switch (Index) {
    case 0:
        MessageId= MSG_DLL_CHANGE;
        Severity = LogSevInformation;
        break;
    case 1:
        MessageId= MSG_DLL_CHANGE_FAILURE;
        Severity = LogSevError;
        break;
    case 2:
        MessageId= MSG_DLL_CACHE_COPY_ERROR;
        Severity = LogSevInformation;
        break;
    default:
        MYASSERT(FALSE && "Unknown message id pSetuplogSfcError");
        return(FALSE);
    }

    return SetuplogError(
        SETUPLOG_SINGLE_MESSAGE | Severity,
        SETUPLOG_USE_MESSAGEID,
        MessageId,
        String, NULL, NULL
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\inifile.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    inifile.c

Abstract:

    Routines to deal with ini files.

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// Constants
//
PCWSTR szWININI   = L"win.ini",
       szWINLOGON = L"winlogon",
       szUSERINIT = L"userinit",
       szDESKTOP  = L"desktop";


BOOL
ReplaceIniKeyValue(
    IN PCWSTR IniFile,
    IN PCWSTR Section,
    IN PCWSTR Key,
    IN PCWSTR Value
    )
{
    BOOL b;

    b = WritePrivateProfileString(Section,Key,Value,IniFile);
    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INIWRITE_FAIL,
            IniFile,
            Section,
            Key,
            Value,
            GetLastError(),
            NULL,NULL);
    }

    return(b);
}


BOOL
WinIniAlter1(
    VOID
    )
{
    BOOL b;
    WCHAR AdminName[MAX_USERNAME+1];

    if(!LoadString(MyModuleHandle,IDS_ADMINISTRATOR,AdminName,ARRAYSIZE(AdminName))){
        return FALSE;
    }

#ifdef DOLOCALUSER
    b = ReplaceIniKeyValue(
            szWININI,
            szWINLOGON,
            L"DefaultUserName",
            CreateUserAccount ? UserName : AdminName
            );
#else
    b = ReplaceIniKeyValue(szWININI,szWINLOGON,L"DefaultUserName",AdminName);
#endif

    if(!ReplaceIniKeyValue(szWININI,szWINLOGON,L"DebugServerCommand",L"no")) {
        b = FALSE;
    }

    return(b);
}


BOOL
SetDefaultWallpaper(
    VOID
    )
{
    BOOL b;
    PCWSTR p;

    b = FALSE;
    if(p = MyLoadString(IDS_DEFWALLPAPER)) {
        b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"Wallpaper",p);
        MyFree(p);
        b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"TileWallpaper",L"0");
    }
    return(b);
}


BOOL
SetShutdownVariables(
    VOID
    )
{
    BOOL b;

    if( (Upgrade) || (ProductType == PRODUCT_WORKSTATION) ) {
        b = TRUE;
    } else {
        b = ReplaceIniKeyValue(szWININI,szWINLOGON,L"ShutdownWithoutLogon",L"0");
    }

    return(b);
}


BOOL
SetLogonScreensaver(
    VOID
    )
{
    BOOL b;

    b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"ScreenSaveActive",L"1");
    b &= ReplaceIniKeyValue(szWININI,szDESKTOP,L"SCRNSAVE.EXE",L"logon.scr");

    return(b);
}


BOOL
InstallOrUpgradeFonts(
    VOID
    )
{
    BOOL b;

    b = SetupInstallFromInfSection(
            NULL,
            SyssetupInf,
            Upgrade ? L"UpgradeFonts" : L"InstallFonts",
            SPINST_INIFILES,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            NULL,
            NULL
            );

    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FONTINST_FAIL, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"SetupInstallFromInfSection",
            GetLastError(),
            NULL,NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\makefile.inc ===
$(O)\setupsys.res: setupsys.rc msg.mc dialogs.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\infcache.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    infcache.c

Abstract:

    This module implements a simple inf caching mechanism.

    WARNING: THE CODE IN THIS MODULE IS NOT MULTI-THREAD SAFE.
    EXERCISE EXTREME CAUTION WHEN MAKING USE OF THESE ROUTINES.

Author:

    Ted Miller (tedm) 28-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Structure for cached inf. We assume that there won't be
// too many of these open at the same time so we just keep
// a linear list.
//
typedef struct _INFC {

    struct _INFC *Next;

    //
    // Name of INF
    //
    PCWSTR Filename;

    //
    // Handle to inf.
    //
    HINF InfHandle;

} INFC, *PINFC;

PINFC OpenInfList;


HINF
InfCacheOpenInf(
    IN PCWSTR FileName,
    IN PCWSTR InfType       OPTIONAL
    )

/*++

Routine Description:

    Open a (win95-style) inf file if it has not already been opened
    via the cached inf mechanism.

Arguments:

    FileName - supplies name of inf file to be opened. Matching is
        based solely on this string as given here; no processing on it
        is performed and no attempt is made to determine where the inf
        file is actually located.

    InfType - if specified supplies an argument to be passed to
        SetupOpenInfFile() as the InfType parameter.

Return Value:

    Handle of inf file if successful; NULL if not.

--*/

{
    PINFC p;
    HINF h;

    //
    // Look for inf to see if it's already open.
    //
    for(p=OpenInfList; p; p=p->Next) {
        if(!lstrcmpi(p->Filename,FileName)) {
            return(p->InfHandle);
        }
    }

    h = SetupOpenInfFile(FileName,InfType,INF_STYLE_WIN4,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        return(NULL);
    }

    p = MyMalloc(sizeof(INFC));
    if(!p) {
        SetupCloseInfFile(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    p->Filename = pSetupDuplicateString(FileName);
    if(!p->Filename) {
        MyFree(p);
        SetupCloseInfFile(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    p->InfHandle = h;
    p->Next = OpenInfList;
    OpenInfList = p;

    return(h);
}


HINF
InfCacheOpenLayoutInf(
    IN HINF InfHandle
    )
{
    INFCONTEXT InfContext;
    BOOL b;
    DWORD DontCare;
    HINF h;
    WCHAR FileName[MAX_PATH],TempName[MAX_PATH];
    PINFC p;

    //
    // Fetch the name of the layout inf.
    // Note that an INF is perfectly capable of acting as its own layout inf.
    //
    if(SetupFindFirstLine(InfHandle,L"Version",L"LayoutFile",&InfContext)) {

        if(SetupGetStringField(&InfContext,1,FileName,MAX_PATH,&DontCare)) {
            //
            // Open the layout inf. If first attempt fails,
            // try opening it in the current directory (unqualified inf names
            // will be looked for in %sysroot%\inf, which might not be what
            // we want).
            //
            h = InfCacheOpenInf(FileName,NULL);
            if(!h) {
                TempName[0] = L'.';
                TempName[1] = 0;
                pSetupConcatenatePaths(TempName,FileName,MAX_PATH,NULL);
                h = InfCacheOpenInf(TempName,NULL);
            }
        } else {
            //
            // INF is corrupt
            //
            h = NULL;
        }
    } else {
        //
        // No layout inf: inf is its own layout inf
        //
        h = InfHandle;
    }

    return(h);
}


VOID
InfCacheEmpty(
    IN BOOL CloseInfs
    )
{
    PINFC p,q;
    HINF h;

    for(p=OpenInfList; p; ) {

        q = p->Next;

        if(CloseInfs) {
            SetupCloseInfFile(p->InfHandle);
        }

        MyFree(p->Filename);
        MyFree(p);

        p = q;
    }
}

BOOL
InfCacheRefresh(
    VOID
    )
/*++

Routine Description:

    Refresh all of the open cached inf files.

Arguments:

    None.

Return Value:

    TRUE on success.

    Note: This routine can be used to reopen all cached infs in the current
          context.  This could be necessary if the locale changes, for instance.


--*/

{
    PINFC p,q;
    HINF h;
    BOOL bRet = TRUE;

    for(p=OpenInfList; p; ) {

        q = p->Next;

        SetupCloseInfFile(p->InfHandle);
        p->InfHandle = SetupOpenInfFile(p->Filename,NULL,INF_STYLE_WIN4,NULL);
        bRet = (p->InfHandle == INVALID_HANDLE_VALUE) ? FALSE : bRet;
        p = q;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\mainwind.c ===
#include "setupp.h"
#pragma hdrstop
#include <winuserp.h>

PCWSTR szWindowClass = L"$$$SetupBackground";

//
// Window longs for background window.
//
#define XWL_BITMAP  (0)
#define XWL_LOGO    (XWL_BITMAP + sizeof(PVOID))
#define XWL_BANNER  (XWL_LOGO + sizeof(PVOID))
#define XWL_FONT    (XWL_BANNER + sizeof(PVOID))
#define WL_COUNT    (4 * sizeof(PVOID))

#define POINTSIZE_WASHTEXT 24

HANDLE SetupWindowThreadHandle = NULL;


VOID
SetupMakeSureFontIsAvailable()
{
    static BOOL     DoneAlready = FALSE;
    LONG            l;
    HKEY            hKey;
    DWORD           i;
    WCHAR           Name[256];
    WCHAR           Data[256];
    DWORD           s1;
    DWORD           s2;
    DWORD           Type;
    DWORD           Result;

    if(DoneAlready) {
        return;
    }

    //
    // Want MS Serif but don't know which one serife.fon, seriffg.fon, etc.
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    if(l == NO_ERROR) {

        i = 0;
        s1 = 256;
        s2 = 256;
        while(RegEnumValueW(hKey,i,Name,&s1,NULL,&Type,(LPBYTE) Data,&s2)
            == NO_ERROR) {

            if(Type == REG_SZ) {
                CharUpper(Name);
                if(wcsstr(Name,L"MS SERIF")) {
                    //
                    // Value data is filename.
                    //
                    GetWindowsDirectory(Name,256);
                    lstrcat(Name,L"\\FONTS\\");
                    lstrcat(Name,Data);
                    if(AddFontResource(Name)) {
                        DoneAlready = TRUE;
                        break;
                    }
                }
            }

            i++;
            s1 = 256;
            s2 = 256;
        }

        RegCloseKey(hKey);
    }

    //
    // One last-ditch effort
    //
    if(!DoneAlready) {
        Result = GetWindowsDirectory(Name,256);
        if( Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        lstrcat(Name,L"\\FONTS\\SERIFE.FON");
        if(AddFontResource(Name)) {
            DoneAlready = TRUE;
        }
    }
}

LRESULT
SetupBackgroundWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT l;
    HBITMAP hbm;
    LOGFONT LogFont;
    HFONT hFont;
    HDC hdc;
    HDC hdcMem;
    PAINTSTRUCT ps;
    RECT rc;
    COLORREF crBk,crTx;
    BITMAP bitmap;
    HBITMAP hbmOld;
    HFONT hFontOld;
    WCHAR Buffer[MAX_PATH];
    int OldMode;
    int i;
    PWSTR p;

    switch(msg) {

    case WM_CREATE:
        //
        // Load the default background bitmap and indicate no oem logo bitmap.
        //
#if 0
        hbm = LoadBitmap(
            MyModuleHandle,
            (ProductType == PRODUCT_WORKSTATION) ?
                MAKEINTRESOURCE(IDB_BACKGROUND_WORKSTATION) :
                MAKEINTRESOURCE(IDB_BACKGROUND_SERVER)
            );
#else
        GetSystemDirectory( Buffer, MAX_PATH );
        pSetupConcatenatePaths(Buffer,TEXT("setup.bmp"),MAX_PATH,NULL);
        hbm = (HBITMAP)LoadImage(NULL,Buffer,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
#endif
        SetWindowLongPtr(hwnd,XWL_BITMAP,(LONG_PTR)hbm);
        SetWindowLongPtr(hwnd,XWL_LOGO,0);

#if 0   // Don't show any text for now.
        //
        // Load default banner text.
        //
        LoadString(MyModuleHandle,IDS_WINNT_SETUP,Buffer,sizeof(Buffer)/sizeof(WCHAR));
        SetWindowLongPtr(hwnd,XWL_BANNER,(LONG_PTR)pSetupDuplicateString(Buffer));
#endif

        //
        // Create font used to display text in upper left corner.
        //
        hdc = GetDC(hwnd);
        if( hdc ) {
            i = GetDeviceCaps(hdc,LOGPIXELSY);
            ReleaseDC(hwnd,hdc);
            SetupMakeSureFontIsAvailable();
            ZeroMemory(&LogFont,sizeof(LOGFONT));
            LogFont.lfHeight = -1 * (i * POINTSIZE_WASHTEXT / 72);
            LogFont.lfWeight = FW_DONTCARE;
            LogFont.lfCharSet = DEFAULT_CHARSET;
            LogFont.lfQuality = PROOF_QUALITY;
            LogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_ROMAN;
            lstrcpy(LogFont.lfFaceName,L"MS Serif");
            hFont = CreateFontIndirect(&LogFont);
            SetWindowLongPtr(hwnd,XWL_FONT,(LONG_PTR)hFont);
        }
        //
        // Allow window creation to continue.
        //
        l = 0;
        break;

    case WM_NEWBITMAP:
        //
        // wParam tells us which bitmap; lParam is the bitmap handle
        // (or pointer to a banner string).
        //
        switch(wParam) {

        case SetupBmBackground:

            if(hbmOld = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {
                DeleteObject(hbmOld);
            }
            SetWindowLongPtr(hwnd,XWL_BITMAP,lParam);
            break;

        case SetupBmLogo:

            if(hbmOld = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {
                DeleteObject(hbmOld);
            }
            SetWindowLongPtr(hwnd,XWL_LOGO,lParam);
            break;

        case SetupBmBanner:

            if(p = (PWSTR)GetWindowLongPtr(hwnd,XWL_BANNER)) {
                MyFree(p);
            }
            SetWindowLongPtr(hwnd,XWL_BANNER,lParam);
            break;
        }

        l = 0;
        break;

    case WM_PAINT:

        #define BANNER_OFFSET_X 5
        #define BANNER_OFFSET_Y 5

        //
        // The window class has CS_OWNDC so BeginPaint will succeed.
        //
        BeginPaint(hwnd,&ps);
        GetClientRect(hwnd,&rc);

        if(hdcMem = CreateCompatibleDC(ps.hdc)) {

            crBk = SetBkColor(ps.hdc,RGB(0,0,128));
            crTx = SetTextColor(ps.hdc,RGB(0,0,0));

            if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {

                if(hbmOld = SelectObject(hdcMem,hbm)) {

                    GetObject(hbm,sizeof(BITMAP),&bitmap);

                    BitBlt(
                        ps.hdc,
                        rc.left + (((rc.right - rc.left) - bitmap.bmWidth) / 2),
                        rc.top + (((rc.bottom - rc.top) - bitmap.bmHeight) / 2),
                        bitmap.bmWidth,
                        bitmap.bmHeight,
                        hdcMem,
                        0,0,
                        SRCCOPY
                        );

                    SelectObject(hdcMem,hbmOld);
                }
            }

            if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {

                SetBkColor(ps.hdc,RGB(255,255,255));
                SetTextColor(ps.hdc,RGB(0,0,0));

                if(hbmOld = SelectObject(hdcMem,hbm)) {

                    GetObject(hbm,sizeof(BITMAP),&bitmap);

                    BitBlt(
                        ps.hdc,
                        (rc.right - bitmap.bmWidth) - BANNER_OFFSET_X,
                        rc.top + BANNER_OFFSET_Y,
                        bitmap.bmWidth,
                        bitmap.bmHeight,
                        hdcMem,
                        0,0,
                        SRCCOPY
                        );

                    SelectObject(hdcMem,hbmOld);
                }
            }

            SetBkColor(ps.hdc,crBk);
            SetTextColor(ps.hdc,crTx);

            DeleteDC(hdcMem);
        }

        hFont = (HFONT)GetWindowLongPtr(hwnd,XWL_FONT);
        if(hFont) {
            hFontOld = SelectObject(ps.hdc,hFont);
        } else {
            hFontOld = NULL;
        }

        crTx = SetTextColor(ps.hdc,RGB(255,255,255));
        OldMode = SetBkMode(ps.hdc,TRANSPARENT);

        if(p = (PWSTR)GetWindowLongPtr(hwnd,XWL_BANNER)) {
            //
            // Use this API so we get CR/LF to break a line
            //
            rc.left += BANNER_OFFSET_X;
            rc.top += BANNER_OFFSET_Y;
            DrawText(ps.hdc,p,-1,&rc,DT_NOPREFIX);
        }

        SetTextColor(ps.hdc,crTx);
        if(OldMode) {
            SetBkMode(ps.hdc,OldMode);
        }

        if(hFontOld) {
            SelectObject(ps.hdc,hFontOld);
        }

        EndPaint(hwnd,&ps);
        l = 0;
        break;

    case WM_DESTROY:

        //
        // Clean up.
        //
        if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {
            DeleteObject(hbm);
        }

        if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {
            DeleteObject(hbm);
        }

        if(hFont = (HFONT)GetWindowLongPtr(hwnd,XWL_FONT)) {
            DeleteObject(hFont);
        }
        TerminateBillBoard();

        PostQuitMessage(0);
        l = 0;
        break;

    case WM_EXIT_SETUPWINDOW:
        DestroyWindow(hwnd);
        l = 0;
        break;

    case WM_HOTKEY:
        if (wParam == 0x6969) {
            //
            // Do this to make sure we get the correct cmd.exe, not whatever
            // is in our current path.
            //
            WCHAR Path[MAX_PATH];
            WCHAR CmdLine[MAX_PATH];
            ExpandEnvironmentStrings(
                            L"%SystemRoot%\\system32\\cmd.exe",
                            Path,
                            MAX_PATH);

            wsprintf(CmdLine, L"/c start %s", Path);
            InvokeExternalApplication(Path,CmdLine,NULL);
        }
        else if (wParam == 0xC2C2)
        {
            // User pressed key to make the wizard visible.
            // does not stop the billboard.
            if (WizardHandle)
            {
                SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)FALSE, 0);
            }
        }
        l = 0;
        break;

    default:
        l = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(l);
}


DWORD
SetupWindowThread(
    PVOID ThreadParam
    )
{
    WNDCLASS wc;
    HWND hwnd;
    HWND hwndBB = NULL;
    DWORD ThreadId;
    MSG msg;
    BOOL b;
    WCHAR Buffer[128];
    HMODULE hmodSyssetup = NULL;

    //
    // The thread param is actually the thread id of the main thread.
    //
    ThreadId = (DWORD)((DWORD_PTR)ThreadParam);

    hwnd = NULL;

    wc.style = CS_NOCLOSE | CS_OWNDC;
    wc.lpfnWndProc = SetupBackgroundWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = WL_COUNT;
    wc.hInstance = MyModuleHandle;
    wc.hIcon = LoadIcon(MyModuleHandle,MAKEINTRESOURCE(IDI_SETUP));
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);

    //
    // Background will be erased to black, which is what we want.
    //
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);

    wc.lpszMenuName = NULL;
    wc.lpszClassName = szWindowClass;

    if(RegisterClass(&wc)) {
        // add an extra dllref that holds syssetup.dll in process for the lifetime of the
        // $$$SetupBackground window.
        hmodSyssetup = LoadLibrary(TEXT("syssetup.dll")); 

        LoadString(MyModuleHandle,IDS_WINNT_SETUP,Buffer,sizeof(Buffer)/sizeof(WCHAR));
        hwnd = CreateWindow(
                    szWindowClass,
                    Buffer,  // L"Windows NT Setup",
                    WS_POPUP | WS_CLIPCHILDREN,
                    0,0,
                    GetSystemMetrics(SM_CXSCREEN),
                    GetSystemMetrics(SM_CYSCREEN),
                    NULL,
                    NULL,
                    MyModuleHandle,
                    0
                    );

        SetupWindowHandle = hwnd;
        if(hwnd) {
            ShowWindow(hwnd,SW_SHOW);
            //
            // Make this window bottommost.
            //
            SetShellWindow(hwnd);
            RegisterHotKey(hwnd,0x6969,MOD_SHIFT,VK_F10);
            RegisterHotKey(hwnd,0xC2C2,MOD_SHIFT,VK_F11);
        }
    }

    if (!MiniSetup)
    {
        PrepareBillBoard(hwnd);

        // If we have a Billboard, assign hwnd the windows handle. 
        // That way all dialogs have the billboard as the parent.
        // hwnd is returned by CreateSetupWindow and assinged to MainWindowHandle
        hwndBB = GetBBhwnd();
        if (hwndBB != NULL)
            hwnd = hwndBB; 
    }

    if(ThreadId != (DWORD)(-1)) {
        //
        // Called as a thread. Need to tell the main thread
        // the window handle.
        //
        PostThreadMessage(ThreadId,WM_MY_STATUS,0,(LPARAM)hwnd);

        //
        // Pump the message queue for this thread.
        //
        while((b = GetMessage(&msg,NULL,0,0)) && (b != (BOOL)(-1))) {
            DispatchMessage(&msg);
        }
    }

    if (hmodSyssetup)
    {
        FreeLibraryAndExitThread(hmodSyssetup, HandleToUlong(hwnd));
    }
    
    return HandleToUlong(hwnd);
}


HWND
CreateSetupWindow(
    VOID
    )
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HWND hwnd;
    MSG msg;

    //
    // Create a thread that will in turn create and own the window.
    // This way, the window is always responsive and redraws correctly
    // without special processing requirements.
    //
    SetupWindowThreadHandle = CreateThread(
                        NULL,
                        0,
                        SetupWindowThread,
                        LongToPtr( GetCurrentThreadId() ),
                        0,
                        &ThreadId
                        );

    if(SetupWindowThreadHandle) {

        //
        // Wait for the thread to tell us whether it could
        // create the window or not.
        //
        do {
            WaitMessage();
        } while(!PeekMessage(&msg,(HWND)(-1),WM_MY_STATUS,WM_MY_STATUS,PM_REMOVE));

        hwnd = (HWND)msg.lParam;

    } else {
        //
        // Unable to create the thread. Do it the old fashioned way;
        // this is better than nothing and at least setup will continue.
        //
        hwnd = (HWND)LongToHandle( SetupWindowThread((PVOID)(-1)) );
    }

    return(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\names.c ===
#include "setupp.h"
#pragma hdrstop

//
// List of characters that are not legal in netnames.
//
PCWSTR IllegalNetNameChars = L"\"/\\[]:|<>+=;,?*";

//
// Computer name.
//
WCHAR ComputerName[DNS_MAX_LABEL_LENGTH+1];
WCHAR Win32ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
BOOL IsNameTruncated;
BOOL IsNameNonRfc;

//
// Copy disincentive name/organization strings.
//
WCHAR NameOrgName[MAX_NAMEORG_NAME+1];
WCHAR NameOrgOrg[MAX_NAMEORG_ORG+1];

#ifdef DOLOCALUSER
//
// User name and password
//
WCHAR UserName[MAX_USERNAME+1];
WCHAR UserPassword[MAX_PASSWORD+1];
BOOL CreateUserAccount = FALSE;
#endif // def DOLOCALUSER

//
// Administrator password.
//
WCHAR   CurrentAdminPassword[MAX_PASSWORD+1];
WCHAR   AdminPassword[MAX_PASSWORD+1];
BOOL    EncryptedAdminPasswordSet = FALSE;
BOOL    DontChangeAdminPassword = FALSE;

//  --------------------------------------------------------------------------
//  ::DisableEditSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows us to not
//              process WM_CUT/WM_COPY/WM_PASTE/WM_CLEAR/WM_UNDO and any
//              other messages to be discarded.
//
//  History:    2001-02-18  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    DisableEditSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT     lResult;

    switch (uMsg)
    {
        case WM_CUT:
        case WM_COPY:
        case WM_PASTE:
        case WM_CLEAR:
        case WM_UNDO:
        case WM_CONTEXTMENU:
            lResult = FALSE;
            break;
        default:
            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}

INT_PTR NoPasswordDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    HICON               hicon = NULL;
    switch(msg) {

    case WM_INITDIALOG:
        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
        else
            pSetupCenterWindowRelativeToParent(hdlg);
        if (hicon = LoadIcon(NULL, IDI_WARNING)) 
        {
            SendDlgItemMessage(hdlg, IDC_WARNING, STM_SETICON, (WPARAM)hicon, 0L);
            DestroyIcon(hicon);
        }
        // Make the No button the default button
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        return(FALSE);

    case WM_COMMAND:
        EndDialog (hdlg, wParam);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR WeakPasswordDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    HICON               hicon = NULL;
    switch(msg) {

    case WM_INITDIALOG:
        {
            WCHAR szString[MAX_BUF];
            LPWSTR szAdminName = (LPWSTR)lParam;
            // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
            if (GetBBhwnd())
            {
                CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
            }
            else
            {
                pSetupCenterWindowRelativeToParent(hdlg);
            }
            if (LoadString(MyModuleHandle,
                    IDS_WEAKPASSWORD_MSG1,
                    szString,
                    MAX_BUF) != 0)
            {
                PWSTR  szLine;
                szLine = RetrieveAndFormatMessage( szString, 0, szAdminName );
                if (szLine)
                {
                    SetWindowText(GetDlgItem(hdlg, IDC_WEAK_MSG1),szLine);
                    MyFree( szLine );
                }
            }
            if (hicon = LoadIcon(NULL, IDI_WARNING)) 
            {
                SendDlgItemMessage(hdlg, IDC_WARNING, STM_SETICON, (WPARAM)hicon, 0L);
                DestroyIcon(hicon);
            }
            // Make the No button the default button
            SetFocus(GetDlgItem(hdlg,IDCANCEL));
        }
        return(FALSE);

    case WM_COMMAND:
        EndDialog(hdlg, wParam);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL IsComplexPassword(LPWSTR szPassword)
{
    BOOL bComplex = FALSE; // assume the password in not complex enough
    DWORD cchPassword;
    PWORD CharType;
    DWORD i;
    DWORD dwNum = 0;
    DWORD dwUpper = 0;
    DWORD dwLower = 0;
    DWORD dwSpecial = 0;

    //
    // check    if the password is complex enough for our liking by
    // checking that    at least two of the four character types are
    // present.
    //
    cchPassword = lstrlen(szPassword);
    CharType    = LocalAlloc(LPTR, cchPassword * sizeof(WORD) );
    if (CharType    == NULL)
    {
        return  FALSE;
    }

    if (GetStringTypeW(
        CT_CTYPE1,
        szPassword,
        cchPassword,
        CharType
        ))
    {
        for (i = 0 ; i < cchPassword ; i++)
        {
            //
            //  keep track of what type of characters we have encountered
            //
            if  (CharType[i] & C1_DIGIT)
            {
                dwNum = 1;
                continue;
            }
            if  (CharType[i] & C1_UPPER)
            {
                dwUpper = 1;
                continue;
            }
            if  (CharType[i] & C1_LOWER)
            {
                dwLower = 1;
                continue;
            }
            if  (!(CharType[i] & (C1_ALPHA | C1_DIGIT) ))
            {
                dwSpecial = 1;
                continue;
            }
        }   // for

        //
        // Indicate whether we encountered enough password complexity
        //
        if ( (dwNum + dwUpper + dwLower + dwSpecial) > 2  )
        {
            bComplex =  TRUE;
        }
    } //    if

    LocalFree(CharType);
    return bComplex;
}

BOOL IsStrongPasswordEx(LPWSTR szPassword, LPWSTR szAdminAccountName)
{
    BOOL bStrong =  FALSE; // assume the password in not strong
    if ((lstrlen(szPassword) >= 6) &&
        (StrStrI(szPassword,L"Admin") == NULL) &&
        (StrStrI(szPassword,szAdminAccountName) == NULL))
    {
        bStrong = IsComplexPassword(szPassword);
    }
    return bStrong;
}


VOID
GenerateName(
    OUT PWSTR  GeneratedString,
    IN  DWORD  DesiredStrLen
    )
{
static DWORD Seed = 98725757;
static PCWSTR UsableChars = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

//
// How many characters will come from the org/name string.
//
DWORD   BaseLength = 8;
DWORD   i,j;
DWORD   UsableCount;

    if( DesiredStrLen < BaseLength ) {
        BaseLength = DesiredStrLen - 1;
    }


    if( NameOrgOrg[0] ) {
        wcscpy( GeneratedString, NameOrgOrg );
    } else if( NameOrgName[0] ) {
        wcscpy( GeneratedString, NameOrgName );
    } else {
        wcscpy( GeneratedString, TEXT("X") );
        for( i = 1; i < BaseLength; i++ ) {
            wcscat( GeneratedString, TEXT("X") );
        }
    }

    //
    // Get him upper-case for our filter...
    //
    CharUpper(GeneratedString);

    //
    // Now we want to put a '-' at the end
    // of our GeneratedString.  We'd like it to
    // be placed in the BASE_LENGTH character, but
    // the string may be shorter than that, or may
    // even have a ' ' in it.  Figure out where to
    // put the '-' now.
    //
    for( i = 0; i <= BaseLength; i++ ) {

        //
        // Check for a short string.
        //
        if( (GeneratedString[i] == 0   ) ||
            (GeneratedString[i] == L' ') ||
            (!wcschr(UsableChars, GeneratedString[i])) ||
            (i == BaseLength      )
          ) {
            GeneratedString[i] = L'-';
            GeneratedString[i+1] = 0;
            break;
        }
    }

    //
    // Special case the scenario where we had no usable
    // characters.
    //
    if( GeneratedString[0] == L'-' ) {
        GeneratedString[0] = 0;
    }

    UsableCount = lstrlen(UsableChars);
    Seed ^= GetCurrentTime();
    srand( Seed );

    j = lstrlen( GeneratedString );
    for( i = j; i < DesiredStrLen; i++ ) {
        GeneratedString[i] = UsableChars[rand() % UsableCount];
    }
    GeneratedString[i] = 0;

    //
    // In the normal case, the edit control in the wizard page
    // has the ES_UPPER bit set. In the normal unattend case
    // there is code in unattend.txt that uppercases the name.
    // But if we get to generating the name then then the text
    // in unattend.txt was * and we thus never had any text in
    // the edit control or unattend.txt to be uppercased.
    //
    CharUpper(GeneratedString);
}


BOOL
ContainsDot(
    IN PCWSTR NameToCheck
    )

/*++

Routine Description:

    Determine whether a given name contains a '.'

Arguments:

    NameToCheck - supplies name to be checked.

Return Value:

    TRUE if the name contains a '.'; FALSE if not.

--*/

{
    UINT Length,u;

    if (!NameToCheck)
        return FALSE;

    Length = lstrlen(NameToCheck);

    for (u = 0; u < Length; u++) {
         if (NameToCheck[u] == L'.')
             return TRUE;
    }

    return FALSE;
}


BOOL
IsNetNameValid(
    IN PCWSTR NameToCheck,
    IN BOOL AlphaNumericOnly
    )

/*++

Routine Description:

    Determine whether a given name is valid as a netname, such as
    a computer name.

Arguments:

    NameToCheck - supplies name to be checked.

Return Value:

    TRUE if the name is valid; FALSE if not.

--*/

{
    UINT Length,u;

    Length = lstrlen(NameToCheck);

    //
    // Want at least one character.
    //
    if(!Length) {
        return(FALSE);
    }

    //
    // Leading/trailing spaces are invalid.
    //
    if((NameToCheck[0] == L' ') || (NameToCheck[Length-1] == L' ')) {
        return(FALSE);
    }

    //
    // Control chars are invalid, as are characters in the illegal chars list.
    //
    for(u=0; u<Length; u++) {
        if (AlphaNumericOnly) {
            if (NameToCheck[u] == L'-' || NameToCheck[u] == L'_') {
                continue;
            }
            if (!iswalnum(NameToCheck[u])) {
                return(FALSE);
            }
        } else {
            if((NameToCheck[u] < L' ') || wcschr(IllegalNetNameChars,NameToCheck[u])) {
                return(FALSE);
            }
        }
    }

    //
    // We got here, name is ok.
    //
    return(TRUE);
}

BOOL SetIMEOpenStatus(
    IN HWND   hDlg,
    IN BOOL   bSetActive)
{
    typedef HIMC (WINAPI* PFN_IMMGETCONTEXT)(HWND);
    typedef BOOL (WINAPI* PFN_IMMSETOPENSTATUS)(HIMC,BOOL);
    typedef BOOL (WINAPI* PFN_IMMGETOPENSTATUS)(HIMC);
    typedef BOOL (WINAPI* PFN_IMMRELEASECONTEXT)(HWND,HIMC);

    PFN_IMMGETCONTEXT     PFN_ImmGetContext;
    PFN_IMMSETOPENSTATUS  PFN_ImmSetOpenStatus;
    PFN_IMMGETOPENSTATUS  PFN_ImmGetOpenStatus;
    PFN_IMMRELEASECONTEXT PFN_ImmReleaseContext;

    HIMC    hIMC;
    HKL     hKL;
    HMODULE hImmDll;
    static BOOL bImeEnable=TRUE;

    hKL = GetKeyboardLayout(0);

    if ((HIWORD(HandleToUlong(hKL)) & 0xF000) != 0xE000) {
        //
        // not an IME, do nothing !
        //
        return TRUE;
    }

    hImmDll = GetModuleHandle(TEXT("IMM32.DLL"));

    if (hImmDll == NULL) {
        //
        // weird case, if the kbd layout is an IME, then
        // Imm32.dll should have already been loaded into process.
        //
        return FALSE;
    }


    PFN_ImmGetContext = (PFN_IMMGETCONTEXT) GetProcAddress(hImmDll,"ImmGetContext");
    if (PFN_ImmGetContext == NULL) {
        return FALSE;
    }

    PFN_ImmReleaseContext = (PFN_IMMRELEASECONTEXT) GetProcAddress(hImmDll,"ImmReleaseContext");
    if (PFN_ImmReleaseContext == NULL) {
        return FALSE;
    }


    PFN_ImmSetOpenStatus = (PFN_IMMSETOPENSTATUS) GetProcAddress(hImmDll,"ImmSetOpenStatus");
    if (PFN_ImmSetOpenStatus == NULL) {
        return FALSE;
    }

    PFN_ImmGetOpenStatus = (PFN_IMMGETOPENSTATUS) GetProcAddress(hImmDll,"ImmGetOpenStatus");
    if (PFN_ImmGetOpenStatus == NULL) {
        return FALSE;
    }

    //
    // Get Current Input Context.
    //
    hIMC = PFN_ImmGetContext(hDlg);
    if (hIMC == NULL) {
        return FALSE;
    }

    if (bSetActive) {
        PFN_ImmSetOpenStatus(hIMC,bImeEnable);
    }
    else {
        //
        // Save Current Status.
        //
        bImeEnable = PFN_ImmGetOpenStatus(hIMC);
        //
        // Close IME.
        //
        PFN_ImmSetOpenStatus(hIMC,FALSE);
    }

    PFN_ImmReleaseContext(hDlg,hIMC);

    return TRUE;
}


// returns TRUE if the name is valid, FALSE if it is not
BOOL ValidateNameOrgName (
      WCHAR* pszName
	  )
{
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR guestName[MAX_USERNAME+1];

    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminName,MAX_USERNAME+1);
    LoadString(MyModuleHandle,IDS_GUEST,guestName,MAX_USERNAME+1);

	if ( pszName == NULL )
		return FALSE;

	if(pszName[0] == 0)
		return FALSE;

    if(lstrcmpi(pszName,adminName) == 0 )
		return FALSE;

	if ( lstrcmpi(pszName,guestName) == 0 )
		return FALSE;

	return TRUE;

}




INT_PTR
CALLBACK
NameOrgDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG: {

        //
        // Limit text fields to maximum lengths
        //

        SendDlgItemMessage(hdlg,IDT_NAME,EM_LIMITTEXT,MAX_NAMEORG_NAME,0);
        SendDlgItemMessage(hdlg,IDT_ORGANIZATION,EM_LIMITTEXT,MAX_NAMEORG_ORG,0);

        //
        // Set Initial Values
        //

        SetDlgItemText(hdlg,IDT_NAME,NameOrgName);
        SetDlgItemText(hdlg,IDT_ORGANIZATION,NameOrgOrg);

        break;
    }
    case WM_IAMVISIBLE:
        //
        // If an error occured during out INIT phase, show the box to the
        // user so that they know there is a problem
        //
        MessageBoxFromMessage(hdlg,MSG_NO_NAMEORG_NAME,NULL,IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        SetFocus(GetDlgItem(hdlg,IDT_NAME));
        break;
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE) {
            if(LOWORD(wParam) == IDT_ORGANIZATION) {
                GetDlgItemText( hdlg, IDT_ORGANIZATION, NameOrgOrg, MAX_NAMEORG_ORG+1);
#ifdef DOLOCALUSER
            } else if(LOWORD(wParam) == IDT_NAME) {
                GetDlgItemText( hdlg, IDT_NAME, NameOrgName, MAX_NAMEORG_NAME+1);
#endif
            }
        }
        break;


    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        GetDlgItemText(hdlg,IDT_ORGANIZATION,NameOrgOrg,MAX_NAMEORG_ORG+1);
        GetDlgItemText(hdlg,IDT_NAME,NameOrgName,MAX_NAMEORG_NAME+1);

		// JMH - NameOrgName cannot be "Administrator", "Guest" or "" (blank).

        if(ValidateNameOrgName(NameOrgName) == FALSE) {
            //
            // Skip UI?
            //

            if (!lParam) {
                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
            }

            //
            // Tell user he must at least enter a name, and
            // don't allow next page to be activated.
            //
            if (Unattended) {
                UnattendErrorDlg(hdlg,IDD_NAMEORG);
            } // if
            MessageBoxFromMessage(hdlg,MSG_NO_NAMEORG_NAME,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
            SetFocus(GetDlgItem(hdlg,IDT_NAME));

            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
        }

        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(503);
            BEGIN_SECTION(L"Personalize Your Software Page");
            SetWizardButtons(hdlg,WizPageNameOrg);

            if (Unattended) {
                if (!UnattendSetActiveDlg(hdlg,IDD_NAMEORG)) {
                    break;
                }
            }
            // Page becomes active, make page visible.
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
            //
            // Set focus on the name edit control.
            //
            SetFocus(GetDlgItem(hdlg,IDT_NAME));

            //
            // Open/Close IME.
            //
            SetIMEOpenStatus(hdlg,TRUE);

            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FALSE);

            //
            // Close IME.
            //
            SetIMEOpenStatus(hdlg,FALSE);

            END_SECTION(L"Personalize Your Software Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageNameOrg);
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
ComputerNameDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;
    DWORD err, Win32NameSize = MAX_COMPUTERNAME_LENGTH + 1;
    static BOOL EncryptedAdminPasswordBad = FALSE;
    static BOOL bPersonal = FALSE;

    switch(msg) {

    case WM_INITDIALOG: {

        bPersonal = ( GetProductFlavor() == 4);
        //
        // Limit text to maximum length
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_LIMITTEXT,DNS_MAX_LABEL_LENGTH,0);
        if (!bPersonal)
        {
            SendDlgItemMessage(hdlg,IDT_EDIT2,EM_LIMITTEXT,MAX_PASSWORD,0);
            SendDlgItemMessage(hdlg,IDT_EDIT3,EM_LIMITTEXT,MAX_PASSWORD,0);
        }
        SetWindowSubclass(GetDlgItem(hdlg, IDT_EDIT2), DisableEditSubClassProc, IDT_EDIT2, 0);
        SetWindowSubclass(GetDlgItem(hdlg, IDT_EDIT3), DisableEditSubClassProc, IDT_EDIT3, 0);

        //
        // Set the Edit boxes to the initial text
        //

        //
        // Generate a computer name if we're unattended and
        // the user has requested a random name, or if we're
        // attended.
        //

        GenerateName( ComputerName, 15 );
        if( (Unattended) &&
            (UnattendAnswerTable[UAE_COMPNAME].Answer.String) &&
            (UnattendAnswerTable[UAE_COMPNAME].Answer.String[0] == L'*') ) {
            //
            // The unattend engine has asked us to generate a Computer
            // name.  Let's write the data back into the unattend
            // database.
            //
            MyFree( UnattendAnswerTable[UAE_COMPNAME].Answer.String );
            UnattendAnswerTable[UAE_COMPNAME].Answer.String = ComputerName;
        }

        if (!bPersonal)
        {
            if(DontChangeAdminPassword) {
                EnableWindow(GetDlgItem(hdlg,IDT_EDIT2),FALSE);
                EnableWindow(GetDlgItem(hdlg,IDT_EDIT3),FALSE);
            } else {
                SetDlgItemText(hdlg,IDT_EDIT2,AdminPassword);
                SetDlgItemText(hdlg,IDT_EDIT3,AdminPassword);
            }
        }
        break;
    }

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(
            hdlg,
            ComputerName[0] ? MSG_BAD_COMPUTER_NAME1 : MSG_BAD_COMPUTER_NAME2,
            NULL,
            IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        IsNameNonRfc = FALSE;
        IsNameTruncated = FALSE;

        GetDlgItemText(hdlg,IDT_EDIT1,ComputerName,DNS_MAX_LABEL_LENGTH+1);

        // StrTrim removes both leading and trailing spaces
        StrTrim(ComputerName, TEXT(" "));

        if (ContainsDot(ComputerName)) {
           err = ERROR_INVALID_NAME;
        } else {
           err = DnsValidateDnsName_W(ComputerName);
           if (err == DNS_ERROR_NON_RFC_NAME) {
              IsNameNonRfc = TRUE;
              err = ERROR_SUCCESS;
           }

           if(err == ERROR_SUCCESS) {
              //The name is a valid DNS name. Now verify that it is
              //also a valid WIN32 computer name.

              if (!DnsHostnameToComputerNameW(ComputerName,
                                              Win32ComputerName,
                                              &Win32NameSize) ||
                  !IsNetNameValid(Win32ComputerName, FALSE)) {
                  err = ERROR_INVALID_NAME;
              }
              else {
                  if (Win32NameSize < (UINT)lstrlen(ComputerName) ) {
                      //The DNSName was truncated to get a Win32 ComputerName.
                      IsNameTruncated = TRUE;
                  }
              }
           }
        }

        //
        // If the name has non-RFC characters or if it was truncated, warn
        // user if it is not an unattended install and we have GUI.
        //
        if (err == ERROR_SUCCESS && !Unattended && lParam) {

            if (IsNameNonRfc) {
                //ComputerName has non-standard characters.
                if (MessageBoxFromMessage(
                       hdlg,
                       MSG_DNS_NON_RFC_NAME,
                       NULL,
                       IDS_SETUP,MB_YESNO|MB_ICONWARNING,
                       ComputerName) == IDNO) {

                     SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
                     SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
                     return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                }
            }

            if (IsNameTruncated) {
                //The computer name was truncated.
                if (MessageBoxFromMessage(
                       hdlg,
                       MSG_DNS_NAME_TRUNCATED,
                       NULL,
                       IDS_SETUP,MB_YESNO|MB_ICONWARNING,
                       ComputerName, Win32ComputerName) == IDNO) {

                     SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
                     SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
                     return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                }
            }
        }

        if(err == ERROR_SUCCESS) {
            WCHAR pw1[MAX_PASSWORD+1],pw2[MAX_PASSWORD+1];
            if (bPersonal)
            {
                // if we are in personal we are done.
                return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
            }
            //
            // Good computer name.  Now make sure passwords match.
            //
            GetDlgItemText(hdlg,IDT_EDIT2,pw1,MAX_PASSWORD+1);
            GetDlgItemText(hdlg,IDT_EDIT3,pw2,MAX_PASSWORD+1);
            if(lstrcmp(pw1,pw2)) {
                //
                // Skip UI?
                //

                if (!lParam) {
                    return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
                }

                //
                //
                // Inform user of password mismatch, and don't allow next page
                // to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
                }
                MessageBoxFromMessage(hdlg,MSG_PW_MISMATCH,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetDlgItemText(hdlg,IDT_EDIT2,L"");
                SetDlgItemText(hdlg,IDT_EDIT3,L"");
                SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

            } else {

                WCHAR   adminName[MAX_USERNAME+1];
                BOOL    bContinue = TRUE;
                GetAdminAccountName( adminName );
                // We do the password check only on Server SKUs and if 
                // We are in GUI Attended or ProvideDefault mode
                if ( (UnattendMode == UAM_GUIATTENDED)
                      && (ProductType != PRODUCT_WORKSTATION))
                {
                    if (*pw1 == L'\0')
                    {
                        // Warning about empty password
                        bContinue = (DialogBox(MyModuleHandle, 
                                               MAKEINTRESOURCE(IDD_NOPASSWORD), 
                                               hdlg, 
                                               NoPasswordDlgProc) == IDOK);
                    }
                    else if (!IsStrongPasswordEx(pw1, adminName))
                    {
                        // warning about weak password
                        bContinue = (DialogBoxParam(MyModuleHandle, 
                                               MAKEINTRESOURCE(IDD_WEAKPASSWORD), 
                                               hdlg, 
                                               WeakPasswordDlgProc, (LPARAM)&adminName) == IDOK);
                    }
                }

                if (bContinue)
                {
                    //
                    // Process the encrypted password if
                    // 1) We are unattended and
                    // 2) The EncryptedAdminPassword key is "Yes" in the unatttend file and
                    // 3) We are not back here after setting it - i.e. via the back button etc.
                    // 4) We are not back here after failing to set it once.


                    if( Unattended && IsEncryptedAdminPasswordPresent() &&
                        !DontChangeAdminPassword && !EncryptedAdminPasswordBad){

                        // Logging is done inside the call to ProcessEncryptedAdminPassword

                        if(!(ProcessEncryptedAdminPassword(adminName))){

                            EncryptedAdminPasswordBad = TRUE;

                            // Page becomes active, make page visible.
                            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                            // Inform the user and enable the password fields

                            UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
                            MessageBoxFromMessage(hdlg,MSG_CHANGING_PW_FAIL,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP, adminName );
                            SetDlgItemText(hdlg,IDT_EDIT2,L"");
                            SetDlgItemText(hdlg,IDT_EDIT3,L"");
                            SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
                        }else{
                            EncryptedAdminPasswordSet = TRUE;

                            //
                            // Set DontChangeAdminPassword to avoid the user from ever trying to
                            // reset the password using the dialog. This is needed in the case where the
                            // unattend fails, say, in the next page and the user gets here using the back button.
                            //

                            DontChangeAdminPassword = TRUE;
                        }


                    }else{



                        //
                        // They match; allow next page to be activated.
                        //
                        if (Unattended && pw1[0] == L'*') {
                            pw1[0] = L'\0';
                        }


                        // Set administrator password.  We need to do some checking here though.
                        // There are 3 scenarios that can occur in mini-setup:
                        // 1. The OEM doesn't want to have the admin password changed.
                        //    In this case, he's set OEMAdminPassword = "NoChange".  If that's
                        //    what we find, we don't assign the password.  Remember that this
                        //    system has already been installed, so there's already an admin
                        //    password.
                        // 2. The OEM wants to set the admin password to a specific string.
                        //    In this case, he's set OEMAdminPassword = <some quoted word>.
                        //    If this is the case, we've already caught this string in the
                        //    wizard page.
                        // 3. The OEM wants to let the user set the admin password.  In this
                        //    case, there's no OEMAdminpassword in the answer file.  If this
                        //    is the case, we've already caught this and gotten a password
                        //    from the user in the wizard page.
                        //
                        // The good news is that the unattend engine has already looked
                        // for a password in the unattend file called "NoChange" and has
                        // set a global called "DontChangeAdminPassword" to indicate.



                        if(!DontChangeAdminPassword) {

                            lstrcpy(AdminPassword,pw1);

                            //
                            // The user may have changed the name of the Administrator
                            // account.  We'll call some special code to retrieve the
                            // name on the account.  This is really only needed in the
                            // case of a sysprep run, but it can't hurt to do it always.
                            //
                            // In the Win9x case their code in winnt32 generates a random
                            // password and passes it to us through the unattend file and
                            // so we set it here and do the right thing.

                            // For Minisetup the behavior for now is to silently fail setting
                            // the admin password if there was an existing Password on the system.
                            // WE only allow setting the admin password from NULL i.e. one time change.
                            // In any other case we log the error and move on.
                            //



                            if(!SetLocalUserPassword(adminName,CurrentAdminPassword,AdminPassword) && !MiniSetup) {

                                SetupDebugPrint( L"SETUP: SetLocalUserPassword failed" );
                                // Page becomes active, make page visible.
                                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                                MessageBoxFromMessage(hdlg,MSG_CHANGING_PW_FAIL,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP, adminName );
                                SetDlgItemText(hdlg,IDT_EDIT2,L"");
                                SetDlgItemText(hdlg,IDT_EDIT3,L"");
                                SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                            }
                            //
                            //  Now store this so that we work fine when the user comes to this page by hitting "Back".
                            //
                            lstrcpy( CurrentAdminPassword, AdminPassword );


                        }
                    }
                }
                else
                {
                    // Either empty or weak password and user wants to change it.
                    // Stay on the page
                    SetDlgItemText(hdlg,IDT_EDIT2,L"");
                    SetDlgItemText(hdlg,IDT_EDIT3,L"");
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                    return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
                }
            }
        } else {
            //
            // Skip UI?
            //

            if (!lParam) {
                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
            }

            //
            // Inform user of bogus computer name, and don't allow next page
            // to be activated.
            //
            if (Unattended) {
                UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
            }
            MessageBoxFromMessage(
                hdlg,
                ComputerName[0] ? MSG_BAD_COMPUTER_NAME1 : MSG_BAD_COMPUTER_NAME2,
                NULL,
                IDS_ERROR,MB_OK|MB_ICONSTOP
                );
            SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
            SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);

            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
        }

        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(504);

            BEGIN_SECTION(L"Computer Name Page");
            SetWizardButtons(hdlg,WizPageComputerName);

            //
            // Load ComputerName because it may have been set when the user
            // entered the organization name.
            //
            SetDlgItemText(hdlg,IDT_EDIT1,ComputerName);

            if(Unattended && !UnattendSetActiveDlg(hdlg,IDD_COMPUTERNAME)) {
                break;
            }

            //
            // Post ourselves a message we'll get once displayed.
            //
            PostMessage(hdlg,WM_USER,0,0);
            break;

        case PSN_WIZBACK:
            //
            // Save ComputerName because we're going to load it into the dialog
            // again when we come back.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,ComputerName,DNS_MAX_LABEL_LENGTH+1);
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FALSE);
            END_SECTION(L"Computer Name Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageComputerName);
            break;

        default:
            break;
        }

        break;

    case WM_USER:
        // Page becomes active, make page visible.
        SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        //
        // Select the computer name string and set focus to it.
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
        SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

#ifdef DOLOCALUSER
BOOL
CheckUserAccountData(
    IN  HWND hdlg,
    OUT BOOL ValidateOnly
    )
{
    WCHAR userName[MAX_USERNAME+1];
    WCHAR pw1[MAX_PASSWORD+1];
    WCHAR pw2[MAX_PASSWORD+1];
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR guestName[MAX_USERNAME+1];
    UINT MessageId;

    FocusId = 0;

    //
    // Load names of built-in accounts.
    //
    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminName,MAX_USERNAME+1);
    LoadString(MyModuleHandle,IDS_GUEST,guestName,MAX_USERNAME+1);

    //
    // Fetch data user typed in for username and password.
    //
    GetDlgItemText(hdlg,IDT_EDIT1,userName,MAX_USERNAME+1);
    GetDlgItemText(hdlg,IDT_EDIT2,pw1,MAX_PASSWORD+1);
    GetDlgItemText(hdlg,IDT_EDIT3,pw2,MAX_PASSWORD+1);

    if(lstrcmpi(userName,adminName) && lstrcmpi(userName,guestName)) {
        if(userName[0]) {
            if(IsNetNameValid(userName,FALSE)) {
                if(lstrcmp(pw1,pw2)) {
                    //
                    // Passwords don't match.
                    //
                    MessageId = MSG_PW_MISMATCH;
                    SetDlgItemText(hdlg,IDT_EDIT2,L"");
                    SetDlgItemText(hdlg,IDT_EDIT3,L"");
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT2));
                } else {
                    //
                    // Name is non-empty, is not a built-in, is valid,
                    // and the passwords match.
                    //
                    MessageId = 0;
                }
            } else {
                //
                // Name is not valid.
                //
                MessageId = MSG_BAD_USER_NAME1;
                SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
            }
        } else {
            //
            // Don't allow empty name.
            //
            MessageId = MSG_BAD_USER_NAME2;
            SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
        }
    } else {
        //
        // User entered name of a built-in account.
        //
        MessageId = MSG_BAD_USER_NAME3;
        SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
    }

    if(MessageId && !ValidateOnly) {
        MessageBoxFromMessage(hdlg,MessageId,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
    }

    return(MessageId == 0);
}

BOOL
CALLBACK
UserAccountDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Limit text to maximum length of a user account name,
        // and limit password text to max langth of a password.
        // Also set initial text.
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_LIMITTEXT,MAX_USERNAME,0);
        SendDlgItemMessage(hdlg,IDT_EDIT2,EM_LIMITTEXT,MAX_PASSWORD,0);
        SendDlgItemMessage(hdlg,IDT_EDIT3,EM_LIMITTEXT,MAX_PASSWORD,0);
        SetDlgItemText(hdlg,IDT_EDIT1,UserName);
        SetDlgItemText(hdlg,IDT_EDIT2,UserPassword);
        SetDlgItemText(hdlg,IDT_EDIT3,UserPassword);
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        //
        // Check name.
        //
        if(CheckUserAccountData(hdlg, lParam == 0)) {
            //
            // Data is valid.  Move on to next page.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            GetDlgItemText(hdlg,IDT_EDIT2,UserPassword,MAX_PASSWORD+1);
            CreateUserAccount = TRUE;
        } else if (Unattended) {
            //
            // Data is invalid but we're unattended, so just don't create
            // the account.
            //
            CreateUserAccount = FALSE;
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            SetDlgItemText(hdlg,IDT_EDIT2,L"");
            SetDlgItemText(hdlg,IDT_EDIT3,L"");
            UserPassword[0] = 0;

            return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
        }

        //
        // Don't allow next page to be activated.
        //
        return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(505);
            BEGIN_SECTION(L"User Name and Password Page");
            SetWizardButtons(hdlg,WizPageUserAccount);

            //
            // Load ComputerName because it may have been set when the user
            // entered the user name.
            //
            SetDlgItemText(hdlg,IDT_EDIT1,UserName);

            //
            // Always activate in ui test mode
            //
            if(!UiTest) {
                //
                // Don't activate if this is a dc server or Win9x upgrade.
                //
                if(ISDC(ProductType) || Win95Upgrade) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                    break;
                }
            }
            if (Unattended) {
                if (!UnattendSetActiveDlg(hdlg,IDD_USERACCOUNT)) {
                    break;
                }
            }
            // Page becomes active, make page visible.
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            break;

        case PSN_WIZBACK:
            //
            // Save UserName because we're going to load it into the dialog
            // again when we come back.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, FALSE );
            END_SECTION(L"User Name and Password Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageUserAccount);
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
#endif //def DOLOCALUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\misc.c ===
#include "setupp.h"
#pragma hdrstop


//
// Safe boot strings
//

#define SAFEBOOT_OPTION_KEY  TEXT("System\\CurrentControlSet\\Control\\SafeBoot\\Option")
#define OPTION_VALUE         TEXT("OptionValue")

VOID
SetUpProductTypeName(
    OUT PWSTR  ProductTypeString,
    IN  UINT   BufferSizeChars
    )
{
    switch(ProductType) {
    case PRODUCT_WORKSTATION:
        lstrcpyn(ProductTypeString,L"WinNT",BufferSizeChars);
        break;
    case PRODUCT_SERVER_PRIMARY:
        lstrcpyn(ProductTypeString,L"LanmanNT",BufferSizeChars);
        break;
    case PRODUCT_SERVER_STANDALONE:
        lstrcpyn(ProductTypeString,L"ServerNT",BufferSizeChars);
        break;
    default:
        LoadString(MyModuleHandle,IDS_UNKNOWN,ProductTypeString,BufferSizeChars);
        break;
    }
}


HMODULE
MyLoadLibraryWithSignatureCheck(
    IN PWSTR ModuleName
    )
/*++

Routine Description:

    verifies the signature for a dll and if it's ok, then load the dll

Arguments:

    ModuleName - filename to be loaded.

Return Value:

    an HMODULE on success, else NULL

--*/

{
    WCHAR FullModuleName[MAX_PATH];
    PWSTR p;
    DWORD error;

    if (!GetFullPathName(ModuleName,MAX_PATH,FullModuleName,&p)) {
        //
        // couldn't get full path to file
        //
        SetupDebugPrint1( L"Setup: MyLoadLibraryWithSignatureCheck failed GetFullPathName, le = %d\n",
                          GetLastError() );
        return NULL;
    }

    error = pSetupVerifyFile(
               NULL,
               NULL,
               NULL,
               0,
               pSetupGetFileTitle(FullModuleName),
               FullModuleName,
               NULL,
               NULL,
               FALSE,
               NULL,
               NULL,
               NULL );

    if (NO_ERROR != error) {
        //
        // signing problem
        //
        SetupDebugPrint1( L"Setup: MyLoadLibraryWithSignatureCheck failed pSetupVerifyFile, le = %x\n",
                          error );
        SetLastError(error);
        return NULL;
    }

    return (LoadLibrary(FullModuleName));

}


UINT
MyGetDriveType(
    IN WCHAR Drive
    )
{
    WCHAR DriveNameNt[] = L"\\\\.\\?:";
    WCHAR DriveName[] = L"?:\\";
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    DriveName[0] = Drive;
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile(
                    DriveNameNt,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk != INVALID_HANDLE_VALUE) {

            b = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if(b && (MediaInfo.MediaType == RemovableMedia)) {
                rc = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        }
    }

    return(rc);
}


BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    WCHAR DriveName[] = L"\\\\.\\?:";
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}


BOOL
IsErrorLogEmpty (
    VOID
    )

/*++

Routine Description:

    Checks to see if the error log is empty.

Arguments:

    None.

Returns:

    TRUE if the error log size is zero.

--*/

{
    HANDLE ErrorLog;
    WCHAR LogName[MAX_PATH];
    DWORD Size = 0;

    if( GetWindowsDirectory (LogName, MAX_PATH) ) {
        pSetupConcatenatePaths (LogName, SETUPLOG_ERROR_FILENAME, MAX_PATH, NULL);

        ErrorLog = CreateFile (
            LogName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (ErrorLog != INVALID_HANDLE_VALUE) {
            Size = GetFileSize (ErrorLog, NULL);
            CloseHandle (ErrorLog);
        }
    }
    return Size == 0;
}


VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}


PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext;

    SysSetupContext = MyMalloc(sizeof(SYSSETUP_QUEUE_CONTEXT));

    if(SysSetupContext) {

        SysSetupContext->Skipped = FALSE;

        SysSetupContext->DefaultContext = SetupInitDefaultQueueCallbackEx(
            OwnerWindow,
            AlternateProgressWindow,
            ProgressMessage,
            Reserved1,
            Reserved2
            );
    }

    return SysSetupContext;
}


PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    )
{
    return(InitSysSetupQueueCallbackEx(OwnerWindow,NULL,0,0,NULL));
}


VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    )
{
    PSYSSETUP_QUEUE_CONTEXT Context = SysSetupContext;

    try {
        if(Context->DefaultContext) {
            SetupTermDefaultQueueCallback(Context->DefaultContext);
        }
        MyFree(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


#if 0
UINT
VersionCheckQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    PFILEPATHS  FilePaths = (PFILEPATHS)Param1;

    //
    // If we're being notified that a version mismatch was found,
    // indicate that the file shouldn't be copied.  Otherwise,
    // pass the notification on.
    //
    if((Notification & (SPFILENOTIFY_LANGMISMATCH |
                        SPFILENOTIFY_TARGETNEWER |
                        SPFILENOTIFY_TARGETEXISTS)) != 0) {

        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            , // MSG_LOG_VERSION_MISMATCH,    This message is no longer appropriate.
            FilePaths->Source,
            FilePaths->Target,
            NULL,NULL);

        return(0);
    }

    //
    // Want default processing.
    //
    return(SysSetupQueueCallback(Context,Notification,Param1,Param2));
}
#endif


UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT                    Status;
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext = Context;
    PFILEPATHS              FilePaths = (PFILEPATHS)Param1;
    PSOURCE_MEDIA           SourceMedia = (PSOURCE_MEDIA)Param1;
    REGISTRATION_CONTEXT RegistrationContext;


    //
    // If we're being notified that a file is missing and we're supposed
    // to skip missing files, then return skip. Otherwise pass it on
    // to the default callback routine.
    //
    if(( (Notification == SPFILENOTIFY_COPYERROR) || (Notification == SPFILENOTIFY_NEEDMEDIA) ) && SkipMissingFiles) {

        if((FilePaths->Win32Error == ERROR_FILE_NOT_FOUND)
        || (FilePaths->Win32Error == ERROR_PATH_NOT_FOUND)) {

        if(Notification == SPFILENOTIFY_COPYERROR)
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPY_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error,
                NULL,NULL);
        else
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NEEDMEDIA_SKIP,
                SourceMedia->SourceFile,
                SourceMedia->SourcePath,
                NULL,NULL);


            return(FILEOP_SKIP);
        }
    }

    if ((Notification == SPFILENOTIFY_COPYERROR
         || Notification == SPFILENOTIFY_RENAMEERROR
         || Notification == SPFILENOTIFY_DELETEERROR) &&
        (FilePaths->Win32Error == ERROR_DIRECTORY)) {
            WCHAR Buffer[MAX_PATH];
            PWSTR p;
            //
            // The target directory has been converted into a file by autochk.
            // just delete it -- we might be in trouble if the target directory was
            // really important, but it's worth trying
            //

            wcscpy( Buffer,FilePaths->Target);
            p = wcsrchr(Buffer,L'\\');
            if (p) {
                *p = (WCHAR)NULL;
            }
            if (FileExists(Buffer,NULL)) {
                DeleteFile( Buffer );
                SetupDebugPrint1(L"autochk turned directory %s into file, delete file and retry\n", Buffer);
                return(FILEOP_RETRY);
            }
    }

    //
    // If we're being notified that a version mismatch was found,
    // silently overwrite the file.  Otherwise, pass the notification on.
    //
    if((Notification & (SPFILENOTIFY_LANGMISMATCH |
                        SPFILENOTIFY_TARGETNEWER |
                        SPFILENOTIFY_TARGETEXISTS)) != 0) {

        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_VERSION_MISMATCH,
            FilePaths->Source,
            FilePaths->Target,
            NULL,NULL);

        return(FILEOP_DOIT);
    }


    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback(
        SysSetupContext->DefaultContext,Notification,Param1,Param2);

    switch(Notification) {

    case SPFILENOTIFY_STARTQUEUE:
    case SPFILENOTIFY_STARTSUBQUEUE:
    case SPFILENOTIFY_ENDSUBQUEUE:
        //
        // Nothing is logged in this case.
        //
        break;

    case SPFILENOTIFY_ENDQUEUE:

        if(!Param1) {
            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_QUEUE_ABORT, NULL,
                SETUPLOG_USE_MESSAGEID,
                GetLastError(),
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_STARTRENAME:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDRENAME:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAMED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);

        } else {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAME_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_RENAMEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTDELETE:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDDELETE:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETED,
                FilePaths->Target,
                NULL,NULL);

        } else if(FilePaths->Win32Error == ERROR_FILE_NOT_FOUND ||
            FilePaths->Win32Error == ERROR_PATH_NOT_FOUND) {
            //
            // This failure is not important.
            //
            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error,
                NULL,NULL);

        } else {
            //
            // Here we have an actual error.
            //
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_DELETEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTCOPY:
        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDCOPY:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            LogRepairInfo(
                FilePaths->Source,
                FilePaths->Target
                );

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPIED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);

            //
            // clear the file's readonly attribute that it may have gotten
            // from the cdrom.
            //
            SetFileAttributes(
                FilePaths->Target,
                GetFileAttributes(FilePaths->Target) & ~FILE_ATTRIBUTE_READONLY );

        } else {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPY_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_COPYERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_NEEDMEDIA:

        if(Status == FILEOP_SKIP) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NEEDMEDIA_SKIP,
                SourceMedia->SourceFile,
                SourceMedia->SourcePath,
                NULL,NULL);

            SysSetupContext->Skipped = TRUE;
        }

        break;

    case SPFILENOTIFY_STARTREGISTRATION:
    case SPFILENOTIFY_ENDREGISTRATION:
        RtlZeroMemory(&RegistrationContext,sizeof(RegistrationContext));
        RegistrationQueueCallback(
                        &RegistrationContext,
                        Notification,
                        Param1,
                        Param2);
        break;

    default:

        break;
    }

    return Status;
}


PSID
GetAdminAccountSid(
    )

/*++
===============================================================================
Routine Description:

    This routine gets the Adminstrator's SID

Arguments:

    None.

Return Value:

    TRUE - success.

    FALSE - failed.

===============================================================================
--*/
{
    BOOL b = TRUE;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    UCHAR SubAuthCount;
    DWORD sidlen;
    PSID psid = NULL;


    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (!NT_SUCCESS(ntStatus)) {
        LsaClose(hPolicy);
        b = FALSE;
    }

    if( b ) {
        ntStatus = LsaQueryInformationPolicy( hPolicy,
                                              PolicyAccountDomainInformation,
                                              (PVOID *) &AccountDomainInfo );

        LsaClose( hPolicy );

        if (!NT_SUCCESS(ntStatus)) {
            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
            b = FALSE;
        }
    }

    if( b ) {
        //
        // calculate the size of a new sid with one more SubAuthority
        //
        SubAuthCount = *(GetSidSubAuthorityCount ( AccountDomainInfo->DomainSid ));
        SubAuthCount++; // for admin
        sidlen = GetSidLengthRequired ( SubAuthCount );

        //
        // allocate and copy the new new sid from the Domain SID
        //
        psid = (PSID)malloc(sidlen);

        if( psid ) {

            memcpy(psid, AccountDomainInfo->DomainSid, GetLengthSid(AccountDomainInfo->DomainSid) );

            //
            // increment SubAuthority count and add Domain Admin RID
            //
            *(GetSidSubAuthorityCount( psid )) = SubAuthCount;
            *(GetSidSubAuthority( psid, SubAuthCount-1 )) = DOMAIN_USER_RID_ADMIN;

            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
        }
    }

    return psid;
}


VOID
GetAdminAccountName(
    PWSTR AccountName
    )

/*++
===============================================================================
Routine Description:

    This routine sets the Adminstrator Password

Arguments:

    None.

Return Value:

    TRUE - success.

    FALSE - failed.

===============================================================================
--*/
{
    BOOL b = TRUE;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    UCHAR SubAuthCount;
    DWORD sidlen;
    PSID psid;
    WCHAR adminname[512];
    WCHAR domainname[512];
    DWORD adminlen=512;       // address of size account string
    DWORD domlen=512;       // address of size account string
    SID_NAME_USE sidtype;


    //
    // Initialize the administrator's account name.
    //
    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminname,MAX_USERNAME+1);

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (!NT_SUCCESS(ntStatus)) {
        LsaClose(hPolicy);
        b = FALSE;
    }

    if( b ) {
        ntStatus = LsaQueryInformationPolicy( hPolicy,
                                              PolicyAccountDomainInformation,
                                              (PVOID *) &AccountDomainInfo );

        LsaClose( hPolicy );

        if (!NT_SUCCESS(ntStatus)) {
            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
            b = FALSE;
        }
    }

    if( b ) {
        //
        // calculate the size of a new sid with one more SubAuthority
        //
        SubAuthCount = *(GetSidSubAuthorityCount ( AccountDomainInfo->DomainSid ));
        SubAuthCount++; // for admin
        sidlen = GetSidLengthRequired ( SubAuthCount );

        //
        // allocate and copy the new new sid from the Domain SID
        //
        psid = (PSID)malloc(sidlen);
        if (psid) {
            memcpy(psid, AccountDomainInfo->DomainSid, GetLengthSid(AccountDomainInfo->DomainSid) );

            //
            // increment SubAuthority count and add Domain Admin RID
            //
            *(GetSidSubAuthorityCount( psid )) = SubAuthCount;
            *(GetSidSubAuthority( psid, SubAuthCount-1 )) = DOMAIN_USER_RID_ADMIN;

            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }

            //
            // get the admin account name from the new SID
            //
            LookupAccountSid( NULL,
                              psid,
                              adminname,
                              &adminlen,
                              domainname,
                              &domlen,
                              &sidtype );
    }

    }

    lstrcpy( AccountName, adminname );

    if (psid) {
        free(psid);
    }
}


ULONG
GetBatteryTag (HANDLE DriverHandle)
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;
    ULONG           BatteryTag;

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_TAG,
            NULL,                   // input buffer
            0,
            &BatteryTag,            // output buffer
            sizeof (BatteryTag)
            );


    if (!NT_SUCCESS(Status)) {
        BatteryTag = BATTERY_TAG_INVALID;
        if (Status == STATUS_NO_SUCH_DEVICE) {
            SetupDebugPrint(L"(Battery is not physically present or is not connected)\n");
        } else {
            SetupDebugPrint1(L"Query Battery tag failed: Status = %x\n", Status);
        }

    }

    return BatteryTag;
}


BOOLEAN
GetBatteryInfo (
    HANDLE DriverHandle,
    ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    OUT PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;
    BInfo.AtRate = 0;                       // This is needed for reading estimated time correctly.

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_INFORMATION,
            &BInfo,                 // input buffer
            sizeof (BInfo),
            Buffer,                 // output buffer
            BufferLength
            );


    if (!NT_SUCCESS(Status)) {

        if ((Status == STATUS_INVALID_PARAMETER)        ||
            (Status == STATUS_INVALID_DEVICE_REQUEST)   ||
            (Status == STATUS_NOT_SUPPORTED)) {

            SetupDebugPrint2(L"Not Supported by Battery, Level %x, Status: %x\n", Level, Status);
        } else {
            SetupDebugPrint2(L"Query failed: Level %x, Status = %x\n", Level, Status);
        }

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
IsLongTermBattery(
    PCWSTR  BatteryName
    )
{
    HANDLE                  driverHandle;
    ULONG                   batteryTag;
    BATTERY_INFORMATION     BInfo;
    BOOLEAN                 Ret;


    driverHandle = CreateFile (BatteryName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if (INVALID_HANDLE_VALUE == driverHandle) {

        SetupDebugPrint2(L"Error opening %ws: GetLastError = 0x%08lx \n",
                BatteryName, GetLastError());
        return FALSE;
    }

    batteryTag = GetBatteryTag (driverHandle);
    if (batteryTag == BATTERY_TAG_INVALID) {
        NtClose(driverHandle);
        return FALSE;
    }

    if (GetBatteryInfo (driverHandle, batteryTag, BatteryInformation, &BInfo, sizeof(BInfo))) {

        Ret = !(BInfo.Capabilities & BATTERY_IS_SHORT_TERM);

    } else {

        Ret = FALSE;
    }

    NtClose(driverHandle);
    return(Ret);
}


BOOLEAN
IsLaptop(
    VOID
    )
{
    HDEVINFO                            devInfo;
    SP_INTERFACE_DEVICE_DATA            interfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    funcClassDevData;
    UCHAR                               index;
    DWORD                               reqSize;
    BOOLEAN                             b = FALSE;


    devInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    if (devInfo == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1(L"SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d\n", GetLastError());
        return FALSE;
    }
    interfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

    index = 0;
    while(1) {
        if (SetupDiEnumInterfaceDevice(devInfo,
                                       0,
                                       (LPGUID)&GUID_DEVICE_BATTERY,
                                       index,
                                       &interfaceDevData)) {

            // Get the required size of the function class device data.
            SetupDiGetInterfaceDeviceDetail(devInfo,
                                            &interfaceDevData,
                                            NULL,
                                            0,
                                            &reqSize,
                                            NULL);

            funcClassDevData = MyMalloc(reqSize);
            if (funcClassDevData != NULL) {
                funcClassDevData->cbSize =
                    sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                if (SetupDiGetInterfaceDeviceDetail(devInfo,
                                                    &interfaceDevData,
                                                    funcClassDevData,
                                                    reqSize,
                                                    &reqSize,
                                                    NULL)) {

                    b = IsLongTermBattery(funcClassDevData->DevicePath);
                }
                else {
                    SetupDebugPrint1(L"SetupDiGetInterfaceDeviceDetail, failed: %d\n", GetLastError());
                }

                MyFree(funcClassDevData);
                if (b) {
                    break;
                }
            }
        } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                break;
            }
            else {
                SetupDebugPrint1(L"SetupDiEnumInterfaceDevice, failed: %d\n", GetLastError());
            }
        }
        index++;
    }

    SetupDiDestroyDeviceInfoList(devInfo);
    return b;
}


VOID
SaveInstallInfoIntoEventLog(
    VOID
    )
/*++
Routine Description:

    This routine will store information into the event log regarding
    - if we upgraded or cleaninstall
    - what build did the install originate from
    - what build are we?
    - were there errors during Setup

Arguments:

    None.

Return Value:

    None.

--*/
{
#define     AnswerBufLen (64)
WCHAR       AnswerFile[MAX_PATH];
WCHAR       Answer[AnswerBufLen];
WCHAR       OrigVersion[AnswerBufLen];
WCHAR       NewVersion[AnswerBufLen];
HANDLE      hEventSrc;
PCWSTR      MyArgs[2];
PCWSTR      ErrorArgs[1];
DWORD       MessageID;
WORD        MyArgCount;




    //
    // Go get the starting information out of $winnt$.sif
    //
    OrigVersion[0] = L'0';
    OrigVersion[1] = L'\0';
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN32_VER,
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {

            wsprintf( OrigVersion, L"%d", HIWORD(wcstoul( Answer, NULL, 16 )) );
        }
    }
    MyArgs[1] = OrigVersion;



    //
    // Get the new version information.
    //
    wsprintf( NewVersion, L"%d", HIWORD(GetVersion()) );
    MyArgs[0] = NewVersion;



    //
    // See if we're an NT upgrade?
    //
    MessageID = 0;
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_NTUPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_NTUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // See if we're a Win9X upgrade.
    //
    if( (!MessageID) &&
        GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN95UPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_WIN9XUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // Clean install.
    //
    if( (!MessageID) ) {
        MessageID = MSG_CLEANINSTALL_SUCCESS;
        MyArgCount = 1;
    }


    //
    // If this is anything but an NT upgrade, then
    // we need to go try and manually start the eventlog
    // service.
    //
    if( MessageID != MSG_NTUPGRADE_SUCCESS ) {
        SetupStartService( L"Eventlog", TRUE );
    }



    //
    // Get a handle to the eventlog.
    //
    hEventSrc = RegisterEventSource( NULL, L"Setup" );

    if( (hEventSrc == NULL) ||
        (hEventSrc == INVALID_HANDLE_VALUE) ) {

        //
        // Fail quietly.
        //
        return;
    }


    //
    // Log event message for failure of SceSetupRootSecurity
    //
    if( !bSceSetupRootSecurityComplete) {
        ErrorArgs[0] = L"%windir%";
        ReportEvent( hEventSrc,
                 EVENTLOG_WARNING_TYPE,
                 0,
                 MSG_LOG_SCE_SETUPROOT_ERROR,
                 NULL,
                 1,
                 0,
                 ErrorArgs,
                 NULL );
    }

    //
    // Log event if there were errors during Setup.
    //
    if ( !IsErrorLogEmpty() ) {
        ReportEvent( hEventSrc,
                     EVENTLOG_ERROR_TYPE,
                     0,
                     MSG_NONFATAL_ERRORS,
                     NULL,
                     0,
                     0,
                     NULL,
                     NULL );
    }

    //
    // Build the event log message.
    //
    ReportEvent( hEventSrc,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 MessageID,
                 NULL,
                 MyArgCount,
                 0,
                 MyArgs,
                 NULL );


    DeregisterEventSource( hEventSrc );


}

BOOL
IsEncryptedAdminPasswordPresent( VOID )
{

    #define     MD4HASHLEN ((2*(LM_OWF_PASSWORD_LENGTH + NT_OWF_PASSWORD_LENGTH))+2)
    WCHAR       AnswerFile[MAX_PATH+2];
    WCHAR       Answer[MD4HASHLEN];

    //
    // Get EncryptedAdminPassword from the Answer file
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                 WINNT_US_ENCRYPTEDADMINPASS,
                                 pwNull,
                                 Answer,
                                 MD4HASHLEN,
                                 AnswerFile ) ) {

        //
        // See if we have an encrypted password.  Now interpret the Admin Password differently
        //

        if( !lstrcmpi( WINNT_A_YES, Answer ) )
            return TRUE;

    }

    return FALSE;

}


BOOL
ProcessEncryptedAdminPassword( PCWSTR AdminAccountName )
/*++

Routine Description:

    This routine looks in the unattend file to see if there is an encrypted password and if present
    sets the admin password to that.

Arguments:

    AdminAccountName - Name of the administrator account whose password you want to set.


Returns:

    Returns TRUE if it succeeds, FALSE on failure

--*/

{

    #define MD4HASHLEN ((2*(LM_OWF_PASSWORD_LENGTH + NT_OWF_PASSWORD_LENGTH))+2)
    WCHAR       AnswerFile[MAX_PATH+2];
    WCHAR       Answer[MD4HASHLEN];
    DWORD       Err = NO_ERROR;
    WCHAR       adminName[MAX_USERNAME+1];
    BOOLEAN     ret = FALSE;

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);


    //
    // we look for the following keys in the [GUIUnattended] section:
    //

    //
    // EncryptedAdminPassword    = Yes | No
    // AdminPassword             = <MD4 Hash value>
    //


    if( IsEncryptedAdminPasswordPresent() )       {


        //Fetch the Encrypted Admin Password

        if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                             WINNT_US_ADMINPASS,
                             pwNull,
                             Answer,
                             MD4HASHLEN,
                             AnswerFile ) == (MD4HASHLEN-2) ) {

            Err = SetLocalUserEncryptedPassword( AdminAccountName, L"", FALSE, Answer, TRUE );

            if( Err == ERROR_SUCCESS) {
                ret = TRUE;
            }else{

                //Log the error - MSG_LOG_CHANGING_ENCRYPT_PW_FAIL

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_CHANGING_ENCRYPT_PW_FAIL,
                    AdminAccountName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    L"SetLocalUserEncryptedPassword",
                    Err,
                    AdminAccountName,
                    NULL,NULL);

            }


        }else{

            //Log that we had a bad encrypted password

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_BAD_UNATTEND_PARAM,
                WINNT_US_ADMINPASS,
                WINNT_GUIUNATTENDED,
                NULL,NULL);

        }

    }

    return ret;


}


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL IsSafeMode(
    VOID
    )
{
	LONG lStatus;
	HKEY hk;
	DWORD dwVal;
	DWORD dwType;
	DWORD dwSize;

	lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SAFEBOOT_OPTION_KEY, 0, KEY_QUERY_VALUE, &hk);

	if(lStatus != ERROR_SUCCESS)
		return FALSE;

	dwSize = sizeof(dwVal);
	lStatus = RegQueryValueExW(hk, OPTION_VALUE, NULL, &dwType, (LPBYTE) &dwVal, &dwSize);
	RegCloseKey(hk);
	return ERROR_SUCCESS == lStatus && REG_DWORD == dwType && dwVal != 0;
}


void
SetupCrashRecovery(
    VOID
    )
/*
    Setup the Crash Recovery stuff. This is implemented as RTL APIS
    This call sets up the tracking file etc.  Crash Recovery tracks boot and 
    shutdown and in the event of failures in either it will by default pick the 
    right advanced boot option.
    
*/
{

    HANDLE BootStatusData;
    NTSTATUS Status;
    BOOLEAN Enabled;
    UCHAR Timeout = 30; //default = 30 sec
    WCHAR Buffer[10];
    PSTR AnsiBuffer;
    int p = 0;

    //
    // We enable the feature for Pro and Per. On Server SKUs
    // we create the file but don't enable the feature by default.
    //


    if( ProductType == PRODUCT_WORKSTATION ){
        Enabled = TRUE;
    }else{
        Enabled = FALSE;
    }

    //
    // For the fresh install case create the boot status data file
    // and setup the default settings. In the case of an upgrade
    // we will set the previous values if we find them in $winnt$.inf 
    // as textmode setup would have stored this away for us. If not we 
    // proceed as if we were fresh.
    //


    if( Upgrade ){

        //Look for settings in $winnt$.inf

        if( SpSetupLoadParameter( WINNT_D_CRASHRECOVERYENABLED, Buffer, sizeof(Buffer)/sizeof(WCHAR))){
            if (_wcsicmp(Buffer, L"NO") == 0) {
                Enabled = FALSE;
            }

            //
            //We do the below check also as we might have to migrate settings on server SKUs
            //that have this enabled. By default they are disabled.
            //

            if (_wcsicmp(Buffer, L"YES") == 0) {
                Enabled = TRUE;
            }

        }
    }



    Status = RtlLockBootStatusData( &BootStatusData );

    // This is the first time or there was no file. Create it

    if( !NT_SUCCESS( Status )){
        Status = RtlCreateBootStatusDataFile();

        if( !NT_SUCCESS( Status )){
            SetuplogError(
                LogSevWarning,
                L"Setup: (non-critical error) Could not lock the Crash Recovery status file - (%1!x!)\n",
                0,Status,NULL,NULL);
            return;
        }

        //Lock the file

        Status = RtlLockBootStatusData( &BootStatusData );
        if( !NT_SUCCESS( Status )){
            SetupDebugPrint1( L"Setup: (non-critical error) Could not lock the Crash Recovery status file - (%x)\n", Status );
            return;
        }

        Status = RtlGetSetBootStatusData(
                    BootStatusData,
                    FALSE,
                    RtlBsdItemAabTimeout,
                    &Timeout,
                    sizeof(UCHAR),
                    NULL
                    );
    
        if( !NT_SUCCESS( Status )){
            SetupDebugPrint1( L"Setup: (non-critical error) Could not set the Crash Recovery timeout - (%x)\n", Status );
            goto SCR_done;
        }


    }

    Status = RtlGetSetBootStatusData(
                BootStatusData,
                FALSE,
                RtlBsdItemAabEnabled,
                &Enabled,
                sizeof(BOOLEAN),
                NULL
                );

    if( !NT_SUCCESS( Status )){
        SetupDebugPrint1( L"Setup: (non-critical error) Could not enable Crash Recovery - (%x)\n", Status );
    }

SCR_done:

    RtlUnlockBootStatusData( BootStatusData );
    
    return;

}

DWORD
BuildFileListFromDir(
    IN PCTSTR PathBase,
    IN PCTSTR Directory OPTIONAL,
    IN DWORD MustHaveAttrs OPTIONAL,
    IN DWORD MustNotHaveAttrs OPTIONAL,
    IN PFN_BUILD_FILE_LIST_CALLBACK Callback OPTIONAL,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

	Builds a linked list containing the names (without path) of files present in a specified directory.
    The files must meed a set of conditions as specified by the arguments.

Arguments:

	PathBase -          The path to the directory to enumerate files in.
	Directory -         If not NULL or empty, it is appended to PathBase to form a complete path to the directory.
	MustHaveAttrs -     A set of attributes a file must have to be included on the list.
	MustNotHaveAttrs -  A set of attributes a file must not have to be included on the list.
	Callback -          If not NULL, this function will be called and the file will be included on the list only
                        if it returns TRUE.
	ListHead -          Pointer to the head of the list to be filled in.

Return value:

    ERROR_SUCCESS on success, otherwise a Win32 error code. The list may not be empty even if the function fails; the caller
    must always empty the list.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    PTSTR szPath = NULL;
    WIN32_FIND_DATA fd;

    if(ListHead != NULL) {
        InitializeListHead(ListHead);
    }

    if(NULL == PathBase || 0 == PathBase[0] || NULL == ListHead) {
        Error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    szPath = (PTSTR) MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(NULL == szPath) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    _tcsncpy(szPath, PathBase, MAX_PATH - 1);
    szPath[MAX_PATH - 1] = 0;

    if(Directory != NULL && Directory[0] != 0) {
        pSetupConcatenatePaths(szPath, Directory, MAX_PATH, NULL);
    }

    if(!pSetupConcatenatePaths(szPath, TEXT("\\*"), MAX_PATH, NULL)) {
        Error = ERROR_BAD_PATHNAME;
        goto exit;
    }

    hFind = FindFirstFile(szPath, &fd);

    if(INVALID_HANDLE_VALUE == hFind) {
        Error = GetLastError();

        if(ERROR_FILE_NOT_FOUND == Error || ERROR_PATH_NOT_FOUND == Error) {
            Error = ERROR_SUCCESS;
        }

        goto exit;
    }

    //
    // We might need the dir later
    //
    (_tcsrchr(szPath, L'\\'))[0] = 0;

    do {
        if(_tcscmp(fd.cFileName, _T(".")) != 0 && 
            _tcscmp(fd.cFileName, _T("..")) != 0 &&
            (MustHaveAttrs & fd.dwFileAttributes) == MustHaveAttrs &&
            0 == (MustNotHaveAttrs & fd.dwFileAttributes) &&
            (NULL == Callback || Callback(szPath, fd.cFileName))) {

            ULONG uLen;
            PSTRING_LIST_ENTRY pElem = (PSTRING_LIST_ENTRY) MyMalloc(sizeof(STRING_LIST_ENTRY));

            if(NULL == pElem) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            uLen = (_tcslen(fd.cFileName) + 1) * sizeof(TCHAR);
            pElem->String = (PTSTR) MyMalloc(uLen);

            if(NULL == pElem->String) {
                MyFree(pElem);
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            RtlCopyMemory(pElem->String, fd.cFileName, uLen);
            InsertTailList(ListHead, &pElem->Entry);
        }
    }
    while(FindNextFile(hFind, &fd));

    Error = GetLastError();

    if(ERROR_NO_MORE_FILES == Error) {
        Error = ERROR_SUCCESS;
    }

exit:
    if(hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if(szPath != NULL) {
        MyFree(szPath);
    }

    return Error;
}

PSTRING_LIST_ENTRY
SearchStringInList(
    IN PLIST_ENTRY ListHead,
    IN PCTSTR String,
    BOOL CaseSensitive
    )
/*++

Routine Description:

	This routine searches for a string in a string list. The string can be NULL or empty, in which
    case the function returns the first entry in the list with a NULL or empty string.

Arguments:

	ListHead -      Pointer to the head of the list to be searched.
	String -        Specifies the string to search for.
	CaseSensitive - If TRUE, the search will be case sensitive.

Return value:

	A pointer to the first entry containing the string, if found, or NULL otherwise.

--*/
{
    if(ListHead != NULL)
    {
        PLIST_ENTRY pEntry;
        ULONG uLen1 = (String != NULL ? _tcslen(String) : 0);

        for(pEntry = ListHead->Flink; pEntry != ListHead; pEntry = pEntry->Flink) {
            PSTRING_LIST_ENTRY pStringEntry;
            ULONG uLen2;
            pStringEntry = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);
            uLen2 = (pStringEntry->String != NULL ? _tcslen(pStringEntry->String) : 0);

            if(uLen1 == uLen2) {
                if(0 == uLen1 || 0 == (CaseSensitive ? _tcscmp : _tcsicmp)(String, pStringEntry->String)) {
                    return pStringEntry;
                }
            }
        }
    }

    return NULL;
}

DWORD
LookupCatalogAttribute(
    IN PCWSTR CatalogName,
    IN PCWSTR Directory OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    PBOOL Found
    )
/*++

Routine Description:

	This function searches if a catalog has the specified attribute with the specified value.

Arguments:

	CatalogName -       Name of the catalog to search. A path can be specified.
	Directory -         If specified, it is prepended to CatalogName to form the path to the catalog.
	AttributeName -     See AttributeValue.
	AttributeValue -    If AttributeName and AttributeValue are not specified, the catalog meets the condition.
                        If AttributeName is specified and AttributeValue isn't, the catalog meets the condition if
                        it contains an attribute with AttributeName name and any value. If AttributeName is not
                        specified and AttributeValue is, the catalog meets the condition if it contains an attribute 
                        with AttributeValue value and any name. If both AttributeName and AttributeValue are
                        specified, the catalog meets the condition if it contains an attribute with AttributeName name 
                        and AttributeValue value.
	Found -             Pointer to a variable that receives TRUE if the catalog meets the condition, or FALSE otherwise.

Return value:

	ERROR_SUCCESS if successful, otherwise a Win32 error code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    HANDLE hCat = INVALID_HANDLE_VALUE;
    PWSTR szCatPath = NULL;
    CRYPTCATATTRIBUTE* pAttr;

    if(Found != NULL) {
        *Found = FALSE;
    }

    if(NULL == CatalogName || 0 == CatalogName[0] || NULL == Found) {
        Error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if(Directory != NULL && Directory[0] != 0) {
        szCatPath = MyMalloc(MAX_PATH * sizeof(WCHAR));

        if(NULL == szCatPath) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        _tcsncpy(szCatPath, Directory, MAX_PATH - 1);
        szCatPath[MAX_PATH - 1] = 0;
        pSetupConcatenatePaths(szCatPath, CatalogName, MAX_PATH, NULL);
        CatalogName = szCatPath;
    }

    //
    // This is easier to test
    //
    if(AttributeName != NULL && 0 == AttributeName[0]) {
        AttributeName = NULL;
    }

    if(AttributeValue != NULL && 0 == AttributeValue[0]) {
        AttributeValue = NULL;
    }

    if(NULL == AttributeName && NULL == AttributeValue) {
        //
        // If attribute name and value are not specified, any catalog is a match
        //
        *Found = TRUE;
        goto exit;
    }

    hCat = CryptCATOpen((PWSTR) CatalogName, CRYPTCAT_OPEN_EXISTING, 0, 0, 0);

    if(INVALID_HANDLE_VALUE == hCat) {
        Error = GetLastError();
        goto exit;
    }

    pAttr = CryptCATEnumerateCatAttr(hCat, NULL);

    while(pAttr != NULL) {
        *Found = (NULL == AttributeName || 0 == _wcsicmp(AttributeName, pAttr->pwszReferenceTag)) && 
            (NULL == AttributeValue || 0 == _wcsicmp(AttributeName, (PCWSTR) pAttr->pbValue));

        if(*Found) {
            goto exit;
        }

        pAttr = CryptCATEnumerateCatAttr(hCat, pAttr);
    }

    Error = GetLastError();

    if(CRYPT_E_NOT_FOUND == Error) {
        Error = ERROR_SUCCESS;
    }

exit:
    if(szCatPath != NULL) {
        MyFree(szCatPath);
    }

    if(hCat != INVALID_HANDLE_VALUE) {
        CryptCATClose(hCat);
    }

    return Error;
}

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    )
{
    DWORD d = GetModuleFileName (Module, Buffer, BufferLength);
    Buffer[BufferLength - 1] = 0;
    return d < BufferLength ? d : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\netdde.c ===
#include "setupp.h"
#pragma hdrstop
#ifndef _WIN64

#include <setup_netdde.c>
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
// Modified 4/4/95 tedm

BOOL
InstallNetDDE(
    VOID
    )
{
    HKEY hKey;
    BOOL b;
    LONG rc;

    rc = RegOpenKeyEx(
            HKEY_USERS,
            L".DEFAULT",
            0,
            KEY_SET_VALUE | KEY_QUERY_VALUE,
            &hKey
            );

    if(rc == NO_ERROR) {
        if(b = CreateShareDBInstance()) {
            b = CreateDefaultTrust(hKey);
        }
        RegCloseKey(hKey);
        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CANT_INIT_NETDDE, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NETDDELIB_FAILED,
                NULL,NULL);
        }
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CANT_INIT_NETDDE, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            L"HKEY_USERS\\.DEFAULT",
            NULL,NULL);
    }

    return(b);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\optdirs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    optdirs.c

Abstract:

    Routines for copying optional directories.

Author:

    Ted Miller (tedm) 7-Jun-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


PWSTR OptionalDirSpec;

PWSTR *OptionalDirs;
UINT OptionalDirCount;


BOOL
InitializeOptionalDirList(
    VOID
    )

/*++

Routine Description:

    Initialize the list of optional directories by transforming a
    *-delineated list of directories into an array of strings.

Arguments:

    None.

Return Value:

    Boolean value indicating whether initialization was successful.
    If not an entry will have been logged indicating why.

--*/

{
    PWSTR p,q;
    WCHAR c;
    UINT Count,i,Len;

    //
    // The number of directories is equal to the number of *'s plus one.
    //
    Len = lstrlen(OptionalDirSpec);
    OptionalDirCount = 1;
    for(Count=0; Count<Len; Count++) {
        if(OptionalDirSpec[Count] == L'*') {
            OptionalDirCount++;
        }
    }

    OptionalDirs = MyMalloc(OptionalDirCount * sizeof(PWSTR));
    if(!OptionalDirs) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }
    ZeroMemory(OptionalDirs,OptionalDirCount * sizeof(PWSTR));

    p = OptionalDirSpec;
    Count = 0;
    do {
        if((q = wcschr(p,L'*')) == NULL) {
            q = wcschr(p,0);
        }

        c = *q;
        *q = 0;
        OptionalDirs[Count] = pSetupDuplicateString(p);
        *q = c;

        if(!OptionalDirs[Count]) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OPTIONAL_DIRS,NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);

            for(i=0; i<Count; i++) {
                MyFree(OptionalDirs[i]);
            }
            MyFree(OptionalDirs);
            return(FALSE);
        }

        Count++;
        p = q+1;

    } while(c);

    return(TRUE);
}


BOOL
QueueFilesInOptionalDirectory(
    IN HSPFILEQ FileQ,
    IN PCWSTR   Directory
    )
{
    WCHAR FileDirSpec[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    WCHAR c1,c2,c3;
    BOOL b;
    DWORD Result;

    //
    // Create the directory in the user's nt tree.
    //
    Result = GetWindowsDirectory(FileDirSpec,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);
    CreateDirectory(FileDirSpec,NULL);

    //
    // Form the full name of the directory to iterate
    // and add on the search spec.
    //
    lstrcpyn(FileDirSpec,SourcePath,MAX_PATH);
    pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);
    pSetupConcatenatePaths(FileDirSpec,L"*",MAX_PATH,NULL);

    b = TRUE;
    FindHandle = FindFirstFile(FileDirSpec,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // It's a directory. Ignore if current or parent dir spec (. or ..).
                //
                c1 = FindData.cFileName[0];
                c2 = FindData.cFileName[1];
                c3 = FindData.cFileName[2];

                if(!(((c1 == TEXT('.')) && !c2) || ((c1 == TEXT('.')) && (c2 == TEXT('.')) && !c3))) {
                    //
                    // Recurse to handle the child directory.
                    //
                    lstrcpyn(FileDirSpec,Directory,MAX_PATH);
                    pSetupConcatenatePaths(FileDirSpec,FindData.cFileName,MAX_PATH,NULL);

                    b = QueueFilesInOptionalDirectory(FileQ,FileDirSpec);
                }
            } else {
                //
                // It's a file. Queue it up for copy.
                //
                Result = GetWindowsDirectory(FileDirSpec,MAX_PATH);
                if (Result == 0) {
		    MYASSERT(FALSE);
                    return FALSE;
                }
                pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);

                b = SetupQueueCopy(
                        FileQ,
                        SourcePath,
                        Directory,
                        FindData.cFileName,
                        NULL,
                        NULL,
                        FileDirSpec,
                        FindData.cFileName,
                        SP_COPY_DELETESOURCE | BaseCopyStyle
                        );

                if(!b) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OPTIONAL_DIR,
                        Directory, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_RETURNED_WINERR,
                        L"SetupQueueCopy",
                        GetLastError(),
                        NULL,NULL);
                }
            }
        } while(b && FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    return(b);
}


BOOL
CopyOptionalDirectories(
    VOID
    )

/*++

Routine Description:

Arguments:

    None.

Return Value:

    Boolean value indicating whether copying was successful.
    If not an entry will have been logged indicating why.

--*/
{
    UINT u;
    BOOL b;
    HSPFILEQ FileQ;
    PVOID QueueCallbackInfo;
    BYTE PrevPolicy;
    BOOL ResetPolicy = FALSE;

    if(!OptionalDirSpec) {
        return(TRUE);
    }

    //
    // Unless the default non-driver signing policy was overridden via an
    // answerfile entry, then we want to temporarily turn down the policy level
    // to ignore while we copy optional directories.  Of course, setupapi log
    // entries will still be generated for any unsigned files copied during
    // this time, but there'll be no UI.
    //
    if(!AFNonDrvSignPolicySpecified) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, DRIVERSIGN_NONE, &PrevPolicy);
        ResetPolicy = TRUE;
    }

    //
    // Initialize the optional directory list.
    //
    if(!InitializeOptionalDirList()) {
        return(FALSE);
    }

    //
    // Initialize a setup file queue.
    //
    FileQ = SetupOpenFileQueue();
    if(FileQ == INVALID_HANDLE_VALUE) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }
    QueueCallbackInfo = SetupInitDefaultQueueCallbackEx(
        MainWindowHandle,
        INVALID_HANDLE_VALUE,
        0,0,NULL);

    if(!QueueCallbackInfo) {
        SetupCloseFileQueue(FileQ);
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }

    //
    // Queue the files in each directory.
    //
    b = TRUE;
    for(u=0; u<OptionalDirCount; u++) {
        if(!QueueFilesInOptionalDirectory(FileQ,OptionalDirs[u])) {
            b = FALSE;
        }
    }


    //
    // Copy the files in the queue. We do this even if some of the queue
    // operations failed, so we get at least a subset of the files copied over.
    //
    if(!SetupCommitFileQueue(MainWindowHandle,FileQ,SetupDefaultQueueCallback,QueueCallbackInfo)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIR_COPY,
            NULL,NULL);
        b = FALSE;
    }

    SetupTermDefaultQueueCallback(QueueCallbackInfo);
    SetupCloseFileQueue(FileQ);

    //
    // Now crank the non-driver signing policy back up to what it was prior to
    // entering this routine.
    //
    if(ResetPolicy) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, PrevPolicy, NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\pid.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    pid.c

Abstract:

    Product id routines.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

    13-Sep-1995 (t-stepl) - Check for unattended install

--*/

#include "setupp.h"
#include <spidgen.h>
#include <pencrypt.h>
#pragma hdrstop

CDTYPE  CdType;

//
// Constants used for logging that are specific to this source file.
//
PCWSTR szPidKeyName                 = L"SYSTEM\\Setup\\Pid";
PCWSTR szPidListKeyName             = L"SYSTEM\\Setup\\PidList";
PCWSTR szPidValueName               = L"Pid";
PCWSTR szPidSelectId                = L"270";
#if 0
// msdn no longer exists.
PCWSTR szPidMsdnId                  = L"335";
#endif
PCWSTR szPidOemId                   = L"OEM";
PCWSTR szFinalPidKeyName            = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
PCWSTR szFinalPidValueName          = L"ProductId";
PCWSTR szSkuProfessionalFPP         = L"B23-00079";
PCWSTR szSkuProfessionalCCP         = L"B23-00082";
PCWSTR szSkuProfessionalSelect      = L"B23-00305";
PCWSTR szSkuProfessionalEval        = L"B23-00084";
PCWSTR szSkuServerFPP               = L"C11-00016";
PCWSTR szSkuServerCCP               = L"C11-00027";
PCWSTR szSkuServerSelect            = L"C11-00222";
PCWSTR szSkuServerEval              = L"C11-00026";
PCWSTR szSkuServerNFR               = L"C11-00025";
PCWSTR szSkuAdvServerFPP            = L"C10-00010";
PCWSTR szSkuAdvServerCCP            = L"C10-00015";
PCWSTR szSkuAdvServerSelect         = L"C10-00098";
PCWSTR szSkuAdvServerEval           = L"C10-00014";
PCWSTR szSkuAdvServerNFR            = L"C10-00013";
PCWSTR szSkuDTCFPP                  = L"C49-00001";
PCWSTR szSkuDTCSelect               = L"C49-00023";
PCWSTR szSkuUnknown                 = L"A22-00001";
PCWSTR szSkuOEM                     = L"OEM-93523";

//
// Flag indicating whether to display the product id dialog.
//
BOOL DisplayPidDialog = TRUE;

//
// Product ID.
//
WCHAR ProductId[MAX_PRODUCT_ID+1];


PWSTR*  Pid20Array = NULL;

//
// pid 30 product id
//
WCHAR Pid30Text[5][MAX_PID30_EDIT+1];
WCHAR ProductId20FromProductId30[MAX_PRODUCT_ID+1];
WCHAR Pid30Rpc[MAX_PID30_RPC+1];
WCHAR Pid30Site[MAX_PID30_SITE+1];
BYTE  DigitalProductId[DIGITALPIDMAXLEN];

//
// global variable used for subclassing.
//
WNDPROC OldPidEditProc[5];


//
//  Pid related flags
//
// BOOL DisplayPidCdDialog;
// BOOL DisplayPidOemDialog;

//
// forward declarations
//

CDTYPE
MiniSetupGetCdType(
    LPCWSTR Value
    )

/*++

Routine Description:

    Get the right CD type during Mini-Setup. PidGen changes the channel ID
    for the value at HKLM\Software\Microsoft\Windows NT\CurrentVersion!ProductId,
    we have to preserve and rely on the value at HKLM\SYSTEM\Setup\Pid!Pid

Return Value:

    the CdType.

--*/

{
    CDTYPE RetVal;
    WCHAR  TmpPid30Site[MAX_PID30_SITE+1];
    HKEY   Key = NULL;
    DWORD  cbData;
    WCHAR  Data[ MAX_PATH + 1];
    DWORD  Type;

    cbData = sizeof(Data);
    if ( ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szPidKeyName,
                0,
                KEY_READ,
                &Key ) == ERROR_SUCCESS ) &&
          ( RegQueryValueEx( Key,
                 szPidValueName,
                 0,
                 &Type,
                 ( LPBYTE )Data,
                 &cbData ) == ERROR_SUCCESS ) )
    {
        wcsncpy(TmpPid30Site, Data + MAX_PID30_RPC, MAX_PID30_SITE+1);
    }
    else
    {
        if (Value != NULL)
        {
            wcsncpy(TmpPid30Site, Value, MAX_PID30_SITE+1);
        }
        else
        {
            TmpPid30Site[0] = L'\0';
        }
    }
    
    TmpPid30Site[MAX_PID30_SITE] = (WCHAR)'\0';

    if (_wcsicmp( TmpPid30Site, szPidSelectId ) == 0) {
        RetVal = CDSelect;
    } else if( _wcsicmp( TmpPid30Site, szPidOemId ) == 0 ) {
        RetVal = CDOem;
    } else {
        RetVal = CDRetail;
    }

    if (Key != NULL)
    {
        RegCloseKey(Key);
    }

    return RetVal;
}

PCWSTR GetStockKeepingUnit( 
    PWCHAR pMPC,
    UINT ProductType,
    CDTYPE  CdType
)
/*++

Routine Description:

    This returns the Stock Keeping Unit based off the MPC.

Arguments:

    pMPC - pointer to 5 digit MPC code, null terminated.
    ProductType - Product type flag, tells us if this is a workataion or server sku. 
    CdType - one of CDTYPE enum

Return Value:

    Returns pointer to sku.
    If no match found returns szSkuUnknown.

--*/
{
    // check for eval
    if (!_wcsicmp(Pid30Rpc,EVAL_MPC) || !_wcsicmp(Pid30Rpc,DOTNET_EVAL_MPC)){
        // this is eval media ...
        if (ProductType == PRODUCT_WORKSTATION){
            return (szSkuProfessionalEval);
        } // else
        // else it is server or advanced server.  I don't think that at this point
        // we can easily tell the difference.  Since it's been said that having the
        // correct sku is not critically important, I shall give them both the sku
        // code of server
        return (szSkuServerEval);
    }

    // check for NFR
    if (!_wcsicmp(Pid30Rpc,SRV_NFR_MPC)){
        return (szSkuServerNFR);
    }
    if (!_wcsicmp(Pid30Rpc,ASRV_NFR_MPC)){
        return (szSkuAdvServerNFR);
    }

    if (CdType == CDRetail) {
        if (!_wcsicmp(Pid30Rpc,L"51873")){
            return (szSkuProfessionalFPP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51874")){
            return (szSkuProfessionalCCP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51876")){
            return (szSkuServerFPP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51877")){
            return (szSkuServerCCP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51879")){
            return (szSkuAdvServerFPP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51880")){
            return (szSkuAdvServerCCP);
        }
        if (!_wcsicmp(Pid30Rpc,L"51891")){
            return (szSkuDTCFPP);
        }
    } else if (CdType == CDSelect) {
        if (!_wcsicmp(Pid30Rpc,L"51873")){
            return (szSkuProfessionalSelect);
        }
        if (!_wcsicmp(Pid30Rpc,L"51876")){
            return (szSkuServerSelect);
        }
        if (!_wcsicmp(Pid30Rpc,L"51879")){
            return (szSkuAdvServerSelect);
        }
        if (!_wcsicmp(Pid30Rpc,L"51891")){
            return (szSkuDTCSelect);
        }
    }

    return (szSkuUnknown);
}

BOOL
ValidateAndSetPid30(
    VOID
    )
/*++

Routine Description:

    Using the Pid30Text global variables, check if we have a valid id.
    This generates the pid30 digital product id and pid20 string id, which
    we set into DigitalProductId and ProductId20FromProductId30 globals

Arguments:

    None.

Return Value:

    TRUE if pid was valid.  Set's the globals correctly on success, zero's them out on failure

--*/

{
    WCHAR tmpPid30String[5+ 5*MAX_PID30_EDIT];
    BOOL rc;
    PCWSTR pszSkuCode;

    // Since we require a PID in the Select media too, we need to fill the string
    wsprintf( tmpPid30String, L"%s-%s-%s-%s-%s",
              Pid30Text[0],Pid30Text[1],Pid30Text[2],Pid30Text[3],Pid30Text[4]);

    pszSkuCode = GetStockKeepingUnit( Pid30Rpc, ProductType, CdType);

    *(LPDWORD)DigitalProductId = sizeof(DigitalProductId);
    rc = SetupPIDGenW(
                 tmpPid30String,             // [IN] 25-character Secure CD-Key (gets U-Cased)
                 Pid30Rpc,                   // [IN] 5-character Release Product Code
                 pszSkuCode,                 // [IN] Stock Keeping Unit (formatted like 123-12345)
                 (CdType == CDOem),          // [IN] is this an OEM install?
                 ProductId20FromProductId30, // [OUT] PID 2.0, pass in ptr to 24 character array
                 DigitalProductId,           // [OUT] pointer to binary PID3 buffer. First DWORD is the length
                 NULL);                      // [OUT] optional ptr to Compliance Checking flag (can be NULL)


#ifdef PRERELEASE
        SetupDebugPrint2(L"Pidgen returns for PID:%s and MPC:%s\n", tmpPid30String, Pid30Rpc);
#endif
    if (!rc) {
#ifdef PRERELEASE
        SetupDebugPrint1(L"Pidgen returns %d for PID.n", rc);
#endif
        ZeroMemory(Pid30Text[0],5*(MAX_PID30_EDIT+1));
    }       
    else
    {
        if (*ProductId20FromProductId30 == L'\0')
        {
            SetupDebugPrint(L"ProductId20FromProductId30 is empty after call into pidgen and pidgen returns OK\n");
        }
        if (*DigitalProductId == 0)
        {
            SetupDebugPrint(L"DigitalProductId is empty after call into pidgen and pidgen returns OK\n");
        }
    }

    return rc;

}

LRESULT
CALLBACK
PidEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, sets the focus to the correct edit box when the user enters text.
    This routine assumes that the pid controls ids are in sequential order.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    DWORD len, id;

    //
    // eat spaces
    //
    if ((msg == WM_CHAR) && (wParam == VK_SPACE)) {
        return(0);
    }

    if ((msg == WM_CHAR)) {
        //
        // First override: if we have the max characters in the current edit
        // box, let's post the character to the next box and set focus to that
        // control.
        //
        if ( ( (len = (DWORD)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0)) == MAX_PID30_EDIT) &&
             ((wParam != VK_DELETE) && (wParam != VK_BACK)) ) {
            //
            // set the focus to the next edit control and post the character
            // to that edit control
            //
            if ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5 ) {
                DWORD start, end;
                SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
                if (start == end) {
                    HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                    SetFocus(hNext);
                    SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                    PostMessage( GetDlgItem(GetParent(hwnd),id+1), WM_CHAR, wParam, lParam );
                    return(0);
                }

            }
        //
        // Second override: if the user hit's a delete key and they are at the
        // the start of an edit box, then post the delete to the previous edit
        // box.
        //
        } else if ( (len == 0) &&
                    ((id = GetDlgCtrlID(hwnd)) > IDT_EDIT_PID1) &&
                    ((wParam == VK_DELETE) || (wParam == VK_BACK) )) {
            //
            // set the focus to the previous edit control and post the command
            // to that edit control
            //
            HWND hPrev = GetDlgItem(GetParent(hwnd),id-1);
            SetFocus(hPrev);
            SendMessage(hPrev, EM_SETSEL, (WPARAM)MAX_PID30_EDIT-1,(LPARAM)MAX_PID30_EDIT);
            PostMessage( hPrev, WM_CHAR, wParam, lParam );
            return(0);
        //
        // Third override: if posting this message will give us the maximum
        // characters in our in the current edit box, let's post the character
        // to the next box and set focus to that control.
        //
        } else if (   (len == MAX_PID30_EDIT-1) &&
                      ((wParam != VK_DELETE) && (wParam != VK_BACK)) &&
                      ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5) ) {
            DWORD start, end;
            SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
            if (start == end) {
                HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                //
                // post the message to the edit box
                //
                CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam);
                //
                // now set the focus to the next edit control
                //
                SetFocus(hNext);
                SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                return(0);
            }
        }

    }

    return(CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam));
}


INT_PTR
CALLBACK
Pid30CDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

        Dialog procedure for the CD Retail Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;

    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDRetail;
            DisplayPidDialog = TRUE;
        }


        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;
    }
    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_IS_INVALID,NULL,
            IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(506);
            BEGIN_SECTION(L"Your (Retail) Product Key Page");
            if(DisplayPidDialog && CdType == CDRetail) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (Retail) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg(hdlg,IDD_PID_CD))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }

            if (!ValidateAndSetPid30()) {

                // failure
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_CD );
                }
                MessageBoxFromMessage(hdlg,MSG_PID_IS_INVALID,NULL,
                        IDS_ERROR,MB_OK|MB_ICONSTOP);

                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {


                // success
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;

                //
                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_PID_CANT_WRITE_PID,
                        dwRet,NULL,NULL);
                }

                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            }

            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE);
            END_SECTION(L"Your (Retail) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
Pid30OemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

        Dialog procedure for the OEM Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;

    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDOem;
            DisplayPidDialog = TRUE;
        }

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;

    }
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(507);
            BEGIN_SECTION(L"Your (OEM) Product Key Page");
            if(DisplayPidDialog && CdType == CDOem) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (OEM) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg( hdlg, IDD_PID_OEM ))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }


            if (!ValidateAndSetPid30()) {

                // failure
                //
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_OEM );
                } // if
                MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {

                // success
                //
                //  The Pid is valid.
                //


                //
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;

                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_PID_CANT_WRITE_PID,
                        dwRet,NULL,NULL);
                }
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);

            }
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE );
            END_SECTION(L"Your (OEM) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
Pid30SelectDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

        Dialog procedure for the OEM Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;

    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDSelect;
            DisplayPidDialog = TRUE;
        }

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;

    }
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(508);
            BEGIN_SECTION(L"Your (Select) Product Key Page");
            if(DisplayPidDialog && CdType == CDSelect) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (Select) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg( hdlg, IDD_PID_SELECT ))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }


            if (!ValidateAndSetPid30()) {

                // failure
                //
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_SELECT );
                } // if
                MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {

                // success
                //
                //  The Pid is valid.
                //


                //
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;

                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_PID_CANT_WRITE_PID,
                        dwRet,NULL,NULL);
                }
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);

            }
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE );
            END_SECTION(L"Your (Select) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
SetPid30Variables(
    PWSTR   Buffer
    )
{
    LPWSTR ptr;
    UINT i;


    //
    // all install cases are the same for pid3.0
    // Check that the string specified on the unattended script file
    // represents a valid 25 digit product id:
    //
    //      1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5
    //      0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2
    //                          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
    //
    // As a first validation test, we verify that the length is correct,
    // then we check if the "-" characters are in the correct place
    //
    //
    if(   ( wcslen( Buffer ) !=  (4+ MAX_PID30_EDIT*5)) ||
          ( Buffer[5]  != (WCHAR)L'-' ) ||
          ( Buffer[11] != (WCHAR)L'-' ) ||
          ( Buffer[17] != (WCHAR)L'-' ) ||
          ( Buffer[23] != (WCHAR)L'-' )
      ) {
          //
          // The Pid in the unattended script file is invalid.
          //
          return(FALSE);
    }


    for (i = 0;i<5;i++) {
        //
        // quintet i
        //
        ptr = &Buffer[i*(MAX_PID30_EDIT+1)];
        wcsncpy(Pid30Text[i], ptr, MAX_PID30_EDIT+1 );
        Pid30Text[i][MAX_PID30_EDIT] = (WCHAR)L'\0';
    }

    return TRUE;
}


BOOL
SetPid30FromAnswerFile(
    )
/*++

Routine Description:

        set the pid3.0 globals based on unattend file parameter, if it exists.

Arguments:

        None.

Return Value:


--*/

{
    WCHAR Buffer[MAX_BUF];
    DWORD dwRet;


    if (!GetPrivateProfileString(pwUserData,
                                 pwProductKey,
                                 L"",
                                 Buffer,
                                 sizeof(Buffer)/sizeof(WCHAR),
                                 AnswerFile)) {
       return(FALSE);
    }

    if (!Buffer || !*Buffer) {
       return(FALSE);
    }

    // Buffer contains the Product ID 
    // Is the PID encrypted?
    if (lstrlen(Buffer) > (4 + MAX_PID30_EDIT*5))
    {
        LPWSTR szDecryptedPID = NULL;
        if (ValidateEncryptedPID(Buffer, &szDecryptedPID) == S_OK)
        {
            lstrcpyn(Buffer, szDecryptedPID, sizeof(Buffer)/sizeof(WCHAR));
        }
        if (szDecryptedPID)
        {
            GlobalFree(szDecryptedPID);
        }
    }

    if ( !SetPid30Variables( Buffer ) ) {
        return FALSE;
    }

    SetupDebugPrint(L"Found Product key in Answer file.\n");
    //
    // check with pid30 to make sure it's valid
    //
    if (!ValidateAndSetPid30()) {
        return(FALSE);
    }

    dwRet = SetCurrentProductIdInRegistry();
    if (dwRet != NOERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PID_CANT_WRITE_PID,
            dwRet,NULL,NULL);
    }
    return(TRUE);

}



BOOL
InitializePid20Array(
    )
/*++

Routine Description:

        Build the array that contains all Pid20 found in the machine
        during textmode setup.  Even though we are using pid30 now, we still have
        a pid20 string id (pid30 is binary and can't be displayed to the user)

Arguments:

        None.

Return Value:


--*/

{
    LONG    Error;
    HKEY    Key;
    DWORD   cbData;
    WCHAR   Data[ MAX_PATH + 1];
    DWORD   Type;
    ULONG   i;
    ULONG   PidIndex;
    ULONG   Values;
    WCHAR   ValueName[ MAX_PATH + 1 ];

    Pid20Array = NULL;
    //
    //  Get the Pid from HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPidListKeyName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &Values,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    Pid20Array = (PWSTR *)MyMalloc( (Values + 1)* sizeof( PWSTR ) );

    for( i = 0, PidIndex = 0; i < Values; i++ ) {
        Pid20Array[PidIndex] = NULL;
        Pid20Array[PidIndex + 1] = NULL;
        swprintf( ValueName, L"Pid_%u", i );
        cbData = sizeof(Data);
        Error = RegQueryValueEx( Key,
                                 ValueName,
                                 0,
                                 &Type,
                                 ( LPBYTE )Data,
                                 &cbData );
        if( (Error != ERROR_SUCCESS) ||
            ( Type != REG_SZ ) ||
            ( wcslen( Data ) != MAX_PRODUCT_ID ) ) {
            continue;
        }
        Pid20Array[PidIndex] = pSetupDuplicateString( Data );
        PidIndex++;
    }
    RegCloseKey( Key );
    return( TRUE );
}


BOOL
InitializePidVariables(
    )
/*++

Routine Description:

        Read from the registry some values created by textmode setup,
        and initialize some global Pid flags based on the values found

Arguments:

        None.

Return Value:

        Returns TRUE if the initialization succedded.
        Returns FALSE if the Pid could not be read from the registry

--*/

{
    LONG    Error;
    HKEY    Key;
    DWORD   cbData;
    WCHAR   Data[ MAX_PATH + 1];
    DWORD   Type;
    ULONG   StringLength;
    PWSTR   p;
    DWORD   Seed;
    DWORD   RandomNumber;
    ULONG   ChkDigit;
    ULONG   i;
    PCWSTR  q;
    BOOLEAN KeyPresent;
    WCHAR   KeyBuffer[MAX_BUF];


    //
    // find out if product key was entered by the user or not
    // NB : set the answer file (if needed)
    //
    if (!AnswerFile[0])
      SpSetupLoadParameter(pwProductKey, KeyBuffer, sizeof(KeyBuffer)/sizeof(WCHAR));

    KeyBuffer[0] = 0;
    KeyPresent = ((GetPrivateProfileString(pwUserData, pwProductKey,
                      pwNull, KeyBuffer, sizeof(KeyBuffer)/sizeof(WCHAR),
                      AnswerFile) != 0) &&
                  (KeyBuffer[0] != 0));

    //  First create an array with the Pids found during textmode setup
    //
    if( !(MiniSetup || OobeSetup) ) {
        InitializePid20Array();
    }


    //
    //  Get the Pid from HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          ((MiniSetup || OobeSetup) ? szFinalPidKeyName : szPidKeyName),
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError( LogSevFatalError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PID_CANT_READ_PID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            Error,
            szPidKeyName,
            NULL,NULL);
        return( FALSE );
    }

    cbData = sizeof(Data);
    Error = RegQueryValueEx( Key,
                             ((MiniSetup || OobeSetup) ? szFinalPidValueName : szPidValueName),
                             0,
                             &Type,
                             ( LPBYTE )Data,
                             &cbData );
    RegCloseKey( Key );
    if( (Error != ERROR_SUCCESS) ) {
        SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_X_PARAM_RETURNED_WINERR,
                  szRegQueryValueEx,
                  Error,
                  szPidValueName,
                  NULL,NULL);
        return( FALSE );
    }

    //
    // Take care of the mini-setup case first because it's quick.
    // The Pid seeds left behind by textmode are long gone, so
    // we're going to pull out a few rabbits.  We'll go read the
    // real Pid (the one gui-mode generated the first time he
    // ran through) and use that to determine which kind of
    // PID to prompt for later on.
    //
    if( MiniSetup || OobeSetup ) {

        //
        // tuck away the rpc code for later on
        //
        wcsncpy( Pid30Rpc, Data, MAX_PID30_RPC +1 );
        Pid30Rpc[MAX_PID30_RPC] = (WCHAR)'\0';

        p = Data + (MAX_PID30_RPC + 1);
        wcsncpy(Pid30Site,p,MAX_PID30_SITE+1);
        Pid30Site[MAX_PID30_SITE] = (WCHAR)'\0';
        //
        // Look to see what kind of media we're installing from.
        //
        CdType = MiniSetupGetCdType(Pid30Site);

        if (CdType == CDSelect)
        {
            goto SelectPid;
        }
        else
        {
            DisplayPidDialog = TRUE;
        }

        return( TRUE );
    }



    //
    //  Do some validation of the value read
    //

    if( ( Type != REG_SZ ) ||
        ( ( ( StringLength = wcslen( Data ) ) != 0 ) &&
          ( StringLength != MAX_PID30_RPC ) &&
          ( StringLength != MAX_PID30_RPC + MAX_PID30_SITE )
        )
      ) {
        SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
        return( FALSE );
    }

    //
    // tuck away the rpc code for later on
    //
    wcsncpy( Pid30Rpc, Data, MAX_PID30_RPC +1 );
    Pid30Rpc[MAX_PID30_RPC] = (WCHAR)'\0';

    //
    //  Find out the kind of product we have (by looking at the site code):
    //  CD Retail, OEM or Select
    //

    if( StringLength > MAX_PID30_RPC ) {
        //
        //  If the Pid contains the Site, then find out what it is
        //
        p = Data + MAX_PID30_RPC;
        wcsncpy(Pid30Site,p,MAX_PID30_SITE+1);

        if(_wcsicmp( Pid30Site, szPidSelectId ) == 0) {

            //
            //  This is a Select CD
            //
SelectPid:
            CdType = CDSelect;
            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //

                if (!SetPid30FromAnswerFile()) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }
                DisplayPidDialog = FALSE;

            }
/*
// Old code. previous version of Windows did not require a PID for Select media.
            for (i = 0; i< 5; i++) {
                Pid30Text[i][0] = (WCHAR)L'\0';
            }

            DisplayPidDialog = FALSE;

            if (!ValidateAndSetPid30()) {
                SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
                return( FALSE );
            }

            if (MiniSetup || OobeSetup) {
                return(TRUE);
            }
*/
#if 0
// msdn media no longer exists (and if it does it should be viewed as retail,
// so later in this case statement we will fall thru to retail
        } else if (_wcsicmp( Pid30Site, szPidMsdnId ) == 0) {

            //
            //  This is an MSDN CD
            //
MsdnPid:
        for (i = 0; i< 5; i++) {
                LPWSTR ptr;
                ptr = (LPTSTR) &szPid30Msdn[i*(MAX_PID30_EDIT+1)];
                wcsncpy(Pid30Text[i], ptr, MAX_PID30_EDIT+1 );
                Pid30Text[i][MAX_PID30_EDIT] = (WCHAR)L'\0';
        }
            CdType = CDSelect;
        DisplayPidDialog = FALSE;
            if (!ValidateAndSetPid30()) {
                SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
                return( FALSE );
            }

            if (MiniSetup) {
                return(TRUE);
            }
#endif
        } else if( _wcsicmp( Pid30Site, szPidOemId ) == 0 ) {
            //
            //  This is OEM
            //
            CdType = CDOem;

            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //
                if (!SetPid30FromAnswerFile() ) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }

                DisplayPidDialog = FALSE;
            }

        } else {
            //
            // This is a bogus site assume CD Retail
            //
            CdType = CDRetail;
            wcsncpy( Pid30Site, L"000", MAX_PID30_SITE+1 );
            Pid30Site[ MAX_PID30_SITE ] = (WCHAR)'\0';

            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //

                if (!SetPid30FromAnswerFile()) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }
                DisplayPidDialog = FALSE;

            }

        }


    } else {
        //
        //  If it doesn't contain the Site, then it is a CD retail,
        //  and the appropriate Pid dialog must be displayed.
        //
        CdType = CDRetail;
        wcsncpy( Pid30Site, L"000", MAX_PID30_SITE+1 );
        Pid30Site[ MAX_PID30_SITE ] = (WCHAR)'\0';

        if (!EulaComplete && !KeyPresent) {
            DisplayPidDialog = TRUE;
        } else {
            //
            //  The Pid was specified during winnt32.
            //  Set the pid globals and build the product id string
            //
            if (!SetPid30FromAnswerFile()) {
               DisplayPidDialog = TRUE;
               goto finish;
            }
            DisplayPidDialog = FALSE;
        }
    }

finish:
    //
    //  Don't remove the Setup\Pid here. See MiniSetupGetCdType
    //  Delete Setup\PidList since it is no longer needed
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\Setup",
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );

    if( Error == ERROR_SUCCESS ) {
        // pSetupRegistryDelnode( Key, L"Pid" );
        pSetupRegistryDelnode( Key, L"PidList" );
        RegCloseKey( Key );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\ocm.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocm.c

Abstract:

    OC Manager implementation for intergratation with NT base setup

Author:

    Ted Miller (tedm) 20 May 1997

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#include <ocmanage.h>
#include <ocmgrlib.h>

//  Returns TRUE if ASR is enabled.  Otherwise, FALSE is returned.
BOOL
AsrIsEnabled(VOID);

VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    );

VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    );

VOID
OcSetReboot(
    VOID
    );

INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCWSTR      FormatString,
    ...
    );



OCM_CLIENT_CALLBACKS OcManagerImplementationCallbackRoutines = {
                                                                    OcFillInSetupDataA,
                                                                    OcLogError,
                                                                    OcSetReboot,
                                                                    OcFillInSetupDataW,
                                                                    ShowHideWizardPage,
                                                                    Billboard_Progress_Callback,
                                                                    Billboard_Set_Progress_Text,
                                                                    pSetupDebugPrint
                                                               };



PVOID
FireUpOcManager(
    VOID
    )

/*++

Routine Description:

    Initialize OC Manager, generating an OC Manager context.
    The master oc inf is assumed to be %windir%\system32\SYSOC.INF.

Arguments:

    None.

Return Value:

    OC Manager context handle.

--*/

{
    PWSTR MasterOcInf;
    WCHAR SystemDir[MAX_PATH];
    WCHAR DirSave[MAX_PATH];
    BOOL ShowErr;
    PVOID OcManagerContext;


    //
    // save the current directory
    //

    if(!GetCurrentDirectory(ARRAYSIZE(DirSave), DirSave)){
        MYASSERT(FALSE);
        return NULL;
    }

    //
    // get the system directory
    //

    if(!GetSystemDirectory(SystemDir, ARRAYSIZE(SystemDir))){
        MYASSERT(FALSE);
        return NULL;
    }

    //
    // set the current dir to the master oc inf path
    // so that OcInitialize can find the component DLLs
    //

    SetCurrentDirectory( SystemDir );

    //
    // create a valid path to the master oc inf
    //

    if( !MiniSetup ) {
        if (!AsrIsEnabled()) {
            MasterOcInf =  L"SYSOC.INF";
        }
        else {
            MasterOcInf = L"ASROC.INF";
        }

    } else {
        MasterOcInf =  L"MINIOC.INF";
    }

    //
    // initialize the oc manager
    //

    BEGIN_SECTION(L"Initializing the OC manager");
    OcManagerContext = OcInitialize(
        &OcManagerImplementationCallbackRoutines,
        MasterOcInf,
        OCINIT_FORCENEWINF,
        &ShowErr,
        NULL
        );
    END_SECTION(L"Initializing the OC manager");

    //
    // restore the current directory
    //

    SetCurrentDirectory( DirSave );

    //
    // return the oc manager handle
    //

    return OcManagerContext;
}


VOID
KillOcManager(
    PVOID OcManagerContext
    )

/*++

Routine Description:

    Terminate OC Manager

Arguments:

    OC Manager context handle.

Return Value:

    none

--*/

{
    MYASSERT(OcManagerContext);
    if (OcManagerContext)
        OcTerminate(&OcManagerContext);
}


VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager to request that the
    implementation fill in setup data to be passed to OC Manager
    component DLLs that expect Unicode data.

Arguments:

    SetupData - recieves setup data expected by OC components.

Return Value:

    None.

--*/

{
    //
    // It's not possible to be any more specific than this because
    // the mode page hasn't been shown yet.
    //
    SetupData->SetupMode = SETUPMODE_UNKNOWN;
    SetupData->ProductType = ProductType;

    lstrcpy(SetupData->SourcePath,SourcePath);

    SetupData->OperationFlags = 0;
    if(Win31Upgrade) {
        SetupData->OperationFlags |= SETUPOP_WIN31UPGRADE;
    }

    if(Win95Upgrade) {
        SetupData->OperationFlags |= SETUPOP_WIN95UPGRADE;
    }

    if(Upgrade) {
        SetupData->OperationFlags |= SETUPOP_NTUPGRADE;
    }

    if(UnattendMode > UAM_PROVIDEDEFAULT) {
        SetupData->OperationFlags |= SETUPOP_BATCH;
        lstrcpy(SetupData->UnattendFile,AnswerFile);
    }


    //
    // Which files are available?
    //
#if defined(_AMD64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_AMD64_FILES_AVAIL;
#elif defined(_X86_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL;
#elif defined(_IA64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_IA64_FILES_AVAIL;
#else
#pragma message( "*** Warning! No architecture defined!")
#endif

}


VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager to request that the
    implementation fill in setup data to be passed to OC Manager
    component DLLs that expect ANSI data.

Arguments:

    SetupData - recieves setup data expected by OC components.

Return Value:

    None.

--*/

{
    SETUP_DATAW setupdata;

    OcFillInSetupDataW(&setupdata);

    SetupData->SetupMode = setupdata.SetupMode;
    SetupData->ProductType = setupdata.ProductType;
    SetupData->OperationFlags = setupdata.OperationFlags;

    if(!WideCharToMultiByte(
        CP_ACP,
        0,
        setupdata.SourcePath,
        -1,
        SetupData->SourcePath,
        sizeof(SetupData->SourcePath),
        NULL,
        NULL
        )){
        MYASSERT(FALSE);
    }

    if(!WideCharToMultiByte(
        CP_ACP,
        0,
        setupdata.UnattendFile,
        -1,
        SetupData->UnattendFile,
        sizeof(SetupData->UnattendFile),
        NULL,
        NULL
        )){
        MYASSERT(FALSE);
    }
}


VOID
OcSetReboot(
    VOID
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager when a reboot is deemed
    necessary by an OC Manager component.

    For this integrated version of OC Manager, this does nothing;
    the system is rebooted at the end of text mode.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}


INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCWSTR      FormatString,
    ...
    )
{
    TCHAR str[4096];
    va_list arglist;
    UINT Icon;
    UINT lev;

    va_start(arglist,FormatString);
    _vsntprintf(str, ARRAYSIZE(str), FormatString, arglist);

    // null terminate string.
    str[ARRAYSIZE(str) - 1] = '\0';
    va_end(arglist);

    if (Level &  OcErrLevWarning)
        lev = LogSevWarning;
    else if (Level &  OcErrLevError)
        lev = LogSevError;
    else if (Level &  OcErrLevFatal)
        lev = LogSevError;
    else 
        lev = LogSevInformation;

#if DBG
    if (lev != LogSevInformation) {
        SetupDebugPrint(str);        
    }
#endif

    SetuplogError(lev, str, 0, NULL, NULL);

    return NO_ERROR;
}

HWND 
ShowHideWizardPage(
    IN BOOL bShow
    )
{
    HWND hwnd = GetBBhwnd();
    if (hwnd)
    {
        SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)!bShow, 0);
    }
    // If we show the wizard again, return the wizard hwnd
    if (bShow)
    {
        // Should hide the progress bar, the wizard page is showing.
        BB_ShowProgressGaugeWnd(SW_HIDE);
        hwnd = WizardHandle;
    }
    return hwnd;
}

LRESULT
Billboard_Progress_Callback(
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    LRESULT lResult;
    if ((Msg == PBM_SETRANGE) || (Msg == PBM_SETRANGE32))
    {
        // Also enable the progress bar
        // Note: No hiding of the progress this way.
        BB_ShowProgressGaugeWnd(SW_SHOW);
        lResult = ProgressGaugeMsgWrapper(Msg, wParam, lParam);
    }
    else
    {
        lResult = ProgressGaugeMsgWrapper(Msg, wParam, lParam);
    }

    return lResult;
}

VOID Billboard_Set_Progress_Text(LPCTSTR Text)
{
    BB_SetProgressText(Text);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\oobe.c ===
#include "setupp.h"
#pragma hdrstop


#define INTL_ANSWER_FILE        L"intl.txt"
#define INTL_LANG_SECTION       L"regionalsettings"
#define INTL_LOCALE             L"userlocale"
#define INTL_KEYBOARD           L"inputlocale"

// This turns on some debug spew that lists all the available locales, geo
// locations, and keyboards.
#define INTL_LIST_OPTIONS   0

#define LANG_LIST_INCREMENT   10
POOBE_LOCALE_INFO   LanguageList = NULL;
DWORD   LanguageListSize;
DWORD   LanguageIndex;
DWORD   DefaultID;
DWORD   DefaultIndex;

typedef struct tagPHONEENTRY {
    LPWSTR  Country;
    LPWSTR  TollFreeNumber;
    LPWSTR  TollNumber;
} PHONEENTRY, *PPHONEENTRY;

PWSTR   PhoneList = NULL;
DWORD   PhoneListSize;
DWORD   PhoneListLength;


//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
BOOL OobeSetup = FALSE;

//
// We need a global variable for OCM, coresponding to the local variable in
// InstallWindowsNT().
//
#ifdef _OCM
    PVOID g_OcManagerContext;
#endif


BOOL
WINAPI
SetupGetProductType(
    PWSTR   Product,
    PDWORD  pSkuFlags
    )
{
    Product[0] = 0;
    *pSkuFlags = 0;
    return TRUE;
}


PID3_RESULT
WINAPI
SetupPidGen3(
    PWSTR   Pid3,
    DWORD   SkuFlags,
    PWSTR   OemId,
    BOOL    Batch,
    PWSTR   Pid2,
    LPBYTE  lpPid3,
    LPBOOL  Compliance
    )
{
    if ( !InitializePidVariables() ) {
        SetupDebugPrint( L"SETUP: InitializePidVariables failed" );
        return PID_INVALID;
    }

    if ( !SetPid30Variables( Pid3 ) ) {
        SetupDebugPrint( L"SETUP: SetPid30Variables failed" );
        return PID_INVALID;
    }

    if ( !ValidateAndSetPid30() ) {
        SetupDebugPrint( L"SETUP: ValidateAndSetPid30 failed" );
        return PID_INVALID;
    }

    if(!SetProductIdInRegistry()) {
        SetupDebugPrint( L"SETUP: SetProductIdInRegistry failed" );
        return PID_INVALID;
    }

    return PID_VALID;
}


BOOL
WINAPI
SetupGetValidEula(
    PCWSTR  Eula,
    PWSTR   Path
    )
{
    return TRUE;
}


BOOL
CheckLangListSize(
    DWORD   StructSize
    )
{
    PVOID   NewList;


    //
    // Check to make sure the LanguageList has at least 1 unused element.
    // If not, make it bigger.
    //
    if ( LanguageIndex == LanguageListSize ) {

        LanguageListSize *= 2;
        NewList = MyRealloc(
            LanguageList,
            LanguageListSize * StructSize
            );

        if ( NewList ) {
            LanguageList = NewList;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
WINAPI
SetupDestroyLanguageList(
    IN      POOBE_LOCALE_INFO   LanguageList,
    IN      DWORD               Count
    )
{
    DWORD   i;


    if ( LanguageList ) {
        for ( i=0; i < Count; i++ ) {
            if ( LanguageList + i ) {
                MyFree( LanguageList[i].Name );
            }
        }

        MyFree( LanguageList );
    }
}


BOOL
CALLBACK
EnumLocalesProc(
    PWSTR pszLocale
    )
{
    BOOL    b;
    LCID    Locale;
    TCHAR   LanguageName[128];
    POOBE_LOCALE_INFO   pLocaleInfo;


    Locale = wcstoul (pszLocale, NULL, 16);

    b = GetLocaleInfo (
        Locale,
        LOCALE_SLANGUAGE | LOCALE_NOUSEROVERRIDE,
        LanguageName,
        sizeof(LanguageName) / sizeof(TCHAR)
        );
    MYASSERT(b);
    if ( !b ) {
        return FALSE;
    }

    //
    // Add it to our global array
    //
    if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }
    pLocaleInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
    pLocaleInfo->Name = MyMalloc( (lstrlen(LanguageName) + 1) * sizeof(TCHAR) );
    if ( !pLocaleInfo->Name ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    lstrcpy( pLocaleInfo->Name, LanguageName );
    pLocaleInfo->Id = Locale;
    pLocaleInfo->Installed = IsValidLocale(
        Locale,
        LCID_INSTALLED
        );

    if ( Locale == DefaultID ) {
        DefaultIndex = LanguageIndex;
    }

    LanguageIndex++;

    return TRUE;
}


int
__cdecl
LocaleCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((POOBE_LOCALE_INFO)arg1)->Name,
       ((POOBE_LOCALE_INFO)arg2)->Name
       );
}


BOOL
WINAPI
SetupGetLocaleOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    BOOL    bReturn = FALSE;
    DWORD   i;


    //
    // Init our global variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;


    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    DefaultID = OptionalDefault ? OptionalDefault : GetUserDefaultLCID();
    DefaultIndex = 0;

    EnumSystemLocales ( EnumLocalesProc , LCID_INSTALLED );

    if ( LanguageList ) {

        // Success
        qsort(
            LanguageList,
            LanguageIndex,
            sizeof( OOBE_LOCALE_INFO ),
            LocaleCompare
            );
        for (i=0; i<LanguageIndex; i++) {
            if (LanguageList[i].Id == DefaultID) {
                DefaultIndex = i;
                break;
            }
        }

#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetLocaleOptions|%x|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );

        }
#endif

        *ReturnList = LanguageList;
        LanguageList = NULL;
        *Items = LanguageIndex;
        *Default = DefaultIndex;
        bReturn = TRUE;
    }

exit:
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
CALLBACK
EnumGeoInfoProc(
    GEOID GeoID
    )
{
    TCHAR   pData[128];
    POOBE_LOCALE_INFO   pGeoInfo;


    //
    // Add it to our global array
    //
    if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    if( !GetGeoInfo(
        GeoID,
        GEO_FRIENDLYNAME,
        pData,
        sizeof(pData) / sizeof(TCHAR),
        0
        )) {

        // Skip this one.
        MYASSERT(0);
        return TRUE;
    }

    pGeoInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
    pGeoInfo->Name = MyMalloc( (lstrlen(pData) + 1) * sizeof(TCHAR) );
    if ( !pGeoInfo->Name ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    lstrcpy( pGeoInfo->Name, pData );
    pGeoInfo->Id = GeoID;
    pGeoInfo->Installed = TRUE;

    if ( GeoID == (GEOID)DefaultID ) {
        DefaultIndex = LanguageIndex;
    }
    LanguageIndex++;

    return TRUE;
}


BOOL
WINAPI
SetupGetGeoOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    BOOL    bReturn = FALSE;
    DWORD   i;


    //
    // Init our global variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;

    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    DefaultID = OptionalDefault ? OptionalDefault : GetUserGeoID( GEOCLASS_NATION );
    DefaultIndex = 0;

    bReturn = EnumSystemGeoID(
        GEOCLASS_NATION,
        0,
        EnumGeoInfoProc
        );
    MYASSERT(bReturn);

    if ( bReturn && LanguageList ) {
        // Success
        qsort(
            LanguageList,
            LanguageIndex,
            sizeof( OOBE_LOCALE_INFO ),
            LocaleCompare
            );
        for (i=0; i<LanguageIndex; i++) {
            if (LanguageList[i].Id == DefaultID) {
                DefaultIndex = i;
                break;
            }
        }
#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetGeoOptions|%d|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );
        }
#endif

        bReturn = TRUE;
        *ReturnList = LanguageList;
        LanguageList = NULL;
        *Items = LanguageIndex;
        *Default = DefaultIndex;
    }

exit:
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
WINAPI
SetupGetKeyboardOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    DWORD       DefaultKeyboard;
    DWORD       i;
    BOOL        bReturn = FALSE;
    TCHAR       pData[128];
    TCHAR       Substitute[9];
    POOBE_LOCALE_INFO   pLocaleInfo;
    DWORD       rc;
    HKEY        hLangKey = NULL;
    HKEY        hLangSubKey = NULL;
    DWORD       Index;
    TCHAR       SubKeyName[9];
    DWORD       SubKeyNameLength;
    DWORD       DataSize;
    DWORD       Type;


    //
    // Initialize our variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;

    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    // DefaultIndex = -1;
    *Default = 0;

    if (OptionalDefault) {
        DefaultKeyboard = OptionalDefault;

    } else {
        //
        // Lookup default keyboard in the registry
        //
        rc = RegOpenKeyEx( HKEY_USERS,
                           L".DEFAULT\\Keyboard Layout\\Preload",
                           0,
                           KEY_READ,
                           &hLangKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(.DEFAULT\\Keyboard Layout\\Preload) failed (%d)", rc );
            MYASSERT(0);
            goto exit;
        }

        DataSize = sizeof(pData);
        rc = RegQueryValueEx(
            hLangKey,
            L"1",
            NULL,
            &Type,
            (LPBYTE)pData,
            &DataSize
            );
        RegCloseKey( hLangKey );
        hLangKey = NULL;

        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegQueryValueEx(1) failed (%d)", rc );
            MYASSERT(0);
            goto exit;
        }

        DefaultKeyboard = wcstoul( pData, NULL, 16 );

        //
        // Now we look in the Substitutes key to see whether there is a
        // substitute there.
        //
        if( RegOpenKeyEx( HKEY_USERS,
                          L".DEFAULT\\Keyboard Layout\\Substitutes",
                          0,
                          KEY_READ,
                          &hLangKey ) == NO_ERROR) {

            DataSize = sizeof(Substitute);
            if( (RegQueryValueEx( hLangKey,
                                  pData,
                                  NULL,
                                  &Type,
                                  (LPBYTE)Substitute,
                                  &DataSize ) == NO_ERROR) &&
                (Type == REG_SZ)
                ) {

                DefaultKeyboard = wcstoul( Substitute, NULL, 16 );
            }

            RegCloseKey(hLangKey);
            hLangKey = NULL;
        }
    }

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Control\\Keyboard Layouts",
                       0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                       &hLangKey );
    if( rc != NO_ERROR ) {
        SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(System\\CurrentControlSet\\Control\\Keyboard Layouts) failed (%d)", rc );
        goto exit;
    }

    for( Index = 0; ; Index++ ) {

        SubKeyNameLength = sizeof(SubKeyName) / sizeof(TCHAR);

        rc = RegEnumKeyEx( hLangKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegEnumKeyEx failed (%d).  Index = %d", rc, Index );
                MYASSERT(0);
            }
            break;
        }

        rc = RegOpenKeyEx( hLangKey,
                           SubKeyName,
                           0,
                           KEY_READ,
                           &hLangSubKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(%s) failed (%d)", SubKeyName, rc );
            MYASSERT(0);
            continue;
        }

        DataSize = sizeof(pData);
        rc = RegQueryValueEx(
            hLangSubKey,
            L"Layout Text",
            NULL,
            &Type,
            (LPBYTE)pData,
            &DataSize
            );
        RegCloseKey( hLangSubKey );
        hLangSubKey = NULL;

        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegQueryValueEx(Layout Text) for %s failed (%d)", SubKeyName, rc );
            continue;
        }

        //
        // Add it to our global array
        //
        if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
            SetupDestroyLanguageList( LanguageList, LanguageIndex );
            LanguageList = NULL;
            goto exit;
        }
        pLocaleInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
        pLocaleInfo->Name = MyMalloc( (lstrlen(pData) + 1) * sizeof(TCHAR) );
        if ( !pLocaleInfo->Name ) {
            SetupDestroyLanguageList( LanguageList, LanguageIndex );
            LanguageList = NULL;
            goto exit;
        }

        lstrcpy( pLocaleInfo->Name, pData );
        pLocaleInfo->Id = wcstoul( SubKeyName, NULL, 16 );
        pLocaleInfo->Installed = TRUE;

        LanguageIndex++;
    }

    RegCloseKey( hLangKey );
    hLangKey = NULL;

    qsort(
        LanguageList,
        LanguageIndex,
        sizeof( OOBE_LOCALE_INFO ),
        LocaleCompare
        );
    for (i=0; i<LanguageIndex; i++) {
        if (LanguageList[i].Id == DefaultKeyboard) {
            *Default = i;
            break;
        }
    }

#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions|%x|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );
        }
#endif

    bReturn = TRUE;
    *ReturnList = LanguageList;
    LanguageList = NULL;
    *Items = LanguageIndex;

exit:
    if ( hLangKey ) {
        RegCloseKey( hLangKey );
     }
    if ( hLangSubKey ) {
        RegCloseKey( hLangSubKey );
    }
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
WINAPI
SetupSetIntlOptions(
    DWORD LocationIndex,
    DWORD LanguageIndex,
    DWORD KeyboardIndex
    )
{
    WCHAR   PathBuffer[MAX_PATH];
    WCHAR   KeyValue[128];
    WCHAR   CmdLine[MAX_PATH];
    BOOL    bResult;


    SetupDebugPrint3(
        L"SetupSetIntlOptions: Location = %d, Language = 0x%08x, Keyboard = 0x%08x",
        LocationIndex,
        LanguageIndex,
        KeyboardIndex );
    GetSystemDirectory( PathBuffer, MAX_PATH );
    pSetupConcatenatePaths( PathBuffer, INTL_ANSWER_FILE, MAX_PATH, NULL );
    DeleteFile( PathBuffer );

    //
    // Write language value
    //
    wsprintf(
        KeyValue,
        L"\"%08x\"",
        LanguageIndex
        );

    WritePrivateProfileString(
        INTL_LANG_SECTION,
        INTL_LOCALE,
        KeyValue,
        PathBuffer
        );

    //
    // Write keyboard value
    //
    wsprintf(
        KeyValue,
        L"\"%04x:%08x\"",
        KeyboardIndex & 0x0000ffff,
        KeyboardIndex
        );

    WritePrivateProfileString(
        INTL_LANG_SECTION,
        INTL_KEYBOARD,
        KeyValue,
        PathBuffer
        );

    //
    // Call intl.cpl to do the work
    //
    wsprintf(
        CmdLine,
        L"/f:\"%s\" /s:\"%s\"",
        PathBuffer,
        LegacySourcePath
        );

    InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);
    DeleteFile( PathBuffer );

    //
    // Set the GEO location
    //
    bResult = SetUserGeoID( LocationIndex );

    if ( !bResult ) {

        SetupDebugPrint1(
            L"SetupSetIntlOptions: SetUserGeoID failed.  Status = %d.",
            GetLastError()
            );
    }
    MYASSERT( bResult );

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   CompareCntryNameLookUpElements()
//
//  Synopsis:   Function to compare names used by sort
//
//+---------------------------------------------------------------------------
int __cdecl ComparePhoneEntry(const void *e1, const void *e2)
{
    PPHONEENTRY pPhone1 = (PPHONEENTRY)e1;
    PPHONEENTRY pPhone2 = (PPHONEENTRY)e2;

    return CompareStringW(LOCALE_USER_DEFAULT, 0,
        pPhone1->Country, -1,
        pPhone2->Country, -1
        ) - 2;
}

VOID
WINAPI
SetupDestroyPhoneList(
    )
{
    if ( PhoneList ) {
        MyFree( PhoneList );
    }
    PhoneList = NULL;
}

VOID
WINAPI
SetupFreePhoneList(PPHONEENTRY PhoneList, DWORD cbEntries)
{
    DWORD i;
    if ( PhoneList )
    {
        for( i=0; i < cbEntries; i++ )
        {
            if (PhoneList[i].Country) {
                GlobalFree(PhoneList[i].Country);
            }
            if (PhoneList[i].TollFreeNumber) {
                GlobalFree(PhoneList[i].TollFreeNumber);
            }
            if (PhoneList[i].TollNumber) {
                GlobalFree(PhoneList[i].TollNumber);
            }
        }
        GlobalFree(PhoneList);
    }
    PhoneList = NULL;
}


BOOL
AddToPhoneList(
    LPCWSTR Item
    )
{
    PVOID   NewList;
    DWORD   ItemLength = lstrlen(Item);


    if ( !PhoneList ) {

        PhoneListLength = 0;
        PhoneListSize = 1024;
        PhoneList = MyMalloc( PhoneListSize * sizeof(TCHAR) );
        if (!PhoneList) {
            return FALSE;
        }

    } else if ( PhoneListLength + ItemLength > PhoneListSize ) {

        PhoneListSize *= 2;
        NewList = MyRealloc(
            PhoneList,
            PhoneListSize * sizeof(TCHAR)
            );

        if ( NewList ) {
            PhoneList = NewList;
        } else {
            MyFree(PhoneList);
            return FALSE;
        }
    }

    memcpy( PhoneList + PhoneListLength,
            Item,
            ItemLength * sizeof(TCHAR)
            );

    PhoneListLength += ItemLength;

    return TRUE;
}

BOOL MakePhoneListForScript(PPHONEENTRY PhoneList, DWORD cbEntries)
{
    BOOL  bRet = FALSE;
    DWORD i;
    if ( PhoneList )
    {
        for( i=0; i < cbEntries; i++ )
        {
            if (!AddToPhoneList(PhoneList[i].Country) ||
                !AddToPhoneList( TEXT("\t") ) ||
                !AddToPhoneList(PhoneList[i].TollFreeNumber) ||
                !AddToPhoneList( TEXT("\t") ) ||
                !AddToPhoneList(PhoneList[i].TollNumber) ||
                !AddToPhoneList( TEXT("\t") ) )
            {
                goto ExitMakePhoneListForScript;
            }
        }
        bRet = TRUE;
    }
ExitMakePhoneListForScript:
    return bRet;
}

BOOL AddItemToPhoneEntry(LPCWSTR Item,
                         LPWSTR  *pPointer)
{
    BOOL bRet = FALSE;
    if ((Item) && (pPointer))
    {
        *pPointer = (LPWSTR)GlobalAlloc(GPTR, (lstrlen(Item) + 1)*sizeof(TCHAR));
        if (*pPointer)
        {
            lstrcpy(*pPointer, Item);
            bRet = TRUE;
        }
    }
    return bRet;
}


PTSTR
WINAPI
SetupReadPhoneList(
    PWSTR   PhoneInfName
    )
{
    HINF    PhoneInf = NULL;
    DWORD   LineCount;
    DWORD   ItemNo;
    LPCTSTR SectionName;
    INFCONTEXT InfContext;
    BOOL    bSucceeded = FALSE;
    PPHONEENTRY pPhoneList = NULL;

    SetupDebugPrint( L"START: SetupReadPhoneList");
    PhoneList = NULL;

    PhoneInf = SetupOpenInfFile( PhoneInfName, NULL, INF_STYLE_WIN4, NULL );
    if( PhoneInf == INVALID_HANDLE_VALUE ) {
        return NULL;
    }

    SectionName = TEXT("IsoCodes");
    LineCount = SetupGetLineCount( PhoneInf, SectionName );
    if ( !LineCount ) {

        goto ReadPhoneListCleanup;
    }

    pPhoneList = (PPHONEENTRY)GlobalAlloc(GPTR,
                                          (int)(sizeof(PHONEENTRY) * LineCount));

    if (!pPhoneList )
    {
        goto ReadPhoneListCleanup;
    }
    ZeroMemory( pPhoneList, sizeof(PHONEENTRY) * LineCount );

    for( ItemNo=0; ItemNo<LineCount; ItemNo++ ) {
        if( SetupGetLineByIndex( PhoneInf, SectionName, ItemNo, &InfContext )) {

            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 4 ), &pPhoneList[ItemNo].Country ) ) {

                goto ReadPhoneListCleanup;
            }
            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 5 ), &pPhoneList[ItemNo].TollFreeNumber ) ) {

                goto ReadPhoneListCleanup;
            }
            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 6 ), &pPhoneList[ItemNo].TollNumber ) ) {

                goto ReadPhoneListCleanup;
            }
        }
    }

    // sort the array
    qsort(pPhoneList, (int)LineCount,sizeof(PHONEENTRY),
      ComparePhoneEntry);


    // Convert the array into a TAB delimited list for script.
    if (MakePhoneListForScript(pPhoneList,LineCount))
    {
        //
        // Replace the final TAB with a NUL.
        //
        PhoneList[PhoneListLength-1] = '\0';

        bSucceeded = TRUE;
    }

ReadPhoneListCleanup:

    if (pPhoneList)
    {
        SetupFreePhoneList(pPhoneList,LineCount);
    }
    SetupCloseInfFile( PhoneInf );

    SetupDebugPrint( L"END: SetupReadPhoneList");
    if ( bSucceeded ) {
        return PhoneList;
    } else {
        SetupDestroyPhoneList();
        return NULL;
    }
}


//
// Read INF to map a TAPI country id to a 3 letter ISO code.
//
VOID
SetupMapTapiToIso (
    IN  PWSTR   PhoneInfName,
    IN  DWORD   dwCountryID,
    OUT PWSTR   szIsoCode
    )
{
    HINF        PhoneInf;
    WCHAR       szCountryID[9];
    BOOL        bResult;
    INFCONTEXT  Context;


    szIsoCode[0] = L'\0';
    PhoneInf = SetupOpenInfFile( PhoneInfName, NULL, INF_STYLE_WIN4, NULL );
    if( PhoneInf == INVALID_HANDLE_VALUE ) {
        return;
    }

    wsprintf ( szCountryID, L"%d", dwCountryID);

    bResult = SetupFindFirstLine (
        PhoneInf,
        L"TapiCodes",
        szCountryID,
        &Context
        );

    if (bResult) {
        SetupGetStringField ( &Context, 1, szIsoCode, 4, NULL );
        SetupDebugPrint2 ( L"SetupMapTapiToIso: %d mapped to %s", dwCountryID, szIsoCode );
    }

    SetupCloseInfFile( PhoneInf );
}


BOOL
WINAPI
SetupGetSetupInfo(
    PWSTR Name,     OPTIONAL
    DWORD cbName,
    PWSTR Org,      OPTIONAL
    DWORD cbOrg,
    PWSTR OemId,    OPTIONAL
    DWORD cbOemId,
    LPBOOL IntlSet  OPTIONAL
    )
{
    BOOL    b = TRUE;
    HKEY    hkey = NULL;
    DWORD   Size;
    DWORD   Type;


    //
    // Open the key if we need it
    //
    if( (Name || Org) &&
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,0,
        KEY_QUERY_VALUE,&hkey) != NO_ERROR) {

        return FALSE;
    }

    //
    // Get Name
    //
    if (Name) {
        Size = cbName;
        if((RegQueryValueEx(hkey,szRegisteredOwner,NULL,&Type,
            (LPBYTE)Name,&Size) != NO_ERROR)
            || (Type != REG_SZ)
            ) {

            b = FALSE;
        }
    }

    //
    // Get Org
    //
    if (Org) {
        Size = cbOrg;
        if((RegQueryValueEx(hkey,szRegisteredOrganization,NULL,&Type,
            (LPBYTE)Org,&Size) != NO_ERROR)
            || (Type != REG_SZ)
            ) {

            b = FALSE;
        }
    }

    // TBD: figure out what this is for
    if (OemId) {
        OemId[0] = 0;
        cbOemId = 0;
    }

    //
    // Note: IntlSet is not used currently
    //

    if (hkey) {
        RegCloseKey(hkey);
    }
    return b;
}

BOOL
WINAPI
SetupSetSetupInfo(
    PCWSTR  Name,
    PCWSTR  Org
    )
{
    BOOL    b;


    b = StoreNameOrgInRegistry( (PWSTR)Name, (PWSTR)Org );
    return b;
}


BOOL
WINAPI
SetupSetAdminPassword(
    PCWSTR  OldPassword,
    PCWSTR  NewPassword
    )
{
    WCHAR   AdminName[MAX_USERNAME+1];
    BOOL    Status;


    GetAdminAccountName( AdminName );
    Status = SetLocalUserPassword( AdminName, OldPassword, NewPassword );

    if ( !Status ) {
        SetupDebugPrint( L"SetupSetAdminPassword: SetLocalUserPassword failed.");
    }

    return Status;
}


VOID
WINAPI
SetupOobeInitDebugLog(
    )
{
    //
    // Do no UI.  Note that we must set OobeSetup before our first call to
    // SetupDebugPrint.
    //

    OobeSetup = TRUE;
    SetupDebugPrint( L"SetupOobeInitDebugLog" );
}


// Run initialization that is known not to requires services to run.
//
VOID
WINAPI
SetupOobeInitPreServices(
    IN  BOOL    DoMiniSetupStuff
    )
{
    //
    // Turn off logging.
    //
    // IsSetup = FALSE;

    SetupDebugPrint( L"SetupOobeInitPreServices" );

    if ( DoMiniSetupStuff ) {
        //
        // Act like the miniwizard (except with no UI)
        //
        MiniSetup = TRUE;
        Preinstall = TRUE;

        //
        // Tell SetupAPI not to bother backing up files and not to verify
        // that any INFs are digitally signed.
        //
        pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_BACKUP|PSPGF_NO_VERIFY_INF);

        CommonInitialization();

        SetUpDataBlock();
        InternalSetupData.CallSpecificData1 = 0;

#if 0
        //
        // We aren't going to do this for rev 1.
        //

        if( PnPReEnumeration ) {
            //
            // The user wants us to do PnP re-enumeration.
            // Go do it.
            //
            InstallPnpDevices( hdlg,
                               SyssetupInf,
                               GetDlgItem(hdlg,IDC_PROGRESS1),
                               StartAtPercent,
                               StopAtPercent );
        }
#endif
    } else { // DoMiniSetupStuff

    //
    // Get handle to heap so we can periodically validate it.
    //
#if DBG
        g_hSysSetupHeap = GetProcessHeap();
#endif
    }
}


// Run initialization that may or does require services.
//
VOID
WINAPI
SetupOobeInitPostServices(
    IN  BOOL    DoMiniSetupStuff
    )
{
    InitializeExternalModules(
        DoMiniSetupStuff,
        &g_OcManagerContext
    );
}


VOID
WINAPI
SetupOobeCleanup(
    IN  BOOL    DoMiniSetupStuff
    )
{
    static FINISH_THREAD_PARAMS Context;


    SetupDebugPrint( L"SetupOobeCleanup" );

    if ( DoMiniSetupStuff ) {

        RestoreBootTimeout();

        Context.ThreadId = GetCurrentThreadId();
        Context.OcManagerContext = g_OcManagerContext;
        FinishThread( &Context );
    }
}

// Resets the activation days (allowed 3 times only)
//
DWORD
SetupReArmWPA(
    VOID
    )
{
    LPCSTR  lpszReArmInterface = (LPCSTR)124;
    typedef HRESULT (WINAPI* lpReArmEntryPoint) ();
    HMODULE hRearmdll = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    hRearmdll = LoadLibraryA("licdll.dll");

    if (hRearmdll)
    {
        lpReArmEntryPoint pReArmEntry  =
                                (lpReArmEntryPoint) GetProcAddress(hRearmdll,lpszReArmInterface);

        if (pReArmEntry)
        {
            //
            // ValidateDigitalPid returns zero if success, otherwise its custom error code
            //
            HRESULT hr = (*pReArmEntry )();

            if (FAILED(hr))
            {
                // If PID cannot be validated we should force activation/PID reentry.
                SetupDebugPrint1(L"SETUP: Rollback WPA failed! HRESULT=%ld", hr);
                dwError = (DWORD)hr;
            }
            else
                SetupDebugPrint(L"SETUP: Rollback WPA succeeded.");
        }
        else {
            SetupDebugPrint(L"SETUP: Failed to get WPA entry point!");
            dwError = ERROR_INVALID_FUNCTION;
        }
        FreeLibrary (hRearmdll);
    }
    else {
        SetupDebugPrint(L"SETUP: Failed to load WPA library!");
        dwError = ERROR_FILE_NOT_FOUND;
    }

    // Return error code or success
    //
    return dwError;
}

// Once Windows is activated the Activate Windows shortcut is removed by msoobe.exe /a.
// If OEMs sysprep a machine they will need to re-activate Windows and the shortcut
// needs to be restored.  Msoobe.exe cannot restore it because it does not
// run in server skus.
//
DWORD
SetupRestoreWPAShortcuts(
    VOID
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HINF hinf;
    hinf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    if(hinf != INVALID_HANDLE_VALUE)
    {
        if (SetupInstallFromInfSection(NULL,
                                       hinf,
                                       L"RESTORE_OOBE_ACTIVATE",
                                       SPINST_PROFILEITEMS , //SPINST_ALL,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL) != 0)
        {
            // Success
            SetupDebugPrint(L"SETUP: Restore Activation shortcut succeeded");
        }
        else
        {
            // Failure
            dwError = GetLastError();
            SetupDebugPrint1(L"SETUP: Restore Activation shortcut failed. GetLastError=%ld",dwError);
        }
        SetupCloseInfFile(hinf);
    }
    else
    {
        dwError = GetLastError();
        SetupDebugPrint1(L"SETUP: Restore Activation shortcut failed to open syssetup.inf. GetLastError=%ld",dwError);
    }

    return dwError;
}

BOOL Activationrequired(VOID);

// Rollback the activation days and put back the activate windows shortcut(s). X86 only.
//
DWORD
WINAPI
SetupOobeBnk(
    LPBYTE pDummy
    )
{
    DWORD dwError = ERROR_SUCCESS;

    // Return if we failed to rollback so we don'put the shortcut back
    // On volume license skus this always returns successful
    //
    if (ERROR_SUCCESS != (dwError = SetupReArmWPA()))
        return dwError;

    // If not activated, restore the shortcuts, or if we don't
    // require activation (for volume license skus)
    //
    if (Activationrequired())
    {
        // Restore the Activate Windows shortcut(s)
        //
        dwError = SetupRestoreWPAShortcuts();
    }
    return dwError;
}


static
LPTSTR
NextNumber(
    LPTSTR lpString,
    BOOL bSkipFirst
    )
{
    // The first time we just want to walk past any non-numbers,
    // we don't want to skip any numbers if they are right at the
    // begining of the string.
    //
    if ( bSkipFirst )
    {
        // Walk past the first number in the string.
        //
        while ( ( *lpString >= _T('0') ) &&
                ( *lpString <= _T('9') ) )
        {
            lpString++;
        }
    }

    // Now walk till we get to the next number or we reach the end.
    //
    while ( ( *lpString ) &&
            ( ( *lpString < _T('0') ) ||
              ( *lpString > _T('9') ) ) )
    {
        lpString++;
    }

    return lpString;
}

BOOL
WINAPI
SetupSetDisplay(
    LPCTSTR lpszUnattend,
    LPCTSTR lpszSection,
    LPCTSTR lpszResolutionKey,
    LPCTSTR lpszRefreshKey,
    DWORD   dwMinWidth,
    DWORD   dwMinHeight,
    DWORD   dwMinBits
    )
{
    DEVMODE devmode;
    DWORD   dwVal;
    TCHAR   szText[256];
    LPTSTR  lpDisplay;
    BOOL    bRet = TRUE;

    ZeroMemory(&devmode, sizeof(DEVMODE));
    devmode.dmSize = sizeof(DEVMODE);

    // Check the current resolution, make sure it meets our mins.
    //
    if ( EnumDisplaySettings(NULL, ENUM_REGISTRY_SETTINGS, &devmode) )
    {
        if ( devmode.dmPelsWidth < dwMinWidth )
        {
            devmode.dmPelsWidth =  dwMinWidth;
            devmode.dmFields |= DM_PELSWIDTH;
        }

        if ( devmode.dmPelsHeight < dwMinHeight )
        {
            devmode.dmPelsHeight = dwMinHeight;
            devmode.dmFields |= DM_PELSHEIGHT;
        }

        if ( devmode.dmBitsPerPel < dwMinBits )
        {
            devmode.dmBitsPerPel = dwMinBits;
            devmode.dmFields |= DM_BITSPERPEL;
        }
    }

    // Make sure they passed in an unattend and section to look in.
    //
    if ( lpszUnattend && *lpszUnattend && lpszSection && *lpszSection )
    {
        // Now check in the winbom to see if they want to change the current resolution.
        //
        szText[0] = _T('\0');
        if ( ( lpszResolutionKey ) &&
             ( *lpszResolutionKey ) &&
             ( GetPrivateProfileString(lpszSection, lpszResolutionKey, _T(""), szText, sizeof(szText) / sizeof(szText[0]), lpszUnattend) ) &&
             ( szText[0] ) )
        {
            bRet = FALSE;

            lpDisplay = NextNumber(szText, FALSE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_PELSWIDTH;
                devmode.dmPelsWidth = dwVal;
            }

            lpDisplay = NextNumber(lpDisplay, TRUE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_PELSHEIGHT;
                devmode.dmPelsHeight = dwVal;
            }

            lpDisplay = NextNumber(lpDisplay, TRUE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_BITSPERPEL;
                devmode.dmBitsPerPel = dwVal;
            }
        }

        // Now check in the winbom to see if they want to change the default refresh rate.
        //
        szText[0] = _T('\0');
        if ( ( lpszRefreshKey ) &&
             ( *lpszRefreshKey ) &&
             ( GetPrivateProfileString(lpszSection, lpszRefreshKey, _T(""), szText, sizeof(szText) / sizeof(szText[0]), lpszUnattend) ) &&
             ( szText[0] ) )
        {
            bRet = FALSE;

            if ( dwVal = (DWORD) _ttoi(szText) )
            {
                devmode.dmFields |= DM_DISPLAYFREQUENCY;
                devmode.dmDisplayFrequency = dwVal;
            }
        }
    }

    // If we have anything to change, change it now.
    //
    if ( devmode.dmFields )
    {
        DWORD dwRet = ChangeDisplaySettings(&devmode, CDS_UPDATEREGISTRY | CDS_GLOBAL);

        switch ( dwRet )
        {
            case DISP_CHANGE_SUCCESSFUL:
            case DISP_CHANGE_RESTART:
                bRet = TRUE;
                break;

            //case DISP_CHANGE_BADFLAGS:
            //case DISP_CHANGE_BADPARAM:
            //case DISP_CHANGE_FAILED:
            //case DISP_CHANGE_BADMODE
            //case DISP_CHANGE_NOTUPDATED:
                //bRet = FALSE;
        }
    }

    return bRet;
}


typedef struct _OEM_FINISH_APPS {
    LPTSTR  szApp;
    LPTSTR  szArgs;
} OEM_FINISH_APPS;

OEM_FINISH_APPS OEM_Finish_Apps[] = {
    { L"Rundll32.exe", L"fldrclnr.dll,Wizard_RunDLL silent"},
    { NULL, NULL}   // End of list.
};


void RunOEMExtraTasks()
{
    LPTSTR pApp = NULL;
    LPTSTR pArgs = NULL;
    DWORD dwSize;
    DWORD dwCode;
    int i;

    BEGIN_SECTION(L"RunOEMExtraTasks");
    i = 0;
    while (OEM_Finish_Apps[i].szApp != NULL)
    {
        // Get the size we need to the expanded app
        dwSize = ExpandEnvironmentStrings(
                                OEM_Finish_Apps[i].szApp ,
                                NULL,
                                0);
        if (dwSize)
        {
            pApp = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR) * dwSize);
            if (pApp)
            {
                ExpandEnvironmentStrings(
                                OEM_Finish_Apps[i].szApp ,
                                pApp,
                                dwSize);

                if (OEM_Finish_Apps[i].szArgs)
                {
                    // Get the size we need to the expanded arguments
                    dwSize = ExpandEnvironmentStrings(
                                            OEM_Finish_Apps[i].szArgs ,
                                            NULL,
                                            0);
                    if (dwSize)
                    {
                        pArgs = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR) * dwSize);
                        if (pArgs)
                        {
                            ExpandEnvironmentStrings(
                                            OEM_Finish_Apps[i].szArgs,
                                            pArgs,
                                            dwSize);
                        }
                    }
                }
                // Log what we will start
                if (pArgs)
                {
                    SetupDebugPrint2(L"Start command :%s: with arguments :%s:", pApp, pArgs);
                }
                else
                {
                    SetupDebugPrint1(L"Start command :%s: with no arguments", pApp);
                }

                // Start the app.
                dwCode = 0;
                if (pArgs)
                {
                    InvokeExternalApplicationEx(pApp, pArgs, &dwCode, INFINITE, TRUE);
                }
                else
                {
                    // If we don't have args. the first parameter is NULL
                    InvokeExternalApplicationEx(NULL, pApp, &dwCode, INFINITE, TRUE);
                }
            }
        }
        if (pApp)
        {
            GlobalFree(pApp);
            pApp = NULL;
        }
        if (pArgs)
        {
            GlobalFree(pArgs);
            pArgs = NULL;
        }
        i++;
    }
    END_SECTION(L"RunOEMExtraTasks");
}

static 
BOOL
SetupCheckRegValue(
    IN HKEY   hKey,
    IN LPTSTR lpszValueName,
    IN DWORD  dwCompareValue
    )
{
    BOOL  fRet = FALSE;
    DWORD dwData = 0,
          dwType,
          cbSize = sizeof(dwData);

    if ( ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                             lpszValueName,
                                             0,
                                             &dwType,
                                             (LPBYTE) &dwData,
                                             &cbSize ) ) &&
         ( REG_DWORD == dwType) &&
         ( dwData == dwCompareValue ) )
    {
        fRet = TRUE;
    }

    return fRet;
}

BOOL
SetupGetInstallMode(
    OUT LPDWORD lpdwMode,
    OUT LPDWORD lpdwFlags
    )
{
    BOOL fRet = FALSE;
    HKEY hKeySetup;

    //
    // Make sure the caller is actually checking for something.
    //
    if ( lpdwMode || lpdwFlags )
    {
        //    
        // Also make sure we can open the "HKLM\System\Setup" key.
        //
        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            TEXT("System\\Setup"),
                                            0,
                                            KEY_READ,
                                            &hKeySetup ) )
        {
            DWORD dwMode  = SETUP_MODE_NONE,
                  dwFlags = 0;
            BOOL  fSetup,
                  fOobe,
                  fAudit,
                  fMini,
                  fFactory;

            //
            // Check all of the registry values we might care about...
            //
            fSetup   = SetupCheckRegValue( hKeySetup, TEXT("SystemSetupInProgress"),       1 );
            fOobe    = SetupCheckRegValue( hKeySetup, TEXT("OobeInProgress"),              1 );
            fAudit   = SetupCheckRegValue( hKeySetup, TEXT("AuditInProgress"),             1 );
            fMini    = SetupCheckRegValue( hKeySetup, TEXT("MiniSetupInProgress"),         1 );
            fFactory = SetupCheckRegValue( hKeySetup, TEXT("FactoryPreInstallInProgress"), 1 );

            //
            // We are in OOBE if the OobeInProgress value is non-zero...
            //
            if ( fOobe )
            {
                dwMode = SETUP_MODE_OOBE;
                if ( fMini )
                {
                    dwFlags |= SETUP_FLAG_OEM;
                }
            }
            else
            {
                //
                // We are in MiniSetup if the MiniSetupInProgress value is non-zero...
                //
                if ( fMini )
                {
                    dwMode = SETUP_MODE_MINI;
                    dwFlags |= SETUP_FLAG_OEM;
                }
                else
                {
                    //
                    // We are in Audit mode if the AuditInProgress value is non-zero...
                    //
                    if ( fAudit )
                    {
                        dwMode = SETUP_MODE_AUDIT;
                        dwFlags |= (SETUP_FLAG_OEM | SETUP_FLAG_UNATTENDED);

                        //
                        // If the FactoryPreInstallInProgress flag is non-zero, then we are delaying PNP...
                        //
                        if ( fFactory )
                        {
                            dwFlags |= SETUP_FLAG_DELAYPNP;
                        }
                    }
                    else
                    {
                        //
                        // We are in Setup if the SystemSetupInProgress and SetupType values are non-zero...
                        //
                        if ( fSetup )
                        {
                            dwMode = SETUP_MODE_SETUP;
                        }
                    }
                }
            }

            //
            // Now put our values into the caller's buffers...
            //
            if ( lpdwMode )
            {
                *lpdwMode = dwMode;
            }

            if ( lpdwFlags )
            {
                *lpdwFlags = dwFlags;
            }

            //
            // We were able to open the Setup key... so return TRUE.
            //
            fRet = TRUE;

            //
            // We're done, so close the Setup key.
            //
            RegCloseKey( hKeySetup );
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\printer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    printer.c

Abstract:

    Routines to deal with printer/spooler.

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\printer.c

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// Name of spooler service.
//
PCWSTR szSpooler = L"Spooler";


BOOL
MiscSpoolerInit(
    VOID
    )
{
    MONITOR_INFO_2  MonitorInfo2;
    PROVIDOR_INFO_1 ProviderInfo1;
    BOOL b;
    WCHAR MonitorName[128];

    MonitorInfo2.pName = L"Local Port";
    MonitorInfo2.pEnvironment = NULL;
    MonitorInfo2.pDLLName = L"localmon.dll";

    b = TRUE;

    if(!AddMonitor(NULL,2,(PBYTE)&MonitorInfo2)) {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddMonitor",
            GetLastError(),
            NULL,NULL);
    }

    if(!AddPrintProcessor(NULL,NULL,L"winprint.dll",L"winprint")) {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddPrintProcessor",
            GetLastError(),
            NULL,NULL);
    }

    ProviderInfo1.pName         = L"Internet Print Provider";
    ProviderInfo1.pEnvironment  = NULL;
    ProviderInfo1.pDLLName      = L"inetpp.dll";

    if ( !AddPrintProvidor(NULL, 1, (LPBYTE)(&ProviderInfo1)) ) {

        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddPrintProvidor",
            GetLastError(),
            NULL,NULL);
    }

    return(TRUE);
}


BOOL
StartSpooler(
    VOID
    )
{
#define SLEEP_TIME 4000
#define LOOP_COUNT 30
    SC_HANDLE hSC,hSCService;
    BOOL b;
    DWORD d;
    DWORD dwDesiredAccess;


    b = FALSE;
    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    d = GetLastError();

    if(hSC == NULL) {
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_STARTSVC_FAIL,
                szSpooler, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szOpenSCManager,
                d,
                NULL,NULL);
        return(FALSE);
    }

    dwDesiredAccess = SERVICE_START | SERVICE_QUERY_STATUS;
    if(hSCService = OpenService(hSC,szSpooler,dwDesiredAccess)) {
        SetupDebugPrint1( L"StartSpooler: Just opened service %s", szSpooler);
        b = StartService(hSCService,0,NULL);
        d = GetLastError();
        SetupDebugPrint3( L"StartSpooler: Just started service %s, ret=%d, error=%d", szSpooler, b, d);
        if(!b) {
            if( d  == ERROR_SERVICE_ALREADY_RUNNING) {
                //
                // Service is already running.
                //
                b = TRUE;
            } else if (d == ERROR_SERVICE_DATABASE_LOCKED) {
                LPQUERY_SERVICE_LOCK_STATUS lpqslsBuf;
                DWORD dwBytesNeeded;
                DWORD loopCount = 0;

                lpqslsBuf = (LPQUERY_SERVICE_LOCK_STATUS) MyMalloc( sizeof(QUERY_SERVICE_LOCK_STATUS)+256);
                if( lpqslsBuf) {
                    do {
                        // Lets query the lock status before we attempt to StartService
                        b = QueryServiceLockStatus( 
                                hSC,
                                lpqslsBuf,
                                sizeof(QUERY_SERVICE_LOCK_STATUS)+256,
                                &dwBytesNeeded);
                        d = GetLastError();
                        if ( !b ) {
                            // Not a critical error but log it.
                            SetupDebugPrint2( L"StartSpooler: Could Not QueryServiceLockStatus %s, Error=%d", szSpooler, d);
                        }
                        // Now retry StartService
                        b = StartService(hSCService,0,NULL);
                        d = GetLastError();
                        SetupDebugPrint5( L"StartSpooler: Start service %s, database was locked by %s, duration=%d, lockstatus=%d, error=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked, d);
                        if (!b) {
                            // Could not StartService
                            if ( loopCount++ == LOOP_COUNT) {
                                SetupDebugPrint5( L"StartSpooler: Timeout. Start service %s, database was locked by %s, duration=%d, lockstatus=%d, error=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked, d);
                                if( d  == ERROR_SERVICE_ALREADY_RUNNING) {
                                    b = TRUE;
                                } else {
                                    SetuplogError(
                                        LogSevWarning,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_STARTSVC_FAIL,
                                        szSpooler, NULL,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                                        szStartService,
                                        WAIT_TIMEOUT,
                                        szSpooler,
                                        NULL,NULL);
                                    SetuplogError(
                                        LogSevWarning,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_STARTSVC_FAIL,
                                        szSpooler, NULL,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                                        szStartService,
                                        ERROR_SERVICE_DATABASE_LOCKED,
                                        szSpooler,
                                        NULL,NULL);
                                }
                                break;
                            }
                            else {
                                SetupDebugPrint2( L"StartSpooler: Sleeping. service %s, count=%d", szSpooler, loopCount);
                                Sleep( SLEEP_TIME );
                            }
                        }
                        else {
                            // StartService succeeded this time.
                            SetupDebugPrint4( L"StartSpooler: Had to retry start service %s, database was locked by %s, duration=%d, lockstatus=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked);
                            break;
                        }
                    } while ( TRUE );
                    MyFree( lpqslsBuf);
                } else {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_STARTSVC_FAIL,
                        szSpooler, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szStartService,
                        ERROR_NOT_ENOUGH_MEMORY,
                        szSpooler,
                        NULL,NULL);
                }
            
            } else {
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_STARTSVC_FAIL,
                    szSpooler, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    szStartService,
                    d,
                    szSpooler,
                    NULL,NULL);
            }
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            szSpooler, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            szSpooler,
            NULL,NULL);
    }

    CloseServiceHandle(hSC);
    SetupDebugPrint1( L"StartSpooler: Just closed service handler %s", szSpooler);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\printupg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    printupg.c

Abstract:

    Module to upgrade printer drivers and related stuff.

    Top-level routines: UpgradePrinters

Author:

    Ted Miller (tedm) 4-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
//  Maximum time to wait for the spooler service to start
//
#define MAXIMUM_WAIT_TIME   30000

DWORD
UpgradePrinters(
    VOID
    )

/*++

Routine Description:

    Top level routine to upgrade printer drivers.

    Call out to ntprint.dll to to the upgrade.

Arguments:

    None.

Return Value:

    Win32 error code indicating outcome of operation.
    NO_ERROR if successful.

--*/

{
    DWORD ReturnCode;
    BOOL b;
    SERVICE_STATUS ServiceStatus;
    DWORD InitialTickCount;
    SC_HANDLE hSC,hService;
    HINSTANCE NtPrintLibrary;
    UPGRADEPRINTERSPROC UpgradeRoutine;


    //
    // Make sure the spooler is running.
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
    SetupDebugPrint( L"UpgradePrinters: Just opened SCManager");
    if(hSC == NULL) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenSCManager,
            ReturnCode,
            L"SC_MANAGER_CONNECT",
            NULL,NULL);
        return(ReturnCode);
    }
    hService = OpenService(hSC,L"Spooler",SERVICE_START | SERVICE_QUERY_STATUS);
    SetupDebugPrint1( L"UpgradePrinters: Just opened service spooler, ret = %d", hService);
    CloseServiceHandle(hSC);
    if(hService == NULL) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            ReturnCode,
            L"Spooler",
            NULL,NULL);
        return(ReturnCode);
    }
    if( !StartSpooler()) {
        ReturnCode = GetLastError();
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_PRINTUPG_FAILED, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_PARAM_RETURNED_WINERR,
                szStartService,
                ReturnCode,
                L"Spooler",
                NULL,NULL);
        KdPrint(("SETUP: Unable to start spooler for printer upgrade (%u)\n",ReturnCode));
        CloseServiceHandle(hService);
        return(ReturnCode);
    }

    //
    // Wait for the service to start.
    //
    InitialTickCount = GetTickCount();
    while(TRUE) {
        if(QueryServiceStatus(hService,&ServiceStatus)) {
            if( ServiceStatus.dwCurrentState == SERVICE_RUNNING ) {
                KdPrint(("SETUP: spooler started after %u seconds. \n",(GetTickCount() - InitialTickCount) /1000));
                break;
            } else if( ServiceStatus.dwCurrentState == SERVICE_START_PENDING ) {
                if( ( GetTickCount() - InitialTickCount ) < MAXIMUM_WAIT_TIME ) {
                    // KdPrint(("SETUP: spooler has been starting for the past %u seconds. \n",(GetTickCount() - InitialTickCount) /1000));
                    // Sleep( ServiceStatus.dwWaitHint );
                    Sleep( 1000 );
                } else {
                    //
                    //  Assume that the service is hung
                    //
                    KdPrint(("SETUP: the spooler appears to be hung. It has been starting for more than %u seconds. \n", MAXIMUM_WAIT_TIME/1000));
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_PRINTUPG_FAILED, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_SPOOLER_TIMEOUT, NULL,
                        NULL);
                    //
                    //  Return the same error code that EnumPrinterDrivers()
                    //  would return if called, but the spooler wasn't started
                    //
                    CloseServiceHandle(hService);
                    return(RPC_S_SERVER_UNAVAILABLE);
                }
            } else {
                //
                //  The service is not running and is not starting
                //
                KdPrint(("SETUP: Spooler is not running and is is not starting. ServiecState = (%u)\n", ServiceStatus.dwCurrentState));
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_PRINTUPG_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_SPOOLER_NOT_RUNNING, NULL,
                    NULL);
                //
                //  Return the same error code that EnumPrinterDrivers()
                //  would return if called, but the spooler wasn't started
                //
                CloseServiceHandle(hService);
                return(RPC_S_SERVER_UNAVAILABLE);
            }
        } else {
            //
            //  If unable to query the spooler status, then ignore the
            //  error, wait for some time, and assume that the service is up
            //  and running. If it is not started, then the EnumeratePrinterDrivers
            //  will fail, an we will catch the error there.
            //
            ReturnCode = GetLastError();
            KdPrint(("SETUP: Unable to query spooler status. Error = (%u)\n",ReturnCode));
            Sleep( 10000 );
            break;
        }
    }
    CloseServiceHandle(hService);

    NtPrintLibrary = LoadLibrary(L"NTPRINT");
    if(!NtPrintLibrary) {

        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            L"LoadLibrary",
            ReturnCode,
            L"NTPRINT.DLL",
            NULL,NULL);

        return(ReturnCode);
    }

    UpgradeRoutine = (UPGRADEPRINTERSPROC)GetProcAddress(
                                            NtPrintLibrary,
                                            UPGRADEPRINTERSPROCNAME
                                            );

    if(!UpgradeRoutine) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            L"GetProcAddress",
            ReturnCode,
            L"NTPRINT.DLL",
            NULL,NULL);

        FreeLibrary(NtPrintLibrary);
        return(ReturnCode);
    }


    ReturnCode = UpgradeRoutine(MainWindowHandle,&InternalSetupData);
    if(ReturnCode != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"NTPRINT.DLL",
            ReturnCode,
            NULL,NULL);
    }

    FreeLibrary(NtPrintLibrary);
    SetupDebugPrint1( L"UpgradePrinters: leaving ret = %d", ReturnCode);
    return(ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\preinst.c ===
#include "setupp.h"
#pragma hdrstop

//
// List of oem preinstall/unattend values we can fetch from profile files.
// Do NOT change the order of this without changing the order of the
// PreinstUnattendData array.
//
typedef enum {
    OemDatumBackgroundBitmap,
    OemDatumBannerText,
    OemDatumLogoBitmap,
    OemDatumMax
} OemPreinstallDatum;

//
// Define structure that represents a single bit of data read
// from a profile file relating to preinstallation.
//
typedef struct _PREINSTALL_UNATTEND_DATUM {
    //
    // Filename. If NULL, use the system answer file $winnt$.inf.
    // Otherwise this is relative to the root of the source drive.
    //
    PCWSTR Filename;

    //
    // Section name.
    //
    PCWSTR Section;

    //
    // Key name.
    //
    PCWSTR Key;

    //
    // Default value. Can be NULL but that will be translated to
    // "" when the profile API is called to retrieve the data.
    //
    PCWSTR Default;

    //
    // Where to put the actual value. The actual value may be
    // a string, or NULL.
    //
    PWSTR *Value;

    //
    // Value for sanity checking.
    //
    OemPreinstallDatum WhichValue;

} PREINSTALL_UNATTEND_DATUM, *PPREINSTALL_UNATTEND_DATUM;

//
// Name of oem background bitmap file and logo bitmap file.
// Replacement banner text.
// Read from unattend.txt
//
PWSTR OemBackgroundBitmapFile;
PWSTR OemLogoBitmapFile;
PWSTR OemBannerText;

//
// If this is non-NULL, it is a replacement bitmap
// to use for the background.
//
HBITMAP OemBackgroundBitmap;


PREINSTALL_UNATTEND_DATUM PreinstUnattendData[OemDatumMax] = {

    //
    // Background bitmap
    //
    {   NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_BACKGROUND,
        NULL,
        &OemBackgroundBitmapFile,
        OemDatumBackgroundBitmap
    },

    //
    // Banner text
    //
    {
        NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_BANNER,
        NULL,
        &OemBannerText,
        OemDatumBannerText
    },

    //
    // Logo bitmap
    //
    {
        NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_LOGO,
        NULL,
        &OemLogoBitmapFile,
        OemDatumLogoBitmap
    }
};

//
//  Path to the registry key that contains the list of preinstalled
//  drivers (SCSI, keyboard and mouse)
//

PCWSTR szPreinstallKeyName = L"SYSTEM\\Setup\\Preinstall";


//
// Forward references
//
VOID
ProcessOemBitmap(
    IN PWSTR   FilenameAndResId,
    IN SetupBm WhichOne
    );

BOOL
CleanupPreinstalledComponents(
    );



BOOL
InitializePreinstall(
    VOID
    )
{
    WCHAR Buffer[2*MAX_PATH];
    DWORD d;
    int i;

    //
    // Must be run after main initialization. We rely on stuff that is
    // set up there.
    //
    MYASSERT(AnswerFile[0]);

    //
    // Special skip-eula value.  Note that we want this value even if we're not
    // doing a Preinstall.
    //
    GetPrivateProfileString(
        WINNT_UNATTENDED,
        L"OemSkipEula",
        pwNo,
        Buffer,
        sizeof(Buffer)/sizeof(Buffer[0]),
        AnswerFile
        );

    OemSkipEula = (lstrcmpi(Buffer,pwYes) == 0);

    //
    // For the mini-setup case, always be preinstall.
    //
    if( MiniSetup ) {
        Preinstall = TRUE;
    } else {

        MYASSERT(SourcePath[0]);

        //
        // First, figure out whether this is an OEM preinstallation.
        //
        GetPrivateProfileString(
            WINNT_UNATTENDED,
            WINNT_OEMPREINSTALL,
            pwNo,
            Buffer,
            sizeof(Buffer)/sizeof(Buffer[0]),
            AnswerFile
            );

        Preinstall = (lstrcmpi(Buffer,pwYes) == 0);

        //
        // If not preinstallation, nothing more to do.
        //
        if(!Preinstall) {
            return(TRUE);
        }
    }

    //
    // OK, it's preinstsall. Fill in our data table.
    //
    for(i=0; i<OemDatumMax; i++) {

        //
        // Sanity check
        //
        MYASSERT(PreinstUnattendData[i].WhichValue == i);

        //
        // Retrieve data and duplicate. If the value comes back as ""
        // assume it means there is no value in there.
        //
        GetPrivateProfileString(
            PreinstUnattendData[i].Section,
            PreinstUnattendData[i].Key,
            PreinstUnattendData[i].Default ? PreinstUnattendData[i].Default : NULL,
            Buffer,
            sizeof(Buffer)/sizeof(Buffer[0]),
            PreinstUnattendData[i].Filename ? PreinstUnattendData[i].Filename : AnswerFile
            );

        *PreinstUnattendData[i].Value = Buffer[0] ? pSetupDuplicateString(Buffer) : NULL;
        if(Buffer[0] && (*PreinstUnattendData[i].Value == NULL)) {
            //
            // Out of memory.
            //
            pSetupOutOfMemory(MainWindowHandle);
            return(FALSE);
        }
    }

    //
    // Change the banner text, if the OEM supplied new text.
    // Make sure our product name is in there.
    //
    if(OemBannerText) {

        if(wcsstr(OemBannerText,L"Windows NT") ||
           wcsstr(OemBannerText,L"BackOffice")) {
            //
            // Substitute * with \n
            //
            for(i=0; OemBannerText[i]; i++) {
                if(OemBannerText[i] == L'*') {
                    OemBannerText[i] = L'\n';
                }
            }
#if 0
            //
            // Disable the banner for now.
            //
            SendMessage(MainWindowHandle,WM_NEWBITMAP,SetupBmBanner,(LPARAM)OemBannerText);
#endif
        } else {
            MyFree(OemBannerText);
            OemBannerText = NULL;
        }
    }

    //
    // Load the OEM background bitmap, if any.
    // Load the OEM logo bitmap, if any.
    //
    ProcessOemBitmap(OemBackgroundBitmapFile,SetupBmBackground);
    ProcessOemBitmap(OemLogoBitmapFile,SetupBmLogo);

    //
    // Repaint the main window. Specify that the background should be erased
    // because the main window relies on this behavior.
    //
    InvalidateRect(MainWindowHandle,NULL,TRUE);
    UpdateWindow(MainWindowHandle);

    CleanupPreinstalledComponents();
    return(TRUE);
}


VOID
ProcessOemBitmap(
    IN PWSTR   FilenameAndResId,
    IN SetupBm WhichOne
    )

/*++

Routine Description:

    This routine processes a single oem bitmap specification.

    The OEM bitmap may either be in a resource file or in a standalone
    bitmap file. Once the bitmap has been loaded the main window
    is told about it.

Arguments:

    FileNameAndResId - specifies a profile string with either one
        or 2 fields. If the string contains a comma, it is assumed to be
        the name of a DLL followed by a resource ID. The dll is loaded
        from the $OEM$\OEMFILES directory and then we call LoadBitmap
        with the given resource id, which is a base-10 string of ascii digits.
        The string is split at the comma during this routine.
        If this parameter does not contain a comma then it is assumed to be
        the name of a .bmp in $OEM$\OEMFILES and we load it via LoadImage().

    WhichOne - supplies a value indicating which bitmap this is.

Return Value:

    None.

--*/

{
    HINSTANCE ModuleHandle;
    PWCHAR p,q;
    HBITMAP Bitmap;
    WCHAR Buffer[MAX_PATH];
    DWORD Result;

    if(FilenameAndResId) {

        Bitmap = NULL;

        if( !MiniSetup ) {
            lstrcpy(Buffer,SourcePath);
            pSetupConcatenatePaths(Buffer,WINNT_OEM_DIR,MAX_PATH,NULL);
        } else {
            //
            // If we're doing a mini-install, look for the bmp in
            // the \sysprep directory on the drive where NT is
            // installed, not $OEM$
            //
            Result = GetWindowsDirectory( Buffer, MAX_PATH );
            if( Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            Buffer[3] = 0;
            pSetupConcatenatePaths( Buffer, TEXT("sysprep"), MAX_PATH, NULL );
        }

        if(p = wcschr(FilenameAndResId,L',')) {

            q = p;
            //
            // Skip backwards over spaces and quotes. The text setup ini file writer
            // will create a line like
            //
            //      a = "b","c"
            //
            // whose RHS comes back as
            //
            //      b","c
            //
            // since the profile APIs strip off the outermost quotes.
            //
            //
            while((q > FilenameAndResId) && ((*(q-1) == L'\"') || iswspace(*(q-1)))) {
                q--;
            }
            *q = 0;

            q = p+1;
            while(*q && ((*q == L'\"') || iswspace(*q))) {
                q++;
            }

            pSetupConcatenatePaths(Buffer,FilenameAndResId,MAX_PATH,NULL);

            if(ModuleHandle = LoadLibraryEx(Buffer,NULL,LOAD_LIBRARY_AS_DATAFILE)) {

                Bitmap = LoadBitmap(ModuleHandle,MAKEINTRESOURCE(wcstoul(q,NULL,10)));
                FreeLibrary(ModuleHandle);
            }
        } else {
            pSetupConcatenatePaths(Buffer,FilenameAndResId,MAX_PATH,NULL);

            Bitmap = (HBITMAP)LoadImage(NULL,Buffer,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
        }

        if(Bitmap) {
            //
            // Got a valid bitmap. Tell main window about it.
            //
            SendMessage(MainWindowHandle,WM_NEWBITMAP,WhichOne,(LPARAM)Bitmap);
        }
    }
}

LONG
ExaminePreinstalledComponent(
    IN  HKEY       hPreinstall,
    IN  SC_HANDLE  hSC,
    IN  PCWSTR     ServiceName
    )

/*++

Routine Description:

    Query a preinstalled component, and disable it if necessary.
    If the component is an OEM component, and is running, then disable
    any associated service, if necessary.

Arguments:

    hPreinstall - Handle to the key SYSTEM\Setup\Preinstall.

    hSC - Handle to the Service Control Manager.

    ServiceName - Name of the service to be examined.

Return Value:

    Returns a Win32 error code indicating the outcome of the operation.

--*/

{
    BOOL            OemComponent;
    HKEY            Key;
    LONG            Error;
    DWORD           cbData;
    WCHAR           Data[ MAX_PATH + 1];
    DWORD           Type;
    SC_HANDLE       hSCService;
    SERVICE_STATUS  ServiceStatus;

    //
    //  Open the key that contains the info about the preinstalled component.
    //

    Error = RegOpenKeyEx( hPreinstall,
                          ServiceName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    //  Find out if the component is an OEM or RETAIL
    //
    cbData = sizeof(Data);
    Error = RegQueryValueEx( Key,
                             L"OemComponent",
                             0,
                             &Type,
                             ( LPBYTE )Data,
                             &cbData );
    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }

    OemComponent = (*((PULONG)Data) == 1);

    if( OemComponent ) {
        //
        //  Get the name of the retail service to disable
        //
        cbData = sizeof(Data);
        Error = RegQueryValueEx( Key,
                                 L"RetailClassToDisable",
                                 0,
                                 &Type,
                                 ( LPBYTE )Data,
                                 &cbData );
        if( Error != ERROR_SUCCESS ) {
            *(( PWCHAR )Data) = '\0';
        }
    }
    RegCloseKey( Key );

    //
    //  Query the service
    //
    hSCService = OpenService( hSC,
                              ServiceName,
                              SERVICE_QUERY_STATUS );

    if( hSCService == NULL ) {
        Error = GetLastError();
        return( Error );
    }
    if( !QueryServiceStatus( hSCService,
                             &ServiceStatus ) ) {
        Error = GetLastError();
        return( Error );
    }
    CloseServiceHandle( hSCService );
    if( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) {
        //
        //  Due to the nature of the services that were pre-installed,
        //  we can assume that the service failed to initialize, and that
        //  it can be disabled.
        //
        MyChangeServiceStart( ServiceName,
                              SERVICE_DISABLED );
    } else {
        if( OemComponent &&
            ( lstrlen( (PCWSTR)Data ) != 0 ) ) {
            MyChangeServiceStart( (PCWSTR)Data,
                                  SERVICE_DISABLED );
        }
    }

    return( ERROR_SUCCESS );
}

BOOL
CleanupPreinstalledComponents(
    )

/*++

Routine Description:

    Query the preinstalled components, and disable the ones that
    failed to start.
    This is done by enumerating the subkeys of SYSTEM\Setup\Preinstall.
    Each subkey represents a SCSI, Keyboard or Mouse installed.
    The video drivers are not listed here. The "Display" applet will
    determine and disable the video drivers that were preinstalled, but
    failed to start.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    LONG            Error;
    LONG            SavedError;
    HKEY            Key;
    HKEY            SubKeyHandle;
    ULONG           i;
    ULONG           SubKeys;
    WCHAR           SubKeyName[ MAX_PATH + 1 ];
    ULONG           NameSize;
    FILETIME        LastWriteTime;
    SC_HANDLE       hSC;

    EnableEventlogPopup();
    //
    //  Find out the number of subkeys of SYSTEM\Setup\Preinstall
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPreinstallKeyName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        //
        //  If the key doesn't exist, then assume no driver to preinstall,
        //  and return TRUE.
        //
        return( Error == ERROR_FILE_NOT_FOUND );
    }

    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             &SubKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    //  If there are no subkeys, then assume no driver to preinstall
    //
    if( SubKeys == 0 ) {
        return( TRUE );
    }

    //
    //  Get a handle to the service control manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        Error = GetLastError();
        return( FALSE );
    }

    //
    //  Query each SCSI, keyboard and mouse driver that was preinstalled
    //  and disable it if necessary.
    //
    SavedError = ERROR_SUCCESS;
    for( i = 0; i < SubKeys; i++ ) {
        NameSize = sizeof( SubKeyName ) / sizeof( WCHAR );
        Error = RegEnumKeyEx( Key,
                              i,
                              SubKeyName,
                              &NameSize,
                              NULL,
                              NULL,
                              NULL,
                              &LastWriteTime );
        if( Error != ERROR_SUCCESS ) {
            if( SavedError == ERROR_SUCCESS ) {
                SavedError = Error;
            }
            continue;
        }

        Error = ExaminePreinstalledComponent( Key,
                                              hSC,
                                              SubKeyName );
        if( Error != ERROR_SUCCESS ) {
            if( SavedError == ERROR_SUCCESS ) {
                SavedError = Error;
            }
            // continue;
        }
    }
    RegCloseKey( Key );
    //
    //  At this point we can remove the Setup\Preinstall key
    //
    //  DeletePreinstallKey();
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\Setup",
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );
    if( Error == ERROR_SUCCESS ) {
        pSetupRegistryDelnode( Key, L"Preinstall" );
        RegCloseKey( Key );
    }
    return( TRUE );
}

BOOL
EnableEventlogPopup(
    VOID
    )

/*++

Routine Description:

    Delete from the registry the value entry that disables the error
    popups displayed by the eventlog, if one or more pre-installed
    driver failed to load.
    This value entry is created in the registry during textmode setup.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    HKEY    hKey = 0;
    ULONG   Error;

    //
    // Delete the 'NoPopupsOnBoot' value
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\Windows",
                          0,
                          KEY_SET_VALUE,
                          &hKey );

    if(Error == NO_ERROR) {
        Error = RegDeleteValue(hKey,
                               L"NoPopupsOnBoot");
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    return( Error == ERROR_SUCCESS );
}


BOOL
ExecutePreinstallCommands(
    VOID
    )

/*++

Routine Description:

    Executes all commands specified in the file $OEM$\OEMFILES\cmdlines.txt.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    WCHAR OldCurrentDir[MAX_PATH];
    WCHAR FileName[MAX_PATH];
    HINF CmdlinesTxtInf;
    LONG LineCount,LineNo;
    INFCONTEXT InfContext;
    PCWSTR CommandLine;
    DWORD DontCare;
    BOOL AnyError;
    PCWSTR SectionName;

    //
    // Set current directory to $OEM$.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    lstrcpy(FileName,SourcePath);
    pSetupConcatenatePaths(FileName,WINNT_OEM_DIR,MAX_PATH,NULL);
    SetCurrentDirectory(FileName);

    //
    // Form name of cmdlines.txt and see if it exists.
    //
    pSetupConcatenatePaths(FileName,WINNT_OEM_CMDLINE_LIST,MAX_PATH,NULL);
    AnyError = FALSE;
    if(FileExists(FileName,NULL)) {

        CmdlinesTxtInf = SetupOpenInfFile(FileName,NULL,INF_STYLE_OLDNT,NULL);
        if(CmdlinesTxtInf == INVALID_HANDLE_VALUE) {
            //
            // The file exists but is invalid.
            //
            AnyError = TRUE;
        } else {
            //
            // Get the number of lines in the section that contains the commands to
            // be executed. The section may be empty or non-existant; this is not
            // an error condition. In that case LineCount may be -1 or 0.
            //
            SectionName = L"Commands";
            LineCount = SetupGetLineCount(CmdlinesTxtInf,SectionName);

            for(LineNo=0; LineNo<LineCount; LineNo++) {

                if(SetupGetLineByIndex(CmdlinesTxtInf,SectionName,(DWORD)LineNo,&InfContext)
                && (CommandLine = pSetupGetField(&InfContext,1))) {
                    if(!InvokeExternalApplication(NULL,CommandLine,&DontCare)) {
                        AnyError = TRUE;
                    }
                } else {
                    //
                    // Strange case, inf is messed up
                    //
                    AnyError = TRUE;
                }
            }
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        SetCurrentDirectory(OldCurrentDir);
    }

    if(AnyError) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OEMPRE_FAIL,
            NULL,NULL);
    }

    return(!AnyError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#include "..\inc\cmnres.h"

#define IDS_TITLE_INSTALL_W             1
#define IDS_TITLE_INSTALL_S             2
#define IDS_TITLE_UPGRADE_W             3
#define IDS_TITLE_UPGRADE_S             4
#define IDS_ERROR                       5
#define IDS_UNKNOWN                     6
#define IDS_FATALERROR                  7
#define IDS_DEFWALLPAPER                8
#define IDS_SETUP                       9
#define IDS_WINNT_SETUP                 10
#define IDS_DISPLAYAPPLET               11
#define IDS_ADMINISTRATOR               12
#define IDS_GUEST                       13
#define IDS_LOCAL_PORT                  14
#define IDS_MSSERIF                     15
#define IDS_LARGEFONTSIZE               16
#define IDS_LOGSEV                      17
#define IDS_LOGSEVINFO                  18
#define IDS_LOGSEVWARN                  19
#define IDS_LOGSEVERR                   20
#define IDS_LOGSEVFATAL                 21
#define IDS_MB                          22
#define IDS_INSTALLED                   23
#define IDS_HAVEDISKCAPTION             24
#define IDS_SPECIALOC_TEXT              25
#define IDS_STEPS                       26
#define IDS_STEPS_UPGRADE               27
#define IDS_FILE_PRINT_LIC_NAME         28
#define IDS_FILE_PRINT_LIC_FAMILY_NAME  29
#define IDS_LIC_SERV_DISPLAY_NAME       30
#define IDS_LOG_DEFAULT_HEADING         31
#define IDS_LOG_WINDOW_HEADING          32
#define IDS_NEWDEVFOUND_WAIT            33
#define IDS_NEWDEVFOUND_NOAUTO          34
#define IDS_NEWDEVFOUND_NOTADMIN        35
#define IDS_DEVNAME_UNK                 36
#define IDS_SEARCHING                   37
#define IDS_NEWDEVFOUND_CAPTION         38
#define IDS_CONFIRM_DEVINSTALL          39
#define IDS_DEVINSTALL_ERROR            40
#define IDS_SVCDISPLAY_TO_FRIENDLYNAME  41
#define IDS_SVCNAME_TO_FRIENDLYNAME     42
#define IDS_PROGRAM_FILES_DIRECTORY     43
#define IDS_COMMON_FILES_DIRECTORY      44
#define IDS_NODRIVER                    45
#define IDS_NETADAPTER_PROMPT1          46
#define IDS_NETADAPTER_PROMPT2          47
#define IDS_NETADAPTER_CAPTION          48
#define IDD_WELCOME                     49
#define IDS_KBDLAYOUT_MSG               49
#define IDD_LAST_WIZARD_PAGE            50
#define IDS_KBDLAYOUT_MSG2              50
#define IDD_STEPS1                      51
#define IDS_LOCALE_MSG                  51
#define IDD_EULA                        52
#define IDD_NAMEORG                     53
#define IDS_UNKNOWN_PARENS              53
#define IDD_COMPUTERNAME                54
#define IDS_PREPARING_INSTALL           54
#define IDS_SETUP_MODE                  55
#define IDD_USERACCOUNT                 56
#define IDS_REGIONAL_SETTINGS           56
#define IDD_PID                         57
#define IDS_REGIONAL_SETTINGS_SUB       57
#define IDD_PID_CD                      58
#define IDS_PREPARING_INSTALL_SUB       58
#define IDD_PID_OEM                     59
#define IDS_SETUP_MODE_SUB              59
#define IDD_ADMINPASSWORD               60
#define IDS_NAMEORG                     60
#define IDD_REPAIRDISK                  61
#define IDS_NAMEORG_SUB                 61
#define IDD_BILLBOARD1                  62
#define IDS_PID                         62
#define IDD_DONE_SUCCESS                63
#define IDS_PID_SUB                     63
#define IDD_WELCOMEBUTTONS              64
#define IDS_COMPUTERNAME                64
#define IDD_OPTIONS_YESNO               65
#define IDS_COMPUTERNAME_SUB            65
#define IDD_OPTIONS                     66
#define IDD_OPTIONS2                    67
#define IDD_OPTIONS_DETAILS_SETUP       68
#define IDS_ADMINPW                     68
#define IDD_OPTIONS_DETAILS             69
#define IDS_ADMINPW_SUB                 69
#define IDD_CPL_HAVEDISK                70
#define IDS_FPERRATA                    70
#define IDD_SPECIAL_OPTIONS             71
#define IDS_FPERRATA_SUB                71
#define IDD_PREPARING                   72
#define IDS_REPAIRDISK                  72
#define IDD_ACLPROGRESS                 73
#define IDS_REPAIRDISK_SUB              73
#define IDD_VIEWLOG                     74
#define IDS_OPTIONALCOMP                74
#define IDD_CAIRODOMAINNAME             75
#define IDS_OPTIONALCOMP_SUB            75
#define IDD_CAIROUSERACCOUNT            76
#define IDS_ACCESS_UTIL                 76
#define IDD_PENTIUM                     77
#define IDS_WORKSTATION_WELCOME_1       77
#define IDD_SELECTCLASS                 78
#define IDS_WORKSTATION_WELCOME_2       78
#define IDD_HELP                        79
#define IDS_SERVER_WELCOME_1            79
#define IDS_SERVER_WELCOME_2            80
#define IDI_SETUP                       81
#define IDS_OEM                         81
#define IDI_CUSTOM                      82
#define IDS_OEM_SUB                     82
#define IDI_COMPACT                     83
#define IDS_WELCOME_FONT_NAME           83
#define IDI_TYPICAL                     84
#define IDS_WELCOME_FONT_SIZE           84
#define IDI_PORTABLE                    85
#define IDS_EULA                        85
#define IDI_MSN                         86
#define IDS_EULA_SUB                    86
#define IDI_EXCHANGE                    87
#define IDS_COPYFILES                   87
#define IDI_FAX                         88
#define IDS_COPYFILES_SUB2              88
#define IDI_SAFE                        89
#define IDS_COPYFILES_SUB1              89
#define IDI_NEWDEVICEICON               90
#define IDS_PROGRAM_FILES_DIRECTORY_WX86 90
#define IDI_CTAPE                       91
#define IDS_USERNAME                    91
#define IDB_WELCOME                     92
#define IDS_USERNAME_SUB                92
#define IDB_WIZARD1                     93
#define IDS_ASR                         93
#define IDB_REBOOT                      94
#define IDS_ASR_SUB                     94
#define IDB_BACKGROUND                  95
#define IDD_REGIONAL_SETTINGS           96
#define IDD_LOCALE                      97
#define IDD_HARDWARE                    98
#define IDS_MAINTOBS_MSG1               99
#define IDS_SAFEMODENOTALLOWED          100
#define IDI_CDDRIVE                     101
#define IDI_FLPDRIVE                    102
#define IDT_COMPONENTS                  102
#define IDB_ARROW                       102
#define IDT_INSTRUCTIONS                103
#define IDD_OCM_WIZARD_PAGE             103
#define IDB_CHECK                       103
#define IDI_GLOBE                       103
#define IDD_OCM_PROGRESS_PAGE           104
#define IDT_SPACE_NEEDED_NUM            105
#define IDD_OCM_DETAILS                 105
#define IDA_FILECOPY                    105
#define IDB_OEM                         105
#define IDT_SPACE_AVAIL_NUM             106
#define IDB_CDKEY                       106
#define IDD_COPYFILES                   106
#define IDT_TIP                         107
#define IDD_COPYFILES2                  107
#define IDD_WELCOME2                    108
#define IDD_WELCOME3                    109
#define IDD_LAST_WIZARD_PAGE2           110
#define IDB_HEADER                      113
#define IDD_COPYFILES3                  114
#define IDD_LAST_WIZARD_PAGE3           115
#define IDD_COMPUTERNAME2               117
#define IDD_ADMINPASSWORD2              118
#define IDD_SETUPINIT                   119
#define IDD_SETUPINIT_ASR               120
#define IDA_SETUPINIT                   122
#define IDB_BITMAP1                     124
#define IDI_ADMIN                       125
#define IDB_SETUPINIT                   125
#define IDB_INIT_WORKSTATION            125
#define IDI_COMPUTER                    126
#define IDD_COPYFILES4                  126
#define IDI_NAME                        127
#define IDB_INIT_SERVER                 128
#define IDI_SCROLL                      131
#define IDB_BACKGROUND_SERVER           132
#define IDB_BACKGROUND_WORKSTATION      133
#define IDD_PREPARING2                  134
#define IDT_LOCALE                      201
#define IDT_KBD_LAYOUT                  202
#define IDS_OCPAGE_HEADER               203
#define IDS_OCPAGE_SUBHEAD              204
#define IDS_PROGPAGE_HEADER             205
#define IDS_PROGPAGE_SUBHEAD            206
#define IDD_PROP_PAGE_PS2_MOUSE         207
#define IDD_PID_SELECT                  208
#define IDS_SELECT                      209
#define IDS_SELECT_SUB                  210
#define IDT_NAME                        1000
#define IDT_ORGANIZATION                1001
#define IDB_DETAILS                     1001
#define IDT_RICHEDIT1                   1002
#define IDB_BUTTON_1                    1003
#define IDB_BUTTON_2                    1004
#define IDB_BUTTON_3                    1005
#define IDB_BUTTON_4                    1006
#define IDC_LISTBOX                     1006
#define IDB_RADIO_1                     1007
#define IDB_RADIO_2                     1008
#define IDB_RADIO_3                     1009
#define IDC_PROGRESS                    1009
#define IDC_RADIO_1                     1010
#define IDA_EXTERNAL_PROGRAM            1010
#define IDC_RADIO_2                     1011
#define IDT_EDIT1                       1012
#define IDT_EDIT2                       1013
#define IDT_EDIT3                       1014
#define IDT_COMP_TITLE                  1014
#define IDT_EDIT4                       1015
#define IDT_THERM_LABEL                 1015
#define IDT_STATIC                      1016
#define IDT_STATIC_1                    1017
#define IDT_STATIC_2                    1018
#define IDT_STATIC_3                    1019
#define IDT_STATIC_4                    1020
#define IDT_STATIC_5                    1021
#define IDT_STATIC_6                    1022
#define IDT_STATIC4                     1023
#define IDC_GROUP1                      1024
#define IDC_ICON1                       1025
#define IDC_TYPICAL                     1026
#define IDC_PORTABLE                    1027
#define IDC_COMPACT                     1028
#define IDC_CUSTOM                      1029
#define IDT_EDIT_PID1                   1030
#define IDT_EDIT_PID2                   1031
#define IDT_EDIT_PID3                   1032
#define IDT_EDIT_PID4                   1033
#define IDC_LIST1                       1033
#define IDT_EDIT_PID5                   1034
#define IDT_INSTALLED                   1034
#define IDC_MSN                         1035
#define IDC_EXCHANGE                    1036
#define IDC_FAX                         1037
#define IDC_MSN_SPACE                   1038
#define IDC_EXCHANGE_SPACE              1039
#define IDC_FAX_SPACE                   1040
#define IDC_PROGRESS1                   1041
#define IDC_PROGRESS2                   1042
#define IDC_NEWDEV_DESCRIPTION          1043
#define IDC_NEWDEV_INSTRUCTIONS         1044
#define IDC_NEWDEV_DEFAULTDRV           1045
#define IDC_NEWDEV_OEMDRV               1046
#define IDC_NEWDEV_NODRV                1047
#define IDC_NEWDEV_SELECTDRV            1048
#define IDC_NEWDEV_CLASSICON            1049
#define IDC_NDW_TEXT                    1050
#define IDC_NDW_PICKCLASS_HWTYPES       1051
#define IDC_NDW_PICKCLASS_CLASSLIST     1052
#define IDB_CHANGE_LOCALE               1053
#define IDB_CHANGE_KBD_LAYOUT           1054
#define IDB_KBDLAYOUT                   1055
#define IDB_LOCALE                      1056
#define IDC_COPY_BMP                    1058
#define IDC_CONFIGURE_BMP               1059
#define IDC_SAVE_BMP                    1060
#define IDC_REMOVE_BMP                  1061
#define IDC_COPY_TXT                    1062
#define IDC_CONFIGURE_TXT               1063
#define IDC_SAVE_TXT                    1064
#define IDC_REMOVE_TXT                  1065
#define IDC_COPY_BMP2                   1066
#define IDC_EDIT1                       1070
#define IDC_EDIT2                       1071
#define IDC_ANIMATE1                    1074
#define IDC_PREPARETEXT                 1075
#define IDC_SAMPLE_RATE                 1076
#define IDC_SAMPLE_RATE_SPIN            1077
#define IDC_BUFFER                      1078
#define IDC_BUFFER_SPIN                 1079
#define IDC_WHEEL_DETECTION             1080
#define IDC_DEFAULT                     1081
#define IDC_FAST_INIT                   1082
#define IDC_BITMAP                      1083
#define IDD_PREPARING_ASR               1084
#define IDC_UPGRADE_TXT                 1084
#define IDD_LAST_ASR_PAGE               1085
#define IDC_UPGRADE_BMP                 1085
#define IDD_PROP_LEGACY_SERVICE         1086
#define IDC_STATIC_SERVICE_NAME         1087
#define IDC_STATIC_DISPLAY_NAME         1088
#define IDC_EDIT_DISPLAY_NAME           1089
#define IDC_EDIT_SERVICE_NAME           1091
#define IDC_GROUP_CURRENT_STATUS        1092
#define IDC_STATIC_CURRENT_STATUS_STATIC 1093
#define IDC_STATIC_CURRENT_STATUS       1094
#define IDC_BUTTON_START                1095
#define IDC_BUTTON_STOP                 1096
#define IDC_GROUP_STARTUP_TYPE          1097
#define IDC_STATIC_STARTUP_TYPE         1098
#define IDC_COMBO_STARTUP_TYPE          1099
#define IDC_PROP_LEGACY_ICON            1100
#define IDC_PROP_LEGACY_DESC            1101
#define IDS_SERVICE_STARTUP_AUTOMATIC   1102
#define IDS_SERVICE_STARTUP_BOOT        1103
#define IDS_SERVICE_STARTUP_DEMAND      1104
#define IDS_SERVICE_STARTUP_SYSTEM      1105
#define IDS_SERVICE_STARTUP_DISABLED    1106
#define IDC_LEGACY_DETAILS              1109
#define IDD_DRIVERFILES                 1110
#define IDC_DRIVERFILES_FILELIST        1111
#define IDC_DRIVERFILES_PROVIDER        1112
#define IDC_DRIVERFILES_VERSION         1113
#define IDC_DRIVERFILES_COPYRIGHT       1114
#define IDC_DRIVERFILES_ICON            1115
#define IDC_DRIVERFILES_DESC            1116
#define IDC_DRIVERFILES_FILES           1117
#define IDC_DRIVERFILES_TITLE_PROVIDER  1118
#define IDC_DRIVERFILES_TITLE_VERSION   1119
#define IDC_DRIVERFILES_TITLE_COPYRIGHT 1120
#define IDD_PCIHAL_PROPPAGE             1121
#define IDC_PCIHAL_ICON                 1122
#define IDC_PCIHAL_DEVDESC              1123
#define IDC_PCIHAL_ENABLE               1124
#define IDC_PCIHAL_MSSPEC               1125
#define IDC_PCIHAL_REALMODE             1126
#define IDC_PCIHAL_SETDEFAULTS          1127
#define IDC_PCIHAL_RESULTS              1128
#define IDS_PCIHAL_ERROR                1129
#define IDS_PCIHAL_ENABLED              1130
#define IDS_PCIHAL_DISABLED             1131
#define IDS_PCIHAL_NOSTATUS             1132
#define IDS_PCIHAL_TABLE_ERROR          1133
#define IDS_PCIHAL_TABLE_NONE           1134
#define IDS_PCIHAL_TABLE_REGISTRY       1135
#define IDS_PCIHAL_TABLE_MSSPEC         1136
#define IDS_PCIHAL_TABLE_REALMODE       1137
#define IDS_PCIHAL_TABLE_BAD            1138
#define IDS_PCIHAL_TABLE_SUCCESS        1139
#define IDS_PCIHAL_MINIPORT_ERROR       1140
#define IDS_PCIHAL_MINIPORT_NORMAL      1141
#define IDS_PCIHAL_MINIPORT_COMPATIBLE  1142
#define IDS_PCIHAL_MINIPORT_OVERRIDE    1143
#define IDS_PCIHAL_MINIPORT_NONE        1144
#define IDS_PCIHAL_MINIPORT_NOKEY       1145
#define IDS_PCIHAL_MINIPORT_SUCCESS     1146
#define IDS_PCIHAL_MINIPORT_INVALID     1147
#define IDS_FAIL_INPUT_WHQL_REQS        1148
#define IDS_FAIL_INPUT_WHQL_REQS_AVERTED 1149
#define IDS_FAIL_INPUT_WHQL_REQS_NO_ALT 1150
#define IDS_PS2_DETECTION_DISABLED      1151
#define IDS_PS2_DETECTION_LOOK          1152
#define IDS_PS2_DETECTION_ASSUME_PRESENT 1153
#define IDS_SVC_STATUS_STARTED          1154
#define IDS_SVC_STATUS_STOPPED          1155
#define IDS_SVC_STATUS_PAUSED           1156
#define IDS_SVC_STATUS_STARTING         1157
#define IDS_SVC_STATUS_STOPPING         1158
#define IDS_SVC_STATUS_PAUSING          1159
#define IDS_SVC_STATUS_RESUMING         1160
#define IDS_SVC_STATUS_UNKNOWN          1161
#define IDS_SVC_START_ERROR             1162
#define IDS_SVC_STOP_ERROR              1163
#define IDS_BB_COPY_TXT                 1164
#define IDS_BB_CONFIGURE                1165
#define IDS_BB_UPGRADE                  1166
#define IDC_ASR_PNP_TXT                 1167
#define IDS_BB_SAVE                     1168
#define IDC_ASR_EXTERN_TXT              1169
#define IDS_BB_REMOVE                   1170
#define IDC_ASR_PNP_BMP                 1171
#define IDC_ASR_EXTERN_BMP              1172
#define IDS_ASR_ERROR_UNABLE_TO_LAUNCH_APP      1173
#define IDS_ASR_ERROR_RECOVERY_APP_FAILED       1174
#define IDS_ASR_ERROR_UNABLE_TO_OPEN_SCM        1175
#define IDS_ASR_ERROR_UNABLE_TO_START_SERVICE   1176
#define IDS_BB_INSTALLING_DEVICES       1177
#define IDS_TIMEESTIMATE_UNKNOWN        1178
#define IDS_TIMEESTIMATE_MINUTES        1179
#define IDS_TIMEESTIMATE_LESSTHENONEMINUTE 1180
#define IDS_OWNER                       1181
#define IDS_TITLE_INSTALL_P             1182
#define IDS_TITLE_UPGRADE_P             1183
#define IDS_EMPTY_STRING                1184
#define IDD_SERVICE_STOP_DEPENDENCIES   1190
#define IDC_ICON_WARN_SERVICES          1192
#define IDC_LIST_SERVICES               1193
#define IDS_COMPUTERNAME2               1194
#define IDS_COMPUTERNAME2_SUB           1195
#define IDS_DS_STARTUP                  1196
#define IDS_SAC_GUI_MODE_DEBUG_NAME             1200
#define IDS_SAC_GUI_MODE_DEBUG_DESCRIPTION      1201
#define IDS_SAC_GUI_MODE_ACTION_LOG_NAME        1202
#define IDS_SAC_GUI_MODE_ACTION_LOG_DESCRIPTION 1203
#define IDS_SAC_GUI_MODE_ERROR_LOG_NAME         1204
#define IDS_SAC_GUI_MODE_ERROR_LOG_DESCRIPTION  1205
#define IDD_NOPASSWORD                  1210
#define IDD_WEAKPASSWORD                1211
#define IDS_WEAKPASSWORD_MSG1           1212
#define IDC_WEAK_MSG1                   1213
#define IDC_WARNING                     1214
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\registry.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Routines for manupilating the configuration registry.

    Entry points:

        SaveHive
        SetEnvironmentVariableInRegistry

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#ifdef _WIN64
#include <shlwapi.h>
#endif

//
// Names of frequently used keys, values.
//
PCWSTR ControlKeyName = L"SYSTEM\\CurrentControlSet\\Control";
PCWSTR SessionManagerKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager";
PCWSTR EnvironmentKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment";
PCWSTR WinntSoftwareKeyName = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
PCWSTR MemoryManagementKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
PCWSTR WindowsCurrentVersionKeyName = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion";
PCWSTR IEProductVersionKeyName = L"Software\\Microsoft\\Internet Explorer\\Registration";

PCWSTR szBootExecute = L"BootExecute";
PCWSTR szRegisteredProcessors = L"RegisteredProcessors";
PCWSTR szLicensedProcessors = L"LicensedProcessors";
PCWSTR szRegisteredOwner = L"RegisteredOwner";
PCWSTR szRegisteredOrganization = L"RegisteredOrganization";
PCWSTR szCurrentProductId = L"CurrentProductId";

//
// Logging constants used only in this module.
//
PCWSTR szRegSaveKey = L"RegSaveKey";

//
// Number of processors to enable in server case.
//
#define SERVER_PROCESSOR_LICENSE (2)



//
// Table telling us the info needed in order to save and
// replace the system hives at the end of setup.
//
struct {
    //
    // Key and subkey that is at the root of the hive.
    //
    HKEY RootKey;
    PCWSTR Subkey;

    //
    // Name active hive has in the config directory.
    //
    PCWSTR Hive;

    //
    // Name to use for new hive file, that will be the hive
    // at next boot.
    //
    PCWSTR NewHive;

    //
    // Name to use for current hive file, that will be deleted
    // on next boot.
    //
    PCWSTR DeleteHive;

} HiveTable[3] = {

    //
    // System hive.
    //
    { HKEY_LOCAL_MACHINE, L"SYSTEM"  , L"SYSTEM"  , L"SYS$$$$$.$$$", L"SYS$$$$$.DEL" },

    //
    // Software hive
    //
    { HKEY_LOCAL_MACHINE, L"SOFTWARE", L"SOFTWARE", L"SOF$$$$$.$$$", L"SOF$$$$$.DEL" },

    //
    // Default user hive
    //
    { HKEY_USERS        , L".DEFAULT", L"DEFAULT" , L"DEF$$$$$.$$$", L"DEF$$$$$.DEL" }
};




BOOL
SaveHive(
    IN HKEY   RootKey,
    IN PCWSTR Subkey,
    IN PCWSTR Filename,
    IN DWORD  Format
    )

/*++

Routine Description:

    Save a hive into a disk file.

Arguments:

    RootKey - supplies root key for hive to be saved, ie,
        HKEY_LOCAL_MACHINE or HKEY_USERS

    Subkey - supplies name of subkey for hive to be saved, such as
        SYSTEM, SOFTWARE, or .DEFAULT.

    Filename - supplies the name of the file to be created. If it exists
        it is overwritten.

Return Value:

    Boolean value indicating outcome.

--*/

{
    LONG rc;
    HKEY hkey;
    BOOL b;

    b = FALSE;

    //
    // Open the key.
    //
    rc = RegOpenKeyEx(RootKey,Subkey,0,KEY_READ,&hkey);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SAVEHIVE_FAIL,
            Subkey,
            Filename, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            NULL,NULL);
        goto err1;
    }

    //
    // Delete the file if it's there.
    //
    if(FileExists(Filename,NULL)) {
        SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Filename);
    }

    //
    // Enable backup privilege. Ignore any error.
    //
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    //
    // Do the save.
    //
    rc = RegSaveKeyEx(hkey,Filename,NULL,Format);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SAVEHIVE_FAIL,
            Subkey,
            Filename, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szRegSaveKey,
            rc,
            NULL,NULL);
        goto err2;
    }

    b = TRUE;

err2:
    RegCloseKey(hkey);
err1:
    return(b);
}


BOOL
SetEnvironmentVariableInRegistry(
    IN PCWSTR Name,
    IN PCWSTR Value,
    IN BOOL   SystemWide
    )
{
    HKEY hKey,hRootKey;
    PCWSTR Subkey;
    DWORD dwDisp;
    LONG rc;
    BOOL b;

    b = FALSE;

    //
    // Check if the caller wants to modify a system environment variable
    // or a user environment variable. Accordingly find out the right
    // place in the registry to look.
    //
    if(SystemWide) {
        hRootKey = HKEY_LOCAL_MACHINE;
        Subkey = EnvironmentKeyName;
    } else {
        hRootKey = HKEY_CURRENT_USER;
        Subkey = L"Environment";
    }

    //
    // Open the environment variable key.
    //
    rc = RegCreateKeyEx(hRootKey,Subkey,0,NULL,REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,NULL,&hKey,&dwDisp);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETENV_FAIL,
            Name, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            Subkey,
            NULL,NULL);
        goto err0;
    }

    //
    // Write the value given.
    //
    rc = RegSetValueEx(
            hKey,
            Name,
            0,
            REG_EXPAND_SZ,
            (PBYTE)Value,
            (lstrlen(Value)+1)*sizeof(WCHAR)
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETENV_FAIL,
            Name, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegSetValueEx,
            rc,
            Subkey,
            NULL,NULL);
        goto err1;
    }

    //
    // Send a WM_WININICHANGE message so that progman picks up the new
    // variable
    //
    SendMessageTimeout(
        (HWND)-1,
        WM_WININICHANGE,
        0L,
        (LPARAM)"Environment",
        SMTO_ABORTIFHUNG,
        1000,
        NULL
        );

    b = TRUE;

err1:
    RegCloseKey(hKey);
err0:
    return(b);
}

#ifdef _WIN64

typedef struct _SUBST_STRING {
    BOOL  ExpandEnvironmentVars;
    PTSTR InputString;
    PTSTR ExclusionString;
    PTSTR OutputString;
    PTSTR SourceInputString;
    PTSTR SourceExclusionString;
    PTSTR SourceOutputString;
} SUBST_STRING,*PSUBST_STRING;


//
// note that WOW64 does file system redirection of system32, but it does NOT do
// redirection of program files, etc.  So we must substitute in the 32 bit
// environment variables in those cases where WOW64 does not do it for us
// automatically
//
SUBST_STRING StringArray[] = {
    //
    // order of these 2 is important!
    //
    { FALSE,
      NULL,
      NULL,
      NULL,
      TEXT("%CommonProgramFiles%"),
      TEXT("%CommonProgramFiles(x86)%"),
      TEXT("%CommonProgramFiles(x86)%")
    },

    { FALSE,
      NULL,
      NULL,
      NULL,
      TEXT("%ProgramFiles%"),
      TEXT("%ProgramFiles(x86)%"),
      TEXT("%ProgramFiles(x86)%")
    },

    { TRUE,
      NULL,
      NULL,
      NULL,
      TEXT("%CommonProgramFiles%"),
      TEXT("%CommonProgramFiles(x86)%"),
      TEXT("%CommonProgramFiles(x86)%")
    },

    { TRUE,
      NULL,
      NULL,
      NULL,
      TEXT("%ProgramFiles%"),
      TEXT("%ProgramFiles(x86)%"),
      TEXT("%ProgramFiles(x86)%")
    }

} ;


BOOL
pDoWow64SubstitutionHelper(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine filters and outputs the input line.  It looks for a string
    pattern that matches one of a known list of strings, and replaces the
    known string with a substitution string.

Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/

{
    WCHAR ScratchBuffer[MAX_PATH];


    DWORD i;
    PTSTR p,q;
    TCHAR c;

    for (i = 0; i< sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
        if (!StrStrI(String,StringArray[i].ExclusionString) &&
            (p = StrStrI(String,StringArray[i].InputString))) {
            //
            // if we found a hit, then find the end of the string
            // and concatenate that to our source string, which gives
            // the resultant string with substitutions.
            //
            q = p + wcslen(StringArray[i].InputString);
            c = *p;
            *p = TEXT('\0');
            wcscpy(ScratchBuffer,String);
            *p = c;
            wcscat(ScratchBuffer,StringArray[i].OutputString);
            wcscat(ScratchBuffer,q);
            wcscpy(String,ScratchBuffer);
            //
            // recursively call in case there are more strings.
            //
            pDoWow64SubstitutionHelper(String);
            break;
        }
    }

    return(TRUE);
}


BOOL
pDoWow64Substitution(
    IN PCWSTR InputString,
    OUT PWSTR  OutputString
    )
{
    DWORD i;
    WCHAR Buffer[MAX_PATH];
    BOOL RetVal;

    //
    // set up our global array of substitution strings
    //
    for (i = 0; i<sizeof(StringArray) / sizeof(SUBST_STRING);i++) {
        if (StringArray[i].ExpandEnvironmentVars) {
            ExpandEnvironmentStrings(
                        StringArray[i].SourceInputString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].InputString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].InputString) {
                RetVal = FALSE;
                goto exit;
            }

            ExpandEnvironmentStrings(
                        StringArray[i].SourceExclusionString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].ExclusionString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].ExclusionString) {
                RetVal = FALSE;
                goto exit;
            }

            ExpandEnvironmentStrings(
                        StringArray[i].SourceOutputString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].OutputString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].OutputString) {
                RetVal = FALSE;
                goto exit;
            }

        } else {
            StringArray[i].InputString = pSetupDuplicateString(StringArray[i].SourceInputString);
            if (!StringArray[i].InputString) {
                RetVal = FALSE;
                goto exit;
            }

            StringArray[i].ExclusionString = pSetupDuplicateString(StringArray[i].SourceExclusionString);
            if (!StringArray[i].ExclusionString) {
                RetVal = FALSE;
                goto exit;
            }

            StringArray[i].OutputString = pSetupDuplicateString(StringArray[i].SourceOutputString);
            if (!StringArray[i].OutputString) {
                RetVal = FALSE;
                goto exit;
            }
        }
    }

    //
    // do the recursive inplace substition
    //
    wcscpy(OutputString, InputString);
    RetVal = pDoWow64SubstitutionHelper( OutputString );

    //
    // clean up our global array of substitution strings
    //
exit:
    for (i = 0; i<sizeof(StringArray)/sizeof(SUBST_STRING);i++) {
        if (StringArray[i].InputString) {
            MyFree(StringArray[i].InputString);
            StringArray[i].InputString = NULL;
        }

        if (StringArray[i].ExclusionString) {
            MyFree(StringArray[i].ExclusionString);
            StringArray[i].ExclusionString = NULL;
        }

        if (StringArray[i].OutputString) {
            MyFree(StringArray[i].OutputString);
            StringArray[i].OutputString = NULL;
        }
    }

    return(RetVal);


}

PWSTR
pMungeDataForWow64(
    IN DWORD DataType,
    IN PCWSTR Data,
    IN DWORD DataSize,
    OUT PDWORD NewSize
    )
/*++

Routine Description:

    This routine patches an in string for wow64 so that it is in proper format
    for 32 bit programs.

    This involves looking for strings that are different on 64 bits and 32 bits
    and substituting the 32 bit equivalent for the 64 bit entry.

Arguments:

    DataType - REG_XXX constant describing the data.  we only support strings
               types
    Data - pointer to the data to be munged

    DataSize - size of the data to be converted in bytes

    NewSize - size of the new string in bytes

Return Value:

    A pointer to the converted data string on success, and NULL on failure.

--*/
{
    PWSTR pNewData,q;
    PCWSTR p;
    DWORD ScratchSize;

    switch (DataType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            //
            // just allocate twice the original size, and that should be plenty of
            // room.
            //
            pNewData = MyMalloc(DataSize * 2);
            if (!pNewData) {
                goto exit;
            }

            pDoWow64Substitution(Data,pNewData);

            *NewSize = sizeof(WCHAR)*(wcslen(pNewData) +1);

            break;
        case REG_MULTI_SZ:
            //
            // just allocate twice the original size, and that should be plenty of
            // room.
            //
            pNewData = MyMalloc(DataSize * 2);
            if (!pNewData) {
                goto exit;
            }

            RtlZeroMemory(pNewData,DataSize * 2);
            p = Data;
            q = pNewData;
            ScratchSize = 1; // for the double-null terminator
            while (p) {

                pDoWow64Substitution(p,q);

                ScratchSize += wcslen(q) + 1;
                p += wcslen(p) + 1;
                q += wcslen(q) + 1;

            }

            *NewSize = ScratchSize * sizeof(WCHAR);
            break;
        default:
            MYASSERT(FALSE && "invalid data type in pMungeDataForWow64");
            pNewData = NULL;
            break;
    }

exit:
    return(pNewData);
}


UINT
SetGroupOfValues_32(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    DWORD ActionTaken;
    UINT RememberedRc;
    WCHAR String[MAX_PATH];

    wcscpy(String,SubkeyName);
    for (i = 0; i< wcslen(String); i++) {
        CharUpper(&String[i]);
    }

    //
    // only write registry stuff under HKLM\software
    //
    if ((RootKey != HKEY_LOCAL_MACHINE) ||
        (NULL == StrStrI(String,L"SOFTWARE\\"))) {
        SetupDebugPrint2(
            L"Setup: skipping creation of 32 bit registry key for data under %x \\ %s \n",
            RootKey,
            SubkeyName );
        return(ERROR_SUCCESS);
    }

    //
    // Open/create the key first.
    //
    rc = RegCreateKeyEx(
            RootKey,
            SubkeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_WOW64_32KEY | KEY_SET_VALUE,
            NULL,
            &hkey,
            &ActionTaken
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REGKEY_FAIL,
            SubkeyName, NULL,
            SETUPLOG_USE_MESSAGEID,
            rc, NULL, NULL
            );
        return(rc);
    }

    RememberedRc = NO_ERROR;
    //
    // Set all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {
        PWSTR NewData = NULL,OldData = NULL;
        DWORD OldSize, NewSize;

        if (ValueList[i].Type == REG_SZ ||
            ValueList[i].Type == REG_EXPAND_SZ ||
            ValueList[i].Type == REG_MULTI_SZ) {
            OldData = ValueList[i].Data;
            OldSize = ValueList[i].Size;
            NewData = pMungeDataForWow64(
                                ValueList[i].Type,
                                ValueList[i].Data,
                                ValueList[i].Size,
                                &NewSize
                                );

            if (NewData) {
                ValueList[i].Data = (PVOID)NewData;
                ValueList[i].Size = NewSize;
            }
        }

        rc = RegSetValueEx(
                hkey,
                ValueList[i].Name,
                0,
                ValueList[i].Type,
                (CONST BYTE *)ValueList[i].Data,
                ValueList[i].Size
                );

        if (NewData) {
            MyFree(NewData);
            ValueList[i].Data = (PVOID)OldData;
            ValueList[i].Size = OldSize;
        }

        if(rc != NO_ERROR) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_REGVALUE_FAIL,
                SubkeyName,
                ValueList[i].Name, NULL,
                SETUPLOG_USE_MESSAGEID,
                rc, NULL, NULL
                );
            RememberedRc = rc;
        }
    }

    RegCloseKey(hkey);
    return(RememberedRc);
}

#endif

UINT
SetGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    DWORD ActionTaken;
    UINT RememberedRc;

    //
    // Open/create the key first.
    //
    rc = RegCreateKeyEx(
            RootKey,
            SubkeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &ActionTaken
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REGKEY_FAIL,
            SubkeyName, NULL,
            SETUPLOG_USE_MESSAGEID,
            rc, NULL, NULL
            );
        return(rc);
    }

    RememberedRc = NO_ERROR;
    //
    // Set all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {

        rc = RegSetValueEx(
                hkey,
                ValueList[i].Name,
                0,
                ValueList[i].Type,
                (CONST BYTE *)ValueList[i].Data,
                ValueList[i].Size
                );

        if(rc != NO_ERROR) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_REGVALUE_FAIL,
                SubkeyName,
                ValueList[i].Name, NULL,
                SETUPLOG_USE_MESSAGEID,
                rc, NULL, NULL
                );
            RememberedRc = rc;
        }
    }

    RegCloseKey(hkey);

#ifdef _WIN64
    rc = SetGroupOfValues_32(
                 RootKey,
                 SubkeyName,
                 ValueList,
                 ValueCount);
    if (rc != NO_ERROR) {
        RememberedRc = rc;
    }
#endif

    return(RememberedRc);
}


BOOL
CreateWindowsNtSoftwareEntry(
    IN BOOL FirstPass
    )
{
    WCHAR Path[MAX_PATH];
    time_t DateVal;
    BOOL b;
    REGVALITEM SoftwareKeyItems[4];
    PWSTR Source;
    unsigned PlatformNameLength;
    unsigned PathLength;
    int PlatformOffset;
    DWORD Result;

    b = TRUE;

    if(FirstPass) {
        //
        // First pass occurs before net setup, and they want
        // the actual path where the files are located *right now*.
        // So we write that into the legacy source path value
        // in the registry.
        //
        SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
        SoftwareKeyItems[0].Data = LegacySourcePath;
        SoftwareKeyItems[0].Size = (lstrlen(LegacySourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[0].Type = REG_SZ;

        //
        // Set up fields for PathName value
        //
        Path[0] = '\0';
        Result = GetWindowsDirectory(Path,MAX_PATH);
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        SoftwareKeyItems[1].Name = L"PathName";
        SoftwareKeyItems[1].Data = Path;
        SoftwareKeyItems[1].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
        SoftwareKeyItems[1].Type = REG_SZ;

        //
        // Set up fields for SoftwareType value
        //
        SoftwareKeyItems[2].Name = L"SoftwareType";
        SoftwareKeyItems[2].Data = L"SYSTEM";
        SoftwareKeyItems[2].Size = sizeof(L"SYSTEM");
        SoftwareKeyItems[2].Type = REG_SZ;

        //
        // Set up fields for InstallDate value
        // (we no longer set this value here because this function is called before
        //  the Date/Time wizard page is executed. This value entry is now set by
        //  CreateInstallDateEntry(), which is always called after the Date/Time page
        //  is executed, when the user can no longer go back this page)
        //
        // time(&DateVal);
        // SoftwareKeyItems[3].Name = L"InstallDate";
        // SoftwareKeyItems[3].Data = &DateVal;
        // SoftwareKeyItems[3].Size = sizeof(DWORD);
        // SoftwareKeyItems[3].Type = REG_DWORD;
        //

        //
        // Write values into the registry.
        //
        if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,3) != NO_ERROR) {
            b = FALSE;
        }

        //
        // In addition we will populate the MRU list with a reasonable source path
        // which for now is the actual source path where files are located,
        // ie the CD-ROM or the temporary local source. Thus in the winnt/winnt32
        // case the user wouldn't see any UNC paths yet in any prompts that might
        // occur between now and pass 2 of this routine. Such paths aren't accessible
        // now anyway.
        //
        // Ditto for the 'SourcePath' value entry under
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Setup that is expected by
        // setupapi.dll/Win95 apps.
        //
        // The 'ServicePackSourcePath' is the same as the sourcepath for gui-mode setup.
        // We assume that the user has overlaid a service pack at the source location.
        // If it's retail media, this is technically incorrect, but it doesn't matter
        // since nothing will want to use the servicepack source anyway.  The service
        // pack update program will update this location if it is run.
        //


        if(!SetupAddToSourceList(SRCLIST_SYSTEM,SourcePath)) {
            b = FALSE;
        }

        SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
        SoftwareKeyItems[0].Data = SourcePath;
        SoftwareKeyItems[0].Size = (lstrlen(SourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[0].Type = REG_SZ;

        SoftwareKeyItems[1].Name = REGSTR_VAL_SVCPAKSRCPATH;
        SoftwareKeyItems[1].Data = SourcePath;
        SoftwareKeyItems[1].Size = (lstrlen(SourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[1].Type = REG_SZ;

        PathLength = gInstallingFromCD ? 1 : 0;
        SoftwareKeyItems[2].Name = L"CDInstall";
        SoftwareKeyItems[2].Data = &PathLength;
        SoftwareKeyItems[2].Size = sizeof(DWORD);
        SoftwareKeyItems[2].Type = REG_DWORD;

        if(SetGroupOfValues(HKEY_LOCAL_MACHINE,REGSTR_PATH_SETUP REGSTR_KEY_SETUP,SoftwareKeyItems,3) != NO_ERROR) {
            b = FALSE;
        }

#ifdef _X86_
        //
        // NEC98
        //
        // If this is system setup and using local copy, platform-specific extension
        // must be "nec98".
        //
        if (IsNEC_98 && SourcePath[0] && SourcePath[1] == L':' && SourcePath[2] == L'\\' && !lstrcmpi(SourcePath+2, pwLocalSource)) {
            SoftwareKeyItems[0].Name = L"ForcePlatform";
            SoftwareKeyItems[0].Data = L"nec98";
            SoftwareKeyItems[0].Size = (lstrlen(L"nec98")+1)*sizeof(WCHAR);
            SoftwareKeyItems[0].Type = REG_SZ;
            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,TEXT("System\\Setup"),SoftwareKeyItems,1) != NO_ERROR) {
                b = FALSE;
            }
        }
#endif

    } else {
        //
        // Not first pass. This occurs after network installation.
        // In the case where we are winnt-based, we need to fix up source paths
        // to point at the "real" location where files can be obtained -- ie,
        // a network share saved away for us by winnt/winnt32. If we are installing
        // from CD then the path we wrote during FirstPass is fine so we don't
        // bother changing it.
        //
        if(WinntBased) {
            //
            // Remove local source directory from MRU list.
            // Ignore errors.
            //
            SetupRemoveFromSourceList(SRCLIST_SYSTEM,SourcePath);

            lstrcpy(Path,OriginalSourcePath);

            //
            // Update legacy source path.
            //
            SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
            SoftwareKeyItems[0].Data = Path;
            SoftwareKeyItems[0].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
            SoftwareKeyItems[0].Type = REG_SZ;

            SoftwareKeyItems[1].Name = REGSTR_VAL_SVCPAKSRCPATH;
            SoftwareKeyItems[1].Data = Path;
            SoftwareKeyItems[1].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
            SoftwareKeyItems[1].Type = REG_SZ;

            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,1) != NO_ERROR) {
                b = FALSE;
            }

            //
            // Strip off platform-specific extension if it exists.
            //
            PathLength = lstrlen(Path);
            PlatformNameLength = lstrlen(PlatformName);
            PlatformOffset = PathLength - PlatformNameLength;

            if((PlatformOffset > 0)
            && (Path[PlatformOffset-1] == L'\\')
            && !lstrcmpi(Path+PlatformOffset,PlatformName)) {

                Path[PlatformOffset-1] = 0;

                SoftwareKeyItems[0].Size -= (PlatformNameLength+1)*sizeof(WCHAR);
                SoftwareKeyItems[1].Size -= (PlatformNameLength+1)*sizeof(WCHAR);
            }

            //
            // Add "real" path to MRU list and update setupapi.dll/Win95
            // SourcePath value.
            //
            if(!SetupAddToSourceList(SRCLIST_SYSTEM,Path)) {
                b = FALSE;
            }
            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,REGSTR_PATH_SETUP REGSTR_KEY_SETUP,SoftwareKeyItems,2) != NO_ERROR) {
                b = FALSE;
            }
        }
    }

    return(b);
}


BOOL
StoreNameOrgInRegistry(
    PWSTR   NameOrgName,
    PWSTR   NameOrgOrg
    )
{
    DWORD d;
    REGVALITEM SoftwareKeyItems[2];

    MYASSERT(!Upgrade);

    SoftwareKeyItems[0].Name = szRegisteredOwner;
    SoftwareKeyItems[0].Data = NameOrgName;
    SoftwareKeyItems[0].Size = (lstrlen(NameOrgName)+1)*sizeof(WCHAR);
    SoftwareKeyItems[0].Type = REG_SZ;

    SoftwareKeyItems[1].Name = szRegisteredOrganization;
    SoftwareKeyItems[1].Data = NameOrgOrg;
    SoftwareKeyItems[1].Size = (lstrlen(NameOrgOrg)+1)*sizeof(WCHAR);
    SoftwareKeyItems[1].Type = REG_SZ;

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,2);
    return(d == NO_ERROR);
}


BOOL
SetUpEvaluationSKUStuff(
    VOID
    )
{
    FILETIME FileTime;
    DWORD EvalValues[3];
    DWORD d;
    REGVALITEM Value;
    HKEY hkey;
    ULONGLONG SKUData;
    DWORD DataType;
    DWORD DataSize;
    time_t RawLinkTime;
    SYSTEMTIME SystemTime;
    struct tm *LinkTime;
    int delta;
    PIMAGE_NT_HEADERS NtHeaders;

    //
    // Fetch the evaulation time in minutes from the registry.
    // An evaluation time of 0 means indefinite.
    // This value was passed in from text mode in a special way
    // (ie, not via the text file that contains our params,
    // since that's not secure enough).
    //
    EvalValues[1] = 0;
    d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,KEY_READ,&hkey);
    if(d == NO_ERROR) {

        DataSize = sizeof(ULONGLONG);
        d = RegQueryValueEx(hkey,L"SystemPrefix",NULL,&DataType,(PBYTE)&SKUData,&DataSize);
        if(d == NO_ERROR) {
            //
            // Do not change this line without changing SpSaveSKUStuff() in
            // text setup (spconfig.c).
            //
            EvalValues[1] = (DWORD)(SKUData >> 13);
        }
        RegCloseKey(hkey);
    }

    //
    // Verify that the clock seems right in the eval unit case.
    // This helps protect against prople discovering that their
    // clock is wrong later and changing it, which expires their
    // eval unit.
    //
    if(EvalValues[1]) {
        //
        // Get the link time of our dll and convert to
        // a form where we have the year separated out.
        //
        try {
            if( NtHeaders = RtlImageNtHeader(MyModuleHandle) ) {
                RawLinkTime = NtHeaders->FileHeader.TimeDateStamp;
            } else {
                RawLinkTime = 0;
            }
            RawLinkTime = RtlImageNtHeader(MyModuleHandle)->FileHeader.TimeDateStamp;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            RawLinkTime = 0;
        }

        if(RawLinkTime && (LinkTime = gmtime(&RawLinkTime))) {

            GetLocalTime(&SystemTime);

            delta = (SystemTime.wYear - 1900) - LinkTime->tm_year;

            //
            // If the year of the current time is more than one year less then
            // the year the dll was linked, or more than three years more,
            // assume the user's clock is out of whack.
            //
            if((delta < -1) || (delta > 3)) {

                extern PCWSTR DateTimeCpl;

                MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_EVAL_UNIT_CLOCK_SEEMS_WRONG,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_OK | MB_ICONWARNING
                    );

                InvokeControlPanelApplet(DateTimeCpl,L"",0,L"");
            }
        }
    }

    //
    // Get current date/time and put into array in format
    // expected by the system code that reads it.
    //
    GetSystemTimeAsFileTime(&FileTime);
    EvalValues[0] = FileTime.dwLowDateTime;
    EvalValues[2] = FileTime.dwHighDateTime;

    //
    // Write value into registry.
    //
    Value.Name = L"PriorityQuantumMatrix";
    Value.Data = EvalValues;
    Value.Size = sizeof(EvalValues);
    Value.Type = REG_BINARY;

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Executive",
            &Value,
            1
            );

    return(d == NO_ERROR);
}



BOOL
ReadAndParseProcessorLicenseInfo(
    PDWORD LicensedProcessors,
    PLARGE_INTEGER pSKUData
    )
{

    DWORD d;
    REGVALITEM Value;
    HKEY hkey;
    LARGE_INTEGER SKUData;
    DWORD DataType;
    DWORD DataSize;
    DWORD NumberOfProcessors;

    //
    // Fetch the SKU Data from the registry
    //
    d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,KEY_READ,&hkey);
    if(d == NO_ERROR) {

        DataSize = sizeof(ULONGLONG);
        d = RegQueryValueEx(hkey,L"SystemPrefix",NULL,&DataType,(PBYTE)&SKUData,&DataSize);
        if(d == NO_ERROR) {

            //
            // The SKU Data contains several pieces of information.
            //
            // The registered processor related pieces are
            //
            // Bits 5 - 9  :  Log(NumberOfProcessors) Where NumberOfProcessors is the maximum
            //                   2
            //                number of processors that the system is licensed to use.

            //
            // Compute Licensed Processors
            //

            NumberOfProcessors = SKUData.LowPart;
            NumberOfProcessors = NumberOfProcessors >> 5;
            NumberOfProcessors = NumberOfProcessors & 0x0000001f;
            NumberOfProcessors = (1 << NumberOfProcessors);

            *LicensedProcessors = NumberOfProcessors;
        }
        RegCloseKey(hkey);
    }
    *pSKUData = SKUData;
    return(d == NO_ERROR);
}

BOOL
IsStandardServerSKU(
    PBOOL pIsServer
    )
{
    BOOL  fReturnValue = (BOOL) FALSE;
    OSVERSIONINFOEX  VersionInfo;
    BOOL  IsServer = FALSE;

     //
     // get the current SKU.
     //
     VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
     if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
         fReturnValue = TRUE;
         //
         // is it some sort of server SKU?
         //
         if (VersionInfo.wProductType != VER_NT_WORKSTATION) {

             //
             // standard server or a server variant?
             //
             if ((VersionInfo.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) == 0) {
                 //
                 // it's standard server
                 //
                 IsServer = TRUE;
             }

         }

         *pIsServer = IsServer;

     }

     return(fReturnValue);


}

BOOL
SetEnabledProcessorCount(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem;
    HKEY hkey;
    DWORD Size;
    DWORD Type;
    DWORD OriginalLicensedProcessors;
    DWORD LicensedProcessors;
    LARGE_INTEGER SKUData;
    BOOL IsServer = FALSE;
    ULONG Index = 0;

    if ( !ReadAndParseProcessorLicenseInfo(&OriginalLicensedProcessors,&SKUData) ) {
        return FALSE;
    }

    LicensedProcessors = OriginalLicensedProcessors;
    if(Upgrade) {

        //
        // During an upgrade, do not let the user go backwards.
        // (except for standard server SKU)
        //
        if (!IsStandardServerSKU(&IsServer) || IsServer == FALSE) {
            if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,SessionManagerKeyName,0,KEY_QUERY_VALUE,&hkey) == NO_ERROR) {

                Size = sizeof(d);
                if((RegQueryValueEx(hkey,szLicensedProcessors,NULL,&Type,(LPBYTE)&d,&Size) == NO_ERROR)
                && (Type == REG_DWORD)
                && (d >= LicensedProcessors)) {

                    LicensedProcessors = d;

                }

                RegCloseKey(hkey);
            }

        }

    }


    d = LicensedProcessors;
    RegistryItem.Data = &d;
    RegistryItem.Size = sizeof(DWORD);
    RegistryItem.Type = REG_DWORD;
    RegistryItem.Name = szRegisteredProcessors;

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,SessionManagerKeyName,&RegistryItem,1);

    if ( d == NO_ERROR ) {
        RegistryItem.Data = &LicensedProcessors;
        RegistryItem.Size = sizeof(DWORD);
        RegistryItem.Type = REG_DWORD;
        RegistryItem.Name = szLicensedProcessors;

        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,SessionManagerKeyName,&RegistryItem,1);
    }

    if ( d == NO_ERROR && LicensedProcessors >= OriginalLicensedProcessors) {

        //
        // need to update SKUData to reflect the fact the we are running with
        // a licensed processor count that is different from what is programmed
        // in the hives.
        //

        //
        // Convert Licensed Processors to Registry Format
        //

        //
        // Logic of getting the log(NumberOfProcessor) and verification.
        //                         2
        // Here we encode the number of processors as the power of 2.
        // Where NumberOfProcessors is the maximum number of processors that
        // the system is licensed to use.

        //
        // If exact power of two only then it is a good value.
        //
        if (LicensedProcessors & (LicensedProcessors-1)){
           SetupDebugPrint1( L"Setup: Licenced Processors contains an invalid value (%u) \n", LicensedProcessors );
           return( FALSE );
        }


        //
        // Count the number of times we need to divide NumberOfProcessors
        // by 2 to reduce it to 1.
        // 8 = 1000 in binary and (2^3 = 8) and we store 3 in the registry.
        //
        Index = 0;
        while(LicensedProcessors > 1){
            LicensedProcessors = LicensedProcessors >> 1;
            ++Index;
        }

        LicensedProcessors = Index;
        LicensedProcessors = LicensedProcessors << 5;
        LicensedProcessors &= 0x000003e0;

        //
        // Store NumberOfProcessors into the registry
        //

        SKUData.LowPart &= ~0x000003e0;
        SKUData.LowPart |= LicensedProcessors;

        RegistryItem.Data = &SKUData;
        RegistryItem.Size = sizeof(SKUData);
        RegistryItem.Type = REG_BINARY;
        RegistryItem.Name = L"SystemPrefix";

        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,L"SYSTEM\\Setup",&RegistryItem,1);
    }


    return(d == NO_ERROR);
}


#ifdef PRERELEASE
UINT
ValidateGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    UINT RememberedRc;

    //
    // Open the key first.
    //
    rc = RegOpenKeyEx(
            RootKey,
            SubkeyName,
            0,
            KEY_READ,
            &hkey
            );

    if(rc != NO_ERROR)
    {
        SetupDebugPrint2(L"RegOpenKeyEx failed on key:%s errorcode: %d\n",
            SubkeyName, rc);
        return(FALSE);
    }

    RememberedRc = NO_ERROR;
    //
    // Query all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {
        DWORD size;
        DWORD dontcare;
        BYTE  *data;
        size = ValueList[i].Size;
        data = LocalAlloc(LPTR, size);
        if (data)
        {
            rc = RegQueryValueEx(
                hkey,
                ValueList[i].Name,
                NULL,
                &dontcare,
                data,
                &size
                );
            if (rc == ERROR_SUCCESS)
            {
                // See if the data we read is the same then what is in the registery
                if (memcmp(data, ValueList[i].Data, size) != 0)
                {
                    // Data is different that what we expect.
                    SetupDebugPrint2(L"ValidateGroupOfValues, data difference for key:%s Valuename:%s\n",
                        SubkeyName, ValueList[i].Name);

                }
            }
            else
            {
                SetupDebugPrint3(L"RegQueryValueEx failed on key:%s Valuename:%s, errorcode: %d\n",
                    SubkeyName, ValueList[i].Name, rc);
                RememberedRc = rc;
            }
            LocalFree(data);
        }
    }

    RegCloseKey(hkey);

    return(RememberedRc == NO_ERROR);
}

void ValidateProductIDInReg()
{
    REGVALITEM RegistryItem[2];

    RegistryItem[0].Name = L"ProductId";
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,WindowsCurrentVersionKeyName,&RegistryItem[0],1);

    RegistryItem[1].Name = L"DigitalProductId";
    RegistryItem[1].Data = DigitalProductId;
    RegistryItem[1].Type = REG_BINARY;
    RegistryItem[1].Size = (DWORD)*DigitalProductId;
    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],2);
    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,IEProductVersionKeyName,&RegistryItem[0],2);

    return;
}


#endif

BOOL
SetProductIdInRegistry(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem[2];

    BEGIN_SECTION(L"SetProductIdInRegistry");
    if (*ProductId20FromProductId30 == L'\0')
    {
        SetupDebugPrint(L"ProductId20FromProductId30 is empty\n");
    }
    RegistryItem[0].Name = L"ProductId";
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    // SetGroupOfValues is logging it's errors
    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WindowsCurrentVersionKeyName,&RegistryItem[0],1);

    if (*DigitalProductId == 0)
    {
        SetupDebugPrint(L"DigitalProductId is empty\n");
    }
    //
    // first dword of the binary blob is the size
    //
    RegistryItem[1].Name = L"DigitalProductId";
    RegistryItem[1].Data = DigitalProductId;
    RegistryItem[1].Type = REG_BINARY;
    RegistryItem[1].Size = (DWORD)*DigitalProductId;

    if (d == NO_ERROR) {
        // SetGroupOfValues is logging it's errors
        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],2);
    }

    if (d == NO_ERROR) {
        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,IEProductVersionKeyName,&RegistryItem[0],2);
    }

#ifdef PRERELEASE
    ValidateProductIDInReg();
#endif
    END_SECTION(L"SetProductIdInRegistry");
    return(d == NO_ERROR);
}

DWORD
SetCurrentProductIdInRegistry(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem[1];

    BEGIN_SECTION(L"SetCurrentProductIdInRegistry");
    if (*ProductId20FromProductId30 == L'\0')
    {
        SetupDebugPrint(L"ProductId20FromProductId30 is empty\n");
    }
    RegistryItem[0].Name = szCurrentProductId;
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],1);

    END_SECTION(L"SetCurrentProductIdInRegistry");
    return(d);
}

VOID
DeleteCurrentProductIdInRegistry(
    VOID
    )
{
    HKEY    hKey = 0;
    ULONG   Error;

    BEGIN_SECTION(L"DeleteCurrentProductIdInRegistry");
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          WinntSoftwareKeyName,
                          0,
                          KEY_SET_VALUE,
                          &hKey );

    if (Error == NO_ERROR) {
        Error = RegDeleteValue(hKey, szCurrentProductId);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    END_SECTION(L"DeleteCurrentProductIdInRegistry");
}

BOOL
SetProductTypeInRegistry(
    VOID
    )
{
    WCHAR ProductTypeName[24];
    REGVALITEM RegistryItem;
    DWORD d;

    ProductTypeName[0] = '\0';
    SetUpProductTypeName(ProductTypeName,sizeof(ProductTypeName)/sizeof(WCHAR));
    RegistryItem.Data = ProductTypeName;
    RegistryItem.Size = (lstrlen(ProductTypeName)+1)*sizeof(WCHAR);
    RegistryItem.Type = REG_SZ;
    RegistryItem.Name = L"ProductType";

    if( MiniSetup ) {
        d = NO_ERROR;
    } else {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                &RegistryItem,
                1
                );
    }

    return(d == NO_ERROR);
}


BOOL
SetAutoAdminLogonInRegistry(
    LPWSTR Username,
    LPWSTR Password
    )
{
#define    AnswerBufLen (4*MAX_PATH)
#define    NumberOfEntries  3
REGVALITEM RegistryItem[NumberOfEntries];
DWORD      d;
WCHAR      AnswerFile[AnswerBufLen];
WCHAR      Answer[AnswerBufLen];

    d = StorePasswordAsLsaSecret (Password);
    if( d != NO_ERROR ) {
        SetupDebugPrint1( L"SETUP: StorePasswordAsLsaSecret failed (rc=%#x)", d );
        SetLastError (d);
        return FALSE;
    }

    RegistryItem[0].Data = L"1";
    RegistryItem[0].Size = (lstrlen(RegistryItem[0].Data)+1)*sizeof(WCHAR);
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Name = L"AutoAdminLogon";

    RegistryItem[1].Data = Username;
    RegistryItem[1].Size = (lstrlen(RegistryItem[1].Data)+1)*sizeof(WCHAR);
    RegistryItem[1].Type = REG_SZ;
    RegistryItem[1].Name = L"DefaultUserName";

    RegistryItem[2].Data = Win32ComputerName;
    RegistryItem[2].Size = (lstrlen(RegistryItem[2].Data)+1)*sizeof(WCHAR);
    RegistryItem[2].Type = REG_SZ;
    RegistryItem[2].Name = L"DefaultDomainName";

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            RegistryItem,
            NumberOfEntries
            );

    if( d != NO_ERROR ) {
        return FALSE;
    }

    //
    // Now set the AutoLogonCount entry if it's in the unattend file.
    //

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Is AutoLogonCount specified?
    //
    if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                 TEXT("AutoLogonCount"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {
        DWORD   Val;

            //
            // We got an answer.  If it's valid, then set it.
            //
            Val = wcstoul(Answer,NULL,10);

            RegistryItem[0].Data = &Val;
            RegistryItem[0].Size = sizeof(DWORD);
            RegistryItem[0].Type = REG_DWORD;
            RegistryItem[0].Name = TEXT("AutoLogonCount");

            d = SetGroupOfValues(
                    HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                    RegistryItem,
                    1 );
        }
    }

    return(d == NO_ERROR);
}

BOOL
SetProfilesDirInRegistry(
    LPWSTR ProfilesDir
    )
{
    REGVALITEM RegistryItem[1];
    DWORD d;


    RegistryItem[0].Data = ProfilesDir;
    RegistryItem[0].Size = (lstrlen(RegistryItem[0].Data)+1)*sizeof(WCHAR);
    RegistryItem[0].Type = REG_EXPAND_SZ;
    RegistryItem[0].Name = L"ProfilesDirectory";

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
            RegistryItem,
            1
            );

    return(d == NO_ERROR);
}

BOOL
ResetSetupInProgress(
    VOID
    )
{
    REGVALITEM RegistryItems[2];
    DWORD Zero;
    DWORD d;

    Zero = 0;

    RegistryItems[0].Name = L"SystemSetupInProgress";
    RegistryItems[0].Data = &Zero;
    RegistryItems[0].Size = sizeof(DWORD);
    RegistryItems[0].Type = REG_DWORD;

    if(Upgrade) {
        RegistryItems[1].Name = L"UpgradeInProgress";
        RegistryItems[1].Data = &Zero;
        RegistryItems[1].Size = sizeof(DWORD);
        RegistryItems[1].Type = REG_DWORD;
    }

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\Setup",
            RegistryItems,
            Upgrade ? 2 : 1
            );

    return(d == NO_ERROR);
}


BOOL
RemoveRestartStuff(
    VOID
    )
{
    #define     AnswerBufLen (4*MAX_PATH)
    HKEY hKeySetup;
    DWORD rc;
    BOOL AnyErrors;
    PWSTR *MultiSz;
    UINT Count;
    UINT i;
    BOOL Found;
    WCHAR c;
    UINT        Type;
    WCHAR       AnswerFile[AnswerBufLen];
    WCHAR       Answer[AnswerBufLen];

    AnyErrors = FALSE;

    //
    // Delete the 'RestartSetup' value.
    //
    rc = (DWORD)RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"System\\Setup",
                    0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE,
                    &hKeySetup
                    );

    if(rc == NO_ERROR) {
        rc = (DWORD)RegDeleteValue(hKeySetup,L"RestartSetup");
        if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND)) {
            AnyErrors = TRUE;
        }
        RegCloseKey(hKeySetup);
    } else {
        AnyErrors = TRUE;
    }

    if(AnyErrors) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REMOVE_RESTART_FAIL,
            rc,
            NULL,NULL);

        return FALSE;
    }

    //
    // Take care of the MiniSetup-specific items...
    //
    if( MiniSetup ) {
    BOOLEAN     FixupSourcePath;

        //
        // We've set a registry key specific to MiniSetup to
        // signal lsass to skip generating a new SID.  He
        // wanted to because he thinks we're setting up
        // a machine.  We need to delete that key now.
        //
        rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  L"System\\Setup",
                                  0,
                                  KEY_SET_VALUE | KEY_QUERY_VALUE,
                                  &hKeySetup );

        if(rc == NO_ERROR) {

            // There are reboot cases where OOBE doesn't want these values
            // modified.  OOBE is responsible for setting them appropriately
            // during its cleanup.
            //
            if (! OobeSetup)
            {
                //
                // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
                //
                rc = 0;
                RegSetValueEx( hKeySetup,
                               TEXT( "SetupType" ),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&rc,
                               sizeof(DWORD));
                RegDeleteValue(hKeySetup,L"MiniSetupInProgress");
            }
            RegDeleteValue(hKeySetup,L"MiniSetupDoPnP");
            RegCloseKey(hKeySetup);
        } else {
            AnyErrors = TRUE;
        }

        if(AnyErrors) {
            //
            // No.  This is a don't-care failure.
            //
        }

        //
        // Now fixup the SourcePath entry.
        //
        // For the MiniSetup case, we'll use an unattend key to determine
        // how to set the sourcepath.  The possible scenarios are:
        // [Unattended]
        // ResetSourcePath=*                This will indicate that we should
        //                                  not modify the existing source path
        //
        // ResetSourcePath="my_path"        This will indicate that we should use
        //                                  this as our new source path.
        //
        // <nothing>                        Reset the source path to the CDROM.
        //
        //


        //
        // Pickup the answer file.
        //
        GetSystemDirectory(AnswerFile,MAX_PATH);
        pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

        //
        // Assume we need to fixup the sourcepath.
        //
        FixupSourcePath = TRUE;

        //
        // Go retrieve this key from the unattend file.
        //
        if( GetPrivateProfileString( pwUnattended,
                                     TEXT("ResetSourcePath"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     AnswerFile ) ) {
            //
            // We got an answer.  See what he wants us to do.
            //
            if( !wcscmp( L"*", Answer ) ) {
                //
                // He gave us a "*", so don't change anything.
                //
                FixupSourcePath = FALSE;
            } else {
                //
                // We'll be using the contents of Answer for the
                // new source path.
                //
                FixupSourcePath = TRUE;
            }
        } else {
            //
            // Reset the source path to the first CDROM.
            // Assume conservatively that we don't have a CDROM, and
            // in that case, we won't be resetting the source path.
            //

            FixupSourcePath = FALSE;

            //
            // Don't change the sourcepath if the directory specified in
            // the key exists.
            //
            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );
            if( rc == NO_ERROR ) {
                TCHAR CurrentSourcePath[MAX_PATH] = L"";
                DWORD Size = sizeof(CurrentSourcePath);
                DWORD dwAttr;
                UINT  OldMode;

                //
                // Avoid system popups.
                //
                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                //
                // Read the current value.
                //
                rc = RegQueryValueEx( hKeySetup,
                                      TEXT("SourcePath"),
                                      0,
                                      0,
                                      (LPBYTE)CurrentSourcePath,
                                      &Size);

// Set up the ARCH_DIR based on the current binary architecture
//
#if defined(_X86_)
    #define ARCH_DIR L"i386"
#elif defined(_AMD64_)
    #define ARCH_DIR L"amd64"
#elif defined(_IA64_)
    #define ARCH_DIR L"ia64"
#else
#error "No Target Architecture"
#endif

                //
                // If the current directory (with arch) exists and it is on a fixed disk and it
                // is not a root directory then don't change it, otherwise change it.
                //
                if ( !((rc == NO_ERROR) &&
                       (CurrentSourcePath[0]) &&
                       (CurrentSourcePath[1] == L':') &&
                       (MyGetDriveType(CurrentSourcePath[0]) == DRIVE_FIXED) &&
                       (pSetupConcatenatePaths(CurrentSourcePath, ARCH_DIR, MAX_PATH, NULL)) &&
                       ((dwAttr = GetFileAttributes(CurrentSourcePath)) != 0xFFFFFFFF) &&
                       (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
                      )
                   ) {

                    Type = DRIVE_CDROM;

                    wcscpy( Answer, L"A:\\" );
                    for( c = L'A'; c <= L'Z'; c++ ) {
                        if( MyGetDriveType(c) == DRIVE_CDROM ) {

                            //
                            // Got it.  Remember the drive letter for
                            // the CDROM and break.
                            //
                            Answer[0] = c;

                            FixupSourcePath = TRUE;

                            break;
                        }
                    }
                }
                SetErrorMode(OldMode);
                RegCloseKey( hKeySetup );
            }
        }

        if( FixupSourcePath ) {
            //
            // If we get here, then Answer contains the new source path.
            //

            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );
            if( rc == NO_ERROR ) {
                //
                // Set the value.  Ignore the return.
                //
                RegSetValueEx( hKeySetup,
                               TEXT("SourcePath" ),
                               0,
                               REG_SZ,
                               (LPBYTE)Answer,
                               (lstrlen(Answer)+1) * sizeof(WCHAR) );

                RegSetValueEx( hKeySetup,
                               TEXT("ServicePackSourcePath" ),
                               0,
                               REG_SZ,
                               (LPBYTE)Answer,
                               (lstrlen(Answer)+1) * sizeof(WCHAR) );

                //
                // Now we need to determine if the drive we're setting him to
                // is a CDROM.
                //
                if( (Answer[1] == L':') &&
                    (MyGetDriveType(Answer[0]) == DRIVE_CDROM) ) {

                    rc = 1;
                    RegSetValueEx( hKeySetup,
                                   TEXT("CDInstall" ),
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&rc,
                                   sizeof(DWORD));
                }

                RegCloseKey( hKeySetup );
            }
        }
    }




    //
    // See if we need to disable the Admin account.  Only do this if
    // the user asked us to *and* the machine has been joined to a
    // domain.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    if( GetPrivateProfileString( pwData,
                                 TEXT("DisableAdminAccountOnDomainJoin"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( wcscmp( L"", Answer ) ) {

            PWSTR                   SpecifiedDomain = NULL;
            NETSETUP_JOIN_STATUS    JoinStatus;

            //
            // See if we're in a domain.
            //
            rc = NetGetJoinInformation( NULL,
                                        &SpecifiedDomain,
                                        &JoinStatus );

            if( SpecifiedDomain ) {
                NetApiBufferFree( SpecifiedDomain );
            }

            if( (rc == NO_ERROR) &&
                (JoinStatus == NetSetupDomainName) ) {


                //
                // Yes.  Go disable the Admin account.
                //
                DisableLocalAdminAccount();
            }
        }
    }



    //
    // Remove sprestrt.exe from the session manager execute list.
    //
    rc = pSetupQueryMultiSzValueToArray(
            HKEY_LOCAL_MACHINE,
            SessionManagerKeyName,
            szBootExecute,
            &MultiSz,
            &Count,
            TRUE
            );

    if(rc == NO_ERROR) {

        Found = FALSE;
        for(i=0; i<Count && !Found; i++) {

            if(!_wcsnicmp(MultiSz[i],L"sprestrt",8)) {
                //
                // Found it, remove it.
                //
                Found = TRUE;

                MyFree(MultiSz[i]);

                MoveMemory(&MultiSz[i],&MultiSz[i+1],((Count-i)-1)*sizeof(PWSTR));
                Count--;
            }
        }

        if(Found) {

            rc = pSetupSetArrayToMultiSzValue(
                    HKEY_LOCAL_MACHINE,
                    SessionManagerKeyName,
                    szBootExecute,
                    MultiSz,
                    Count
                    );

            if(rc != NO_ERROR) {
                AnyErrors = TRUE;
            }
        }

        pSetupFreeStringArray(MultiSz,Count);
    }

    if(AnyErrors) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REMOVE_RESTART_FAIL,
            rc,
            NULL,NULL);
    }

    return(!AnyErrors);
}

VOID
RestoreOldPathVariable(
    VOID
    )
{
    HKEY hkey;
    LONG rc;
    DWORD Size;
    DWORD BufferSize;
    PWSTR Data;
    DWORD Type;
    BOOL b;


    b = FALSE;
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            EnvironmentKeyName,
            0,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            &hkey
            );

    if(rc == NO_ERROR) {

        Size = 0;
        rc = RegQueryValueEx(hkey,L"OldPath",NULL,&Type,NULL,&Size);
        if(rc == NO_ERROR) {

            BufferSize = Size;
            if(Data = MyMalloc(BufferSize)) {

                rc = RegQueryValueEx(hkey,L"OldPath",NULL,&Type,(LPBYTE)Data,&Size);
                if(rc == NO_ERROR) {

                    if( Data && *Data )
                        rc = RegSetValueEx(hkey,L"Path",0,Type,(LPBYTE)Data,Size);

                    rc = RegDeleteValue(hkey,L"OldPath");

                    if(rc == NO_ERROR) {
                        b = TRUE;
                    }
                }

                MyFree(Data);
            }
        }

        RegCloseKey(hkey);
    }

    if( rc != NO_ERROR ){
        SetupDebugPrint1(L"Setup: (non-critical error) Could not restore PATH variable - Error %lx\n", rc );
        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_RESTORE_PATH_FAILURE,
                            NULL,NULL);
    }



    return;

}


BOOL
FixQuotaEntries(
    VOID
    )
{
    BOOL b;
    HKEY key1,key2;
    LONG rc,rc1,rc2;
    PCWSTR szPagedPoolSize = L"PagedPoolSize";
    PCWSTR szRegistryLimit = L"RegistrySizeLimit";
    DWORD Size;
    DWORD Type;
    DWORD PoolSize,RegistryLimit;

    MYASSERT(Upgrade);

    if(ISDC(ProductType)) {

        b = FALSE;

        //
        // Open keys.
        //
        rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                MemoryManagementKeyName,
                0,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &key1
                );

        if(rc == NO_ERROR) {

            rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    ControlKeyName,
                    0,
                    KEY_QUERY_VALUE | KEY_SET_VALUE,
                    &key2
                    );

            if(rc == NO_ERROR) {

                b = TRUE;

                //
                // Read paged pool size and registry limit. If either is not present,
                // then we're done.
                //
                Size = sizeof(DWORD);
                rc1 = RegQueryValueEx(
                            key1,
                            szPagedPoolSize,
                            NULL,
                            &Type,
                            (LPBYTE)&PoolSize,
                            &Size
                            );

                Size = sizeof(DWORD);
                rc2 = RegQueryValueEx(
                            key2,
                            szRegistryLimit,
                            NULL,
                            &Type,
                            (LPBYTE)&RegistryLimit,
                            &Size
                            );

                if((rc1 == NO_ERROR) && (rc2 == NO_ERROR)
                && (PoolSize == (48*1024*1024))
                && (RegistryLimit == (24*1024*1024))) {
                    //
                    // Values are in bogus state. Clean them up.
                    //
                    PoolSize = 0;
                    RegistryLimit = 0;
                    rc1 = RegSetValueEx(
                                key1,
                                szPagedPoolSize,
                                0,
                                REG_DWORD,
                                (CONST BYTE *)&PoolSize,
                                sizeof(DWORD)
                                );

                    rc2 = RegSetValueEx(
                                key2,
                                szRegistryLimit,
                                0,
                                REG_DWORD,
                                (CONST BYTE *)&RegistryLimit,
                                sizeof(DWORD)
                                );

                    if((rc1 != NO_ERROR) || (rc2 != NO_ERROR)) {
                        b = FALSE;
                    }
                }

                RegCloseKey(key2);
            }

            RegCloseKey(key1);
        }
    } else {
        b = TRUE;
    }

    return(b);
}


//
// Stamps the current build number into the .default hive
// which is then saved into the Default User hive
//

BOOL
StampBuildNumber(
    VOID
    )
{
    OSVERSIONINFO ver;
    HKEY hKeyWinlogon;
    DWORD dwVer, dwDisp;
    LONG lResult;


    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&ver)) {
        return FALSE;
    }

    dwVer = LOWORD(ver.dwBuildNumber);

    lResult = RegCreateKeyEx (HKEY_USERS,
                              TEXT(".DEFAULT\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKeyWinlogon,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    RegSetValueEx (hKeyWinlogon, TEXT("BuildNumber"), 0, REG_DWORD,
                   (LPBYTE) &dwVer, sizeof(dwVer));

    RegCloseKey (hKeyWinlogon);


    return TRUE;
}


VOID
pCheckAnswerFileForProgramFiles (
    IN OUT  PWSTR PfPath,
    IN      UINT UnattendId
    )

/*++

Routine Description:

  pCheckAnswerFileForProgramFiles checks the unattend.txt data structure to
  see if the user supplied a new value for one of the paths of program files.
  If an entry is specified, it is validated, and the directory is created if
  it does not already exist.

Arguments:

  PfPath     - Specifies the current program files path, receives the new
               path.
  UnattendId - Specifies which unattend.txt entry to process.  This is a
               constant defined in unattend.h.

Return Value:

  None.

--*/

{
    DWORD Attributes;
    WCHAR Path[MAX_PATH / 2];
    WCHAR fullPath[MAX_PATH];

    if (Unattended) {
        //
        // If an answer file setting exists for this unattend ID,
        // test the path, and if it does not exist, try creating it.
        // If the path is an actual local directory, then use it.
        //

        if (UnattendAnswerTable[UnattendId].Present) {

            lstrcpyn (Path, UnattendAnswerTable[UnattendId].Answer.String, ARRAYSIZE(Path));

            *fullPath = 0;
            GetFullPathName (Path, ARRAYSIZE(fullPath), fullPath, NULL);

            Attributes = GetFileAttributes (fullPath);

            if (Attributes == 0xFFFFFFFF) {
                CreateDirectory (fullPath, NULL);
                Attributes = GetFileAttributes (fullPath);
            }

            if (Attributes != 0xFFFFFFFF && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                lstrcpy (PfPath, fullPath);
            }
        }
    }
}


BOOL
SetProgramFilesDirInRegistry(
    VOID
    )
{
    DWORD d;
#if defined(WX86) || defined(_WIN64) // non-x86 platforms that have WX86 defined
    REGVALITEM RegistryItem[4];
#else
    REGVALITEM RegistryItem[2];
#endif
    WCHAR   DirPath0[ MAX_PATH + 1 ];
    WCHAR   DirPath1[ MAX_PATH + 1 ];
#if defined(WX86) || defined(_WIN64)
    WCHAR   DirPath2[ MAX_PATH + 1 ];
    WCHAR   DirPath3[ MAX_PATH + 1 ];
#endif
    WCHAR   DirName[ MAX_PATH + 1 ];
    DWORD Result;


    //
    //  Get the letter of the drive where the system is installed
    //
    Result = GetWindowsDirectory(DirPath0, sizeof(DirPath0)/sizeof(WCHAR));
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    DirPath0[3] = (WCHAR)'\0';
#if defined(WX86) || defined(_WIN64)
    lstrcpy(DirPath2, DirPath0);
#endif

    //
    //  Get the name of the 'Program Files' directory
    //
    LoadString(MyModuleHandle,
               IDS_PROGRAM_FILES_DIRECTORY,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath0, DirName );
    lstrcpy( DirPath1, DirPath0 );
#if defined(WX86) || defined(_WIN64)
    //
    //  Get the name of the 'Program Files (x86)' directory
    //
    LoadString(MyModuleHandle,
               IDS_PROGRAM_FILES_DIRECTORY_WX86,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath2, DirName );
    lstrcpy( DirPath3, DirPath2 );
#endif

    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath0, UAE_PROGRAMFILES);

    RegistryItem[0].Name = L"ProgramFilesDir";
    RegistryItem[0].Data = DirPath0;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(DirPath0)+1)*sizeof(WCHAR);

    //
    //  Get the name of the 'Common Files' directory
    //
    LoadString(MyModuleHandle,
               IDS_COMMON_FILES_DIRECTORY,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath1, L"\\" );
    lstrcat( DirPath1, DirName );
    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath1, UAE_COMMONPROGRAMFILES);

    RegistryItem[1].Name = L"CommonFilesDir";
    RegistryItem[1].Data = DirPath1;
    RegistryItem[1].Type = REG_SZ;
    RegistryItem[1].Size = (lstrlen(DirPath1)+1)*sizeof(WCHAR);

#if defined(WX86) || defined(_WIN64)

    SetEnvironmentVariableW (L"ProgramFiles(x86)", DirPath2);
    SetEnvironmentVariableW (L"CommonProgramFiles(x86)", DirPath3);

    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath2, UAE_PROGRAMFILES_X86);

    RegistryItem[2].Name = L"ProgramFilesDir (x86)";
    RegistryItem[2].Data = DirPath2;
    RegistryItem[2].Type = REG_SZ;
    RegistryItem[2].Size = (lstrlen(DirPath2)+1)*sizeof(WCHAR);

    //
    //  Build the full path
    //
    lstrcat( DirPath3, L"\\" );
    lstrcat( DirPath3, DirName );
    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath3, UAE_COMMONPROGRAMFILES_X86);

    RegistryItem[3].Name = L"CommonFilesDir (x86)";
    RegistryItem[3].Data = DirPath3;
    RegistryItem[3].Type = REG_SZ;
    RegistryItem[3].Size = (lstrlen(DirPath3)+1)*sizeof(WCHAR);
#endif

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,
                         WindowsCurrentVersionKeyName,
                         RegistryItem,
                         sizeof(RegistryItem)/sizeof(REGVALITEM));



    //
    // Set the ProgramFiles and wx86 Program Files environment
    // variable in setup's process so that ExpandEnvironmentStrings
    // can be used later.
    //

    SetEnvironmentVariableW (L"ProgramFiles", DirPath0);
    SetEnvironmentVariableW (L"CommonProgramFiles", DirPath1);

#if defined(WX86) || defined(_WIN64)
    //
    // also set programfiles and commonprogramfiles for 32 bit applications on
    // the machine
    //
    RegistryItem[2].Name = L"ProgramFilesDir";
    RegistryItem[3].Name = L"CommonFilesDir";

    SetGroupOfValues_32(HKEY_LOCAL_MACHINE,
                     WindowsCurrentVersionKeyName,
                     &RegistryItem[2],
                     2 );
#endif

    return (d == NO_ERROR);
}


BOOL
SaveAndReplaceSystemHives(
    VOID
)

/*++

Routine Description:

    Saave the system hives listed on HiveTable.
    This is the remove fragmentation from the current system hives.
    The hives that are successfully saved, will be used later on, to replace
    the current system hives.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/


{
    int i;
    WCHAR Name1[MAX_PATH],Name2[MAX_PATH];
    PWSTR p, q;
    LONG  Error;
    HKEY  Key;
    BOOL  b = TRUE;

    //
    //  Initialize buffers with path to the config directory
    GetSystemDirectory(Name1,MAX_PATH);
    pSetupConcatenatePaths(Name1,L"CONFIG\\",MAX_PATH,NULL);
    lstrcpy(Name2,Name1);
    //
    //  Remember the position of file names in the buffers
    //
    p = Name1 + lstrlen( Name1 );
    q = Name2 + lstrlen( Name2 );

    //
    //  Delete the files that need to be deleted before they
    //  are even created. This is done before the system hive
    //  is saved, because the list of files to be deleted on
    //  reboot is stored in the system hive.
    //
    for(i=0; i<sizeof(HiveTable)/sizeof(HiveTable[0]); i++) {

        lstrcpy(p, HiveTable[i].NewHive);
        lstrcpy(q, HiveTable[i].DeleteHive);

        Error = MoveFileEx( Name1, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );
        lstrcat(Name1,L".LOG");
        Error = MoveFileEx( Name1, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );

        Error = MoveFileEx( Name2, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );
    }

    //
    // Enable backup privilege. Ignore any error.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);

    for(i=0; i<sizeof(HiveTable)/sizeof(HiveTable[0]); i++) {

        //
        //  Build the name for the new hive
        //
        lstrcpy(p,HiveTable[i].NewHive);
        lstrcpy(q,HiveTable[i].DeleteHive);

        //
        //  Attempt to save the hive
        //
        if( !SaveHive( HiveTable[i].RootKey,
                       HiveTable[i].Subkey,
                       Name1,
                       REG_LATEST_FORMAT // latest format available for local hives
                       ) ) {
            b = FALSE;
            continue;
        }
        if(FileExists(Name2,NULL)) {
            //
            // If the file exists, then delete it
            //
            SetFileAttributes(Name2,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Name2);
        }


        //
        //  Now replace the current system hive with the one just saved
        //

        Error = RegReplaceKey( HiveTable[i].RootKey,
                               HiveTable[i].Subkey,
                               Name1,
                               Name2 );

        if( Error != ERROR_SUCCESS ) {
            b = FALSE;
        }
    }
    return(b);
}


BOOL
CreateInstallDateEntry(
    )
{
    WCHAR Path[MAX_PATH];
    time_t DateVal;
    BOOL b;
    REGVALITEM SoftwareKeyItems[1];

    b = TRUE;

    //
    // Set up fields for InstallDate value.
    // This can be set only after the Date/Time wizard page was executed, otherwise the Date/Time info
    // may be wrong.
    //
    time(&DateVal);
    SoftwareKeyItems[0].Name = L"InstallDate";
    SoftwareKeyItems[0].Data = &DateVal;
    SoftwareKeyItems[0].Size = sizeof(DWORD);
    SoftwareKeyItems[0].Type = REG_DWORD;

    //
    // Write values into the registry.
    //
    if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,1) != NO_ERROR) {
        b = FALSE;
    }

    return(b);
}

VOID
ConfigureSystemFileProtection(
    VOID
    )
/*++

Routine Description:

    This routine looks in the unattend file to see if there are any entries
    that may need to be set in the registry for the SFP (dll cache).

Arguments:

    None.

Returns:

    None.

--*/

{
#define     AnswerBufLen (4*MAX_PATH)
WCHAR       AnswerFile[AnswerBufLen];
WCHAR       Answer[AnswerBufLen];
DWORD       d;
HKEY        hKey;

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Open the target registry entry.
    //
    if (RegOpenKey( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", &hKey ) != ERROR_SUCCESS) {
        return;
    }


    //
    // we look for the following keys in the [SystemFileProtection] section:
    //

    // SFCQuota         = <hex value>, default to 0x32
    // SFCShowProgress  = <0|1>, default to 0
    // SFCDllCacheDir   = <string>, default to "%systemroot%\system32\dllcache"
    //

    //
    // SFCQuota
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCQuota"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,16);

            RegSetValueEx( hKey,
                           TEXT("SFCQuota"),
                           0,
                           REG_DWORD,
                           (CONST BYTE *)&d,
                           sizeof(DWORD) );
        }
    }


    //
    // SFCShowProgress
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCShowProgress"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,10);

            if( d <= 1 ) {
                RegSetValueEx( hKey,
                               TEXT("SFCShowProgress"),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&d,
                               sizeof(DWORD) );
            }
        }
    }


    //
    // SFCDllCacheDir
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCDllCacheDir"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            RegSetValueEx( hKey,
                           TEXT("SFCDllCacheDir"),
                           0,
                           REG_EXPAND_SZ,
                           (CONST BYTE *)Answer,
                           (lstrlen(Answer)+1)*sizeof(WCHAR) );
        }
    }

    RegCloseKey( hKey );
}

DWORD
QueryValueInHKLM (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    )

/*++

Routine Description:

    Queries the data for a value in HKLM.

Arguments:

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - returns the type of the value data.

    ValueData - returns a pointer to value data.  This buffer must be
        freed by the caller using MyFree.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY hkey;
    DWORD disposition;
    DWORD error;

    //
    // Open the parent key.
    //

    if ( (KeyName == NULL) || (wcslen(KeyName) == 0) ) {
        hkey = HKEY_LOCAL_MACHINE;
    } else {
        error = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                KeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkey,
                                &disposition );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    //
    // Query the value to get the length of its data.
    //

    *ValueDataLength = 0;
    *ValueData = NULL;
    error = RegQueryValueEx( hkey,
                             ValueName,
                             NULL,
                             ValueType,
                             NULL,
                             ValueDataLength );

    //
    // Allocate a buffer to hold the value data.
    //

    if ( error == NO_ERROR ) {
        *ValueData = MyMalloc( *ValueDataLength );
        if ( *ValueData == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Query the value again, this time retrieving the data.
    //

    if ( error == NO_ERROR ) {
        error = RegQueryValueEx( hkey,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 *ValueData,
                                 ValueDataLength );
        if ( error != NO_ERROR ) {
            MyFree( *ValueData );
        }
    }

    //
    // Close the parent key.
    //

    if ( hkey != HKEY_CURRENT_USER ) {
        RegCloseKey( hkey );
    }

    return error;
}


DWORD
MyCopyKeyRecursive(
    IN HKEY     DestRootKey,
    IN HKEY     SourceRootKey
    )

/*++

Routine Description:

    This function will duplicate one key (and all its subkeys)
    to another key.

Arguments:

    DestRootKey     - Root of the destination registry key.

    SourceRootKey   - Root of the source registry key.

Return Value:

    ReturnCode

--*/

{
PWCH        SubKeyName;
DWORD       SubKeyNameLength;
PVOID       DataBuffer;
DWORD       DataLength;
DWORD       maxValueDataLength;
DWORD       maxValueNameLength;
DWORD       maxKeyNameLength;
ULONG       Index;
DWORD       rc = NO_ERROR;
FILETIME    ftLastWriteTime;
HKEY        hSubDestKey, hSubSourceKey;
DWORD       dwDisp;
DWORD       Type;

    //
    // Query information about the key that we'll be inspecting.
    //
    rc = RegQueryInfoKey( SourceRootKey,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &maxKeyNameLength,
                          NULL,
                          NULL,
                          &maxValueNameLength,
                          &maxValueDataLength,
                          NULL,
                          NULL );
    if( rc != NO_ERROR ) {
        SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegQueryInfoKey failed (%d)", rc );
        return rc;
    }



    //
    // Enumerate all keys in the source and recursively create
    // them in the destination.
    //
    for( Index = 0; ; Index++ ) {

        //
        // Allocate a buffer large enough to hold the longest
        // key name.
        //
        SubKeyName = NULL;
        SubKeyName = MyMalloc( (maxKeyNameLength+2) * sizeof(WCHAR) );
        SubKeyNameLength = (maxKeyNameLength+2);
        if( !SubKeyName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        rc = RegEnumKeyEx( SourceRootKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           NULL,
                           NULL,
                           &ftLastWriteTime );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc == ERROR_NO_MORE_ITEMS ) {
                rc = ERROR_SUCCESS;
            } else {
                SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegEnumKeyEx failed (%d)", rc );
            }

            break;
        }


        hSubDestKey = NULL;
        hSubSourceKey = NULL;
        //
        // Create the key in the destination, and call
        // ourselves again.
        //
        rc = RegCreateKeyEx( DestRootKey,
                             SubKeyName,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hSubDestKey,
                             &dwDisp );

        if( rc == ERROR_SUCCESS ) {
            rc = RegOpenKeyEx( SourceRootKey,
                               SubKeyName,
                               0,
                               KEY_READ,
                               &hSubSourceKey );
        } else {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegCreateKeyEx failed to create %ws (%d)", SubKeyName, rc );
        }


        if( rc == ERROR_SUCCESS ) {
            rc = MyCopyKeyRecursive( hSubDestKey,
                                     hSubSourceKey );
        } else {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegOpenKeyEx failed to open %ws (%d)", SubKeyName, rc );
        }


        //
        // Clean up and do the loop again.
        //
        if( hSubDestKey ) {
            RegCloseKey( hSubDestKey );
            hSubDestKey = NULL;
        }
        if( hSubSourceKey ) {
            RegCloseKey( hSubSourceKey );
            hSubSourceKey = NULL;
        }
        if( SubKeyName ) {
            MyFree( SubKeyName );
            SubKeyName = NULL;
        }


    }




    //
    // Enumerate all the value keys in the source and copy them all
    // into the destination key.
    //



    for( Index = 0; ; Index++ ) {

        //
        // Allocate a buffers large enough to hold the longest
        // name and data
        //
        SubKeyName = NULL;
        SubKeyName = MyMalloc( (maxValueNameLength+2) * sizeof(WCHAR) );
        SubKeyNameLength = (maxValueNameLength+2);
        if( !SubKeyName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DataBuffer = NULL;
        DataBuffer = MyMalloc( maxValueDataLength+2 );
        DataLength = maxValueDataLength+2;
        if( !DataBuffer ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        rc = RegEnumValue( SourceRootKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           &Type,
                           DataBuffer,
                           &DataLength );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc == ERROR_NO_MORE_ITEMS ) {
                rc = ERROR_SUCCESS;
            } else {
                SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegEnumValue failed (%d)", rc );
            }

            break;
        }


        hSubDestKey = NULL;
        hSubSourceKey = NULL;
        //
        // Create the value key in the destination.
        //
        rc = RegSetValueEx( DestRootKey,
                            SubKeyName,
                            0,
                            Type,
                            DataBuffer,
                            DataLength );

        if( rc != ERROR_SUCCESS ) {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegSetValueEx failed to set %ws (%d)", SubKeyName, rc );
        }

        //
        // Clean up and do the loop again.
        //
        if( SubKeyName ) {
            MyFree( SubKeyName );
            SubKeyName = NULL;
        }
        if( DataBuffer ) {
            MyFree( DataBuffer );
            DataBuffer = NULL;
        }

    }





    return rc;
}


DWORD
MyCopyKey (
    IN HKEY        DestRootKey,
    IN PCWSTR      DestKeyName,
    IN HKEY        SourceRootKey,
    IN PCWSTR      SourceKeyName
    )

/*++

Routine Description:

    This function will duplicate one key (and all its subkeys)
    to another key.

    Note that we're not just going to lay the new key ontop of
    the destination.  We're going to actually replace the destination
    with the source.

Arguments:

    DestRootKey     - Root of the destination registry key.

    DestKeyName     - Name of teh source registry key.

    SourceRootKey   - Root of the source registry key.

    SourceKeyName   - Name of teh source registry key.

Return Value:

    ReturnCode

--*/

{
UINT        i;
HKEY        hDestKey = NULL, hSourceKey = NULL;
DWORD       ActionTaken;
UINT        RememberedRc;
DWORD       rc = NO_ERROR;

    //
    // Don't accept any NULL parameters.
    //
    if( (SourceRootKey == NULL ) ||
        (SourceKeyName == NULL ) ||
        (DestRootKey   == NULL ) ||
        (DestKeyName   == NULL ) ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open our source key.
    //
    rc = RegOpenKeyEx( SourceRootKey,
                       SourceKeyName,
                       0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                       &hSourceKey );

    if( rc != NO_ERROR ) {
        SetupDebugPrint2( L"Setup: MyCopyKey - Failed to open %ws (%d)", SourceKeyName, rc );
        return rc;
    }



    //
    // Remove the destination key.
    //
    if( rc == NO_ERROR ) {
        pSetupRegistryDelnode( DestRootKey,
                         DestKeyName );
    }


    //
    // Now copy over the source key into the destination key.
    //
    //
    // Open/create the key first.
    //
    if( rc == NO_ERROR ) {
        rc = RegCreateKeyEx( DestRootKey,
                             DestKeyName,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE,
                             NULL,
                             &hDestKey,
                             &ActionTaken );

        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: MyCopyKey - Failed to create %ws (%d)", DestKeyName, rc );
        }
    }


    //
    // We've got handles to both keys, now we're ready to call
    // our worker.
    //
    if( rc == NO_ERROR ) {
        rc = MyCopyKeyRecursive( hDestKey,
                                 hSourceKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: MyCopyKey - MyCopyKeyRecursive failed (%d)", rc );
        }
    }


    //
    // Clean up and exit.
    //
    if( hSourceKey ) {
        RegCloseKey( hSourceKey );
    }
    if( hDestKey ) {
        RegCloseKey( hDestKey );
    }

    return rc;

}


DWORD
FixupUserHives(
    VOID
    )

/*++

Routine Description:

    This function will take some of the changes we've made to
    the default hive and copy them into the various user hives.

Arguments:

    NONE

Return Value:

    ReturnCode

--*/

{
DWORD               rc = ERROR_SUCCESS;
WCHAR               ProfilesDir[MAX_PATH*2];
WCHAR               HiveName[MAX_PATH*2];
WCHAR               ValueBuffer[MAX_PATH*2];
DWORD               dwSize;
HANDLE              FindHandle;
WIN32_FIND_DATA     FileData;
DWORD               Type, DataSize;
HKEY                TmpKey1, TmpKey2;


    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);

    //
    // Take care of every profile we find.
    //
    dwSize = (MAX_PATH * 2);
    if( GetProfilesDirectory( ProfilesDir, &dwSize ) ) {
        pSetupConcatenatePaths( ProfilesDir, L"\\*", (MAX_PATH*2), NULL );
        FindHandle = FindFirstFile( ProfilesDir, &FileData );

        if( FindHandle != INVALID_HANDLE_VALUE ) {

            do {
                //
                // We got something, but remember that we only want directories.
                //
                if( (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (wcscmp(FileData.cFileName,L"."))                      &&
                    (wcscmp(FileData.cFileName,L"..")) ) {

                    //
                    // He's a directory and he's not parent or current.
                    // Generate a path to his hive.
                    //
                    dwSize = (MAX_PATH * 2);
                    GetProfilesDirectory( HiveName, &dwSize );

                    pSetupConcatenatePaths( HiveName, FileData.cFileName, (MAX_PATH*2), NULL );
                    pSetupConcatenatePaths( HiveName, L"\\NTUSER.DAT", (MAX_PATH*2), NULL );

                    rc = RegLoadKey( HKEY_LOCAL_MACHINE,
                                     L"MiniSetupTemp",
                                     HiveName );


                    if( rc == ERROR_SUCCESS ) {

                        //
                        // Take care of the 'International' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Control Panel\\International",
                                        HKEY_CURRENT_USER,
                                        L"Control Panel\\International" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Control Panel\\International in %ws (%d)", HiveName, rc );
                        }


                        //
                        // Take care of the 'Keyboard Layout' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Keyboard Layout",
                                        HKEY_CURRENT_USER,
                                        L"Keyboard Layout" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Keyboard Layout in %ws (%d)", HiveName, rc );
                        }


                        //
                        // Take care of the 'Input Method' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Control Panel\\Input Method",
                                        HKEY_CURRENT_USER,
                                        L"Control Panel\\Input Method" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Input Method in %ws (%d)", HiveName, rc );
                        }


                        //
                        // If the user has modified the internationalization settings
                        // in intl.cpl, then there's likely a 'Run' key.  We need to migrate that
                        // too.  We need to be careful here though.  The established users may already
                        // have value keys set under here.  We only need to set *our* single value
                        // key under here.  That value is called 'internat.exe'.  If it's there, we
                        // need to prop it out to the hives we're modifying.
                        //
                        rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                                           REGSTR_PATH_RUN,
                                           0,
                                           KEY_READ,
                                           &TmpKey1 );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint1( L"Setup: FixupUserHive - Failed to open Run key (%d)", rc );
                        } else {

                            DataSize = sizeof(ValueBuffer);
                            rc = RegQueryValueEx( TmpKey1,
                                                  L"internat.exe",
                                                  NULL,
                                                  &Type,
                                                  (PBYTE)ValueBuffer,
                                                  &DataSize );

                            RegCloseKey( TmpKey1 );

                            if( rc == ERROR_SUCCESS ) {
                                //
                                // It's there.  Prop it into the existing hives too.
                                // We can't just use RegSetValueEx though because that API
                                // may tell us we succeeded, when in fact if the key doesn't
                                // exist, we won't set it.  To fix that, first create the
                                // key.
                                //
                                rc = RegCreateKeyEx ( HKEY_LOCAL_MACHINE,
                                                      TEXT("MiniSetupTemp\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                                                      0,
                                                      NULL,
                                                      REG_OPTION_NON_VOLATILE,
                                                      KEY_WRITE,
                                                      NULL,
                                                      &TmpKey1,
                                                      &DataSize);

                                if( rc == ERROR_SUCCESS ) {

                                    wcscpy( ValueBuffer, L"internat.exe" );
                                    rc = RegSetValueEx( TmpKey1,
                                                        L"Internat.exe",
                                                        0,
                                                        REG_SZ,
                                                        (LPBYTE)ValueBuffer,
                                                        (lstrlen(ValueBuffer)+1)*sizeof(WCHAR) );

                                    RegCloseKey( TmpKey1 );

                                    if( rc != ERROR_SUCCESS ) {
                                        SetupDebugPrint2( L"Setup: FixupUserHive - Failed to set internat.exe key in hive %ws (%d)", HiveName, rc );
                                    }


                                } else {
                                    SetupDebugPrint1( L"Setup: FixupUserHive - Failed to create MiniSetupTemp\\Software\\Microsoft\\Windows\\CurrentVersion\\Run key (%d)", rc );
                                }


                            }

                        }



                        rc = RegUnLoadKey( HKEY_LOCAL_MACHINE,
                                           L"MiniSetupTemp" );

                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to unload %ws (%d)", HiveName, rc );
                        }

                    } else {
                        SetupDebugPrint2( L"Setup: FixupUserHive - Failed to load %ws (%d)", HiveName, rc );
                    }
                }
            } while( FindNextFile( FindHandle, &FileData ) );

        }

    } else {
        SetupDebugPrint( L"Setup: FixupUserHive - Failed to get Profiles path." );
    }

    return rc;

}


void LogPidValues()
{
    LONG rc;
    HKEY hkey = NULL;
    WCHAR RegProductId[MAX_PRODUCT_ID+1];
    BYTE  RegDigitalProductId[DIGITALPIDMAXLEN];
    DWORD Size;
    DWORD Type;

#ifdef PRERELEASE
    ValidateProductIDInReg();
#endif
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,0,KEY_READ,&hkey);
    if (rc == ERROR_SUCCESS)
    {
        *RegProductId = L'\0';
        Size = sizeof(RegProductId);
        rc = RegQueryValueEx(hkey,L"ProductId",NULL,&Type,(PBYTE)RegProductId,&Size);
        if (rc == ERROR_SUCCESS)
        {
            if (*RegProductId == L'\0')
            {
                SetupDebugPrint(L"LogPidValues: ProductId20FromProductId30 is empty\n");
            }
            else
            {
                SetupDebugPrint(L"LogPidValues: ProductId20FromProductId30 is NOT empty\n");
            }
        }
        else
        {
            SetupDebugPrint1(L"LogPidValues: RegQueryValueEx on ProductId failed. Error code:%d\n",rc);
        }
        *RegDigitalProductId = 0;
        Size = sizeof(RegDigitalProductId);
        rc = RegQueryValueEx(hkey,L"DigitalProductId",NULL,&Type,(PBYTE)RegDigitalProductId,&Size);
        if (rc == ERROR_SUCCESS)
        {
            if (*RegDigitalProductId == 0)
            {
                SetupDebugPrint(L"LogPidValues: DigitalProductId is empty\n");
            }
            else
            {
                SetupDebugPrint(L"LogPidValues: DigitalProductId is NOT empty\n");
            }
        }
        else
        {
            SetupDebugPrint1(L"LogPidValues: RegQueryValueEx on DigitalProductId failed. Error code:%d\n",rc);
        }
        RegCloseKey(hkey);
    }
    else
    {
        SetupDebugPrint1(L"LogPidValues: RegOpenKeyEx on %1 failed\n",WindowsCurrentVersionKeyName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\ps2ppg.c ===
#include "setupp.h"
#pragma hdrstop

#include <windowsx.h>

//
// PAGE_INFO and related Prototypes
//
typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    HKEY             hKeyDev;

    DWORD            enableWheelDetect;
    DWORD            sampleRate;
    DWORD            bufferLength;
    DWORD            mouseInitPolled;
} PAGE_INFO, * PPAGE_INFO;

PPAGE_INFO
PS2Mouse_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

void
PS2Mouse_DestroyPageInfo(
    PPAGE_INFO PageInfo
    );

//
// Function Prototypes
//
HPROPSHEETPAGE
PS2Mouse_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PPAGE_INFO       PageInfo
    );

UINT CALLBACK
PS2Mouse_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    );

INT_PTR
APIENTRY
PS2Mouse_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

void
PS2Mouse_InitializeControls(
    HWND        ParentHwnd,
    PPAGE_INFO  PageInfo
    );

void
PS2Mouse_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );

BOOL
PS2Mouse_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

INT_PTR
PS2Mouse_OnCtlColorStatic(
    HDC  DC,
    HWND Hwnd
    );

void
PS2Mouse_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
PS2Mouse_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
PS2Mouse_OnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr
    );

//
// Message macros for up down controls
//
#define UpDown_SetRange(hwndUD, nLower, nUpper)                 \
    (VOID) SendMessage((hwndUD), UDM_SETRANGE, (WPARAM) 0,      \
                       (LPARAM) MAKELONG((short) (nUpper), (short) (nLower)) )

#define UpDown_GetPos(hwndUD)                                   \
    (DWORD) SendMessage((hwndUD), UDM_GETPOS, (WPARAM) 0, (LPARAM) 0)

#define UpDown_SetPos(hwndUD, nPos)                             \
    (short) SendMessage((hwndUD), UDM_SETPOS, (WPARAM) 0,       \
                        (LPARAM) MAKELONG((short) (nPos), 0) )

#define UpDown_SetAccel(hwndUD, nCount, pAccels)                \
    (BOOL) SendMessage((hwndUD), UDM_SETACCEL, (WPARAM) nCount, \
                        (LPARAM) pAccels)

//
// Constants and strings
//
#define MOUSE_INIT_POLLED_DEFAULT 0

#define MAX_DETECTION_TYPES 3
#define WHEEL_DETECT_DEFAULT 2 // Default is now 2 for Beta3  /* 1 */

#define DATA_QUEUE_MIN      100
#define DATA_QUEUE_MAX      300
#define DATA_QUEUE_DEFAULT  100

#define SAMPLE_RATE_DEFAULT  100

const DWORD PS2Mouse_SampleRates[] =
{
    20,
    40,
    60,
    80,
    100,
    200
};

#define MAX_SAMPLE_RATES (sizeof(PS2Mouse_SampleRates)/sizeof(PS2Mouse_SampleRates[0]))

#define IDH_DEVMGR_MOUSE_ADVANCED_RATE      2002100
#define IDH_DEVMGR_MOUSE_ADVANCED_DETECT    2002110
#define IDH_DEVMGR_MOUSE_ADVANCED_BUFFER    2002120
#define IDH_DEVMGR_MOUSE_ADVANCED_INIT      2002130
#define IDH_DEVMGR_MOUSE_ADVANCED_DEFAULT   2002140

const DWORD PS2Mouse_HelpIDs[] = {
    IDC_SAMPLE_RATE,        IDH_DEVMGR_MOUSE_ADVANCED_RATE,
    IDC_WHEEL_DETECTION,    IDH_DEVMGR_MOUSE_ADVANCED_DETECT,
    IDC_BUFFER,             IDH_DEVMGR_MOUSE_ADVANCED_BUFFER,
    IDC_BUFFER_SPIN,        IDH_DEVMGR_MOUSE_ADVANCED_BUFFER,
    IDC_FAST_INIT,          IDH_DEVMGR_MOUSE_ADVANCED_INIT,
    IDC_DEFAULT,            IDH_DEVMGR_MOUSE_ADVANCED_DEFAULT,
    0, 0
    };

TCHAR szDevMgrHelp[] = L"devmgr.hlp";

TCHAR szMouseDataQueueSize[] =    L"MouseDataQueueSize";
TCHAR szSampleRate[] =            L"SampleRate";
TCHAR szEnableWheelDetection[] =  L"EnableWheelDetection";
TCHAR szMouseInitializePolled[] = L"MouseInitializePolled";
TCHAR szDisablePolledUI[] =       L"DisableInitializePolledUI";

PPAGE_INFO
PS2Mouse_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData)
{
    PPAGE_INFO tmp = (PPAGE_INFO) MyMalloc(sizeof(PAGE_INFO));

    if (!tmp) {
        return NULL;
    }

    tmp->deviceInfoSet = DeviceInfoSet;
    tmp->deviceInfoData = DeviceInfoData;

    tmp->hKeyDev =
        SetupDiOpenDevRegKey(DeviceInfoSet,
                             DeviceInfoData,
                             DICS_FLAG_GLOBAL,
                             0,
                             DIREG_DEV,
                             KEY_ALL_ACCESS);

    return tmp;
}

void
PS2Mouse_DestroyPageInfo(
    PPAGE_INFO PageInfo
    )
{
    if (PageInfo->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(PageInfo->hKeyDev);
    }

    MyFree(PageInfo);
}

HPROPSHEETPAGE
PS2Mouse_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PPAGE_INFO       PageInfo
    )
{
    //
    // Add the Port Settings property page
    //
    PropSheetPage->dwSize      = sizeof(PROPSHEETPAGE);
    PropSheetPage->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    PropSheetPage->hInstance   = MyModuleHandle;
    PropSheetPage->pszTemplate = MAKEINTRESOURCE(IDD_PROP_PAGE_PS2_MOUSE);

    //
    // following points to the dlg window proc
    //
    PropSheetPage->pfnDlgProc = PS2Mouse_DlgProc;
    PropSheetPage->lParam     = (LPARAM) PageInfo;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    PropSheetPage->pfnCallback = PS2Mouse_PropPageCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(PropSheetPage);
}

BOOL APIENTRY
PS2MousePropPageProvider(
    LPVOID               Info,
    LPFNADDPROPSHEETPAGE AddFunction,
    LPARAM               Lparam)
{
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PPAGE_INFO       ppi = NULL;
    ULONG devStatus, devProblem;
    CONFIGRET cr;

    ppr = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (ppr->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        ppi = PS2Mouse_CreatePageInfo(ppr->DeviceInfoSet, ppr->DeviceInfoData);

        if (!ppi) {
            return FALSE;
        }

        //
        // If this fails, it is most likely that the user does not have
        //  write access to the devices key/subkeys in the registry.
        //  If you only want to read the settings, then change KEY_ALL_ACCESS
        //  to KEY_READ in CreatePageInfo.
        //
        // Administrators usually have access to these reg keys....
        //
        if (ppi->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
            PS2Mouse_DestroyPageInfo(ppi);
            return FALSE;
        }

        //
        // Retrieve the status of this device instance.
        //
        cr = CM_Get_DevNode_Status(&devStatus,
                                   &devProblem,
                                   ppr->DeviceInfoData->DevInst,
                                   0);
        if ((cr == CR_SUCCESS) &&
            (devStatus & DN_HAS_PROBLEM) &&
            (devProblem & CM_PROB_DISABLED_SERVICE)) {
            //
            // If the controlling service has been disabled, do not show any
            // additional property pages.
            //
            return FALSE;
        }

        hpsp = PS2Mouse_CreatePropertyPage(&psp, ppi);

        if (!hpsp) {
            return FALSE;
        }

        if (!AddFunction(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
}

UINT CALLBACK
PS2Mouse_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    )
{
    PPAGE_INFO ppi;

    switch (Message) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) PropSheetPage->lParam;
        PS2Mouse_DestroyPageInfo(ppi);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}


INT_PTR
APIENTRY
PS2Mouse_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {
    case WM_COMMAND:
        PS2Mouse_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return PS2Mouse_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        PS2Mouse_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_CTLCOLORSTATIC:
        return PS2Mouse_OnCtlColorStatic((HDC) wParam, (HWND) lParam);

    case WM_INITDIALOG:
        return PS2Mouse_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return PS2Mouse_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
}

DWORD
PS2Mouse_GetSampleRateIndex(
    DWORD SampleRate
    )
{
    ULONG i;

    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        if (PS2Mouse_SampleRates[i] == SampleRate) {
            return i; 
        }
    }

    return 0;
}

void
PS2Mouse_OnDefault(
    HWND ParentHwnd,
    PPAGE_INFO PageInfo
    )
{
    UpDown_SetPos(GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN), DATA_QUEUE_DEFAULT);
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE),
                       PS2Mouse_GetSampleRateIndex(SAMPLE_RATE_DEFAULT));
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION), WHEEL_DETECT_DEFAULT);
    Button_SetCheck(GetDlgItem(ParentHwnd, IDC_FAST_INIT), !MOUSE_INIT_POLLED_DEFAULT);

    PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
}

void
PS2Mouse_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
    }
    else {
        switch (ControlId) {
        case IDC_DEFAULT:
            PS2Mouse_OnDefault(ParentHwnd, pageInfo);
            break;

        case IDC_FAST_INIT:
            PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
            break;
        }
    }
}

BOOL
PS2Mouse_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            szDevMgrHelp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) PS2Mouse_HelpIDs);

    return FALSE;
}

INT_PTR
PS2Mouse_OnCtlColorStatic(
    HDC  DC,
    HWND HStatic
    )
{
    UINT id = GetDlgCtrlID(HStatic);

    //
    // WM_CTLCOLORSTATIC is sent for the edit controls because they are read
    // only
    //
    if (id == IDC_BUFFER) {
        SetBkColor(DC, GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    }

    return FALSE;
}

void
PS2Mouse_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                szDevMgrHelp,
                HELP_WM_HELP,
                (ULONG_PTR) PS2Mouse_HelpIDs);
    }
}

BOOL
PS2Mouse_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    pageInfo = (PPAGE_INFO) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) pageInfo);

    PS2Mouse_InitializeControls(ParentHwnd, pageInfo);

    return TRUE;
}

void
PS2Mouse_OnApply(
    HWND        ParentHwnd,
    PPAGE_INFO  PageInfo
    )
{
    DWORD uiEnableWheelDetect, uiSampleRate, uiBufferLength, uiMouseInitPolled;
    int iSel;
    BOOL reboot = FALSE;

    uiEnableWheelDetect =
        ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION));
    uiBufferLength = UpDown_GetPos(GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN));
    uiMouseInitPolled = !Button_GetCheck(GetDlgItem(ParentHwnd, IDC_FAST_INIT));

    //
    // Must index the array as opposed to getting a real value
    //
    iSel = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE));
    if (iSel == CB_ERR) {
        uiSampleRate = PageInfo->sampleRate;
    }
    else {
        uiSampleRate = PS2Mouse_SampleRates[iSel];
    }

    //
    // See if anything has changed
    //
    if (uiEnableWheelDetect != PageInfo->enableWheelDetect) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szEnableWheelDetection,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiEnableWheelDetect,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiSampleRate != PageInfo->sampleRate) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szSampleRate,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiSampleRate,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiBufferLength != PageInfo->bufferLength) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szMouseDataQueueSize,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiBufferLength,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiMouseInitPolled) {
        //
        // make sure if it is nonzero that it is 1
        //
        uiMouseInitPolled = 1;
    }

    if (uiMouseInitPolled != PageInfo->mouseInitPolled) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szMouseInitializePolled,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiMouseInitPolled,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (reboot) {
        SP_DEVINSTALL_PARAMS   dip;

        ZeroMemory(&dip, sizeof(dip));
        dip.cbSize = sizeof(dip);

        SetupDiGetDeviceInstallParams(PageInfo->deviceInfoSet,
                                      PageInfo->deviceInfoData,
                                      &dip);

        dip.Flags |= DI_NEEDREBOOT;

        SetupDiSetDeviceInstallParams(PageInfo->deviceInfoSet,
                                      PageInfo->deviceInfoData,
                                      &dip);
    }
}

BOOL
PS2Mouse_OnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (NmHdr->code) {

    //
    // The user is about to change an up down control
    //
    case UDN_DELTAPOS:
        PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
        return FALSE;

    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Write out the com port options to the registry
        //
        PS2Mouse_OnApply(ParentHwnd, pageInfo);
        SetWindowLongPtr(ParentHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

    default:
        return FALSE;
    }
}

DWORD
PS2Mouse_SetupSpinner(
    HKEY  Hkey,
    HWND  SpinnerHwnd,
    TCHAR ValueName[],
    short MinVal,
    short MaxVal,
    short DefaultVal,
    short IncrementVal
    )
{
    DWORD dwValue, dwSize;
    UDACCEL accel;

    UpDown_SetRange(SpinnerHwnd, MinVal, MaxVal);
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        ValueName,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = DefaultVal;
    }
    if (((short) dwValue) < MinVal || ((short) dwValue) > MaxVal) {
        dwValue = DefaultVal;
    }

    if (dwValue % IncrementVal) {
        //
        // Set the value to a good one and return the one we took out of the
        // registry.  When the user applies the changes the value in the control
        // will be different and we will write the value out
        //
        UpDown_SetPos(SpinnerHwnd, dwValue - (dwValue % IncrementVal));
    }
    else {
        UpDown_SetPos(SpinnerHwnd, dwValue);
    }

    accel.nSec = 0;
    accel.nInc = IncrementVal;
    UpDown_SetAccel(SpinnerHwnd, 1, &accel);

    return dwValue;
}

DWORD
PS2Mouse_SetupSampleRate(
    HWND        ComboBoxHwnd,
    HKEY        Hkey
    )
{
    int     i;
    DWORD   dwValue, dwSize;
    BOOL    badValue = FALSE;
    TCHAR   szValue[32];

    //
    // First setup the cb, then find the correct selection
    //
    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        wsprintf(szValue, TEXT("%d"), PS2Mouse_SampleRates[i]);
        ComboBox_AddString(ComboBoxHwnd, szValue);
    }

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szSampleRate,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = SAMPLE_RATE_DEFAULT;
        badValue = TRUE;
    }

    //
    // Assume the value is wrong
    //
    badValue = TRUE;
    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        if (PS2Mouse_SampleRates[i] == dwValue) {
            badValue = FALSE;
            break;
        }
    }

    if (badValue) {
        dwValue = SAMPLE_RATE_DEFAULT;
    }

    ComboBox_SetCurSel(ComboBoxHwnd, PS2Mouse_GetSampleRateIndex(dwValue));

    if (badValue) {
        return 0xffffffff;
    }
    else {
        return dwValue;
    }
}

DWORD
PS2Mouse_SetupWheelDetection(
    HWND        ComboBoxHwnd,
    HKEY        Hkey
    )
{
    int     i;
    DWORD   dwValue, dwSize;
    BOOL    badValue = FALSE;
    TCHAR   szDescription[80];
    UINT    stringIDs[MAX_DETECTION_TYPES] = {
                IDS_PS2_DETECTION_DISABLED,
                IDS_PS2_DETECTION_LOOK,
                IDS_PS2_DETECTION_ASSUME_PRESENT
            };

    //
    // First setup the cb, then find the correct selection
    //
    for (i = 0; i < MAX_DETECTION_TYPES; i++) {
        LoadString(MyModuleHandle,
                   stringIDs[i],
                   szDescription,
                   sizeof(szDescription) / sizeof(TCHAR));
        ComboBox_AddString(ComboBoxHwnd, szDescription);
    }

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szEnableWheelDetection,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = WHEEL_DETECT_DEFAULT;
        badValue = TRUE;
    }

    if (dwValue > 2) {
        dwValue = WHEEL_DETECT_DEFAULT;
        badValue = TRUE;
    }

    ComboBox_SetCurSel(ComboBoxHwnd, dwValue);

    if (badValue) {
        return 0xffffffff;
    }
    else {
        return dwValue;
    }
}

ULONG
PSMouse_SetupFastInit(
    HWND CheckBoxHwnd,
    HKEY Hkey
    )
{
    DWORD dwSize, dwValue, dwDisable = FALSE;
    BOOL  badValue = FALSE;

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szMouseInitializePolled,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = MOUSE_INIT_POLLED_DEFAULT;
        badValue = TRUE;
    }

    //
    // Make sure the value is 1 or 0.  If it is nonzero and not 1, it is assumed
    // to be 1
    //
    if (dwValue != 0 && dwValue != 1) {
        dwValue = 1;
        badValue = TRUE;
    }

    //
    // This is a bit confusing.  The UI has fast initialization, but underneath
    // it is represented as initialize polled which is fast when it is false,
    // but we must show true to the user
    //
    Button_SetCheck(CheckBoxHwnd, !dwValue);

    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szDisablePolledUI,
                        0,
                        NULL,
                        (PBYTE) &dwDisable,
                        &dwSize) == ERROR_SUCCESS &&
        dwDisable != FALSE) {
        EnableWindow(CheckBoxHwnd, FALSE);
    }

    if (badValue) {
        return -1;
    }
    else {
        return dwValue;
    }
}

void
PS2Mouse_InitializeControls(
    HWND       ParentHwnd,
    PPAGE_INFO PageInfo
    )
{
    HKEY        hKey;
    HWND        hwnd;
    DWORD       dwValue, dwSize;
    int         i;

    if (PageInfo->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
        //
        // Disable all of the controls
        //
        return;
    }

    PageInfo->bufferLength =
        PS2Mouse_SetupSpinner(PageInfo->hKeyDev,
                              GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN),
                              szMouseDataQueueSize,
                              DATA_QUEUE_MIN,
                              DATA_QUEUE_MAX,
                              DATA_QUEUE_DEFAULT,
                              10);

    PageInfo->sampleRate =
        PS2Mouse_SetupSampleRate(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE),
                                 PageInfo->hKeyDev);

    PageInfo->enableWheelDetect =
        PS2Mouse_SetupWheelDetection(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION),
                                     PageInfo->hKeyDev);

    PageInfo->mouseInitPolled =
        PSMouse_SetupFastInit(GetDlgItem(ParentHwnd, IDC_FAST_INIT),
                              PageInfo->hKeyDev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\repair.c ===
#include "setupp.h"
#pragma hdrstop


#define SYSTEM_HIVE             (LPWSTR)L"system"
#define SOFTWARE_HIVE           (LPWSTR)L"software"
#define SECURITY_HIVE           (LPWSTR)L"security"
#define SAM_HIVE                (LPWSTR)L"sam"
#define DEFAULT_USER_HIVE       (LPWSTR)L".default"
#define DEFAULT_USER_HIVE_FILE  (LPWSTR)L"default"
#define NTUSER_HIVE_FILE        (LPWSTR)L"ntuser.dat"
#define REPAIR_DIRECTORY        (LPWSTR)L"\\repair"
#define SETUP_LOG_FILE          (LPWSTR)L"setup.log"

#define NTUSER_COMPRESSED_FILE_NAME     ( LPWSTR )L"ntuser.da_"
#define AUTOEXEC_NT_FILE_NAME           ( LPWSTR )L"autoexec.nt"
#define CONFIG_NT_FILE_NAME             ( LPWSTR )L"config.nt"

//
// Relative costs to perform various actions,
// to help make the gas gauge mean something.
//
#define COST_SAVE_HIVE      3
#define COST_COMPRESS_HIVE  20
#define COST_SAVE_VDM_FILE  1


//
//  Structure used in the array of hives to be saved.
//  This structure contains the predefined key that contains the hive
//  to be saved, and the name of the hive root, and the name of the file
//  where the hive should be saved.
//

typedef struct _HIVE_INFO {
    HKEY            PredefinedKey;
    PWSTR           HiveName;
    PWSTR           FileName;
    } HIVE_INFO, *PHIVE_INFO;


//
//  The array below contains the location and name of all hives that
//  we need to save. When the utility is operating on the silent mode,
//  (invoked from setup), then all hives will be saved. Otherwise, only
//  system and software will be saved.
//  For this reason, do not change the order of the hives in the array
//  below. System and software must be the first elements of
//  the array.
//
static
HIVE_INFO   HiveList[] = {
    { HKEY_LOCAL_MACHINE, SYSTEM_HIVE,       SYSTEM_HIVE },
    { HKEY_LOCAL_MACHINE, SOFTWARE_HIVE,     SOFTWARE_HIVE },
    { HKEY_USERS,         DEFAULT_USER_HIVE, DEFAULT_USER_HIVE_FILE },
    { HKEY_LOCAL_MACHINE, SECURITY_HIVE,     SECURITY_HIVE },
    { HKEY_LOCAL_MACHINE, SAM_HIVE,          SAM_HIVE }
};

static
PWSTR   VdmFiles[] = {
    AUTOEXEC_NT_FILE_NAME,
    CONFIG_NT_FILE_NAME
};


DWORD
SaveOneHive(
    IN     LPWSTR DirectoryName,
    IN     LPWSTR HiveName,
    IN     HKEY   hkey,
    IN     HWND   hWnd,
    IN OUT PDWORD GaugePosition,
    IN     DWORD  GaugeDeltaUnit
    )

/*++

Routine Description:

    Save one registry hive.  The way we will do this is to do a RegSaveKey
    of the hive into a temporary localtion, and then call the LZ apis to
    compress the file from that temporary location to the floppy.

    LZ must have already been initialized via InitGloablBuffersEx()
    BEFORE calling this routine.

Arguments:

    DirectoryName - Full path of the directory where the hive will be saved.

    HiveName - base name of the hive file to save.  The file will end up
               compressed on disk with the name <HiveName>._.

    hkey - supplies handle to open key of root of hive to save.

    GaugePosition - in input, supplies current position of the gas gauge.
        On output, supplies new position of gas gauge.

    GaugeDeltaUnit - supplies cost of one unit of activity.

Return Value:

    DWORD - Return ERROR_SUCCESS if the hive was saved. Otherwise, it returns
            an error code.

--*/

{
    DWORD Status;
    WCHAR SaveFilename[ MAX_PATH + 1 ];
    WCHAR CompressPath[ MAX_PATH + 1 ];
    CHAR SaveFilenameAnsi[ MAX_PATH + 1 ];
    CHAR CompressPathAnsi[ MAX_PATH + 1 ];
    LPWSTR TempName = ( LPWSTR )L"\\$$hive$$.tmp";

    //
    // Create the name of the file into which we will save the
    // uncompressed hive.
    //

    wsprintf(SaveFilename,L"%ls\\%ls.",DirectoryName,HiveName);
    wsprintfA(SaveFilenameAnsi,"%ls\\%ls.",DirectoryName,HiveName);

    //
    // Delete the file just in case, because RegSaveKey will fail if the file
    // already exists.
    //
    SetFileAttributes(SaveFilename,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(SaveFilename);

    //
    // Save the registry hive into the temporary file.
    //
    Status = RegSaveKey(hkey,SaveFilename,NULL);

    //
    //  Update the gas gauge.
    //
    *GaugePosition += GaugeDeltaUnit * COST_SAVE_HIVE;
    SendMessage(
        hWnd,
        PBM_SETPOS,
        *GaugePosition,
        0L
        );

    //
    //  If the hive was saved successfully, then delete the old compressed
    //  one if it happens to be there.
    //

    if(Status == ERROR_SUCCESS) {
        //
        // Form the name of the file into which the saved hive file is
        // to be compressed.
        //
        wsprintf(CompressPath,L"%ls\\%ls._",DirectoryName,HiveName);
        wsprintfA(CompressPathAnsi,"%ls\\%ls._",DirectoryName,HiveName );

        //
        // Delete the destination file just in case.
        //
        SetFileAttributes(CompressPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompressPath);
    }

    return(Status);
}

VOID
SaveRepairInfo(
    IN  HWND    hWnd,
    IN  ULONG   StartAtPercent,
    IN  ULONG   StopAtPercent
    )

/*++

Routine Description:

    This routine implements the thread that saves all system configuration
    files into the repair directory. It first saves and compresses the
    registry hives, and then it save the VDM configuration files (autoexec.nt
    and config.nt).
    If the application is running in the SilentMode (invoked by setup),
    then system, software, default, security and sam hives will be saved
    and compressed.
    If the application was invoked by the user, then only system, software
    and default will be saved.

    This thread will send messages to the gas gauge dialog prcedure, so that
    the gas gauge gets updated after each configuration file is saved.
    This thread will also inform the user about errors that might have
    occurred during the process of saving the configuration files.

Arguments:

    hWnd - handle to progress gauge

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).

Return Value:

    None.
    However, the this routine will send a message to the dialog procedure
    that created the thread, informing the outcome the operation.

--*/

{
    DWORD    i;
    HKEY     hkey;
    BOOL     ErrorOccurred;
    CHAR     SourceUserHivePathAnsi[ MAX_PATH + 1 ];
    CHAR     UncompressedUserHivePathAnsi[ MAX_PATH + 1 ];
    CHAR     CompressedUserHivePathAnsi[ MAX_PATH + 1 ];
    WCHAR    ProfilesDirectory[ MAX_PATH + 1 ];
    WCHAR    RepairDirectory[ MAX_PATH + 1 ];
    WCHAR    SystemDirectory[ MAX_PATH + 1 ];
    WCHAR    Source[ MAX_PATH + 1 ];
    WCHAR    Target[ MAX_PATH + 1 ];
    DWORD    GaugeDeltaUnit;
    DWORD    GaugeTotalCost;
    DWORD    GaugeRange;
    DWORD    GaugePosition;
    DWORD    NumberOfHivesToSave;
    DWORD    NumberOfUserHivesToSave;
    DWORD    NumberOfVdmFiles;
    DWORD    dwSize;
    DWORD    Error;
    DWORD    Status;
    HANDLE   Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID     Luid;


    Error = ERROR_SUCCESS;

    ErrorOccurred = FALSE;
    //
    //  Compute the cost of saving the hives and vdm files.
    //  For every hive we save, we have to save a key into a file and then
    //  compress the file. After each of these tasks is completed, we upgrade
    //  the gas gauge by the amount dicated by the COST_xxx values.
    //  The cost of saving the hives depends on the mode that the utility is
    //  running.
    //
    NumberOfHivesToSave = sizeof( HiveList ) / sizeof( HIVE_INFO );

    NumberOfUserHivesToSave = 1;
    NumberOfVdmFiles = sizeof( VdmFiles ) / sizeof( PWSTR );

    GaugeTotalCost = (COST_SAVE_HIVE * NumberOfHivesToSave)
                   + (COST_SAVE_VDM_FILE * NumberOfVdmFiles);

    GaugeRange = (GaugeTotalCost*100/(StopAtPercent-StartAtPercent));
    GaugeDeltaUnit = 1;
    GaugePosition = GaugeRange*StartAtPercent/100;
    SendMessage(hWnd, WMX_PROGRESSTICKS, GaugeTotalCost, 0);
    SendMessage(hWnd,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(hWnd,PBM_SETPOS,GaugePosition,0);

    //
    //  Enable BACKUP privilege
    //
    if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {

        if(LookupPrivilegeValue(NULL,SE_BACKUP_NAME,&Luid)) {

            NewPrivileges.PrivilegeCount = 1;
            NewPrivileges.Privileges[0].Luid = Luid;
            NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            AdjustTokenPrivileges(Token,FALSE,&NewPrivileges,0,NULL,NULL);
        }
    }

    Status = GetWindowsDirectory( RepairDirectory, sizeof( RepairDirectory ) / sizeof( WCHAR ) );
    if( Status == 0) {
        MYASSERT(FALSE);
        return;
    }
    lstrcat( RepairDirectory, REPAIR_DIRECTORY );

    dwSize = MAX_PATH + 1;
    GetDefaultUserProfileDirectoryW (ProfilesDirectory, &dwSize);

    GetSystemDirectory( SystemDirectory, sizeof( SystemDirectory ) / sizeof( WCHAR ) );

    //
    //  Make sure that the repair directory already exists.
    //  If it doesn't exist, then create one.
    //
    if( CreateDirectory( RepairDirectory, NULL )  ||
        ( ( Error = GetLastError() ) == ERROR_ALREADY_EXISTS ) ||
        ( Error == ERROR_ACCESS_DENIED )
      ) {
        //
        //  If the repair directory didn't exist and we were able to create it,
        //  or if the repair directory already exists, then save and compress
        //  the hives.
        //

        Error = ERROR_SUCCESS;
        for( i=0; i < NumberOfHivesToSave; i++ ) {
            //
            //  First open the root of the hive to be saved
            //
            Status = RegOpenKeyEx( HiveList[i].PredefinedKey,
                                   HiveList[i].HiveName,
                                   REG_OPTION_RESERVED,
                                   READ_CONTROL,
                                   &hkey );

            //
            //  If unable to open the key, update the gas gauge to reflect
            //  that the operation on this hive was completed.
            //  Otherwise, save the hive. Note that Save hive will update
            //  the gas gauge, as it saves and compresses the hive.
            //
            if(Status != ERROR_SUCCESS) {
                //
                // If this is the first error while saving the hives,
                // then save the error code, so that we can display the
                // correct error message to the user.
                //
                if( Error == ERROR_SUCCESS ) {
                    Error = Status;
                }

                //
                // Update the gas gauge
                //
                GaugePosition += GaugeDeltaUnit * (COST_SAVE_HIVE + COST_COMPRESS_HIVE);
                SendMessage( hWnd,
                             PBM_SETPOS,
                             GaugePosition,
                             0L );

            } else {
                //
                //  Save and compress the hive.
                //  Note that the gas gauge will up be updated by SaveOneHive
                //  Note also that when we save the default user hive, we skip
                //  the first character of the
                //

                Status = SaveOneHive(RepairDirectory,
                                     HiveList[i].FileName,
                                     hkey,
                                     hWnd,
                                     &GaugePosition,
                                     GaugeDeltaUnit );
                //
                // If this is the first error while saving the hives,
                // then save the error code, so that we can display the
                // correct error message to the user.
                //

                if( Error == ERROR_SUCCESS ) {
                    Error = Status;
                }

                RegCloseKey(hkey);
            }
        }

        //
        //  Save the hive for the Default User
        //

        wsprintfA(SourceUserHivePathAnsi,"%ls\\%ls",ProfilesDirectory,NTUSER_HIVE_FILE);
        wsprintfA(UncompressedUserHivePathAnsi,"%ls\\%ls",RepairDirectory,NTUSER_HIVE_FILE);
        wsprintfA(CompressedUserHivePathAnsi,  "%ls\\%ls",RepairDirectory,NTUSER_COMPRESSED_FILE_NAME);


        Status = CopyFileA (
            SourceUserHivePathAnsi,
            UncompressedUserHivePathAnsi,
            FALSE);

        if(Status) {
            //
            // Delete the destination file just in case.
            //
            SetFileAttributesA(CompressedUserHivePathAnsi,FILE_ATTRIBUTE_NORMAL);
            DeleteFileA(CompressedUserHivePathAnsi);
        } else if(Error == ERROR_SUCCESS) {
            //
            // If this is the first error, remember it.
            //
            Error = GetLastError();
        }

        //
        // Now that the hives are saved, save the vdm files
        //

        for( i = 0; i < NumberOfVdmFiles; i++ ) {
            wsprintf(Source,L"%ls\\%ls",SystemDirectory,VdmFiles[i]);
            wsprintf(Target,L"%ls\\%ls",RepairDirectory,VdmFiles[i]);
            if( !CopyFile( Source, Target, FALSE ) ) {
                Status = GetLastError();
                if( Error != ERROR_SUCCESS ) {
                    Error = Status;
                }
            }
            GaugePosition += GaugeDeltaUnit * COST_SAVE_VDM_FILE;
            SendMessage( ( HWND )hWnd,
                         PBM_SETPOS,
                         GaugePosition,
                         0L );

        }
    }

    if( Error != ERROR_SUCCESS ) {
        SetupDebugPrint1( L"SETUP: SaveRepairInfo() failed.  Error = %d", Error );
    }

    //
    // Set security on all the files.
    //
    ApplySecurityToRepairInfo();

    //
    // At this point, the operation was completed (successfully, or not).
    // So update the gas gauge to 100%
    //
    GaugePosition = GaugeRange*StopAtPercent/100;
    SendMessage(hWnd,PBM_SETPOS,GaugePosition,0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\sacchan.c ===
#include <setupp.h>

DEFINE_GUID(
    SAC_CHANNEL_GUI_MODE_DEBUG_GUID,
    0x5ed3bac7, 0xa2f9, 0x4e45, 0x98, 0x75, 0xb2, 0x59, 0xea, 0x3f, 0x29, 0x1f
    );

DEFINE_GUID(
    SAC_CHANNEL_GUI_MODE_ERROR_LOG_GUID,
    0x773d2759, 0x19b8, 0x4d6e, 0x80, 0x45, 0x26, 0xbf, 0x38, 0x40, 0x22, 0x52
    );

DEFINE_GUID(
    SAC_CHANNEL_GUI_MODE_ACTION_LOG_GUID,
    0xd37c67ba, 0x89e7, 0x44ba, 0xae, 0x5a, 0x11, 0x2c, 0x68, 0x06, 0xb0, 0xdd
    );

//
// The GUI-mode channels
//
SAC_CHANNEL_HANDLE  SacChannelGuiModeDebugHandle; 
BOOL                SacChannelGuiModeDebugEnabled = FALSE;
SAC_CHANNEL_HANDLE  SacChannelActionLogHandle;
BOOL                SacChannelActionLogEnabled = FALSE;
SAC_CHANNEL_HANDLE  SacChannelErrorLogHandle;
BOOL                SacChannelErrorLogEnabled = FALSE;

PUCHAR   Utf8ConversionBuffer       = NULL;
ULONG    Utf8ConversionBufferSize   = 0;

//
// Define the max # of Unicode chars that can be translated with the
// given size of the utf8 translation buffer
//
#define MAX_UTF8_ENCODE_BLOCK_LENGTH ((Utf8ConversionBufferSize / 3) - 1)

VOID
SacChannelInitialize(
    VOID
    )
/*++

Routine Description:

    This routine creates and initializes all the GUI-mode channels

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL                        bSuccess;
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    //
    //
    Utf8ConversionBufferSize = 512*3+3;
    Utf8ConversionBuffer = malloc(Utf8ConversionBufferSize);
    if (Utf8ConversionBuffer == NULL) {
        return;
    }

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type = ChannelTypeRaw;
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_DEBUG_NAME, Attributes.Name, ARRAYSIZE(Attributes.Name)) ) {
        Attributes.Name[0] = L'\0';
    }
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_DEBUG_DESCRIPTION, Attributes.Description, ARRAYSIZE(Attributes.Description)) ) {
        Attributes.Description[0] = L'\0';
    }
    Attributes.ApplicationType = SAC_CHANNEL_GUI_MODE_DEBUG_GUID;

    //
    // Create a channel for the GUI Mode Debug spew
    //
    bSuccess = SacChannelOpen(
        &SacChannelGuiModeDebugHandle, 
        &Attributes
        );


    if (bSuccess) {
        
        //
        // We can now use this channel
        //
        SacChannelGuiModeDebugEnabled = TRUE;
    
        SetupDebugPrint(L"Successfully opened GuiModeDebug channel\n");
        
    } else {
        SetupDebugPrint(L"Failed to open GuiModeDebug channel\n");
    }

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type = ChannelTypeRaw;
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_ACTION_LOG_NAME, Attributes.Name, ARRAYSIZE(Attributes.Name)) ) {
        Attributes.Name[0] = L'\0';
    }
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_ACTION_LOG_DESCRIPTION, Attributes.Description, ARRAYSIZE(Attributes.Description)) ) {
        Attributes.Description[0] = L'\0';
    }
    Attributes.ApplicationType = SAC_CHANNEL_GUI_MODE_ACTION_LOG_GUID;
    
    //
    // Create a channel for the Action Log spew
    //
    bSuccess = SacChannelOpen(
        &SacChannelActionLogHandle, 
        &Attributes
        );


    if (bSuccess) {
        
        //
        // We can now use this channel
        //
        SacChannelActionLogEnabled = TRUE;

        SetupDebugPrint(L"Successfully opened ActionLog channel\n");
    
    } else {
        SetupDebugPrint(L"Failed to open ActionLog channel\n");
    }
    

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type = ChannelTypeRaw;
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_ERROR_LOG_NAME, Attributes.Name, ARRAYSIZE(Attributes.Name)) ) {
        Attributes.Name[0] = L'\0';
    }
    if( !LoadString(MyModuleHandle, IDS_SAC_GUI_MODE_ERROR_LOG_DESCRIPTION, Attributes.Description, ARRAYSIZE(Attributes.Description)) ) {
        Attributes.Description[0] = L'\0';
    }
    Attributes.ApplicationType = SAC_CHANNEL_GUI_MODE_ERROR_LOG_GUID;

    //
    // Create a channel for the Error Log spew
    //
    bSuccess = SacChannelOpen(
        &SacChannelErrorLogHandle, 
        &Attributes
        );

    if (bSuccess) {
        
        //
        // We can now use this channel
        //
        SacChannelErrorLogEnabled = TRUE;
    
        SetupDebugPrint(L"Successfully opened ErrorLog channel\n");
        
    } else {
        SetupDebugPrint(L"Failed to open ErrorLog channel\n");
    }

}

VOID
SacChannelTerminate(
    VOID
    )
/*++

Routine Description:

    This routine closes all the GUI-mode setup channels

Arguments:

    None

Return Value:

    None

--*/
{

    //
    // If the channel is enabled,
    // then attempt to close it
    //
    if (SacChannelActionLogEnabled) {
    
        //
        // This channel is no longer available
        //
        SacChannelActionLogEnabled = FALSE;

        //
        // Attempt to close the channel
        //
        if (SacChannelClose(&SacChannelActionLogHandle)) {
            SetupDebugPrint(L"Successfully closed ActionLog channel\n");
        } else {
            SetupDebugPrint(L"Failed to close ActionLog channel\n");
        }
    
    }
    
    //
    // If the channel is enabled,
    // then attempt to close it
    //
    if (SacChannelErrorLogEnabled) {
        
        //
        // This channel is no longer available
        //
        SacChannelErrorLogEnabled = FALSE;    
        
        //
        // Attempt to close the channel
        //
        if (SacChannelClose(&SacChannelErrorLogHandle)) {
            SetupDebugPrint(L"Successfully closed ErrorLog channel\n");
        } else {
            SetupDebugPrint(L"Failed to close ErrorLog channel\n");
        }

    }

    //
    // If the channel is enabled,
    // then attempt to close it
    //
    if (SacChannelGuiModeDebugEnabled) {

        //
        // This channel is no longer available
        //
        SacChannelGuiModeDebugEnabled = FALSE;

        //
        // Attempt to close the channel
        //
        if (SacChannelClose(&SacChannelGuiModeDebugHandle)) {
            SetupDebugPrint(L"Successfully closed GuiModeDebug channel\n");
        } else {
            SetupDebugPrint(L"Failed to close GuiModeDebug channel\n");
        }
    
    }

    //
    // free the conversion buffer if necessary
    //
    if (Utf8ConversionBuffer != NULL) {
        free(Utf8ConversionBuffer);
        Utf8ConversionBuffer = NULL;
        Utf8ConversionBufferSize = 0;
    }

}

#if 0
BOOL
CopyAndInsertStringAtInterval(
    IN  PSTR     SourceStr,
    IN  ULONG    Interval,
    IN  PSTR     InsertStr,
    OUT PSTR     *pDestStr
    )
/*++

Routine Description:

    This routine takes a source string and inserts an 
    "interval string" at interval characters in the new
    destination string.
    
    Note: caller is responsible for releasing DestStr if successful      
          
    ex:
    
    src "aaabbbccc"
    interval string = "XYZ"
    interval = 3
                       
    ==> dest string == "aaaXYZbbbXYZccc"

Arguments:
    
    SourceStr   - the source string
    Interval    - spanning interval
    InsertStr   - the insert string
    DestStr     - the destination string    

Return Value:

    Status

--*/
{
    ULONG   SrcLength;
    ULONG   DestLength;
    ULONG   DestSize;
    ULONG   InsertLength;
    ULONG   k;
    ULONG   l;
    ULONG   i;
    PSTR    DestStr;
    ULONG   IntervalCnt;

    ASSERT(SourceStr); 
    ASSERT(Interval > 0); 
    ASSERT(InsertStr); 
    ASSERT(pDestStr > 0); 

    //
    // the length of the insert string
    //
    InsertLength = strlen(InsertStr);
    
    //
    // Compute how large the destination string needs to be,
    // including the source string and the interval strings.
    //
    // Note: if the srclength is an integer multiple of Interval
    //       then we need to subtract 1 from the # of partitions
    //
    SrcLength = strlen(SourceStr);
    IntervalCnt = SrcLength / Interval;
    if (SrcLength % Interval == 0) {
        IntervalCnt = IntervalCnt > 0 ? IntervalCnt - 1 : IntervalCnt;
    }
    DestLength = SrcLength + (IntervalCnt * strlen(InsertStr));
    DestSize = (DestLength + 1) * sizeof(UCHAR);

    //
    // Allocate the new destination string
    //
    DestStr = LocalAlloc(LPTR, DestSize);
    if (!DestStr) {
        return FALSE;
    }
    RtlZeroMemory(DestStr, DestSize);

    //
    // Initialize the pointers into the source and destination strings
    //
    l = 0;
    i = 0;

    do {

        //
        // k = # of characters to copy
        //
        // if Interval > # of characters left to copy,
        // then k = # of characters left to copy
        // else k = interval
        // 
        k = Interval > (SrcLength - i) ? (SrcLength - i) : Interval;
        
        //
        // Copy k charactars to the destination buffer
        //
        strncpy(
            &DestStr[l],
            &SourceStr[i],
            k
            );

        //
        // Account for how many characters we just copied
        //
        l += k;
        i += k;

        //
        // If there are any characters left to copy, 
        // then we need to insert the InsertString 
        // That is, we are at an interval.
        //
        if (i < SrcLength) {
            
            //
            // Insert the specified string at the interval
            //
            strcpy(
                &DestStr[l],
                InsertStr
                );

            //
            // Account for how many characters we just copied
            //
            l += InsertLength;
        
        }

    } while ( i < SrcLength);

    //
    //
    //
    ASSERT(i == SrcLength);
    ASSERT(l == DestLength);
    ASSERT((l + 1) * sizeof(UCHAR) == DestSize);

    //
    // Send back the destination string
    //
    *pDestStr = DestStr;

    return TRUE;
}

BOOL
SacChannelWrappedWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    )
/*++

Routine Description:

    This routine takes a string and makes it wrap at 80 cols
    and then sends the new string to the specified channel.
    
Arguments:

    SacChannelHandle     - the channel reference to received the data
    Buffer               - the string
    BufferSize           - the string size                                                           
                                                           
Return Value:

--*/
{
    BOOL    bSuccess;
    PSTR    OutStr;

    UNREFERENCED_PARAMETER(BufferSize);

    bSuccess = CopyAndInsertStringAtInterval(
        Buffer,
        80,
        "\r\n",
        &OutStr
        );

    if (bSuccess) {

        bSuccess = SacChannelRawWrite(
            SacChannelHandle,
            OutStr,
            strlen(OutStr)*sizeof(UCHAR)
            );

        LocalFree(OutStr);

    }

    return bSuccess;
}
#endif

BOOLEAN
SacTranslateUnicodeToUtf8(
    IN  PCWSTR   SourceBuffer,
    IN  ULONG    SourceBufferLength,
    IN  PUCHAR   DestinationBuffer,
    IN  ULONG    DestinationBufferSize,
    OUT PULONG   UTF8Count,
    OUT PULONG   ProcessedCount
    )
/*++

Routine Description:

    This routine translates a Unicode string into a UFT8
    encoded string.

    Note: if the destination buffer is not large enough to hold
          the entire encoded UFT8 string, then it will contain
          as much as can fit.
          
    TODO: this routine should return some notification if
          the entire Unicode string was not encoded.       
              
Arguments:

    SourceBuffer            - the source Unicode string
    SourceBufferLength      - the # of characters the caller wants to translate
                              note: a NULL termination overrides this 
    DestinationBuffer       - the destination for the UTF8 string
    DestinationBufferSize   - the size of the destination buffer                 
    UTF8Count               - on exit, contains the # of resulting UTF8 characters
    ProcessedCount          - on exit, contains the # of processed Unicode characters
                   
Return Value:

    Status

--*/
{
    
    //
    // Init
    //
    *UTF8Count = 0;
    *ProcessedCount = 0;

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    
    //
    // Process until one of the specified conditions is met
    //
    while (*SourceBuffer && 
           (*UTF8Count < DestinationBufferSize) &&
           (*ProcessedCount < SourceBufferLength)
           ) {

        if( (*SourceBuffer & 0xFF80) == 0 ) {
            
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0x7F);
        
        } else if( (*SourceBuffer & 0xF800) == 0 ) {
            
            //
            // see if we pass the end of the buffer
            //
            if ((*UTF8Count + 2) >= DestinationBufferSize) {
                break;
            }
            
            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        
        } else {
            
            //
            // see if we pass the end of the buffer
            //
            if ((*UTF8Count + 3) >= DestinationBufferSize) {
                break;
            }
            
            //
            // encode as 3 bytes
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 12) & 0xF) | 0xE0;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 6) & 0x3F) | 0x80;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;

        }
        
        //
        // Advance the # of characters processed
        //
        (*ProcessedCount)++;
        
        //
        // Advanced to the next character to process
        //
        SourceBuffer += 1;
    
    }

    //
    // Sanity checks
    //
    ASSERT(*ProcessedCount <= SourceBufferLength);
    ASSERT(*UTF8Count <= DestinationBufferSize);

    return(TRUE);

}

BOOL
SacChannelUnicodeWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWSTR               String
    )
/*++

Routine Description:

    This is a wrapper routine for sending data to a channel.  That is,
    we can use this routine to modify the string before we send it off
    without having to modify the callers.
    
    This is a convenience routine to simplify
    UFT8 encoding and sending a Unicode string.
    
Arguments:

    Channel - Previously created channel.
    String  - Output string.
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    BOOL        bStatus;
    ULONG       Length;
    ULONG       i;
    ULONG       k;
    ULONG       j;
    ULONG       TranslatedCount;
    ULONG       UTF8TranslationSize;
    PCWSTR      pwch;

    ASSERT(String);
    
    //
    // Determine the total # of WCHARs to process
    //
    Length = wcslen(String);

    //
    // Do nothing if there is nothing to do
    //
    if (Length == 0) {
        return TRUE;
    }

    //
    // Point to the beginning of the string
    //
    pwch = (PCWSTR)String;

    //
    // default:
    //
    bStatus = TRUE;

    //
    // Divide the incoming buffer into blocks of length
    // MAX_UTF8_ENCODE_BLOCK_LENGTH.  
    //
    do {

        //
        // Determine the remainder 
        //
        k = Length % MAX_UTF8_ENCODE_BLOCK_LENGTH;

        if (k > 0) {
            
            //
            // Translate the first k characters
            //
            bStatus = SacTranslateUnicodeToUtf8(
                pwch,
                k,
                Utf8ConversionBuffer,
                Utf8ConversionBufferSize,
                &UTF8TranslationSize,
                &TranslatedCount
                );

            //
            // If this assert hits, it is probably caused by
            // a premature NULL termination in the incoming string
            //
            ASSERT(k == TranslatedCount);

            if (!bStatus) {
                break;
            }

            //
            // Send the UTF8 encoded characters
            //
            bStatus = SacChannelRawWrite(
                SacChannelHandle,
                Utf8ConversionBuffer,
                UTF8TranslationSize
                );

            if (! bStatus) {
                break;
            }
            
            //
            // Adjust the pwch to account for the sent length
            //
            pwch += k;

        }
        
        //
        // Determine the # of blocks we can process
        //
        j = Length / MAX_UTF8_ENCODE_BLOCK_LENGTH;

        //
        // Translate each WCHAR to UTF8 individually.  This way,
        // no matter how big the String is, we don't run into
        // buffer size problems (it just might take a while).
        //
        for (i = 0; i < j; i++) {

            //
            // Encode the next block
            //
            bStatus = SacTranslateUnicodeToUtf8(
                pwch,
                MAX_UTF8_ENCODE_BLOCK_LENGTH,
                Utf8ConversionBuffer,
                Utf8ConversionBufferSize,
                &UTF8TranslationSize,
                &TranslatedCount
                );

            //
            // If this assert hits, it is probably caused by
            // a premature NULL termination in the incoming string
            //
            ASSERT(MAX_UTF8_ENCODE_BLOCK_LENGTH == TranslatedCount);

            if (! bStatus) {
                break;
            }

            //
            // Adjust the pwch to account for the sent length
            //
            pwch += MAX_UTF8_ENCODE_BLOCK_LENGTH;

            //
            // Send the UTF8 encoded characters
            //
            bStatus = SacChannelRawWrite(
                SacChannelHandle,
                Utf8ConversionBuffer,
                UTF8TranslationSize
                );

            if (! bStatus) {
                break;
            }

        }

    } while ( FALSE );
    
    //
    // Validate that the pwch pointer stopped at the end of the buffer
    //
    ASSERT(pwch == (String + Length));
        
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\sacchan.h ===
#include <ntddsac.h>

extern SAC_CHANNEL_HANDLE   SacChannelGuiModeDebugHandle; 
extern SAC_CHANNEL_HANDLE   SacChannelActionLogHandle;
extern SAC_CHANNEL_HANDLE   SacChannelErrorLogHandle;

extern BOOL                 SacChannelGuiModeDebugEnabled;
extern BOOL                 SacChannelActionLogEnabled;
extern BOOL                 SacChannelErrorLogEnabled;

VOID
SacChannelInitialize(
    VOID
    );

VOID
SacChannelTerminate(
    VOID
    );

BOOL
SacChannelUnicodeWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWSTR               Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\security.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Routines to deal with security, user accounts, etc.

    Externally exposed routines:

        SignalLsa
        CreateSamEvent
        WaitForSam

        SetAccountsDomainSid
        CreateLocalAdminAccount
        CreateLocalUserAccount
        SetLocalUserPassword

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\security.c

Revision History:

--*/

#include "setupp.h"
#include <Lmaccess.h>
#pragma hdrstop


PCWSTR SamEventName = L"\\SAM_SERVICE_STARTED";

PCWSTR SsiAccountNamePostfix = L"$";
PCWSTR SsiSecretName = L"$MACHINE.ACC";

#define DOMAIN_NAME_MAX 33
#define PASSWORD_MAX 14

//
// Constants used for logging that are specific to this source file.
//
PCWSTR szLsaOpenPolicy              = L"LsaOpenPolicy";
PCWSTR szLsaSetInformationPolicy    = L"LsaSetInformationPolicy";
PCWSTR szLsaQueryInformationPolicy  = L"LsaQueryInformationPolicy";
PCWSTR szNtSetEvent                 = L"NtSetEvent";
PCWSTR szNtCreateEvent              = L"NtCreateEvent";
PCWSTR szSamConnect                 = L"SamConnect";
PCWSTR szGetAccountsDomainName      = L"GetAccountsDomainName";
PCWSTR szSamLookupDomainInSamServer = L"SamLookupDomainInSamServer";
PCWSTR szSamOpenDomain              = L"SamOpenDomain";
PCWSTR szSamEnumerateUsersInDomain  = L"SamEnumerateUsersInDomain";
PCWSTR szSamOpenUser                = L"SamOpenUser";
PCWSTR szSamChangePasswordUser      = L"SamChangePasswordUser";
PCWSTR szSamCreateUserInDomain      = L"SamCreateUserInDomain";
PCWSTR szSamQueryInformationUser    = L"SamQueryInformationUser";
PCWSTR szSamSetInformationUser      = L"SamSetInformationUser";
PCWSTR szMyAddLsaSecretObject       = L"MyAddLsaSecretObject";


VOID
SetupLsaInitObjectAttributes(
    IN OUT POBJECT_ATTRIBUTES           ObjectAttributes,
    IN OUT PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    );

BOOL
GetAccountsDomainName(
    IN  LSA_HANDLE hPolicy,         OPTIONAL
    OUT PWSTR      Name,
    IN  DWORD      NameBufferSize
    );

LSA_HANDLE
OpenLsaPolicy(
    VOID
    );

PSID
CreateSidFromSidAndRid(
    IN PSID  DomainSid,
    IN DWORD Rid
    );

NTSTATUS
MyAddLsaSecretObject(
    IN PCWSTR Password
    );


BOOL
SetAccountsDomainSid(
    IN DWORD  Seed,
    IN PCWSTR DomainName
    )

/*++

Routine Description:

    Routine to set the sid of the AccountDomain.

Arguments:

    Seed - The seed is used to generate a unique Sid.  The seed should
        be generated by looking at the systemtime before and after
        a dialog and subtracting the milliseconds field.

    DomainName - supplies name to give to local domain

Return value:

    Boolean value indicating outcome.

--*/

{
    PSID                        Sid;
    PSID                        SidPrimary ;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;
    NTSTATUS                    Status;
    BOOL bResult;

    //
    //
    // Open the LSA Policy object to set the account domain sid.  The access
    // mask needed for this is POLICY_TRUST_ADMIN.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(!NT_SUCCESS(Status)) {

        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETACCOUNTDOMAINSID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szLsaOpenPolicy,
            Status,
            NULL,NULL);

        return(FALSE);
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAccountDomainInformation,
                 &PolicyCurrentAccountDomainInfo
                 );

    if(NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&PolicyCurrentAccountDomainInfo->DomainName,DomainName);


        Status = LsaSetInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     (PVOID) PolicyCurrentAccountDomainInfo
                     );

        LsaFreeMemory( PolicyCurrentAccountDomainInfo );
    }

    if(NT_SUCCESS(Status)) {
        bResult = TRUE;
    } else {
        bResult = FALSE;
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETACCOUNTDOMAINSID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szLsaSetInformationPolicy,
            Status,
            NULL,NULL);
    }

    LsaClose(PolicyHandle);
    return(bResult);
}


VOID
SetupLsaInitObjectAttributes(
    IN OUT POBJECT_ATTRIBUTES           ObjectAttributes,
    IN OUT PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    )

/*++

Routine Description:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller. Borrowed from
    lsa

Arguments:

    ObjectAttributes - Pointer to Object Attributes to be initialized.

    SecurityQualityOfService - Pointer to Security QOS to be initialized.

Return Value:

    None.

--*/

{
    SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService->EffectiveOnly = FALSE;

    InitializeObjectAttributes(ObjectAttributes,NULL,0,NULL,NULL);
    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //
    ObjectAttributes->SecurityQualityOfService = SecurityQualityOfService;
}


BOOL
CreateLocalUserAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PSID*  PointerToUserSid   OPTIONAL
    )
/*++

Routine Description:

    Routine to add a local user account to the AccountDomain. This account
    is created with the password indicated.

Arguments:

    UserName - supplies name for user account

    Password - supplies initial password for user account.

    PointerToUserSid - If this argument is present, then on return it will contain the
                       pointer to the user sid. It is the responsibility of the caller
                       to free the Sid, using MyFree.

Return value:

    Boolean value indicating outcome.

--*/

{
    return (NT_SUCCESS(CreateLocalAdminAccount(UserName, 
                                               Password, 
                                               PointerToUserSid
                                               )
                       )
            );
}

NTSTATUS
CreateLocalAdminAccountEx(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PCWSTR Description,
    IN PSID*  PointerToUserSid   OPTIONAL
    )

/*++

Routine Description:

    Routine to add a local user account to the AccountDomain. This account
    has ADMINISTRATOR priveledges and is created with the password indicated.

Arguments:

    UserName - supplies name for user account

    Password - supplies initial password for user account.

    Description - Description that appears in user manager.

    PointerToUserSid - If this argument is present, then on return it will contain the
                       pointer to the user sid. It is the responsibility of the caller
                       to free the Sid, using MyFree.

Return value:

    Boolean value indicating outcome.

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    UNICODE_STRING UnicodeString;
    SAM_HANDLE ServerHandle;
    SAM_HANDLE DomainHandle;
    SAM_HANDLE UserHandle;
    SAM_HANDLE AliasHandle;
    SAM_HANDLE BuiltinDomainHandle;
    WCHAR AccountsDomainName[DOMAIN_NAME_MAX];
    NTSTATUS Status;
    PSID BuiltinDomainId;
    PSID UserSid;
    ULONG User_RID;
    PUSER_CONTROL_INFORMATION UserControlInfo;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;
    USER_ADMIN_COMMENT_INFORMATION AdminCommentInfo;

    //
    // Use SamConnect to connect to the local domain ("") and get a handle
    // to the local sam server.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    RtlInitUnicodeString(&UnicodeString,L"");
    Status = SamConnect(
                 &UnicodeString,
                 &ServerHandle,
                 SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );

    if(!NT_SUCCESS(Status)) {
        goto err0;
    }

    //
    //  Use the LSA to retrieve the name of the Accounts domain.
    //
    if(!GetAccountsDomainName(NULL,AccountsDomainName,DOMAIN_NAME_MAX)) {
        goto err1;
    }

    //
    // Open the AccountDomain.  First find the Sid for this
    // in the Sam and then open the domain using this sid
    //
    //
    // Open the LSA Policy object to set the account domain sid.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     &PolicyCurrentAccountDomainInfo
                     );

        if(NT_SUCCESS(Status)) {

            Status = SamOpenDomain(
                         ServerHandle,
                         DOMAIN_READ | DOMAIN_LIST_ACCOUNTS | DOMAIN_LOOKUP |
                                            DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_CREATE_USER,
                         PolicyCurrentAccountDomainInfo->DomainSid,
                         &DomainHandle
                         );
        }

        LsaClose( PolicyHandle );
    }

    if (!NT_SUCCESS(Status)) {
        goto err2;
    }

    //
    // Use SamCreateUserInDomain to create a new user with the username
    // specified.  This user account is created disabled with the
    // password not required.
    //
    RtlInitUnicodeString(&UnicodeString,UserName);
    Status = SamCreateUserInDomain(
                 DomainHandle,
                 &UnicodeString,
                 //USER_READ_ACCOUNT | USER_WRITE_ACCOUNT | USER_FORCE_PASSWORD_CHANGE,
				 USER_ALL_ACCESS,
                 &UserHandle,
                 &User_RID
                 );

    if(!NT_SUCCESS(Status)) {
        goto err3;
    }

    //
    // Query all the default control information about the user added
    //
    Status = SamQueryInformationUser(UserHandle,UserControlInformation,&UserControlInfo);
    if(!NT_SUCCESS(Status)) {
        goto err4;
    }

    //
    // If the password is a Null password, make sure the
    // password_not required bit is set before the null
    // password is set.
    //
    if(!Password[0]) {
        UserControlInfo->UserAccountControl |= USER_PASSWORD_NOT_REQUIRED;
        Status = SamSetInformationUser(UserHandle,UserControlInformation,UserControlInfo);
        if(!NT_SUCCESS(Status)) {
            goto err5;
        }
    }

    //
    // Set the password ( NULL or non NULL )
    //
    RtlInitUnicodeString(&UserPasswordInfo.Password,Password);
    UserPasswordInfo.PasswordExpired = FALSE;
    Status = SamSetInformationUser(UserHandle,UserSetPasswordInformation,&UserPasswordInfo);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }


    //
    // Set the information bits - User Password not required is cleared
    // The normal account bit is enabled and the account disabled bit
    // is also reset
    //
    UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
    UserControlInfo->UserAccountControl |=  USER_NORMAL_ACCOUNT;
    Status = SamSetInformationUser(UserHandle,UserControlInformation,UserControlInfo);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }


    // Set the description is one is given
    //
    if ( Description[0])
    {
        // Convert description to unicode string
        //
        RtlInitUnicodeString(&AdminCommentInfo.AdminComment,Description);

        // We do not care if this fails and therefore will not set the status
        //
        SamSetInformationUser(UserHandle,UserAdminCommentInformation,&AdminCommentInfo);
    }

    //
    //  If this is a non-standlone server we're done.
    //
    if(ISDC(ProductType)) {
        Status = STATUS_SUCCESS;
        goto err5;
    }

    //
    // Finally add this to the administrators alias in the BuiltIn Domain
    //
    RtlInitUnicodeString(&UnicodeString,L"Builtin");
    Status = SamLookupDomainInSamServer(ServerHandle,&UnicodeString,&BuiltinDomainId);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }

    Status = SamOpenDomain(
                 ServerHandle,
                 DOMAIN_READ | DOMAIN_ADMINISTER_SERVER | DOMAIN_EXECUTE,
                 BuiltinDomainId,
                 &BuiltinDomainHandle
                 );

    if(!NT_SUCCESS(Status)) {
        goto err6;
    }

    UserSid = CreateSidFromSidAndRid(PolicyCurrentAccountDomainInfo->DomainSid,User_RID);
    if(!UserSid) {
        goto err7;
    }

    Status = SamOpenAlias(BuiltinDomainHandle,ALIAS_ADD_MEMBER,DOMAIN_ALIAS_RID_ADMINS,&AliasHandle);
    if(!NT_SUCCESS(Status)) {
        goto err8;
    }

    Status = SamAddMemberToAlias(AliasHandle,UserSid);
    if(!NT_SUCCESS(Status)) {
        goto err9;
    }

    MYASSERT(NT_SUCCESS(Status));

err9:
    SamCloseHandle(AliasHandle);
err8:
    if(NT_SUCCESS(Status) && (PointerToUserSid != NULL )) {
        *PointerToUserSid = UserSid;
    } else {
        MyFree(UserSid);
    }
err7:
    SamCloseHandle(BuiltinDomainHandle);
err6:
    SamFreeMemory(BuiltinDomainId);
err5:
    SamFreeMemory(UserControlInfo);
err4:
    SamCloseHandle(UserHandle);
err3:
    SamCloseHandle(DomainHandle);
err2:
    LsaFreeMemory( PolicyCurrentAccountDomainInfo );
err1:
    SamCloseHandle(ServerHandle);
err0:
    return(Status);
}


NTSTATUS
CreateLocalAdminAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PSID*  PointerToUserSid   OPTIONAL
    )
/*++

Routine Description:
  
    Please see CreateLocalAdminAccountEx description.


--*/
{
    return ( CreateLocalAdminAccountEx(UserName, Password, L"", PointerToUserSid) );
}

BOOL
GetAccountsDomainName(
    IN  LSA_HANDLE PolicyHandle,    OPTIONAL
    OUT PWSTR      Name,
    IN  DWORD      NameBufferSize
    )
{
    POLICY_ACCOUNT_DOMAIN_INFO *pPadi;
    NTSTATUS Status ;
    BOOL PolicyOpened;

    PolicyOpened = FALSE;
    if(PolicyHandle == NULL) {
        if((PolicyHandle = OpenLsaPolicy()) == NULL) {
            return(FALSE);
        }

        PolicyOpened = TRUE;
    }

    Status = LsaQueryInformationPolicy(PolicyHandle,PolicyAccountDomainInformation,&pPadi);
    if(NT_SUCCESS(Status)) {
         if(NameBufferSize <= (pPadi->DomainName.Length/sizeof(WCHAR))) {
             Status = STATUS_BUFFER_TOO_SMALL;
         } else {
             wcsncpy(Name,pPadi->DomainName.Buffer,pPadi->DomainName.Length/sizeof(WCHAR));
             Name[pPadi->DomainName.Length/sizeof(WCHAR)] = 0;
         }
         LsaFreeMemory(pPadi);
    }

    if(PolicyOpened) {
        LsaClose(PolicyHandle);
    }

    return(NT_SUCCESS(Status));
}


LSA_HANDLE
OpenLsaPolicy(
    VOID
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;

    PolicyHandle = NULL;
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    Status = LsaOpenPolicy(NULL,&ObjectAttributes,GENERIC_EXECUTE,&PolicyHandle);

    return(NT_SUCCESS(Status) ? PolicyHandle : NULL);
}


PSID
CreateSidFromSidAndRid(
    IN PSID  DomainSid,
    IN DWORD Rid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

Arguments:

    DomainSid - supplies sid for domain of account

    Rid - supplies relative id of account

Return Value:

    Pointer to Sid, or NULL on failure.
    The returned Sid must be freed with MyFree.

--*/
{

    NTSTATUS Status;
    PSID AccountSid;
    UCHAR AccountSubAuthorityCount;
    ULONG AccountSidLength;
    PULONG RidLocation;

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    if(AccountSid = (PSID)MyMalloc(AccountSidLength)) {
        //
        // Copy the domain sid into the first part of the account sid
        //
        Status = RtlCopySid(AccountSidLength, AccountSid, DomainSid);

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount - 1);
        *RidLocation = Rid;
    }

    return(AccountSid);
}


BOOL
SetLocalUserPassword(
    IN PCWSTR AccountName,
    IN PCWSTR OldPassword,
    IN PCWSTR NewPassword
    )

/*++

Routine Description:

    Change the password for the local user account.

Arguments:

Return value:

    Boolean value indicating outcome.

--*/

{
    NTSTATUS Status;
    BOOL b;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING OtherUnicodeString;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR AccountsDomainName[DOMAIN_NAME_MAX];
    SAM_HANDLE ServerHandle;
    SAM_HANDLE DomainHandle;
    SAM_HANDLE UserHandle;
    BOOL UserFound;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    SAM_RID_ENUMERATION *SamRidEnumeration;
    UINT i;
    UINT CountOfEntries;
    ULONG UserRid;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;

    b = FALSE;

    //
    // Use SamConnect to connect to the local domain ("") and get a handle
    // to the local sam server
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    RtlInitUnicodeString(&UnicodeString,L"");
    Status = SamConnect(
                 &UnicodeString,
                 &ServerHandle,
                 SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamConnect,
            Status,
            NULL,NULL);
        goto err0;
    }

    //
    //  Use the LSA to retrieve the name of the Accounts domain.
    //
    if(!GetAccountsDomainName(NULL,AccountsDomainName,DOMAIN_NAME_MAX)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_STRING,
            szGetAccountsDomainName,
            szFALSE,
            NULL,NULL);
        goto err1;
    }

    //
    // Open the AccountDomain.  First find the Sid for this
    // in the Sam and then open the domain using this sid.
    //

    //
    // Get the AccountDomainSid from the Lsa
    //

    //
    //
    // Open the LSA Policy object to set the account domain sid.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     &PolicyCurrentAccountDomainInfo
                     );

        if(NT_SUCCESS(Status)) {

            Status = SamOpenDomain(
                         ServerHandle,
                         DOMAIN_READ | DOMAIN_LIST_ACCOUNTS | DOMAIN_LOOKUP |
                                            DOMAIN_READ_PASSWORD_PARAMETERS,
                         PolicyCurrentAccountDomainInfo->DomainSid,
                         &DomainHandle
                         );
            LsaFreeMemory( PolicyCurrentAccountDomainInfo );
        }

        LsaClose( PolicyHandle );
    }

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_NTSTATUS,
            szSamOpenDomain,
            Status,
            AccountsDomainName,
            NULL,NULL);
        goto err2;
    }

    //
    // Find the account name in this domain - and extract the rid.
    //
    UserFound = FALSE;
    EnumerationContext = 0;
    RtlInitUnicodeString(&UnicodeString,AccountName);
    do {
        Status = SamEnumerateUsersInDomain(
                     DomainHandle,
                     &EnumerationContext,
                     0L,
                     &SamRidEnumeration,
                     0L,
                     &CountOfEntries
                     );

        if(!NT_SUCCESS(Status) && (Status != STATUS_MORE_ENTRIES)) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CHANGING_PW_FAIL,
                AccountName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_NTSTATUS,
                szSamEnumerateUsersInDomain,
                Status,
                NULL,NULL);
            goto err3;
        }

        //
        // go through the the SamRidEnumeration buffer for count entries.
        //
        for(i = 0; (i<CountOfEntries) && !UserFound; i++ ) {
            if(RtlEqualUnicodeString(&UnicodeString,&SamRidEnumeration[i].Name,TRUE)) {
                UserRid = SamRidEnumeration[i].RelativeId;
                UserFound = TRUE;
            }
        }

        SamFreeMemory(SamRidEnumeration);

    } while((Status == STATUS_MORE_ENTRIES) && !UserFound);

    if(!UserFound) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_USERNOTFOUND,
            NULL,NULL);
        goto err3;
    }

    //
    // Open the user
    //
    Status = SamOpenUser(
                 DomainHandle,
                 USER_READ_ACCOUNT | USER_WRITE_ACCOUNT | USER_CHANGE_PASSWORD | USER_FORCE_PASSWORD_CHANGE,
                 UserRid,
                 &UserHandle
                 );

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamOpenUser,
            Status,
            NULL,NULL);
        goto err3;
    }

    //
    // Use SAM API to change the password for this Account.
    //
    RtlInitUnicodeString(&UnicodeString,OldPassword);
    RtlInitUnicodeString(&OtherUnicodeString,NewPassword);
    Status = SamChangePasswordUser(UserHandle,&UnicodeString,&OtherUnicodeString);
    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamChangePasswordUser,
            Status,
            NULL,NULL);
        goto err4;
    }

    b = TRUE;

err4:
    SamCloseHandle(UserHandle);
err3:
    SamCloseHandle(DomainHandle);
err2:
err1:
    SamCloseHandle(ServerHandle);
err0:
    return(b);
}



VOID
GenerateRandomPassword(
    OUT PWSTR Password
    )
{
    static DWORD Seed = 98725757;
    static PCWSTR UsableChars = L"ABCDEFGHIJKLMOPQRSTUVWYZabcdefghijklmopqrstuvwyz0123456789";

    UINT UsableCount;
    UINT i;

    UsableCount = lstrlen(UsableChars);
    Seed ^= GetCurrentTime();

    for(i=0; i<PASSWORD_MAX; i++) {
        Password[i] = UsableChars[RtlRandom(&Seed) % UsableCount];
    }

    Password[i] = 0;
}


NTSTATUS
MyAddLsaSecretObject(
    IN PCWSTR Password
    )

/*++

Routine Description:

    Create the Secret Object necessary to support a machine account
    on an NT domain.

Arguments:

    Password - supplies password to machine account

Return value:

    NT Status code indicating outcome.

--*/
{
    UNICODE_STRING SecretName;
    UNICODE_STRING UnicodePassword;
    NTSTATUS Status;
    LSA_HANDLE LsaHandle;
    LSA_HANDLE SecretHandle;
    OBJECT_ATTRIBUTES ObjAttr;

    RtlInitUnicodeString(&SecretName,SsiSecretName) ;
    RtlInitUnicodeString(&UnicodePassword,Password);

    InitializeObjectAttributes(&ObjAttr,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(NULL,&ObjAttr,MAXIMUM_ALLOWED,&LsaHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaCreateSecret(LsaHandle,&SecretName,SECRET_ALL_ACCESS,&SecretHandle);
        if(NT_SUCCESS(Status)) {

            Status = LsaSetSecret(SecretHandle,&UnicodePassword,&UnicodePassword);
            LsaClose(SecretHandle);
        }

        LsaClose(LsaHandle);
    }

    return(Status);
}


BOOL
AdjustPrivilege(
    IN PCWSTR   Privilege,
    IN BOOL     Enable
    )
/*++

Routine Description:

    This routine enables or disable a priviliege of the current process.

Arguments:

    Privilege - String with the name of the privilege to be adjusted.

    Enable - TRUE if the privilege is to be enabled.
             FALSE if the privilege is to be disabled.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        SetupDebugPrint1(L"SYSSETUP: OpenProcessToken() failed. Error = %d \n", GetLastError() );
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        SetupDebugPrint1(L"SYSSETUP: LookupPrivilegeValue failed, Error = %d \n", GetLastError() );
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    if( Enable ) {
        LuidAndAttributes.Attributes |= SE_PRIVILEGE_ENABLED;
    } else {
        LuidAndAttributes.Attributes &= ~SE_PRIVILEGE_ENABLED;
    }

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        SetupDebugPrint1(L"SYSSETUP: AdjustTokenPrivileges failed, Error = %d \n", GetLastError() );
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    CloseHandle( TokenHandle );
    return( TRUE );
}


NTSTATUS
DisableLocalUserAccount(
    PWSTR   AccountName
    )
/*++

Routine Description:

    This routine disables the local administrator account.

Arguments:

    AccountName - Name of the local account to be disabled.

Return Value:

    NTSTATUS, depending on the outcome of the operations.

--*/

{
LONG        rc;
PUSER_INFO_1 ui1;


    // Get the info.
    rc = NetUserGetInfo( NULL,
                         AccountName,
                         1,
                         (PBYTE *)(&ui1) );

    if( rc == NO_ERROR ) {

        // set the disable flag and store the info back out.
        ui1->usri1_flags |= UF_ACCOUNTDISABLE;

        rc = NetUserSetInfo( NULL,
                             AccountName,
                             1,
                             (PBYTE)ui1,
                             NULL );

        NetApiBufferFree((PVOID)ui1);
    }

    return rc;
}


NTSTATUS
DisableLocalAdminAccount(
    VOID
    )
/*++

Routine Description:

    This routine disables the local administrator account.

Arguments:

    None.

Return Value:

    NTSTATUS, depending on the outcome of the operations.

--*/

{
NTSTATUS    Status = STATUS_SUCCESS;
WCHAR       AdminAccountName[MAX_PATH];


    GetAdminAccountName( AdminAccountName );

    Status = DisableLocalUserAccount( AdminAccountName );

    return Status;
}


DWORD
StorePasswordAsLsaSecret (
    IN      PCWSTR Password
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaPolicyHandle;

    LSA_UNICODE_STRING lusSecretName, lusSecretData;
    USHORT SecretNameLength, SecretDataLength;
    
    NTSTATUS ntsResult;
    DWORD dwRetCode = ERROR_SUCCESS;

    // Object attributes are reserved, so initialize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    // Get a handle to the Policy object.
    ntsResult = LsaOpenPolicy(
        NULL,    //local machine
        &ObjectAttributes, 
        POLICY_CREATE_SECRET,
        &LsaPolicyHandle);

    if( STATUS_SUCCESS != ntsResult )
    {
        // An error occurred. Return the win32 error code.
        return LsaNtStatusToWinError(ntsResult);
    } 

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(L"DefaultPassword");
    lusSecretName.Buffer = L"DefaultPassword";
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength = (SecretNameLength+1) * sizeof(WCHAR);

    //Initialize the Password LSA_UNICODE_STRING 
    SecretDataLength = (USHORT)wcslen(Password);
    lusSecretData.Buffer = (PWSTR)Password;
    lusSecretData.Length = SecretDataLength * sizeof(WCHAR);
    lusSecretData.MaximumLength = (SecretDataLength+1) * sizeof(WCHAR);

    ntsResult = LsaStorePrivateData(
        LsaPolicyHandle,
        &lusSecretName,
        &lusSecretData);
    if( STATUS_SUCCESS != ntsResult ) {
        dwRetCode = LsaNtStatusToWinError(ntsResult);
    }

    LsaClose(LsaPolicyHandle);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\resource.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Routines that manipulate resources (strings, messages, etc).

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop



PWSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    WCHAR Buffer[4096];
    UINT Length;

    Length = LoadString(MyModuleHandle,StringId,Buffer,sizeof(Buffer)/sizeof(WCHAR));
    if(!Length) {
        Buffer[0] = 0;
    }

    return(pSetupDuplicateString(Buffer));
}


PWSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PWSTR FormatString;
    va_list arglist;
    PWSTR Message;
    PWSTR Return;
    DWORD d;

    //
    // First, load the format string.
    //
    FormatString = MyLoadString(FormatStringId);
    if(!FormatString) {
        return(NULL);
    }

    //
    // Now format the message using the arguments the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PWSTR)&Message,
            0,
            ArgumentList
            );

    MyFree(FormatString);

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = pSetupDuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PWSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PWSTR p;

    va_start(arglist,FormatStringId);
    p = FormatStringMessageV(FormatStringId,&arglist);
    va_end(arglist);

    return(p);
}


PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    PWSTR Buffer;
    PWSTR Message;
    WCHAR ModuleName[MAX_PATH];
    WCHAR ErrorNumber[24];
    PWCHAR p;
    PWSTR Args[2];
    DWORD Msg_Type;
    UINT Msg_Id = MessageId;

    if(MessageString > SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    } else {

        if( Msg_Id & 0x0FFF0000 )
            Msg_Type = FORMAT_MESSAGE_FROM_SYSTEM;      // If the facility bits are set this is still Win32
        else{
            Msg_Id &= 0x0000FFFF;                       // Mask out Severity and Facility bits so that we do the right thing
            Msg_Type = ((Msg_Id < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE);
        }


        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | Msg_Type,
                (PVOID)MyModuleHandle,
                MessageId,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber,L"%x",MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(MyGetModuleFileName(MyModuleHandle,ModuleName,MAX_PATH)) {
            if(p = wcsrchr(ModuleName,L'\\')) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = pSetupDuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}


PWSTR
RetrieveAndFormatMessage(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PWSTR p;

    va_start(arglist,MessageId);
    p = RetrieveAndFormatMessageV(MessageString,MessageId,&arglist);
    va_end(arglist);

    return(p);
}


int
MessageBoxFromMessageExV (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    IN va_list ArgumentList
    )

/*++

Routine Description:

    Creates a dialog box containing a specified message

Arguments:

    Severity - Severity and flags for the error message.  Currently only the
        flags are significant.

    Onwer - handle to parent window

    MessageId - ID of message to display

    Caption - string to use as caption for dialog box

    CaptionStringId - ID of string to use as caption for dialog box (but not
    used if Caption is specified)

    Style - flags to specify the type of dialog box

    ArgumentList - parameters to MessageId

Return Value:

    return status from MessageBox

--*/

{
    static SETUPLOG_CONTEXT Context = {0};
    PCWSTR Message;
    PCWSTR Title;
    int i;
    BOOL b;


    if(!Context.AllocMem) {
        Context.AllocMem = MyMalloc;
        Context.FreeMem = MyFree;
        Context.Format = RetrieveAndFormatMessageV;
    }
    Message = SetuplogFormatMessageWithContextV(
        &Context,
        Severity,
        (PTSTR)MessageString,
        MessageId,
        &ArgumentList);

    b = FALSE;
    i = IDOK;

    if(Message) {

        if(Title = Caption ? Caption : MyLoadString(CaptionStringId)) {

            b = TRUE;
            i = MessageBox(Owner,Message,Title,Style);

            if(Title != Caption) {
                MyFree(Title);
            }
        }
        MyFree(Message);
    }

    if(!b) {
        pSetupOutOfMemory(Owner);
    }
    return(i);
}

int
MessageBoxFromMessageEx (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    )

/*

    Wrapper for MessageBoxFromMessageExV

*/

{
    va_list ArgumentList;
    int Status;

    va_start(ArgumentList,Style);
    Status = MessageBoxFromMessageExV (
        Owner, Severity, MessageString, MessageId, Caption,
        CaptionStringId, Style, ArgumentList);
    va_end(ArgumentList);
    return Status;
}

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    )
{
    PCWSTR Message;
    PCWSTR Title;
    va_list ArgumentList;
    int i;
    BOOL b;

    va_start(ArgumentList,Style);
    Message = RetrieveAndFormatMessageV(NULL,MessageId,&ArgumentList);
    va_end(ArgumentList);

    b = FALSE;
    i = IDOK;

    if(Message) {

        if(Title = Caption ? Caption : MyLoadString(CaptionStringId)) {

            b = TRUE;
            i = MessageBox(Owner,Message,Title,Style);

            if(Title != Caption) {
                MyFree(Title);
            }
        }
        MyFree(Message);
    }

    if(!b) {
        pSetupOutOfMemory(Owner);
    }
    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\services.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.c

Abstract:

    Routines to deal with the Windows NT service controller
    and service entries in the registry,

    Externally exposed routines:

        MyCreateService
        MyChangeServiceStart
        MyChangeServiceConfig

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\sc.c

Revision History:
    Dan Elliott (dane) 14-Aug-2000  Added WaitForScmInitialization().

--*/

#include "setupp.h"
#pragma hdrstop

//
// Constants used in logging specific to this module.
//
PCWSTR szOpenSCManager       = L"OpenSCManager";
PCWSTR szCreateService       = L"CreateService";
PCWSTR szChangeServiceConfig = L"ChangeServiceConfig";
PCWSTR szOpenService         = L"OpenService";
PCWSTR szStartService        = L"StartService";
PCWSTR szEnumDependentService= L"EnumDependentService";

PCWSTR szServicesKeyPath         = L"SYSTEM\\CurrentControlSet\\Services";
PCWSTR szDependOnService         = L"DependOnService";
PCWSTR szServicesToRename        = L"ServicesToRename";

BOOL
pSetupWaitForScmInitialization()
/*++

Routine Description:

    Wait for services.exe to signal that the Services Control Manager is
    running and autostart services have been started.

Arguments:
    None.

Return value:

    Boolean indicating whether the the SCM was started successfully.

--*/
{
    HANDLE      hEventHandle;
    DWORD       WaitStatus;

    hEventHandle = OpenEvent( SYNCHRONIZE, FALSE, SC_AUTOSTART_EVENT_NAME );
    if( hEventHandle != NULL ) {

        SetupDebugPrint1(L"SETUP: Waiting on event %ls \n", SC_AUTOSTART_EVENT_NAME );
        WaitStatus = WaitForSingleObject( hEventHandle, INFINITE );
        if( WaitStatus != WAIT_FAILED ) {
            if( WaitStatus == WAIT_OBJECT_0 ) {
                SetupDebugPrint1(L"SETUP: Wait on event %ls completed successfully \n", SC_AUTOSTART_EVENT_NAME );
            } else {
                SetupDebugPrint2(L"SETUP: Wait on event %ls failed. WaitStatus = %d \n", SC_AUTOSTART_EVENT_NAME, WaitStatus );
            }
        } else {
            DWORD   Error;

            Error = GetLastError();
            SetupDebugPrint2(L"SETUP: Wait on event %ls failed. Error = %d \n", SC_AUTOSTART_EVENT_NAME, Error );
        }
        CloseHandle( hEventHandle );
    }
    else {
        return FALSE;
    }

    return (WAIT_OBJECT_0 == WaitStatus);
}

BOOL
MyCreateService(
    IN PCWSTR  ServiceName,
    IN PCWSTR  DisplayName,         OPTIONAL
    IN DWORD   ServiceType,
    IN DWORD   StartType,
    IN DWORD   ErrorControl,
    IN PCWSTR  BinaryPathName,
    IN PCWSTR  LoadOrderGroup,      OPTIONAL
    IN PWCHAR  DependencyList,
    IN PCWSTR  ServiceStartName,    OPTIONAL
    IN PCWSTR  Password             OPTIONAL
    )

/*++

Routine Description:

    Stub for calling CreateService. If CreateService fails with
    the error code indicating that the service already exists, this routine
    calls the routine for ChangeServiceConfig to ensure that the
    parameters passed in are reflected in the services database.

Arguments:

    ServiceName - Name of service

    DisplayName - Localizable name of Service or ""

    ServiceType - Service type, e.g. SERVICE_KERNEL_DRIVER

    StartType - Service Start value, e.g. SERVICE_BOOT_START

    ErrorControl - Error control value, e.g. SERVICE_ERROR_NORMAL

    BinaryPathName - Full Path of the binary image containing service

    LoadOrderGroup - Group name for load ordering or ""

    Dependencies - MultiSz list of dependencies for this service. Any dependency
        component having + as the first character is a group dependency.
        The others are service dependencies.

    ServiceStartName - Service Start name (account name in which this service is run).

    Password - Password used for starting the service.

Return value:

    Boolean value indicating outcome.

--*/

{
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD dwTag,dw;
    BOOL b;

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CREATESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    //
    // Process the optional "" parameters passed in and make them NULL.
    //
    if(DisplayName && !DisplayName[0]) {
        DisplayName = NULL;
    }
    if(LoadOrderGroup && !LoadOrderGroup[0]) {
        LoadOrderGroup = NULL;
    }
    if(ServiceStartName && !ServiceStartName[0]) {
        ServiceStartName = NULL;
    }
    if(Password && !Password[0]) {
        Password = NULL;
    }

    //
    // Create the service.
    //

    hSCService = CreateService(
                     hSC,
                     ServiceName,
                     DisplayName,
                     0,
                     ServiceType,
                     StartType,
                     ErrorControl,
                     BinaryPathName,
                     LoadOrderGroup,
                     LoadOrderGroup ? &dwTag : NULL,
                     DependencyList,
                     ServiceStartName,
                     Password
                     );
    //
    // If we were unable to create the service, check if the service already
    // exists in which case all we need to do is change the configuration
    // parameters in the service.
    //
    if(hSCService) {
        //
        // Note that we won't do anything with the tag.
        //
        CloseServiceHandle(hSCService);
        b = TRUE;
    } else {
        if((dw = GetLastError()) == ERROR_SERVICE_EXISTS) {

            b = MyChangeServiceConfig(
                    ServiceName,
                    ServiceType,
                    StartType,
                    ErrorControl,
                    BinaryPathName,
                    LoadOrderGroup,
                    DependencyList,
                    ServiceStartName,
                    Password,
                    DisplayName
                    );
        } else {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CREATESVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szCreateService,
                dw,
                NULL,NULL);
            b = FALSE;
        }
    }

    CloseServiceHandle(hSC);
    return(b);
}


BOOL
MyChangeServiceConfig(
    IN PCWSTR ServiceName,
    IN DWORD  ServiceType,
    IN DWORD  StartType,
    IN DWORD  ErrorControl,
    IN PCWSTR BinaryPathName,   OPTIONAL
    IN PCWSTR LoadOrderGroup,   OPTIONAL
    IN PWCHAR DependencyList,
    IN PCWSTR ServiceStartName, OPTIONAL
    IN PCWSTR Password,         OPTIONAL
    IN PCWSTR DisplayName       OPTIONAL
    )

/*++

Routine Description:

    Wrapper for ChangeServiceConfig.

Arguments:

    ServiceName - Name of service

    ServiceType - Service type, e.g. SERVICE_KERNEL_DRIVER

    StartType - Service Start value, e.g. SERVICE_BOOT_START

    ErrorControl - Error control value, e.g. SERVICE_ERROR_NORMAL

    BinaryPathName - Full Path of the binary image containing service

    LoadOrderGroup - Group name for load ordering

    DependencyList - Multisz string having dependencies.  Any dependency
        component having + as the first character is a
        group dependency.  The others are service dependencies.

    ServiceStartName - Service Start name (account name in which this
        service is run).

    Password - Password used for starting the service.

    DisplayName - Localizable name of Service.

Return value:

    Boolean value indicating outcome.

--*/

{
    SC_LOCK sclLock;
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD dw;
    BOOL b;

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    //
    // Try to lock the database, if possible. If we are not able to lock
    // the database we will still modify the services entry. This is because
    // we are just modifying a single service and chances are very low that
    // anybody else is manipulating the same entry at the same time.
    //
    SetupDebugPrint1(L"MyChangeServiceConfig: LockingServiceDatabase for service %s", ServiceName);
    sclLock = LockServiceDatabase(hSC);

    //
    // Process optional parameters
    //
    if(BinaryPathName && !BinaryPathName[0]) {
        BinaryPathName = NULL;
    }
    if(LoadOrderGroup && !LoadOrderGroup[0]) {
        LoadOrderGroup = NULL;
    }
    if(ServiceStartName && !ServiceStartName[0]) {
        ServiceStartName = NULL;
    }
    if(Password && !Password[0]) {
        Password = NULL;
    }
    if(DisplayName && !DisplayName[0]) {
        DisplayName = NULL;
    }

    //
    // Open the service with SERVICE_CHANGE_CONFIG access
    //
    if(hSCService = OpenService(hSC,ServiceName,SERVICE_CHANGE_CONFIG)) {

        b = ChangeServiceConfig(
                hSCService,
                ServiceType,
                StartType,
                ErrorControl,
                BinaryPathName,
                LoadOrderGroup,
                NULL,
                DependencyList,
                ServiceStartName,
                Password,
                DisplayName
                );

        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CHANGESVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szChangeServiceConfig,
                GetLastError(),
                NULL,NULL);
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            NULL,NULL);
    }

    //
    // Unlock the database if locked and then close the service controller
    // handle
    //
    if(sclLock) {
        UnlockServiceDatabase(sclLock);
        SetupDebugPrint1(L"MyChangeServiceConfig: Unlocked ServiceDatabase for service %s", ServiceName);
    }

    CloseServiceHandle(hSC);
    return(b);
}


BOOL
MyChangeServiceStart(
    IN PCWSTR ServiceName,
    IN DWORD  StartType
    )

/*++

Routine Description:

    Routine to change the start value of a service. This turns
    around and calls the stub to ChangeServiceConfig.

Arguments:

    ServiceName - Name of service

    StartType - Service Start value, e.g. SERVICE_BOOT_START

Return value:

    Boolean value indicating outcome.

--*/
{
    BOOL b;

    b = MyChangeServiceConfig(
                ServiceName,
                SERVICE_NO_CHANGE,
                StartType,
                SERVICE_NO_CHANGE,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );

    return(b);
}


BOOL
SetupStartService(
    IN PCWSTR ServiceName,
    IN BOOLEAN Wait        // if TRUE, try to wait until it is started.
    )
{
    SC_HANDLE hSC,hSCService;
    BOOL b;
    DWORD d;
    DWORD dwDesiredAccess;

    b = FALSE;
    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    if (Wait) {
        dwDesiredAccess = SERVICE_START | SERVICE_QUERY_STATUS;
    } else {
        dwDesiredAccess = SERVICE_START;
    }
    if(hSCService = OpenService(hSC,ServiceName,dwDesiredAccess)) {
        SetupDebugPrint1(L"SetupStartService: Sending StartService to <%ws>\n", ServiceName);
        b = StartService(hSCService,0,NULL);
        SetupDebugPrint1(L"SetupStartService: Sent StartService to <%ws>\n", ServiceName);
        if(!b && ((d = GetLastError()) == ERROR_SERVICE_ALREADY_RUNNING)) {
            //
            // Service is already running.
            //
            b = TRUE;
        }
        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_STARTSVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_PARAM_RETURNED_WINERR,
                szStartService,
                d,
                ServiceName,
                NULL,NULL);
        }
        if (b && Wait) {
#define SLEEP_TIME 4000
#define LOOP_COUNT 30
            SERVICE_STATUS ssStatus;
            DWORD loopCount = 0;
            //SetupDebugPrint(L"  )) Looping waiting for start\n");
            do {
                b = QueryServiceStatus( hSCService, &ssStatus);
                if ( !b ) {
                    //SetupDebugPrint(L"FAILED %d\n", GetLastError());
                    break;
                }
                if (ssStatus.dwCurrentState == SERVICE_START_PENDING) {
                    //SetupDebugPrint(L"PENDING\n");
                    if ( loopCount++ == LOOP_COUNT ) {
                        //SetupDebugPrint2(L"SYSSETUP: STILL PENDING after %d times: <%ws> service\n", loopCount, ServiceName);
                        break;
                    }
                    Sleep( SLEEP_TIME );
                } else {
                    //SetupDebugPrint3(L"SYSSETUP: WAITED %d times: <%ws> service, status %d\n", loopCount, ServiceName, ssStatus.dwCurrentState);
                    break;
                }
            } while ( TRUE );
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            ServiceName,
            NULL,NULL);
    }

    CloseServiceHandle(hSC);

    return(b);
}

BOOL
FixServiceDependency(
    IN PCWSTR ServiceName,
    IN PCWSTR OldDependencyName,
    IN PCWSTR NewDependencyName
    )
{
    ULONG     Error;
    HKEY      hKey;
    WCHAR     ServicePath[ MAX_PATH + 1 ];
    PBYTE     OldValueData;
    PBYTE     NewValueData;
    ULONG     OldValueSize;
    ULONG     NewValueSize;
    DWORD     Type;
    PBYTE     p,q;
    BOOL      ChangeDependencyList;

    //
    //  Open the key that describes the service
    //

    lstrcpy( ServicePath, szServicesKeyPath );
    pSetupConcatenatePaths(ServicePath,ServiceName,sizeof( ServicePath )/sizeof( WCHAR ),NULL);

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          ServicePath,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            Error,
            ServicePath,
            NULL,NULL);
         return( FALSE );
    }

    //
    //  Allocate a buffer for the old value data
    //

    OldValueSize = 0;
    Error = RegQueryValueEx(hKey,
                            szDependOnService,
                            NULL,
                            &Type,
                            NULL,
                            &OldValueSize);
    if( ( Error != ERROR_SUCCESS ) && ( Error != ERROR_MORE_DATA ) ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegQueryValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         RegCloseKey( hKey );
         return( FALSE );
    }

    OldValueData = MyMalloc( OldValueSize );
    if( OldValueData == NULL ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Read the value entry that lists the dependencies
    //

    Error = RegQueryValueEx(hKey,
                            szDependOnService,
                            NULL,
                            &Type,
                            OldValueData,
                            &OldValueSize);
    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegQueryValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         MyFree( OldValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Find out if the OldValueData, explicitly list OldDependencyName.
    //  If not, then the service depends on another service that depends
    //  on OlDependencyName, and in this case there is no need to change
    //  the dependency list.
    //
    p = OldValueData;
    ChangeDependencyList = FALSE;
    while( (ULONG)(p - OldValueData) < OldValueSize ) {
        if( ( lstrcmpi( (PWSTR)p, OldDependencyName ) == 0 ) ) {
            ChangeDependencyList = TRUE;
            break;
        }
        p += (lstrlen( (PWSTR)p ) + 1)*sizeof(WCHAR);
    }
    if( !ChangeDependencyList ) {
         MyFree( OldValueData );
         RegCloseKey( hKey );
         //
         // Let the caller think that the dependency list was fixed
         //
         return( TRUE );
    }

    //
    //  Allocate a buffer for the new value data
    //
    NewValueSize = OldValueSize -
                    ( lstrlen( OldDependencyName ) - lstrlen( NewDependencyName ) )*sizeof(WCHAR);

    NewValueData = MyMalloc( NewValueSize );
    if( NewValueData == NULL ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
         MyFree( OldValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Replace the old dependency name with the new one
    //
    p = OldValueData;
    q = NewValueData;

    lstrcpy( (PWSTR)q, NewDependencyName );
    q += (lstrlen( (PWSTR)q ) + 1)*sizeof(WCHAR);
    while( (ULONG)(p - OldValueData) < OldValueSize ) {
        if( ( lstrcmpi( (PWSTR)p, OldDependencyName ) != 0 ) &&
            ( lstrcmpi( (PWSTR)p, NewDependencyName ) != 0 )
          ) {
            lstrcpy( (PWSTR)q, (PWSTR)p );
            q += (lstrlen( (PWSTR)q ) + 1)*sizeof(WCHAR);
        }
        p += (lstrlen( (PWSTR)p ) + 1)*sizeof(WCHAR);
    }

    //
    //  Save the value entry with the new dependency name
    //
    Error = RegSetValueEx( hKey,
                           szDependOnService,
                           0,
                           REG_MULTI_SZ,
                           NewValueData,
                           (DWORD)(q-NewValueData) // NewValueSize
                         );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegSetValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         MyFree( OldValueData );
         MyFree( NewValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Free the allocated buffers
    //

    MyFree( OldValueData );
    MyFree( NewValueData );

    //
    //  Close the key
    //
    RegCloseKey( hKey );
    return( TRUE );
}


BOOL
UpdateServicesDependencies(
    IN HINF InfHandle
    )
{
    INFCONTEXT            InfContext;
    PCWSTR                OldServiceName,NewServiceName;
    BOOL                  b;
    SC_HANDLE             hSC, hSCService;
    LPENUM_SERVICE_STATUS DependentsList;
    DWORD                 BytesNeeded;
    DWORD                 ServicesReturned;
    HKEY                  hKey;
    ULONG                 Error;
    ULONG                 i;

    //
    // Iterate the [ServicesToRename] section in the inf.
    // Each line is the name of a dependecy service that needs to be renamed.
    //
    if(SetupFindFirstLine(InfHandle,szServicesToRename,NULL,&InfContext)) {
        b = TRUE;
    } else {
        SetuplogError( LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_NO_SECTION,
            szServicesToRename,NULL,NULL);
        return(FALSE);
    }

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    do {
        //
        // Fetch the name of a service that got renamed
        //
        if((OldServiceName = pSetupGetField(&InfContext,0))
        && (NewServiceName = pSetupGetField(&InfContext,1))) {

            //
            //  Create a dummy service that has the same name as the old service
            //  This is necessarey so that we can get a handle to this service,
            //  and pass it to EnumDependentServices to find out the services that
            //  depend on this one.
            //

            if( !MyCreateService( OldServiceName,
                                  NULL,
                                  SERVICE_WIN32_OWN_PROCESS,
                                  SERVICE_DISABLED,
                                  SERVICE_ERROR_NORMAL,
                                  L"%SystemRoot%\\System32\\dummy.exe",
                                  NULL,
                                  L"",
                                  NULL,
                                  NULL ) ) {

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_CANT_CREATE_DUMMY_SERVICE,
                    OldServiceName,
                    NULL,NULL);

                b = FALSE;
                continue;
            }

            //
            //  Open the service that was just created
            //

            hSCService = OpenService(hSC,OldServiceName,SERVICE_ENUMERATE_DEPENDENTS | DELETE);
            if( hSCService == NULL) {
                Error = GetLastError();
                SetupDebugPrint2( L"SYSSETUP: Unable to open service = %ls. Error = %d \n", OldServiceName, Error );
                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    szOpenService,
                    Error,
                    OldServiceName,
                    NULL,NULL);
                //
                //  Force deletion of the service cretated
                //
                b = FALSE;
                Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      szServicesKeyPath,
                                      0,
                                      MAXIMUM_ALLOWED,
                                      &hKey );
                if( Error == ERROR_SUCCESS ) {
                    pSetupRegistryDelnode( hKey, OldServiceName );
                    RegCloseKey( hKey );
                }
                continue;
            }

            //
            //  Determine all services that depend on the service that was renamed
            //

            BytesNeeded = 0;
            ServicesReturned = 0;
            DependentsList = NULL;
            if( !EnumDependentServices( hSCService,
                                        SERVICE_ACTIVE | SERVICE_INACTIVE,
                                        DependentsList,
                                        0,
                                        &BytesNeeded,
                                        &ServicesReturned ) &&
                ( Error = GetLastError()) != ERROR_MORE_DATA ) {

                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szEnumDependentService,
                    Error,
                    NULL,NULL);

                b = FALSE;
                goto delete_dummy_service;
            }

            DependentsList = MyMalloc( BytesNeeded );
            if( DependentsList == NULL ) {

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_OUTOFMEMORY,
                    NULL,NULL);

                b = FALSE;
                goto delete_dummy_service;
            }

            if( !EnumDependentServices( hSCService,
                                        SERVICE_ACTIVE | SERVICE_INACTIVE,
                                        DependentsList,
                                        BytesNeeded,
                                        &BytesNeeded,
                                        &ServicesReturned ) ) {

                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szEnumDependentService,
                    GetLastError(),
                    NULL,NULL);

                MyFree( DependentsList );
                b = FALSE;
                goto delete_dummy_service;
            }

            for( i = 0; i < ServicesReturned; i++ ) {
                //
                //  Fix the dependency for this service
                //
                b = b && FixServiceDependency( DependentsList[i].lpServiceName,
                                               OldServiceName,
                                               NewServiceName );
            }
            MyFree( DependentsList );

delete_dummy_service:

            if( !DeleteService(hSCService) &&
                ((Error = GetLastError()) != ERROR_SERVICE_MARKED_FOR_DELETE)
              ) {
                SetupDebugPrint2( L"SYSSETUP: Unable to delete service %ls. Error = %d \n", OldServiceName, Error );
#if 0
                //
                //  Force deletion of the dummy service
                //
                Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      szServicesKeyPath,
                                      0,
                                      MAXIMUM_ALLOWED,
                                      &hKey );
                if( Error == ERROR_SUCCESS ) {
                    pSetupRegistryDelnode( hKey, OldServiceName );
                    RegCloseKey( hKey );
                }
#endif
            }
            CloseServiceHandle(hSCService);


        } else {
            SetuplogError( LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NO_SECTION,
                szServicesToRename,NULL,NULL);
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

    CloseServiceHandle(hSC);
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\setupasr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    setupasr.c

Abstract:

    Services in this module implement the Automatic System Recovery (ASR)
    routines of guimode setup.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     20.Jan.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Sep.1999

--*/

#include "setupp.h"
#pragma hdrstop
#include <setupapi.h>
#include <mountmgr.h>
#include <accctrl.h>
#include <aclapi.h>

#define THIS_MODULE 'S'
#include "asrpriv.h"


///////////////////////////////////////////////////////////////////////////////
// Private Type and constant declarations
///////////////////////////////////////////////////////////////////////////////

const PCWSTR AsrSifPath             = L"%systemroot%\\repair\\asr.sif\0";
const PCWSTR AsrCommandsSectionName = L"COMMANDS";
const PCWSTR AsrCommandSuffix       = L"/sifpath=%systemroot%\\repair\\asr.sif";
const PCWSTR AsrTempDir             = L"%systemdrive%\\TEMP";

const PCWSTR AsrLogFileName         = L"\\asr.log";
const PCWSTR AsrErrorFileName       = L"\\asr.err";

const PCWSTR Asr_ControlAsrRegKey        = L"SYSTEM\\CurrentControlSet\\Control\\ASR";
const PCWSTR Asr_LastInstanceRegValue    = L"Instance";

//
// The following are to update system and boot partition devices
// in setup.log
//
const PCWSTR Asr_SystemDeviceEnvName    = L"%ASR_C_SYSTEM_PARTITION_DEVICE%";
const PCWSTR Asr_SystemDeviceWin32Path  = L"\\\\?\\GLOBALROOT%ASR_C_SYSTEM_PARTITION_DEVICE%";
const PCWSTR Asr_WinntDeviceEnvName     = L"%ASR_C_WINNT_PARTITION_DEVICE%";

const PCWSTR Asr_SetupLogFilePath       = L"%systemroot%\\repair\\setup.log";
const PCWSTR Asr_AsrLogFilePath         = L"%systemroot%\\repair\\asr.log";
const PCWSTR Asr_AsrErrorFilePath       = L"%systemroot%\\repair\\asr.err";
const PCWSTR Asr_OldAsrErrorFilePath    = L"%systemroot%\\repair\\asr.err.old";

const PCWSTR Asr_FatalErrorCommand      = L"notepad.exe %systemroot%\\repair\\asr.err";


///////////////////////////////////////////////////////////////////////////////
// Data global to this module
///////////////////////////////////////////////////////////////////////////////
BOOL Gbl_IsAsrEnabled = FALSE;
PWSTR Gbl_AsrErrorFilePath = NULL;
PWSTR Gbl_AsrLogFilePath = NULL;
HANDLE Gbl_AsrLogFileHandle = NULL;
HANDLE Gbl_AsrSystemVolumeHandle = NULL;
WCHAR g_szErrorMessage[4196];


///////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////

//
// ASR Memory allocation and free wrappers
//

//
// _AsrAlloc
// Macro description:
//  ASSERTS first if ptr is non-NULL.  The expectation is that
//  all ptrs must be initialised to NULL before they are allocated.
//  That way, we can catch instances where we try to re-allocate
//  memory without freeing first.
//
// IsNullFatal:  flag to indicate if mem allocation failures are fatal
//
#define _AsrAlloc(ptr,sz,IsNullFatal)   {           \
                                                    \
    if (ptr != NULL) {                              \
        AsrpPrintDbgMsg(_asrinfo, "Pointer being allocated not NULL.\r\n"); \
        MYASSERT(0);                                  \
    }                                               \
                                                    \
    ptr = MyMalloc(sz);                             \
                                                    \
    if (ptr) {                                      \
        memset(ptr, 0, sz);                         \
    }                                               \
                                                    \
    if (!ptr) {                                     \
        if ((BOOLEAN) IsNullFatal) {                \
            AsrpPrintDbgMsg(_asrerror, "Setup was unable to allocate memory.\r\n"); \
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0); \
        }                                           \
        else {                                      \
            AsrpPrintDbgMsg(_asrwarn, "Warning.  Setup was unable to allocate memory.\r\n"); \
        }                                           \
    }                                               \
}


//
// _AsrFree
// Macro description:
//  Frees ptr and resets it to NULL.
//  Asserts if ptr was already NULL
//
#define _AsrFree(ptr)    {  \
                            \
    if (NULL != ptr) {      \
        MyFree(ptr);        \
        ptr = NULL;         \
    }                       \
    else {                  \
        AsrpPrintDbgMsg(_asrlog, "Attempt to free null Pointer.\r\n");   \
        MYASSERT(0);          \
    }                       \
}


#define _AsrFreeIfNotNull(ptr) {    \
    if (NULL != ptr) {      \
        MyFree(ptr);        \
        ptr = NULL;         \
    }                       \
}

//
// One ASR_RECOVERY_APP_NODE struct is created for each entry
// in the [COMMANDS] section of asr.sif.
//
typedef struct _ASR_RECOVERY_APP_NODE {
    struct _ASR_RECOVERY_APP_NODE *Next;

    //
    // Expect this to always be 1
    //
    LONG SystemKey;

    //
    // The sequence number according to which the apps are run.  If
    // two apps have the same sequence number, the app that appears
    // first in the sif file is run.
    //
    LONG SequenceNumber;

    //
    // The "actionOnCompletion" field for the app.  If CriticalApp is
    // non-zero, and the app returns an non-zero exit-code, we shall
    // consider it a fatal failure and quit out of ASR.
    //
    LONG CriticalApp;

    //
    // The app to be launched
    //
    PWSTR RecoveryAppCommand;

    //
    // The paramaters for the app.  This is just concatenated to the
    // string above.  May be NULL.
    //
    PWSTR RecoveryAppParams;

} ASR_RECOVERY_APP_NODE, *PASR_RECOVERY_APP_NODE;


//
// This contains our list of entries in the COMMANDS section,
// sorted in order of sequence numbers.
//
typedef struct _ASR_RECOVERY_APP_LIST {
    PASR_RECOVERY_APP_NODE  First;      // Head
    PASR_RECOVERY_APP_NODE  Last;       // Tail
    LONG AppCount;                      // NumEntries
} ASR_RECOVERY_APP_LIST, *PASR_RECOVERY_APP_LIST;



//
// We call this to change the boot.ini timeout value to 30 seconds
//
extern BOOL
ChangeBootTimeout(IN UINT Timeout);

//
// From asr.c
//
extern BOOL
AsrpRestoreNonCriticalDisksW(
    IN PCWSTR   lpSifPath,
    IN BOOL     bAllOrNothing
    );


extern BOOL
AsrpRestoreTimeZoneInformation(
    IN PCWSTR   lpSifPath
    );

//
// Indices for fields in the [COMMANDS] section.
//
typedef enum _SIF_COMMANDS_FIELD_INDEX {
    ASR_SIF_COMMANDS_KEY = 0,
    ASR_SIF_SYSTEM_KEY,             // Expected to always be "1"
    ASR_SIF_SEQUENCE_NUMBER,
    ASR_SIF_ACTION_ON_COMPLETION,
    ASR_SIF_COMMAND_STRING,
    ASR_SIF_COMMAND_PARAMETERS,     // May be NULL
    SIF_SIF_NUMFIELDS               // Must always be last
} SIF_COMMANDS_FIELD_INDEX;

#define _Asr_CHECK_BOOLEAN(b,msg) \
    if((b) == FALSE) { \
        AsrpFatalErrorExit(MSG_FATAL_ERROR, __LINE__, (msg)); \
    }


///////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////



//
// Logs the message to the asr error file.  Note that
// AsrpInitialiseErrorFile must have been called once before
// this routine is used.
//
VOID
AsrpLogErrorMessage(
    IN PCWSTR buffer
    )
{
    HANDLE hFile = NULL;
    DWORD bytesWritten = 0;

    if (Gbl_AsrErrorFilePath) {
        //
        // Open the error log
        //
        hFile = CreateFileW(
            Gbl_AsrErrorFilePath,           // lpFileName
            GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_ALWAYS,                  // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );
        if ((!hFile) || (INVALID_HANDLE_VALUE == hFile)) {
            return;
        }

        //
        // Move to the end of file
        //
        SetFilePointer(hFile, 0L, NULL, FILE_END);

        //
        // Add our error string
        //
        WriteFile(hFile,
            buffer,
            (wcslen(buffer) * sizeof(WCHAR)),
            &bytesWritten,
            NULL
            );

        //
        // And we're done
        //
        CloseHandle(hFile);
    }
}


//
// Logs the message to the asr log file.  Note that
// AsrpInitialiseLogFile must have been called once before
// this routine is used.
//
VOID
AsrpLogMessage(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN CONST PCSTR Message
    )
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    char buffer[4196];
    GetSystemTime(&currentTime);

    sprintf(buffer,
        "[%04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu] %c%lu %s%s",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds,
        Module,
        Line,
        ((DPFLTR_ERROR_LEVEL == MesgLevel) ? "(Error:ASR) " :  (DPFLTR_WARNING_LEVEL == MesgLevel ? "(Warning:ASR) " : "")),
        Message
        );

    if (Gbl_AsrLogFileHandle) {
        WriteFile(Gbl_AsrLogFileHandle,
            buffer,
            (strlen(buffer) * sizeof(char)),
            &bytesWritten,
            NULL
            );
    }

}


VOID
AsrpPrintDbgMsg(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...)
/*++
Description:
    This prints a debug message AND makes the appropriate entries in
    the log and error files.

Arguments:
    Line            pass in __LINE__
    MesgLevel       DPFLTR_ levels
    FormatString    Formatted Message String to be printed.

Returns:

--*/
{
    char str[4096];     // the message better fit in this
    va_list arglist;

    DbgPrintEx(DPFLTR_SETUP_ID, MesgLevel, "ASR %c%lu ", Module, Line);

    va_start(arglist, FormatString);
    wvsprintfA(str, FormatString, arglist);
    va_end(arglist);

    DbgPrintEx(DPFLTR_SETUP_ID, MesgLevel, str);

    if ((DPFLTR_ERROR_LEVEL == MesgLevel) ||
        (DPFLTR_WARNING_LEVEL == MesgLevel) ||
        (DPFLTR_TRACE_LEVEL == MesgLevel)
        ) {
        AsrpLogMessage(Module, Line, MesgLevel, str);
    }
}


//
// This will terminate Setup and cause a reboot.  This is called
// on Out of Memory errors
//
VOID
AsrpFatalErrorExit(
    IN LONG MsgValue,
    IN LONG LineNumber,
    IN PWSTR MessageString
   )
{
    AsrpPrintDbgMsg(THIS_MODULE, LineNumber, DPFLTR_ERROR_LEVEL, "Fatal Error: %ws (%lu)",
        (MessageString ? MessageString : L"(No error string)"), GetLastError()
        );

    FatalError(MsgValue, MessageString, 0, 0);
}


//
// This just adds the new node to the end of the list.
// Note that this does NOT sort the list by sequenceNumber:
// we'll do that later on
//
VOID
AsrpAppendNodeToList(
    IN PASR_RECOVERY_APP_LIST pList,
    IN PASR_RECOVERY_APP_NODE pNode
   )
{
    //
    // Insert at end of list.
    //
    pNode->Next = NULL;

    if (pList->AppCount == 0) {
        pList->First = pNode;
    } else {
        pList->Last->Next = pNode;
    }

    pList->Last  = pNode;
    pList->AppCount += 1;
}


//
// Pops off the first node in the list.  The list is sorted
// in order of increasing SequenceNumber's at this point.
//
PASR_RECOVERY_APP_NODE
AsrpRemoveFirstNodeFromList(
    IN PASR_RECOVERY_APP_LIST pList
   )
{
    PASR_RECOVERY_APP_NODE pNode;

    if(pList->AppCount == 0) {
        return NULL;
    }

    pNode = pList->First;
    pList->First = pNode->Next;
    pList->AppCount -= 1;

    MYASSERT(pList->AppCount >= 0);

    return  pNode;
}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    _AsrAlloc(expandedString, (cchSize * sizeof(WCHAR)), TRUE);

    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString,
        expandedString,
        cchSize
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        _AsrFree(expandedString);
        cchSize = cchRequiredSize + 1;

        _AsrAlloc(expandedString, (cchSize * sizeof(WCHAR)), TRUE);
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString,
            expandedString,
            cchSize
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough
        // even on the second try
        //
        _AsrFree(expandedString);   // sets it to NULL
    }

    return expandedString;
}

//
// Builds the invocation string, as the name suggests.  It expands out
// the environment variables that apps are allowed to use in the
// sif file, and adds in /sifpath=<path to the sif file> at the end
// of the command.  So for an entry in the COMMANDS section of
// the form:
// 4=1,3500,0,"%TEMP%\app.exe","/param1 /param2"
//
// the invocation string would be of the form:
// c:\windows\temp\app.exe /param1 /param2 /sifpath=c:\windows\repair\asr.sif
//
//
PWSTR
AsrpBuildInvocationString(
    IN PASR_RECOVERY_APP_NODE pNode     // must not be NULL
   )
{
    PWSTR app   = pNode->RecoveryAppCommand,
        args    = pNode->RecoveryAppParams,
        cmd     = NULL,
        fullcmd = NULL;

    DWORD size  = 0;

    MYASSERT(app);

    //
    // Build an command line that looks like...
    //
    //      "%TEMP%\ntbackup recover /1 /sifpath=%systemroot%\repair\asr.sif"
    //
    // The /sifpath parameter is added to all apps being launched
    //

    //
    //  Allocate memory for the cmd line
    //
    size = sizeof(WCHAR) *
        (
        wcslen(app) +                       // app name     "%TEMP%\ntbackup"
        (args ? wcslen(args) : 0) +         // arguments    "recover /1"
        wcslen(AsrCommandSuffix) +          // suffix       "/sifpath=%systemroot%\repair\asr.sif"
        4                                   // spaces and null
        );
    _AsrAlloc(cmd, size, TRUE); // won't return if alloc fails

    //
    // Build the string
    //
    swprintf(cmd,
        L"%ws %ws %ws",
        app,
        (args? args: L""),
        AsrCommandSuffix
       );

    //
    // Expand the %% stuff, to build the full path
    //
    fullcmd = AsrpExpandEnvStrings(cmd);

    _AsrFree(cmd);
    return fullcmd;
}


BOOL
AsrpRetryIsServiceRunning(
    IN PWSTR ServiceName,
    IN UINT MaxRetries
    )
{
    SERVICE_STATUS status;
    SC_HANDLE svcHandle = NULL, // handle to the service
        scmHandle = NULL;       // handle to the service control manager
    UINT count = 0;
    BOOL errorsEncountered = FALSE;
    PWSTR errString = NULL;

    scmHandle = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (!scmHandle) {
        //
        // OpenSCManager() call failed - we are broke.
        //
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to open the service control manager.  The error code returned was 0x%x.\r\n",
            GetLastError()
            );

        errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_OPEN_SCM);

        if (errString) {
            swprintf(g_szErrorMessage, errString, GetLastError());
            AsrpLogErrorMessage(g_szErrorMessage);
            MyFree(errString);
            errString = NULL;
        }
        else {
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
        }


        errorsEncountered = TRUE;
        goto EXIT;
    }

    svcHandle = OpenServiceW(scmHandle, ServiceName, SERVICE_QUERY_STATUS);
    if (!svcHandle) {
        //
        // OpenService() call failed - we are broke.
        //
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to start the service \"%ws\".  The error code returned was 0x%x.\r\n",
            ServiceName,
            GetLastError()
            );

        errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_START_SERVICE);

        if (errString) {
            swprintf(g_szErrorMessage, errString, ServiceName, GetLastError());
            AsrpLogErrorMessage(g_szErrorMessage);
            MyFree(errString);
            errString = NULL;
        }
        else {
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
        }


        errorsEncountered = TRUE;
        goto EXIT;
    }

    //
    // Got the service opened for query. See if it's running, and
    // if not, go thru the retry loop.
    //
    while (count < MaxRetries) {

        if (!QueryServiceStatus(svcHandle, &status)) {
            //
            // Couldn't query the status of the service
            //
            AsrpPrintDbgMsg(_asrerror,
                "Setup was unable to query the status of service \"%ws\".  The error code returned was 0x%x\r\n",
                ServiceName,
                GetLastError()
                );

            errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_START_SERVICE);

            if (errString) {
                swprintf(g_szErrorMessage, errString, ServiceName, GetLastError());
                AsrpLogErrorMessage(g_szErrorMessage);
                MyFree(errString);
                errString = NULL;
            }
            else {
                FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
            }

            errorsEncountered = TRUE;
            goto EXIT;
        }

        if (status.dwCurrentState == SERVICE_RUNNING) {
            //
            // Service is running - we can proceed.
            //
            break;
        }

        ++count;

        AsrpPrintDbgMsg(_asrinfo,
            "Attempting to start service [%ws]: status = [%d], retry [%d]\r\n",
            ServiceName,
            status.dwCurrentState,
            count
           );

        Sleep(2000);
    }

EXIT:
    if ((svcHandle) && (INVALID_HANDLE_VALUE != svcHandle)) {
        CloseServiceHandle(svcHandle);
        svcHandle = NULL;
    }

    if ((scmHandle) && (INVALID_HANDLE_VALUE != svcHandle)) {
        CloseServiceHandle(scmHandle);
        scmHandle = NULL;
    }

    if ((errorsEncountered) || (count >= MaxRetries)) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}


//
// Before launching apps, we need RSM (specifically, the backup app
// might need RSM to access its backup media)
//
VOID
AsrpStartNtmsService(VOID)
{
    BOOL result = TRUE;
    DWORD exitCode = ERROR_SUCCESS;
    PWSTR registerNtmsCommand = NULL;

    AsrpPrintDbgMsg(_asrinfo, "Entered InitNtmsService()\r\n");

    //
    // RSM isn't setup to run during GUI mode setup, but the back-up app is
    // likely going to need access to tape-drives and other RSM devices.
    // So we regsvr32 the appropriate dll's and start the service
    //
    // Register the rsmps.dll using:
    //   regsvr32 /s %Systemroot%\system32\rsmps.dll
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"regsvr32 /s %systemroot%\\system32\\rsmps.dll");
    
    if (registerNtmsCommand) {        
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
        AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
        _AsrFree(registerNtmsCommand);
    }
    _Asr_CHECK_BOOLEAN(result, L"regsvr32 /s %systemroot%\\rsmps.dll failed\r\n");

    //
    // Register the rsmmllsv.exe using:
    //  %SystemRoot%\system32\rsmmllsv.exe /regserver
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"%systemroot%\\system32\\rsmmllsv.exe /regserver");
    
    if (registerNtmsCommand) {
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
        AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
        _AsrFree(registerNtmsCommand);
    }
    _Asr_CHECK_BOOLEAN(result, L"%systemroot%\\system32\\rsmmllsv.exe /regserver failed\r\n");

    //
    // Register the ntmssvc.dll using:
    //  regsvr32 /s %SystemRoot%\system32\ntmssvc.dll
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"regsvr32 /s %systemroot%\\system32\\ntmssvc.dll");

    if (registerNtmsCommand) {
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
        AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
        _AsrFree(registerNtmsCommand);
    }
    _Asr_CHECK_BOOLEAN(result, L"regsvr32 /s %systemroot%\\ntmssvc.dll failed\r\n");

    //
    // Register the rsmsink.exe using:
    //  %SystemRoot%\system32\rsmsink.exe /regserver
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"%systemroot%\\system32\\rsmsink.exe /regserver");
    
    if (registerNtmsCommand) {
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
        AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
        _AsrFree(registerNtmsCommand);
    }
    _Asr_CHECK_BOOLEAN(result, L"%systemroot%\\system32\\rsmsink.exe /regserver failed\r\n");

    //
    // Now, start the ntms service.
    //
    result = SetupStartService(L"ntmssvc", FALSE);
    _Asr_CHECK_BOOLEAN(result, L"Could not start RSM service (ntmssvc).\r\n");

    //
    // Check for ntms running, give a few retries.
    //
    result = AsrpRetryIsServiceRunning(L"ntmssvc", 30);
    _Asr_CHECK_BOOLEAN(result, L"Failed to start RSM service after 30 retries.\r\n");

    AsrpPrintDbgMsg(_asrinfo, "RSM service (ntmssvc) started.\r\n");
}


PWSTR
AsrpReadField(
    PINFCONTEXT pInfContext,
    DWORD       FieldIndex,
    BOOL        NullOkay
   )
{
    PWSTR   data        = NULL;
    UINT    reqdSize    = 0;
    BOOL    result      = FALSE;

    //
    //  Allocate memory and read the data
    //
    _AsrAlloc(data, (sizeof(WCHAR) * (MAX_PATH + 1)), TRUE);

    result = SetupGetStringFieldW(
        pInfContext,
        FieldIndex,
        data,
        MAX_PATH + 1,
        &reqdSize
       );

    if (!result) {
        DWORD status = GetLastError();
        //
        // If our buffer was too small, allocate a larger buffer
        // and try again
        //
        if (ERROR_INSUFFICIENT_BUFFER == status) {
            status = ERROR_SUCCESS;

            _AsrFree(data);
            _AsrAlloc(data, (sizeof(WCHAR) * reqdSize), TRUE);

            result = SetupGetStringFieldW(
                pInfContext,
                FieldIndex,
                data,
                reqdSize,
                NULL    // don't need required size any more
               );
        }
    }

    if (!result) {
        _AsrFree(data);
        _Asr_CHECK_BOOLEAN(NullOkay, L"Could not read entry from commands section");
        // Never returns if NullOkay is FALSE.
        // Memory leaks here then, since we don't free some structs.  But
        // it's a fatal error, so the system must be rebooted anyway
        //
    }

    return data;
}

//
// This adds in the "Instance" value under the ASR key.
// Third party applications (or Windows components like DTC) can use
// this to determine if a new ASR has been run since the last time we
// booted, and can take any actions they need to.  For instance, the
// DTC log file needs to be recreated after an ASR, since it is not
// backed-up or restored by the backup app, and Dtc refuses to start
// if it doesn't find a log file when it expects one.
//
VOID
AsrpAddRegistryEntry()
{

    LONG result = 0;
    HKEY regKey = NULL;

    WCHAR   szLastInstanceData[40];
    DWORD   cbLastInstanceData = 0;

    SYSTEMTIME currentTime;

    GUID asrInstanceGuid;

    PWSTR lpGuidString = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    //
    // We try to set the key to a newly generated GUID, to make sure it is
    // unique (and different from the previous value stored there).  If, for
    // some reason, we aren't able to generate a GUID, we'll just store the
    // current date and time as a string--that should be unique, too.
    //
    rpcStatus = UuidCreate(
        &asrInstanceGuid
        );

    if (RPC_S_OK == rpcStatus) {
        //
        // Convert the GUID to a printable string
        //
        rpcStatus = UuidToStringW(
            &asrInstanceGuid,
            &lpGuidString
            );

        if (RPC_S_OK == rpcStatus) {
            wsprintf(szLastInstanceData,
                L"%ws",
                lpGuidString
                );
            cbLastInstanceData = wcslen(szLastInstanceData)*sizeof(WCHAR);
        }

        if (lpGuidString) {
            RpcStringFreeW(&lpGuidString);
        }
    }


    if (RPC_S_OK != rpcStatus)  {
        //
        // We couldn't get a GUID.  Let's store the time-stamp ...
        //
        GetSystemTime(&currentTime);
        wsprintf(szLastInstanceData,
            L"%04hu%02hu%02hu%02hu%02hu%02hu%03hu",
            currentTime.wYear,
            currentTime.wMonth,
            currentTime.wDay,
            currentTime.wHour,
            currentTime.wMinute,
            currentTime.wSecond,
            currentTime.wMilliseconds
            );
        cbLastInstanceData = wcslen(szLastInstanceData)*sizeof(WCHAR);
    }

    result = RegCreateKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        Asr_ControlAsrRegKey,       // lpSubKey
        0,                  // reserved
        NULL,               // lpClass
        REG_OPTION_NON_VOLATILE,    // dwOptions
        MAXIMUM_ALLOWED,     // samDesired
        NULL,               // lpSecurityAttributes
        &regKey,            // phkResult
        NULL                // lpdwDisposition
        );
    if ((ERROR_SUCCESS != result) || (!regKey)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not create the Control\\ASR registry entry (0x%x).\r\n",
            result
            );
        return;
    }

    result = RegSetValueExW(
        regKey,             // hKey
        Asr_LastInstanceRegValue,       // lpValueName
        0L,                 // reserved
        REG_SZ,             // dwType
        (LPBYTE)szLastInstanceData,     // lpData
        cbLastInstanceData              // cbData
        );

    RegCloseKey(regKey);

    if (ERROR_SUCCESS != result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not set the ASR instance-ID in the registry (0x%x).\r\n",
            result
            );
        return;
    }

    AsrpPrintDbgMsg(_asrlog,
        "Set the ASR instance-ID at [%ws\\%ws] value to [%ws]\r\n",
        Asr_ControlAsrRegKey,
        Asr_LastInstanceRegValue,
        szLastInstanceData
        );

}

VOID
AsrpSetEnvironmentVariables()
{

    PWSTR TempPath = AsrpExpandEnvStrings(AsrTempDir);

    if (NULL == TempPath) {
        return;
    }

    if (!CreateDirectoryW(TempPath, NULL)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to create TEMP directory [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }

    AsrpPrintDbgMsg(_asrlog,
        "Setting environment variables TEMP and TMP to [%ws]\r\n",
        TempPath
        );

    if (!SetEnvironmentVariableW(L"TEMP", TempPath)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to set environment variable TEMP to [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }


    if (!SetEnvironmentVariableW(L"TMP", TempPath)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to set environment variable TEMP to [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }

    _AsrFree(TempPath);

    return;

}


VOID
AsrpInitExecutionEnv(
    OUT PASR_RECOVERY_APP_LIST List
   )
{
    PWSTR   stateFileName   = NULL;
    HINF    sifHandle       = NULL;

    LONG    lineCount       = 0,
            line            = 0;

    BOOL    result          = FALSE;

    INFCONTEXT infContext;

    //
    // Start the RSM service
    //
    AsrpStartNtmsService();

    //
    // Open the asr.sif file and build the list
    // of commands to be launched.
    //
    stateFileName = AsrpExpandEnvStrings(AsrSifPath);
    if (!stateFileName) {
        AsrpPrintDbgMsg(_asrerror, "Setup was unable to locate the ASR state file asr.sif on this machine.\r\n");
        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    sifHandle = SetupOpenInfFileW(
        stateFileName,
        NULL,               // Inf Class
        INF_STYLE_WIN4,
        NULL                // Error-line
       );

    if ((!sifHandle) || (INVALID_HANDLE_VALUE == sifHandle)) {
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to process the ASR state file %ws (0x%x).  This could indicate that the file is corrupt, or has been modified since the last ASR backup.\r\n",
            stateFileName,
            GetLastError());
        _AsrFree(stateFileName);

        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }
    _AsrFree(stateFileName);

    //
    // Read the COMMANDS section, and add each command to our list
    //
    lineCount = SetupGetLineCountW(sifHandle, AsrCommandsSectionName);
    for (line = 0; line < lineCount; line++) {

        //
        // Create a new node
        //
        PASR_RECOVERY_APP_NODE pNode = NULL;
        _AsrAlloc(pNode, (sizeof(ASR_RECOVERY_APP_NODE)), TRUE);

        //
        //  Get the inf context for the line in asr.sif.  This will be used
        //  to read the fields on that line
        //
        result = SetupGetLineByIndexW(
            sifHandle,
            AsrCommandsSectionName,
            line,
            &infContext
           );
        _Asr_CHECK_BOOLEAN(result, L"SetupGetLinebyIndex failed");

        //
        // Read in the int fields
        //
        result = SetupGetIntField(
            &infContext,
            ASR_SIF_SYSTEM_KEY,
            &(pNode->SystemKey)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get system key in commands section");

        result = SetupGetIntField(
            &infContext,
            ASR_SIF_SEQUENCE_NUMBER,
            &(pNode->SequenceNumber)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get sequence number in commands section");

        result = SetupGetIntField(
            &infContext,
            ASR_SIF_ACTION_ON_COMPLETION,
            &(pNode->CriticalApp)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get criticalApp in commands section");

        //
        // Read in the string fields
        //
        pNode->RecoveryAppCommand = AsrpReadField(
            &infContext,
            ASR_SIF_COMMAND_STRING,
            FALSE                   // Null not okay
           );

        pNode->RecoveryAppParams = AsrpReadField(
            &infContext,
            ASR_SIF_COMMAND_PARAMETERS,
            TRUE                   // Null okay
           );

        //
        // Add this node to our list, and move on to next
        //
        AsrpAppendNodeToList(List, pNode);
    }

    SetupCloseInfFile(sifHandle);
}


//
// Bubble sort ...
//
VOID
AsrpSortAppListBySequenceNumber(PASR_RECOVERY_APP_LIST pList)
{
    PASR_RECOVERY_APP_NODE
        pCurr       = NULL,
        pNext       = NULL,
        *ppPrev     = NULL;

    BOOLEAN done    = FALSE;

    if ((!pList) || (!pList->First)) {
        MYASSERT(0 && L"Recovery App List pList is NULL");
        return;
    }

    //
    // Start the outer loop. Each iteration of the outer loop includes a
    // full pass down the list, and runs until the inner loop is satisfied
    // that no more passes are needed.
    //
    while (!done) {
        //
        // Start at the beginning of the list for each inner (node) loop.
        //
        // We will initialize a pointer *to the pointer* which points to
        // the current node - this pointer might be the address of the "list
        // first" pointer (as it always will be at the start of an inner loop),
        // or as the inner loop progresses, it might be the address of the
        // "next" pointer in the previous node. In either case, the pointer
        // to which ppPrev points will be changed in the event of a node swap.
        //
        pCurr  =   pList->First;
        ppPrev = &(pList->First);
        done = TRUE;

        MYASSERT(pCurr);

        while (TRUE) {
            pNext = pCurr->Next;
            //
            // If the current node is the last one, reset to the beginning
            // and break out to start a new inner loop.
            //
            if (pNext == NULL) {
                pCurr = pList->First;
                break;
            }

            //
            // If the node *after* the current node has a lower sequence
            // number, fix up the pointers to swap the two nodes.
            //
            if (pCurr->SequenceNumber > pNext->SequenceNumber) {
                done = FALSE;

                pCurr->Next = pNext->Next;
                pNext->Next = pCurr;
                *ppPrev = pNext;
                ppPrev = &(pNext->Next);
            }
            else {
                ppPrev = &(pCurr->Next);
                pCurr  =   pCurr->Next;
            }
        }
    }
}


VOID
AsrpPerformSifIntegrityCheck(IN HINF Handle)
{
    //
    // No check for now.
    //
    return;
}

//
// This checks if the following entries are different in setup.log
// from their values.  This could happen because we might have installed
// to a new disk that has a different disk number
//
// [Paths]
// TargetDevice = "\Device\Harddisk0\Partition2"
// SystemPartition = "\Device\Harddisk0\Partition1"
//
// If they are different, we'll update them.
//
BOOL
AsrpCheckSetupLogDeviceEntries(
    PWSTR CurrentSystemDevice,      // used for SystemPartition
    PWSTR CurrentBootDevice,        // used for TargetDevice
    PWSTR LogFileName               // path to setup.log
   )
{
    WCHAR szLine[MAX_INF_STRING_LENGTH + 1];
    PWSTR lpLine = NULL;
    BOOL isDifferent = FALSE;
    FILE *fp = NULL;
    INT iNumEntries = 0;

    //
    // Open existing setup.log
    //
    fp = _wfopen(LogFileName, L"r");
    if (!fp) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not open setup log file [%ws]\r\n",
            LogFileName
            );
        return FALSE;
    }

    //
    // Check each line of the file for the System or Boot device entries
    //
    lpLine = fgetws(szLine, MAX_PATH-1, fp);
    while ((lpLine) && (iNumEntries < 2)) {
        BOOL systemEntry = FALSE;
        BOOL bootEntry = FALSE;

        if (wcsstr(szLine, L"SystemPartition =")) {
            systemEntry = TRUE;
            iNumEntries++;
        }
        if (wcsstr(szLine, L"TargetDevice =")) {
            bootEntry = TRUE;
            iNumEntries++;
        }

        if (systemEntry || bootEntry) {

            PWSTR DeviceName = NULL;
            //
            // Both the system and boot entries must have the full
            // devicepath in them, of the form \Device\Harddisk0\Partition1
            //
            DeviceName = wcsstr(szLine, L"\\Device");
            if (!DeviceName) {
                isDifferent = TRUE;
                AsrpPrintDbgMsg(_asrlog,
                    "Marking setup logs different:  \\Device\\ not found in boot or system entry\r\n"
                    );
                break;
            }
            else {
                //
                // Find the start of the "Hardisk0\Partition1" text after \Device
                //
                PWSTR ss = wcsstr(DeviceName, L"\"");
                if (!ss) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "Marking setup logs different:  \\Device\\ not found in boot or system entry\r\n"
                        );
                    break;
                }
                else {
                    ss[0] = L'\0';
                }
            }

            //
            // And check if this device matches
            //
            if (systemEntry) {
                AsrpPrintDbgMsg(_asrinfo,
                    "Comparing System Device.  Current:[%ws] setup.log:[%ws]\r\n",
                    CurrentSystemDevice,
                    DeviceName
                    );

                if (wcscmp(DeviceName, CurrentSystemDevice) != 0) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "System Device has changed.  Current:[%ws] setup.log:[%ws]\r\n",
                        CurrentSystemDevice,
                        DeviceName
                        );
                    break;
                }
            }
            else if (bootEntry) {
                AsrpPrintDbgMsg(_asrinfo,
                    "Comparing Boot Device.  Current:[%ws] setup.log:[%ws]\r\n",
                    CurrentBootDevice,
                    DeviceName
                    );

                if (wcscmp(DeviceName, CurrentBootDevice) != 0) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "Boot device has changed.  Current:[%ws] setup.log:[%ws]\r\n",
                        CurrentBootDevice,
                        DeviceName
                        );
                    break;
                }
            }
        }

        lpLine = fgetws(szLine, MAX_PATH-1, fp);
    }

    if (!isDifferent) {
        AsrpPrintDbgMsg(_asrinfo,  "No changes in system and boot devices for setup.log\r\n");
    }

    fclose(fp);
    fp = NULL;

    return isDifferent;
}


//
// If the setup.log restored by the backup from tape has a different
// boot or system device marked (we might have picked a new disk in
// textmode Setup), this will update the relevant entries to match the
// current boot and system devices.
//
VOID
AsrpMergeSetupLog(
    PWSTR CurrentSystemDevice,
    PWSTR CurrentBootDevice,
    PWSTR LogFileName
    )
{
    WCHAR szLine[MAX_INF_STRING_LENGTH + 1];

    PWSTR lpLine = NULL,
        lpOldFileName = NULL,
        lpNewFileName = NULL;

    BOOL result = FALSE;
    FILE *fpNew = NULL,
        *fpCurrent = NULL;

    INT iNumEntries = 0;

    //
    // Create the "new" and "old" file names, i.e., "setup.log.new" and "setup.log.old"
    //
    _AsrAlloc(lpNewFileName, ((wcslen(LogFileName) + 5) * sizeof(WCHAR)), TRUE)
    wcscpy(lpNewFileName, LogFileName);
    wcscat(lpNewFileName, L".new");

    _AsrAlloc(lpOldFileName, ((wcslen(LogFileName) + 5) * sizeof(WCHAR)), TRUE);
    wcscpy(lpOldFileName, LogFileName);
    wcscat(lpOldFileName, L".old");

    //
    // Open the current setup.log file.
    //
    fpCurrent = _wfopen(LogFileName, L"r");
    if (!fpCurrent) {
        AsrpPrintDbgMsg(_asrwarn, "Setup was unable to open the setup log file \"%ws\"\r\n", LogFileName);
        goto EXIT;
    }

    //
    // Open the new file - we will write into this one.
    //
    fpNew = _wfopen(lpNewFileName, L"w");
    if (!fpNew) {
        AsrpPrintDbgMsg(_asrwarn, "Setup was unable to open the setup log file \"%ws\"\r\n", lpNewFileName);
        goto EXIT;
    }

    //
    // Read each line in the log file, copy into the new file, unless we hit
    // one of the two lines in question. Once we've seen both of them, don't
    // check for them anymore.
    //
    lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
    while (lpLine) {
        BOOL systemEntry = FALSE;
        BOOL bootEntry = FALSE;

        //
        // If we've already found both entries of interest, just copy
        // and continue.
        //
        if (iNumEntries >= 2) {
            fputws(szLine, fpNew);

            lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
            continue;
        }

        //
        // Is this line either the boot or system device?
        //
        if (wcsstr(szLine, L"SystemPartition =")) {

            AsrpPrintDbgMsg(_asrlog,
                "Changing SystemPartition in setup.log to %ws\r\n",
                CurrentSystemDevice
                );
            ++iNumEntries;

            wcscpy(szLine, L"SystemPartition = \"");
            wcscat(szLine, CurrentSystemDevice);
            wcscat(szLine, L"\"\n");
        }
        else if (wcsstr(szLine, L"TargetDevice =")) {

            AsrpPrintDbgMsg(_asrlog,
                "Changing TargetDevice in setup.log to %ws\r\n",
                CurrentBootDevice
                );
            ++iNumEntries;

            wcscpy(szLine, L"TargetDevice = \"");
            wcscat(szLine, CurrentBootDevice);
            wcscat(szLine, L"\"\n");
        }

        fputws(szLine, fpNew);

        lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
   }

    //
    // Rename the current setup.log to setup.log.old, and setup.log.new to
    // setup.log.  Need to delay this until reboot since setup.log is in
    // use.
    //
    result = MoveFileExW(LogFileName,
        lpOldFileName,
        MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
        );
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "MoveFileEx([%ws] to [%ws]) failed (%lu)",
            LogFileName, lpOldFileName, GetLastError()
            );
    }
    else {
        result = MoveFileExW(lpNewFileName,
            LogFileName,
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
            );
        if (!result) {
            AsrpPrintDbgMsg(_asrwarn,
                "MoveFileEx([%ws] to [%ws]) failed (%lu)",
                lpNewFileName, LogFileName, GetLastError()
                );
        }
    }

EXIT:


    if (fpCurrent) {
        fclose(fpCurrent);
        fpCurrent = NULL;
    }

    if (fpNew) {
        fclose(fpNew);
        fpNew = NULL;
    }

    _AsrFree(lpNewFileName);
    _AsrFree(lpOldFileName);
}


VOID
AsrpMergeSetupLogIfNeeded()
{
    PWSTR currentSystemDevice = NULL,
        currentBootDevice = NULL,
        winntRootDir = NULL,
        setupLogFileName = NULL;

    BOOL isSetupLogDifferent = FALSE;

    //
    // Get the environment variable for the partition devices
    //
    currentSystemDevice = AsrpExpandEnvStrings(Asr_SystemDeviceEnvName);
    currentBootDevice = AsrpExpandEnvStrings(Asr_WinntDeviceEnvName);
    setupLogFileName = AsrpExpandEnvStrings(Asr_SetupLogFilePath);

    if ((!currentSystemDevice) ||
        (!currentBootDevice) ||
        (!setupLogFileName)) {
        goto EXIT;
    }

    //
    // Check if the system and/or boot devices listed in setup.log are
    // different than the current devices
    //
    isSetupLogDifferent = AsrpCheckSetupLogDeviceEntries(
        currentSystemDevice,
        currentBootDevice,
        setupLogFileName
        );

    if (isSetupLogDifferent) {
        //
        // They are different: fix it.
        //
        AsrpMergeSetupLog(currentSystemDevice,
            currentBootDevice,
            setupLogFileName
            );
    }

EXIT:
    _AsrFreeIfNotNull(setupLogFileName);
    _AsrFreeIfNotNull(currentBootDevice);
    _AsrFreeIfNotNull(currentSystemDevice);
}


//
// This creates an ASR log file at %systemroot%\asr.log,
// and also initialises Gbl_AsrLogFileHandle.
//
VOID
AsrpInitialiseLogFile()
{

    PWSTR currentSystemDevice = NULL;

    Gbl_AsrLogFileHandle = NULL;
    Gbl_AsrSystemVolumeHandle = NULL;

    //
    // Get full path to the error file.
    //
    Gbl_AsrLogFilePath = AsrpExpandEnvStrings(Asr_AsrLogFilePath);
    if (!Gbl_AsrLogFilePath) {
        goto OPENSYSTEMHANDLE;
    }

    //
    // Create an empty file (over-write it if it already exists).
    //
    Gbl_AsrLogFileHandle = CreateFileW(
        Gbl_AsrLogFilePath,             // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode: nobody else should write to the log file while we are
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                    // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes: write through so we flush
        NULL                            // hTemplateFile
        );

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        //
        // Move to the end of file
        //
        SetFilePointer(Gbl_AsrLogFileHandle, 0L, NULL, FILE_END);

    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Unable to create/open ASR log file at %ws (0x%x)\r\n",
            Gbl_AsrLogFilePath,
            GetLastError()
           );
    }

OPENSYSTEMHANDLE:

    //
    // Open a handle to the system volume.  This is needed since the system
    // disk might otherwise be removed and added back by PnP during the
    // device detecion and re-installation phase (which will cause the
    // HKLM\System\Setup\SystemPartition key to be out-of-sync, and apps/
    // components such as LDM that depend on that key to find the system
    // partition will fail).
    //
    // The more permanent work-around to this involves a change in mountmgr,
    // (such that it updates this key everytime the system volume disappears
    // and reappears) but for now, holding an open handle to the system
    // volume should suffice.
    //
    // See Windows Bugs 155675 for more information.
    //
    currentSystemDevice = AsrpExpandEnvStrings(Asr_SystemDeviceWin32Path);

    if (currentSystemDevice) {
        Gbl_AsrSystemVolumeHandle = CreateFileW(
            currentSystemDevice,           // lpFileName
            FILE_READ_ATTRIBUTES,             // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE,          // dwShareMode
            NULL,                     // lpSecurityAttributes
            OPEN_EXISTING,              // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,    // dwFlagsAndAttributes: write through so we flush
            NULL                      // hTemplateFile
            );

        if ((Gbl_AsrSystemVolumeHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrSystemVolumeHandle)) {
            AsrpPrintDbgMsg(_asrinfo, "Opened a handle to the system volume %ws\r\n", currentSystemDevice);
        }
        else {
            AsrpPrintDbgMsg(_asrinfo, "Unable to open a handle to the system volume %ws (0x%x)\r\n",
                currentSystemDevice,
                GetLastError()
               );
        }

        _AsrFree(currentSystemDevice);
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, "Unable to get current system volume (0x%x)\r\n", GetLastError());
    }

}


//
// This creates an empty ASR error file at %systemroot%\asr.err,
// and also initialises Gbl_AsrErrorFilePath with the full path
// to asr.err
//
VOID
AsrpInitialiseErrorFile()
{
    HANDLE errorFileHandle = NULL;
    PWSTR lpOldFileName = NULL;
    DWORD size = 0;
    BOOL bResult = FALSE;
    char  UnicodeFlag[3];

    //
    // Get full path to the error file.
    //
    Gbl_AsrErrorFilePath = AsrpExpandEnvStrings(Asr_AsrErrorFilePath);
    if (!Gbl_AsrErrorFilePath) {
        return;
    }

    lpOldFileName = AsrpExpandEnvStrings(Asr_OldAsrErrorFilePath);
    if (lpOldFileName) {
        //
        // If the file already exists, move it to asr.err.old
        //
        MoveFileExW(Gbl_AsrErrorFilePath, lpOldFileName, MOVEFILE_REPLACE_EXISTING);
    }

    //
    // Create an empty file (append to it if it already exists), and close it
    // immediately
    //
    errorFileHandle = CreateFileW(
        Gbl_AsrErrorFilePath,           // lpFileName
        GENERIC_WRITE,                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                           // lpSecurityAttributes
        CREATE_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((errorFileHandle) && (INVALID_HANDLE_VALUE != errorFileHandle)) {
        sprintf(UnicodeFlag, "%c%c", 0xFF, 0xFE);
        WriteFile(errorFileHandle, UnicodeFlag, strlen(UnicodeFlag)*sizeof(char), &size, NULL);
        CloseHandle(errorFileHandle);
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL,
            "ASR %c%lu Create ASR error file at %ws\r\n",
            THIS_MODULE, __LINE__, Gbl_AsrErrorFilePath);
    }
    else {
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "ASR %c%lu (ERROR) Unable to create ASR error file at %ws (0x%lu)\r\n",
            THIS_MODULE, __LINE__, Gbl_AsrErrorFilePath, GetLastError());
    }
}


VOID
AsrpCloseLogFiles() {

    if (Gbl_AsrErrorFilePath) {
        _AsrFree(Gbl_AsrErrorFilePath);
    }

    if (Gbl_AsrLogFilePath) {
        _AsrFree(Gbl_AsrLogFilePath);
    }

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        CloseHandle(Gbl_AsrLogFileHandle);
        Gbl_AsrLogFileHandle = NULL;
    }
}

//
// This executes "notepad <Asr-Log-File>".  If we encounter a critical
// failure, we display the error log to the user, and reboot.  We
// document that any critical application that returns a fatal error
// code is required to make an entry explaining the error in the
// ASR error file.
//
VOID
AsrpExecuteOnFatalError()
{
    BOOL result = FALSE;
    DWORD exitCode = 0;
    PWSTR onFatalCmd = NULL;

    if (!Gbl_AsrErrorFilePath) {
        MYASSERT(0 && L"ExecuteOnFatalError called before InitialiseErrorFile: Gbl_ErrorFilePath is NULL");
        return;
    }

    //
    // Make the error file read-only, so that the user's changes
    // aren't accidentally saved.
    //
    result = SetFileAttributesW(Gbl_AsrErrorFilePath, FILE_ATTRIBUTE_READONLY);
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to reset file attributes on file [%ws] to read-only (0x%x)\r\n",
            Gbl_AsrErrorFilePath,
            GetLastError()
           );
    }

    //
    // Pop up the ASR failed wizard page.
    //

    //
    // Finally run "notepad <asr-log-file>"
    //
    onFatalCmd = AsrpExpandEnvStrings(Asr_FatalErrorCommand);
    if (!onFatalCmd) {
        //
        // Nothing we can do here--we couldn't find the command
        // to execute on fatal errors.  Just bail--this is going
        // to make the system reboot.
        //
        return;
    }

    result = InvokeExternalApplication(
        NULL,           // no Application Name
        onFatalCmd,    // the full command string
        &exitCode       // we want a synchronous execution
       );
    if (!result) {
        SetFileAttributesW(Gbl_AsrErrorFilePath, FILE_ATTRIBUTE_NORMAL);
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to display error file, [%ws] failed (0x%x)\r\n",
            onFatalCmd,
            GetLastError()
           );
    }

    _AsrFree(onFatalCmd);
}


BOOL
AsrpSetFileSecurity(
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    SECURITY_ATTRIBUTES securityAttributes;
    SECURITY_DESCRIPTOR securityDescriptor;
    BOOL bResult = FALSE;

    if ((!Gbl_AsrErrorFilePath) || (!Gbl_AsrLogFilePath)) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        AsrpPrintDbgMsg(_asrlog,
            "Unable to set backup operator permissions for log/error files (0x2)\r\n");
        return FALSE;
    }

    securityAttributes.nLength  = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = &securityDescriptor;
    securityAttributes.bInheritHandle = FALSE;

    bResult = AsrpConstructSecurityAttributes(&securityAttributes, esatFile, TRUE);
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    bResult = SetFileSecurity(Gbl_AsrErrorFilePath,
        DACL_SECURITY_INFORMATION,
        &securityDescriptor
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());
    AsrpPrintDbgMsg(_asrinfo,
        "Set backup operator permissions for error file at %ws\r\n",
        Gbl_AsrErrorFilePath
        );


    bResult = SetFileSecurity(Gbl_AsrLogFilePath,
        DACL_SECURITY_INFORMATION,
        &securityDescriptor
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());
    AsrpPrintDbgMsg(_asrinfo,
        "Set backup operator permissions for log file at %ws\r\n",
        Gbl_AsrLogFilePath
        );


EXIT:
    AsrpCleanupSecurityAttributes(&securityAttributes);

    if (ERROR_SUCCESS != dwStatus) {
        SetLastError(dwStatus);
    }

    if (bResult) {
        AsrpPrintDbgMsg(_asrinfo, "Set backup operator permissions for files\r\n");
    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Unable to set backup operator permissions for log/error files (0x%lu)\r\n",
            GetLastError());
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
// Public function definitions.
///////////////////////////////////////////////////////////////////////////////

VOID
AsrInitialize(VOID)
/*++
Description:

    Initializes the data structures required to complete ASR (Automated System
    Recovery, aka Disaster Recovery).  This consists of reading the asr.sif
    file then initializing a list of recovery applications to be executed.

Arguments:

    None.

Returns:

    None.
--*/
{
    PWSTR sifName = NULL;
    HINF sifHandle  = NULL;
    BOOL result = FALSE;
    UINT errorLine = 0;

    SYSTEMTIME currentTime;
    GetSystemTime(&currentTime);


    //
    // Set the %TEMP% to c:\temp
    //
    AsrpSetEnvironmentVariables();

    //
    // Initialise the log files
    //
    AsrpInitialiseErrorFile();
    AsrpInitialiseLogFile();

    AsrpPrintDbgMsg(_asrlog,
        "Entering GUI-mode Automated System Recovery.  UTC: %04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu.\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds
       );

    //
    // Open the asr.sif file
    //
    sifName = AsrpExpandEnvStrings(AsrSifPath);
    if (!sifName) {
        AsrpPrintDbgMsg(_asrerror, "Setup was unable to locate the ASR state file asr.sif.\r\n");
        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    sifHandle = SetupOpenInfFileW(
        sifName,
        NULL,               // Inf Class
        INF_STYLE_WIN4,
        &errorLine                // Error-line
       );

    if ((!sifHandle) || (INVALID_HANDLE_VALUE == sifHandle)) {

        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to open the ASR state file [%ws].  Error-code: 0x%x, Line %lu\r\n",
            sifName,
            GetLastError(),
            errorLine
           );
        _AsrFree(sifName);

        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    //
    // Add the "last instance" registry entry for ASR.
    //
    AsrpAddRegistryEntry();

    //
    // Set the time-zone information.
    //
    result = AsrpRestoreTimeZoneInformation(sifName);
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to restore the time-zone information on the machine.  (0x%x)  ASR state file %ws\r\n",
            GetLastError(),
            (sifName ? sifName : L"could not be determined")
            );
    }
    else {
        AsrpPrintDbgMsg(_asrlog, "Successfully restored time-zone information.\r\n");
    }


    _AsrFree(sifName);

    //AsrpPerformSifIntegrityCheck(Handle); No check at the moment

    //
    // Make sure the licensed processors key is set.  I'm adding this call here
    // since if this key isn't present when we reboot, the system bugchecks with
    // 9A: system_license_violation.
    //
    SetEnabledProcessorCount();

    SetupCloseInfFile(sifHandle);
    Gbl_IsAsrEnabled = TRUE;
}


BOOL
AsrIsEnabled(VOID)
/*++
Description:

    Informs the caller whether ASR has been enabled by returning the value of
    the Gbl_IsAsrEnabled flag.

Arguments:

    None.

Returns:

    TRUE, if ASR is enabled.  Otherwise, FALSE is returned.

--*/
{
    return Gbl_IsAsrEnabled;
}


VOID
AsrExecuteRecoveryApps(VOID)
/*++
Description:

    Executes the commands in the [COMMANDS] section of the asr.sif file.

Arguments:

    None.

Returns:

    None.
--*/
{
    BOOL errors = FALSE,
     result = FALSE;
    DWORD exitCode = 0;
    LONG criticalApp = 0;
    PWSTR sifPath = NULL;
    PWSTR application = NULL;
    PASR_RECOVERY_APP_NODE pNode = NULL;
    ASR_RECOVERY_APP_LIST list = {NULL, NULL, 0};
    SYSTEMTIME currentTime;
    PWSTR errString = NULL;

    ASSERT_HEAP_IS_VALID();
    //
    // Restore the non-critical disks.
    //
    SetLastError(ERROR_SUCCESS);
    sifPath = AsrpExpandEnvStrings(AsrSifPath);
    if (sifPath) {
        result = AsrpRestoreNonCriticalDisksW(sifPath, TRUE);
    }
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to restore the configuration of some of the disks on the machine.  (0x%x)  ASR state file %ws\r\n",
            GetLastError(),
            (sifPath ? sifPath : L"could not be determined")
            );
    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Successfully recreated disk configurations.\r\n");
    }
    _AsrFree(sifPath);

    ASSERT_HEAP_IS_VALID();

    //
    // Close the system handle
    //
    if ((Gbl_AsrSystemVolumeHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrSystemVolumeHandle)) {
        CloseHandle(Gbl_AsrSystemVolumeHandle);
        Gbl_AsrSystemVolumeHandle = NULL;
        AsrpPrintDbgMsg(_asrinfo, "Closed system device handle.\r\n");
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, "Did not have a valid system device handle to close.\r\n");
    }


    //
    // Set the file security for the log and err files, to allow
    // backup operators to be able to access it on reboot
    //
    AsrpSetFileSecurity();


    AsrpInitExecutionEnv(&list);

    //
    // Sort the list of recovery apps, by sequence number.
    //
    AsrpSortAppListBySequenceNumber(&list);

    //
    // Change the boot timeout value in the boot.ini file. We do this now,
    // since executed apps in the list might result in changing drive letter,
    // which would make finding boot.ini non-trivial.
    //
    if (!ChangeBootTimeout(30)) {
        AsrpPrintDbgMsg(_asrwarn, "Failed to change boot.ini timeout value.\r\n");
    }

    //
    // Remove an application from the list and execute it.  Continue until
    // no more applications remain.
    //
    pNode = AsrpRemoveFirstNodeFromList(&list);

    while (pNode && !errors) {

        application = AsrpBuildInvocationString(pNode);
        criticalApp = pNode->CriticalApp;

        //
        // We don't need pNode any more
        //
        if (pNode->RecoveryAppParams) {
            _AsrFree(pNode->RecoveryAppParams);
        }
        _AsrFree(pNode->RecoveryAppCommand);
        _AsrFree(pNode);

        //
        // if the cmd line couldn't be created:
        // for a critical app, fail.
        // for a non-critical app, move on to next
        //
        if (!application) {
            if (0 < criticalApp) {
                errors = TRUE;
            }
        }
        else {
            //
            // Launch the app
            //
            AsrpPrintDbgMsg(_asrlog, "Invoking external recovery application [%ws]\r\n", application);
            exitCode = ERROR_SUCCESS;
            SetLastError(ERROR_SUCCESS);

            result = InvokeExternalApplication(
                NULL,           // no Application Name
                application,    // the full command string
                &exitCode       // we want a synchronous execution
               );

            if (!result) {
                AsrpPrintDbgMsg(_asrerror,
                    "Setup was unable to start the recovery application \"%ws\" (0x%x).\r\n",
                    application,
                    GetLastError()
                   );
                //
                // If a critical app couldn't be launched, it's a fatal error
                //
                if (0 < criticalApp) {

                    errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_LAUNCH_APP);

                    if (errString) {
                        swprintf(g_szErrorMessage, errString, application, GetLastError());
                        AsrpLogErrorMessage(g_szErrorMessage);
                        MyFree(errString);
                        errString = NULL;
                    }
                    else {
                        FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
                    }

                    errors = TRUE;
                }
            }
            else {
                //
                // Application was started: check the return code.  If return
                // code is not zero and this is a critical app (ie criticalApp=1)
                // it is a fatal error
                //
                if ((ERROR_SUCCESS != exitCode) && (0 < criticalApp)) {

                    AsrpPrintDbgMsg(_asrerror, "The recovery application \"%ws\" returned an error code 0x%x.  Since this indicates an unrecoverable error, ASR cannot continue on this machine.\r\n", application, exitCode);

                    errString = MyLoadString(IDS_ASR_ERROR_RECOVERY_APP_FAILED);

                    if (errString) {
                        swprintf(g_szErrorMessage, errString, application, exitCode);
                        AsrpLogErrorMessage(g_szErrorMessage);
                        MyFree(errString);
                        errString = NULL;
                    }
                    else {
                        FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
                    }

                    errors = TRUE;
                }
                else {
                    AsrpPrintDbgMsg(_asrlog, "The recovery application \"%ws\" returned an exit code of 0x%x\r\n", application, exitCode);
                }
            }

            _AsrFree(application);
        }

        pNode = AsrpRemoveFirstNodeFromList(&list);
    }

    if (errors) {
        //
        // A critical app above did not return 0.
        //
        AsrpExecuteOnFatalError();
    }
    else {
        //
        // We executed all the apps, without any critical failure.
        //
        RemoveRestartability(NULL);
        DeleteLocalSource();
        AsrpMergeSetupLogIfNeeded();

        AsrpPrintDbgMsg(_asrlog, "ASR completed successfully.\r\n");
    }


    GetSystemTime(&currentTime);
    AsrpPrintDbgMsg(_asrlog,
        "Exiting from GUI-mode Automated System Recovery.  UTC: %04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu.\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds
       );

    //
    // Clean up global values
    //
    AsrpCloseLogFiles();
    ASSERT_HEAP_IS_VALID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\setupp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    setupp.h

Abstract:

    Private top-level header file for Windows NT Setup module.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

--*/


//
// System header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntdddisk.h>
#include <ntapmsdk.h>
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
#include <winspool.h>
#include <winsvcp.h>
#include <ntdskreg.h>
#include <ntddft.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <objbase.h>
#include <syssetup.h>
#include <ntsetup.h>
#include <userenv.h>
#include <userenvp.h>
#include <regstr.h>
#include <setupbat.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <cryptui.h>
#include <wincrypt.h>
#include <dnsapi.h>
#include <winnls.h>
#include <encrypt.h>
// For setting default power scheme
#include <initguid.h>
#include <poclass.h>
#include <powrprof.h>
// For NetGetJoinInformation & NetApiBufferFree
#include <lmjoin.h>
#include <lmapibuf.h>
// For EnableSR()
#include <srrpcapi.h>

#ifdef _WIN64
#include <wow64reg.h>
#endif

#include <sacapi.h>

//
// CRT header files
//
#include <process.h>
#include <wchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <limits.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>

//
// Private header files
//
#include "res.h"
#include "msg.h"
#include "helpids.h"
#include "unattend.h"
#include "sif.h"
#include "watch.h"
#include "userdiff.h"
#include "setuplog.h"
#include "pidgen.h"
#include "mgdlllib.h"
#include "dynupdt.h"
#include "sacchan.h"
#include "compliance.h"

#include <sfcapip.h>
#include <sfcfiles.h>
#include <excppkg.h>
#include <mscat.h>
#include <softpub.h>


#if defined(_AMD64_)
#include "amd64\spx86.h"
#elif defined(_X86_)
#include "i386\spx86.h"
#endif


//
// Custom window messages.
//
#define WM_IAMVISIBLE   (WM_APP + 0)
#define WM_SIMULATENEXT (WM_APP + 1)
#define WM_MY_PROGRESS  (WM_APP + 2)
#define WM_NEWBITMAP    (WM_APP + 3)
#define WM_MY_STATUS    (WM_APP + 4)

#define WMX_TERMINATE   (WM_APP + 5)
#define WMX_VALIDATE    (WM_APP + 6)

// Message used to end the main setup window.
#define WM_EXIT_SETUPWINDOW (WM_APP + 7)

// Billboard private messages
#define WMX_SETPROGRESSTEXT (WM_APP + 8)
#define WMX_BB_SETINFOTEXT  (WM_APP + 9)
#define WMX_BBPROGRESSGAUGE (WM_APP + 10)
#define WMX_BBTEXT          (WM_APP + 11)
#define WMX_PROGRESSTICKS   (WM_APP + 12)
//
// enum for use with WM_NEWBITMAP
//
typedef enum {
    SetupBmBackground,
    SetupBmLogo,
    SetupBmBanner           // text, not a bitmap
} SetupBm;

//
// Context for file queues in SysSetup
//
typedef struct _SYSSETUP_QUEUE_CONTEXT {
    PVOID   DefaultContext;
    BOOL    Skipped;
} SYSSETUP_QUEUE_CONTEXT, *PSYSSETUP_QUEUE_CONTEXT;

//
// Context for migrating exception packages
//
typedef struct _EXCEPTION_MIGRATION_CONTEXT {
    PDWORD  Count;
    HWND    hWndProgress;
    BOOL    AnyComponentFailed;
} EXCEPTION_MIGRATION_CONTEXT, *PEXCEPTION_MIGRATION_CONTEXT;

//
// context for file registration in syssetup
//
typedef struct _REGISTRATION_CONTEXT {
    HWND hWndParent;
    HWND hWndProgress;
} REGISTRATION_CONTEXT, *PREGISTRATION_CONTEXT;



//
// Constant for SETUPLDR. Use #ifdef since it has different names for
// different architectures.
//
#ifdef _IA64_
#define SETUPLDR                L"SETUPLDR.EFI"
#endif

#ifdef _AMD64_
#define SETUPLDR                L"SETUPLDR"
#endif

//
// Module handle for this module.
//
extern HANDLE MyModuleHandle;

//
// full path to this module
//
extern WCHAR MyModuleFileName[MAX_PATH];

//
// unattend answer table
//
extern UNATTENDANSWER UnattendAnswerTable[];

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT(x)

#endif
//
// Handle to heap so we can periodically validate it.
//
#if DBG
    extern HANDLE g_hSysSetupHeap;
    #define ASSERT_HEAP_IS_VALID()  if (g_hSysSetupHeap) MYASSERT(RtlValidateHeap(g_hSysSetupHeap,0,NULL))
#else
    #define ASSERT_HEAP_IS_VALID()
#endif
//
// Product type being installed.
//
extern UINT ProductType;

//
// Boolean value indicating whether this installation
// originated with winnt/winnt32.
// And, original source path, saved away for us by winnt/winnt32.
//
extern BOOL WinntBased;
extern PCWSTR OriginalSourcePath;

//
// Boolean value indicating whether this is a remote boot setup.
//
extern BOOL RemoteBootSetup;

//
// Mask indicating the "base" CopyStyle to use. Normally 0, this is set to
// SP_COPY_SOURCE_SIS_MASTER during a remote boot setup to indicate that
// the installation source and target reside on the same single-instance
// storage volume.
//
extern ULONG BaseCopyStyle;

//
// Boolean value indicating whether we're upgrading.
//
extern BOOL Upgrade;
extern BOOL Win31Upgrade;
extern BOOL Win95Upgrade;
extern BOOL UninstallEnabled;

//
// Boolean value indicating whether we're in Setup or in appwiz.
//
extern BOOL IsSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
extern BOOL MiniSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
extern BOOL OobeSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup
// AND we did PnP re-enumeration.
//
extern BOOL PnPReEnumeration;

//
// Window handle of topmost setup window.
//
extern HWND SetupWindowHandle;
extern HWND MainWindowHandle;
extern HWND WizardHandle;
extern HANDLE SetupWindowThreadHandle;

//
// Source path for installation.
//
extern WCHAR SourcePath[MAX_PATH];

//
// System setup inf.
//
extern HINF SyssetupInf;

//
// Flag indicating whether this is an unattended mode install/upgrade.
//
extern BOOL Unattended;

//
// We can get into unattended mode in several ways, so we also check whether
// the "/unattend" switch was explicitly specified.
//
extern BOOL UnattendSwitch;

//
// Flag indicating whether we should run OOBE after Setup completes.  Note
// that if it is FALSE, OOBE may still be run, based on other criteria.
//
extern BOOL ForceRunOobe;

//
// Flag indicating whether we are in a special mode for OEM's to use on the
// factory floor.
//
extern BOOL ReferenceMachine;

//
// Flag indicating whether a volume was extended or not using
// ExtendOemPartition
//
extern BOOL PartitionExtended;


//
// Flag indicating if we're installing from a CD.
//
extern BOOL gInstallingFromCD;

//
// Cryptographically secure codesigning policies
//
extern DWORD PnpSeed;

//
// the original locale we started setup under.
//
extern LCID  OriginalInstallLocale;

//
// Indicates whether we need to wait at the installation
// end in unattended mode. Default is no wait.
//
extern BOOL UnattendWaitForReboot;


//
// If we are running unattended, the following mode indicates how answers
// are used.
//
typedef enum _UNATTENDMODE {
   UAM_INVALID,
   UAM_GUIATTENDED,
   UAM_PROVIDEDEFAULT,
   UAM_DEFAULTHIDE,
   UAM_READONLY,
   UAM_FULLUNATTENDED,
} UNATTENDMODE;

extern UNATTENDMODE UnattendMode;

//
// Flags indicating whether any accessibility utilities are in use.
//
extern BOOL AccessibleSetup;
extern BOOL Magnifier;
extern BOOL ScreenReader;
extern BOOL OnScreenKeyboard;

//
// String id of the string to be used for titles -- "Windows NT Setup"
//
extern UINT SetupTitleStringId;

//
// Platform name, like i386, ppc, alpha, mips
//
extern PCWSTR PlatformName;

//
// Maximum lengths for the various fields that form Pid 2.0
//
#define MAX_PID20_RPC  5
#define MAX_PID20_SITE  3
#define MAX_PID20_SERIAL_CHK  7
#define MAX_PID20_RANDOM  5


//
// Maximum lengths for the pid 3.0 fields
//
#define MAX_PID30_EDIT 5
#define MAX_PID30_RPC  5
#define MAX_PID30_SITE 3
extern WCHAR Pid30Text[5][MAX_PID30_EDIT+1];
extern WCHAR Pid30Rpc[MAX_PID30_RPC+1];
extern WCHAR Pid30Site[MAX_PID30_SITE+1];
extern BYTE DigitalProductId[DIGITALPIDMAXLEN];


//
// Maximum product id length and the Product ID.
//
//                   5    3     7     5    3 for the 3 dashes between the numbers.
// MAX_PRODUCT_ID = MPC+SITE+SERIAL+RANDOM+3
#define MAX_PRODUCT_ID  MAX_PID20_RPC+MAX_PID20_SITE+MAX_PID20_SERIAL_CHK+MAX_PID20_RANDOM + 3
extern WCHAR ProductId[MAX_PRODUCT_ID+1];
extern WCHAR ProductId20FromProductId30[MAX_PRODUCT_ID+1];

//
// Maximum computer name length and the computer name.
//
extern WCHAR ComputerName[DNS_MAX_LABEL_LENGTH+1];
extern WCHAR Win32ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
extern BOOL IsNameTruncated;
extern BOOL IsNameNonRfc;

//
// Copy disincentive name/organization strings.
//
#define MAX_NAMEORG_NAME  50
#define MAX_NAMEORG_ORG   50
extern WCHAR NameOrgName[MAX_NAMEORG_NAME+1];
extern WCHAR NameOrgOrg[MAX_NAMEORG_ORG+1];

//
// User name and password
//
#define MAX_USERNAME    20
#define MAX_PASSWORD    127
extern WCHAR UserName[MAX_USERNAME+1];
extern WCHAR UserPassword[MAX_PASSWORD+1];
extern BOOL CreateUserAccount;

//
// Administrator password.

extern WCHAR   CurrentAdminPassword[MAX_PASSWORD+1];//
extern WCHAR   AdminPassword[MAX_PASSWORD+1];
extern BOOL    EncryptedAdminPasswordSet;
extern BOOL    DontChangeAdminPassword;

#ifdef _X86_
extern BOOL FlawedPentium;
#endif

//
// This is a specification of optional directories
// and/or optional user command to execute,
// passed to us from text setup.
//
extern PWSTR OptionalDirSpec;
extern PWSTR UserExecuteCmd;
extern BOOL SkipMissingFiles;
extern PWSTR IncludeCatalog;

//
// Custom, typical, laptop, minimal.
//
extern UINT SetupMode;

//
// boolean indicating if the eula was already shown during the winnt32 setup phase
// this was passed to us from text setup.  if the eula was shown, then the pid has
// also been retreived from the user and validated
extern BOOL EulaComplete;

//
// Flag indicating if the eula was already shown during the textmode setup phase
// This will be the same as !Unattended unless UnattendMode = GuiAttended.
//
extern BOOL TextmodeEula;

//
// Global structure that contains information that will be used
// by net setup and license setup. We pass a pointer to this structure when we
// call NetSetupRequestWizardPages and LicenseSetupRequestWizardPages, then
// fill it in before we call into the net setup wizard, or liccpa.
//

extern INTERNAL_SETUP_DATA InternalSetupData;

//
// Flags indicating whether the driver and non-driver signing policies came
// from the answerfile.  (If so, then those values are in effect throughout
// GUI-mode setup and thereafter.)
//
extern BOOL AFDrvSignPolicySpecified;
extern BOOL AFNonDrvSignPolicySpecified;

//
//
// Did we log an error during SfcInitProt()?
//
extern BOOL SfcErrorOccurred;

//
// multi-sz list of files that is passed to SfcInitProt that the initial scan
// will not replace. This is used for non-signed drivers that are specified
// by F6 during textmode setup.
//
extern MULTISZ EnumPtrSfcIgnoreFiles;

//
// Parameters that are passed to the thread that drives the Finish dialog.
//
typedef struct _FINISH_THREAD_PARAMS {

    HWND  hdlg;
    DWORD ThreadId;
#ifdef _OCM
    PVOID  OcManagerContext;
#endif

} FINISH_THREAD_PARAMS, *PFINISH_THREAD_PARAMS;

DWORD
FinishThread(
    PFINISH_THREAD_PARAMS   Context
    );


//
// Miscellaneous stuff.
//
DWORD
SetupInstallTrustedCertificate(
    IN PCWSTR CertPath
    );

DWORD
ApplySecurityToRepairInfo(
    );

BOOL
RestoreBootTimeout(
    VOID
    );

VOID
PrepareForNetSetup(
    VOID
    );

VOID
PrepareForNetUpgrade(
    VOID
    );

VOID
pSetInstallAttributes(
    VOID
    );

DWORD
TreeCopy(
    IN PCWSTR SourceDir,
    IN PCWSTR TargetDir
    );

VOID
DelSubNodes(
    IN PCWSTR Directory
    );

VOID
Delnode(
    IN PCWSTR Directory
    );

BOOL
InitializePidVariables(
    VOID
    );

BOOL
SetPid30Variables(
    PWSTR   Buffer
    );

BOOL
ValidateCDRetailSite(
    IN PCWSTR    PidString
    );

BOOL
ValidateSerialChk(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemRpc(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemSerialChk(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemRandom(
    IN PCWSTR    PidString
    );

BOOL
ValidateAndSetPid30(
    VOID
    );

BOOL
CreateLicenseInfoKey(
    );

BOOL
InstallNetDDE(
    VOID
    );

BOOL
CopyOptionalDirectories(
    VOID
    );

VOID
SetUpProductTypeName(
    OUT PWSTR  ProductTypeString,
    IN  UINT   BufferSizeChars
    );

VOID
RemoveHotfixData(
    VOID
    );

void
SetupCrashRecovery(
    VOID
    );

BOOL
SpSetupLoadParameter(
    IN  PCWSTR Param,
    OUT PWSTR  Answer,
    IN  UINT   AnswerBufLen
    );

//
// IsArc() is always true on non-x86 machines except AMD64 for which it is
// always false. On x86, this determination has to be made at run time.
//
#if defined(_X86_)
BOOL
IsArc(
    VOID
    );
#elif defined(_AMD64_)
#define IsArc() FALSE
#else
#define IsArc() TRUE
#endif

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//
// Note that EFI_NVRAM_ENABLED is defined in ia64\sources.
//
#if defined(EFI_NVRAM_ENABLED)
#define IsEfi() TRUE
#else
#define IsEfi() FALSE
#endif

VOID
DeleteLocalSource(
    VOID
    );

BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

HMODULE
MyLoadLibraryWithSignatureCheck(
    IN  PWSTR   ModuleName
    );

DWORD
QueryHardDiskNumber(
    IN  UCHAR   DriveLetter
    );

BOOL
ExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    );

DWORD
RemoveStaleVolumes(
    VOID
    );


BOOL
DoFilesMatch(
    IN PCWSTR File1,
    IN PCWSTR File2
    );

UINT
MyGetDriveType(
    IN WCHAR Drive
    );

BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    );

BOOL
IsErrorLogEmpty (
    VOID
    );

VOID
BuildVolumeFreeSpaceList(
    OUT DWORD VolumeFreeSpaceMB[26]
    );

BOOL
SetUpVirtualMemory(
    VOID
    );

BOOL
RestoreVirtualMemoryInfo(
    VOID
    );

BOOL
CopySystemFiles(
    VOID
    );

BOOL
UpgradeSystemFiles(
    VOID
    );

VOID
MarkFilesReadOnly(
    VOID
    );

VOID
PumpMessageQueue(
    VOID
    );

BOOL
ConfigureMsDosSubsystem(
    VOID
    );

BOOL
PerfMergeCounterNames(
    VOID
    );

DWORD
pSetupInitRegionalSettings(
    IN  HWND    Window
    );

VOID
pSetupMarkHiddenFonts(
    VOID
    );

VOID
InstallServerNLSFiles(
    );

PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    );

VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    );

UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );


VOID
SaveRepairInfo(
    IN  HWND    hWnd,
    IN  ULONG   StartAtPercent,
    IN  ULONG   StopAtPercent
    );

BOOLEAN
IsLaptop(
    VOID
    );

VOID
InitializeUniqueness(
    IN OUT HWND *Billboard
    );

#ifdef _X86_

//
// Code in i386\migwin95.c
//

BOOL
PreWin9xMigration(
    VOID
    );

BOOL
MigrateWin95Settings(
    IN HWND     hwndWizardParent,
    IN LPCWSTR  UnattendFile
    );

BOOL
Win95MigrationFileRemoval(
    void
    );

BOOL
RemoveFiles_X86(
    IN HINF InfHandle
    );

#endif // def _X86_


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    );

LONG
WINAPI
MyUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    );

#ifdef _OCM
PVOID
#else
VOID
#endif
CommonInitialization(
    VOID
    );


VOID
InitializeExternalModules(
    BOOL                DoSetupStuff,
    PVOID*              pOcManagerContext
    );

BOOL
pSetupWaitForScmInitialization();

VOID
SetUpDataBlock(
    VOID
    );


//
// Wizard control.
//
VOID
Wizard(
#ifdef _OCM
    IN PVOID OcManagerContext
#else
    VOID
#endif
    );

//
// IMPORTANT: keep this in sync with WIZPAGE SetupWizardPages[WizPageMaximum]
//
typedef enum {
    WizPageWelcome,
    WizPageEula,
    WizPagePreparing,
    WizPagePreparingAsr,
    WizPageRegionalSettings,
    WizPageNameOrg,
    WizPageProductIdCd,
    WizPageProductIdOem,
    WizPageProductIdSelect,
    WizPageComputerName,
#ifdef DOLOCALUSER
    WizPageUserAccount,
#endif
#ifdef _X86_
    WizPagePentiumErrata,
#endif // def _X86_
    WizPageSteps1,

    WizSetupPreNet,
    WizSetupPostNet,

    WizPageCopyFiles,
    WizPageAsrLast,
    WizPageLast,
    WizPageMaximum
} WizPage;

extern HPROPSHEETPAGE WizardPageHandles[WizPageMaximum];

extern BOOL UiTest;

VOID
SetWizardButtons(
    IN HWND    hdlgPage,
    IN WizPage PageNumber
    );

VOID
WizardBringUpHelp(
    IN HWND    hdlg,
    IN WizPage PageNumber
    );

VOID
WizardKillHelp(
    IN HWND hdlg
    );

//
// Dialog procs.
//
INT_PTR
CALLBACK
WelcomeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
EulaDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
StepsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PreparingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
InstalledHardwareDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
SetupModeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
RegionalSettingsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
NameOrgDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
LicensingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
ComputerNameDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PidCDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30OemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30CDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30SelectDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PidOemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef DOLOCALUSER
INT_PTR
CALLBACK
UserAccountDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
CALLBACK
OptionalComponentsPageDlgProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
RepairDiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
CopyFilesDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
LastPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DoneDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
SetupPreNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
INT_PTR
CALLBACK
SetupPostNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

//
// Billboard stuff.
//
HWND
DisplayBillboard(
    IN HWND Owner,
    IN UINT MessageId,
    ...
    );

VOID
KillBillboard(
    IN HWND BillboardWindowHandle
    );

//
// Message string routines
//
PWSTR
MyLoadString(
    IN UINT StringId
    );

PWSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    );

PWSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    );

PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    );

PWSTR
RetrieveAndFormatMessage(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    ...
    );

int
MessageBoxFromMessageExV (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    IN va_list ArgumentList
    );

int
MessageBoxFromMessageEx (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );

//
// Action-logging routines.
//
extern PCWSTR ActionLogFileName;

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
LogRepairInfo(
    IN  PCWSTR  Source,
    IN  PCWSTR  Target
    );

VOID
FatalError(
    IN UINT MessageId,
    ...
    );

BOOL
InitializeSetupActionLog(
    BOOL WipeLogFile
    );

VOID
TerminateSetupActionLog(
    VOID
    );

BOOL
LogItem(
    IN LogSeverity Severity,
    IN PCWSTR      Description
    );

BOOL
LogItem0(
    IN LogSeverity Severity,
    IN UINT        MessageId,
    ...
    );

BOOL
LogItem1(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN UINT        MinorMsgId,
    ...
    );

BOOL
LogItem2(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN PCWSTR      MajorMsgParam,
    IN UINT        MinorMsgId,
    ...
    );

BOOL
LogItem3(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN PCWSTR      MajorMsgParam1,
    IN PCWSTR      MajorMsgParam2,
    IN UINT        MinorMsgId,
    ...
    );

PCWSTR
FormatSetupMessageV (
    IN UINT     MessageId,
    IN va_list  ArgumentList
    );

BOOL
LogItemV (
    IN LogSeverity  Severity,
    IN va_list      ArgumentList
    );

LogItemN (
    IN LogSeverity  Severity,
    ...
    );

BOOL
ViewSetupActionLog(
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    );


//
// Constant strings used for logging in various places.
//
extern PCWSTR szFALSE;
extern PCWSTR szWaitForSingleObject;
extern PCWSTR szSetGroupOfValues;
extern PCWSTR szSetArrayToMultiSzValue;
extern PCWSTR szCreateProcess;
extern PCWSTR szRegOpenKeyEx;
extern PCWSTR szRegQueryValueEx;
extern PCWSTR szRegSetValueEx;
extern PCWSTR szDeleteFile;
extern PCWSTR szRemoveDirectory;
extern PCWSTR szOpenSCManager;
extern PCWSTR szCreateService;
extern PCWSTR szChangeServiceConfig;
extern PCWSTR szOpenService;
extern PCWSTR szStartService;
extern PCWSTR szSetupInstallFromInfSection;



//
// ARC routines.
//
PWSTR
ArcDevicePathToNtPath(
    IN PCWSTR ArcPath
    );

PWSTR
NtFullPathToDosPath(
    IN PCWSTR NtPath
    );

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    );

BOOL
SetNvRamVariable(
    IN PCWSTR VarName,
    IN PCWSTR VarValue
    );

PWSTR
NtPathToDosPath(
    IN PCWSTR NtPath
    );

//
// Progman/program group stuff
//
BOOL
CreateStartMenuItems(
    IN HINF InfHandle
    );

BOOL
UpgradeStartMenuItems(
    IN HINF InfHandle
    );

//
// Cryptography stuff
//
BOOL
InstallOrUpgradeCapi(
    VOID
    );


//
// Plug&Play initialization
//
HANDLE
SpawnPnPInitialization(
    VOID
    );

DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    );



//
// Printer/spooler routines
//
BOOL
MiscSpoolerInit(
    VOID
    );

BOOL
StartSpooler(
    VOID
    );

DWORD
UpgradePrinters(
    VOID
    );


//
// Name of spooler service.
//
extern PCWSTR szSpooler;

//
// Service control.
//
BOOL
MyCreateService(
    IN PCWSTR  ServiceName,
    IN PCWSTR  DisplayName,         OPTIONAL
    IN DWORD   ServiceType,
    IN DWORD   StartType,
    IN DWORD   ErrorControl,
    IN PCWSTR  BinaryPathName,
    IN PCWSTR  LoadOrderGroup,      OPTIONAL
    IN PWCHAR  DependencyList,
    IN PCWSTR  ServiceStartName,    OPTIONAL
    IN PCWSTR  Password             OPTIONAL
    );

BOOL
MyChangeServiceConfig(
    IN PCWSTR ServiceName,
    IN DWORD  ServiceType,
    IN DWORD  StartType,
    IN DWORD  ErrorControl,
    IN PCWSTR BinaryPathName,   OPTIONAL
    IN PCWSTR LoadOrderGroup,   OPTIONAL
    IN PWCHAR DependencyList,
    IN PCWSTR ServiceStartName, OPTIONAL
    IN PCWSTR Password,         OPTIONAL
    IN PCWSTR DisplayName       OPTIONAL
    );

BOOL
MyChangeServiceStart(
    IN PCWSTR ServiceName,
    IN DWORD  StartType
    );

BOOL
UpdateServicesDependencies(
    IN HINF InfHandle
    );

//
// Registry manipulation
//
typedef struct _REGVALITEM {
    PCWSTR Name;
    PVOID Data;
    DWORD Size;
    DWORD Type;
} REGVALITEM, *PREGVALITEM;

//
// Names of frequently used keys/values
//
extern PCWSTR SessionManagerKeyName;
extern PCWSTR EnvironmentKeyName;
extern PCWSTR szBootExecute;
extern PCWSTR WinntSoftwareKeyName;
extern PCWSTR szRegisteredOwner;
extern PCWSTR szRegisteredOrganization;

UINT
SetGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    );

BOOL
CreateWindowsNtSoftwareEntry(
    IN BOOL FirstPass
    );

BOOL
CreateInstallDateEntry(
    );

BOOL
StoreNameOrgInRegistry(
    PWSTR   NameOrgName,
    PWSTR   NameOrgOrg
    );

BOOL
SetUpEvaluationSKUStuff(
    VOID
    );

BOOL
SetEnabledProcessorCount(
    VOID
    );

BOOL
SetProductIdInRegistry(
    VOID
    );

DWORD
SetCurrentProductIdInRegistry(
    VOID
    );

VOID
DeleteCurrentProductIdInRegistry(
    VOID
    );

void LogPidValues();

BOOL
SetAutoAdminLogonInRegistry(
    LPWSTR Username,
    LPWSTR Password
    );

BOOL
SetProfilesDirInRegistry(
    LPWSTR ProfilesDir
    );

BOOL
SetProductTypeInRegistry(
    VOID
    );

BOOL
SetEnvironmentVariableInRegistry(
    IN PCWSTR Name,
    IN PCWSTR Value,
    IN BOOL   SystemWide
    );

BOOL
SaveHive(
    IN HKEY   RootKey,
    IN PCWSTR Subkey,
    IN PCWSTR Filename,
    IN DWORD  Format
    );

BOOL
SaveAndReplaceSystemHives(
    VOID
    );

DWORD
FixupUserHives(
    VOID
    );

DWORD
QueryValueInHKLM (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    );

VOID
ConfigureSystemFileProtection(
    VOID
    );

VOID
RemoveRestartability (
    HWND hProgress
    );

BOOL
ResetSetupInProgress(
    VOID
    );

BOOL
RemoveRestartStuff(
    VOID
    );

BOOL
EnableEventlogPopup(
    VOID
    );

BOOL
SetUpPath(
    VOID
    );

VOID
RestoreOldPathVariable(
    VOID
    );

BOOL
FixQuotaEntries(
    VOID
    );

BOOL
StampBuildNumber(
    VOID
    );

BOOL
SetProgramFilesDirInRegistry(
    VOID
    );

BOOL
RegisterOleControls(
    IN HWND     hwndParent,
    IN PVOID    InfHandle,
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent,
    IN PWSTR    SectionName
    );


VOID
InitializeCodeSigningPolicies(
    IN BOOL ForGuiSetup
    );


VOID
GetDllCacheFolder(
    OUT LPWSTR CacheDir,
    IN DWORD cbCacheDir
    );


typedef enum _CODESIGNING_POLICY_TYPE {
    PolicyTypeDriverSigning,
    PolicyTypeNonDriverSigning
} CODESIGNING_POLICY_TYPE, *PCODESIGNING_POLICY_TYPE;

VOID
SetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    );

DWORD
GetSeed(
    VOID
    );

//
// Ini file routines.
//
BOOL
ReplaceIniKeyValue(
    IN PCWSTR IniFile,
    IN PCWSTR Section,
    IN PCWSTR Key,
    IN PCWSTR Value
    );

BOOL
WinIniAlter1(
    VOID
    );

BOOL
SetDefaultWallpaper(
    VOID
    );

BOOL
SetShutdownVariables(
    VOID
    );

BOOL
SetLogonScreensaver(
    VOID
    );

BOOL
InstallOrUpgradeFonts(
    VOID
    );

//
// External app stuff.
//
BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    );


BOOL
InvokeControlPanelApplet(
    IN PCWSTR CplSpec,
    IN PCWSTR AppletName,           OPTIONAL
    IN UINT   AppletNameStringId,
    IN PCWSTR CommandLine
    );

//
// Security/account routines.
//
BOOL
SignalLsa(
    VOID
    );

BOOL
CreateSamEvent(
    VOID
    );

BOOL
WaitForSam(
    VOID
    );

BOOL
SetAccountsDomainSid(
    IN DWORD  Seed,
    IN PCWSTR DomainName
    );

BOOL
CreateLocalUserAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    OUT PSID* UserSid   OPTIONAL
    );

NTSTATUS
CreateLocalAdminAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    OUT PSID* UserSid   OPTIONAL
    );

BOOL
SetLocalUserPassword(
    IN PCWSTR AccountName,
    IN PCWSTR OldPassword,
    IN PCWSTR NewPassword
    );

BOOL
IsEncryptedAdminPasswordPresent( VOID );

BOOL
ProcessEncryptedAdminPassword( PCWSTR AdminAccountName );

BOOL
CreatePdcAccount(
    IN PCWSTR MachineName
    );

BOOL
AdjustPrivilege(
    IN PCWSTR   Privilege,
    IN BOOL     Enable
    );

UINT
PlatformSpecificInit(
    VOID
    );

//
// Interface to new style parameter operations
//
BOOL
SpSetupProcessParameters(
    IN OUT HWND *Billboard
    );

VOID
SpInitSxsContext(
    VOID
    );

BOOL
SpInitCommonControls(
    VOID
    );

extern WCHAR LegacySourcePath[MAX_PATH];

HWND
CreateSetupWindow(
    VOID
    );

//
// Preinstallation stuff
//
extern BOOL Preinstall;
extern BOOL AllowRollback;
extern BOOL OemSkipEula;

BOOL
InitializePreinstall(
    VOID
    );

BOOL
ExecutePreinstallCommands(
    VOID
    );

BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    );

BOOL
ProcessCompatibilityInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage
    );


VOID
DoRunonce (
    );

//
//  Security Stuff
//
BOOL
SetupInstallSecurity(
    IN HWND Window,
    IN HWND ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    );


VOID
CallSceGenerateTemplate( VOID );

VOID
CallSceConfigureServices( VOID );

extern HANDLE SceSetupRootSecurityThreadHandle;
extern BOOL bSceSetupRootSecurityComplete;

VOID
CallSceSetupRootSecurity( VOID );

PSID
GetAdminAccountSid(
    );

VOID
GetAdminAccountName(
    PWSTR AccountName
    );

NTSTATUS
DisableLocalAdminAccount(
    VOID
    );

DWORD
StorePasswordAsLsaSecret (
    IN      PCWSTR Password
    );

BOOL
SetupRunBaseWinOptions(
    IN HWND Window,
    IN HWND ProgressWindow
    );

//
//  PnP stuff.
//
BOOL
InstallPnpDevices(
    IN HWND  hwndParent,
    IN HINF  InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    );

VOID
PnpStopServerSideInstall( VOID );

VOID
PnpUpdateHAL(
    VOID
    );

#ifdef _OCM
PVOID
FireUpOcManager(
    VOID
    );

VOID
KillOcManager(
    PVOID OcManagerContext
    );
#endif

//
// Boolean value indicating whether we found any new
// optional component infs.
//
extern BOOL AnyNewOCInfs;

//
// INF caching -- used during optional components processing.
// WARNING: NOT MULTI-THREAD SAFE!
//
HINF
InfCacheOpenInf(
    IN PCWSTR FileName,
    IN PCWSTR InfType       OPTIONAL
    );

HINF
InfCacheOpenLayoutInf(
    IN HINF InfHandle
    );

VOID
InfCacheEmpty(
    IN BOOL CloseInfs
    );

//
//  Pnp stuff
//

BOOL
InstallPnpClassInstallers(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HSPFILEQ FileQ
    );

//
// UI Stuff
//
VOID
SetFinishItemAttributes(
    IN HWND     hdlg,
    IN int      BitmapControl,
    IN HANDLE   hBitmap,
    IN int      TextControl,
    IN LONG     Weight
    );


void
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    );

#define SetupDebugPrint(_fmt_)                            pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_)
#define SetupDebugPrint1(_fmt_,_arg1_)                    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_)
#define SetupDebugPrint2(_fmt_,_arg1_,_arg2_)             pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_)
#define SetupDebugPrint3(_fmt_,_arg1_,_arg2_,_arg3_)      pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_)
#define SetupDebugPrint4(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)
#define SetupDebugPrint5(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)


VOID
SaveInstallInfoIntoEventLog(
    VOID
    );


#ifdef      _SETUP_PERF_
#define BEGIN_SECTION(_section_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",_section_)
#define END_SECTION(_section_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_SECTION",_section_)
#define BEGIN_FUNCTION(_func_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_FUNCTION",_func_)
#define END_FUNCTION(_func_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_FUNCTION",_func_)
#define BEGIN_BLOCK(_block_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_BLOCK",_block_)
#define END_BLOCK(_block_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_BLOCK",_block_)
#else   //  ! _PERF_
#define BEGIN_SECTION(_section_) ((void)0)
#define END_SECTION(_section_) ((void)0)
#endif  //  _PERF_

//
// Service Pack DLL Prototypes
//

#define SVCPACK_DLL_NAME TEXT("svcpack.dll")
#define SVCPACK_CALLBACK_NAME ("SvcPackCallbackRoutine")

#define CALL_SERVICE_PACK(_si_,_p1_,_p2_,_p3_) if (hModSvcPack && pSvcPackCallbackRoutine) pSvcPackCallbackRoutine(_si_,_p1_,_p2_,_p3_)

#define SVCPACK_PHASE_1 1
#define SVCPACK_PHASE_2 2
#define SVCPACK_PHASE_3 3
#define SVCPACK_PHASE_4 4

typedef DWORD
(WINAPI *PSVCPACKCALLBACKROUTINE)(
    DWORD dwSetupPhase,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwParam3
    );

extern HMODULE hModSvcPack;
extern PSVCPACKCALLBACKROUTINE pSvcPackCallbackRoutine;

extern HINSTANCE hinstBB;
void PrepareBillBoard(HWND hwnd);
void TerminateBillBoard();
HWND GetBBhwnd();
void SetBBStep(int iStep);
VOID CenterWindowRelativeToWindow(HWND hwndtocenter, HWND hwndcenteron, BOOL bWizard);
BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow);
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam);
LRESULT ProgressGaugeMsgWrapper(UINT msg, WPARAM wparam, LPARAM lparam);
void BB_SetProgressText(LPCTSTR szText);
void BB_SetTimeEstimateText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);
BOOL StartStopBB(BOOL bStart);


HWND
ShowHideWizardPage(
    IN BOOL bShow
    );

LRESULT
Billboard_Progress_Callback(
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    );
VOID Billboard_Set_Progress_Text(LPCTSTR Text);

typedef struct _SETUPPHASE {
    DWORD   Time;
    BOOL    Win9xUpgradeOnly;
} SETUPPHASE;


void SetTimeEstimates();
DWORD CalcTimeRemaining(UINT Phase);
void SetRemainingTime(DWORD TimeInSeconds);
void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime);

extern UINT CurrentPhase;
extern ULONG RemainingTime;
extern SETUPPHASE SetupPhase[];

typedef enum {
    Phase_Unknown = -1,
    Phase_Initialize = 0,
    Phase_InstallSecurity,
    Phase_PrecompileInfs,
    Phase_InstallEnumDevices1,
    Phase_InstallLegacyDevices,
    Phase_InstallEnumDevices2,
    Phase_NetInstall,
    Phase_OCInstall,
    Phase_InstallComponentInfs,
    Phase_Inf_Registration,
    Phase_RunOnce_Registration,
    Phase_SecurityTempates,
    Phase_Win9xMigration,
    Phase_SFC,
    Phase_SaveRepair,
    Phase_RemoveTempFiles,
    Phase_Reboot                // no entry for this, just to make sure we don't overrun.
} SetupPhases;



#include "SetupSxs.h"
#include "SxsApi.h"

typedef struct _SIDE_BY_SIDE
{
    HINSTANCE                   Dll;
    PSXS_BEGIN_ASSEMBLY_INSTALL BeginAssemblyInstall;
    PSXS_END_ASSEMBLY_INSTALL   EndAssemblyInstall;
    PSXS_INSTALL_W              InstallW;
    PVOID                       Context;
} SIDE_BY_SIDE;

BOOL
SideBySidePopulateCopyQueue(
    SIDE_BY_SIDE*     Sxs,
    HSPFILEQ          FileQ,                    OPTIONAL
    PCWSTR            AssembliesRootSource      OPTIONAL
    );

BOOL
SideBySideFinish(
    SIDE_BY_SIDE*     Sxs,
    BOOL              fSuccess
    );

BOOL
SideBySideCreateSyssetupContext(
    VOID
    );


VOID
SetUpProcessorNaming(
    VOID
    );

BOOL
SpSetProductTypeFromParameters(
    VOID
    );

//
// imported from setupapi
//
#define SIZECHARS(x)    (sizeof((x))/sizeof(TCHAR))
#define CSTRLEN(x)      ((sizeof((x))/sizeof(TCHAR)) - 1)
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#define MyFree          pSetupFree
#define MyMalloc        pSetupMalloc
#define MyRealloc       pSetupRealloc

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
DriverNodeSupportsNT(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

VOID
ReplaceSlashWithHash(
    IN PWSTR Str
    );

HANDLE
UtilpGetDeviceHandle(
    HDEVINFO DevInfo,
    PSP_DEVINFO_DATA DevInfoData,
    LPGUID ClassGuid,
    DWORD DesiredAccess
    );

typedef enum {
    CDRetail,
    CDOem,
    CDSelect
} CDTYPE;

extern CDTYPE  CdType;
extern DWORD GetProductFlavor();

BOOL IsSafeMode(
    VOID
    );

DWORD
SpUninstallCatalog(
    IN HCATADMIN CatAdminHandle OPTIONAL,
    IN PCWSTR CatFileName,
    IN PCWSTR CatFilePath OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    IN OUT PLIST_ENTRY InstalledCatalogsList OPTIONAL
    );

extern GUID DriverVerifyGuid;

#ifdef PRERELEASE
extern INT g_TestHook;
# define TESTHOOK(n)        if(g_TestHook==(n))RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION,EXCEPTION_NONCONTINUABLE,0,NULL)
#else
# define TESTHOOK(n)
#endif

BOOL
RenameOnRestartOfGUIMode(
    IN PCWSTR pPathName,
    IN PCWSTR pPathNameNew
    );

BOOL
DeleteOnRestartOfGUIMode(
    IN PCWSTR pPathName
    );

VOID
RemoveAllPendingOperationsOnRestartOfGUIMode(
    VOID
    );

typedef struct _STRING_LIST_ENTRY
{
    LIST_ENTRY Entry;
    PTSTR String;
}
STRING_LIST_ENTRY, *PSTRING_LIST_ENTRY;

void
FORCEINLINE
FreeStringEntry(
    PLIST_ENTRY pEntry,
    BOOL DeleteEntry
    )
{
    PSTRING_LIST_ENTRY pStringEntry = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);

    if(pStringEntry->String != NULL) {
        MyFree(pStringEntry->String);
        pStringEntry->String = NULL;
    }

    if(DeleteEntry) {
        MyFree(pStringEntry);
    }
}

typedef BOOL (CALLBACK* PFN_BUILD_FILE_LIST_CALLBACK)(IN PCTSTR Directory OPTIONAL, IN PCTSTR FilePath);

void
FORCEINLINE
FreeStringList(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY pEntry;
    ASSERT(pListHead != NULL);
    pEntry = pListHead->Flink;

    while(pEntry != pListHead) {
        PLIST_ENTRY Flink = pEntry->Flink;
        FreeStringEntry(pEntry, TRUE);
        pEntry = Flink;
    }

    InitializeListHead(pListHead);
}

DWORD
BuildFileListFromDir(
    IN PCTSTR PathBase,
    IN PCTSTR Directory OPTIONAL,
    IN DWORD MustHaveAttrs OPTIONAL,
    IN DWORD MustNotHaveAttrs OPTIONAL,
    IN PFN_BUILD_FILE_LIST_CALLBACK Callback OPTIONAL,
    OUT PLIST_ENTRY ListHead
    );

PSTRING_LIST_ENTRY
SearchStringInList(
    IN PLIST_ENTRY ListHead,
    IN PCTSTR String,
    BOOL CaseSensitive
    );

DWORD
LookupCatalogAttribute(
    IN PCWSTR CatalogName,
    IN PCWSTR Directory OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    PBOOL Found
    );

HRESULT
WaitForSamService(
    IN DWORD Waittime
    );

BOOL
BuildPath (
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\storinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clasinst.c

Abstract:

    Routines for the following 'built-in' class installers:

        TapeDrive
        SCSIAdapter
        CdromDrive

Author:

    Lonny McMichael 26-February-1996

--*/


#include "setupp.h"
#pragma hdrstop

//
// include common INF strings headerfile.
//
#include <infstr.h>

//
// instantiate device class GUIDs.
//
#include <initguid.h>
#include <devguid.h>

#include <ntddvol.h>

#include <ntddscsi.h> // for StorageCdromQueryCdda()
#include <ntddcdrm.h> // for StorageCdromQueryCdda()

#define _NTSCSI_USER_MODE_  // prevents all the kernel-mode stuff
#include <scsi.h>     // for StorageCdromQueryCdda()

ULONG BreakWhenGettingModePage2A = FALSE;

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>

#define TCHAR_NULL TEXT('\0')

//
// Just to make sure no one is trying to use this obsolete string definition.
//
#ifdef IDS_DEVINSTALL_ERROR
    #undef IDS_DEVINSTALL_ERROR
#endif

#define DISABLE_IMAPI 0

//
// Define the location of the device settings tree.
//
#define STORAGE_DEVICE_SETTINGS_DATABASE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Storage\\DeviceSettings\\")

#define REDBOOK_SETTINGS_KEY    TEXT("DigitalAudio")
#define REDBOOK_SERVICE_NAME    TEXT("redbook")
#define IMAPI_SETTINGS_KEY      TEXT("Imapi")
#define IMAPI_ENABLE_VALUE      TEXT("EnableImapi")
#define IMAPI_SERVICE_NAME      TEXT("imapi")

typedef struct STORAGE_COINSTALLER_CONTEXT {
    PWSTR DeviceDescBuffer;
    HANDLE DeviceEnumKey;
    union {
        struct {
            BOOLEAN RedbookInstalled;
            BOOLEAN ImapiInstalled;
        } CdRom;
    };
} STORAGE_COINSTALLER_CONTEXT, *PSTORAGE_COINSTALLER_CONTEXT;

typedef struct _PASS_THROUGH_REQUEST {
    SCSI_PASS_THROUGH Srb;
    SENSE_DATA SenseInfoBuffer;
    UCHAR DataBuffer[0];
} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;

#define PASS_THROUGH_NOT_READY_RETRY_INTERVAL 100

//
// Some debugging aids for us kernel types
//

#define CHKPRINT 0

#if CHKPRINT
#define ChkPrintEx(_x_) DbgPrint _x_   // use:  ChkPrintEx(( "%x", var, ... ));
#define ChkBreak()    DbgBreakPoint()
#else
#define ChkPrintEx(_x_)
#define ChkBreak()
#endif

DWORD StorageForceRedbookOnInaccurateDrives = FALSE;

BOOLEAN
OverrideFriendlyNameForTape(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

DWORD
RegCopyKey(
    HKEY SourceKey,
    HKEY DestinationKey
    );

BOOLEAN
StorageCopyDeviceSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey
    );

VOID
StorageInstallCdrom(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HANDLE           DeviceEnumKey,
    IN BOOLEAN          PreInstall
    );

BOOLEAN
StorageUpdateRedbookSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE DeviceCapabilities OPTIONAL
    );

BOOLEAN
StorageUpdateImapiSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE DeviceCapabilities OPTIONAL
    );

DWORD
StorageInstallFilter(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR          FilterName,
    IN DWORD            FilterType
    );

DWORD
SetServiceStart(
    IN LPCTSTR ServiceName,
    IN DWORD StartType,
    OUT DWORD *OldStartType
    );

DWORD
AddFilterDriver(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           ServiceName,
    IN DWORD            FilterType
    );

VOID
StorageInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    );


typedef struct _STORAGE_REDBOOK_SETTINGS {

    ULONG CDDASupported;
    ULONG CDDAAccurate;
    ULONG ReadSizesSupported;

} STORAGE_REDBOOK_SETTINGS, *PSTORAGE_REDBOOK_SETTINGS;

#if 0
#define BREAK ASSERT(!"Break")
#else
#define BREAK
#endif

DWORD
TapeClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for TapeDrive devices.  Now that
    we've stopped supporting legacy INFs, it presently does nothing! :-)

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

DWORD
ScsiClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for SCSIAdapter devices.  It
    provides special handling for the following DeviceInstaller function codes:

    DIF_ALLOW_INSTALL - Check to see if the selected driver node supports NT

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        case DIF_ALLOW_INSTALL :
            //
            // Check to make sure the selected driver node supports NT.
            //
            if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
               return NO_ERROR;
            } else {
                SetupDebugPrint(L"A SCSI driver is not a Win NTdriver.\n");
               return ERROR_NON_WINDOWS_NT_DRIVER;
            }

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}


DWORD
HdcClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for hard disk controllers
    (IDE controllers/channels).  It provides special handling for the
    following DeviceInstaller function codes:

    DIF_FIRSTTIMESETUP - Search through all root-enumerated devnodes, looking
                         for ones being controlled by hdc-class drivers.  Add
                         any such devices found into the supplied device
                         information set.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        case DIF_FIRSTTIMESETUP :
            //
            // BUGBUG (lonnym): handle this!
            //

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

BOOLEAN
StorageGetCDVDCapabilities(
    IN  HDEVINFO         DeviceInfo,
    IN  PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCDVD_CAPABILITIES_PAGE CapabilitiesPage
    )
{
    PPASS_THROUGH_REQUEST passThrough;
    PCDVD_CAPABILITIES_PAGE modePage;
    DWORD allocLength;
    DWORD dataLength;
    ULONG attempt;
    BOOLEAN status = FALSE;

    HANDLE deviceHandle;

    deviceHandle = INVALID_HANDLE_VALUE;
    passThrough = NULL;
    modePage = NULL;

    ASSERT(CapabilitiesPage != NULL);

    if (BreakWhenGettingModePage2A) {
        ChkPrintEx(("CDGetCap => entering\n"));
        DbgBreakPoint();
    }


    //
    // open a handle to the device, needed to send the ioctls
    //

    deviceHandle = UtilpGetDeviceHandle(DeviceInfo,
                                        DeviceInfoData,
                                        (LPGUID)&CdRomClassGuid,
                                        GENERIC_READ | GENERIC_WRITE
                                        );

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        ChkPrintEx(("CDGetCap => cannot get device handle\n"));
        goto cleanup;
    }

    //
    // determine size of allocation needed
    //

    dataLength =
        sizeof(MODE_PARAMETER_HEADER10) +    // larger of 6/10 byte
        sizeof(CDVD_CAPABILITIES_PAGE)  +    // the actual mode page
        8;                                   // extra spooge for drives that ignore DBD
    allocLength = sizeof(PASS_THROUGH_REQUEST) + dataLength;

    //
    // allocate this buffer for the ioctls
    //

    passThrough = (PPASS_THROUGH_REQUEST)MyMalloc(allocLength);

    if (passThrough == NULL) {
        ChkPrintEx(("CDGetCap => could not allocate for passThrough\n"));
        goto cleanup;
    }

    ASSERT(dataLength <= 0xff);  // one char

    //
    // send 6-byte, then 10-byte if 6-byte failed.
    // then, just parse the information
    //

    for (attempt = 1; attempt <= 2; attempt++) {

        ULONG j;
        BOOLEAN retry = TRUE;
        DWORD error;

        for (j=0; (j < 5) && (retry); j++) {

            PSCSI_PASS_THROUGH srb = &passThrough->Srb;
            PCDB cdb = (PCDB)(&srb->Cdb[0]);
            DWORD bytes;
            BOOL b;

            retry = FALSE;

            ZeroMemory(passThrough, allocLength);

            srb->TimeOutValue = 20;
            srb->Length = sizeof(SCSI_PASS_THROUGH);
            srb->SenseInfoLength = sizeof(SENSE_DATA);
            srb->SenseInfoOffset =
                FIELD_OFFSET(PASS_THROUGH_REQUEST, SenseInfoBuffer);
            srb->DataBufferOffset =
                FIELD_OFFSET(PASS_THROUGH_REQUEST, DataBuffer);
            srb->DataIn = SCSI_IOCTL_DATA_IN;
            srb->DataTransferLength = dataLength;

            if ((attempt % 2) == 1) { // settings based on 6-byte request

                srb->CdbLength = 6;
                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_CAPABILITIES;
                cdb->MODE_SENSE.AllocationLength = (UCHAR)dataLength;
                cdb->MODE_SENSE.Dbd = 1;

            } else {                  // settings based on 10 bytes request

                srb->CdbLength = 10;
                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
                cdb->MODE_SENSE10.AllocationLength[0] = 0;
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(dataLength & 0xff);
                cdb->MODE_SENSE10.Dbd = 1;

            }

            //
            // buffers are all set, send the ioctl
            //

            b = DeviceIoControl(deviceHandle,
                                IOCTL_SCSI_PASS_THROUGH,
                                passThrough,
                                allocLength,
                                passThrough,
                                allocLength,
                                &bytes,
                                NULL);

            if (!b) {

                ChkPrintEx(("CDGetCap => %s byte command failed to be sent to device\n",
                            ((attempt%2) ? "6" : "10")
                            ));
                retry = FALSE;
                continue; // try the next 'j' loop.

            }

            //
            // now see if we should retry
            //

            StorageInterpretSenseInfo(&passThrough->SenseInfoBuffer,
                                      SENSE_BUFFER_SIZE,
                                      &error,
                                      &retry,
                                      NULL);

            if (error != ERROR_SUCCESS) {

                ChkPrintEx(("CDGetCap => %s byte command failed (%x/%x/%x),"
                            "%s retrying\n",
                            ((attempt%2) ? "6" : "10"),
                            passThrough->SenseInfoBuffer.SenseKey,
                            passThrough->SenseInfoBuffer.AdditionalSenseCode,
                            passThrough->SenseInfoBuffer.AdditionalSenseCodeQualifier,
                            (retry ? "" : "not")
                            ));

                //
                // retry will be set to either true or false to
                // have this loop (j) re-run or not....
                //

                continue;

            }

            //
            // else it worked!
            //
            ASSERT(retry == FALSE);
            retry = FALSE;
            ASSERT(status == FALSE);
            status = TRUE;
        }

        //
        // if unable to retrieve the page, just start the next loop.
        //

        if (!status) {
            continue; // try the next 'attempt' loop.
        }

        //
        // find the mode page data
        //
        // NOTE: if the drive fails to ignore the DBD bit,
        // we still need to install?  HCT will catch this,
        // but legacy drives need it.
        //

        (ULONG_PTR)modePage = (ULONG_PTR)passThrough->DataBuffer;

        if (attempt == 1) {

            PMODE_PARAMETER_HEADER h;
            h = (PMODE_PARAMETER_HEADER)passThrough->DataBuffer;

            //
            // add the size of the header
            //

            (ULONG_PTR)modePage += sizeof(MODE_PARAMETER_HEADER);
            dataLength -= sizeof(MODE_PARAMETER_HEADER);

            //
            // add the size of the block descriptor, which should
            // always be zero, but isn't on some poorly behaved drives
            //

            if (h->BlockDescriptorLength) {

                ASSERT(h->BlockDescriptorLength == 8);

                ChkPrintEx(("CDGetCap => %s byte command ignored DBD bit (%x)\n",
                            ((attempt%2) ? "6" : "10"),
                            h->BlockDescriptorLength
                            ));
                (ULONG_PTR)modePage += h->BlockDescriptorLength;
                dataLength -= h->BlockDescriptorLength;
            }

        } else {

            PMODE_PARAMETER_HEADER10 h;
            h = (PMODE_PARAMETER_HEADER10)passThrough->DataBuffer;

            //
            // add the size of the header
            //

            (ULONG_PTR)modePage += sizeof(MODE_PARAMETER_HEADER10);
            dataLength -= sizeof(MODE_PARAMETER_HEADER10);

            //
            // add the size of the block descriptor, which should
            // always be zero, but isn't on some poorly behaved drives
            //

            if ((h->BlockDescriptorLength[0] != 0) ||
                (h->BlockDescriptorLength[1] != 0)
                ) {

                ULONG_PTR bdLength = 0;
                bdLength += ((h->BlockDescriptorLength[0]) << 8);
                bdLength += ((h->BlockDescriptorLength[1]) & 0xff);

                ASSERT(bdLength == 8);

                ChkPrintEx(("CDGetCap => %s byte command ignored DBD bit (%x)\n",
                            ((attempt%2) ? "6" : "10"),
                            bdLength
                            ));

                (ULONG_PTR)modePage += bdLength;
                dataLength -= (DWORD)bdLength;

            }
        }

        //
        // now have the pointer to the mode page data and length of usable data
        // copy it back to requestor's buffer
        //

        ChkPrintEx(("CDGetCap => %s byte command succeeded\n",
                    (attempt%2) ? "6" : "10"));

        RtlZeroMemory(CapabilitiesPage, sizeof(CDVD_CAPABILITIES_PAGE));
        RtlCopyMemory(CapabilitiesPage,
                      modePage,
                      min(dataLength, sizeof(CDVD_CAPABILITIES_PAGE))
                      );

        if (BreakWhenGettingModePage2A) {
            ChkPrintEx(("CDGetCap => Capabilities @ %#p\n", CapabilitiesPage));
            DbgBreakPoint();
        }

        goto cleanup; // no need to send another command


    }


    ChkPrintEx(("CDGetCap => Unable to get drive capabilities via modepage\n"));

cleanup:

    if (passThrough) {
        MyFree(passThrough);
    }
    if (deviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(deviceHandle);
    }

    return status;
}

BOOLEAN
ScReadRegDword(
    IN HANDLE Key,
    IN LPTSTR ValueName,
    OUT PDWORD Value
    )
{
    DWORD type;
    DWORD size = sizeof(DWORD);
    DWORD value;
    DWORD result;

    result = RegQueryValueEx(Key,
                             ValueName,
                             NULL,
                             &type,
                             (LPBYTE) &value,
                             &size);

    if(result == ERROR_SUCCESS) {
        *Value = value;
        return TRUE;
    }
    return FALSE;
}

VOID
StorageReadRedbookSettings(
    IN HANDLE Key,
    OUT STORAGE_REDBOOK_SETTINGS *Settings
    )
{
    STORAGE_REDBOOK_SETTINGS settings;

    //
    // since this key exists, query for the values
    //

    DWORD dataType;
    DWORD dataSize;
    DWORD value;
    LONG  results;

    settings.CDDASupported = FALSE;
    settings.CDDAAccurate = FALSE;
    settings.ReadSizesSupported = 0;

    if(ScReadRegDword(Key, TEXT("CDDASupported"), &value)) {
        settings.CDDASupported = value ? 1 : 0;
    }

    if(ScReadRegDword(Key, TEXT("CDDAAccurate"), &value)) {
        settings.CDDAAccurate = value ? 1 : 0;
    }

    if(ScReadRegDword(Key, TEXT("ReadSizesSupported"), &value)) {
        settings.ReadSizesSupported = value;
    }

    //
    // one of the three worked
    //

    ChkPrintEx(("StorageReadSettings: Query Succeeded:\n"));
    ChkPrintEx(("StorageReadSettings:     ReadSizeMask  (pre): %x\n",
                settings.ReadSizesSupported));
    ChkPrintEx(("StorageReadSettings:     CDDAAccurate  (pre): %x\n",
                settings.CDDAAccurate));
    ChkPrintEx(("StorageReadSettings:     CDDASupported (pre): %x\n",
                settings.CDDASupported));

    //
    // interpret the redbook device settings.
    //

    if (settings.ReadSizesSupported) {

        ChkPrintEx(("StorageSeed: Drive supported only some sizes "
                    " (%#08x)\n", settings.ReadSizesSupported));

        settings.CDDASupported = TRUE;
        settings.CDDAAccurate = FALSE;

    } else if (settings.CDDAAccurate) {

        ChkPrintEx(("StorageSeed: Drive is fully accurate\n"));

        settings.CDDASupported = TRUE;
        settings.ReadSizesSupported = -1;

    } else if (settings.CDDASupported) {

        ChkPrintEx(("StorageSeed: Drive lies about being accurate\n"));

        settings.CDDAAccurate = FALSE;
        settings.ReadSizesSupported = -1;

    } // values are now interpreted

    *Settings = settings;

    return;
} // end of successful open of key

DWORD
StorageCoInstaller(
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    This routine acts as a co-installer for storage devices.  It is presently
    registered (via hivesys.inf) for CDROM, DiskDrive, and TapeDrive classes.

    The purpose of this co-installer is to save away the bus-supplied default
    DeviceDesc into the device's FriendlyName property.  The reason for this
    is that the bus can retrieve a very specific description from the device
    (e.g., via SCSI inquiry data), yet the driver node we install will often
    be something very generic (e.g., "Disk drive").
    We want to keep the descriptive name, so that it can be displayed in the
    UI (DevMgr, etc.) to allow the user to distinguish between multiple storage
    devices of the same class.

    A secondary purpose for this co-installer is to seed the ability to play
    digital audio for a given device.  The reason for this is that many cdroms
    that support digital audio do not report this ability, there are some that
    claim this ability but cannot actually do it reliably, and some that only
    work when reading N sectors at a time.  This information is seeded in the
    registry, and copied to the enum key.  If this information does not exist,
    no keys are created, and defaults are used.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Supplies the installation context that is per-install
        request/per-coinstaller.

Return Value:

    If this function successfully completed the requested action (or did
        nothing) and wishes for the installation to continue, the return
        value is NO_ERROR.

    If this function successfully completed the requested action (or did
        nothing) and would like to be called back once installation has
        completed, the return value is ERROR_DI_POSTPROCESSING_REQUIRED.

    If an error occurred while attempting to perform the requested action,
        a Win32 error code is returned.  Installation will be aborted.

--*/

{
    PSTORAGE_COINSTALLER_CONTEXT InstallContext;

    PWSTR DeviceDescBuffer = NULL;
    DWORD DeviceDescBufferLen, Err;
    ULONG ulStatus, ulProblem;

    switch(InstallFunction) {

        case DIF_INSTALLDEVICE : {

            if(Context->PostProcessing) {
                //
                // We're 'on the way out' of an installation.  The context
                // PrivateData had better contain the string we stored on
                // the way in.
                //

                InstallContext = Context->PrivateData;
                MYASSERT(InstallContext);

                //
                // We only want to store the FriendlyName property if the
                // installation succeeded. We only want to seed redbook values
                // if the install succeeded.
                //

                if(Context->InstallResult == NO_ERROR) {

                    BOOLEAN OverrideFriendlyName = FALSE;

                    if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                     &GUID_DEVCLASS_TAPEDRIVE)) {
                       //
                       // This function checks if we need to use
                       // the device description, given in INF file,
                       // in UI such as Device Manager. Returns TRUE
                       // if INF description is to used. FALSE, otherwise.
                       //
                       OverrideFriendlyName = OverrideFriendlyNameForTape(
                                                      DeviceInfoSet,
                                                      DeviceInfoData);

                    } else if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                           &GUID_DEVCLASS_CDROM)) {

                        //
                        // See if we need to install any of the filter drivers
                        // to enable additional CD-ROM (CD-R, DVD-RAM, etc...)
                        // features.
                        //


                        StorageInstallCdrom(DeviceInfoSet,
                                            DeviceInfoData,
                                            InstallContext,
                                            FALSE);
                    }

                    if ((OverrideFriendlyName == FALSE) &&
                        (InstallContext->DeviceDescBuffer != NULL))  {
                       //
                       // If we need not use the INF device description
                       // write the name, generated from SCSI Inquiry data,
                       // onto FriendlyName
                       //
                       SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_FRIENDLYNAME,
                                                        (PBYTE) InstallContext->DeviceDescBuffer,
                                                        (lstrlen(InstallContext->DeviceDescBuffer) + 1) * sizeof(WCHAR));
                    }
                }

                //
                // Now free our installation context.
                //
                if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
                    RegCloseKey(InstallContext->DeviceEnumKey);
                }

                if(InstallContext->DeviceDescBuffer) {
                    MyFree(InstallContext->DeviceDescBuffer);
                }

                MyFree(InstallContext);

                //
                // Propagate the result of the previous installer.
                //
                return Context->InstallResult;

            } else {

                //
                // We're 'on the way in' for device installation.
                // Make sure that whoever called SetupDiCallClassInstaller
                // passed in a device information element.  (Don't fail the
                // call if they didn't--that's the job of the class
                // installer/SetupDiInstallDevice.)
                //
                if(!DeviceInfoData) {
                    return NO_ERROR;
                }

                //
                // Make sure this isn't a root-enumerated device.  The root
                // enumerator clearly has nothing interesting to say about
                // the device's description beyond what the INF says.
                //
                if((CM_Get_DevNode_Status(&ulStatus, &ulProblem, DeviceInfoData->DevInst, 0) != CR_SUCCESS) ||
                   (ulStatus & DN_ROOT_ENUMERATED)) {

                    return NO_ERROR;
                }

                //
                // Allocate our context.
                //

                InstallContext = MyMalloc(sizeof(STORAGE_COINSTALLER_CONTEXT));

                if(InstallContext == NULL) {
                    return NO_ERROR;
                }

                memset(InstallContext, 0, sizeof(STORAGE_COINSTALLER_CONTEXT));
                InstallContext->DeviceEnumKey = INVALID_HANDLE_VALUE;

                //
                // open the device's instance under the enum key
                //

                InstallContext->DeviceEnumKey = SetupDiCreateDevRegKey(
                                                    DeviceInfoSet,
                                                    DeviceInfoData,
                                                    DICS_FLAG_GLOBAL,
                                                    0,
                                                    DIREG_DEV,
                                                    NULL,
                                                    NULL);

                if (InstallContext->DeviceEnumKey == INVALID_HANDLE_VALUE) {
                    ChkPrintEx(("StorageInstallCdrom: Failed to open device "
                                "registry key\n"));
                }

                //
                // Search the device settings database to see if there are
                // any settings provided for this particular device.
                //
                if (InstallContext->DeviceEnumKey != INVALID_HANDLE_VALUE) {
                    StorageCopyDeviceSettings(DeviceInfoSet,
                                              DeviceInfoData,
                                              InstallContext->DeviceEnumKey);
                }

                //
                // See if we need to install any of the filter drivers to enable
                // additional CD-ROM (CD-R, DVD-RAM, etc...) features.
                //

                if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                &GUID_DEVCLASS_CDROM)) {

                    StorageInstallCdrom(DeviceInfoSet,
                                        DeviceInfoData,
                                        InstallContext,
                                        TRUE);
                }

                //
                // See if there is currently a 'FriendlyName' property.
                //

                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_FRIENDLYNAME,
                                                    NULL,
                                                    NULL,
                                                    0,
                                                    NULL) ||
                   (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    //
                    // Either we succeeded (which should never happen), or we
                    // failed with a return value of buffer-too-small,
                    // indicating that the property already exists.  In this
                    // case, there's nothing for us to do.
                    //
                    goto CoPreInstallDone;
                }

                //
                // Attempt to retrieve the DeviceDesc property.
                // start out with a buffer size that should always be big enough
                //

                DeviceDescBufferLen = LINE_LEN * sizeof(WCHAR);

                while(TRUE) {

                    if(!(DeviceDescBuffer = MyMalloc(DeviceDescBufferLen))) {

                        //
                        // We failed, but what we're doing is not at all
                        // critical.  Thus, we'll go ahead and let the
                        // installation proceed.  If we're out of memory, it's
                        // going to fail for a much more important reason
                        // later anyway.
                        //

                        goto CoPreInstallDone;
                    }

                    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_DEVICEDESC,
                                                        NULL,
                                                        (PBYTE)DeviceDescBuffer,
                                                        DeviceDescBufferLen,
                                                        &DeviceDescBufferLen)) {
                        break;
                    }

                    Err = GetLastError();

                    //
                    // Free our current buffer before examining the
                    // cause of failure.
                    //

                    MyFree(DeviceDescBuffer);
                    DeviceDescBuffer = NULL;

                    if(Err != ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // The failure was for some other reason than
                        // buffer-too-small.  This means we're not going to
                        // be able to get the DeviceDesc (most likely because
                        // the bus driver didn't supply us one.  There's
                        // nothing more we can do.
                        //
                        goto CoPreInstallDone;
                    }
                }

CoPreInstallDone:

                //
                // Save the device description buffer away.
                //

                InstallContext->DeviceDescBuffer = DeviceDescBuffer;

                //
                // Store the installer context in the context structure and
                // request a post-processing callback.
                //

                Context->PrivateData = InstallContext;

                return ERROR_DI_POSTPROCESSING_REQUIRED;
            }
        }

        default :
            //
            // We should always be 'on the way in', since we never request
            // postprocessing except for DIF_INSTALLDEVICE.
            //
            MYASSERT(!Context->PostProcessing);
            return NO_ERROR;
    }
}

DWORD
VolumeClassInstaller(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            DeviceInfoSet,
    IN  PSP_DEVINFO_DATA    DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine is the class installer function for storage volumes.

Arguments:

    InstallFunction - Supplies the install function.

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    return ERROR_DI_DO_DEFAULT;
}

BOOLEAN
OverrideFriendlyNameForTape(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine checks the device description, given in the INF, for
    the tape being installed. If the device description is a generic
    name (Tape drive), then we use the name generated from Inquiry
    data in UI such as Device Manager. If the INF provides a specific
    name, then we use that instead.

Arguments:

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    TRUE  : If the device description given in the INF should be
            used as FriendlyName
    FALSE : If the name generated from Inquiry data should be
            used as FriendlyName instead of the name given in INF
*/
{

   SP_DRVINFO_DETAIL_DATA  drvDetData;
   SP_DRVINFO_DATA         drvData;
   DWORD                   dwSize;
   TCHAR                   szSection[LINE_LEN];
   HINF                    hInf;
   INFCONTEXT              infContext;
   BOOLEAN                 OverrideFriendlyName = FALSE;
   TCHAR                   szSectionName[LINE_LEN];

   ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
   drvData.cbSize = sizeof(SP_DRVINFO_DATA);
   if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &drvData)) {
       return FALSE;
   }

   ZeroMemory(&drvDetData, sizeof(SP_DRVINFO_DETAIL_DATA));
   drvDetData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
   if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &drvData,
                                   &drvDetData,
                                   drvDetData.cbSize,
                                   &dwSize) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
       return FALSE;
   }

   hInf = SetupOpenInfFile(drvDetData.InfFileName,
                           NULL,
                           INF_STYLE_WIN4,
                           NULL);
   if (hInf == INVALID_HANDLE_VALUE) {
       return FALSE;
   }

   //
   // Get the actual device install section name
   //
   ZeroMemory(szSectionName, sizeof(szSectionName));
   SetupDiGetActualSectionToInstall(hInf,
                                    drvDetData.SectionName,
                                    szSectionName,
                                    sizeof(szSectionName) / sizeof(TCHAR),
                                    NULL,
                                    NULL
                                    );

   if (SetupFindFirstLine(hInf, szSectionName,
                          TEXT("UseInfDeviceDesc"),
                          &infContext)) {
      DWORD UseDeviceDesc = 0;
      if ((SetupGetIntField(&infContext, 1, (PINT)&UseDeviceDesc)) &&
          (UseDeviceDesc)) {

         //
         // Delete friendly name if it exists.
         // Device Description will be used here on.
         //
         SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_FRIENDLYNAME,
                                          NULL,
                                          0);

         OverrideFriendlyName = TRUE;
      }
   }

   if (OverrideFriendlyName) {
      ChkPrintEx(("Will override friendly name\n"));
   } else {
      ChkPrintEx(("Will NOT override friendly name\n"));
   }

   SetupCloseInfFile(hInf);

   return OverrideFriendlyName;
}

BOOLEAN
CopyKey(
    HKEY SourceKey,
    HKEY DestinationKey
    )
{
    DWORD index = 0;

    DWORD numberOfKeys;
    DWORD numberOfValues;

    DWORD keyNameLength;
    DWORD valueNameLength;
    DWORD valueLength;

    DWORD nameLength;

    PTCHAR name = NULL;
    PVOID data = NULL;

    LONG status = ERROR_SUCCESS;

    //
    // Determine the largest name and data length of the values in this key.
    //

    status = RegQueryInfoKey(SourceKey,
                             NULL,
                             NULL,
                             NULL,
                             &numberOfKeys,
                             &keyNameLength,
                             NULL,
                             &numberOfValues,
                             &valueNameLength,
                             &valueLength,
                             NULL,
                             NULL);

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("Error %d getting info for key %#0x\n", status, SourceKey));
        return FALSE;
    }

    //
    // Determine the longer of the two name lengths, then account for the
    // short lengths returned by the registry code (it leaves out the
    // terminating NUL).
    //

    nameLength = max(valueNameLength, keyNameLength);
    nameLength += 1;

    //
    // Allocate name and data buffers
    //

    name = MyMalloc(nameLength * sizeof(TCHAR));
    if(name == NULL) {
        return FALSE;
    }

    //
    // there may not be any data to buffer.
    //

    if(valueLength != 0) {
        data = MyMalloc(valueLength);
        if(data == NULL) {
            MyFree(name);
            return FALSE;
        }
    }

    //
    // Enumerate each value in the SourceKey and copy it to the DestinationKey.
    //

    for(index = 0;
        (index < numberOfValues) && (status != ERROR_NO_MORE_ITEMS);
        index++) {

        DWORD valueDataLength;

        DWORD type;

        valueNameLength = nameLength;
        valueDataLength = valueLength;

        //
        // Read the value into the pre-allocated buffers.
        //

        status = RegEnumValue(SourceKey,
                              index,
                              name,
                              &valueNameLength,
                              NULL,
                              &type,
                              data,
                              &valueDataLength);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d reading value %x\n", status, index));
            continue;
        }

        //
        // Now set this value in the destination key.
        // If this fails there's not much we can do but continue on to the
        // next value.
        //

        status = RegSetValueEx(DestinationKey,
                               name,
                               0,
                               type,
                               data,
                               valueDataLength);
    }

    //
    // Free the data buffer.
    //

    MyFree(data);
    data = NULL;

    status = ERROR_SUCCESS;

    //
    // Now enumerate each key in the SourceKey, create the same key in the
    // desination key, open a handle to each one and recurse.
    //

    for(index = 0;
        (index < numberOfKeys) && (status != ERROR_NO_MORE_ITEMS);
        index++) {

        FILETIME lastWriteTime;

        HKEY newSourceKey;
        HKEY newDestinationKey;

        keyNameLength = nameLength;

        status = RegEnumKeyEx(SourceKey,
                              index,
                              name,
                              &keyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              &lastWriteTime);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d enumerating source key %x\n", status, index));
            continue;
        }

        //
        // Open the source subkey.
        //

        status = RegOpenKeyEx(SourceKey,
                              name,
                              0L,
                              KEY_READ,
                              &newSourceKey);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d opening source key %x\n", status, index));
            continue;
        }

        //
        // Create the destination subkey.
        //

        status = RegCreateKeyEx(DestinationKey,
                                name,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &newDestinationKey,
                                NULL);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d creating dest key %x\n", status, index));
            RegCloseKey(newSourceKey);
            continue;
        }

        //
        // Recursively copy this key.
        //

        CopyKey(newSourceKey, newDestinationKey);

        RegCloseKey(newSourceKey);
        RegCloseKey(newDestinationKey);
    }

    //
    // Now free the name buffer.
    //

    MyFree(name);


    return TRUE;
}

BOOLEAN
StorageCopyDeviceSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey
    )
{
    PTCHAR hardwareIdList = NULL;
    PTCHAR hardwareId = NULL;

    DWORD requiredSize = 0;

    HKEY settingsDatabaseKey = INVALID_HANDLE_VALUE;

    BOOLEAN settingsCopied = FALSE;
    DWORD status;

    ASSERT(DeviceInfo != NULL);
    ASSERT(DeviceInfoData != NULL);

    //
    // Open the device settings key.
    //

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          STORAGE_DEVICE_SETTINGS_DATABASE,
                          0L,
                          KEY_READ,
                          &settingsDatabaseKey);

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageCopyDeviceSettings: Error %d opening "
                    "settings database\n",
                    status));
        return FALSE;
    }

    //
    // get the hardware id's
    //

    if(SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                        DeviceInfoData,
                                        SPDRP_HARDWAREID,
                                        NULL,
                                        NULL,
                                        0,
                                        &requiredSize) ||
       (requiredSize == 0)) {

        //
        // That's odd.
        //

        ChkPrintEx(("StorageCopyDeviceSettings: no hardware ids available?\n"));
        goto cleanup;
    }

    //
    // requiredSize is bytes, not characters
    //

    hardwareIdList = MyMalloc(requiredSize);
    if (hardwareIdList == NULL) {
        ChkPrintEx(("StorageCopyDeviceSettings: Couldn't allocate %d bytes "
                    "for HWIDs\n", requiredSize));
        goto cleanup;
    }

    if(!SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                         DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         NULL,
                                         (PBYTE)hardwareIdList,
                                         requiredSize,
                                         NULL)) {
        ChkPrintEx(("StorageCopyDeviceSettings: failed to get "
                    "device's hardware ids %x\n",
                    GetLastError()));
        goto cleanup;
    }

    //
    // Look in the device settings database for a matching hardware ID.  When
    // we find a match copy the contents of that key under the device's
    // devnode key.
    //
    // The hardware IDs we get back from SetupDi are sorted from most exact
    // to least exact so we're guaranteed to find the closest match first.
    //

    hardwareId = hardwareIdList;

    while(hardwareId[0] != TCHAR_NULL) {

        HKEY deviceSettingsKey;

        LONG openStatus;

        //
        // Replace slashes with #'s so that it's compatible as a registry
        // key name.
        //

        ReplaceSlashWithHash(hardwareId);

        openStatus = RegOpenKeyEx(settingsDatabaseKey,
                                  hardwareId,
                                  0,
                                  KEY_READ,
                                  &deviceSettingsKey);

        if (openStatus == ERROR_SUCCESS) {

            //StorageReadSettings(specialTargetHandle, &settings);
            CopyKey(deviceSettingsKey, DeviceEnumKey);

            settingsCopied = TRUE;

            RegCloseKey(deviceSettingsKey);
            break;
        }

        // get to next null, for statement will advance past it
        while (*hardwareId) {
            hardwareId += 1;
        }

        //
        // Skip the nul and go to the next tchar.
        //

        hardwareId += 1;

        RegCloseKey(deviceSettingsKey);

    } // end of loop for query'ing each id

cleanup:

    ChkPrintEx(("StorageCopyDeviceSettings: Cleaning up...\n"));

    if (settingsDatabaseKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(settingsDatabaseKey);
    }

    if (hardwareIdList != NULL) {
        MyFree(hardwareIdList);
    }

    return settingsCopied;
}

VOID
StorageInstallCdrom(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PSTORAGE_COINSTALLER_CONTEXT InstallContext,
    IN BOOLEAN          PreInstall
    )
{
    CDVD_CAPABILITIES_PAGE buffer;
    PCDVD_CAPABILITIES_PAGE page = NULL;

    BOOLEAN installRedbook = FALSE;
    BOOLEAN installImapi = FALSE;
    BOOLEAN needRestart = FALSE;

    //
    // If this is post-installation then get the device capabilities page and
    // provide it to the update routines.
    //

    if(PreInstall == FALSE) {

        if(StorageGetCDVDCapabilities(DeviceInfo, DeviceInfoData, &buffer)) {
            page = &buffer;
        }
    }

    //
    // Check in the registry (or query the device) and determine if we should
    // enable the redbook (digital audio playback) driver on this device.
    //
    // If redbook was already installed the first time through then there's no
    // need to do this step
    //

    if((PreInstall == TRUE) ||
       ((InstallContext->CdRom.RedbookInstalled == FALSE) && (page != NULL))) {

        if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
            installRedbook = StorageUpdateRedbookSettings(
                                DeviceInfo,
                                DeviceInfoData,
                                InstallContext->DeviceEnumKey,
                                page);
        }
    }

    //
    // Check in the registry (or query the device) and determine if we should
    // enable the IMAPI driver on this device.
    //
    // If imapi was already installed the first time through then there's no
    // need to do this step
    //

    if((PreInstall == TRUE) ||
       ((InstallContext->CdRom.ImapiInstalled == FALSE) && (page != NULL))) {

        if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
            installImapi = StorageUpdateImapiSettings(DeviceInfo,
                                                      DeviceInfoData,
                                                      InstallContext->DeviceEnumKey,
                                                      page);
        }
    }

    //
    // If this is a pre-install pass then we can just add the services.  If it's
    // not then first check to see that we don't do anything here that we
    // already did in the pre-install pass.
    //

    if(PreInstall) {

        //
        // Save away what we've done during the pre-install pass.
        //

        InstallContext->CdRom.RedbookInstalled = installRedbook;
        InstallContext->CdRom.ImapiInstalled = installImapi;
    }

    //
    // If we're supposed to enable IMAPI then do so by enabling the IMAPI
    // service and including it in the list of lower filters for this device.
    //

    if(installRedbook) {
        ChkPrintEx(("StorageInstallCdrom: Installing Upperfilter: REDBOOK\n"));
        StorageInstallFilter(DeviceInfo,
                             DeviceInfoData,
                             REDBOOK_SERVICE_NAME,
                             SPDRP_UPPERFILTERS);
        needRestart = TRUE;
    }

    if(installImapi) {
        ChkPrintEx(("StorageInstallCdrom: Installing Lowerfilter: IMAPI\n"));
        StorageInstallFilter(DeviceInfo,
                             DeviceInfoData,
                             IMAPI_SERVICE_NAME,
                             SPDRP_LOWERFILTERS);
        needRestart = TRUE;
    }

    if((PreInstall == FALSE) && (needRestart == TRUE)) {

        SP_PROPCHANGE_PARAMS propChange;

        //
        // The device is all set but we to indicate that a property change
        // has occurred.  Set the propchange_pending flag which should cause
        // a DIF_PROPERTYCHANGE command to get sent through, which we'll use
        // to restart the device.
        //

        ChkPrintEx(("StorageInstallCdrom: Calling class installer with DIF_PROPERTYCHANGE\n"));

        propChange.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        propChange.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
        propChange.StateChange = DICS_PROPCHANGE;
        propChange.Scope = DICS_FLAG_GLOBAL;
        propChange.HwProfile = 0;

        SetupDiSetClassInstallParams(DeviceInfo,
                                     DeviceInfoData,
                                     &propChange.ClassInstallHeader,
                                     sizeof(SP_PROPCHANGE_PARAMS));

        SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfo,
                                  DeviceInfoData);
    }

    return;
}


BOOLEAN
StorageUpdateRedbookSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE CapabilitiesPage OPTIONAL
    )
{
    STORAGE_REDBOOK_SETTINGS settings;

    HKEY redbookKey;

    DWORD setFromDevice = FALSE;

    DWORD disposition;
    DWORD status;

    settings.CDDASupported = FALSE;
    settings.CDDAAccurate = FALSE;
    settings.ReadSizesSupported = 0;

    //
    // Open the digital audio subkey of the device's enum key.  If the device
    // hasn't been started yet then we won't create the key.  Otherwise we
    // will create it and populate it.
    //

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {

        status = RegCreateKeyEx(DeviceEnumKey,
                                REDBOOK_SETTINGS_KEY,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &redbookKey,
                                &disposition
                                );
    } else {

        status = RegOpenKeyEx(DeviceEnumKey,
                              REDBOOK_SETTINGS_KEY,
                              0L,
                              KEY_READ | KEY_WRITE,
                              &redbookKey);

        disposition = REG_OPENED_EXISTING_KEY;
    }

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageUpdateRedbookSettings: couldn't open redbook key "
                    "- %d\n", status));
        return FALSE;
    }

    if(disposition == REG_OPENED_EXISTING_KEY) {

        //
        // Read the redbook settings out of the registry (if there are any) and
        // see if they make any sense.
        //

        StorageReadRedbookSettings(redbookKey, &settings);

    } else {

        //
        // Since the DigitalAudio key didn't exist nothing could be set.  Check
        // with the device to see what it supports.
        //

        MYASSERT(CapabilitiesPage != NULL);

        settings.CDDASupported = CapabilitiesPage->CDDA;
        settings.CDDAAccurate = CapabilitiesPage->CDDAAccurate;

        //
        // If the device isn't accurate then we can't be quite sure what the valid
        // read sizes are (unless they were listed in the registry, but in that case
        // we'd never have been here).  Use zero, which is a special value for
        // ReadSizesSupported which means "i don't know".
        //

        if((settings.CDDASupported == TRUE) &&
           (settings.CDDAAccurate == TRUE)) {
            settings.ReadSizesSupported = -1;
        }

        setFromDevice = TRUE;
    }

    //
    // Write the updated (or derived) settings to the registry.
    //

    if (settings.CDDAAccurate) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom fully supports CDDA.\n"));
    } else if (settings.ReadSizesSupported) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom only supports some sizes CDDA read.\n"));
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "These are in the bitmask: %x.\n",
                    settings.ReadSizesSupported));
    } else if (settings.CDDASupported) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom only supports some sizes CDDA read.\n"));
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "There is no data on which sizes (if any) "
                    "are accurate\n"));
    } else {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom does not support CDDA at all.\n"));
    }

    RegSetValueEx(redbookKey,
                  L"ReadSizesSupported",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.ReadSizesSupported,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"CDDASupported",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.CDDASupported,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"CDDAAccurate",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.CDDAAccurate,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"SettingsFromDevice",
                  0,
                  REG_DWORD,
                  (LPBYTE) &(setFromDevice),
                  sizeof(DWORD)
                  );

    RegCloseKey(redbookKey);

    //
    // if CDDA is supported, and one of:
    //      CDDA is accurate
    //      We have a mask of accurate settings
    //      We want to force install of redbook
    // is true, then return TRUE.
    // else, return FALSE.
    //

    if((settings.CDDASupported) &&
       ((settings.CDDAAccurate) ||
        (settings.ReadSizesSupported != 0) ||
        (StorageForceRedbookOnInaccurateDrives))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
StorageUpdateImapiSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE CapabilitiesPage OPTIONAL
    )
{
    HKEY imapiKey;

    DWORD disposition;
    DWORD status;

    //
    // must be a DWORD so we can read into it from the registry.
    //

    DWORD enableImapi = FALSE;

    //
    // Open the imapi subkey of the device's enum key.  If the device has been
    // started then we'll create the key if it didn't already exist.
    //

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {
        status = RegCreateKeyEx(DeviceEnumKey,
                                IMAPI_SETTINGS_KEY,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &imapiKey,
                                &disposition
                                );
    } else {
        status = RegOpenKeyEx(DeviceEnumKey,
                              IMAPI_SETTINGS_KEY,
                              0L,
                              KEY_READ | KEY_WRITE,
                              &imapiKey
                              );

        disposition = REG_OPENED_EXISTING_KEY;
    }

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageUpdateImapiSettings: couldn't open imapi key "
                    "- %d\n", status));
        return FALSE;
    }

    if(disposition == REG_OPENED_EXISTING_KEY) {

        DWORD type = REG_DWORD;
        DWORD dataSize = sizeof(DWORD);

        //
        // Check to see if the EnableImapi value is set in this key.  If it is
        // then we'll be wanting to enable the filter driver.
        //

        status = RegQueryValueEx(imapiKey,
                                 IMAPI_ENABLE_VALUE,
                                 NULL,
                                 &type,
                                 (LPBYTE) &enableImapi,
                                 &dataSize);

        if (status == ERROR_SUCCESS) {
            if(type != REG_DWORD) {
                ChkPrintEx(("StorageUpdateImapiSettings: EnableImapi value is of "
                            "type %d\n", type));
                enableImapi = FALSE;
            }

            RegCloseKey(imapiKey);

            return (BOOLEAN) enableImapi ? TRUE : FALSE;

        }

        //
        // else the key wasn't accessible.  fall through to query the drive
        //

    }

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {

        //
        // query the drive to see if it supports mastering...
        //

        if((CapabilitiesPage->CDRWrite) || (CapabilitiesPage->CDEWrite)) {
            enableImapi = TRUE;
        }
    }

    if (enableImapi && DISABLE_IMAPI) {
        ChkPrintEx(("StorageUpdateImapiSettings: Imapi would have "
                    "been enabled"));
        enableImapi = FALSE;
    }


    if (enableImapi) {

        //
        // must add registry key listed above that suggests that
        // imapi must be enabled by default.
        //

        status = RegSetValueEx(imapiKey,
                               IMAPI_ENABLE_VALUE,
                               0,
                               REG_DWORD,
                               (BYTE*)&enableImapi,
                               sizeof(DWORD)
                               );

        //
        // if this failed, then the device driver won't attach itself
        // to the stack.  in this case, we don't want to enable IMAPI
        // after all...
        //

        if (status != ERROR_SUCCESS) {
            enableImapi = FALSE;
        }
    }

    RegCloseKey(imapiKey);


    return (BOOLEAN) enableImapi ? TRUE : FALSE;
}


DWORD
StorageInstallFilter(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           FilterName,
    IN DWORD            FilterType
    )
{
    DWORD status;

    DWORD oldStartType;

    //
    // Check with the service controller and make sure that the IMAPI service
    // is set to start at system time.
    //

    status = SetServiceStart(FilterName, SERVICE_SYSTEM_START, &oldStartType);

    if(status != ERROR_SUCCESS) {
        return status;
    }

    //
    // Add the IMAPI filter to the list of lower device filters.
    //

    status = AddFilterDriver(DeviceInfo,
                             DeviceInfoData,
                             FilterName,
                             FilterType
                             );

    if(status != ERROR_SUCCESS) {

        //
        // if it failed, and the service was previously disabled,
        // re-disable the service.
        //

        if(oldStartType == SERVICE_DISABLED) {
            SetServiceStart(FilterName, SERVICE_DISABLED, &oldStartType);
        }

    }

    return status;
}


DWORD
SetServiceStart(
    IN LPCTSTR ServiceName,
    IN DWORD StartType,
    OUT DWORD *OldStartType
    )
{
    SC_HANDLE serviceManager;
    SC_HANDLE service;

    DWORD status;

    serviceManager = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_WRITE);

    if(serviceManager == NULL) {
        return GetLastError();
    }

    service = OpenService(serviceManager,
                          ServiceName,
                          SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG);

    if(service == NULL) {
        status = GetLastError();
        CloseServiceHandle(serviceManager);
        return status;
    }

    {
        QUERY_SERVICE_CONFIG configBuffer;
        LPQUERY_SERVICE_CONFIG config = &(configBuffer);
        DWORD configSize;

        BOOLEAN wasStarted;

        //
        // Retrieve the configuration so we can get the current service
        // start value.  We unfortuantely need to allocate memory for the
        // entire service configuration - the fine QueryServiceConfig API
        // doesn't give back partial data.
        //

        memset(config, 0, sizeof(QUERY_SERVICE_CONFIG));
        configSize = sizeof(QUERY_SERVICE_CONFIG);

        //
        // Determine the number of bytes needed for the configuration.
        //

        QueryServiceConfig(service, config, 0, &configSize);
        status = GetLastError();

        if(status != ERROR_INSUFFICIENT_BUFFER) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            return status;
        }

        //
        // Allocate the appropriately sized config buffer.
        //

        config = MyMalloc(configSize);
        if(config == NULL) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if(!QueryServiceConfig(service, config, configSize, &configSize)) {
            status = GetLastError();

            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            MyFree(config);
            return status;
        }

        //
        // Record what the old start type was so that the caller can disable
        // the service again if filter-installation fails.
        //

        *OldStartType = config->dwStartType;

        //
        // If the start type doesn't need to be changed then bail out now.
        //

        if(config->dwStartType == StartType) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            MyFree(config);
            return ERROR_SUCCESS;
        }

        //
        // Now write the configuration back to the service.
        //

        if(ChangeServiceConfig(service,
                               SERVICE_NO_CHANGE,
                               StartType,
                               SERVICE_NO_CHANGE,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL) == FALSE) {
            status = GetLastError();
        } else {
            status = ERROR_SUCCESS;
        }

        CloseServiceHandle(service);
        CloseServiceHandle(serviceManager);
        MyFree(config);
    }

    return status;
}


DWORD
AddFilterDriver(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           ServiceName,
    IN DWORD            FilterType
    )
{

    DWORD serviceNameLength = (_tcslen(ServiceName) + 2) * sizeof(TCHAR);

    LPTSTR filterList = NULL;
    DWORD filterListSize = 0;

    DWORD type;

    DWORD status;

    ASSERT((FilterType == SPDRP_LOWERFILTERS) ||
           (FilterType == SPDRP_UPPERFILTERS));

    //
    // Query to find out the property size.  If it comes back zero then
    // we'll just try to write the property in there.
    //

    SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                     DeviceInfoData,
                                     FilterType,
                                     &type,
                                     NULL,
                                     0L,
                                     &filterListSize);

    status = GetLastError();

    if((status != ERROR_INVALID_DATA) &&
       (status != ERROR_INSUFFICIENT_BUFFER)) {

        //
        // If this succeeded with no buffer provided then there's something
        // very odd going on.
        //

        ChkPrintEx(("Unable to get filter list: %x\n", status));
        ASSERT(status != ERROR_SUCCESS);

        return status;
    }

    //
    // This error code appears to be returned if the property isn't set in the
    // devnode.  In that event make sure propertySize is cleared.
    //

    if(status == ERROR_INVALID_DATA) {

        filterListSize = 0;

    } else if(type != REG_MULTI_SZ) {

        return ERROR_INVALID_DATA;
    }

    //
    // If the property size is zero then there's nothing to query.  Likewise,
    // if it's equal to the size of two nul characters.
    //

    if(filterListSize >= (sizeof(TCHAR_NULL) * 2)) {

        DWORD tmp;
        LPTSTR listEnd;

        //
        // increase the filter list buffer size so that it can hold our
        // addition.  Make sure to take into account the extra nul character
        // already in the existing list.
        //

        filterListSize += serviceNameLength - sizeof(TCHAR);

        filterList = MyMalloc(filterListSize);

        if(filterList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(filterList, 0, filterListSize);

        //
        // Query the registry information again.
        //

        if(!SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                             DeviceInfoData,
                                             FilterType,
                                             &type,
                                             (PBYTE) filterList,
                                             filterListSize,
                                             &tmp)) {
            status = GetLastError();
            MyFree(filterList);
            return status;
        }

        if(type != REG_MULTI_SZ) {
            MyFree(filterList);
            return ERROR_INVALID_DATA;
        }

        //
        // Compute the end of the filter list and copy the imapi filters
        // there.
        //

        listEnd = filterList;
        listEnd += tmp / sizeof(TCHAR);
        listEnd -= 1;

        memset(listEnd, 0, serviceNameLength);
        memcpy(listEnd, ServiceName, serviceNameLength - sizeof(TCHAR_NULL));

    } else {
        filterList = MyMalloc(serviceNameLength);

        if(filterList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(filterList, 0, serviceNameLength);
        memcpy(filterList, ServiceName, serviceNameLength - sizeof(TCHAR_NULL));

        filterListSize = serviceNameLength;
    }

    if(!SetupDiSetDeviceRegistryProperty(DeviceInfo,
                                         DeviceInfoData,
                                         FilterType,
                                         (PBYTE) filterList,
                                         filterListSize)) {
        status = GetLastError();
    } else {
        status = ERROR_SUCCESS;
    }

    MyFree(filterList);

    return status;
}




/*++

Routine Description:

    NOTE: we default to RETRY==TRUE except for known error classes
    This is based upon classpnp's InterpretSenseInfo().

Arguments:

Return Value:


--*/
VOID
StorageInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL // in 1/10 second intervals
    )
{
    DWORD   error;
    DWORD   retryDelay;
    BOOLEAN retry;
    UCHAR   senseKey;
    UCHAR   asc;
    UCHAR   ascq;

    if (SenseDataSize == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_IO_DEVICE;
        goto SetAndExit;

    }

    //
    // default to suggesting a retry in 1/10 of a second,
    // with a status of ERROR_IO_DEVICE.
    //
    retry = TRUE;
    retryDelay = 1;
    error = ERROR_IO_DEVICE;

    //
    // if we can't even see the sense key, just return.
    // can't use bitfields in these macros, so use next field
    // instead of RTL_SIZEOF_THROUGH_FIELD
    //

    if (SenseDataSize < FIELD_OFFSET(SENSE_DATA, Information)) {
        goto SetAndExit;
    }

    senseKey = SenseData->SenseKey;

    //
    // if the device succeeded the request, return success.
    //

    if (senseKey == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_SUCCESS;
        goto SetAndExit;
    }


    { // set the size to what's actually useful.
        UCHAR validLength;
        // figure out what we could have gotten with a large sense buffer
        if (SenseDataSize <
            RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)) {
            validLength = SenseDataSize;
        } else {
            validLength =
                RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
            validLength += SenseData->AdditionalSenseLength;
        }
        // use the smaller of the two values.
        SenseDataSize = min(SenseDataSize, validLength);
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCode)) {
        asc = SCSI_ADSENSE_NO_SENSE;
    } else {
        asc = SenseData->AdditionalSenseCode;
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCodeQualifier)) {
        ascq = SCSI_SENSEQ_CAUSE_NOT_REPORTABLE; // 0x00
    } else {
        ascq = SenseData->AdditionalSenseCodeQualifier;
    }

    //
    // interpret :P
    //

    switch (senseKey & 0xf) {

    case SCSI_SENSE_RECOVERED_ERROR: {  // 0x01
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
        } else {
            error = ERROR_SUCCESS;
        }
        retry = FALSE;
        break;
    } // end SCSI_SENSE_RECOVERED_ERROR

    case SCSI_SENSE_NOT_READY: { // 0x02
        error = ERROR_NOT_READY;

        switch (asc) {

        case SCSI_ADSENSE_LUN_NOT_READY: {

            switch (ascq) {

            case SCSI_SENSEQ_BECOMING_READY:
            case SCSI_SENSEQ_OPERATION_IN_PROGRESS: {
                retryDelay = PASS_THROUGH_NOT_READY_RETRY_INTERVAL;
                break;
            }

            case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE:
            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
            case SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS: {
                retry = FALSE;
                break;
            }

            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED: {
                retry = FALSE;
                break;
            }

            } // end switch (senseBuffer->AdditionalSenseCodeQualifier)
            break;
        }

        case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
            error = ERROR_NOT_READY;
            retry = FALSE;
            break;
        }
        } // end switch (senseBuffer->AdditionalSenseCode)

        break;
    } // end SCSI_SENSE_NOT_READY

    case SCSI_SENSE_MEDIUM_ERROR: { // 0x03
        error = ERROR_CRC;
        retry = FALSE;

        //
        // Check if this error is due to unknown format
        //
        if (asc == SCSI_ADSENSE_INVALID_MEDIA) {

            switch (ascq) {

            case SCSI_SENSEQ_UNKNOWN_FORMAT: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                break;
            }

            case SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                //error = ERROR_CLEANER_CARTRIDGE_INSTALLED;
                break;
            }

            } // end switch AdditionalSenseCodeQualifier

        } // end SCSI_ADSENSE_INVALID_MEDIA
        break;
    } // end SCSI_SENSE_MEDIUM_ERROR

    case SCSI_SENSE_ILLEGAL_REQUEST: { // 0x05
        error = ERROR_INVALID_FUNCTION;
        retry = FALSE;

        switch (asc) {

        case SCSI_ADSENSE_ILLEGAL_BLOCK: {
            error = ERROR_SECTOR_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_INVALID_LUN: {
            error = ERROR_FILE_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_COPY_PROTECTION_FAILURE: {
            error = ERROR_FILE_ENCRYPTED;
            //error = ERROR_SPT_LIB_COPY_PROTECTION_FAILURE;
            switch (ascq) {
                case SCSI_SENSEQ_AUTHENTICATION_FAILURE:
                    //error = ERROR_SPT_LIB_AUTHENTICATION_FAILURE;
                    break;
                case SCSI_SENSEQ_KEY_NOT_PRESENT:
                    //error = ERROR_SPT_LIB_KEY_NOT_PRESENT;
                    break;
                case SCSI_SENSEQ_KEY_NOT_ESTABLISHED:
                    //error = ERROR_SPT_LIB_KEY_NOT_ESTABLISHED;
                    break;
                case SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION:
                    //error = ERROR_SPT_LIB_SCRAMBLED_SECTOR;
                    break;
                case SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT:
                    //error = ERROR_SPT_LIB_REGION_MISMATCH;
                    break;
                case SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR:
                    //error = ERROR_SPT_LIB_RESETS_EXHAUSTED;
                    break;
            } // end switch of ASCQ for COPY_PROTECTION_FAILURE
            break;
        }

        } // end switch (senseBuffer->AdditionalSenseCode)
        break;

    } // end SCSI_SENSE_ILLEGAL_REQUEST

    case SCSI_SENSE_DATA_PROTECT: { // 0x07
        error = ERROR_WRITE_PROTECT;
        retry = FALSE;
        break;
    } // end SCSI_SENSE_DATA_PROTECT

    case SCSI_SENSE_BLANK_CHECK: { // 0x08
        error = ERROR_NO_DATA_DETECTED;
        break;
    } // end SCSI_SENSE_BLANK_CHECK

    case SCSI_SENSE_NO_SENSE: { // 0x00
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
            retry   = FALSE;
        } else {
            error = ERROR_IO_DEVICE;
        }
        break;
    } // end SCSI_SENSE_NO_SENSE

    case SCSI_SENSE_HARDWARE_ERROR:  // 0x04
    case SCSI_SENSE_UNIT_ATTENTION: // 0x06
    case SCSI_SENSE_UNIQUE:          // 0x09
    case SCSI_SENSE_COPY_ABORTED:    // 0x0A
    case SCSI_SENSE_ABORTED_COMMAND: // 0x0B
    case SCSI_SENSE_EQUAL:           // 0x0C
    case SCSI_SENSE_VOL_OVERFLOW:    // 0x0D
    case SCSI_SENSE_MISCOMPARE:      // 0x0E
    case SCSI_SENSE_RESERVED:        // 0x0F
    default: {
        error = ERROR_IO_DEVICE;
        break;
    }

    } // end switch(SenseKey)

SetAndExit:

    if (ARGUMENT_PRESENT(SuggestRetry)) {
        *SuggestRetry = retry;
    }
    if (ARGUMENT_PRESENT(SuggestRetryDelay)) {
        *SuggestRetryDelay = retryDelay;
    }
    *ErrorValue = error;

    return;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\syssec.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syssec.c

Abstract:

    Security installation routines.

Author:

    Vijesh Shetty (vijeshs) 6-Mar-1997

Revision History:


--*/

#include "setupp.h"
#include "scesetup.h"
#pragma hdrstop

#if DBG
    #define SEC_DEBUG  1
#else
    #define SEC_DEBUG  0
#endif


#define SECURITY_WKS_INF_FILE L"defltwk.inf"
#define SECURITY_SRV_INF_FILE L"defltsv.inf"

//
// Structure for thread parameter
//
typedef struct _SYSSEC_THREAD_PARAMS {

    HWND  Window;
    HWND  ProgressWindow;
    DWORD ThreadId;
    ULONG Sec_StartAtPercent;
    ULONG Sec_StopAtPercent;
    BOOL  SendWmQuit;

} SYSSEC_THREAD_PARAMS, *PSYSSEC_THREAD_PARAMS;

BOOL SetupSecurityGaugeUpdate(
                             IN HWND Window,
                             IN UINT NotificationCode,
                             IN UINT NotificationSpecificValue,
                             IN LPARAM lParam );



HWND SetupProgWindow;
HANDLE SceSetupRootSecurityThreadHandle = NULL;
BOOL bSceSetupRootSecurityComplete = FALSE;


DWORD
pSetupInstallSecurity(
                     IN PVOID ThreadParam
                     )
{
    BOOL b;
    BOOL Success;
    UINT i;
    UINT GaugeRange;
    PSYSSEC_THREAD_PARAMS Context;
    DWORD NumberOfTicks;
    DWORD_PTR ret;
    HINSTANCE Dll_Handle;
    FARPROC SceSystem;
    WCHAR SecurityLogPath[MAX_PATH];
    DWORD Result;


    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "SETUP:            Entering Security Block. \n"));

    Context = ThreadParam;


    //
    // Assume success.
    //
    Success = TRUE;


    try{



    if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
         (SceSystem = GetProcAddress(Dll_Handle,"SceSetupSystemByInfName")) ) {


        Result = GetWindowsDirectory( SecurityLogPath, MAX_PATH );
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        pSetupConcatenatePaths( SecurityLogPath, L"security\\logs\\scesetup.log", (sizeof(SecurityLogPath)/sizeof(WCHAR)), NULL );

        //
        //Call for no. of ticks
        //

        if ( ret = SceSystem(ProductType ? SECURITY_SRV_INF_FILE : SECURITY_WKS_INF_FILE,
                             SecurityLogPath,
                             Upgrade ? 0 : (AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY),
                             Upgrade ? (SCESETUP_QUERY_TICKS | SCESETUP_UPGRADE_SYSTEM) : SCESETUP_QUERY_TICKS,
                             SetupSecurityGaugeUpdate,
                             (PVOID)&NumberOfTicks) ) {

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error in SCE while querying ticks - (%d)\n",
                       ret));

            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_SCE_SETUP_ERROR,
                         NULL,
                         SETUPLOG_USE_MESSAGEID,
                         ret, NULL, NULL);
            Success = FALSE;
        } else {

            GaugeRange = (NumberOfTicks*100/(Context->Sec_StopAtPercent - Context->Sec_StartAtPercent));
            SendMessage(Context->ProgressWindow, WMX_PROGRESSTICKS, NumberOfTicks, 0);
            SendMessage(Context->ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(Context->ProgressWindow,PBM_SETPOS,GaugeRange*Context->Sec_StartAtPercent/100,0);
            SendMessage(Context->ProgressWindow,PBM_SETSTEP,1,0);



            if ( ret = SceSystem(ProductType ? SECURITY_SRV_INF_FILE : SECURITY_WKS_INF_FILE,
                                 SecurityLogPath,
                                 Upgrade ? 0 : (AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY),
                                 Upgrade ? SCESETUP_UPGRADE_SYSTEM : SCESETUP_CONFIGURE_SECURITY,
                                 SetupSecurityGaugeUpdate,
                                 (PVOID)(Context->ProgressWindow) )) {

                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SETUP: Error in SCE while setting security - (%d)\n",
                           ret));

                SetuplogError(
                             LogSevError,
                             SETUPLOG_USE_MESSAGEID,
                             MSG_LOG_SCE_SETUP_ERROR,
                             NULL,
                             SETUPLOG_USE_MESSAGEID,
                             ret, NULL, NULL);

                Success = FALSE;
            }

        }

        FreeLibrary(Dll_Handle);

    } else {

        if ( Dll_Handle )
            FreeLibrary(Dll_Handle);


        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Error while loading SCE\n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


    }

    } except(EXCEPTION_EXECUTE_HANDLER) {


        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while applying default security \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }


    SendMessage(Context->ProgressWindow,PBM_SETPOS,(GaugeRange*Context->Sec_StopAtPercent/100),0);

    if ( Context->SendWmQuit ) {
        //
        //  We send WM_QUIT only if this routine was started as a separate thread.
        //  Otherwise, the WM_QUIT will be processed by the wizard, and it will make it stop.
        //
        PostThreadMessage(Context->ThreadId,WM_QUIT,Success,0);
    }

    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "SETUP:            Leaving Security Block. \n"));

    return(Success);
}


BOOL
SetupInstallSecurity(
                    IN HWND Window,
                    IN HWND ProgressWindow,
                    IN ULONG StartAtPercent,
                    IN ULONG StopAtPercent
                    )

/*++

Routine Description:

    Implement Security at start of GUI Setup.

Arguments:

    Window - supplies window handle for Window that is to be the
        parent/owner for any dialogs that are created, etc.

    ProgressWindow - supplies window handle of progress bar Window
        common control. This routine manages the progress bar.

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).


Return Value:

    Boolean value indicating whether all operations completed successfully.

--*/
{
    DWORD ThreadId;
    HANDLE ThreadHandle = NULL;
    MSG msg;
    SYSSEC_THREAD_PARAMS Context;
    BOOL Success;





    Context.ThreadId = GetCurrentThreadId();
    Context.Window = Window;
    Context.Sec_StartAtPercent = StartAtPercent;
    Context.Sec_StopAtPercent = StopAtPercent;
    Context.SendWmQuit = TRUE;
    Context.ProgressWindow = ProgressWindow;

    ThreadHandle = CreateThread(
                               NULL,
                               0,
                               pSetupInstallSecurity,
                               &Context,
                               0,
                               &ThreadId
                               );
    if (ThreadHandle) {

        CloseHandle(ThreadHandle);

        //
        // Pump the message queue and wait for the thread to finish.
        //
        do {
            GetMessage(&msg,NULL,0,0);
            if (msg.message != WM_QUIT) {
                DispatchMessage(&msg);
            }
        } while (msg.message != WM_QUIT);

        Success = (BOOL)msg.wParam;

    } else {
        //
        // Just do it synchronously.
        //
        Context.SendWmQuit = FALSE;
        Success = pSetupInstallSecurity(&Context);
    }

    return(Success);



}

BOOL
SetupSecurityGaugeUpdate(
                             IN HWND Window,
                             IN UINT NotificationCode,
                             IN UINT NotificationSpecificValue,
                             IN LPARAM lParam )
{
    SendMessage(Window,PBM_STEPIT,0,0);
    return( TRUE );
}


VOID
CallSceGenerateTemplate( VOID )
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupBackupSecurity")) ) {

            // We don't log errors for this call

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Generating Security Template. \n"));

            SceCall( NULL );

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Generating Security Template. Done ! \n"));

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while generating security template (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return;
}

VOID
CallSceConfigureServices( VOID )
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupConfigureServices")) ) {

            // We don't log errors for this call

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Configuring services. \n"));

            SceCall( ProductType );

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Configuring services. Done ! \n"));

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while configuring services (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return;
}


DWORD
pSceSetupRootSecurity( 
    IN PVOID ThreadParam
)
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;
    BOOL Success = FALSE;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupRootSecurity")) ) {

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Setup root security. \n"));

            BEGIN_SECTION(L"SceSetupRootSecurity");
            SceCall();
            Success = TRUE;

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Setup root security. Done ! \n"));

            bSceSetupRootSecurityComplete = TRUE;
            END_SECTION(L"SceSetupRootSecurity");

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while setting root security (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return( Success);
}

VOID
CallSceSetupRootSecurity( VOID )
{
    DWORD ThreadId;

    SceSetupRootSecurityThreadHandle = CreateThread(
                               NULL,
                               0,
                               pSceSetupRootSecurity,
                               0,
                               0,
                               &ThreadId
                               );
    if ( !SceSetupRootSecurityThreadHandle) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: SCE Could not start thread to setup root security(non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\unattend.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Unattend.c

Description:

    This performs all of the automated installation GUI mode setup.
    See below for usage and modification information

Author:

    Stephane Plante (t-stepl) 4-Sep-1995

Revision History:

    15-Sep-1995 (t-stepl) rewritten in table format
    26-Feb-1996 (tedm)    massive cleanup

--*/

#include "setupp.h"
#include <pencrypt.h>
#pragma hdrstop


/*

Table-driven unattended engine
------------------------------

There are two interrelated tables.

The first table is concerned with fetching data from the parameters file
($winnt$.inf) and processing it into a format that can be accessed by the
second table. The second table is associated with the pages in the setup wizard,
and provides the unattend engine with the rules for filling in the contents
of the associated pages from the data contained in the first table.


Adding a new piece of data to the parameters file
-------------------------------------------------

In the header file there is an enumerated type called UNATTENDENTRIES.
Add an entry for your data to the end of this enum. Now add an entry to the
UNATTENDANSWER table.

Here's an explanation of an entry in the UNATTENDEDANSWER table:

{ UAE_PROGRAM,  <-This is the identifier for the data item that I want
                to fetch. It is used to index into the table array
  FALSE,        <-This is a runtime variable. Just keep it as false
  FALSE,        <-If this is true, then it is considered an error in the
                unattend script if this value is unspecified. If it is
                false, then it does not matter if the value is not
                present.
  FALSE,        <-Another runtime flag. Just keep it as false
  0,            <-This is the answer we have initially. Since it gets overwritten
                quickly, there is no reason why not to set it to 0
  pwGuiUnattended   <- This is the string which identifies the section we want
  pwProgram     <- This is the string which identifies the key we want
  pwNull        <- This identifies the default. Note: NULL means that there is
                no default and so it is a serious error if the key does not
                exist in the file. pwNull, on the other hand, means the
                empty string.
  UAT_STRING    <- What format we want the answer in. Can be as a string, boolean
                or ULONG
  NULL          <- No callback function exists, however if one did, then must
                in the form of: BOOL fnc( struct _UNATTENDANSWER *rec)
                Where the fnc returns TRUE if the answer contained in the
                record is correct, or FALSE if the answer contained in the
                record is incorrect. This callback is meant to allow the
                programmer the ability to check to see if his answer is correct.
                Note: there is no bound as to when this callback can be issued.
                As such, no code which depends on a certain state of the
                installation should be used. For the record, the first time
                that an answer is required is the time when all records are
                filled in in the theory that it is cheaper to do all of the
                disk access at once rather then doing it on a as required basis.


Adding/changing wizard pages
----------------------------

Each page contains a series of items which must be filled in by the user.
Since the user wants hands off operation, he is counting on us
to do that filling in. As such, we require information about what elements are
contained on each page. To do this, we define an array whose elements each
describe a single element on the page. Here is the example from the NameOrg
page:

UNATTENDITEM ItemNameOrg[] = {
    {   IDT_NAME,   <-This is the label that identifies the item to which we
                    will try to send messages to, using SetDlgItemText().
        0,          <-One of the reserved words which can be used for
                    information passing during a callback
        0,          <-The second such word
        NULL,       <-Callback function. When we are trying to do something
                    complicated for the item (like comparing two strings)
                    it is easier to hardcode it in C. The format for it is:
                    BOOL fnc(HWND hwnd,DWORD contextinfo,
                        struct _UNATTENDITEM *item), where contextinfo is
                    a pointer to the page that the item resides on. The
                    function returns TRUE if is succeeded and doesn't think
                    that the user should see the page. FALSE otherwise.
        &UnattendAnswerTable[UAE_FULLNAME]
                    ^- This is a pointer to the data table so that we know
                    how to fill the item. If a callback is specified, this
                    could be set to null. Note that reference is made using
                    the enum that had defined previously. This is why
                    keeping the answer data table in order is so critical.
    },
    { IDT_ORGANIZATION, 0, 0, FALSE, NULL, &UnattendAnswerTable[UAE_ORGNAME] }
};

After this table has been created (if required), then you are ready to add
an entry to the UnattendPageTable[]. In this case, order doesn't matter,
but it is general practice to keep the entries in the same order
as the pages. Here is the entry in the table for the NAMEORG page:
    {
        IDD_NAMEORG,    <- This is the page id. We search based on this key.
                        Simply use whatever resourcename you used for the
                        dialogs.dlg file
        FALSE,          <- Runtime flag. Set it as false
        FALSE,          <- Runtime flag. Set it as false
        FALSE,          <- If this flag is true, then if there is an error
                        that occured in the unattended process, then this
                        page will always be displayed for the user. Good
                        for the start and finish pages
        2,              <- The number of items in the array
        ItemNameOrg     <- The array of items
    },

Once this is done, then you can add:
    if (Unattended) {
        UnattendSetActiveDlg( hwnd, <pageid> );
    }
    break;

As the last thing in the code for the page's setactive.
This function does is that it sets the DWL_MSGRESULT based on wether or
not the user should see the page and returns that value also (TRUE -- user
should see the page, FALSE, he should not). Then you should add:

    case WM_SIMULATENEXT:
        PropSheet_PressButton(GetParent(hwnd),PSBTN_NEXT);

to the DlgProc for the page. This means that the code in PSN_WIZNEXT
case will be executed.

You can also use UnattendErrorDlg( hwnd, <pageid> ); in the PSN_WIZNEXT
case if you detect any errors. That will allow unattended operation to try
to clean itself up a bit before control returns to the user for the page.

Note however that as soon as the user hits the next or back button that
control returns to the unattended engine.
*/


//
// Initialization Callbacks
//
// These are used to verify that the entries in the answer file are valid.
//
BOOL
CheckServer(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckComputerName(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckAdminPassword(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckMode(
    struct _UNATTENDANSWER *rec
    );

//
// SetActive Callbacks
//
// When a wizard page receives a PSN_SETACTIVE notification, a callback is used
// to set the controls on that wizard page, based on the values in the answer
// file.
//
BOOL
SetPid(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetSetupMode(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetPentium(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetLastPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetStepsPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

//
// Do not change the order of these unless you know what you are doing.
// These entries must me in the same order as the UNATTENDENTRIES enum.
//

UNATTENDANSWER UnattendAnswerTable[] = {

   { UAE_PROGRAM, FALSE, FALSE, FALSE, 0,
       pwGuiUnattended, pwProgram, pwNull,
       UAT_STRING, NULL },

   { UAE_ARGUMENT, FALSE, FALSE, FALSE, 0,
       pwGuiUnattended, pwArgument, pwNull,
       UAT_STRING, NULL },

   { UAE_TIMEZONE, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwTimeZone, pwTime,
       UAT_STRING, NULL },

   { UAE_FULLNAME, FALSE, TRUE, FALSE, 0,
       pwUserData, pwFullName, NULL,
       UAT_STRING, NULL },

   { UAE_ORGNAME, FALSE, FALSE, FALSE, 0,
       pwUserData, pwOrgName, pwNull,
       UAT_STRING, NULL },

   { UAE_COMPNAME, FALSE, TRUE, FALSE, 0,
       pwUserData, pwCompName, NULL,
       UAT_STRING, CheckComputerName },

   { UAE_ADMINPASS, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwAdminPassword, NULL,
       UAT_STRING, CheckAdminPassword },

   { UAE_PRODID, FALSE, TRUE, FALSE, 0,
       pwUserData, pwProductKey, NULL,
       UAT_STRING, NULL },

   { UAE_MODE, FALSE, TRUE, FALSE, 0,
       pwUnattended, pwMode, pwExpress,
       UAT_STRING, CheckMode },

   { UAE_AUTOLOGON, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwAutoLogon, pwNull,
       UAT_STRING, NULL },

   { UAE_PROFILESDIR, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwProfilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_PROGRAMFILES, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwProgramFilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_COMMONPROGRAMFILES, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwCommonProgramFilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_PROGRAMFILES_X86, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwProgramFilesX86Dir, pwNull,
       UAT_STRING, NULL },

   { UAE_COMMONPROGRAMFILES_X86, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwCommonProgramFilesX86Dir, pwNull,
       UAT_STRING, NULL },


};

UNATTENDITEM ItemSetup[] = {
    { 0, IDC_TYPICAL, IDC_CUSTOM, SetSetupMode, &UnattendAnswerTable[UAE_MODE] }
};

UNATTENDITEM ItemNameOrg[] = {
    { IDT_NAME, 0, 0, NULL, &UnattendAnswerTable[UAE_FULLNAME] },
    { IDT_ORGANIZATION, 0, 0, NULL, &UnattendAnswerTable[UAE_ORGNAME] }
};

UNATTENDITEM ItemPidCd[] = {
    { IDT_EDIT_PID1, 0, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID2, 1, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID3, 2, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID4, 3, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID5, 4, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] }
};

UNATTENDITEM ItemPidOem[] = {
    { IDT_EDIT_PID1, 0, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID2, 1, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID3, 2, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID4, 3, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID5, 4, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] }
};

UNATTENDITEM ItemCompName[] = {
    { IDT_EDIT1, 0, 0, NULL, &UnattendAnswerTable[UAE_COMPNAME] },
    { IDT_EDIT2, 0, 0, NULL, &UnattendAnswerTable[UAE_ADMINPASS] },
    { IDT_EDIT3, 0, 0, NULL, &UnattendAnswerTable[UAE_ADMINPASS] }
};

#ifdef _X86_
UNATTENDITEM ItemPentium[] = {
    { 0, IDC_RADIO_1, IDC_RADIO_2, SetPentium, NULL }
};
#endif

UNATTENDITEM ItemStepsPage[] = {
    { 0, 0, 0, SetStepsPage, NULL }
};

UNATTENDITEM ItemLastPage[] = {
    { 0, 0, 0, SetLastPage, NULL }
};



UNATTENDPAGE UnattendPageTable[] = {
    { IDD_WELCOME, FALSE, FALSE, TRUE, 0, NULL },
    { IDD_PREPARING, FALSE, FALSE, FALSE, 0, NULL },
    { IDD_WELCOMEBUTTONS, FALSE, FALSE, FALSE, 1, ItemSetup },
    { IDD_REGIONAL_SETTINGS, FALSE, FALSE, FALSE, 0, NULL },
    { IDD_NAMEORG, FALSE, FALSE, FALSE, 2, ItemNameOrg },
    { IDD_PID_CD, FALSE, FALSE, FALSE, 5, ItemPidCd },
    { IDD_PID_OEM, FALSE, FALSE, FALSE, 5, ItemPidOem },
    { IDD_COMPUTERNAME, FALSE, FALSE, FALSE, 3, ItemCompName },
#ifdef DOLOCALUSER
    { IDD_USERACCOUNT, FALSE, FALSE, FALSE, 0, NULL },
#endif
#ifdef _X86_
    { IDD_PENTIUM, FALSE, FALSE, FALSE, 1, ItemPentium },
#endif
    { IDD_OPTIONS, FALSE, FALSE, FALSE, 0, NULL },
    { IDD_STEPS1, FALSE, FALSE, TRUE, 1, ItemStepsPage },
    { IDD_LAST_WIZARD_PAGE, FALSE, FALSE, TRUE, 1, ItemLastPage }
};


UNATTENDWIZARD UnattendWizard = {
    FALSE, FALSE, TRUE,
    sizeof(UnattendPageTable)/sizeof(UnattendPageTable[0]),
    UnattendPageTable,
    sizeof(UnattendAnswerTable)/sizeof(UnattendAnswerTable[0]),
    UnattendAnswerTable
};

//
// Global Pointer to the Answer file
//
WCHAR AnswerFile[MAX_PATH] = TEXT("");


BOOL
GetAnswerFileSetting (
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR Buffer,
    IN      UINT BufferSize
    )

/*++

Routine Description:

  GetAnswerFileSetting uses the private profile APIs to obtain an answer file
  string from %systemroot%\system32\$winnt$.inf. It also performs %% removal,
  since $winnt$.inf is an INF, not an INI.

Arguments:

  Section - Specifies the section to retreive the value from (such as
            GuiUnattended)

  Key - Specifies the key within the section (such as TimeZone)

  Buffer - Receives the value

  BufferSize - Specifies the size, in WCHARs, of Buffer.

Return Value:

  TRUE if the setting was retrived, FALSE otherwise.

--*/

{
    PCWSTR src;
    PWSTR dest;
    WCHAR testBuf[3];

    MYASSERT (BufferSize > 2);

    if (!AnswerFile[0]) {
        GetSystemDirectory (AnswerFile, MAX_PATH);
        pSetupConcatenatePaths (AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        SetEnvironmentVariable (L"UnattendFile", AnswerFile);
    }

    if (!GetPrivateProfileString (
            Section,
            Key,
            L"",
            Buffer,
            BufferSize,
            AnswerFile
            )) {
        //
        // String not present or is empty -- try again with a different
        // default. If the string is empty, we'll get back 0. If the key does
        // not exist, we'll get back 1.
        //

        MYASSERT (BufferSize == 0 || *Buffer == 0);

        return 0 == GetPrivateProfileString (
                        Section,
                        Key,
                        L"X",
                        testBuf,
                        3,
                        AnswerFile
                        );
    }

    //
    // We obtained the string. Now remove pairs of %.
    //

    if (BufferSize) {
        src = Buffer;
        dest = Buffer;

        while (*src) {
            if (src[0] == L'%' && src[1] == L'%') {
                src++;
            }

            *dest++ = *src++;
        }

        *dest = 0;
    }

    return TRUE;
}

BOOL
UnattendFindAnswer(
    IN OUT PUNATTENDANSWER ans
    )

/*++

Routine Description:

    Fills in the response from the unattend file to the key 'id' into
    the structure pointed to by 'ans'. If a non-null 'def' is specified
    and no answer exists in the file, 'def' is parsed as the answer.

Arguments:

    ans - pointer to the structure information for the answer

Return Value:

    TRUE - 'ans' structure has been filled in with an answer
    FALSE - otherwise

--*/

{
    WCHAR Buf[MAX_BUF];

    MYASSERT(AnswerFile[0]);

    if (!GetAnswerFileSetting (ans->Section, ans->Key, Buf, MAX_BUF)) {
        //
        // Setting does not exist. If there is a default, use it.
        //

        if (ans->DefaultAnswer) {
            lstrcpyn (Buf, ans->DefaultAnswer, MAX_BUF);
        } else {
            ans->Present = FALSE;
            return (!ans->Required);
        }
    }

    //
    // Assume empty string means the string does not exist. This is how the
    // original implementation worked.
    //

    if (*Buf == 0) {
        ans->Present = FALSE;
        return !ans->Required;
    }

    //
    // Found a value, or using the default
    //

    ans->Present = TRUE;

    //
    // Copy the data into the answer structure. This requires
    // switching on the type of data expected and converting it to
    // the required format. In the case of strings, it also means
    // allocating a pool of memory for the result
    //
    switch(ans->Type) {

    case UAT_STRING:
        //
        // We allocate some memory, so we must free it later
        //
        ans->Answer.String = pSetupDuplicateString(Buf);
        if(!ans->Answer.String) {
            pSetupOutOfMemory(GetActiveWindow());
            return(FALSE);
        }
        break;

    case UAT_LONGINT:
        //
        // Simply convert the number from string to long
        //
        ans->Answer.Num = _wtol(Buf);
        break;

    case UAT_BOOLEAN:
        //
        // check to see if the answer is yes
        //
        ans->Answer.Bool = ((Buf[0] == L'y') || (Buf[0] == L'Y'));
        break;

    default:
        break;
    }

    //
    // Execute any callbacks if present
    //
    if(ans->pfnCheckValid) {
        if(!ans->pfnCheckValid(ans)) {
            ans->Present = FALSE;
            ans->ParseErrors = TRUE;
            return(!ans->Required);
        }
    }

    //
    // Success.
    //
    return(TRUE);
}


VOID
UnattendInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize unattended mode support by loading all answers
    from the unattend file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    WCHAR   p[MAX_BUF];
    DWORD   Result;
    BOOL    Success = TRUE;
    UINT    i;


    //
    // If we haven't calculated the path to $winnt$.sif yet, do so now
    //
    if(!AnswerFile[0]) {
        GetSystemDirectory(AnswerFile,MAX_PATH);
        pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

        SetEnvironmentVariable( L"UnattendFile", AnswerFile );
    }

    if( MiniSetup ) {
        WCHAR MyAnswerFile[MAX_PATH];

        //
        // First, see if there's a sysprep.inf on the a:\ drive.  If so, use it.
        //
        lstrcpy( MyAnswerFile, TEXT("a:\\sysprep.inf") );
        if( !FileExists( MyAnswerFile, NULL ) ) {

            //
            // Nope.  Check for a \sysprep\sysprep.inf.
            //

            Result = GetWindowsDirectory( MyAnswerFile, MAX_PATH );
            if( Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            MyAnswerFile[3] = 0;
            pSetupConcatenatePaths( MyAnswerFile, TEXT("sysprep\\sysprep.inf"), MAX_PATH, NULL );
        }

        //
        // We've assumed that we're running unattended, but
        // network setup hates it when we pretend to be unattended, but
        // don't provide an answer file.  So if there is no answer file,
        // quit the facade.
        //
        Unattended = FileExists(MyAnswerFile, NULL);
        Preinstall = Unattended;

        //
        // Now either replace or delete the original unattend file.
        // We do this so that we don't erroneously pickup unattend
        // entries out of the old answer file.  However, if OOBE is
        // running, we still need the old answerfile.
        //
        if( Unattended ) {
            CopyFile( MyAnswerFile, AnswerFile, FALSE );
        } else if ( !OobeSetup ) {
            DeleteFile( AnswerFile );
        }
    }

    //
    // We need to make the product id an alias for the product key.
    //
    if ( GetPrivateProfileString(
        pwUserData, pwProdId, pwNull, p, MAX_BUF, AnswerFile)
        ) {

        if ( !WritePrivateProfileString(
            pwUserData, pwProductKey, p, AnswerFile ) ) {

            SetupDebugPrint( L"SETUP: WritePrivateProfileString failed to write the product key in UnattendInitialize()." );
        }
    }

    //
    // Now get all the answers.
    //
    MYASSERT(!UnattendWizard.Initialized);
    UnattendWizard.Initialized = TRUE;
    for(i=0; i<UnattendWizard.AnswerCount; i++) {

        //
        // Check to make sure that the table order hasn't changed
        // and load the appropriate answer
        //
        MYASSERT((UINT)UnattendWizard.Answer[i].AnswerId == i);
        Success &= UnattendFindAnswer(&UnattendWizard.Answer[i]);
    }

    UnattendWizard.ShowWizard = !Success;
}


LRESULT
SendDlgMessage (
    HWND hdlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT OldResult;
    LRESULT Result;

    OldResult = GetWindowLongPtr (hdlg, DWLP_MSGRESULT);
    SendMessage (hdlg, Message, wParam, lParam);

    Result = GetWindowLongPtr (hdlg, DWLP_MSGRESULT);
    SetWindowLongPtr (hdlg, DWLP_MSGRESULT, OldResult);

    return Result;
}


BOOL
ReturnDlgResult (
    HWND hdlg,
    LRESULT Result
    )
{
    SetWindowLongPtr (hdlg, DWLP_MSGRESULT, Result);
    return TRUE;
}

VOID
UnattendAdvanceIfValid (
    IN HWND hwnd
    )
{
    LRESULT ValidationState;

    //
    // Validate wizard page data with UI
    //

    ValidationState = SendDlgMessage (hwnd, WMX_VALIDATE, 0, TRUE);

    if (ValidationState == VALIDATE_DATA_INVALID) {
        SetWindowLongPtr (hwnd, DWLP_MSGRESULT, WIZARD_NEXT_DISALLOWED);
    } else {
        SetWindowLongPtr (hwnd, DWLP_MSGRESULT, WIZARD_NEXT_OK);
    }
}


BOOL
UnattendSetActiveDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    )

/*++


Routine Description:

    Initialize unattended mode support by loading all answers
    from the unattend file.

Arguments:

    None.

Return Value:

    TRUE - Page will become active
    FALSE - Page will not become active

--*/

{
    PUNATTENDPAGE pPage;
    PUNATTENDITEM pItem;
    BOOL success;
    UINT i,j;

    MYASSERT(UnattendWizard.Initialized);

    for(i=0; i<UnattendWizard.PageCount; i++) {

        if(controlid == UnattendWizard.Page[i].PageId) {
            //
            // Found Matching Page entry
            // Check to see if we have already loaded the page
            //
            pPage = & (UnattendWizard.Page[i]);
            if(!pPage->LoadPage) {
                //
                // Set the flags that load and display the page and
                // the flag that controls wether or not to stop on this page
                //
                pPage->LoadPage = TRUE;
                pPage->ShowPage = (UnattendMode == UAM_PROVIDEDEFAULT);

                for(j=0;j<pPage->ItemCount;j++) {

                    pItem = &(pPage->Item[j]);

                    if(pItem->pfnSetActive) {
                        //
                        // If the item has a call back function then
                        // execute that function, otherwise try to load
                        // the answer into the appropriate message box
                        //
                        success = pItem->pfnSetActive(hwnd,0,pItem);
                        pPage->ShowPage |= !success;

                    } else if (!pItem->Item->Present) {
                        //
                        // The answer for this item is missing.
                        //
                        pPage->ShowPage |= pItem->Item->Required;

                    } else {
                        //
                        // Switch to set the text of the item on the screen
                        //
                        switch(pItem->Item->Type) {

                        case UAT_STRING:
                            SetDlgItemText(hwnd,pItem->ControlId,pItem->Item->Answer.String);
                            break;

                        case UAT_LONGINT:
                        case UAT_BOOLEAN:
                        case UAT_NONE:
                        default:
                            break;

                        }

                        if( UnattendMode == UAM_PROVIDEDEFAULT ||
                            UnattendMode == UAM_DEFAULTHIDE) {

                            EnableWindow(GetDlgItem(hwnd,pItem->ControlId), TRUE);
                        } else {
                            EnableWindow(GetDlgItem(hwnd,pItem->ControlId),FALSE);
                        }
                    } // if (pItem
                } // for(j

                //
                // Allow the page to become activated
                //
                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);

                if(!pPage->ShowPage) {
                    //
                    // Perform validation, skip activation if validation succeeds.
                    //

                    if (SendDlgMessage (hwnd, WMX_VALIDATE, 0, 0) == 1) {
                        SetWindowLongPtr(hwnd,DWLP_MSGRESULT,-1);
                        return FALSE;
                    }

                    //
                    // Simulate the pressing of the next button, which causes the
                    // wizard page proc to evaluate the data in its controls, and
                    // throw up popups to the user.
                    //
                    PostMessage(hwnd,WM_SIMULATENEXT,0,0);

                } else if (!pPage->NeverSkip) {
                    //
                    // Pages which are marked as NeverSkip should not
                    // cause the unattended status to be considered
                    // unsuccessful.
                    //
                    // We can't skip this page so mark the init as
                    // unsuccessful.  If this is the first error in a fully
                    // unattended setup, notify the user.
                    //
                    if(UnattendMode == UAM_FULLUNATTENDED) {

                        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_BAD_UNATTEND_PARAM,
                            pItem->Item->Key,
                            pItem->Item->Section,
                            NULL,NULL);

                        if(UnattendWizard.Successful) {
                            MessageBoxFromMessage(
                                MainWindowHandle,
                                MSG_FULLUNATTENDED_ERROR,
                                NULL,
                                IDS_ERROR,
                                MB_ICONERROR | MB_OK | MB_SYSTEMMODAL
                                );
                        }
                    }
                    UnattendWizard.Successful = FALSE;
                }
                return(TRUE);

            } else {
                //
                // The Page has already been loaded, so we don't do that again
                // If we are ShowPage is FALSE, then we don't show the page to
                // the user, otherwise we do.
                //
                if(!pPage->ShowPage && !pPage->NeverSkip) {
                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,-1);
                } else {
                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);
                }

                return(pPage->ShowPage);
            }
        }
    }
    //
    // We didn't find a matching id, stop at the page that called us.
    //
    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);
    return(TRUE);
}


BOOL
UnattendErrorDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    )

/*++

Routine Description:

    Called when an error occurs in a DLG. Enables all windows
    in the dialog and turns off the successful flag for the
    unattend wizard

Arguments:

Return Value:

    Boolean value indicating outcome.

--*/

{
    PUNATTENDPAGE pPage;
    PUNATTENDITEM pItem;
    BOOL success;
    BOOL stop;
    UINT i,j;

    MYASSERT(UnattendWizard.Initialized);

    for(i=0; i<UnattendWizard.PageCount; i++) {

        if(controlid == UnattendWizard.Page[i].PageId) {
            //
            // Found Matching Page entry
            //
            pPage = &UnattendWizard.Page[i];

            if(!pPage->LoadPage) {
                //
                // The Page hasn't been loaded, so it isn't correct
                //
                continue;
            }

            //
            // Always display the page from now on
            //
            pPage->ShowPage = TRUE;

            //
            // Enable all the items
            //
            for (j=0;j<pPage->ItemCount;j++) {
                pItem = &(pPage->Item[j]);
                if(pItem->pfnSetActive) {
                    //
                    // if this is present then we assume that the
                    // callback handled itself properly already
                    //
                    continue;
                }
                EnableWindow( GetDlgItem(hwnd,pItem->ControlId), TRUE);
            }
        }
    }

    UnattendWizard.Successful = FALSE;
    return(TRUE);

}


PWSTR
UnattendFetchString(
   IN UNATTENDENTRIES entry
   )

/*++

Routine Description:

    Finds the string which corresponds to 'entry' in the answer
    table and returns a pointer to a copy of that string

Arguments:

    entry - which answer do you want?

Return Value:

    NULL - if any errors occur
    string - if a normal string

    Note: if the answer is an int or a bool or some other type,
    the behavior of this function is undefined (for now it will
    return NULL -- in the future it might make sense to turn these
    into strings...)

--*/

{
    MYASSERT(UnattendWizard.Initialized);

    //
    // Sanity check to make sure that the order of the answers is
    // what we expect.
    //
    MYASSERT(UnattendWizard.Answer[entry].AnswerId == entry);

    if(!UnattendWizard.Answer[entry].Present
    || (UnattendWizard.Answer[entry].Type != UAT_STRING)) {
        //
        // There is no string to return
        //
        return NULL;
    }

    return(pSetupDuplicateString(UnattendWizard.Answer[entry].Answer.String));
}


BOOL
CheckServer(
    struct _UNATTENDANSWER *rec
    )

/*++

Routine Description:

    Callback to check that the string used for the server type is valid

Arguments:

Return Value:

    TRUE - Answer is valid
    FALSE - Answer is invalid

--*/

{
    MYASSERT(rec);

    //
    // Check to make sure that we have a string
    //
    if(rec->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Check to see if we have one of the valid strings
    //
    if(lstrcmpi(rec->Answer.String,WINNT_A_LANMANNT)
    && lstrcmpi(rec->Answer.String,WINNT_A_SERVERNT)) {

        //
        // We don't have a valid string, so we can clean up the answer
        //
        MyFree(rec->Answer.String);
        rec->Present = FALSE;
        rec->ParseErrors = TRUE;

        return(FALSE);
    }

    return(TRUE);

}


BOOL
CheckComputerName(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Uppercase the computer name that comes out of the unattended file.

Arguments:

Returns:

    Always TRUE.

--*/

{
    if((rec->Type == UAT_STRING) && rec->Answer.String) {
        CharUpper(rec->Answer.String);
    }

    return(TRUE);
}


BOOL
CheckAdminPassword(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Check for the "NoChange" keyword.

Arguments:

Returns:

    Always TRUE.

--*/

{
    //Ignore the check for 'No Change' in the encrypted password case.

    if( !IsEncryptedAdminPasswordPresent() ){


        if((rec->Type == UAT_STRING) && rec->Answer.String &&
            !lstrcmpi(rec->Answer.String, L"NoChange")) {

            DontChangeAdminPassword = TRUE;
            rec->Answer.String[0] = (WCHAR)'\0';
        }
    }




    return(TRUE);
}


BOOL
CheckMode(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Callback to check that the string used for the setup type is valid

Arguments:

Returns:

    TRUE - Answer is valid
    FALSE - Answer is invalid

--*/

{
    MYASSERT(rec);

    //
    // Check to make sure that we have a string
    //
    if(rec->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Check to see if the string is the custom or express one
    //
    if(lstrcmpi(rec->Answer.String,WINNT_A_CUSTOM)
    && lstrcmpi(rec->Answer.String,WINNT_A_EXPRESS)) {
        //
        // Free the old string and allocate a new one
        //
        MyFree(rec->Answer.String);
        rec->Answer.String = pSetupDuplicateString(WINNT_A_EXPRESS);
        rec->ParseErrors = TRUE;
    }

    return(TRUE);
}


BOOL
SetPid(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )

/*++

Routine Description:

    Callback for both the OEM and CD dialog boxes that split the
    product string into the proper location boxes.

Arguments:

Returns:

    TRUE - success
    FALSE - failure

--*/

{
    WCHAR *ptr;
    UINT length;
    WCHAR Buf[MAX_BUF];
    WCHAR szPid[MAX_BUF];

    MYASSERT(item);
    MYASSERT(item->Item);

    //
    // Check to see if we found the pid and make sure that we have a string
    //
    if(!item->Item->Present || (item->Item->Type != UAT_STRING)) {
        return(FALSE);
    }

    //
    // oem and cd installs are both the same case for pid3.0
    //
    lstrcpyn(szPid, item->Item->Answer.String, MAX_BUF);
    szPid[MAX_BUF - 1] = L'\0';
    if ( ( lstrlen( szPid ) != (4 + MAX_PID30_EDIT*5) ) ||
        ( szPid[5]  != (WCHAR)L'-' ) ||
        ( szPid[11] != (WCHAR)L'-' ) ||
        ( szPid[17] != (WCHAR)L'-' ) ||
        ( szPid[23] != (WCHAR)L'-' )
      ) {
        MyFree(item->Item->Answer.String);
        item->Item->Present = FALSE;
        return(FALSE);
    }

    if (item->Reserved1 > 5) {
        MyFree(item->Item->Answer.String);
        item->Item->Present = FALSE;
        return(FALSE);
    }

    ptr = &szPid[item->Reserved1*(MAX_PID30_EDIT+1)];
    lstrcpyn(Pid30Text[item->Reserved1], ptr, MAX_PID30_EDIT+1 );
    Pid30Text[item->Reserved1][MAX_PID30_EDIT] = (WCHAR)L'\0';

    //
    // Copy the string to a buffer, set the dialog text and return success.
    //
    lstrcpyn(Buf,ptr,MAX_PID30_EDIT+1);
    SetDlgItemText(hwnd,item->ControlId,Buf);
    return(TRUE);
}


BOOL
SetSetupMode(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{
    MYASSERT(item);
    MYASSERT(item->Item);

    //
    // Make sure that we have a string
    //
    if(item->Item->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Did we get a parse error? if so display something that the user can
    // see so that the problem gets corrected in the future
    //
    if(item->Item->ParseErrors) {
        PostMessage(hwnd,WM_IAMVISIBLE,0,0);
    }

    SetupMode = lstrcmpi(item->Item->Answer.String,WINNT_A_CUSTOM)
              ? SETUPMODE_TYPICAL
              : SETUPMODE_CUSTOM;

    return(!item->Item->ParseErrors);
}


#ifdef _X86_
BOOL
SetPentium(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{
    //
    // Do nothing. The dialog procedure takes care of all the logic.
    // See i386\fpu.c.
    //
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(contextinfo);
    UNREFERENCED_PARAMETER(item);
    return(TRUE);
}
#endif


BOOL
SetStepsPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{

    return(TRUE);
}


BOOL
SetLastPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\sif.c ===
#include "setupp.h"
#pragma hdrstop

//
// IMPORTANT: keep the following strings ENTIRELY in LOWER CASE
// Failure to do so will result in much grief and pain.
//

// Section Headings
const WCHAR pwGuiUnattended[]   = WINNT_GUIUNATTENDED;
const WCHAR pwUserData[]        = WINNT_USERDATA;
const WCHAR pwUnattended[]      = WINNT_UNATTENDED;
const WCHAR pwAccessibility[]   = WINNT_ACCESSIBILITY;
const WCHAR pwGuiRunOnce[]      = WINNT_GUIRUNONCE;
const WCHAR pwCompatibility[]   = WINNT_COMPATIBILITYINFSECTION;

// Key Headings
const WCHAR pwProgram[]         = WINNT_G_DETACHED;
const WCHAR pwArgument[]        = WINNT_G_ARGUMENTS;
const WCHAR pwServer[]          = WINNT_G_SERVERTYPE;
const WCHAR pwTimeZone[]        = WINNT_G_TIMEZONE;
const WCHAR pwAutoLogon[]       = WINNT_US_AUTOLOGON;
const WCHAR pwProfilesDir[]     = WINNT_US_PROFILESDIR;
const WCHAR pwProgramFilesDir[]             = WINNT_U_PROGRAMFILESDIR;
const WCHAR pwCommonProgramFilesDir[]       = WINNT_U_COMMONPROGRAMFILESDIR;
const WCHAR pwProgramFilesX86Dir[]          = WINNT_U_PROGRAMFILESDIR_X86;
const WCHAR pwCommonProgramFilesX86Dir[]    = WINNT_U_COMMONPROGRAMFILESDIR_X86;
const WCHAR pwWaitForReboot[]   = WINNT_U_WAITFORREBOOT;
const WCHAR pwFullName[]        = WINNT_US_FULLNAME;
const WCHAR pwOrgName[]         = WINNT_US_ORGNAME;
const WCHAR pwCompName[]        = WINNT_US_COMPNAME;
const WCHAR pwAdminPassword[]   = WINNT_US_ADMINPASS;
const WCHAR pwProdId[]          = WINNT_US_PRODUCTID;
const WCHAR pwProductKey[]      = WINNT_US_PRODUCTKEY;
const WCHAR pwMode[]            = WINNT_U_METHOD;
const WCHAR pwUnattendMode[]    = WINNT_U_UNATTENDMODE;
const WCHAR pwAccMagnifier[]    = WINNT_D_ACC_MAGNIFIER;
const WCHAR pwAccReader[]       = WINNT_D_ACC_READER;
const WCHAR pwAccKeyboard[]     = WINNT_D_ACC_KEYBOARD;

// Default Headings
const WCHAR pwNull[]            = WINNT_A_NULL;
const WCHAR pwExpress[]         = WINNT_A_EXPRESS;
const WCHAR pwTime[]            = L"(GMT-08:00) Pacific Time (US & Canada); Tijuana";

// These are used to read the parameters from textmode
const WCHAR pwProduct[]         = WINNT_D_PRODUCT;
const WCHAR pwMsDos[]           = WINNT_D_MSDOS;
const WCHAR pwWin31Upgrade[]    = WINNT_D_WIN31UPGRADE;
const WCHAR pwWin95Upgrade[]    = WINNT_D_WIN95UPGRADE;
const WCHAR pwBackupImage[]     = WINNT_D_BACKUP_IMAGE;
const WCHAR pwServerUpgrade[]   = WINNT_D_SERVERUPGRADE;
const WCHAR pwNtUpgrade[]       = WINNT_D_NTUPGRADE;
const WCHAR pwBootPath[]        = WINNT_D_BOOTPATH;
const WCHAR pwLanmanNt[]        = WINNT_A_LANMANNT;
const WCHAR pwServerNt[]        = WINNT_A_SERVERNT;
const WCHAR pwWinNt[]           = WINNT_A_WINNT;
const WCHAR pwNt[]              = WINNT_A_NT;
const WCHAR pwInstall[]         = WINNT_D_INSTALL;
const WCHAR pwUnattendSwitch[]  = WINNT_D_UNATTEND_SWITCH;
const WCHAR pwRunOobe[]         = WINNT_D_RUNOOBE;
const WCHAR pwReferenceMachine[] = WINNT_D_REFERENCE_MACHINE;
const WCHAR pwOptionalDirs[]    = WINNT_S_OPTIONALDIRS;
const WCHAR pwUXC[]             = WINNT_S_USEREXECUTE;
const WCHAR pwSkipMissing[]     = WINNT_S_SKIPMISSING;
const WCHAR pwIncludeCatalog[]  = WINNT_S_INCLUDECATALOG;
const WCHAR pwDrvSignPol[]      = WINNT_S_DRVSIGNPOL;
const WCHAR pwNonDrvSignPol[]   = WINNT_S_NONDRVSIGNPOL;
const WCHAR pwYes[]             = WINNT_A_YES;
const WCHAR pwNo[]              = WINNT_A_NO;
const WCHAR pwOne[]             = WINNT_A_ONE;
const WCHAR pwZero[]            = WINNT_A_ZERO;
const WCHAR pwIgnore[]          = WINNT_A_IGNORE;
const WCHAR pwWarn[]            = WINNT_A_WARN;
const WCHAR pwBlock[]           = WINNT_A_BLOCK;
const WCHAR pwData[]            = WINNT_DATA;
const WCHAR pwSetupParams[]     = WINNT_SETUPPARAMS;
const WCHAR pwSrcType[]         = WINNT_D_SRCTYPE;
const WCHAR pwSrcDir[]          = WINNT_D_SOURCEPATH;
const WCHAR pwCurrentDir[]      = WINNT_D_CWD;
const WCHAR pwDosDir[]          = WINNT_D_DOSPATH;
const WCHAR pwGuiAttended[]     = WINNT_A_GUIATTENDED;
const WCHAR pwProvideDefault[]  = WINNT_A_PROVIDEDEFAULT;
const WCHAR pwDefaultHide[]     = WINNT_A_DEFAULTHIDE;
const WCHAR pwReadOnly[]        = WINNT_A_READONLY;
const WCHAR pwFullUnattended[]  = WINNT_A_FULLUNATTENDED;
const WCHAR pwEulaDone[]        = WINNT_D_EULADONE;

// These are used as string constants throughout
const WCHAR pwArcType[]         = L"ARC";
const WCHAR pwDosType[]         = L"DOS";
const WCHAR pwUncType[]         = L"UNC";
const WCHAR pwNtType[]          = L"NT";
const WCHAR pwArcPrefix[]       = L"\\ArcName\\";
const WCHAR pwNtPrefix[]        = L"\\Device\\";
const WCHAR pwLocalSource[]     = L"\\$WIN_NT$.~LS";

// This is used when an exception occurs in gui-mode
const WCHAR pwException[]        = WINNT_D_UNHANDLEDEXCEPTION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\syssetup.c ===
#include "setupp.h"
#include <passrec.h>
#include <wow64reg.h>
#pragma hdrstop

#include <wininet.h>    // for INTERNET_MAX_URL_LENGTH

//
// These three functions are imported from setupasr.c, the module containing
// the source for the Automatic System Recovery (ASR) functions.
//

//  Returns TRUE if ASR is enabled.  Otherwise, FALSE is returned.
extern BOOL
AsrIsEnabled(VOID);

// Initializes ASR data.  This is called iff the -asr switch is detected.
extern VOID
AsrInitialize(VOID);

// Launches recovery applications specified in the asr state file.
extern VOID
AsrExecuteRecoveryApps(VOID);

// Checks the system to see if we are running on the personal version of the
// operating system.
extern BOOL
AsrpIsRunningOnPersonalSKU(VOID);

//
// Handle for watching changes to the user's profile directory and the current user hive.
//
PVOID   WatchHandle;

//
// Handle to heap so we can periodically validate it.
//
#if DBG
HANDLE g_hSysSetupHeap = NULL;
#endif

//
// Product type: workstation, standalone server, dc server.
//
UINT ProductType;

//
// Set to TRUE if this is an ASR quick test
//
BOOL AsrQuickTest = FALSE;

//
// service pack dll module handle
//
HMODULE hModSvcPack;
PSVCPACKCALLBACKROUTINE pSvcPackCallbackRoutine;

//
// Boolean value indicating whether this installation
// originated with winnt/winnt32.
// And, original source path, saved away for us by winnt/winnt32.
//
BOOL WinntBased;
PCWSTR OriginalSourcePath;

//
// Boolean value indicating whether we're upgrading.
//
BOOL Upgrade;
BOOL Win31Upgrade;
BOOL Win95Upgrade = FALSE;
BOOL UninstallEnabled = FALSE;

//
// Boolean value indicating whether we're in Setup or in appwiz.
//
BOOL IsSetup = FALSE;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
BOOL MiniSetup = FALSE;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup
// AND we did PnP re-enumeration.
//
BOOL PnPReEnumeration = FALSE;

//
// Boolean value indicating whether we're doing a remote boot setup.
//
BOOL RemoteBootSetup = FALSE;

//
// During remote boot setup, BaseCopyStyle will be set to
// SP_COPY_SOURCE_SIS_MASTER to indicate that single-instance
// store links should be created instead of copying files.
//

ULONG BaseCopyStyle = 0;

//
// Support for SMS.
//
typedef DWORD (*SMSPROC) (char *, char*, char*, char*, char *, char *, char *, BOOL);
HMODULE SMSHandle = NULL;
SMSPROC InstallStatusMIF = NULL;

//
// Window handle of topmost setup window.
//
HWND SetupWindowHandle;
HWND MainWindowHandle;
HWND WizardHandle;

//
// Source path for installation.
//
WCHAR SourcePath[MAX_PATH];

//
// System setup inf.
//
HINF SyssetupInf;

//
// Save the unhandled exception filter so we can restore it when we're done.
//
LPTOP_LEVEL_EXCEPTION_FILTER    SavedExceptionFilter = NULL;

//
// Unique Id for the main Setup thread.  If any other thread has an unhandled
// exception, we just log an error and try to keep going.
//
DWORD MainThreadId;

//
// The original locale we started setup under.  If the locale changes during
// gui-setup (via the IDD_REGIONAL_SETTINGS dialog), then new threads will
// startup with the updated LCID, which may end up confusing any locale-centric
// code.  An example of this would be setupapi's string table implementation,
// which does sorting by locale.
//
LCID  OriginalInstallLocale;


//
// Flag indicating whether this is an unattended mode install/upgrade, and
// if so, what mode to run in.
// Also a flag indicating whether this is a preinstallation.
// And a flag indicating whether we are supposed to allow rollback
// once setup has been completed.
// And a flag that tells us whether to skip the eula in the preinstall case.
// And a flag that tells us whether any accessibility utilities are in use.
//
BOOL Unattended;
UNATTENDMODE UnattendMode;
BOOL Preinstall;
BOOL AllowRollback;
BOOL OemSkipEula;
BOOL AccessibleSetup;
BOOL Magnifier;
BOOL ScreenReader;
BOOL OnScreenKeyboard;
BOOL EulaComplete = FALSE;

//
// Indicates whether we need to wait at the installation
// end in unattended mode
//
BOOL UnattendWaitForReboot = FALSE;

//
// We can get into unattended mode in several ways, so we also check whether
// the "/unattend" switch was explicitly specified.
//
BOOL UnattendSwitch;

//
// Flag indicating whether we should run OOBE after Setup completes.  Note
// that if it is FALSE, OOBE may still be run, based on other criteria.
//
BOOL ForceRunOobe;

#ifdef PRERELEASE
//
// Test hooks
//

INT g_TestHook;
#endif

//
// Flag indicating whether we are in a special mode for OEM's to use on the
// factory floor.
//
BOOL ReferenceMachine;

//
// Flag indicating whether a volume was extended or not using
// ExtendOemPartition
//
BOOL PartitionExtended = FALSE;

//
// Flag indicating if the eula was already shown during the textmode setup phase
//
BOOL TextmodeEula = FALSE;

//
// Flag indicating whether to skip missing files.
//
BOOL SkipMissingFiles;

//
// Catalog file to include (facilitates easy testing)
//

PWSTR IncludeCatalog;

//
// User command to execute, if any.
//
PWSTR UserExecuteCmd;

//
// String id of the string to be used for titles -- "Windows NT Setup"
//
UINT SetupTitleStringId;

//
// Strings used with date/timezone applet
//
PCWSTR DateTimeCpl = L"timedate.cpl";
PCWSTR DateTimeParam = L"/firstboot";
PCWSTR UnattendDateTimeParam = L"/z ";

//
// Registry Constants
//
#define REGSTR_PATH_SYSPREP                 _T("Software\\Microsoft\\Sysprep")
#define REGSTR_VAL_SIDGENHISTORY            _T("SidsGeneratedHistory")
#define SETUP_KEY_STR                       TEXT("SYSTEM\\Setup")
#define SETUP_IN_PROGRESS_STR               TEXT("SystemSetupInProgress")
#define REGSTR_PATH_SERVICES_MOUNTMGR       _T("System\\CurrentControlSet\\Services\\MountMgr")
#define REGSTR_VAL_NOAUTOMOUNT              _T("NoAutoMount")

//
// Global structure that contains information that will be used
// by net setup. We pass a pointer to this structure when we call
// NetSetupRequestWizardPages, then fill it in before we call into
// the net setup wizard.
//
INTERNAL_SETUP_DATA InternalSetupData;

//
// In the initial install case, we time how long the wizard takes
// to help randomize the sid we generate.
//
DWORD PreWizardTickCount;

//
// Global structure that contains callback routines and data needed by
// the Setuplog routines.
//
SETUPLOG_CONTEXT    SetuplogContext;

//
// Did we log an error during SfcInitProt()?
//
BOOL    SfcErrorOccurred = FALSE;

//
// List of drivers that remote boot requires to be boot drivers.
// driver's name should always be <= 8 characters.
//
const static PCWSTR RemoteBootDrivers[] = { L"mrxsmb", L"netbt", L"rdbss", L"tcpip", L"ipsec" };

//
// List of functions for the billboard background
//
typedef BOOL (CALLBACK* SETSTEP)(int);
typedef HWND (CALLBACK* GETBBHWND)(void);
typedef BOOL (WINAPI* INITBILLBOARD)(HWND , LPCTSTR, DWORD);
typedef BOOL (WINAPI* TERMBILLBOARD)();

HINSTANCE hinstBB = NULL;
// End billboards

VOID
CallNetworkSetupBack(
    IN PCSTR ProcName
    );


VOID
RemoveMSKeyboardPtrPropSheet (
    VOID
    );

VOID
FixWordPadReg (
    VOID
    );

VOID
ProcessRegistryFiles(
    IN  HWND    Billboard
    );

VOID
SetStartTypeForRemoteBootDrivers(
    VOID
    );

BOOL
RunMigrationDlls (
    VOID
    );

BOOL
RunSetupPrograms(
    IN PVOID InfHandle,
    PWSTR SectionName
    );

VOID
GetUnattendRunOnceAndSetRegistry(
    VOID
    );

VOID
ExecuteUserCommand (
    HWND hProgress
    );

BOOL
MigrateExceptionPackages(
    IN HWND hProgress,
    IN DWORD StartAtPercent,
    IN DWORD StopAtPercent
    );

VOID
RemoveRestartability (
    HWND hProgress
    );

PCTSTR
pGenerateRandomPassword (
    VOID
    );

DWORD GetProductFlavor();

VOID
CopyOemProgramFilesDir(
    VOID
    );

VOID
CopyOemDocumentsDir(
    VOID
    );

BOOL
UpdateServerProfileDirectory(
    VOID
    );

BOOL
IsSBSSKU(
    VOID
    )
/*++

Routine Description:

    Determines if this is a Small Business Server

Arguments:

    none

Return value:

    TRUE if SBS SKU

--*/
{
    OSVERSIONINFOEX osver;
    osver.dwOSVersionInfoSize = sizeof(osver);
    return GetVersionEx((LPOSVERSIONINFO) &osver) && (osver.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED) != 0;
}


VOID
SendSMSMessage(
    IN UINT MessageId,
    IN BOOL Status
    )

/*++

Routine Description:

    If setup was initiated by SMS, then report our status.

Arguments:

    MessageId - supplies the id for the message in the message table.

    Status - TRUE = "Success" or FALSE = "Failed"

Return Value:

    None.

--*/

{
    PWSTR   UnicodeBuffer;
    PSTR    AnsiBuffer;

    if(InstallStatusMIF) {
        if( UnicodeBuffer = RetrieveAndFormatMessageV( NULL, MessageId, NULL )) {
            if(AnsiBuffer = pSetupUnicodeToAnsi (UnicodeBuffer)) {

                InstallStatusMIF(
                    "setupinf",
                    "Microsoft",
                    "Windows NT",
                    "5.0",
                    "",
                    "",
                    AnsiBuffer,
                    Status
                    );

                MyFree (AnsiBuffer);
            }

            MyFree( UnicodeBuffer );
        }
    }
}

VOID
BrandIE(
    )
{
    if( Unattended && !Upgrade && !MiniSetup ) {

        typedef     BOOL (*BRANDINTRAPROC) ( LPCSTR );
        typedef     BOOL (*BRANDCLEANSTUBPROC) (HWND, HINSTANCE, LPCSTR, int);
        HMODULE     IedkHandle = NULL;
        BRANDINTRAPROC      BrandIntraProc;
        BRANDCLEANSTUBPROC  BrandCleanStubProc;
        BOOL        Success = TRUE;
        BOOL        UseOemBrandingFile = FALSE;
        CHAR BrandingFileA[MAX_PATH];
        WCHAR OemBrandingFile[MAX_PATH];
        DWORD OemDirLen = 0;
#define BUF_SIZE 4
        WCHAR Buf[BUF_SIZE];

        //
        // We need to call out to iedkcs32!BrandIntra.
        //
        // Load iedkcs32.dll, lookup BrandIntra and
        // call out to him.
        //

        if (GetPrivateProfileString(L"Branding", L"BrandIEUsingUnattended", L"",
                                    Buf, BUF_SIZE,
                                    AnswerFile)) {
            //Found the Branding section
            __try {

                if( IedkHandle = LoadLibrary(L"IEDKCS32") ) {

                   BrandCleanStubProc = (BRANDCLEANSTUBPROC) GetProcAddress(IedkHandle,"BrandCleanInstallStubs");
                   BrandIntraProc =  (BRANDINTRAPROC) GetProcAddress(IedkHandle,"BrandIntra");
                   if( BrandCleanStubProc && BrandIntraProc ) {

                      if (_wcsicmp(Buf, L"YES")) {
                          //
                          // Check whether the OEM supplies an IE branding file.
                          //
                          MYASSERT(wcslen(SourcePath) < ARRAYSIZE(SourcePath));
                          lstrcpy(OemBrandingFile, SourcePath);

                          if (pSetupConcatenatePaths(OemBrandingFile, WINNT_OEM_DIR, ARRAYSIZE(OemBrandingFile), &OemDirLen)) {
                              if(OemDirLen < ARRAYSIZE(OemBrandingFile)){
                                    MYASSERT(OemBrandingFile[OemDirLen - 1] == 0);
                                    OemBrandingFile[OemDirLen-1] = L'\\';
                                    OemBrandingFile[OemDirLen] = L'\0';
                                    if (GetPrivateProfileString(L"Branding",
                                                                L"IEBrandingFile",
                                                                L"",
                                                                OemBrandingFile + OemDirLen,
                                                                ARRAYSIZE(OemBrandingFile) - OemDirLen,
                                                                AnswerFile)) {
                                            if (FileExists(OemBrandingFile, NULL))
                                                UseOemBrandingFile = TRUE;
                                    }
                              }
                              else{
                                  SetupDebugPrint( L"Setup: (non-critical error) Failed to finish up OemBrandingFile\n" );
                              }
                          } else {
                               SetupDebugPrint( L"Setup: (non-critical error) Failed call pSetupConcatenatePaths\n" );
                          }

                          if (!UseOemBrandingFile) {
                               Success = FALSE;
                               SetupDebugPrint( L"Setup: (non-critical error) Could not find the OEM branding file for IE\n" );
                          }
                      }

                      if (Success) {
                          if (!WideCharToMultiByte(
                                             CP_ACP,
                                             0,
                                             UseOemBrandingFile?OemBrandingFile:AnswerFile,
                                             -1,
                                             BrandingFileA,
                                             ARRAYSIZE(BrandingFileA),
                                             NULL,
                                             NULL
                                             )) {
                               Success = FALSE;
                               SetupDebugPrint1( L"Setup: (non-critical error) Failed call WideCharToMultiByte (gle %u) \n", GetLastError() );

                          } else {

                               Success = BrandCleanStubProc( NULL, NULL, "", 0);
                               if( !Success ) {
                                  SetupDebugPrint( L"Setup: (non-critical error) Failed call BrandCleanInstallStubs \n" );
                               } else {
                                  Success = BrandIntraProc( BrandingFileA );
                                  if( !Success ) {
                                     SetupDebugPrint( L"Setup: (non-critical error) Failed call BrandIntra \n" );
                                  }
                               }
                          }
                      }

                   } else {
                      Success = FALSE;
                      SetupDebugPrint( L"Syssetup: (non-critical error) Failed GetProcAddress on BrandIntra or BrandCleanInstallStubs.\n" );
                   }

                } else {
                   Success = FALSE;
                   SetupDebugPrint( L"Syssetup: (non-critical error) Failed load of iedkcs32.dll.\n" );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                   Success = FALSE;
                   SetupDebugPrint( L"Setup: Exception in iedkcs32!BrandIntra\n" );
            }

            if (IedkHandle)
                FreeLibrary(IedkHandle);

            if( !Success ) {
               //
               // We failed the call (for whatever reason).  Log
               // this error.
               //
               SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_BRAND_IE_FAILURE,
                            NULL,NULL);
            }

        }

    }

}


VOID
SpStartAccessibilityUtilities(
    IN HWND     Billboard
    )
/*++

Routine Description:

    Installs and runs selected accessibility utilities.

Arguments:

    Billboard - window handle of "Setup is Initializing" billboard.

Returns:

    Boolean value indicating outcome.

--*/

{
    HINF    hInf;
    HINF    LayoutInf;
    HSPFILEQ FileQueue;
    PVOID   QContext;
    BOOL    b = TRUE;
    DWORD   ScanQueueResult;

    //
    // Install text-to-speech engine and SAPI 5 for the screen reader.
    //
    FileQueue = SetupOpenFileQueue();
    b = b && (FileQueue != INVALID_HANDLE_VALUE);

    if(b) {
        hInf = SetupOpenInfFile(L"sapi5.inf", NULL, INF_STYLE_WIN4, NULL);
        if(hInf && (hInf != INVALID_HANDLE_VALUE)
        && (LayoutInf = InfCacheOpenLayoutInf(hInf))) {

            SetupInstallFilesFromInfSection(
                hInf,
                LayoutInf,
                FileQueue,
                L"DefaultInstall",
                SourcePath,
                SP_COPY_NEWER
                );

            SetupCloseInfFile(hInf);
        } else {
            b = FALSE;
        }
    }

    //
    // If enqueuing went OK, now perform the copying, renaming, and deleting.
    // Then perform the rest of the install process (registry stuff, etc).
    //
    if(b) {
        QContext = InitSysSetupQueueCallbackEx(
            Billboard,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

        if( QContext ) {

            if(!SetupScanFileQueue(
                   FileQueue,
                   SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                   Billboard,
                   NULL,
                   NULL,
                   &ScanQueueResult)) {
                    //
                    // SetupScanFileQueue should really never
                    // fail when you don't ask it to call a
                    // callback routine, but if it does, just
                    // go ahead and commit the queue.
                    //
                    ScanQueueResult = 0;
                }


            if( ScanQueueResult != 1 ){


                b = SetupCommitFileQueue(
                    Billboard,
                    FileQueue,
                    SysSetupQueueCallback,
                    QContext
                    );
            }

            TermSysSetupQueueCallback(QContext);
        }
        else {
            b = FALSE;
        }
    }

    if(b) {
        hInf = SetupOpenInfFile(L"sapi5.inf",NULL,INF_STYLE_WIN4,NULL);
        if(hInf && (hInf != INVALID_HANDLE_VALUE)) {

            SetupInstallFromInfSection(
                Billboard,
                hInf,
                L"DefaultInstall",
                SPINST_ALL ^ SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );

            SetupCloseInfFile(hInf);
        } else {
            b = FALSE;
        }
    }

    //
    // Delete the file queue.
    //
    if(FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
    }
    // END OF SAPI 5 INSTALLATION.

    if(Magnifier) {
        b = b && InvokeExternalApplication(L"magnify.exe", L"", NULL);
    }

    if(OnScreenKeyboard) {
        b = b && InvokeExternalApplication(L"osk.exe", L"", NULL);
    }

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_ACCESSIBILITY_FAILED,
            NULL,NULL);
    }
}


VOID
FatalError(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user of an error which prevents Setup from continuing.
    The error is logged as a fatal error, and a message box is presented.

Arguments:

    MessageId - supplies the id for the message in the message table.

    Additional agruments specify parameters to be inserted in the message.

Return Value:

    DOES NOT RETURN.

--*/

{
    PWSTR   Message;
    va_list arglist;
    HKEY    hKey;
    DWORD   RegData;


    va_start(arglist,MessageId);
    Message = SetuplogFormatMessageV(
        0,
        SETUPLOG_USE_MESSAGEID,
        MessageId,
        &arglist);
    va_end(arglist);

    if(Message) {

        //
        // Log the error first.
        //
        SetuplogError(
            LogSevFatalError,Message,0,NULL,NULL);

        //
        // Now tell the user.
        //
        MessageBoxFromMessage(
            MainWindowHandle,
            MSG_FATAL_ERROR,
            NULL,
            IDS_FATALERROR,
            MB_ICONERROR | MB_OK | MB_SYSTEMMODAL,
            Message
            );

    } else {
        pSetupOutOfMemory(MainWindowHandle);
    }

    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_ABORTED,
        NULL,NULL);
    if ( SavedExceptionFilter ) {
        SetUnhandledExceptionFilter( SavedExceptionFilter );
    }

    TerminateSetupLog(&SetuplogContext);
    ViewSetupActionLog(MainWindowHandle, NULL, NULL);

    SendSMSMessage( MSG_SMS_FAIL, FALSE );

    if ( OobeSetup ) {
        //
        // Create registry entry that tell winlogon to shutdown for the OOBE case.
        // This doesn't work for MiniSetup, because winlogon always restarts in
        // that case.
        //
        RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\Setup",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            NULL
            );
        if ( hKey ) {
            RegData = ShutdownPowerOff;
            RegSetValueEx(
                hKey,
                L"SetupShutdownRequired",
                0,
                REG_DWORD,
                (PVOID)&RegData,
                sizeof(RegData)
                );
            RegCloseKey(hKey);
        }
    }

    ExitProcess(1);

}

LONG
WINAPI
MyUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    The routine deals with any unhandled exceptions in Setup.  We log an error
    and kill the offending thread.

Arguments:

    Same as UnhandledExceptionFilter.

Return Value:

    Same as UnhandledExceptionFilter.

--*/

{
    UINT_PTR Param1, Param2;
    LONG lStatus;


    switch(ExceptionInfo->ExceptionRecord->NumberParameters) {
    case 1:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = 0;
        break;
    case 2:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
        break;
    default:
        Param1 = Param2 = 0;
    }

    SetupDebugPrint4( L"Setup: (critical error) Encountered an unhandled exception (%lx) at address %lx with the following parameters: %lx %lx.",
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2
        );

#ifdef NOT_FOR_NT5
    SetuplogError(
        LogSevError | SETUPLOG_SINGLE_MESSAGE,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_UNHANDLED_EXCEPTION,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2,
        NULL,
        NULL);
#else
    SetuplogError(
        LogSevError | SETUPLOG_SINGLE_MESSAGE,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_UNHANDLED_EXCEPTION,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2,
        NULL,
        NULL
        );
#endif

    // If we are under a debugger, this will breakin and output some debugging information.
    // Note if a dbgbreak occurs, the real exception will not be logged by ER. This is ok
    // since by default the debugger will not be enabled in gui-mode.
    lStatus = RtlUnhandledExceptionFilter( ExceptionInfo);

    //
    // If we're running under the debugger, then RtlUnhandledExceptionFilter will 
    // pass the exception to the debugger.  
    //
    // If the exception occurred in some thread other than the main
    // Setup thread, then kill the thread on the second occureance and hope that Setup can continue.
    // On the first occurrence, let error recovery queue up the crash.
    //
    // If the exception is in the main thread, then don't handle the exception,
    // and let dr watson queue up the crash and then let Setup die.
    //

    if( GetCurrentThreadId() != MainThreadId) {
        if( AnswerFile[0] != L'\0') {
            WCHAR Buf[4];
            if( GetPrivateProfileString( pwData, pwException, pwNull, Buf, ARRAYSIZE(Buf), AnswerFile)) {
                ExitThread( 0 );
                return EXCEPTION_CONTINUE_EXECUTION;
            } else {
                WritePrivateProfileString( pwData, pwException, TEXT("1") ,AnswerFile);
            }
        }
    }
        
    return lStatus;
}

BOOL
ProcessUniquenessValue(
    LPTSTR lpszDLLPath
    )
{
    BOOL bRet = FALSE;

    //
    // Make sure we were passed something valid...
    //
    if ( lpszDLLPath && *lpszDLLPath )
    {
        LPWSTR pSrch;

        //
        // Look for the comma that separates the DLL and the entrypoint...
        //
        if ( pSrch = wcschr( lpszDLLPath, L',' ) )
        {
            CHAR szEntryPointA[MAX_PATH] = {0};

            // We found one, now NULL the string at the comma...
            //
            *(pSrch++) = L'\0';

            //
            // If there's still something after the comma, and we can convert it
            // into ANSI for GetProcAddress, then let's proceed...
            //
            if ( *pSrch &&
                 ( 0 != WideCharToMultiByte( CP_ACP,
                                             0,
                                             pSrch,
                                             -1,
                                             szEntryPointA,
                                             ARRAYSIZE(szEntryPointA),
                                             NULL,
                                             NULL ) ) )
            {
                HMODULE hModule = NULL;

                try
                {
                    //
                    // Load and call the entry point.
                    //
                    if ( hModule = LoadLibrary( lpszDLLPath ) )
                    {
                        FARPROC fpEntryPoint;

                        if ( fpEntryPoint = GetProcAddress(hModule, szEntryPointA) )
                        {
                            //
                            // Do it, ignoring any return value/errors
                            //
                            fpEntryPoint();

                            //
                            // We made it this far, consider this a success...
                            //
                            bRet = TRUE;
                        }
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    //
                    // We don't do anything with the exception code...
                    //
                }

                //
                // Free the library outside the try/except block in case the function faulted.
                //
                if ( hModule )
                {
                    FreeLibrary( hModule );
                }
            }
        }
    }

    return bRet;
}

VOID
ProcessUniquenessKey(
    BOOL fBeforeReseal
    )
{
    HKEY   hKey;
    TCHAR  szRegPath[MAX_PATH] = {0};
    LPTSTR lpszBasePath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep\\");

    //
    // Build a path to the registry key we want to process...
    //
    lstrcpyn( szRegPath, lpszBasePath, ARRAYSIZE(szRegPath) );
    lstrcpyn( szRegPath + lstrlen(szRegPath),
              fBeforeReseal ? TEXT("SysprepBeforeExecute") : TEXT("SysprepAfterExecute"),
              ARRAYSIZE(szRegPath) - lstrlen(szRegPath) );

    //
    // We want to make sure an Administrator is doing this, so get KEY_ALL_ACCESS
    //
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szRegPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey ) )
    {
        DWORD dwValues          = 0,
              dwMaxValueLen     = 0,
              dwMaxValueNameLen = 0;
        //
        // Query the key to find out some information we care about...
        //
        if ( ( ERROR_SUCCESS == RegQueryInfoKey( hKey,                  // hKey
                                                 NULL,                  // lpClass
                                                 NULL,                  // lpcClass
                                                 NULL,                  // lpReserved
                                                 NULL,                  // lpcSubKeys
                                                 NULL,                  // lpcMaxSubKeyLen
                                                 NULL,                  // lpcMaxClassLen
                                                 &dwValues,             // lpcValues
                                                 &dwMaxValueNameLen,    // lpcMaxValueNameLen
                                                 &dwMaxValueLen,        // lpcMaxValueLen
                                                 NULL,                  // lpcbSecurityDescriptor
                                                 NULL ) ) &&            // lpftLastWriteTime
             ( dwValues > 0 ) &&
             ( dwMaxValueNameLen > 0) &&
             ( dwMaxValueLen > 0 ) )
        {
            //
            // Allocate buffers large enough to hold the data we want...
            //
            LPBYTE lpData      = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwMaxValueLen );
            LPTSTR lpValueName = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, ( dwMaxValueNameLen + 1 ) * sizeof(TCHAR) );

            //
            // Make sure we could allocate our buffers... otherwise bail out
            //
            if ( lpData && lpValueName )
            {
                DWORD dwIndex   = 0;
                BOOL  bContinue = TRUE;

                //
                // Enumerate through the key values and call the DLL entrypoints...
                //
                while ( bContinue )
                {
                    DWORD dwType,
                          cbData         = dwMaxValueLen,
                          dwValueNameLen = dwMaxValueNameLen + 1;

                    bContinue = ( ERROR_SUCCESS == RegEnumValue( hKey,
                                                                 dwIndex++,
                                                                 lpValueName,
                                                                 &dwValueNameLen,
                                                                 NULL,
                                                                 &dwType,
                                                                 lpData,
                                                                 &cbData ) );

                    //
                    // Make sure we got some data of the correct format...
                    //
                    if ( bContinue && ( REG_SZ == dwType ) && ( cbData > 0 ) )
                    {
                        //
                        // Now split up the string and call the entrypoints...
                        //
                        ProcessUniquenessValue( (LPTSTR) lpData );
                    }
                }
            }

            //
            // Clean up any buffers we may have allocated...
            //
            if ( lpData )
            {
                HeapFree( GetProcessHeap(), 0, lpData );
            }

            if ( lpValueName )
            {
                HeapFree( GetProcessHeap(), 0, lpValueName );
            }
        }

        //
        // Close the key...
        //
        RegCloseKey( hKey );
    }
}


VOID
RunExternalUniqueness(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine will call out to any external dlls that will allow
    3rd party apps to make their stuff unique.

    We'll look in 2 inf files:
    %windir%\inf\minioc.inf
    %systemroot%\sysprep\providers.inf

    In each of these files, we'll look in the [SysprepInitExecute] section
    for any entries.  The entries must look like:
    dllname,entrypoint

    We'll load the dll and call into the entry point.  Errors are ignored.

Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
WCHAR       InfPath[MAX_PATH];
PCWSTR      DllName;
PCWSTR      EntryPointNameW;
CHAR        EntryPointNameA[MAX_PATH];
HINF        AnswerInf;
HMODULE     DllHandle;
FARPROC     MyProc;
INFCONTEXT  InfContext;
DWORD       i;
PCWSTR      SectionName = L"SysprepInitExecute";
BOOL        LineExists;
DWORD       Result;

    //
    // =================================
    // Minioc.inf
    // =================================
    //
#define MINIOC_INF_SUB_PATH TEXT("\\inf\\minioc.inf")

    //
    // Build the path.
    //
    Result = GetWindowsDirectory(InfPath,
                                 ARRAYSIZE(InfPath) - ARRAYSIZE(MINIOC_INF_SUB_PATH) + 1);
    if(Result == 0) {
        MYASSERT(FALSE);
        return;
    }
    lstrcat(InfPath, MINIOC_INF_SUB_PATH);

    //
    // See if he's got an entry
    // section.
    //
    AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( AnswerInf == INVALID_HANDLE_VALUE ) {
        //
        // Try an old-style.
        //
        AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_OLDNT, NULL );
    }


    if( AnswerInf != INVALID_HANDLE_VALUE ) {
        //
        // Process each line in our section
        //
        LineExists = SetupFindFirstLine( AnswerInf, SectionName, NULL, &InfContext );

        while( LineExists ) {

                if( DllName = pSetupGetField(&InfContext, 1) ) {
                    if( EntryPointNameW = pSetupGetField(&InfContext, 2) ) {

                        DllHandle = NULL;

                        //
                        // Load and call the entry point.
                        //
                        __try {
                            if( DllHandle = LoadLibrary(DllName) ) {

                                //
                                // No Unicode version of GetProcAddress(). Convert string to ANSI.
                                //
                                i = WideCharToMultiByte(CP_ACP,0,EntryPointNameW,-1,EntryPointNameA,MAX_PATH,NULL,NULL);

                                if(i){
                                    if( MyProc = GetProcAddress(DllHandle, EntryPointNameA) ) {
                                        //
                                        // Do it, ignoring any return value/errors
                                        //
                                        MyProc();
                                    }
                                }
                                else{
                                    SetuplogError(LogSevError,
                                                  L"WideCharToMultiByte failed to convert W to A (GetLastError() = %1!u!)\r\n",
                                                  0,
                                                  GetLastError(),
                                                  NULL,
                                                  NULL);
                                }
                            }
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                        }

                        if( DllHandle ) {
                            FreeLibrary( DllHandle );
                        }

                    }
                }

            LineExists = SetupFindNextLine(&InfContext,&InfContext);

        }

        SetupCloseInfFile( AnswerInf );
    }




    //
    // =================================
    // Provider.inf
    // =================================
    //

    ProcessUniquenessKey( FALSE );
}



#ifdef _X86_
VOID
CleanUpHardDriveTags (
    VOID
    )
{
#define DRV_PATH    TEXT("?:\\")

    WCHAR path[MAX_PATH];
    WCHAR rootPath[4] = DRV_PATH;
    UINT i;
    BYTE bitPosition;
    DWORD drives;
    UINT type;

    MYASSERT((ARRAYSIZE(WINNT_WIN95UPG_DRVLTR_W) + ARRAYSIZE(DRV_PATH) - 1) < ARRAYSIZE(path));

    lstrcpy(path, DRV_PATH);
    lstrcat(path, WINNT_WIN95UPG_DRVLTR_W);

    drives = GetLogicalDrives ();

    for (bitPosition = 0; bitPosition < 26; bitPosition++) {

        if (drives & (1 << bitPosition)) {

            *rootPath = bitPosition + L'A';
            type = GetDriveType (rootPath);

            if (type == DRIVE_FIXED) {
                *path = *rootPath;
                DeleteFile (path);
            }
        }
    }
}


#endif




HRESULT
WaitForSamService(
    IN DWORD dwWaitTime)
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:
    dwWaitTime - Amount of time to wait up to in ms

Return Value:

Notes:

  acosma 10/12/2001 - code borrowed from winlogon. Waiting for 20 seconds just like winlogon.

--*/

{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    HRESULT Hr;

    //
    // open SAM event
    //

    RtlInitUnicodeString(&EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );
    if (!NT_SUCCESS(Status))
    {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION )
            {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status))
        {
            //
            // could not make the event handle
            //
            return( Status );
        }
    }

    WaitStatus = WaitForSingleObject( EventHandle,
                                      dwWaitTime );

    if ( WaitStatus == WAIT_OBJECT_0 )
    {
        Hr = S_OK;
    }
    else
    {
        Hr = WaitStatus;
    }

    (VOID) NtClose( EventHandle );
    return Hr;
}




#define UPDATE_KEYS         L"UpdateKeys"
#define KEY_UPDATE_NEEDED   0
#define KEY_UPDATE_FAIL     1
#define KEY_UPDATE_SUCCESS  2
#define KEY_UPDATE_MAX      2


VOID
UpdateSecurityKeys(
    )

/*+++

    This function calls an API that generates new security keys for machines
    that have been cloned.  If the API fails, it is a fatal error.  Whether it
    succeeds or not, we record the result in the registry so that we don't
    try again if the machine is restarted.

--*/

{
    DWORD       Status;
    HKEY        hKey = NULL;
    DWORD       dwType;
    LONG        RegData = KEY_UPDATE_NEEDED;
    DWORD       cbData;


    SetupDebugPrint(L"Updating keys ...");

    RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE",
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        NULL
        );
    if ( hKey ) {

        cbData = sizeof(RegData);
        Status = RegQueryValueEx(
            hKey,
            UPDATE_KEYS,
            NULL,
            &dwType,
            (PVOID)&RegData,
            &cbData
            );

        if ( Status != ERROR_SUCCESS ||
             dwType != REG_DWORD ||
             RegData > KEY_UPDATE_MAX
             ) {

            RegData = KEY_UPDATE_NEEDED;
        }
    }

    switch (RegData) {

    case KEY_UPDATE_NEEDED:
#if 1
        Status = CryptResetMachineCredentials( 0 );
#else
        // To test the failure case:
        Status = ERROR_OUT_OF_PAPER;
#endif
        if ( Status != ERROR_SUCCESS ) {
            SetupDebugPrint1(L"... failed.  Error = %d", Status);
            MYASSERT( Status );
            RegData = KEY_UPDATE_FAIL;
        } else {
            SetupDebugPrint(L"... succeeded.");
            RegData = KEY_UPDATE_SUCCESS;
        }

        if ( hKey ) {
            Status = RegSetValueEx(
                hKey,
                UPDATE_KEYS,
                0,
                REG_DWORD,
                (PVOID)&RegData,
                sizeof(RegData)
                );
            MYASSERT( Status == ERROR_SUCCESS);
        }
        break;

    case KEY_UPDATE_FAIL:
        SetupDebugPrint(L"... not needed (previously failed).");
        break;

    case KEY_UPDATE_SUCCESS:
        SetupDebugPrint(L"... not needed (previously succeeded).");
        break;

    default:
        MYASSERT(0);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    // Note: FatalError() doesn't return.
    if ( RegData == KEY_UPDATE_FAIL ) {
        FatalError( MSG_LOG_CANT_SET_SECURITY, 0, 0 );
    }
}


#ifdef _OCM
PVOID
#else
VOID
#endif
CommonInitialization(
    VOID
    )

/*++

Routine Description:

    Initialize GUI Setup. This is common to upgrades and initial installs.
    In this phase, we perform initialization tasks such as creating the
    main background window, initializing the action log (into which we will
    store error and other info), and fetch setup parameters from the
    response file.

    We also install the NT catalog file(s) and load system infs.

    Note that any errors that occur during this phase are fatal.

    NOTE: IF YOU ADD CODE TO THIS FUNCTION THAT REQUIRES A SERVICE TO RUN MAKE
        SURE THAT IT IS NOT EXECUTED IN OOBE MODE.  OOBE DELAYS THE STARTING OF
        SERVICES UNTIL THE MACHINE NAME HAS BEEN CHANGED, SO WAITING FOR A
        SERVICE TO START DURING INITIALIZATION WILL CAUSE A DEADLOCK.

Arguments:

    None.

Return Value:

#ifdef _OCM
    OC Manager context handle.
#else
    None.
#endif

--*/

{
    #define     MyAnswerBufLen (2*MAX_PATH)
    WCHAR       MyAnswerFile[MyAnswerBufLen];
    WCHAR       MyAnswer[MyAnswerBufLen];
    DWORD       rc,wowretval, Err;
    BOOL        b;
    HWND        Billboard;
    HCURSOR     hCursor;
    WCHAR       Path[MAX_PATH];
    PWSTR       Cmd;
    PWSTR       Args;
    WCHAR       PathBuffer[4*MAX_PATH];
    PWSTR       PreInstallProfilesDir;
    int         i;
    HANDLE      h;
    WCHAR       CmdLine[MAX_PATH];
#ifdef _OCM
    PVOID       OcManagerContext;
#endif
    TCHAR       paramBuffer[MAX_PATH];
    TCHAR       profilePath[MAX_PATH];
    DWORD       Size;

    //
    // Get handle to heap so we can periodically validate it.
    //
#if DBG
    g_hSysSetupHeap = GetProcessHeap();
#endif

    //
    // Hack to make mini setup restartable.
    //
    if( MiniSetup ) {
    HKEY hKeySetup;

        // OOBE will set its own restartability.
        //
        if (! OobeSetup)
        {
            BEGIN_SECTION(L"Making mini setup restartable");

            //
            // Reset the SetupType entry to 1.  We'll clear
            // it at the end of gui-mode.
            //
            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"System\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );

            if(rc == NO_ERROR) {
                //
                // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
                //
                rc = 1;
                RegSetValueEx( hKeySetup,
                               TEXT( "SetupType" ),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&rc,
                               sizeof(DWORD));

                RegCloseKey(hKeySetup);
            }
            END_SECTION(L"Making mini setup restartable");
        }
    }

    //
    // Initialize the action log. This is where we log any errors or other
    // info we think might be useful to the user.
    //
    BEGIN_SECTION(L"Initializing action log");
    InitializeSetupLog(&SetuplogContext);
    MainThreadId = GetCurrentThreadId();
    OriginalInstallLocale = GetThreadLocale();
    SavedExceptionFilter = SetUnhandledExceptionFilter( MyUnhandledExceptionFilter );
    END_SECTION(L"Initializing action log");

    Upgrade = (SpSetupLoadParameter(pwNtUpgrade,
                                    paramBuffer,
                                    ARRAYSIZE(paramBuffer)) &&
               !lstrcmpi(paramBuffer, pwYes));

#ifdef _X86_
    Win95Upgrade = (SpSetupLoadParameter(pwWin95Upgrade,
                                         paramBuffer,
                                         ARRAYSIZE(paramBuffer)) &&
                    !lstrcmpi(paramBuffer, pwYes));

    if(Win95Upgrade){
        UninstallEnabled = (SpSetupLoadParameter(pwBackupImage,
                                        paramBuffer,
                                        ARRAYSIZE(paramBuffer)) &&
                                0xffffffff != GetFileAttributes(paramBuffer));
    }

    if (UninstallEnabled) {
        //
        // Put the boot.ini timeout to 30 seconds (or whatever the answer
        // file says it should be), so that if setup fails, the user can
        // clearly see the Cancel Setup option in the boot menu. The
        // timeout gets set back to 5 seconds during PNP detection, so
        // that PNP hung device logic still works.
        //

        RestoreBootTimeout();
    }
#endif

    if (!OobeSetup)
    {
        if(Win95Upgrade || !Upgrade){
            Size = ARRAYSIZE(profilePath);
            if(GetAllUsersProfileDirectory(profilePath, &Size)) {
                DeleteOnRestartOfGUIMode(profilePath);
            }
            else{
                SetupDebugPrint(TEXT("Cannot get All Users profile path."));
            }

            Size = ARRAYSIZE(profilePath);
            if(GetDefaultUserProfileDirectory(profilePath, &Size)) {
                DeleteOnRestartOfGUIMode(profilePath);
            }
            else{
                SetupDebugPrint(TEXT("Cannot get Default User profile path."));
            }
        }
    }

    //
    // Create the main setup background window.  We need to know which product
    // we are for the "Initializing" dialog.
    //
    SpSetProductTypeFromParameters();

#ifdef PRERELEASE
    {
        //
        // Initialize test hook failure point (internal use only, for testing restartability)
        //

        WCHAR buffer[32];
        int TestRun;


        //
        // This next function call is just to ensure the global AnswerFile value is filled in.
        // Since this is temp code, we call GetPrivateProfileString knowing some of the
        // implementation of SpSetupLoadParameter.
        //

        SpSetupLoadParameter(pwWin95Upgrade, buffer, ARRAYSIZE(buffer));

        // Get the test hook that we want to fail on
        g_TestHook = GetPrivateProfileInt (L"TestHooks", L"BugCheckPoint", 0, AnswerFile);
        TestRun = GetPrivateProfileInt (L"TestHooks", L"BugCheckRuns", 0, AnswerFile);
        if (TestRun > 1) {
            wsprintf( buffer, L"%d", TestRun-1);
            WritePrivateProfileString( L"TestHooks", L"BugCheckRuns", buffer ,AnswerFile);
        }
        else if( TestRun == 1) {
            g_TestHook = 0;
        }
    }
#endif

    TESTHOOK(501);

    // This needs to be called before DisplayBillboard is called.
    if (MiniSetup) {
        BEGIN_SECTION(L"Initialize SxS Context");
        SpInitSxsContext();
        END_SECTION(L"Initialize SxS Context");

        SpInitCommonControls();
    }

    if( !OobeSetup ) {
        WCHAR p[16];
        BEGIN_SECTION(L"Creating setup background window");
        MainWindowHandle = CreateSetupWindow();

        //
        // Need to know this to calc the remaining time correct.
        //

        //
        //Already initialized;
        //Win95Upgrade = (SpSetupLoadParameter(pwWin95Upgrade,p,sizeof(p)/sizeof(WCHAR)) && !lstrcmpi(p,pwYes));
        //

        // Now the billboard window is up. set the first estimate.
        RemainingTime = CalcTimeRemaining(Phase_Initialize);
        SetRemainingTime(RemainingTime);

        Billboard = DisplayBillboard(MainWindowHandle,MSG_INITIALIZING);
        hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
        END_SECTION(L"Creating setup background window");
    }

    //
    // Update security keys for syspreped systems.  See RAID 432224.
    // Also restore the MountMgr settings if sysprep saved them.
    //
    if ( MiniSetup ) {
        HRESULT hrSamStatus;
        HKEY    hKey                = NULL;
        DWORD   dwValue,
                dwSize              = sizeof(dwValue);

        //
        // Before calling UpdateSecurityKeys make sure that LSA is properly initialized.
        //
        if ( S_OK != (hrSamStatus = WaitForSamService(300*1000)) ) {
            SetuplogError(LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_SAM_WAIT_ERROR,
                hrSamStatus,
                NULL,
                NULL
                );
        }

        // Determine if we have regenerated the SIDS without calling the UpdateSecurityKeys
        //
        if ( (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSPREP, 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS) &&
             (RegQueryValueEx(hKey, REGSTR_VAL_SIDGENHISTORY, NULL, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS) &&
             (dwValue == 1)
           )
        {
            // We've regenerated SIDS without calling UpdateSecurityKeys, lets do it now
            //
            UpdateSecurityKeys();
            RegDeleteValue(hKey,REGSTR_VAL_SIDGENHISTORY);
        }

        // Restore the MountMgr settings if sysprep saved them.
        //
        // The Sysprep key should already be opened.
        //
        dwSize = sizeof(dwValue);

        if ( hKey &&
             ( RegQueryValueEx(hKey, REGSTR_VAL_NOAUTOMOUNT, NULL, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS ) )
        {
            HKEY hKeyMountMgr = NULL;

            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SERVICES_MOUNTMGR, 0, KEY_ALL_ACCESS, &hKeyMountMgr ) == ERROR_SUCCESS )
            {
                RegSetValueEx( hKeyMountMgr, REGSTR_VAL_NOAUTOMOUNT, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue) );
                RegCloseKey( hKeyMountMgr );
            }
            // Delete the backed up value since we no longer need it.
            //
            RegDeleteValue(hKey, REGSTR_VAL_NOAUTOMOUNT);
        }
        
        // Close the key that we opened
        //
        if ( hKey )
        {
            RegCloseKey(hKey);
        }
    }

    //
    // Support for SMS.
    //
    if( !MiniSetup ) {
        __try {
            BEGIN_SECTION(L"Initializing SMS support");
            if( SMSHandle = LoadLibrary( TEXT("ISMIF32")) ) {

                if( InstallStatusMIF = (SMSPROC)GetProcAddress(SMSHandle,"InstallStatusMIF")) {
                    SetupDebugPrint( L"Setup: GetProcAddress on ISMIF32 succeeded." );
                } else {
                    SetupDebugPrint( L"Setup: (non-critical error): Failed GetProcAddress on ISMIF32." );
                }
            } else {
                    SetupDebugPrint( L"Setup: (non-critical error): Failed load of ismif32.dll." );
            }
            END_SECTION(L"Initializing SMS support");
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            SetupDebugPrint( L"Setup: Exception in ISMIF32." );
            END_SECTION(L"Initializing SMS support");
        }
    }

    //
    // Are we in safe mode?
    //
    // BUGBUG: OOBE shouldn't start in safe mode
    //
#ifdef NOT_FOR_NT5
    {
        DWORD d;
        HKEY hkey;

        d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",0,KEY_READ,&hkey);
        if(d == NO_ERROR) {
            RegCloseKey(hkey);
            SetuplogError(
                LogSevError,
                L"Setup is running in safe-mode.  This is not supported.\r\n",
                0,NULL,NULL);
        }
    }
#endif

    //
    // Prevent power management from kicking in.
    //
    BEGIN_SECTION(L"Shutting down power management");
    SetThreadExecutionState(
        ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED);
    END_SECTION(L"Shutting down power management");

    //
    // Fetch our parameters. Note that this also takes care of initializing
    // uniqueness stuff, so later initialization of preinstall and unattend mode
    // don't ever have to know anything about the uniqueness stuff -- it's
    // totally transparent to them.
    //
    if (MiniSetup) {
        DWORD Err;

        //
        // Initialize unattended operation now.  In the case of MiniSetup,
        // we actually determine if we're unattended during UnattendInitialize.
        // We make that determination based on whether or not there's an
        // unattend file.
        //
        BEGIN_SECTION(L"Initialize unattended operation (mini-setup only)");
        UnattendInitialize();
        END_SECTION(L"Initialize unattended operation (mini-setup only)");

        //
        // Check to see if our unattend file specifies a test root certificate
        // to be installed via a "TestCert" entry.
        //
        BEGIN_SECTION(L"Checking for test root certificate (mini-setup only)");
        if(!GetSystemDirectory(MyAnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths(MyAnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        if(GetPrivateProfileString(WINNT_UNATTENDED,
                                   WINNT_U_TESTCERT,
                                   pwNull,
                                   MyAnswer,
                                   MyAnswerBufLen,
                                   MyAnswerFile)) {

            Err = SetupAddOrRemoveTestCertificate(MyAnswer, INVALID_HANDLE_VALUE);

            if(Err != NO_ERROR) {
                SetupDebugPrint2( L"SETUP: SetupAddOrRemoveTestCertificate(%ls) failed. Error = %d \n", MyAnswer, Err );
                SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CERT_NOT_INSTALLED,
                              MyAnswer,
                              Err,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );

                KillBillboard(Billboard);
                FatalError(MSG_LOG_BAD_UNATTEND_PARAM, WINNT_U_TESTCERT, WINNT_UNATTENDED);
            }
        }
        END_SECTION(L"Checking for test root certificate (mini-setup only)");

        BEGIN_SECTION(L"Reinstalling SLP files");
        MyAnswer[0] = 0;
        GetDllCacheFolder(MyAnswer, MyAnswerBufLen);
        if(!pSetupConcatenatePaths(MyAnswer,L"OEMBIOS.CAT",MyAnswerBufLen,NULL)){
            MYASSERT(FALSE);
            SetuplogError(LogSevWarning,
                          L"CommonInitialization: MyAnswer has been truncated due to buffer size\r\n",
                          0,
                          NULL,
                          NULL);
        }
        if ( FileExists(MyAnswer, NULL) )
        {
            SetupInstallCatalog(MyAnswer);
        }
        END_SECTION(L"Reinstalling SLP files");

        PnpSeed = GetSeed();

        pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_VERIFY_INF);

        BEGIN_SECTION(L"Initializing code signing policies");
        InitializeCodeSigningPolicies(TRUE);
        END_SECTION(L"Initializing code signing policies");
    } else {
        //
        // Load up all the parameters.  Note that this also initializes the
        // unattend engine.
        //
        BEGIN_SECTION(L"Processing parameters from sif");
        if( !SpSetupProcessParameters(&Billboard) ) {
            KillBillboard(Billboard);
            FatalError(MSG_LOG_LEGACYINTERFACE,0,0);
        }
        END_SECTION(L"Processing parameters from sif");
    }

    //
    // see if we need to prop flag to supress driver prompts
    // this puts setupapi into full headless mode
    //
    if (UnattendMode == UAM_FULLUNATTENDED) {
        pSetupSetNoDriverPrompts(TRUE);
    }

    //
    // load the service pack dll if it is present
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 1)");
        hModSvcPack = MyLoadLibraryWithSignatureCheck( SVCPACK_DLL_NAME );
        if (hModSvcPack) {
            pSvcPackCallbackRoutine = (PSVCPACKCALLBACKROUTINE)GetProcAddress( hModSvcPack, SVCPACK_CALLBACK_NAME );
        } else {
            DWORD LastError = GetLastError();
            if (LastError != ERROR_FILE_NOT_FOUND && LastError != ERROR_PATH_NOT_FOUND) {
                SetuplogError(LogSevWarning,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SVCPACK_DLL_LOAD_FAILED,
                              LastError, NULL,NULL
                              );
            }
        }

        CALL_SERVICE_PACK( SVCPACK_PHASE_1, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 1)");
    }

#ifdef _X86_
    //
    // Win9x upgrade: do pre-migration work
    //

    if (Win95Upgrade && ! OobeSetup) {
        BEGIN_SECTION(L"Win9x premigration (Win9x only)");
        PreWin9xMigration();
        END_SECTION(L"Win9x premigration (Win9x only)");
    }

    //
    // Clean up drvlettr tag files from drvlettr mapping.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Cleaning up hard drive tags");
        CleanUpHardDriveTags ();
        END_SECTION(L"Cleaning up hard drive tags");
    }

#endif

    TESTHOOK(518);

    //
    // Initialize preinstallation.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Initializing OEM preinstall");
        InitializePreinstall();
        END_SECTION(L"Initializing OEM preinstall");
    } else {
        //
        // MiniSetup case...
        //
        //
        // Find out what platform we're on.  This will initalize
        // PlatformName.
        //
        SetUpProcessorNaming();
    }

    if( MiniSetup ) {
    //
    // MiniSetup case
    //
    DWORD   CMP_WaitNoPendingInstallEvents (IN DWORD dwTimeout);
    DWORD   rc, Type, dword;
    HKEY    hKey;
    ULONG   Size;


        //
        // Mini-setup is _never_ an upgrade...
        //
        MYASSERT(!Upgrade);

        if( ProductType == PRODUCT_WORKSTATION) {
            if( GetProductFlavor() == 4) {
                SetupTitleStringId = IDS_TITLE_INSTALL_P;
            }
            else {
                SetupTitleStringId = IDS_TITLE_INSTALL_W;
            }
        }
        else
        {
            SetupTitleStringId = IDS_TITLE_INSTALL_S;
        }

        if(Unattended) {
            //
            // Initialize preinstallation.
            //
            UnattendMode = UAM_DEFAULTHIDE;
            BEGIN_SECTION(L"Initializing OEM preinstall (mini-setup only)");
            InitializePreinstall();
            END_SECTION(L"Initializing OEM preinstall (mini-setup only)");
        }

        // OOBE will have already completed PnP at this point.
        //
        if (! OobeSetup)
        {
            //
            //  Let the network component do some cleanup before we start the
            //  pnp stuff
            BEGIN_SECTION(L"Initial network setup cleanup (mini-setup only)");
            CallNetworkSetupBack("DoInitialCleanup");
            END_SECTION(L"Initial network setup cleanup (mini-setup only)");
        }

        BEGIN_SECTION(L"Opening syssetup.inf (mini-setup only)");
        SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
        END_SECTION(L"Opening syssetup.inf (mini-setup only)");

        if(SyssetupInf == INVALID_HANDLE_VALUE) {
            KillBillboard(Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"syssetup.inf",0,0);
        }

        //
        // Now go off and do the unattended locale stuff.  We need
        // to see if the user sent us any source path before we call
        // out to intl.cpl because he'll want to copy some files.
        // If there are no files, there's no need to even call
        // intl.cpl
        //

        BEGIN_SECTION(L"Unattended locale initialization (mini-setup only)");
        //
        // Pickup the answer file.
        //
        if(!GetSystemDirectory(MyAnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths(MyAnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        if( GetPrivateProfileString( TEXT("Unattended"),
                                     TEXT("InstallFilesPath"),
                                     pwNull,
                                     MyAnswer,
                                     MyAnswerBufLen,
                                     MyAnswerFile ) ) {
            if( lstrcmp( pwNull, MyAnswer ) ) {
                if(wcslen(MyAnswer) < MAX_PATH){
                    MYASSERT(ARRAYSIZE(LegacySourcePath) >= MAX_PATH);
                    MYASSERT(ARRAYSIZE(SourcePath) >= MAX_PATH);
                    //
                    // He sent us a source path.  We need to go ahead
                    // and set SourcePath and LegacySourcePath here
                    // because we'll be calling out to intl.cpl again
                    // during the regional settings page.  So we might
                    // as well do the forward work here.
                    //
                    lstrcpy( LegacySourcePath, MyAnswer );

                    //
                    // And this is good enough for MiniSetup.  We shouldn't
                    // ever need SourcePath, but set it just to make sure.
                    //
                    lstrcpy( SourcePath, MyAnswer );

                    if(_snwprintf(CmdLine,
                                  ARRAYSIZE(CmdLine),
                                  L"/f:\"%s\" /s:\"%s\"",
                                  MyAnswerFile,
                                  LegacySourcePath) < 0){
                        CmdLine[ARRAYSIZE(CmdLine) - 1] = 0;
                        SetuplogError(LogSevWarning,
                                    L"CmdLine has been truncated due to buffer size\r\n",
                                    0,
                                    NULL,
                                    NULL);
                    }

                    InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);
                }
                else{
                    MYASSERT(FALSE);
                    SetuplogError(LogSevWarning,
                                L"Skip InvokeControlPanelApplet for \"intl.cpl\" due to buffer size\r\n",
                                0,
                                NULL,
                                NULL);
                }
            }
        } else {

            //
            // Set the strings from the registry.
            //

            //
            // Open HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
            //
            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                               0,
                               KEY_ALL_ACCESS,
                               &hKey );

            if(rc == NO_ERROR) {

                //
                // Retrieve the original value.
                //
                Size = sizeof(SourcePath);
                rc = RegQueryValueEx(hKey,
                                     TEXT("SourcePath"),
                                     NULL,
                                     &Type,
                                     (LPBYTE)SourcePath,
                                     &Size);

                if(rc == ERROR_SUCCESS && Type == REG_SZ &&
                   /* this assumes SourcePath is UNICODE */ !(Size & 1) &&
                   /* make sure it's nul-terminated or that we can append one*/
                   (!SourcePath[Size/sizeof(SourcePath[0]) - 1] || Size < sizeof (SourcePath))
                    ) {
                    //
                    // Got it.  Write it into SfcDisable.
                    // Make sure it's zero terminated
                    //
                    if (!SourcePath[Size / sizeof (SourcePath[0]) - 1]) {
                        SourcePath[Size / sizeof (SourcePath[0])] = 0;
                    }
                    lstrcpy( LegacySourcePath, SourcePath );

                    if(!pSetupConcatenatePaths( LegacySourcePath, PlatformName, MAX_PATH, NULL )){
                        SetuplogError(LogSevWarning,
                                      L"CommonInitialization: MyAnswer has been truncated due to buffer size\r\n",
                                      0,
                                      NULL,
                                      NULL);
                    }
                }
                else{
                    MYASSERT(FALSE);
                    SourcePath[0] = 0;
                    LegacySourcePath[0] = 0;
                    SetuplogError(LogSevWarning,
                                  L"CommonInitialization:RegQueryValueEx failed to get \"SourcePath\"\r\n",
                                  0,
                                  NULL,
                                  NULL);
                }

                RegCloseKey(hKey);
            }

        }
        END_SECTION(L"Unattended local initialization (mini-setup only)");

        //
        // Now give the PnP engine time to finish before we
        // start the wizard.  Only do this if we're NOT doing
        // a -PnP though.  The only way to do that is to look
        // at the registry.  We can tell if that's been
        // requested by checking the value in:
        // HKLM\SYSTEM\SETUP\MiniSetupDoPnP.
        //
        BEGIN_SECTION(L"Waiting for PnP engine to finish");
        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\SETUP",
                           0,
                           KEY_READ,
                           &hKey );

        if( rc == NO_ERROR ) {
            Size = sizeof(DWORD);
            rc = RegQueryValueEx( hKey,
                                  L"MiniSetupDoPnP",
                                  NULL,
                                  &Type,
                                  (LPBYTE)&dword,
                                  &Size );

            if( (rc == NO_ERROR) && (dword == 1) ) {
                PnPReEnumeration = TRUE;
            } else {
                //
                // Wait.
                //
                CMP_WaitNoPendingInstallEvents ( INFINITE );
                //
                // Update PnP drivers if specified from answerfile.
                //
                if ( GetPrivateProfileString( TEXT("Unattended"),
                                              TEXT("UpdateInstalledDrivers"),
                                              pwNull,
                                              MyAnswer,
                                              MyAnswerBufLen,
                                              MyAnswerFile )  )
                {
                    if ( 0 == _wcsicmp( TEXT("YES"), MyAnswer ) ) {
                        BEGIN_SECTION(L"Updating PnP Drivers");
                        UpdatePnpDeviceDrivers();
                        END_SECTION(L"Updating PnP Drivers");
                    }
                }
            }
        }
        END_SECTION(L"Waiting for PnP engine to finish");

    } else { // !MiniSetup

        //
        // fix problem with IntelliType Manager conflict.
        //
        RemoveMSKeyboardPtrPropSheet ();

        //
        // Fix Wordpad registry entry.
        //
        FixWordPadReg ();

        if(Unattended) {

            BEGIN_SECTION(L"Invoking external app (unattended only)");
            //
            // Set the current dir to %windir% -- to be consistent with
            // UserExecuteCmd
            //
            if(!GetWindowsDirectory(PathBuffer, MAX_PATH)){
                MYASSERT(FALSE);
            }
            if(!SetCurrentDirectory(PathBuffer)){
                MYASSERT(FALSE);
            }

            //
            // The program to execute is in 2 parts: DetachedProgram and Arguments.
            //
            if(Cmd = UnattendFetchString(UAE_PROGRAM)) {

                if(Cmd[0]) {

                    Args = UnattendFetchString(UAE_ARGUMENT);

                    ExpandEnvironmentStrings(Cmd,PathBuffer,MAX_PATH);
                    ExpandEnvironmentStrings(Args ? Args : L"",PathBuffer+MAX_PATH,3*MAX_PATH);

                    if(!InvokeExternalApplication(PathBuffer,PathBuffer+MAX_PATH,NULL)) {
                        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_DETACHED_PROGRAM_FAILED,
                            PathBuffer,
                            NULL,NULL);
                    }

                    if(Args) {
                        MyFree(Args);
                    }
                }

                MyFree(Cmd);
            }
            END_SECTION(L"Invoking external app (unattended only)");
        }

        if(!Upgrade) {

            //
            // See if the user wants the profiles in a custom
            // location.
            //
            if (Unattended && UnattendAnswerTable[UAE_PROFILESDIR].Answer.String) {
                if (!SetProfilesDirInRegistry(UnattendAnswerTable[UAE_PROFILESDIR].Answer.String)) {
                    b = FALSE;
                }
            }

            //
            // In preinstall scenarios the OEM might "preload" the Default Users
            // or All Users profile with links. Currently the Profiles or Documents and Settings
            // directory is created in Winlogon as services.exe need to use it.
            //
            // We have a changed behavior with Whistler. If the OEM wants to overlay a Profiles directory on the system
            // then he needs to postfix it with $$. This is also true in the cases where he needs to provide a $$rename.txt.
            // That way winlogon will always create a true folder without .Windows appended. We then just come here and overlay
            //
            //
            if(Preinstall) {
            PSID    AdminSid = NULL;
            WCHAR   AdminAccountName[MAX_PATH];
            DWORD   dwsize;

                BEGIN_SECTION(L"Initialize user profiles (preinstall)");

                PreInstallProfilesDir = PathBuffer;

                if (Unattended && UnattendAnswerTable[UAE_PROFILESDIR].Answer.String) {
                    if((lstrlen(UnattendAnswerTable[UAE_PROFILESDIR].Answer.String) + 2) >= MAX_PATH){
                        MYASSERT(FALSE);
                        //
                        // BUGBUG: setup should fail here
                        //FatalError();
                        //
                    }
                    lstrcpy( Path, UnattendAnswerTable[UAE_PROFILESDIR].Answer.String );
                } else {
                    dwsize = MAX_PATH - 2;
                    if(!GetProfilesDirectory( Path, &dwsize )){
                        MYASSERT(FALSE);
                        //
                        // BUGBUG: setup should fail here
                        //FatalError();
                        //
                    }
                }

                lstrcpy( PreInstallProfilesDir, Path );
                lstrcat( PreInstallProfilesDir, L"$$" );


                //
                // Recreate it from scratch.
                //
                ProcessRegistryFiles( Billboard );
                InitializeProfiles( TRUE );

                //
                // Since the Profiles directory maybe (actually is) already created by Winlogon
                // we now just special case the "Documents and Settings$$" directory and merge it after InitializeProfiles.
                // This is hacky but will save the people who do a winnt.exe based PreInstall. They just
                // need to change their first directive to be a rename to the Profiles folder postfixed with a "$$".
                // WE will notice this special directory and do a merge with the current Profiles directory.
                //

                if(FileExists(PreInstallProfilesDir,NULL)) {
                    if( (Err = TreeCopy(PreInstallProfilesDir,Path)) == NO_ERROR ){
                        Delnode( PreInstallProfilesDir);
                    }else {

                        SetuplogError(LogSevWarning,
                          L"Setup (PreInstall) Failed to tree copy Profiles Dir %1 to %2 (TreeCopy failed %1!u!)\r\n",
                          0, PreInstallProfilesDir, Path, Err, NULL,NULL
                          );

                    }

                }

                END_SECTION(L"Initialize user profiles (preinstall)");
            }
        }


        if( !Preinstall ) {
            //
            //  Create/upgrade the registry
            //
            BEGIN_SECTION(L"Create/upgrade registry");
            ProcessRegistryFiles(Billboard);
            END_SECTION(L"Create/upgrade registry");

            //
            // Initialize user profiles
            //
            BEGIN_SECTION(L"Initializing user profiles");
            InitializeProfiles(TRUE);
            END_SECTION(L"Initializing user profiles");
        }



        //
        // Set fonts directory to system + read only. This causes
        // explorer to treat the directory specially and allows the font
        // folder to work.
        //
        if(!GetWindowsDirectory(Path, MAX_PATH - ARRAYSIZE(L"FONTS"))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths(Path,L"FONTS",MAX_PATH,NULL);
        SetFileAttributes(Path,FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM);

        //
        // Copy some files.
        //
        if(!Upgrade) {
            BEGIN_SECTION(L"Copying System Files");
            if(!CopySystemFiles()) {
                b = FALSE;
            }
            END_SECTION(L"Copying System Files");
        } else {
            BEGIN_SECTION(L"Upgrading System Files");
            if(!UpgradeSystemFiles()) {
                b = FALSE;
            }
            END_SECTION(L"Upgrading System Files");
        }

        //
        // Install default language group
        //
        BEGIN_SECTION(L"Initializing regional settings");
        pSetupInitRegionalSettings(Billboard);
        END_SECTION(L"Initializing regional settings");

        //
        // Pickup the answer file.
        //
        if(!GetSystemDirectory(MyAnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths(MyAnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        if(_snwprintf(CmdLine,
                      ARRAYSIZE(CmdLine),
                      L"/f:\"%s\" /s:\"%s\"",
                      MyAnswerFile,
                      LegacySourcePath) < 0){
            CmdLine[ARRAYSIZE(CmdLine) - 1] = 0;
            SetuplogError(LogSevWarning,
                            L"CmdLine has been truncated due to buffer size\r\n",
                            0,
                            NULL,
                            NULL);
        }

        InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);

        //
        // If upgrade, start watching for changes to the user's
        // profile directory and the current user hive. These changes will
        // be propagated to the userdifr hive.
        // Need to be after InitializeProfiles so that Getspecialfolder is
        // pointing correctly.
        //
        if(Upgrade) {

            DWORD   reRet;
            MYASSERT( !OobeSetup );
            reRet = WatchStart(&WatchHandle);
            if(reRet != NO_ERROR) {
                WatchHandle = NULL;
            }
        } else {
            WatchHandle = NULL;
        }

        //
        // Start any requested accessibility utilities
        //
        SpStartAccessibilityUtilities(Billboard);

        //
        //  Let the network component do some cleanup before we start the pnp stuff
        //
        BEGIN_SECTION(L"Network setup initial cleanup");
        CallNetworkSetupBack("DoInitialCleanup");
        END_SECTION(L"Network setup initial cleanup");

        //
        // Do self registration of some components that may be needed during
        // setup.  This includes initialization of darwin.
        //
        BEGIN_SECTION(L"Registering Phase 1 Dlls");
        RegisterOleControls(MainWindowHandle,SyssetupInf,NULL,0,0,L"RegistrationPhase1");
        END_SECTION(L"Registering Phase 1 Dlls");

        // Call the Compatibility infs. ProcessCompatibilityInfs in turn calls
        // DoInstallComponentInfs with the unattend inf and section
        if( Upgrade )
        {
            BEGIN_SECTION(L"Processing compatibility infs (upgrade)");
            ProcessCompatibilityInfs( Billboard, INVALID_HANDLE_VALUE, 0 );
            END_SECTION(L"Processing compatibility infs (upgrade)");
        }


    } // else !MiniSetup

    TESTHOOK(519);

    //
    // We need to see if the user wants us to extend our partition.
    // We'll do it here in case the user gave us a partition that's
    // just big enough to fit on (i.e. we'd run out of disk space
    // later in gui-mode.  Some OEM will want this).
    //
    // Besides that, there isn't enough stuff in this function yet...
    //
    if(!GetSystemDirectory(MyAnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(MyAnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

    if( GetPrivateProfileString( TEXT("Unattended"),
                                 TEXT("ExtendOemPartition"),
                                 pwNull,
                                 MyAnswer,
                                 MyAnswerBufLen,
                                 MyAnswerFile ) ) {
        if( lstrcmp( pwNull, MyAnswer ) ) {
            //
            // Yep, he wants us to do it.  Go extend
            // the partition we installed on.
            //
            rc = wcstoul( MyAnswer, NULL, 10 );

            if( rc > 0 ) {
                //
                // 1 means size it maximally, any other non-0
                // number means extend by that many MB
                //
                BEGIN_SECTION(L"Extending partition");
                ExtendPartition( MyAnswerFile[0], (rc == 1) ? 0 : rc );
                END_SECTION(L"Extending partition");
            }
        }
    }

    if (!OobeSetup)
    {
        // OOBE will initialize external modules later.
        //
        // If OOBE is running, services.exe is waiting for OOBE to signal it
        // before initializing the Services Control Manager.  (This allows OOBE
        // to perform actions like change the computer name without affecting
        // services that rely on those actions.)  If initialization of an
        // external object waits for the SCM to start the system will deadlock.
        //
        InitializeExternalModules(
            TRUE,
            &OcManagerContext
            );

        TESTHOOK(520);
    }

    if( !OobeSetup ) {
        KillBillboard(Billboard);
        SetCursor( hCursor );
    }

#ifdef _OCM
    return(OcManagerContext);
#endif

#undef MyAnswerBufLen
}

VOID
InitializeExternalModules(
    BOOL                DoSetupStuff,
    PVOID*              pOcManagerContext   // optional
    )
{
    PVOID               OcManagerContext;

    pSetupWaitForScmInitialization();

    if (DoSetupStuff)
    {
        if (MiniSetup)
        {
            RunExternalUniqueness();
        }

        OcManagerContext = FireUpOcManager();
        if (NULL != pOcManagerContext)
        {
            *pOcManagerContext = OcManagerContext;
        }
    }
}


VOID
SetHibernation(
    BOOLEAN    Enable
    )
{
    NTSTATUS    Error;
    REGVALITEM RegistryItem[1];
    DWORD RegErr, d = 1;

    // Request the privilege to create a pagefile.  Oddly enough this is needed
    // to disable hibernation.
    //
    pSetupEnablePrivilege(SE_CREATE_PAGEFILE_NAME, TRUE);

    Error = NtPowerInformation ( SystemReserveHiberFile,
                         &Enable,
                         sizeof (Enable),
                         NULL,
                         0 );

    if (!NT_SUCCESS(Error)) {
        SetuplogError(LogSevWarning,
                  L"Setup failed to set hibernation as specified by the answer file (NtPowerInformation failed %1!u!)\r\n",
                  0, Error, NULL,NULL
                  );
        return;
    }

    RegistryItem[0].Data = &d;
    RegistryItem[0].Size = sizeof(d);
    RegistryItem[0].Type = REG_DWORD;
    RegistryItem[0].Name = L"HibernationPreviouslyEnabled";

    RegErr = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            RegistryItem,
            1
            );

    if(RegErr != NO_ERROR){
        SetuplogError(LogSevWarning,
                  L"Setup failed to update hibernation as specified by the answer file (SetGroupOfValues failed %1!u!)\r\n",
                  0, RegErr, NULL,NULL
                  );
    }
}

VOID
SetDefaultPowerScheme(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR      AnswerFile[MAX_PATH];
    WCHAR      Answer[MAX_PATH];
    SYSTEM_POWER_CAPABILITIES   SysPwrCapabilities;

    //
    // Figure out what the appropriate power scheme is and set it.
    //
    if (ProductType != PRODUCT_WORKSTATION) {
        //
        // Set to Always on (Servers)
        //
        SetupDebugPrint(L"Power scheme: server.");
        if (!SetActivePwrScheme(3, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    } else if (IsLaptop()) {
        //
        // Set to Portable (Laptop)
        //
        SetupDebugPrint(L"Power scheme: laptop.");
        if (!SetActivePwrScheme(1, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    } else {
        //
        // Set to Home/Office (Desktop)
        //
        SetupDebugPrint(L"Power scheme: desktop.");
        if (!SetActivePwrScheme(0, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    }


    //
    // Now take care of any hibernation settings the user may be asking us
    // to apply via the unattend file.
    //

    //
    // Pickup the answer file.
    //
    if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

    //
    // Is Hibernation specified?
    //
    if( GetPrivateProfileString( WINNT_UNATTENDED,
                                 TEXT("Hibernation"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 AnswerFile) ) {

        if( _wcsicmp( L"NO", Answer ) == 0 ) {

            SetHibernation(FALSE);
        }
        else if( _wcsicmp( L"YES", Answer ) == 0 ) {

            SetHibernation(TRUE);
        }
    }
}

VOID
SetupAddAlternateComputerName(
    PWSTR AltComputerName
)
/*++

Routine Description:

    This function adds an alternate compture name on the specified transport.

Arguments:

    Transport - Transport to add the computer name on.

    AltComputerName - Alternate computer name to add

    EmulatedDomain - Emulated Domain to add computer name on

Return Value:

    None.

TransportName - type browdeb dn to get a list of transports.
                programatically, copy GetBrowserTransportList into here.
                Once I get the list, find the first one that contains "Netbt_tcpip"
                and use that string.

EmulatedDomain, just leave it null


--*/



{
#include <ntddbrow.h>
#define             LDM_PACKET_SIZE (sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR))
    HANDLE              BrowserHandle;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    NTSTATUS            Status;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    LPBYTE              Where;
    PLMDR_TRANSPORT_LIST TransportList = NULL,
                        TransportEntry = NULL;

extern NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

extern NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );

    //
    // Open a browser handle.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);
    InitializeObjectAttributes( &ObjectAttributes,
                                &DeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( &BrowserHandle,
                         SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( NT_SUCCESS(Status) ) {

        RequestPacket = MyMalloc( LDM_PACKET_SIZE );
        if( !RequestPacket ) {
            NtClose( BrowserHandle );
            return;
        }

        ZeroMemory( RequestPacket, LDM_PACKET_SIZE );

        //
        // Get a transport name.
        //
        RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

        RequestPacket->Type = EnumerateXports;

        RtlInitUnicodeString(&RequestPacket->TransportName, NULL);
        RtlInitUnicodeString(&RequestPacket->EmulatedDomainName, NULL);

        Status = DeviceControlGetInfo( BrowserHandle,
                                       IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                                       RequestPacket,
                                       LDM_PACKET_SIZE,
                                       (PVOID *)&TransportList,
                                       0xffffffff,
                                       4096,
                                       NULL );

        if( NT_SUCCESS(Status) ) {

            //
            // Nuke the transport name in the request packet just to be safe.
            //
            RequestPacket->TransportName.Buffer = NULL;

            //
            // Now figure out which entry in the transport list is the
            // one we want.
            //
            TransportEntry = TransportList;
            while( TransportEntry != NULL ) {
                _wcslwr( TransportEntry->TransportName );
                if( wcsstr(TransportEntry->TransportName, L"netbt_tcpip") ) {
                    //
                    // Got it.
                    //
                    RequestPacket->TransportName.Buffer = TransportEntry->TransportName;
                    RequestPacket->TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
                    break;
                }

                //
                // Look at the next entry.
                //
                if (TransportEntry->NextEntryOffset == 0) {
                    TransportEntry = NULL;
                } else {
                    TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
                }
            }

            if( RequestPacket->TransportName.Buffer ) {

                //
                // Prepare a packet to send him.
                //
                RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION;
                RtlInitUnicodeString(&RequestPacket->EmulatedDomainName, NULL);
                RequestPacket->Parameters.AddDelName.Type = AlternateComputerName;
                RequestPacket->Parameters.AddDelName.DgReceiverNameLength = min( wcslen(AltComputerName)*sizeof(WCHAR),
                                                                                 LM20_CNLEN*sizeof(WCHAR));
                wcsncpy(RequestPacket->Parameters.AddDelName.Name, AltComputerName,LM20_CNLEN+1);
                RequestPacket->Parameters.AddDelName.Name[LM20_CNLEN] = (WCHAR)L'\0';
                Where = ((LPBYTE)(RequestPacket->Parameters.AddDelName.Name)) +
                        RequestPacket->Parameters.AddDelName.DgReceiverNameLength +
                        sizeof(WCHAR);

                Status = BrDgReceiverIoControl( BrowserHandle,
                                                IOCTL_LMDR_ADD_NAME_DOM,
                                                RequestPacket,
                                                (DWORD)(Where - (LPBYTE)RequestPacket),
                                                NULL,
                                                0,
                                                NULL );
            }

        }

        MyFree( RequestPacket );

        NtClose( BrowserHandle );
    }
}



BOOL
RestoreBootTimeout(
    VOID
    )
{
    WCHAR       AnswerFile[MAX_PATH];
    WCHAR       Answer[50];
    DWORD       Val;


    //
    // Pickup the answer file.
    //
    if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

    //
    // Is boot timeout specified?
    //
    if( GetPrivateProfileString( TEXT("SetupData"),
                                 WINNT_S_OSLOADTIMEOUT,
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            Val = wcstoul(Answer,NULL,10);
        } else {
            Val = 30;
        }
    } else {
        Val = 30;
    }

    return ChangeBootTimeout(Val);
}



VOID
PrepareForNetSetup(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL b = TRUE;


    //
    // Create Windows NT software key entry
    //
    // if(!MiniSetup && !CreateWindowsNtSoftwareEntry(TRUE)) {
    //     b = FALSE;
    // }
    //
    // Create InstallDate value entry in Windows NT software key.
    // This has to happen after the Date/Time wizard page was executed, when the user can
    // no longer go back to that page.
    //
    if(!CreateInstallDateEntry()) {
        b = FALSE;
    }
    if(!SetProductIdInRegistry()) {
        b = FALSE;
    }
    if(!StoreNameOrgInRegistry( NameOrgName, NameOrgOrg )) {
        b = FALSE;
    }
    if(!MiniSetup && !SetEnabledProcessorCount()) {
        b = FALSE;
    }

    if( (!MiniSetup && !SetAccountsDomainSid(0,Win32ComputerName)) ||
        (!SetComputerNameEx(ComputerNamePhysicalDnsHostname, ComputerName)) ) {

        //
        // Set account domain sid, as well as the computer name.
        // Also create the sam event that SAM will use to signal us
        // when it's finished initializing.
        // Any failures here are fatal.
        //

        FatalError(MSG_LOG_SECURITY_CATASTROPHE,0,0);
    }

    if( !RestoreBootTimeout() ){
        SetupDebugPrint( L"Setup: (non-critical error) Failed to restore boot timeout values\n" );
    }



#ifndef _WIN64
    //
    // Install netdde
    //
    if(!InstallNetDDE()) {
        b = FALSE;
    }
#endif
    SetUpDataBlock();

    //
    // In the case of MiniSetup, we're about to go into the
    // networking wizard pages.  Remember though that lots of
    // our default components have already been installed.  This
    // means that they won't be re-installed, which means the
    // related services won't be started.  Network setup isn't
    // smart enough to check to see if these services are started
    // before proceeding (which results in his failure).  To get
    // around that, we'll start the services right here.
    //
    // Currently, here's what we need to start:
    // tcpip
    // dhcp
    // dnscache
    // Netman
    // lmhosts
    // LanmanWorkstation
    //
    if( MiniSetup ) {

        SetupStartService( L"tcpip", FALSE );
        SetupStartService( L"dhcp", FALSE );
        SetupStartService( L"dnscache", FALSE );
        SetupStartService( L"Netman", FALSE );
        SetupStartService( L"lmhosts", FALSE );
        SetupStartService( L"LanmanWorkstation", TRUE );

        //
        // HACK: fix up the computername before we go off and
        // try and join a domain.
        //
        SetupAddAlternateComputerName( ComputerName );
    }


    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PREPARE_NET_FAILED,
            NULL,NULL);
    }
}


VOID
PrepareForNetUpgrade(
    VOID
    )
{
    BOOL b = TRUE;


    if( !RestoreBootTimeout() ){
        SetupDebugPrint( L"Setup: (non-critical error) Failed to restore boot timeout values\n" );
    }

    // if(!CreateWindowsNtSoftwareEntry(TRUE)) {
    //     b = FALSE;
    // }
    //
    // Create InstallDate value entry in Windows NT software key.
    // This has to happen after the Date/Time wizard page was executed, when the user can
    // no longer go back to that page.
    //
    if(!CreateInstallDateEntry()) {
        b = FALSE;
    }
    if(!SetEnabledProcessorCount()) {
        b = FALSE;
    }

    SetUpDataBlock();

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PREPARE_NET_FAILED,
            NULL,NULL);
    }
}


VOID
ProcessShellAndIEHardeningUnattendSettings(
    VOID
    )
{
    WCHAR PathBuffer[MAX_PATH];

    if (!GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
        return;
    }

    pSetupConcatenatePaths(PathBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

    // parse the [Shell] section
    SetupShellSettings(PathBuffer, TEXT("Shell"));
    
    // parse the [IEHardening] section
    SetupIEHardeningSettings(PathBuffer, TEXT("IEHardening"));
}

BOOL
SetupShellSettings(
    LPCWSTR lpszUnattend,
    LPCWSTR lpszSection
    )
{
    BOOL  bRet = TRUE;
    DWORD dwError;
    WCHAR Answer[MAX_PATH];

    // Check the "DefaultStartPanelOff" key to see if the user wants to have the
    // start panel off by default
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("DefaultStartPanelOff"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 lpszUnattend) ) {
        if ( ( lstrcmpi( pwYes, Answer ) == 0 ) || ( lstrcmpi( pwNo, Answer ) == 0 ) ) {
            HKEY hkStartPanel;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartMenu\\StartPanel"),
                               &hkStartPanel ) == ERROR_SUCCESS ) {
                DWORD dwData;

                if ( lstrcmpi( pwYes, Answer ) == 0 )
                {
                    dwData = 1;
                }
                else
                {
                    dwData = 0;
                }

                dwError = RegSetValueEx( hkStartPanel,
                                         TEXT("DefaultStartPanelOff"),
                                         0,
                                         REG_DWORD,
                                         (BYTE*)&dwData,
                                         sizeof(dwData) );

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set DefaultStartPanelOff reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkStartPanel );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create StartPanel reg key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    // Check the "DefaultThemesOff" key to see if the user wants to not apply themes by default
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("DefaultThemesOff"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 lpszUnattend) ) {
        if ( ( lstrcmpi( pwYes, Answer ) == 0 ) || ( lstrcmpi( pwNo, Answer ) == 0 ) ) {
            HKEY hkThemes;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes"),
                               &hkThemes ) == ERROR_SUCCESS ) {
                BOOL bYes;

                if ( lstrcmpi( pwYes, Answer ) == 0)
                {
                    bYes = TRUE;
                }
                else
                {
                    bYes = FALSE;
                }

                dwError = RegSetValueEx( hkThemes,
                                         TEXT("NoThemeInstall"),
                                         0,
                                         REG_SZ,
                                         (BYTE*)(bYes ? TEXT("TRUE") : TEXT("FALSE")),  // needs to be reg_sz "TRUE" or "FALSE" string
                                         bYes ? sizeof(TEXT("TRUE")) : sizeof(TEXT("FALSE")) );

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set NoThemeInstall reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkThemes );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create Themes key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    // See if the user has specified a "CustomInstalledTheme" which we will apply by default to all users
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("CustomDefaultThemeFile"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 lpszUnattend) ) {
        if ( lstrcmpi( pwNull, Answer ) != 0 ) {
            HKEY hkThemes;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes"),
                               &hkThemes ) == ERROR_SUCCESS ) {
                dwError = RegSetValueEx( hkThemes,
                                         TEXT("CustomInstallTheme"),
                                         0,
                                         REG_EXPAND_SZ,
                                         (BYTE*)Answer,
                                         (lstrlen(Answer) + 1) * sizeof(TCHAR));

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set CustomInstallTheme reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkThemes );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create Themes key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    return bRet;
}


BOOL
WalkUrlList(
    LPWSTR pszUrls,
    LPCWSTR pszRegPath
    )
{
    BOOL bRet = FALSE;
    HKEY hkey;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       pszRegPath,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_SET_VALUE,
                       NULL,
                       &hkey,
                       NULL) == ERROR_SUCCESS)
    {
        int iValueName = 0;
        WCHAR szValueName[MAX_PATH];

        while (*pszUrls)
        {
            LPWSTR pszTemp = wcschr(pszUrls, TEXT(';'));
            if (pszTemp)
            {
                *pszTemp = TEXT('\0');
            }
            
            if (SUCCEEDED(StringCchPrintf(szValueName, ARRAYSIZE(szValueName), TEXT("Url%d"), iValueName)))
            {
                // write a value out represnting this url
                if (RegSetValueEx(hkey,
                                  szValueName,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszUrls,
                                  (lstrlen(pszUrls) + 1) * sizeof(WCHAR)) == ERROR_SUCCESS)
                {
                    bRet = TRUE;
                }
                else
                {
                    SetuplogError(LogSevWarning,
                                  L"SETUP: SetupIEHardeningSettings() failed to write url value!\r\n",
                                  0, NULL, NULL);
                }

            }
            else
            {
                SetuplogError(LogSevWarning,
                              L"SETUP: SetupIEHardeningSettings() failed create url name string!\r\n",
                              0, NULL, NULL);
            }

            // move to the next url
            pszUrls += lstrlen(pszUrls) + 1;
            iValueName++;
        }

        RegCloseKey(hkey);
    }
    else
    {
        SetuplogError(LogSevWarning,
                      L"SETUP: SetupIEHardeningSettings() failed in to create url key!\r\n",
                      0, NULL, NULL);
    }

    return bRet;
}


BOOL
SetupIEHardeningSettings(
    LPCWSTR lpszUnattend,
    LPCWSTR lpszSection
    )
{
    BOOL  bRet = FALSE;
    DWORD cchUrls = (INTERNET_MAX_URL_LENGTH * 128) + 1;    // room for ~128 urls
    LPWSTR pszUrls = (LPWSTR)LocalAlloc(LPTR, cchUrls * sizeof(WCHAR));

    if (pszUrls)
    {
        if( GetPrivateProfileString( lpszSection,
                                     TEXT("TrustedSites"),
                                     pwNull,
                                     pszUrls,
                                     cchUrls,
                                     lpszUnattend) )
        {
            // we have a semicolon delimited list of urls that need to go into the trusted sites section of HKLM,
            // to be processed later by the IEHardening active setup code
            bRet = WalkUrlList(pszUrls, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Unattend\\TrustedSites"));
        }

        if( GetPrivateProfileString( lpszSection,
                                     TEXT("LocalIntranetSites"),
                                     pwNull,
                                     pszUrls,
                                     cchUrls,
                                     lpszUnattend) )
        {
            // we have a semicolon delimited list of urls that need to go into the local intranet sites section of HKLM,
            // to be processed later by the IEHardening active setup code
            bRet = WalkUrlList(pszUrls, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Unattend\\LocalIntranetSites"));
        }

        LocalFree(pszUrls);
    }
    else
    {
        SetuplogError(LogSevWarning,
                      L"SETUP: SetupIEHardeningSettings() failed in to allocate pszUrls!\r\n",
                      0, NULL, NULL);
    }

    return bRet;
}


VOID
ConfigureSetup(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    UINT GaugeRange;
    BOOL b;
    DWORD dwSize;
    WCHAR TempString[MAX_PATH];
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR AnswerFile[4*MAX_PATH];
    WCHAR Answer[4*MAX_PATH];

    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;
    DWORD StartType = SERVICE_DISABLED;

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionExW((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));

    //
    // Initialize the progress indicator control.
    //
    if( !OobeSetup ) {
        GaugeRange = (17*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, 17, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    MYASSERT(!Upgrade);
    b = TRUE;


    if(!MiniSetup ) {

        //
        // Create config.nt/autoexec.nt.
        //
        if( !ConfigureMsDosSubsystem() ) {
            SetupDebugPrint( L"SETUP: ConfigureMsDosSubsystem failed" );
            b = FALSE;
        }


        //
        // Make the appropriate entries for wow.
        //
        // Note, we no longer need to make WOW key for ntvdm.  To keep the number
        // of StepIt messages the same, we leave the SendMessage call alone.
        SendMessage(hProgress,PBM_STEPIT,0,0);
        //if( !MakeWowEntry() ) {
        //    SetupDebugPrint( L"SETUP: MakeWowEntry failed" );
        //    b = FALSE;
        //}


        SendMessage(hProgress,PBM_STEPIT,0,0);
        CallSceConfigureServices();


        //
        // Enable and start the spooler.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if( !MyChangeServiceStart(szSpooler,SERVICE_AUTO_START) ) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart failed" );
            b = FALSE;
        }


        if( !StartSpooler() ) {
            SetupDebugPrint( L"SETUP: StartSpooler failed" );
            b = FALSE;
        }


        //
        // Set up program groups.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if(!CreateStartMenuItems(SyssetupInf)) {
            SetupDebugPrint( L"SETUP: CreateStartMenuItems failed" );
            b = FALSE;
        }

        //
        // Change some service start values.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if(!MyChangeServiceStart(L"EventLog",SERVICE_AUTO_START)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(EventLog) failed" );
            b = FALSE;
        }

        if( ProductType == PRODUCT_WORKSTATION ) {
            StartType = SERVICE_DEMAND_START;
        }

        if(!MyChangeServiceStart(L"ClipSrv",StartType)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(ClipSrv) failed" );
            b = FALSE;
        }
        if(!MyChangeServiceStart(L"NetDDE",StartType)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDE) failed" );
            b = FALSE;
        }
        if(!MyChangeServiceStart(L"NetDDEdsdm",StartType)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDEdsdm) failed" );
            b = FALSE;
        }

        // Moved Admin Password code to wizard

        SendMessage(hProgress,PBM_STEPIT,0,0);

    }



    //
    // Don't bother with the Autologon stuff if the user provided an encrypted password in the unattend file
    //

    if(  !fPersonalSKU || Win95Upgrade ){

        if( !EncryptedAdminPasswordSet ){

            if (Unattended && UnattendAnswerTable[UAE_AUTOLOGON].Answer.String &&
                lstrcmpi(UnattendAnswerTable[UAE_AUTOLOGON].Answer.String,pwYes)==0) {
                GetAdminAccountName( adminName );
                if (!SetAutoAdminLogonInRegistry(adminName,AdminPassword)) {
                    SetupDebugPrint( L"SETUP: SetAutoAdminLogonInRegistry failed" );
                    b = FALSE;
                }
            }
        }
    }

    //
    // For OobeSetup, OOBE has just run and manage new account creation
    //

    if ( fPersonalSKU && !OobeSetup )
    {
        WCHAR    OwnerName[MAX_USERNAME+1];
        NTSTATUS OwnerCreated = STATUS_UNSUCCESSFUL;
        WCHAR    PathBuffer[MAX_PATH];

        if (LoadString(MyModuleHandle, IDS_OWNER, OwnerName, ARRAYSIZE(OwnerName)))
        {
            OwnerCreated = CreateLocalAdminAccount(OwnerName,TEXT(""),NULL);

            if(OwnerCreated){
                DeleteOnRestartOfGUIMode(OwnerName);
            }

            SetupDebugPrint2(
                L"SETUP: CreateLocalAdminAccount %s NTSTATUS(%d)",
                OwnerName,
                OwnerCreated
                );
        }
        else
        {
            SetupDebugPrint( L"SETUP: Failed LoadString on IDS_OWNER" );
        }

        if (GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(TEXT("oobe\\oobeinfo.ini"))))
        {
            pSetupConcatenatePaths(
                PathBuffer,
                TEXT("oobe\\oobeinfo.ini"),
                MAX_PATH,
                NULL
                );

            WritePrivateProfileString(
                TEXT("Options"),
                TEXT("RemoveOwner"),
                (OwnerCreated == STATUS_SUCCESS) ? TEXT("1") : TEXT("0"),
                PathBuffer
                );
        }
        else{
            MYASSERT(FALSE);
        }
    }

#ifdef DOLOCALUSER
    if(CreateUserAccount) {
        if(!CreateLocalUserAccount(UserName,UserPassword,NULL)) {
            SetupDebugPrint( L"SETUP: CreateLocalUserAccount failed" );
            b = FALSE;
        }
        else {
            DeleteOnRestartOfGUIMode(UserName);
        }
    }
#endif


    //
    // Set temp/tmp variables.
    //

    if(!MiniSetup){
        SendMessage(hProgress,PBM_STEPIT,0,0);
        lstrcpy(TempString, L"%SystemRoot%\\TEMP");
        SetEnvironmentVariableInRegistry(L"TEMP",TempString,TRUE);
        SetEnvironmentVariableInRegistry(L"TMP",TempString,TRUE);


#ifdef _X86_
        //
        // Set NPX emulation state.
        //
        if( !SetNpxEmulationState() ) {
            SetupDebugPrint( L"SETUP: SetNpxEmulationState failed" );
            b = FALSE;
        }
#endif // def _X86_


        BEGIN_SECTION(L"Loading service pack (phase 4)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_4, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 4)");
    }


    //
    // Call the network setup back to handle Internet Server issues.
    //
    BEGIN_SECTION(L"Network setup handling Internet Server issues");
    SendMessage(hProgress,PBM_STEPIT,0,0);
    CallNetworkSetupBack(NETSETUPINSTALLSOFTWAREPROCNAME);
    if (!MiniSetup && RemoteBootSetup) {
        SetStartTypeForRemoteBootDrivers();
    }
    END_SECTION(L"Network setup handling Internet Server issues");


    //
    // Stamp build number
    //
    if( !MiniSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
        StampBuildNumber();

        //
        // Set some misc stuff in win.ini
        //
        if( !WinIniAlter1() ) {
            SetupDebugPrint( L"SETUP: WinIniAlter1 failed" );
            b = FALSE;
        }

        //
        // Fonts.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        pSetupMarkHiddenFonts();

        //
        // Set up pagefile and crashdump.
        //
        BEGIN_SECTION(L"Setting up virtual memory");

        SendMessage(hProgress,PBM_STEPIT,0,0);

        if( !SetUpVirtualMemory() ) {
            SetupDebugPrint( L"SETUP: SetUpVirtualMemory failed" );
            b = FALSE;
        }
        END_SECTION(L"Setting up virtual memory");


        if( !SetShutdownVariables() ) {
            SetupDebugPrint( L"SETUP: SetShutdownVariables failed" );
            b = FALSE;
        }

        //
        // run any programs
        //
        BEGIN_SECTION(L"Processing [RunPrograms] section");
        RunSetupPrograms(SyssetupInf,L"RunPrograms");
        END_SECTION(L"Processing [RunPrograms] section");

        //
        //Brand IE for clean unattended installs.
        //This should be called before the default user hive is saved.
        //
        BrandIE();

    } else {
        //
        // See if it's okay to reset the pagefile for the MiniSetup case.
        //
        if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);
        GetPrivateProfileString( TEXT("Unattended"),
                                 TEXT("KeepPageFile"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 AnswerFile );
        if( !lstrcmp( pwNull, Answer ) ) {

            if( !SetUpVirtualMemory() ) {
                SetupDebugPrint( L"SETUP: SetUpVirtualMemory failed" );
                b = FALSE;
            }
        }
    }

    //
    // Set the default power scheme.  Note that this must be done before saving
    // the userdef hive.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    SetDefaultPowerScheme();


    //
    // There's nothing specific to preinstall about cmdlines.txt.
    // In retail cases the file simply won't exit. Calling this in
    // all cases simplifies things for some people out there.
    //
    // We need to do this here so that if the user has commands
    // that populate the user's hive, they'll get pushed down
    // into default hive.
    //
    if(!ExecutePreinstallCommands()) {
        SetupDebugPrint( L"ExecutePreinstallCommands() failed" );
    }


    //
    // Save off the userdef hive. Don't change the ordering here
    // unless you know what you're doing!
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Saving hives");
        dwSize = MAX_PATH - ARRAYSIZE(L"NTUSER.DAT");
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if (GetDefaultUserProfileDirectory(TempString, &dwSize)) {
            pSetupConcatenatePaths(TempString,L"NTUSER.DAT",MAX_PATH,NULL);
            if(!SaveHive(HKEY_USERS,L".DEFAULT",TempString,REG_STANDARD_FORMAT)) { // standard format as it can be used for roaming
                SetupDebugPrint( L"SETUP: SaveHive failed" );
                b = FALSE;
            }
            SetFileAttributes (TempString, FILE_ATTRIBUTE_HIDDEN);
        } else {
            SetupDebugPrint( L"SETUP: GetDefaultUserProfileDirectory failed" );
            b = FALSE;
        }
        END_SECTION(L"Saving hives");
    } else {
        BEGIN_SECTION(L"Fixing up hives");
        //
        // This is the MiniSetup case.  We're going to surgically
        // place some values from the default hive into all the
        // user profiles.
        //
        FixupUserHives();
        END_SECTION(L"Fixing up hives");
    }


    //
    // Set wallpaper and screen saver.
    //
    if( !MiniSetup ) {

        SendMessage(hProgress,PBM_STEPIT,0,0);
        if( !SetDefaultWallpaper() ) {
            SetupDebugPrint( L"SETUP: SetDefaultWallpaper failed" );
            b = FALSE;
        }

        if( !SetLogonScreensaver() ) {
            SetupDebugPrint( L"SETUP: SetLogonScreensaver failed" );
            b = FALSE;
        }

        BEGIN_SECTION(L"Copying optional directories");
        if( !CopyOptionalDirectories() ) {
            SetupDebugPrint( L"SETUP: CopyOptionalDirectories failed" );
            b = FALSE;
        }
        END_SECTION(L"Copying optional directories");

        SendMessage(hProgress,PBM_STEPIT,0,0);

        if(!b) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FINISH_SETUP_FAILED,
                NULL,NULL);
        }

    }
}


VOID
ConfigureUpgrade(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    UINT GaugeRange;
    BOOL b;
    DWORD dwSize;
    WCHAR TempString[MAX_PATH];
    DWORD DontCare;
    DWORD VolumeFreeSpaceMB[26];
    DWORD TType, TLength, ret;
    PWSTR TData;

    //
    // Initialize the progress indicator control.
    //
    GaugeRange = (12*100/(StopAtPercent-StartAtPercent));
    SendMessage(hProgress, WMX_PROGRESSTICKS, 12, 0);
    SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(hProgress,PBM_SETSTEP,1,0);

    MYASSERT(Upgrade);
    b = TRUE;


    //
    // Create config.sys/autoexec.bat/msdos.sys/io.sys, if they
    // don't already exist
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!ConfigureMsDosSubsystem()) {
        SetupDebugPrint( L"SETUP: ConfigureMsDosSubsystem failed" );
        b = FALSE;
    }

    if(!FixQuotaEntries()) {
        SetupDebugPrint( L"SETUP: FixQuotaEntries failed" );
        b = FALSE;
    }
    if(!InstallOrUpgradeFonts()) {
        SetupDebugPrint( L"SETUP: InstallOrUpgradeFonts failed" );
        b = FALSE;
    }
    pSetupMarkHiddenFonts();
    //
    //  Restore the page file information saved during textmode setup.
    //  Ignore any error, since there is nothing that the user can do.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    SetUpVirtualMemory();
    if(!SetShutdownVariables()) {
        SetupDebugPrint( L"SETUP: SetShutdownVariables failed" );
        b = FALSE;
    }

    //
    // Get list of free space available on each hard drive.  We don't care
    // about this, but it has the side effect of deleting all pagefiles,
    // which we do want to do.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    BuildVolumeFreeSpaceList(VolumeFreeSpaceMB);

    //
    // Upgrade program groups.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!UpgradeStartMenuItems(SyssetupInf)) {
        SetupDebugPrint( L"SETUP: UpgradeStartMenuItems failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!MyChangeServiceStart(szSpooler,SERVICE_AUTO_START)) {
        SetupDebugPrint( L"SETUP: MyChangeServiceStart failed" );
        b = FALSE;
    }

    SetUpDataBlock();
    DontCare = UpgradePrinters();
    if(DontCare != NO_ERROR) {
        SetupDebugPrint( L"SETUP: UpgradePrinters failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( !UpdateServicesDependencies(SyssetupInf) ) {
        SetupDebugPrint( L"SETUP: UpdateServicesDependencies failed" );
        b = FALSE;
    }

    //
    // Set temp/tmp variables for upgrades.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);

    // Look for Environment variable TEMP (we assume that TEMP and TMP appear together)
    // Will not be present on NT4 upgrades

    ret = QueryValueInHKLM( L"System\\CurrentControlSet\\Control\\Session Manager\\Environment",
                      L"TEMP",
                      &TType,
                      (PVOID)&TData,
                      &TLength);

    if( ret != NO_ERROR ){  //only when the TEMP variable is not defined (<=NT4 upgrades)
        lstrcpy(TempString,L"%SystemDrive%\\TEMP");  // On NT4 use %SystemDrive%
        SetEnvironmentVariableInRegistry(L"TEMP",TempString,TRUE);
        SetEnvironmentVariableInRegistry(L"TMP",TempString,TRUE);

    }

    if( ProductType != PRODUCT_WORKSTATION ) {

        if(!MyChangeServiceStart(L"ClipSrv",SERVICE_DISABLED)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(ClipSrv) failed" );
        }
        if(!MyChangeServiceStart(L"NetDDE",SERVICE_DISABLED)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDE) failed" );
        }
        if(!MyChangeServiceStart(L"NetDDEdsdm",SERVICE_DISABLED)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDEdsdm) failed" );
        }
    }


#ifdef _X86_
    //
    // Set NPX emulation state.
    //
    if(!SetNpxEmulationState()) {
        SetupDebugPrint( L"SETUP: SetNpxEmulationState failed" );
        b = FALSE;
    }
#endif // def _X86_

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!SetProductIdInRegistry()) {
        SetupDebugPrint( L"SETUP: SetProductIdInRegistry failed" );
        b = FALSE;
    }

    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 4)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_4, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 4)");
    }

    CallNetworkSetupBack(NETSETUPINSTALLSOFTWAREPROCNAME);
    if (RemoteBootSetup) {
        SetStartTypeForRemoteBootDrivers();
    }

    //
    // Stamp build number
    //

    SendMessage(hProgress,PBM_STEPIT,0,0);
    StampBuildNumber();

    //
    //  UpgradeRegistrySecurity();
    //

    //
    // Set the default power scheme.  Note that this must be done before saving
    // the userdef hive.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    SetDefaultPowerScheme();

    //
    // Save off the userdef hive. Don't change the ordering here
    // unless you know what you're doing!
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);

    dwSize = MAX_PATH - ARRAYSIZE(L"NTUSER.DAT");
    if (GetDefaultUserProfileDirectory(TempString, &dwSize)) {
        pSetupConcatenatePaths(TempString, L"NTUSER.DAT", MAX_PATH, NULL);
        if(!SaveHive(HKEY_USERS,L".DEFAULT",TempString,REG_STANDARD_FORMAT)) { // standard format as it can be used for roaming
            SetupDebugPrint( L"SETUP: SaveHive failed" );
            b = FALSE;
        }
        SetFileAttributes (TempString, FILE_ATTRIBUTE_HIDDEN);
    } else {
        SetupDebugPrint( L"SETUP: GetDefaultUserProfileDirectory failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);

    if(!CopyOptionalDirectories()) {
        SetupDebugPrint( L"SETUP: CopyOptionalDirectories failed" );
        b = FALSE;
    }

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FINISH_SETUP_FAILED,
            NULL,NULL);
    }
}


VOID
ConfigureCommon(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    UINT GaugeRange;
    int i;



    //
    // Initialize the progress indicator control.
    //
    if( !OobeSetup ) {
        GaugeRange = (5*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, 5, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    //
    // Install extra code pages on servers
    //
    if( !MiniSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);

        //
        // Process the [Shell] and [IEHardening] Section of the unattend file
        //
        ProcessShellAndIEHardeningUnattendSettings();

        if( !(ProductType == PRODUCT_WORKSTATION) ) {
            InstallServerNLSFiles(MainWindowHandle);
        }

        //
        // Do the SCE GenerateTemplate stuff
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        BEGIN_SECTION(L"Generating security templates");
        CallSceGenerateTemplate();
        END_SECTION(L"Generating security templates");


        //
        // Try a call out to DcPromoSaveDcStateForUpgrade()...
        //
        if( ISDC(ProductType) && Upgrade ) {
        typedef     DWORD (*DCPROC) ( LPCWSTR );
        HMODULE     DCPromoHandle;
        DCPROC      MyProc;
        DWORD       Result;
        BOOL        Success = TRUE;

            //
            // We need to call out to dcpromo!DcPromoSaveDcStateForUpgrade.
            // Load dcpromo.dll, lookup DcPromoSaveDcStateForUpgrade and
            // call out to him.
            //

            __try {
                if( DCPromoHandle = LoadLibrary(L"DCPROMO") ) {

                  if( MyProc = (DCPROC)GetProcAddress(DCPromoHandle,"DcPromoSaveDcStateForUpgrade")) {

                        Result = MyProc( NULL );
                        if( Result != ERROR_SUCCESS ) {
                            Success = FALSE;
                            SetupDebugPrint1( L"Setup: (non-critical error) Failed call DcPromoSaveDcStateForUpgrade (%lx.\n", Result );
                        }
                    } else {
                        Success = FALSE;
                        SetupDebugPrint( L"Syssetup: (non-critical error) Failed GetProcAddress on DcPromoSaveDcStateForUpgrade.\n" );
                    }
                } else {
                    Success = FALSE;
                    SetupDebugPrint( L"Syssetup: (non-critical error) Failed load of dcpromo.dll.\n" );
                }
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                Success = FALSE;
                SetupDebugPrint( L"Setup: Exception in dcpromo!DcPromoSaveDcStateForUpgrade\n" );
            }

            if( !Success ) {
                //
                // We failed the call (for whatever reason).  Treat
                // this as a fatal error.
                //
                FatalError( MSG_DCPROMO_FAILURE, 0, 0 );
            }

        }

        //
        // Fix up permissions/attributes on some files.
        //
        pSetInstallAttributes();

        //
        // Set the read-only attribute on some files.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        MarkFilesReadOnly();
    }


    //
    // Fix up the legacy install source.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    CreateWindowsNtSoftwareEntry(FALSE);


    //
    // Now put the GuiRunOnce section into the registry.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    GetUnattendRunOnceAndSetRegistry();


}


VOID
SFCCheck(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
/*++

Routine Description:

    This routine calls into WFP (WFP == SFC) to scan all files on the system to
    ensure that the files are all valid.  The routine also populates the WFP
    "dllcache", which is a local store of files on the system.

Arguments:

    hProgress      - progress window for updating a gas guage "tick count".
    StartAtPercent - where to start on the gas guage
    StopAtPercent  - Where to stop on the gas guage

Return Value:

    None.

--*/
{
    PPROTECT_FILE_ENTRY Files;
    ULONG               FileCount;
    DWORD               GaugeRange;
    WCHAR       AnswerFile[4*MAX_PATH];
    WCHAR       Answer[4*MAX_PATH];
    DWORD       d;
    DWORD   l;
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;


    //
    // determine how big to make the dllcache by looking at the
    // SFCQuota unattend value, otherwise use the below default.
    //



#if 0
    d = (ProductType == PRODUCT_WORKSTATION)
         ? SFC_QUOTA_DEFAULT
         : 0xffffffff;
#else
    d = 0xffffffff;
#endif

    //
    // SFCQuota unattend value?
    //

    if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCQuota"),
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,16);
        }
    }

    //
    // Get the total file count
    //
    if (SfcGetFiles( &Files, &FileCount ) == STATUS_SUCCESS) {

        //
        // Initialize the progress indicator control.
        //
        GaugeRange = ((FileCount)*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, FileCount, 0);
        SendMessage( hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,GaugeRange) );
        SendMessage( hProgress, PBM_SETPOS, GaugeRange*StartAtPercent/100, 0 );
        SendMessage( hProgress, PBM_SETSTEP, 1, 0 );

        //
        // check the files
        //
        SfcInitProt(
            SFC_REGISTRY_OVERRIDE,
            SFC_DISABLE_SETUP,
            SFC_SCAN_ALWAYS,
            d,
            hProgress,
            SourcePath,
            EnumPtrSfcIgnoreFiles.Start
            );
    }

    //
    // Free our list of files that Sfc scan should ignore.
    //
    if (EnumPtrSfcIgnoreFiles.Start) {
        MultiSzFree(&EnumPtrSfcIgnoreFiles);
    }


    // also set the "allowprotectedrenames" registry key so that the next boot
    // after gui-mode setup allows any pending rename operations to occur.
    // We do this for performance reasons -- if we aren't looking at the rename
    // operations, it speeds up boot time.  We can do this for the gui-setup
    // case because we trust the copy operations occuring during gui-setup.



    //
    // Open the key
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                     0,
                     KEY_ALL_ACCESS,
                     &hKey );

    if(l == NO_ERROR) {
       d = 1;
       //
       // Write AllowProtectedRenames.
       //
       l = RegSetValueEx(hKey,
                       TEXT("AllowProtectedRenames"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&d,
                       sizeof(DWORD) );


       RegCloseKey(hKey);
    }

}


VOID
ExecuteUserCommand (
    HWND hProgress
    )
{
    WCHAR PathBuffer[4*MAX_PATH];
    DWORD d;
    DWORD Result;

    //
    // Execute user-specified command, if any.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    if(UserExecuteCmd) {

        //
        // Set current directory to %windir%
        //
        Result = GetWindowsDirectory(PathBuffer, MAX_PATH);
        if(Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        if(!SetCurrentDirectory(PathBuffer)){
            MYASSERT(FALSE);
        }

        ExpandEnvironmentStrings(
            UserExecuteCmd,
            PathBuffer,
            ARRAYSIZE(PathBuffer)
            );

        InvokeExternalApplication(NULL,PathBuffer,(PDWORD)&d);
    }
}


BOOL
CALLBACK
pExceptionPackageInstallationCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++
Routine Description:

    This callback routine creates a child process to register the specified
    exception package on the system.

Arguments:

    SetupOsComponentData - specifies component ID information
    SetupOsExceptionData - specifies component migration information
    Context              - context pointer from calling function

Return Value:

    TRUE indicates that the exception package was successfully applied.

--*/
{
    PEXCEPTION_MIGRATION_CONTEXT EMC = (PEXCEPTION_MIGRATION_CONTEXT) Context;
    DWORD RetVal;
    WCHAR Cmdline[MAX_PATH*2];
    PWSTR GuidString;

    #define COMPONENT_PACKAGE_TIMEOUT  60*1000*10  //ten minutes

    StringFromIID( &SetupOsComponentData->ComponentGuid, &GuidString);

    SetupDebugPrint5( L"Exception Package #%d\r\nComponent Data\r\n\tName: %ws\r\n\tGuid: %ws\r\n\tVersionMajor: %d\r\n\tVersionMinor: %d",
             EMC->Count,
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    SetupDebugPrint2( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    EMC->Count += 1;

    //
    // make sure the signature of the inf validates against the supplied catalog before
    // installing the package.
    //
    RetVal = pSetupVerifyFile(
                NULL,
                SetupOsExceptionData->CatalogFileName,
                NULL,
                0,
                pSetupGetFileTitle(SetupOsExceptionData->ExceptionInfName),
                SetupOsExceptionData->ExceptionInfName,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                NULL
                );

    if (RetVal == ERROR_SUCCESS) {
        int i;

        //
        // Build the cmdline to install the package.
        //
        Cmdline[0] = 0;
        i = _snwprintf( Cmdline,
                        ARRAYSIZE(Cmdline),
                        L"%ws,DefaultInstall,1,N",
                        SetupOsExceptionData->ExceptionInfName);

        Cmdline[ARRAYSIZE(Cmdline) - 1] = 0;
        if( i < 0 || i == ARRAYSIZE(Cmdline)) {
            SetuplogError(LogSevWarning,
                          L"pExceptionPackageInstallationCallback: CmdLine has been truncated due to buffer size\r\n",
                          0,
                          NULL,
                          NULL);
        }

        //
        // By specifying the last param as non-NULL, we will wait forever for this
        // package to finish installing
        //
        InvokeExternalApplicationEx( L"RUNDLL32 advpack.dll,LaunchINFSection",
                                     Cmdline,
                                     &RetVal,
                                     COMPONENT_PACKAGE_TIMEOUT,
                                     FALSE);



    }

    if (EMC->hWndProgress) {
        SendMessage(EMC->hWndProgress,PBM_STEPIT,0,0);
    }

    if (RetVal == ERROR_SUCCESS) {
        SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_APPLY_EXCEPTION_PACKAGE,
                SetupOsComponentData->FriendlyName,
                SetupOsComponentData->VersionMajor,
                SetupOsComponentData->VersionMinor,
                NULL,NULL);
    } else {
        SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_APPLY_EXCEPTION_PACKAGE_FAILURE,
                SetupOsComponentData->FriendlyName,
                SetupOsComponentData->VersionMajor,
                SetupOsComponentData->VersionMinor,
                NULL,NULL);
        EMC->AnyComponentFailed = TRUE;
    }

    CoTaskMemFree( GuidString );

    //
    // if we hit a failure installing exception packages, we
    // continue onto the next package but we remember that this failed
    // in our context structure.
    //
    return(TRUE);
}


BOOL
CALLBACK
pExceptionPackageDeleteCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++

Routine Description:

    Callback routine to remove "bad packages" from the system.

    The callback looks in syssetup.inf's [OsComponentPackagesToRemove]
    section for the current GUID.  If it finds an entry for the GUID,
    it does a version check against the version in the syssetup.inf.
    If the version in syssetup.inf is newer, the exception package
    associated with that GUID is removed.  The version in syssetup.inf
    is a DWORD expressed as:
    hiword == VersionMajor
    loword == VersionMinor


Arguments:

    SetupOsComponentData - specifies component ID information
    SetupOsExceptionData - specifies component migration information
    Context              - context pointer from calling function


Return Value:

    Always TRUE.

--*/
{
    INFCONTEXT InfContext;
    PWSTR GuidString;
    DWORD VersionInInf, InstalledVersion;

    UNREFERENCED_PARAMETER(Context);

    StringFromIID( &SetupOsComponentData->ComponentGuid, &GuidString);

    //
    // see if we find the component in the syssetup inf.
    //
    if (SetupFindFirstLine( SyssetupInf,
                            L"OsComponentPackagesToRemove",
                            GuidString,
                            &InfContext)) {

        //
        // we found it, now see if it is an older version
        //
        if (SetupGetIntField( &InfContext, 1, &VersionInInf)) {
            InstalledVersion = MAKELONG(SetupOsComponentData->VersionMinor,
                                        SetupOsComponentData->VersionMajor );

            if (VersionInInf >= InstalledVersion) {
                //
                // it's an obsoleted version, so just remove it.
                //
                SetupUnRegisterOsComponent(&SetupOsComponentData->ComponentGuid);
            }
        }


    }

    CoTaskMemFree( GuidString );

    return(TRUE);

}

BOOL
MigrateExceptionPackages(
    HWND hProgress,
    DWORD StartAtPercent,
    DWORD StopAtPercent
    )
/*++

Routine Description:

    This routine enumerates the registered exception packages on the system.

    For each package on the system, a child process is started to install
    the package.

Arguments:

    hProgress      - progress window for updating a gas guage "tick count".
    StartAtPercent - indicates what % to start the gas guage at
    StopAtPercent  - indicates what % to end the gas guage at

Return Value:

    TRUE indicates that all exception packages were successfully applied.

--*/
{
    DWORD i;
    DWORD GaugeRange;
    DWORD NumberOfPackages;
    EXCEPTION_MIGRATION_CONTEXT EMC;
    HINF hInf;
    WCHAR AnswerFile[MAX_PATH];

    if (SyssetupInf == INVALID_HANDLE_VALUE) {
        //
        // we're not running in GUI-mode setup, so open a handle to the
        // syssetup.inf for the program
        //
        SyssetupInf = SetupOpenInfFile  (L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    }

    //
    // If the answer file tells us not to migrate exception packages,
    // then don't do it.
    //
    if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

    if (GetPrivateProfileInt(
                    TEXT("Data"),
                    TEXT("IgnoreExceptionPackages"),
                    0,
                    AnswerFile) == 1) {
        return(TRUE);
    }


    //
    // The very first thing we do is prune any known bad exceptions from
    // the list.  Just continue if this fails.
    //
    SetupEnumerateRegisteredOsComponents(
                            pExceptionPackageDeleteCallback,
                            (DWORD_PTR)NULL );

    //
    // now see how many components there are so we can scale the gas guage
    //
    if (!SetupQueryRegisteredOsComponentsOrder(&NumberOfPackages, NULL)) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_ENUM_EXCEPTION_PACKAGE_FAILURE,
            NULL,NULL);
        return(FALSE);
    }

    //
    // If there are no packages, we're done!
    //
    if (NumberOfPackages == 0) {
        return (TRUE);
    }

    if (hProgress) {

        GaugeRange = (NumberOfPackages*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, NumberOfPackages, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);

    }

    EMC.hWndProgress = hProgress;
    EMC.Count = 0;
    EMC.AnyComponentFailed = FALSE;

    //
    // now enumerate the packages, installing each of them in turn.
    //
    if (!SetupEnumerateRegisteredOsComponents( pExceptionPackageInstallationCallback ,
                                               (DWORD_PTR)&EMC)) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_ENUM_EXCEPTION_PACKAGE_FAILURE,
            NULL,NULL);
        return(FALSE);
    }

    return (TRUE);

}


VOID
RemoveRestartability (
    HWND hProgress
    )
{
    //
    // Note the order of the following operations.
    // If the order were changed, there is a small window where if the system
    // were to be rebooted, setup would not restart, but the SKU stuff would
    // be inconsistent, causing a licensing bugcheck.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    SetUpEvaluationSKUStuff();

    //
    // Indicate that setup is no longer in progress.
    // Do this before creating repair info! Also do it before
    // removing restart stuff. This way we will always either restart setup
    // or be able to log in.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    ResetSetupInProgress();
    RemoveRestartStuff();
}

BOOL Activationrequired(VOID);
// Setup types defined in winlogon\setup.h
#define SETUPTYPE_NOREBOOT  2


BOOL
PrepareForOOBE(
    )
{
    DWORD           l;
    DWORD           d;
    HKEY            hKeySetup;
    TCHAR           Value[MAX_PATH];
    PWSTR           SpecifiedDomain = NULL;
    NETSETUP_JOIN_STATUS    JoinStatus;
    BOOL            DoIntroOnly = FALSE;
    BOOL            AutoActivate = FALSE;
    BOOL            RunOOBE = TRUE;
    WCHAR           Path[MAX_PATH];


    if((SyssetupInf != INVALID_HANDLE_VALUE) && !Activationrequired())
    {
        // If we are a select SKU
        if (SetupInstallFromInfSection(NULL,
                                       SyssetupInf,
                                       L"DEL_ACTIVATE",
                                       SPINST_PROFILEITEMS , //SPINST_ALL,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL) != 0)
        {
            // Success
            SetupDebugPrint( L"Setup: (Information) activation icons removed\n" );
        }
        else
        {
            // Failure
            SetupDebugPrint( L"Setup: (Information) could not remove hte activation icons\n" );
        }
    }

    if (AsrIsEnabled()) {
        //
        // We don't want to run the OOBE intro after an ASR restore
        //
        return TRUE;
    }

    if (ReferenceMachine) {
        //
        // We don't want to run OOBE if we're setting up a reference machine.
        //
        return TRUE;
    }

    if (ProductType != PRODUCT_WORKSTATION)
    {
        // Don't run OOBE.
        RunOOBE = FALSE;
        // Only run Autoactivation if not DTC and unattended and AutoActivate=Yes
        if (UnattendSwitch)
        {
            // if not DTC
            if (GetProductFlavor() != 3)
            {
                // Check for AutoActivate=Yes
                if(!GetSystemDirectory(Path, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
                    MYASSERT(FALSE);
                }
                pSetupConcatenatePaths(Path, WINNT_GUI_FILE, MAX_PATH, NULL);

                if( GetPrivateProfileString( TEXT("Unattended"),
                                             TEXT("AutoActivate"),
                                             pwNull,
                                             Value,
                                             ARRAYSIZE(Value),
                                             Path ) )
                {
                    SetupDebugPrint( L"Setup: (Information) found AutoAvtivate in unattend file\n" );
                    AutoActivate = (lstrcmpi(Value,pwYes) == 0);
                }
            }
        }
    }

    if (!RunOOBE && !AutoActivate)
    {
        return TRUE;
    }
    // Now we either run OOBE (RunOOBE==TRUE) or we AutoActivate (AutoActivate == TRUE) or both


    //
    // Open HKLM\System\Setup
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeySetup );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to open Setup key.  Error = %d",
            l );
        return FALSE;
    }

    //
    // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
    //
    d = SETUPTYPE_NOREBOOT;
    l = RegSetValueEx(hKeySetup,
                      TEXT("SetupType"),
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&d,
                      sizeof(DWORD));
    if(l != NO_ERROR)
    {
        RegCloseKey(hKeySetup);
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to set SetupType.  Error = %d",
            l );
        return FALSE;
    }

    if (RunOOBE)
    {
        // Set the registry to run OOBE
        //
        //
        // Set HKLM\System\Setup\OobeInProgress to (DWORD) 1
        //
        d = 1;
        l = RegSetValueEx(hKeySetup,
                          REGSTR_VALUE_OOBEINPROGRESS,
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&d,
                          sizeof(DWORD));
        if(l != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(l);
            SetupDebugPrint2(
                L"SETUP: PrepareForOOBE() failed to set %ws.  Error = %d",
                REGSTR_VALUE_OOBEINPROGRESS,
                l );
            return FALSE;
        }

        //
        // Modify the HKLM\System\Setup\CmdLine key to run MSOOBE
        //
        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\msoobe.exe /f /retail"),
            Value,
            ARRAYSIZE(Value)
            );

    }
    else
    {
        // Set the registry to run Autoactivation
        //
        //
        // Modify the HKLM\System\Setup\CmdLine key to run Autoactivation
        //
        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\oobebaln.exe /s"),
            Value,
            ARRAYSIZE(Value)
            );
    }

    l = RegSetValueEx(hKeySetup,
                      TEXT("CmdLine"),
                      0,
                      REG_MULTI_SZ,
                      (CONST BYTE *)Value,
                      (lstrlen( Value ) + 1) * sizeof(TCHAR));
    if(l != NO_ERROR)
    {
        RegCloseKey(hKeySetup);
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to set CmdLine.  Error = %d",
            l );
        return FALSE;
    }

    RegCloseKey(hKeySetup);


    //
    // OOBE should do nothing but show the introductory animation if we're
    // unattended, or in a domain, unless a special unattend key is set to
    // force normal retail OOBE to run.
    // Note that we check whether the user explicity specifed the "/unattend"
    // switch.
    //
    if ( UnattendSwitch ) {

        DoIntroOnly = TRUE;

    } else {

        l = NetGetJoinInformation( NULL,
                                    &SpecifiedDomain,
                                    &JoinStatus );

        if ( SpecifiedDomain ) {
            NetApiBufferFree( SpecifiedDomain );
        }

        if ( l == NO_ERROR && JoinStatus == NetSetupDomainName ) {
            DoIntroOnly = TRUE;
        }
    }

    if ( DoIntroOnly && !ForceRunOobe ) {

        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\oobeinfo.ini"),
            Value,
            ARRAYSIZE(Value)
            );

        WritePrivateProfileString(
            TEXT("Options"),
            TEXT("IntroOnly"),
            TEXT("1"),
            Value
            );
    }

    return (TRUE);
}


BOOL
WINAPI
PrepareForAudit(
    )
{
    HKEY    hKey;
    TCHAR   szFileName[MAX_PATH + 32]   = TEXT("");
    BOOL    bRet                        = TRUE;

    SetupDebugPrint( L"SETUP: PrepareForAudit");
    // We need the path to factory.exe.
    //
    if ( ( ExpandEnvironmentStrings(TEXT("%SystemDrive%\\sysprep\\factory.exe"), szFileName, MAX_PATH) == 0 ) ||
         ( szFileName[0] == TEXT('\0') ) ||
         ( GetFileAttributes(szFileName) == 0xFFFFFFFF ) )
    {
        // If this fails, there is nothing we can really do.
        //
        SetupDebugPrint1( L"SETUP: PrepareForAudit, Factory.exe not found at: %s",szFileName);
        return FALSE;
    }

    // Now make sure we are also setup as a setup program to run before we log on.
    //
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
    {
        DWORD dwVal;

        //
        // Setup the control flags for the SETUP key
        // The Setting used are:
        //      CmdLine = c:\sysprep\factory.exe -setup
        //      SetupType = 2 (No reboot)
        //      SystemSetupInProgress = 0 (no service restrictions)... assuming this is already cleared by setup.
        //      MiniSetupInProgress = 0 (Not doing a mini setup)
        //      FactoryPreInstallInProgress = 1 (Delay pnp driver installs)
        //      AuditInProgress = 1 (general key to determine if the OEM is auditing the machine)
        //

        // Cleanup setting Audit/Factory does not need and does not reset
        ResetSetupInProgress();
        RegDeleteValue(hKey,L"MiniSetupInProgress");
        RegDeleteValue(hKey,REGSTR_VALUE_OOBEINPROGRESS);

        // Now set the values which Audit/Factory needs
        lstrcat(szFileName, TEXT(" -setup"));
        if ( RegSetValueEx(hKey, TEXT("CmdLine"), 0, REG_SZ, (CONST LPBYTE) szFileName, (lstrlen(szFileName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = SETUPTYPE_NOREBOOT;
        if ( RegSetValueEx(hKey, TEXT("SetupType"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("FactoryPreInstallInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("AuditInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;


        RegCloseKey(hKey);
    }
    else
        bRet = FALSE;

    return bRet;
}


VOID
RemoveFiles(
    IN HWND     hProgress
    )
{
    #define     WINNT_GUI_FILE_PNF  L"$winnt$.pnf"
    WCHAR       PathBuffer[4*MAX_PATH];
    WCHAR       Answer[4*MAX_PATH];
    DWORD       Result;
    DWORD       Status;


    //
    // Initialize the progress indicator control.
    //
    SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,6));
    SendMessage(hProgress,PBM_SETPOS,0,0);
    SendMessage(hProgress,PBM_SETSTEP,1,0);

    //
    // Restoring the path saved in textmode on upgrades
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( Upgrade )
        RestoreOldPathVariable();

    if(!MiniSetup) {

        SendMessage(hProgress,PBM_STEPIT,0,0);


        SendMessage(hProgress,PBM_STEPIT,0,0);
#ifdef _X86_
        //
        //  Win95 migration file removal
        //
        if( Win95Upgrade ) {
            Win95MigrationFileRemoval();
        }
        RemoveFiles_X86(SyssetupInf);

        //
        // remove downloaded files in %windir%\winnt32
        //
        Result = GetWindowsDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(TEXT("WINNT32")));
        if (Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        pSetupConcatenatePaths(PathBuffer, TEXT("WINNT32"), MAX_PATH, NULL);
        Delnode(PathBuffer);

        //
        // Prepare to run OOBE after reboot
        //
        if( !PrepareForOOBE() ) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CANT_RUN_OOBE,
                GetLastError(),
                NULL,NULL);
        }
#endif

        if( Upgrade ) {
           //
           //If we upgraded from NT4-SP4, remove the files/registration
           //for sp4 uninstall. If we upgraded from NT4-SPx where x<4,
           //we don't need to remove anything from the registry.
           //
            Result = GetWindowsDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(L"$ntservicepackuninstall$"));
            if (Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            pSetupConcatenatePaths(PathBuffer, L"$ntservicepackuninstall$", MAX_PATH, NULL);
            Delnode(PathBuffer);

            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 4"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 5"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 6"));

            // We should not have to do this.
            // Ther servick pack team needs to remember to put the correct key at
            // Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows 2000 Service Pack 1"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows 2000 Service Pack 2"));

            //Remove the files/registry keys for all the hotfixes.
            // It also implements a generic way to removing Service Pack uninstall entries
            //
            RemoveHotfixData();
        } else {
            //
            // Setup for audit mode if this is a reference machine.
            //
            if ( ReferenceMachine )
                PrepareForAudit();
        }

        //
        // Install the final section of updates.inf from the DU package
        //
        DuInstallUpdatesInfFinal ();

        DuCleanup ();

        DuInstallEndGuiSetupDrivers ();

        SendMessage(hProgress,PBM_STEPIT,0,0);
        DeleteLocalSource();
    } else {
        SendMessage(hProgress,PBM_STEPIT,0,0);
        SendMessage(hProgress,PBM_STEPIT,0,0);
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    //
    // At this point, the net stuff is done. Re-read the product type
    // which might have been changed by them (such as changing PDC/BDC).
    //
    ProductType = InternalSetupData.ProductType;

    //
    // Call the net guys back once again to let them do any final
    // processing, such as BDC replication.
    //
    CallNetworkSetupBack(NETSETUPFINISHINSTALLPROCNAME);

    //
    // If the computer name was a non-RFC name or if it was truncated
    // to make a valid netbios name, put a warning in the log file.
    //
    if (IsNameNonRfc)
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DNS_NON_RFC_NAME,
                ComputerName,
                NULL,NULL);

    if (IsNameTruncated)
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DNS_NAME_TRUNCATED,
                ComputerName,
                Win32ComputerName,
                NULL,NULL);


    //
    // Delete the PNF to take care of security issue with passwords
    // Do this before we save the current system hives so that the
    // delayed delete works
    //

    if(!GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE_PNF))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(PathBuffer, WINNT_GUI_FILE_PNF, MAX_PATH, NULL);
    MoveFileEx( PathBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );


    //
    // Delete the SAM.sav hive file as we no longer need it. Textmode setup
    // creates this file only in upgrades as a backup. We will try to delete it in any case
    // as this file can be used by hackers for offline attacks.
    //
    if(!GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(L"config\\sam.sav"))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths(PathBuffer, L"config\\sam.sav", MAX_PATH, NULL);
    DeleteFile( PathBuffer );



    //
    // Setup the Crash Recovery stuff. This is implemented as RTL APIS
    // Call them now to setup the tracking file etc. as we are past the
    // restartable phase of GUI mode and don't run the risk of having it
    // enabled for GUI mode itself. Crash Recovery tracks boot and shutdown and in
    // the event of failures in either it will by default pick the right advanced
    // boot option.
    //


    BEGIN_SECTION( L"Setting up Crash Recovery" );

    SetupCrashRecovery();

    END_SECTION( L"Setting up Crash Recovery" );

    //
    //  Save and replace the system hives.
    //  This is necessary in order to remove fragmentation and compact the
    //  system hives. Remember that any type of writes to the registry
    //  after this point won't be reflected on next boot.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( !MiniSetup ) {
        SaveAndReplaceSystemHives();
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);

    //
    // Delete the \sysprep directory.
    //
    if( MiniSetup ) {
        HANDLE  hEventLog = NULL;
        Result = GetWindowsDirectory(PathBuffer, MAX_PATH);
        if (Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        PathBuffer[3] = 0;
        pSetupConcatenatePaths( PathBuffer, TEXT("sysprep"), MAX_PATH, NULL );
        Delnode( PathBuffer );

        //
        // Delete the setupcl.exe so session manager won't start us for each
        // session (TS client, user switching).
        //
        Result = GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(TEXT("setupcl.exe")));
        if (Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        pSetupConcatenatePaths( PathBuffer, TEXT("setupcl.exe"), MAX_PATH, NULL );
        SetFileAttributes(PathBuffer, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(PathBuffer);

        //
        // Clear the Event logs.
        //
        hEventLog = OpenEventLog( NULL, TEXT("System") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }

        hEventLog = OpenEventLog( NULL, TEXT("Application") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }

        hEventLog = OpenEventLog( NULL, TEXT("Security") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }
    }

    //
    // Delete certain keys out of the unattend file:
    // - AdminPassword
    // - DomainAdminPassword
    // - UserPassword
    // - DefaultPassword
    // - ProductId
    // - ProductKey
    //
    Result = GetSystemDirectory(PathBuffer, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE));
    if (Result == 0) {
        MYASSERT(FALSE);
        return;
    }
    pSetupConcatenatePaths(PathBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

    if(Unattended) {

        // AdminPassword
        if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                     TEXT("AdminPassword"),
                                     pwNull,
                                     Answer,
                                     ARRAYSIZE(Answer),
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                           TEXT("AdminPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // DomainAdminPassword
        if( GetPrivateProfileString( TEXT("Identification"),
                                     TEXT("DomainAdminPassword"),
                                     pwNull,
                                     Answer,
                                     ARRAYSIZE(Answer),
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Identification"),
                                           TEXT("DomainAdminPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // UserPassword
        if( GetPrivateProfileString( TEXT("Win9xUpg.UserOptions"),
                                     TEXT("UserPassword"),
                                     pwNull,
                                     Answer,
                                     ARRAYSIZE(Answer),
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Win9xUpg"),
                                           TEXT("UserPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // DefaultPassword
        if( GetPrivateProfileString( TEXT("Win9xUpg.UserOptions"),
                                     TEXT("DefaultPassword"),
                                     pwNull,
                                     Answer,
                                     ARRAYSIZE(Answer),
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Win9xUpg"),
                                           TEXT("DefaultPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }
    }
    // ProductId
    if( GetPrivateProfileString( pwUserData,
                                 pwProdId,
                                 pwNull,
                                 Answer,
                                 ARRAYSIZE(Answer),
                                 PathBuffer ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            WritePrivateProfileString( pwUserData,
                                       pwProdId,
                                       pwNull,
                                       PathBuffer );
        }
    }

    //
    // If this is SBS, then we need to leave the product key in the answer file or add it if not already there.
    // For any other SKU, we delete it.
    //
    Answer[0] = 0;

    if(IsSBSSKU()) {
        if(_snwprintf(Answer,
                      ARRAYSIZE(Answer),
                      L"%s-%s-%s-%s-%s",
                      Pid30Text[0],
                      Pid30Text[1],
                      Pid30Text[2],
                      Pid30Text[3],
                      Pid30Text[4]) < 0){
            Answer[ARRAYSIZE(Answer) - 1] = 0;
            SetuplogError(LogSevWarning,
                          L"RemoveFiles: Answer has been truncated due to buffer size\r\n",
                          0,
                          NULL,
                          NULL);
        }
    }

    WritePrivateProfileString( pwUserData,
                               pwProductKey,
                               Answer,
                               PathBuffer );

    //
    // Sysprep disables system restore, so we need to re-enable it now that
    // we're done.
    //
    if ( MiniSetup ) {
        HINSTANCE hSrClient = LoadLibrary(L"srclient.dll");

        if (hSrClient) {
            DWORD (WINAPI *pEnableSrEx)(LPCWSTR, BOOL) = (DWORD (WINAPI *)(LPCWSTR, BOOL))GetProcAddress(hSrClient, "EnableSREx");
            if (pEnableSrEx) {
                Status = pEnableSrEx( NULL , TRUE); // TRUE - synchronous call.  Wait for SR to finish enabling.
                if ( Status != ERROR_SUCCESS ) {

                    SetupDebugPrint1( L"SETUP: EnableSREx(NULL, TRUE) failed. Error = %d", Status);
                }
            } else {
                SetupDebugPrint1( L"SETUP: Unable to find EnableSREx in srclient.dll. Error = %d", GetLastError());
            }
            FreeLibrary(hSrClient);
        } else {
            SetupDebugPrint1( L"SETUP: Unable to load srclient.dll. Error = %d", GetLastError());
        }
    }
}


VOID
SetStartTypeForRemoteBootDrivers(
    VOID
    )

/*++

Routine Description:

    This routine is called at the end of remote boot setup to change the
    start type for certain drivers to BOOT_START.

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD i;
    BOOL b;
    WCHAR imagePath[ARRAYSIZE("System32\\DRIVERS\\xxxxxxxx.sys")];

    //
    // Loop through the list of boot drivers. We call MyChangeServiceConfig
    // directly instead of MyChangeServiceStart so that we can specify
    // an image path, which prevents the service controller from rejecting
    // the change (because it expects the current image path to start
    // with \SystemRoot which it doesn't).
    //

    for (i = 0; i < ARRAYSIZE(RemoteBootDrivers); i++) {
        MYASSERT(wcslen(RemoteBootDrivers[i]) <= 8);// xxxxxxxx
        wsprintf(imagePath, L"System32\\DRIVERS\\%ws.sys", RemoteBootDrivers[i]);
        b = MyChangeServiceConfig(
                    RemoteBootDrivers[i],
                    SERVICE_NO_CHANGE,
                    SERVICE_BOOT_START,
                    SERVICE_NO_CHANGE,
                    imagePath,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    }
}

VOID
CallNetworkSetupBack(
    IN PCSTR ProcName
    )

{
    HMODULE NetSetupModule;
    NETSETUPINSTALLSOFTWAREPROC NetProc;
    DWORD d;
    BOOL b;

    if(NetSetupModule = LoadLibrary(L"NETSHELL")) {

        if(NetProc = (NETSETUPINSTALLSOFTWAREPROC)GetProcAddress(NetSetupModule,ProcName)) {
            SetUpDataBlock();
            NetProc(MainWindowHandle,&InternalSetupData);
        }

        //
        // We don't free the library because it might create threads
        // that are hanging around.
        //
    }
}


VOID
SetUpDataBlock(
    VOID
    )

/*++

Routine Description:

    This routine sets up the internal setup data block structure that
    we use to communicate information to the network setup wizard.
    Note that we passed a pointer to this structure when we fetched
    the net setup wizard pages but at that point the structure was completely
    uninitialized.

Arguments:

    None.

Returns:

    None.

--*/

{
    PWSTR p;
    WCHAR str[1024];

    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);

    //
    // Set the mode: custom, laptop, minimal, typical
    //
    InternalSetupData.SetupMode = SetupMode;

    //
    // Set the product type: workstation, dc, etc.
    //
    InternalSetupData.ProductType = ProductType;

    //
    // Set the operation flags.
    //
    if(Win31Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_WIN31UPGRADE;
    }
    if(Win95Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_WIN95UPGRADE;
    }
    if(Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_NTUPGRADE;
    }
    if(Unattended) {
        InternalSetupData.OperationFlags |= SETUPOPER_BATCH;
        InternalSetupData.UnattendFile = AnswerFile;
        if(Preinstall) {
            InternalSetupData.OperationFlags |= SETUPOPER_PREINSTALL;
        }
    }
    if(MiniSetup) {
        //
        // Pretend we've got access to all the files.
        //
        InternalSetupData.OperationFlags |= SETUPOPER_ALLPLATFORM_AVAIL;

        // Let people know we are in MiniSetup
        InternalSetupData.OperationFlags |= SETUPOPER_MINISETUP;
    }


    //
    // Tell the net guys the source path.
    //
    InternalSetupData.SourcePath = SourcePath;
    InternalSetupData.LegacySourcePath = LegacySourcePath;

    //
    // If we are installing from CD then assume all platforms
    // are available.
    //
    if(SourcePath[0] && (SourcePath[1] == L':') && (SourcePath[2] == L'\\')) {

        lstrcpyn(str,SourcePath,4);
        if(GetDriveType(str) == DRIVE_CDROM) {

            InternalSetupData.OperationFlags |= SETUPOPER_ALLPLATFORM_AVAIL;
        }
    }

    //
    // Tell the net guys the wizard title they should use.
    //
    if(!InternalSetupData.WizardTitle) {
        p = NULL;
        if(LoadString(MyModuleHandle, SetupTitleStringId, str, ARRAYSIZE(str))) {
            p = pSetupDuplicateString(str);
        }
        InternalSetupData.WizardTitle = p ? p : L"";
    }

    //
    // Reset the two call-specific data fields.
    //
    InternalSetupData.CallSpecificData1 = InternalSetupData.CallSpecificData2 = 0;

    // Set the billboard call back function if we have a billboard
    InternalSetupData.ShowHideWizardPage = ShowHideWizardPage;
    InternalSetupData.BillboardProgressCallback = Billboard_Progress_Callback;
    InternalSetupData.BillBoardSetProgressText= Billboard_Set_Progress_Text;
}


VOID
SetFinishItemAttributes(
    IN HWND     hdlg,
    IN int      BitmapControl,
    IN HANDLE   hBitmap,
    IN int      TextControl,
    IN LONG     Weight
    )
{
    HWND    hBitmapControl, hTxt;
    HFONT   Font;
    LOGFONT LogFont;

    if( OobeSetup ) {
        return;
    }


    hBitmapControl = GetDlgItem(hdlg, BitmapControl);
    SendMessage (hBitmapControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
    ShowWindow (hBitmapControl, SW_SHOW);
    if((Font = (HFONT)SendDlgItemMessage(hdlg,TextControl,WM_GETFONT,0,0))
       && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

        LogFont.lfWeight = Weight;
        if(Font = CreateFontIndirect(&LogFont)) {
            SendDlgItemMessage (hdlg, TextControl, WM_SETFONT, (WPARAM)Font,
                MAKELPARAM(TRUE,0));
        }
    }
}


DWORD
FinishThread(
    PFINISH_THREAD_PARAMS   Context
    )
{
    HANDLE  hArrow, hCheck;
    HWND    hProgress;
    DWORD   DontCare;
    NTSTATUS        Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;
    ULONG           RegistryQuota = 0;
    WCHAR str[1024];

    BEGIN_SECTION(L"FinishThread");
    SetThreadLocale(OriginalInstallLocale);


    //
    // Initialize stuff.
    //
    if( !OobeSetup ) {
        hArrow = LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hCheck = LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hProgress = GetDlgItem(Context->hdlg, IDC_PROGRESS1);
    }


    if( !MiniSetup ) {
        pSetupEnablePrivilege(SE_INCREASE_QUOTA_NAME,TRUE);
        Status = NtQuerySystemInformation(SystemRegistryQuotaInformation,
            &srqi, sizeof(srqi), NULL);

        if(NT_SUCCESS(Status)) {
            RegistryQuota = srqi.RegistryQuotaAllowed;
            srqi.RegistryQuotaAllowed *= 2;
            SetupDebugPrint2(L"SETUP: Changing registry quota from %d to %d...",
                RegistryQuota, srqi.RegistryQuotaAllowed);
            Status = NtSetSystemInformation(SystemRegistryQuotaInformation,
                &srqi, sizeof(srqi));
            if (NT_SUCCESS(Status)) {
                SetupDebugPrint(L"SETUP:    ... succeeded");
            } else {
                SetupDebugPrint(L"SETUP:    ... failed");
            }
        }
    }

    //
    // Copying files
    //
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_COPY_BMP, hArrow, IDC_COPY_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_COPY_TXT, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }




    MYASSERT(Context->OcManagerContext);
    BEGIN_SECTION(L"Terminating the OC manager");
    KillOcManager(Context->OcManagerContext);
    END_SECTION(L"Terminating the OC manager");

    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 3)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_3, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 3)");

        BEGIN_SECTION(L"Installing Component Infs");
        DoInstallComponentInfs(MainWindowHandle, Context->hdlg, WM_MY_PROGRESS, SyssetupInf, L"Infs.Always" );
        END_SECTION(L"Installing Component Infs");
    }

    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_COPY_BMP, hCheck, IDC_COPY_TXT, FW_NORMAL);
    }


    //
    // Configuring your computer
    //
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_CONFIGURE_BMP, hArrow, IDC_CONFIGURE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_CONFIGURE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }

    if( !MiniSetup ) {
        RemainingTime = CalcTimeRemaining(Phase_Inf_Registration);
        SetRemainingTime(RemainingTime);
        BEGIN_SECTION(L"Processing RegSvr Sections");
        RegisterOleControls(Context->hdlg,SyssetupInf,hProgress,0,40,L"RegistrationPhase2");
        END_SECTION(L"Processing RegSvr Sections");
    }
    RemainingTime = CalcTimeRemaining(Phase_RunOnce_Registration);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"DoRunonce");
    DoRunonce();
    END_SECTION(L"DoRunonce");

    if(Upgrade) {
        BEGIN_SECTION(L"Configuring Upgrade");
        ConfigureUpgrade(hProgress,40,70);
        END_SECTION(L"Configuring Upgrade");


    } else {
        BEGIN_SECTION(L"Configuring Setup");
        ConfigureSetup(hProgress,40,70);
        END_SECTION(L"Configuring Setup");
    }

    RemainingTime = CalcTimeRemaining(Phase_SecurityTempates);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Configuring Common");
    ConfigureCommon(hProgress,70,100);
    END_SECTION(L"Configuring Common");

    if( !MiniSetup ) {
        if(WatchHandle) {
            if(WatchStop(WatchHandle) == NO_ERROR) {
                MakeUserdifr(WatchHandle);
            }
            WatchFree(WatchHandle);
        }
    }


    //
    // tell umpnpmgr to stop installing any more devices, if it was already doing so
    //
    if( (!MiniSetup) || (MiniSetup && PnPReEnumeration) ) {
        PnpStopServerSideInstall();
    }

    if (!OobeSetup)
    {
        SetFinishItemAttributes (Context->hdlg, IDC_CONFIGURE_BMP, hCheck, IDC_CONFIGURE_TXT, FW_NORMAL);
    }

#ifdef _X86_
    //
    //  Do Win95 migration, if necessary.
    //
    // !!ATTENTION!!
    //
    //  This code must run at the end of GUI mode, but before registry ACLs are applied and also
    //  before temporary files are deleted.  Every NT component must be in place before migration
    //  occurs in order for the migrated users to receive all NT-specific settings.
    //

    if (Win95Upgrade) {
        RemainingTime = CalcTimeRemaining(Phase_Win9xMigration);
        SetRemainingTime(RemainingTime);

        BEGIN_SECTION(L"Migrating Win9x settings");
        SetBBStep(5);

        SetFinishItemAttributes (Context->hdlg, IDC_UPGRADE_BMP, hArrow, IDC_UPGRADE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_UPGRADE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);

        if (!MigrateWin95Settings (hProgress, AnswerFile)) {
            //
            // User's machine is unstable. Fail setup, so that uninstall must kick in.
            //
            WCHAR skipFile[MAX_PATH];
            BOOL ok = FALSE;

            if (GetWindowsDirectory (skipFile, MAX_PATH - ARRAYSIZE(TEXT("nofail")))) {
                pSetupConcatenatePaths (skipFile, TEXT("nofail"), MAX_PATH, NULL);
                if (GetFileAttributes (skipFile) != 0xFFFFFFFF) {
                    ok = TRUE;
                }
            }

            if (!ok) {
                FatalError (MSG_LOG_MIGRATION_FAILED,0,0);
            }
        }

        SetFinishItemAttributes (Context->hdlg, IDC_UPGRADE_BMP, hCheck, IDC_UPGRADE_TXT, FW_NORMAL);
        END_SECTION(L"Migrating Win9x settings");
    }


#endif // def _X86_

    SetFinishItemAttributes (Context->hdlg, IDC_SAVE_BMP, hArrow, IDC_SAVE_TXT, FW_BOLD);

    //
    // The last things to set up.  Make it quick -- the gas guage may be at 100% at this point.
    //
    if( !MiniSetup ) {

        ExecuteUserCommand (NULL);
        InitializeCodeSigningPolicies (FALSE);  // NOTE: don't bother stepping the progress--this is really quick!

        SetBBStep(5);

        //
        // Saving your configuration
        //
        if(!LoadString(MyModuleHandle, IDS_BB_SAVE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);

        //
        // Fix the security on <All Users\Application Data\Microsoft\Windows NT>
        //
        BEGIN_SECTION(L"Fix the security on <All Users\\Application Data\\Microsoft\\Windows NT>");
        InvokeExternalApplication(L"shmgrate.exe", L"Fix-HTML-Help", 0);
        END_SECTION(L"Fix the security on <All Users\\Application Data\\Microsoft\\Windows NT>");

        //
        // Do any exception package installation at this point
        //
        BEGIN_SECTION(L"Migrating exception packages");
        MigrateExceptionPackages(hProgress, 0, 10 );
        END_SECTION(L"Migrating exception packages");

        //
        // Run any nt migration dlls.
        //
        if (Upgrade) {
            RunMigrationDlls ();

        }

        //
        // Scan the system dirs to validate all protected dlls
        //
        RemainingTime = CalcTimeRemaining(Phase_SFC);
        SetRemainingTime(RemainingTime);

        BEGIN_SECTION(L"Running SFC");
        SFCCheck(hProgress,10,70);
        END_SECTION(L"Running SFC");
#ifdef PRERELEASE
        if (SfcErrorOccurred) {
//
// Hack out the fatal error so we can get the build out.
//
//            FatalError(MSG_LOG_SFC_FAILED,0,0);
        }
#endif



    } else {
        //
        // We're in MiniSetup, which means 3 things:
        // 1. If the OEM desires it, they can request a change of kernel+HAL
        //    we have to do this at the end, due to the way we upgrade HAL
        //    doing this sooner can cause other installs to crash
        //
        // 2. SFC has been run on this machine and the files have been
        //    inventoried.
        // 3. We're very concerned with execution time here.
        //
        // Given the last two items, we're just going to re-enable SFC
        // as it was before the user ran sysprep.
        //
        // 1 and 3 are contradictory, however 1 shouldn't take too long
        // and will be used in rare cases
        //

        DWORD   d;
        DWORD   l;
        HKEY    hKey;
        DWORD   Size;
        DWORD   Type;


        //
        // We want to see if the OEM wants MiniSetup to choose a different kernel+HAL
        // this has to be done after all other installation
        // due to the special way we update the kernel+HAL+dependent files
        //
        BEGIN_SECTION(L"Updating HAL (mini-setup)");
        PnpUpdateHAL();
        END_SECTION(L"Updating HAL (mini-setup)");
    }

    //
    // Only copy these folders if OEMPreinstall=yes, and it's not Mini-Setup
    //
    if (Preinstall && !MiniSetup) {
        //
        // Recursively move custom OEM \\Temp\\$PROGS directories to %Program Files%
        //
        BEGIN_SECTION(L"TreeCopy $OEM\\$PROGS");
        CopyOemProgramFilesDir();
        END_SECTION(L"TreeCopy $OEM\\$PROGS");

        //
        // Recursively move custom OEM \\Temp\\$DOCS directories to %Documents and Settings%
        //
        BEGIN_SECTION(L"TreeCopy $OEM\\$DOCS");
        CopyOemDocumentsDir();
        END_SECTION(L"TreeCopy $OEM\\$DOCS");
    }

    //
    // Call User Profile code to copy the SystemProfile under system32\config\systemprofile
    //

    if( !CopySystemProfile(Upgrade ? FALSE : TRUE) ){

        //Log the error and move on.

        SetuplogError(LogSevError,
                      L"Setup failed to migrate the SystemProfile  (CopySystemProfile failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

    }

    // Only do this in Workstation installs in MiniSetup.
    //OOBE is calling this at a different time. Real setup does not need this.
    if (MiniSetup && !OobeSetup && (ProductType == PRODUCT_WORKSTATION))
    {
        RunOEMExtraTasks();
    }

    //
    // Simulate OOBE's functionality of copying the default profile directory to all user profiles.
    // Only do this for MiniSetup and Server skus (server doesn't use OOBE).
    //
    if ( MiniSetup && !OobeSetup && (ProductType != PRODUCT_WORKSTATION) )
    {
        if ( !UpdateServerProfileDirectory() )
        {
            SetuplogError(LogSevError,
                          L"Setup failed to update user(s) profiles.  (UpdateServerProfileDirectory failed %1!u!)\r\n",
                          0, GetLastError(), NULL,NULL
                          );
        }
    }
    // Clean up CurrentProductId which should only be used during gui-mode.
    DeleteCurrentProductIdInRegistry();


    //
    // FROM THIS POINT ON DO NOTHING THAT IS CRITICAL TO THE OPERATION
    // OF THE SYSTEM. OPERATIONS AFTER THIS POINT ARE NOT PROTECTED BY
    // RESTARTABILITY.
    //
    RemoveRestartability (NULL);

    //
    // Update the install date time for shell's application install feature
    //
    CreateInstallDateEntry();

    //
    // Save repair info.
    //
    if(!MiniSetup) {

        RemainingTime = CalcTimeRemaining(Phase_SaveRepair);
        SetRemainingTime(RemainingTime);
        BEGIN_SECTION(L"Saving repair info");
        SaveRepairInfo( hProgress, 70, 100 );
        END_SECTION(L"Saving repair info");
    }
    SetFinishItemAttributes (Context->hdlg, IDC_SAVE_BMP, hCheck, IDC_SAVE_TXT, FW_NORMAL);

    //
    // Removing any temporary files used
    //
    RemainingTime = CalcTimeRemaining(Phase_RemoveTempFiles);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Removing Temporary Files");
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_REMOVE_BMP, hArrow, IDC_REMOVE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_REMOVE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }

    //
    // This call does more than just remove files. It also commits the hives and takes care of admin password stuff etc.
    //
    RemoveFiles(hProgress);

    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_REMOVE_BMP, hCheck, IDC_REMOVE_TXT, FW_NORMAL);
    }
    END_SECTION(L"Removing Temporary Files");

    //
    // Log Any failure for SceSetupRootSecurity.
    //
    if( !MiniSetup ) {
        if (bSceSetupRootSecurityComplete == TRUE) {
            SetupDebugPrint(L"SETUP: CallSceSetupRootSecurity completed");
        }
        else {
            SetuplogError( LogSevError, SETUPLOG_USE_MESSAGEID, MSG_LOG_SCE_SETUPROOT_ERROR, L"%windir%", NULL, NULL);
            if( SceSetupRootSecurityThreadHandle){
                TerminateThread( SceSetupRootSecurityThreadHandle, STATUS_TIMEOUT);
                CloseHandle( SceSetupRootSecurityThreadHandle);
            }
        }
    }

    //
    // Clean up
    //
    if( !MiniSetup ) {
        if(NT_SUCCESS(Status)) {
            SetupDebugPrint2(L"SETUP: Changing registry quota from %d to %d...",
                srqi.RegistryQuotaAllowed, RegistryQuota);
            srqi.RegistryQuotaAllowed = RegistryQuota;
            Status = NtSetSystemInformation(SystemRegistryQuotaInformation,
                &srqi, sizeof(srqi));
            if (NT_SUCCESS(Status)) {
                SetupDebugPrint(L"SETUP:    ... succeeded");
            } else {
                SetupDebugPrint(L"SETUP:    ... failed");
            }
        }


        //
        // Now save information about the upgrade/clean install
        // into the eventlog.
        //
        SaveInstallInfoIntoEventLog();
    }

    if( !OobeSetup ) {
        PostMessage(Context->hdlg,WMX_TERMINATE,0,0);
        DeleteObject(hArrow);
        DeleteObject(hCheck);
    }

    END_SECTION(L"FinishThread");
    return 0;
}


VOID
ShutdownSetup(
    VOID
    )
{
    int i;


    if (SyssetupInf) SetupCloseInfFile(SyssetupInf);

    //
    // Inform the user if there were errors, and optionally view the log.
    //
    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_END,
        NULL,NULL);
    if ( SavedExceptionFilter ) {
        SetUnhandledExceptionFilter( SavedExceptionFilter );
    }
    TerminateSetupLog(&SetuplogContext);

    if(SetuplogContext.WorstError >= LogSevWarning || !IsErrorLogEmpty()) {

        SendSMSMessage( MSG_SMS_MINORERRORS, TRUE );

#ifdef PRERELEASE
        if(!Unattended) {
            i = MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_SETUP_HAD_ERRORS,
                    NULL,
                    SetupTitleStringId,
                    MB_SYSTEMMODAL | MB_YESNO | MB_ICONASTERISK | MB_SETFOREGROUND,
                    SETUPLOG_ERROR_FILENAME
                    );

            if(i == IDYES) {
                ViewSetupActionLog (MainWindowHandle, NULL, NULL);
            }
        }
#endif

    } else {

        SendSMSMessage( MSG_SMS_SUCCEED, TRUE );
    }


    //
    // Note : In unattend mode only wait for reboot if
    // specifically asked for using the "WaitForReboot"
    // key
    //
    if(Unattended && UnattendWaitForReboot) {
        //
        // Count down to reboot
        //
        DialogBoxParam(
            MyModuleHandle,
            MAKEINTRESOURCE(IDD_DONE_SUCCESS),
            MainWindowHandle,
            DoneDlgProc,
            SetuplogContext.WorstError >= LogSevError ? MSG_SETUP_DONE_GENERIC
                      : (Upgrade ? MSG_UPGRADE_DONE_SUCCESS : MSG_SETUP_DONE_SUCCESS)
            );
    }

        //
        // do some wow64 syncing stuffs.
        //
#ifdef _WIN64
        Wow64SyncCLSID();
#endif

    //
    // Done.  Post a quit message to our background bitmap thread so it goes
    // away.
    //
    if (SetupWindowHandle)
    {
        // Cannot use DestroyWindow, since the window was created by a different thread.
        SendMessage(SetupWindowHandle, WM_EXIT_SETUPWINDOW, 0, 0);
    }
    if (SetupWindowThreadHandle)
    {
        // Just make sure the thread finishes before continue.
        WaitForSingleObject(SetupWindowThreadHandle, INFINITE);
        CloseHandle(SetupWindowThreadHandle);
    }

    ASSERT_HEAP_IS_VALID();
}

BOOLEAN
SpRunningSetup(
               VOID
              )
/*++
Routine Description:

    Checks the setup registry key to see if we are in setup.

Arguments:

    None.

Return Value:

    TRUE if we are in setup else FALSE.

--*/
{
   LONG        Result;
   HKEY        SetupKey;
   BOOLEAN     InSetup = FALSE;

   Result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          SETUP_KEY_STR,
                          0,
                          KEY_READ,
                          &SetupKey);

   if (ERROR_SUCCESS == Result){
        DWORD SystemInSetup = 0;
        DWORD BufferSize = sizeof(DWORD);
        Result = RegQueryValueEx( SetupKey,
                                  SETUP_IN_PROGRESS_STR,
                                  0,
                                  NULL,
                                  (LPBYTE)&SystemInSetup,
                                  (LPDWORD)&BufferSize );
        if ((ERROR_SUCCESS == Result) && SystemInSetup){
            InSetup = TRUE;
        }
        RegCloseKey(SetupKey);
    }
    return InSetup;
}



VOID
InstallWindowsNt(
    int  argc,
    wchar_t *argv[]
    )

/*++

Routine Description:

    Main entry point for syssetup.dll. Responsible for installing
    NT on system by calling the required components in the proper
    order.

Arguments:

    argc/argv

Returns:

    none

--*/

{
    int i;
    BOOL ValidOption = FALSE;
    WCHAR TitleBuffer[1024];
    WCHAR MessageBuffer[1024];

#ifdef _OCM
    PVOID OcManagerContext;
#endif

    //
    // Return if we are not running setup.
    // Before returning maintain previous behaviour of displaying message to user 
    // advising them to go to control panel.
    //
    if (!SpRunningSetup()){
        LoadString(MyModuleHandle, IDS_WINNT_SETUP , TitleBuffer, SIZECHARS(TitleBuffer));
        LoadString(MyModuleHandle, IDS_MAINTOBS_MSG1 , MessageBuffer, SIZECHARS(MessageBuffer));
        MessageBox(NULL, MessageBuffer, TitleBuffer, MB_ICONINFORMATION | MB_OK);
        return;
    }

    //
    // Indicate that we're running in Setup, not in appwiz.
    // Nothing should come before this!
    //
    // Need to have this set to that logging is enabled. Otherwise we have no log file
    // SacChannelInitiaize is calling into our logging code.
    IsSetup = TRUE;

    //
    // Initialize the SAC channels used for logging
    //
#if defined(_ENABLE_SAC_CHANNEL_LOGGING_)
    SacChannelInitialize();
#endif


    BEGIN_SECTION(L"Installing Windows NT");
#if 1 // NOTE: Can be turned off before we ship if we don't find use for this. Give a 2 second window!

    // If debugger is not already attached to the process and we have the user pressing the Shift+F10 key,
    // launch just cmd.exe to help debug.
    //
//    MessageBox(NULL, L"Hit Shift-F10 Now.", L"Launch Command Window", MB_OK);
    Sleep(2000) ; // Hack: give user 2 seconds to press Shift+F10. Else we could go by too fast!
    if (!IsDebuggerPresent()) {
        SHORT wTemp;
        DWORD dwTemp ;

        wTemp = GetAsyncKeyState(VK_SHIFT) ;
        if (wTemp & 0x8000) { // See if the user is holding down the Shift key or held it before
            wTemp = GetAsyncKeyState(VK_F10) ;

            if (wTemp & 0x8000) { // See if the user is holding down the F10 key also or held it before?

                // InvokeExternalApplication(L"ntsd",  L" -d setup -newsetup", NULL) ; // if kd is enabled, we can do this
                // InvokeExternalApplication(L"ntsd",  L"setup -newsetup", NULL) ; // in no kd, case launch under ntsd locally
                InvokeExternalApplication(L"cmd",  L"", &dwTemp) ;

               return;
            }
        }
    }
#endif

    // Calc. the time estimates
    SetTimeEstimates();

    BEGIN_SECTION(L"Initialization");

    //
    // Tell SetupAPI not to bother backing up files and not to verify
    // that any INFs are digitally signed.
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_BACKUP|PSPGF_NO_VERIFY_INF);

    //
    // Scan Command Line for -mini or -asr flags
    //
    // -mini enables gui-mode setup but with
    // only a minimal subset of his functionality.  We're going
    // to display a few wizard pages and that's about it.
    //
    // -asr causes the Automated System Recovery (ASR) code to run.
    //
    for(i = 0; i < argc; i++) {
        PCWSTR arg = argv[i];
        if(arg[0] == '-') {
            arg += 1;
            if(_wcsicmp(arg,L"newsetup") == 0) {
                ValidOption = TRUE;
            }

            if(_wcsicmp(arg,L"mini") == 0) {
                MiniSetup = TRUE;
                ValidOption = TRUE;
            }

            if(_wcsicmp(arg, L"asr") == 0) {
                AsrInitialize();
                ValidOption = TRUE;
            }

            if(_wcsicmp(arg, L"asrquicktest") == 0) {
                AsrQuickTest = TRUE;
                ValidOption = TRUE;
                AsrInitialize();
            }
        }
    }

    if( ValidOption == FALSE ){
        LoadString(MyModuleHandle, IDS_WINNT_SETUP , TitleBuffer, SIZECHARS(TitleBuffer));
        LoadString(MyModuleHandle, IDS_MAINTOBS_MSG1 , MessageBuffer, SIZECHARS(MessageBuffer));
        MessageBox(NULL, MessageBuffer, TitleBuffer, MB_ICONINFORMATION | MB_OK);
        return;
    }

    // Check if we are in SafeMode ....
    // If so cause a popup and return.
    // 
    // If we are running in SBS allow mini-setup to run under safe-mode.  
    //

    if ( !IsSBSSKU() ) {
        if( IsSafeMode() ) {
            LoadString(MyModuleHandle, IDS_WINNT_SETUP , TitleBuffer, SIZECHARS(TitleBuffer));
            LoadString(MyModuleHandle, IDS_SAFEMODENOTALLOWED , MessageBuffer, SIZECHARS(MessageBuffer));
            MessageBox(NULL, MessageBuffer, TitleBuffer, MB_ICONINFORMATION | MB_OK);
            return;
        }
    }

    //
    // If we're running ASR quick tests, jump directly to the recovery code
    //
    if (AsrQuickTest) {
#if DBG
        g_hSysSetupHeap = GetProcessHeap();
#endif
        goto Recovery;
    }
    //
    // super bad hack becase pnp, atapi, and cdrom driver are always broken
    // we open a handle to the first cdrom drive so the drive doesn't get removed
    //

    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        HANDLE Handle;
        IO_STATUS_BLOCK StatusBlock;


        RtlInitUnicodeString(&UnicodeString,L"\\Device\\CdRom0");
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        SetErrorMode(SEM_FAILCRITICALERRORS);

        Status = NtCreateFile(
            &Handle,
            FILE_READ_ATTRIBUTES,
            &ObjectAttributes,
            &StatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            0,
            NULL,
            0
            );
        if (!NT_SUCCESS(Status)) {
            SetupDebugPrint1( L"Setup: Could not open the cdrom for hack, ec=0x%08x\n", Status );
        }
    }

    //
    // Initialization phase. Common to initial install and upgrade.
    //
    BEGIN_SECTION(L"Common Initialiazation");
#ifdef _OCM
    OcManagerContext =
#endif
    CommonInitialization();
    END_SECTION(L"Common Initialiazation");

    if(Upgrade || MiniSetup) {

        InitializePidVariables();
        TESTHOOK(521);

    } else {
        if(!InitializePidVariables()) {
            FatalError(MSG_SETUP_CANT_READ_PID,0,0);
        }
        //
        // Do the wizard. Time how long it takes, to later help further randomize
        // the account domain sid we're going to generate later.
        //
        PreWizardTickCount = GetTickCount();
    }

    //
    // Disable the PM engine from powering down the machine
    // while the wizard is going.
    //
    SetThreadExecutionState( ES_SYSTEM_REQUIRED |
                             ES_DISPLAY_REQUIRED |
                             ES_CONTINUOUS );

    SetUpDataBlock();
    InternalSetupData.CallSpecificData1 = 0;

    //
    // Create Windows NT software key entry on both upgrade and clean install
    //
    if(Upgrade || !MiniSetup ) {
        CreateWindowsNtSoftwareEntry(TRUE);
    }

    END_SECTION(L"Initialization");


    BEGIN_SECTION(L"Wizard");
#ifdef _OCM
    MYASSERT(OcManagerContext);
    Wizard(OcManagerContext);
    //
    // this call was moved to CopyFilesDlgProc as an optimization
    //
    //KillOcManager(OcManagerContext);
#else
    Wizard();
#endif
    END_SECTION(L"Wizard");

Recovery:

    BEGIN_SECTION(L"Recovery");
    if (AsrIsEnabled()) {
        AsrExecuteRecoveryApps();
    }
    END_SECTION(L"Recovery");

    BEGIN_SECTION(L"Shutdown");
    ShutdownSetup();
    END_SECTION(L"Shutdown");

    RemoveAllPendingOperationsOnRestartOfGUIMode();

    if (hinstBB)
    {
        FreeLibrary(hinstBB);
        hinstBB = NULL;
    }

    LogPidValues();

    END_SECTION(L"Installing Windows NT");

#if defined(_ENABLE_SAC_CHANNEL_LOGGING_)
    SacChannelTerminate();
#endif

}


VOID
RemoveMSKeyboardPtrPropSheet (
    VOID
    )

/*++

Routine Description:

    Fixes problem with IntelliType Manager under NT 4.0 by disabling it.

Arguments:

    None.

Returns:

    None.

--*/

{
    HKEY  hkeyDir;                     // handle of the key containing the directories
    TCHAR szKbdCpPath[MAX_PATH];       // buffer for the fully-qualified path to INI file
    LONG  lRet;                        // return value from RegQueryValueEx
    DWORD dwDataType;                  // data-type returned from call to RegQueryValueEx
    DWORD BufferSize;
    PCWSTR sz_off = L"OFF";

    //
    // open the key that contains the directories of all the software for all the MS Input Devices
    //
    RegOpenKey ( HKEY_CURRENT_USER,
        L"Control Panel\\Microsoft Input Devices\\Directories", &hkeyDir );

    //
    // get the path to the MS Keyboard software
    //
    BufferSize = sizeof (szKbdCpPath);
    lRet = RegQueryValueEx ( hkeyDir, L"Keyboard", 0, &dwDataType,
        (LPBYTE)szKbdCpPath, &BufferSize);

    //
    // close the directories key now
    //
    RegCloseKey ( hkeyDir );

    // check if we were able to get the directory of the keyboard software; if not, then
    // there may be no keyboard software installed or at least we don't know where
    // to find it; if we got it OK, then use it
    if (lRet == ERROR_SUCCESS &&
        ARRAYSIZE(szKbdCpPath) >= (lstrlen(szKbdCpPath) + ARRAYSIZE(L"\\KBDCP.INI"))) {

        //
        // we have the path to the INI file, so build the fully qualified path to the INI file
        //
        lstrcat ( szKbdCpPath, L"\\KBDCP.INI" );

        //
        // remove the KBDPTR32.DLL entry from the list of 32-bit property sheet DLLs now,
        // because we don't want it loading on Windows NT 4.0 or later
        WritePrivateProfileString ( L"Property Sheets 32", L"KBDPTR32.DLL",
            NULL, szKbdCpPath );

        lRet = RegOpenKey (HKEY_CURRENT_USER,
            L"Control Panel\\Microsoft Input Devices\\WindowsPointer",
            &hkeyDir);

        if (lRet == ERROR_SUCCESS) {

            RegSetValueEx (
                hkeyDir,
                L"MouseKey",
                0,
                REG_SZ,
                (LPBYTE)sz_off,
                (lstrlen(sz_off)+1) * sizeof(WCHAR)
                );

            RegCloseKey (hkeyDir);
        }
    }
}


VOID
FixWordPadReg (
    VOID
    )

/*++

Routine Description:

    Fixes problem with registry entry that associates .doc files with WordPad.

Arguments:

    None.

Returns:

    None.

--*/

{
    PCWSTR  SearchString  = L"WordPad.Document";
    PCWSTR  ReplaceString = L"WordPad.Document.1";
    LONG    Ret;
    HKEY    Key;
    DWORD   Type;
    WCHAR   Data[MAX_PATH];
    DWORD   Size = sizeof(Data);

    Ret = RegOpenKeyEx (
        HKEY_CLASSES_ROOT,
        L".doc",
        0,
        KEY_ALL_ACCESS,
        &Key
        );
    if (Ret != ERROR_SUCCESS) {
        return;
    }

    Ret = RegQueryValueEx (
        Key,
        L"",
        NULL,
        &Type,
        (LPBYTE)Data,
        &Size
        );
    if (Ret != ERROR_SUCCESS ||
        lstrcmp ((PCWSTR)Data, SearchString)) {

        return;
    }

    RegSetValueEx (
        Key,
        L"",
        0,
        Type,
        (PBYTE)ReplaceString,
        (lstrlen (ReplaceString) + 1) * sizeof (WCHAR)
        );
}


VOID
ProcessRegistryFiles(
    IN  HWND    Billboard
    )

/*++

Routine Description:

    This function processes all the inf files listed in the section
    [RegistryInfs] of syssetup.inf.
    The infs listed in this section will populate/upgrade the DEFAULT
    hive and HKEY_CLASSES_ROOT.

    Note that any errors that occur during this phase are fatal.


Arguments:

    Billboard - Handle to the billboard displayed when this function was called
                If an error occurs, tyhe function will kill the billboard.

Return Value:

    None.
    This function will not return if an error occurs.

--*/

{
    ULONG      LineCount;
    ULONG      LineNo;
    PCWSTR     RegSectionName = L"RegistryInfs";
    PCWSTR     InfName;
    HINF       InfHandle;
    INFCONTEXT InfContext;
    BOOL       b;

    //
    // Get the number of lines in the section. The section may be empty
    // or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(SyssetupInf,RegSectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(SyssetupInf,RegSectionName,LineNo,&InfContext) &&
               ((InfName = pSetupGetField(&InfContext,1)) != NULL) ) {

                //
                // Now load the registry (win95-style!) infs.
                //
                //
                InfHandle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,NULL);

                if(InfHandle == INVALID_HANDLE_VALUE) {
                    KillBillboard(Billboard);
                    FatalError(MSG_LOG_SYSINFBAD,InfName,0,0);
                }

                //
                // Process the inf just opened
                //
                b = SetupInstallFromInfSection( NULL,       // Window,
                                                InfHandle,
                                                (Upgrade)? L"Upgrade" : L"CleanInstall",
                                                SPINST_ALL & ~SPINST_FILES,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL
                                              );
                if(!b) {
                    KillBillboard(Billboard);
                    FatalError(MSG_LOG_SYSINFBAD,InfName,0,0);
                }
            }
        }
    }
}


UCHAR
QueryDriveLetter(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    UCHAR                       c;
    WCHAR                       name[80], result[80], num[10];
    DWORD                       i, j;
    HANDLE                      h;
    BOOL                        b;
    DWORD                       bytes;
    PARTITION_INFORMATION       partInfo;

    layout = LocalAlloc(0, 4096);
    if (!layout) {
        return 0;
    }

    for (c = 'C'; c <= 'Z'; c++) {

        name[0] = c;
        name[1] = ':';
        name[2] = 0;

        if (QueryDosDevice(name, result, 80) < 17) {
            continue;
        }

        j = 0;
        for (i = 16; result[i]; i++) {
            if (result[i] == '\\') {
                break;
            }
            num[j++] = result[i];
        }
        num[j] = 0;

        wsprintf(name, L"\\\\.\\PhysicalDrive%s", num);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, layout,
                            4096, &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (layout->Signature != Signature) {
            continue;
        }

        wsprintf(name, L"\\\\.\\%c:", c);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (partInfo.StartingOffset.QuadPart == Offset) {
            break;
        }
    }

    LocalFree(layout);

    return (c <= 'Z') ? c : 0;
}



MIGDLLINIT MigDllInitProc;
MIGDLLSHUTDOWN MigDllShutdownProc;
MIGDLLCLOSEW MigDllCloseProc;
MIGDLLOPENW MigDllOpenProc;
MIGDLLFREELIST MigDllFreeListProc;
MIGDLLENUMNEXTW MigDllEnumNextProc;
MIGDLLENUMFIRSTW MigDllEnumFirstProc;
MIGDLLADDDLLTOLISTW MigDllAddDllToListProc;
MIGDLLCREATELIST MigDllCreateListProc;
MIGDLLINITIALIZEDSTW MigDllInitializeDstProc;
MIGDLLAPPLYSYSTEMSETTINGSW MigDllApplySystemSettingsProc;

BOOL
LoadMigLibEntryPoints (
    HANDLE Library
    )
{

    MigDllInitProc = (MIGDLLINIT) GetProcAddress (Library, "MigDllInit");
    MigDllShutdownProc = (MIGDLLSHUTDOWN) GetProcAddress (Library, "MigDllShutdown");
    MigDllCloseProc = (MIGDLLCLOSEW) GetProcAddress (Library, "MigDllCloseW");
    MigDllOpenProc = (MIGDLLOPENW) GetProcAddress (Library, "MigDllOpenW");
    MigDllFreeListProc = (MIGDLLFREELIST) GetProcAddress (Library, "MigDllFreeList");
    MigDllEnumNextProc = (MIGDLLENUMNEXTW) GetProcAddress (Library, "MigDllEnumNextW");
    MigDllEnumFirstProc = (MIGDLLENUMFIRSTW) GetProcAddress (Library, "MigDllEnumFirstW");
    MigDllAddDllToListProc = (MIGDLLADDDLLTOLISTW) GetProcAddress (Library, "MigDllAddDllToListW");
    MigDllCreateListProc = (MIGDLLCREATELIST) GetProcAddress (Library, "MigDllCreateList");
    MigDllInitializeDstProc = (MIGDLLINITIALIZEDSTW) GetProcAddress (Library, "MigDllInitializeDstW");
    MigDllApplySystemSettingsProc = (MIGDLLAPPLYSYSTEMSETTINGSW) GetProcAddress (Library, "MigDllApplySystemSettingsW");

    if (!MigDllInitProc ||
        !MigDllShutdownProc ||
        !MigDllCloseProc ||
        !MigDllOpenProc ||
        !MigDllFreeListProc ||
        !MigDllEnumNextProc ||
        !MigDllEnumFirstProc ||
        !MigDllAddDllToListProc ||
        !MigDllCreateListProc ||
        !MigDllInitializeDstProc ||
        !MigDllApplySystemSettingsProc
        ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
CallMigDllEntryPoints (
    PMIGDLLENUM Enum
    )
{
    MIGRATIONDLL dll;
    LONG rc;

    if (!MigDllOpenProc (&dll, Enum->Properties->DllPath, APPLYMODE, FALSE, SOURCEOS_WINNT)) {
        return FALSE;
    }


    __try {

        rc = ERROR_SUCCESS;
        if (!MigDllInitializeDstProc (
            &dll,
            Enum->Properties->WorkingDirectory,
            SourcePath,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

        if (!MigDllApplySystemSettingsProc (
            &dll,
            Enum->Properties->WorkingDirectory,
            NULL,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

    }
    __finally {
        MigDllCloseProc (&dll);
    }


    return TRUE;
}



BOOL
RunMigrationDlls (
    VOID
    )
{

    WCHAR libraryPath[MAX_PATH];
    HANDLE libHandle = NULL;
    DLLLIST list = NULL;
    MIGDLLENUM e;
    WCHAR DllInfPath[MAX_PATH];
    WCHAR DllPath[MAX_PATH];
    HINF inf;
    INFCONTEXT ic;
    MIGRATIONDLL dll;


    //
    // Build handle to library and load.
    //
    if(!GetSystemDirectory (libraryPath, MAX_PATH - ARRAYSIZE(TEXT("miglibnt.dll")))){
        MYASSERT(FALSE);
    }
    pSetupConcatenatePaths (libraryPath, TEXT("miglibnt.dll"), MAX_PATH, NULL);
    libHandle = LoadLibrary (libraryPath);
    if (!libHandle || libHandle == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    __try {

        if (!LoadMigLibEntryPoints (libHandle)) {
            __leave;
        }

        if (!MigDllInitProc ()) {
            __leave;
        }

        list = MigDllCreateListProc ();

        if (!list) {
            __leave;
        }


        //
        // Read in list of dlls.
        //
        if(!GetWindowsDirectory (DllInfPath, MAX_PATH - ARRAYSIZE(TEXT("Setup\\dlls.inf")))){
            MYASSERT(FALSE);
        }
        pSetupConcatenatePaths (DllInfPath, TEXT("Setup\\dlls.inf"), MAX_PATH, NULL);
        inf = SetupOpenInfFile (DllInfPath, NULL, INF_STYLE_WIN4, NULL);
        if (!inf || inf == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetupFindFirstLine (inf, TEXT("DllsToLoad"), NULL, &ic)) {
            do {

                if (SetupGetStringField (&ic, 1, DllPath, MAX_PATH,NULL)) {

                    if (MigDllOpenProc (&dll, DllPath, APPLYMODE, FALSE, SOURCEOS_WINNT)) {

                        MigDllAddDllToListProc (list, &dll);
                        MigDllCloseProc (&dll);
                    }
                }

            } while (SetupFindNextLine (&ic, &ic));
        }


        //
        // Enumerate all migration dlls we ran on the winnt32 side and run
        // their syssetup side entry points.
        //
        if (MigDllEnumFirstProc (&e, list)) {
            do {

                CallMigDllEntryPoints (&e);

            } while (MigDllEnumNextProc (&e));
        }

    }
    __finally {

        if (list) {
            MigDllFreeListProc (list);
        }

        if (libHandle && libHandle != INVALID_HANDLE_VALUE) {

            if( MigDllShutdownProc) {
                MigDllShutdownProc ();
            }

            FreeLibrary (libHandle);
        }
    }

    return TRUE;

}


BOOL
RunSetupPrograms(
    IN PVOID InfHandle,
    PWSTR SectionName
    )

/*++

Routine Description:

    This routine executes the commands listed on [RunPrograms] section in the syssetup inf file.

    Each line is interpreted as a single command.


Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    WCHAR OldCurrentDir[MAX_PATH];
    WCHAR System32Dir[MAX_PATH];
    LONG LineCount,LineNo;
    PCWSTR CommandLine;
    DWORD DontCare;
    BOOL AnyError;
    INFCONTEXT InfContext;


    //
    // Set current directory to system32.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    if(!GetSystemDirectory(System32Dir, MAX_PATH)){
        MYASSERT(FALSE);
    }
    if(!SetCurrentDirectory(System32Dir)){
        MYASSERT(FALSE);
    }

    //
    // Get the number of lines in the section that contains the commands to
    // be executed. The section may be empty or non-existant; this is not
    // an error condition. In that case LineCount may be -1 or 0.
    //
    AnyError = FALSE;
    LineCount = SetupGetLineCount(InfHandle,SectionName);

    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,(DWORD)LineNo,&InfContext)
           && (CommandLine = pSetupGetField(&InfContext,1))) {
                if(!InvokeExternalApplication(NULL,CommandLine,&DontCare)) {
                    AnyError = TRUE;
                    SetupDebugPrint1(L"SETUP: Unable to execute the command: %ls", CommandLine);
                }
        } else {
            //
            // Strange case, inf is messed up
            //
            AnyError = TRUE;
            SetupDebugPrint(L"SETUP: Syssetup.inf is corrupt");
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        if(!SetCurrentDirectory(OldCurrentDir)){
            MYASSERT(FALSE);
        }
    }

    if(AnyError) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PROGRAM_FAIL,
            SectionName,
            NULL,NULL);
    }

    return(!AnyError);
}


VOID
GetUnattendRunOnceAndSetRegistry(
    VOID
    )
{
    HINF AnswerInf;
    WCHAR AnswerFile[MAX_PATH];
    WCHAR Buf[128];
    BOOL AnyError;
    INFCONTEXT InfContext;
    LONG LineCount,LineNo;
    PCWSTR SectionName = pwGuiRunOnce;
    PCWSTR CommandLine;
    HKEY hKey;


    if(!GetSystemDirectory(AnswerFile, MAX_PATH - ARRAYSIZE(WINNT_GUI_FILE))){
        MYASSERT(FALSE);
        return;
    }
    pSetupConcatenatePaths(AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

    AnswerInf = SetupOpenInfFile(AnswerFile,NULL,INF_STYLE_OLDNT,NULL);
    if(AnswerInf == INVALID_HANDLE_VALUE) {
        return;
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", &hKey ) != ERROR_SUCCESS) {
        SetupCloseInfFile( AnswerInf );
        return;
    }

    AnyError = FALSE;
    LineCount = SetupGetLineCount(AnswerInf, SectionName);

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if(SetupGetLineByIndex(AnswerInf,SectionName,(DWORD)LineNo,&InfContext)
           && (CommandLine = pSetupGetField(&InfContext,1)))
        {
            MYASSERT((wcslen(SectionName) + 11/*%d can produce max 11 chars*/) <= ARRAYSIZE(Buf));
            swprintf( Buf, L"%ws%d", SectionName, LineNo );
            if (RegSetValueEx( hKey, Buf, 0, REG_EXPAND_SZ, (LPBYTE)CommandLine, (wcslen(CommandLine)+1)*sizeof(WCHAR) ) != ERROR_SUCCESS) {
                AnyError = TRUE;
            }
        } else {
            //
            // Strange case, inf is messed up
            //
            AnyError = TRUE;
        }
    }

    RegCloseKey( hKey );
    SetupCloseInfFile( AnswerInf );

    return;
}

// This function returns the product flavor as a DWORD.
// NOTE: The value has to be the same as the *_PRODUCTTYPE in winnt32.h
DWORD GetProductFlavor()
{
    DWORD ProductFlavor = 0;        // Default Professional
    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO*)&osvi);
    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        if (osvi.wSuiteMask & VER_SUITE_PERSONAL)
        {
            ProductFlavor = 4;  // Personal
        }
    }
    else
    {
        ProductFlavor = 1;  // In the server case assume normal server
        if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
        {
            ProductFlavor = 3;  // Datacenter
        }
        else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            ProductFlavor = 2;  // Advanced server
        }
    }
    return ProductFlavor;
}

void PrepareBillBoard(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    TCHAR *p;
    WNDCLASS    wndclass;
    INITBILLBOARD pinitbb;

    hinstBB = LoadLibrary(TEXT("winntbbu.dll"));
    if (hinstBB)
    {
        *szPath = 0;
        if (MyGetModuleFileName (MyModuleHandle, szPath, MAX_PATH))
        {
            if(p = wcsrchr(szPath,L'\\'))
            {
                *p = 0;
            }
        }

        pinitbb = (INITBILLBOARD)GetProcAddress(hinstBB, "InitBillBoard");
        if (pinitbb)
        {
            (*pinitbb)(hwnd, szPath, GetProductFlavor());
            SetBBStep(4);
        }
    }
}

void TerminateBillBoard()
{
    TERMBILLBOARD pTermBillBoard;
    if (hinstBB)
    {
        if (pTermBillBoard = (TERMBILLBOARD)GetProcAddress(hinstBB, "TermBillBoard"))
            pTermBillBoard ();
    }
}


HWND GetBBhwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;
    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}


void SetBBStep(int iStep)
{
    static SETSTEP psetstep = NULL;
    if (psetstep == NULL)
    {
        if (hinstBB)
        {
            psetstep = (SETSTEP )GetProcAddress(hinstBB, "SetStep");
        }
    }
    if (psetstep)
        psetstep(iStep);
}

VOID
CenterWindowRelativeToWindow(
    HWND hwndtocenter,
    HWND hwndcenteron,
    BOOL bWizard
    )

/*++

Routine Description:

    Centers a dialog hwndtocenter on Windows hwndcenteron.
    if bWizard and the height of the hwndcenteron is 480 or less
    align windows to the right edge of the hwndcenteron.
    In all other cases center both ways.

Arguments:

    hwndtocenter - window handle of dialog to center
    hwndcenteron - window handle to center dialog on
    bWizard      - in low res, align dialog with the right
                   edge of hwndcenteron

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;
    UINT uiHeight = 0;

    GetWindowRect(GetDesktopWindow(), &rcWindow);
    uiHeight = rcWindow.bottom - rcWindow.top;

    if (hwndcenteron == NULL)
        Parent = GetDesktopWindow();
    else
        Parent = hwndcenteron;

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwndtocenter,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);


    // Anything but the wizard can stay centered horizontally.
    // or if we don't have a billboard (hwndcenteron == NULL)
    // or if the height of the desktop is more then 480
    // just center
    if (!bWizard || (hwndcenteron == NULL) || (uiHeight > 480))
    {
        x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    }
    else
    {
        RECT rcParentWindow;

        GetWindowRect(Parent, &rcParentWindow);
        x = point.x + rcParentWindow.right - rcParentWindow.left + 1 - w;
    }

    MoveWindow(hwndtocenter,x,y,w,h,FALSE);
}


VOID
CopyOemProgramFilesDir(
    VOID
    )

/*++

Routine Description:

    Tree copies the $OEM$\\$PROGS to %Program Files% folder.

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR OemDir[MAX_PATH];
    WCHAR ProgramFilesDir[MAX_PATH];
    DWORD Error = NO_ERROR;

    //
    // Build the target Program Files folder path
    //
    ExpandEnvironmentStrings(L"%ProgramFiles%",ProgramFilesDir,MAX_PATH);

    //
    // SourcePath should be initialized to $win_nt$.~ls
    //
    lstrcpy(OemDir,SourcePath);
    pSetupConcatenatePaths(OemDir,WINNT_OEM_DIR,MAX_PATH,NULL);
    if(!pSetupConcatenatePaths(OemDir,WINNT_OEM_FILES_PROGRAMFILES,MAX_PATH,NULL)){
        MYASSERT(FALSE);
        SetuplogError(LogSevWarning,
                      L"CopyOemProgramFilesDir: OemDir has been truncated due to buffer size\r\n",
                      0,
                      NULL,
                      NULL);
    }
    Error = TreeCopy(OemDir,ProgramFilesDir);
    if (!NT_SUCCESS(Error)) {
        SetuplogError(LogSevWarning,
                  L"Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n",
                  0, Error, OemDir, ProgramFilesDir, Error, NULL,NULL
                  );
        return;
    }
}


VOID
CopyOemDocumentsDir(
    VOID
    )

/*++

Routine Description:

    Tree copies the $OEM$\\$DOCS to %Document and Settings% folder.

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR OemDir[MAX_PATH];
    WCHAR DocumentsAndSettingsDir[MAX_PATH];
    DWORD Error = NO_ERROR, dwSize = ARRAYSIZE(DocumentsAndSettingsDir);

    //
    // Make sure we can get the Documents and Settings folder
    //
    if (GetProfilesDirectory(DocumentsAndSettingsDir,&dwSize))
    {
        //
        // SourcePath should be initialized to $win_nt$.~ls
        //
        lstrcpy(OemDir,SourcePath);
        pSetupConcatenatePaths(OemDir,WINNT_OEM_DIR,MAX_PATH,NULL);
        if(!pSetupConcatenatePaths(OemDir,WINNT_OEM_FILES_DOCUMENTS,MAX_PATH,NULL)){
            MYASSERT(FALSE);
            SetuplogError(LogSevWarning,
                          L"CopyOemDocumentsDir: OemDir has been truncated due to buffer size\r\n",
                          0,
                          NULL,
                          NULL);
        }
        Error = TreeCopy(OemDir,DocumentsAndSettingsDir);
        if (!NT_SUCCESS(Error)) {
            SetuplogError(LogSevWarning,
                      L"Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n",
                      0, Error, OemDir, DocumentsAndSettingsDir, NULL,NULL
                      );
            return;
        }
    }
    else {
        SetuplogError(LogSevWarning,
                  L"SETUP: GetProfilesDirectory() failed in function CopyOemDocumentsDir()\r\n",
                  0, NULL, NULL
                  );
    }
}

BOOL
SystemMyGetUserProfileDirectory(
    IN     LPWSTR szUser,           // a user account name
    OUT    LPWSTR szUserProfileDir, // buffer to receive null terminate string
    IN OUT LPDWORD pcchSize         // input the buffer size in TCHAR, including terminating NULL
    )

/*++

Routine Description:

    This function does what the SDK function GetUserProfileDirectory does,
    except that it accepts a user account name instead of handle to a user
    token.

Return Value:

    TRUE  - Success

    FALSE - Failure

Note:

   This function is copy from msobcomm\misc.cpp exactly. We may want
   to put is to common\util.cpp.

--*/

{
    PSID          pSid = NULL;
    DWORD         cbSid = 0;
    LPWSTR        szDomainName = NULL;
    DWORD         cbDomainName = 0;
    SID_NAME_USE  eUse = SidTypeUser;
    BOOL          bRet;

    bRet = LookupAccountName(NULL,
                             szUser,
                             NULL,
                             &cbSid,
                             NULL,
                             &cbDomainName,
                             &eUse);

    if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pSid = (PSID) LocalAlloc(LPTR, cbSid);
        szDomainName = (LPWSTR) LocalAlloc(LPTR, cbDomainName * sizeof(TCHAR));

        if (pSid && szDomainName)
        {
            bRet = LookupAccountName(NULL,
                                     szUser,
                                     pSid,
                                     &cbSid,
                                     szDomainName,
                                     &cbDomainName,
                                     &eUse);
        }

    }

    if (bRet && SidTypeUser == eUse)
    {
        bRet = GetUserProfileDirFromSid(pSid, szUserProfileDir, pcchSize);
        if (!bRet)
        {
            SetuplogError(LogSevWarning,
                          L"Setup failed to GetUserProfileDirFromSid.  (GetUserProfileDirFromSid failed %1!u!)\r\n",
                          0, GetLastError(), NULL,NULL
                          );
        }
    }
    else
    {
        if (SidTypeUser == eUse)
        {
            SetuplogError(LogSevWarning,
                          L"LookupAccountName %1 (%2!u!)\r\n",
                          0, szUser, GetLastError(),NULL,NULL
                          );
        }
    }

    if (pSid)
    {
        LocalFree(pSid);
        pSid = NULL;
    }

    if (szDomainName)
    {
        LocalFree(szDomainName);
        szDomainName = NULL;
    }

    return bRet;
}

BOOL
SystemResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    )
/*++

Routine Description:

    Reset a registry key by deleting the key and all subvalues
    then recreate the key

Arguments:

Return Value:

--*/

{
    HKEY hkey;
    HKEY nkey;
    DWORD rc;
    BOOL AnyErrors;
    DWORD disp;

    AnyErrors = FALSE;

    rc = RegCreateKeyEx(Rootkey, Subkey, 0L, NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE, NULL, &hkey, NULL);
    if ( rc == NO_ERROR )
    {
        rc = SHDeleteKey(hkey, Delkey);
        if( (rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND) ) 
        {
            AnyErrors = TRUE;
        } 
        else 
        {
            rc = RegCreateKeyEx(hkey, Delkey, 0L, NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_CREATE_SUB_KEY, NULL, &nkey, &disp);
            if ( rc != NO_ERROR ) 
            {
                AnyErrors = TRUE;
            }
            else
            {
                RegCloseKey(nkey);
            }
        }
        RegCloseKey(hkey);
    } 
    else 
    {
        AnyErrors = TRUE;
    }

    return (!AnyErrors);
}

BOOL
SystemCopyRegistryValues(
    IN HKEY     SrcRootKey,
    IN LPCWSTR  SrcSubKey,
    IN HKEY     DestRootKey,
    IN LPCWSTR  DestSubKey,
    IN LPCWSTR* ValueNames
    )

/*++

Routine Description:

    Copy values from SrcRootKey\SrcSubKey to DestRootKey\DestSubKey.

Arguments:

    SrcRootKey  - source root key handle
    SrcSubKey   - source subkey name
    DestRootKey - destination root key handle
    DestSubKey  - destination subkey name
    ValueNames  - the list of value to copy

Return Value:

    TRUE if the available values are copy successfully, FALSE
    otherwise (if source key or some source values are not available,
    it is NOT considered as an error)

Note:

    This function assumes the value of each ValueName is no greater
    than MAX_PATH * sizeof(TCHAR) bytes.

--*/

{
    BOOL  ret = TRUE;
    DWORD rc = ERROR_SUCCESS;
    HKEY  hkeySrc = NULL;
    HKEY  hkeyDest = NULL;
    DWORD Type = 0;
    TCHAR Data[MAX_PATH];
    DWORD DataByteCount = 0;
    int   i;

    rc = RegOpenKeyEx(
            SrcRootKey,
            SrcSubKey,
            0,
            KEY_QUERY_VALUE,
            &hkeySrc
            );

    if (rc != ERROR_SUCCESS)
    {
        //
        // return value is true, since the key is not available
        // and nothing to copy.
        //
        goto cleanup;
    }

    rc = RegCreateKeyEx(
            DestRootKey,
            DestSubKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkeyDest,
            NULL
            );

    if (rc != ERROR_SUCCESS)
    {
        SetuplogError(
            LogSevWarning,
            L"SystemCopyRegistryValues:  (RegCreateKeyEx failed %1!u!)\r\n",
            0, rc, NULL,NULL
            );        
        ret = FALSE;
        goto cleanup;
    }

    for (i = 0; ValueNames[i] != NULL; i++)
    {
        DataByteCount = sizeof(Data);

        rc = RegQueryValueEx(
           hkeySrc,
           ValueNames[i],
           NULL,
           &Type,
           (LPBYTE) Data,
           &DataByteCount
           );

        if (rc == ERROR_SUCCESS)
        {
            rc = RegSetValueEx(
                    hkeyDest,
                    ValueNames[i],
                    0,
                    Type,
                    (LPBYTE) Data,
                    DataByteCount
                    );

            if (rc != ERROR_SUCCESS)
            {
                SetuplogError(
                    LogSevWarning,
                    L"SystemCopyRegistryValues:  (RegSetValueEx failed %1!u!)\r\n",
                    0, rc, NULL,NULL
                    );
                ret = FALSE;
                break;
            }
        }
        else
        {
            //
            // Make sure the caller is aware of the buffer size limit.
            //
            if (rc == ERROR_MORE_DATA)
            {
                SetuplogError(LogSevWarning,
                              L"SystemCopyRegistryValues: buffer limit exceeded\r\n",
                              0, NULL,NULL
                              );
            }
        }
    }

cleanup:

    if (hkeyDest != NULL)
    {
        RegCloseKey(hkeyDest);
    }

    if (hkeySrc != NULL)
    {
        RegCloseKey(hkeySrc);
    }

    return ret;
}



BOOL
SystemUpdateUserProfileDirectory(
    IN LPTSTR szSrcUser
    )
{

#define DUMMY_HIVE_NAME      L"$$DEFAULT_USER$$"
#define ACTIVE_SETUP_KEY     DUMMY_HIVE_NAME L"\\SOFTWARE\\Microsoft\\Active Setup"
#define ACTIVE_SETUP_SUBKEY  L"Installed Components"
#define CPL_DESKTOP_SRC_KEY  L".DEFAULT\\Control Panel\\Desktop"
#define CPL_DESKTOP_DEST_KEY DUMMY_HIVE_NAME L"\\Control Panel\\Desktop"

    static LPCWSTR szMUIValues[] = { L"MultiUILanguageId", L"MUILanguagePending", NULL };

    BOOL  bRet = FALSE;
    WCHAR szSrcProfileDir[MAX_PATH];
    DWORD cchSrcProfileDir = ARRAYSIZE(szSrcProfileDir);
    WCHAR szDestProfileDir[MAX_PATH];
    DWORD cchDestProfileDir = ARRAYSIZE(szDestProfileDir);
    WCHAR szDefaultUserHivePath[MAX_PATH];
    HKEY  hHiveKey = NULL;
    DWORD rc;

    if (!SystemMyGetUserProfileDirectory(szSrcUser, szSrcProfileDir, &cchSrcProfileDir))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to get user profile directory.  (SystemMyGetUserProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    if (!GetDefaultUserProfileDirectory(szDestProfileDir, &cchDestProfileDir))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to get default user profile directory.  (GetDefaultUserProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    if (!CopyProfileDirectory(
        szSrcProfileDir,
        szDestProfileDir,
        CPD_FORCECOPY | CPD_SYNCHRONIZE | CPD_NOERRORUI | CPD_IGNORECOPYERRORS))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to CopyProfileDirectory.  (CopyProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    //
    // Fix default user hive
    //

    pSetupEnablePrivilege(SE_RESTORE_NAME, TRUE);

    lstrcpyn(szDefaultUserHivePath, szDestProfileDir, ARRAYSIZE(szDefaultUserHivePath));
    
    pSetupConcatenatePaths(
        szDefaultUserHivePath,
        L"NTUSER.DAT",
        ARRAYSIZE(szDefaultUserHivePath),
        NULL);

    rc = RegLoadKey(
            HKEY_USERS,
            DUMMY_HIVE_NAME,
            szDefaultUserHivePath);

    if (rc != ERROR_SUCCESS)
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to load Default User hive.  (RegLoadKey failed %1!u!)\r\n",
                      0, rc, NULL,NULL
                      ); 

        goto cleanup;
    }

    //
    // The active setup component install keys of the cloned profile contains 
    // the version checking information. Remove the keys so that components will
    // run per-user initialization code properly.
    //

    if (!SystemResetRegistryKey(
            HKEY_USERS, 
            ACTIVE_SETUP_KEY,
            ACTIVE_SETUP_SUBKEY))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to load Default User hive.  (SystemResetRegistryKey failed)\r\n",
                      0, NULL,NULL
                      ); 
    }

    //
    // Early on, mini-setup and oobe call intl.cpl to set regional setting.
    // intl.cpl modifies Default User, .DEFAULT, S-1-5-19, S-1-5-20 hives
    // to fix MUI some issues (Windows Bug 617192, 463867). We need to
    // restore the values. (values in .DEFAULT is used because it is already
    // loaded to the registry, while the other two may not.)
    //

    SystemCopyRegistryValues(
        HKEY_USERS,
        CPL_DESKTOP_SRC_KEY,
        HKEY_USERS,
        CPL_DESKTOP_DEST_KEY,
        szMUIValues
        );


    RegUnLoadKey(
        HKEY_USERS,
        DUMMY_HIVE_NAME
        );

    bRet = TRUE;

cleanup:

    return bRet;
}

BOOL
UpdateServerProfileDirectory(
    VOID
    )

/*++

Routine Description:

    Copy the customized user profile (administrator) to all user profiles.

Arguments:

    None.

Return Value:

    Boolean.

--*/

{
    BOOL bRet = FALSE;
    WCHAR szTemplateUser[MAX_PATH];

    BEGIN_SECTION(L"Updating Server Profile Directories");
    if(LoadString(MyModuleHandle,
                  IDS_ADMINISTRATOR,
                  szTemplateUser,
                  ARRAYSIZE(szTemplateUser)) != 0)
    {
        if ( !(bRet = SystemUpdateUserProfileDirectory(szTemplateUser)) )
        {
            SetuplogError(LogSevWarning,
                          L"Setup failed to update server profile directory.\r\n",
                          0, NULL, NULL,NULL
                          );
        }
    }
    END_SECTION(L"Updating Server Profile Directories");

    return bRet;
}


BOOL
pSetupInitializeUtils (
    VOID
    )
{
    //
    // This is a stub function so migshared.lib can link. Normally it uses
    // private setupapi functions via sputils?.lib, but because syssetup.dll
    // uses the full setupapi, the pSetupInitializeUtils function is not
    // needed.
    //

    return TRUE;
}

BOOL
pSetupUninitializeUtils (
    VOID
    )
{
    //
    // This is a stub function so migshared.lib can link. Normally it uses
    // private setupapi functions via sputils?.lib, but because syssetup.dll
    // uses the full setupapi, the pSetupUninitializeUtils function is not
    // needed.
    //

    return TRUE;
}

BOOL
OpkCheckVersion(
    DWORD dwMajorVersion,
    DWORD dwQFEVersion
    )

/*++

Routine Description:

    Checks whether OPK tool with specified version numbers is allowed to run on this OS.

Arguments:

    DWORD dwMajorVersion - Major version number for tool.
    DWORD dwQFEVersion   - QFE version number for tool.

Return Value:

    TRUE  - Tool is allowed to run on this OS.
    FALSE - Tool is not allowed to run on this OS.

--*/
{
    BOOL bRet = TRUE,
         bXP  = FALSE;  // Variable is TRUE if this is 2600 XP build. It is set below.
    HKEY hKey = NULL;



    LPTSTR lpszRegPath = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep");

    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        lpszRegPath,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hKey ) )
    {
        DWORD  dwType           = 0,
               cbBuildNumber    = 0;
        LPTSTR lpszBuildNumber  = NULL;

        if ( 2600 == dwMajorVersion )
        {
            bXP = TRUE;
        }

        //
        // Read the minimum allowed build number from the registry:
        //
        // 1. Get the size of the data in the registry
        // 2. Allocate a buffer
        // 3. Read the data.
        //
        if ( ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                                 bXP ? _T("XPMinVersion") : _T("NETMinVersion"),
                                                 NULL,
                                                 &dwType,
                                                 NULL,
                                                 &cbBuildNumber ) ) &&
             ( cbBuildNumber > 0 ) &&
             ( lpszBuildNumber = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cbBuildNumber ) ) &&
             ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                                 bXP ? _T("XPMinVersion") : _T("NETMinVersion"),
                                                 NULL,
                                                 &dwType,
                                                 (LPBYTE) lpszBuildNumber,
                                                 &cbBuildNumber ) ) &&
             ( REG_SZ == dwType ) )
        {
            LPTSTR lpTemp            = NULL;
            DWORD  dwMinMajorVersion = 0,
                   dwMinQFEVersion   = 0;

            //
            // Parse the string that we got from the registry into major version and QFE version.
            //
            if ( lpTemp = _tcsstr( lpszBuildNumber, _T(".") ) )
            {
                *lpTemp = _T('\0');

                // Get the Major version of the build number
                //
                dwMinMajorVersion = _tstoi( lpszBuildNumber );

                // Advance past the NULL separator that we added.
                //
                lpTemp++;
                dwMinQFEVersion = _tstoi( lpTemp );

                //
                // Now make sure we are allowed to run
                //

                if ( dwMajorVersion < dwMinMajorVersion )
                {
                    //
                    // If major version is less than minimum allowed major version don't let it run.
                    //
                    bRet = FALSE;
                }
                else if ( dwMajorVersion == dwMinMajorVersion )
                {
                    //
                    // If major version is equal to the minimum allowed major version then check at the QFE field.
                    //
                    if ( dwQFEVersion < dwMinQFEVersion )
                    {
                        bRet = FALSE;
                    }
                }
            }
        }

        if ( lpszBuildNumber )
        {
            HeapFree( GetProcessHeap(), 0, lpszBuildNumber );
        }

        RegCloseKey( hKey );
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\syspnp.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    syspnp.c

Abstract:

    Device installation routines.

Author:

    Jaime Sasson (jaimes) 6-Mar-1997

Revision History:


--*/

#include "setupp.h"
#pragma hdrstop

//
// Provide extern references to device (setup) class GUIDs instantiated in
// clasinst.c.
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
#include <initguid.h>

//
// UpdateDriverForPlugAndPlayDevices constants
//
#include <newdev.h>
#include <strsafe.h>

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

#define PNP_NEW_HW_PIPE             TEXT("\\\\.\\pipe\\PNP_New_HW_Found")
#define PNP_CREATE_PIPE_EVENT       TEXT("PNP_Create_Pipe_Event")
#define PNP_BATCH_PROCESSED_EVENT   TEXT("PNP_Batch_Processed_Event")
#define PNP_PIPE_TIMEOUT            180000

#ifdef PRERELEASE

//
// legacy-phase1 can take a long time in certain cases
//
#define PNP_LEGACY_PHASE1_TIMEOUT   2*60*1000
#define PNP_LEGACY_PHASE2_TIMEOUT   1*60*1000
#define PNP_LEGACY_PHASE3_TIMEOUT   1*60*1000
#define PNP_ENUM_TIMEOUT            1*60*1000
#define RUNONCE_TIMEOUT             1*60*1000
#define RUNONCE_THRESHOLD           20 // * RUNONCE_TIMEOUT

#else  // PRERELEASE

//
// legacy-phase1 can take a long time in certain cases
//
#define PNP_LEGACY_PHASE1_TIMEOUT   4*60*1000
#define PNP_LEGACY_PHASE2_TIMEOUT   2*60*1000
#define PNP_LEGACY_PHASE3_TIMEOUT   2*60*1000
#define PNP_ENUM_TIMEOUT            2*60*1000
#define RUNONCE_TIMEOUT             2*60*1000
#define RUNONCE_THRESHOLD           20 // * RUNONCE_TIMEOUT

#endif // PRERELEASE

//
// Declare a private INF key string recogized only by syssetup during device
// installation...
//
PWSTR  szSyssetupPnPFlags = L"SyssetupPnPFlags";
//
// ...and define the flags that are valid for this value
//
#define PNPFLAG_DONOTCALLCONFIGMG   0x00000001



//
//  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
//           Remove the #define below, after the network guys (jameelh) fix
//           the network class installer. This should happen before beta2
//
#define BB_PNP_NETWORK_TIMEOUT  10*60*1000
#define BB_NETWORK_GUID_STRING  L"{4D36E972-E325-11CE-BFC1-08002BE10318}"


BOOL                PrivilegeAlreadySet = FALSE;
//
// pnplog.txt is the file that lists the class installers
// that hang during GUI setup, so that when GUI setup is restarted,
// the offendig class installers will not be invoked again.
// This file is created during GUI setup on %SystemRoot%, and is always
// deleted during textmode setup (the file is listed on txtsetup.sif as
// "delete on upgrade").
// This file will never exist when the system first boots into GUI setup,
// immediately after the completion of textmode setup. This is
// to ensure that an old version of pnplog.txt will not affect the
// upgrade case, or a clean install of a system that is installed on
// a directory that already contains an NT system.
//
PWSTR               szPnpLogFile = L"pnplog.txt";
PWSTR               szEnumDevSection = L"EnumeratedDevices";
PWSTR               szLegacyClassesSection = L"LegacyClasses";
PWSTR               szLegacyDevSection = L"LegacyDevices";

//
// multi-sz list of files that is passed to SfcInitProt that the initial scan
// will not replace. This is used for non-signed drivers that are specified
// by F6 during textmode setup.
//
MULTISZ EnumPtrSfcIgnoreFiles = {NULL, NULL, 0};

//
// Structure for thread parameter
//
typedef struct _PNP_THREAD_PARAMS {
    HWND  Window;
    HWND  ProgressWindow;
    DWORD ThreadId;
    HINF  InfHandle;
    UINT  ProgressWindowStartAtPercent;
    UINT  ProgressWindowStopAtPercent;
    BOOL  SendWmQuit;
} PNP_THREAD_PARAMS, *PPNP_THREAD_PARAMS;

typedef struct _INF_FILE_NAME {
    struct  _INF_FILE_NAME     *Next;
    PWSTR                      InfName;
} *PINF_FILE_NAME, INF_FILE_NAME;


typedef struct _PNP_ENUM_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pDeviceDescription;
    PWSTR                 pDeviceId;
    PVOID                 DevicesInstalledStringTable;
} PNP_ENUM_DEV_THREAD_PARAMS, *PPNP_ENUM_DEV_THREAD_PARAMS;

typedef struct _PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    GUID                  Guid;
    PWSTR                 pClassDescription;
    HWND                  hwndParent;
} PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS;

typedef struct _PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    HSPFILEQ              FileQ;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pClassDescription;
    PWSTR                 pDeviceId;
} PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS;


typedef struct _PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pDeviceId;
    PVOID                 DevicesInstalledStringTable;
} PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS;

//
// private cfgmgr32 API that we use
//

DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

//
// for run-time loading of newdev.dll
//

typedef BOOL (WINAPI *ExternalUpdateDriverForPlugAndPlayDevicesW)(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    );


//
// Private routine prototypes
//

VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount,
    OUT    PULONG LastBatchedDetect
    );

DWORD
pPhase1InstallPnpLegacyDevicesThread(
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pPhase2InstallPnpLegacyDevicesThread(
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pPhase3InstallPnpLegacyDevicesThread(
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pInstallPnpEnumeratedDeviceThread(
    PPNP_ENUM_DEV_THREAD_PARAMS ThreadParams
    );

BOOL
GetDeviceConfigFlags(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    DWORD* pdwConfigFlags
    );

BOOL
SetDeviceConfigFlags(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    DWORD dwConfigFlags
    );

BOOL
InstallOEMInfs(
    VOID
    );

VOID
SfcExcludeMigratedDrivers (
    VOID
    );

BOOL
CallRunOnceAndWait();

BOOL
MarkPnpDevicesAsNeedReinstall(
    PVOID DevicesInstalledStringTable OPTIONAL
    );

ULONG
SyssetupGetPnPFlags(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData
    );

BOOL
IsInstalledInfFromOem(
    IN PCWSTR InfFileName
    );

BOOL
IsInfInLayoutInf(
    IN PCWSTR InfFileName
    );

UINT
pOemF6ScanQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
    PFILEPATHS FilePaths = (PFILEPATHS)Param1;

    //
    // Add the Target filename to the list of files that Sfc should ignore when
    // doing it's final scan at the end of GUI setup.
    //
    if (Notification == SPFILENOTIFY_QUEUESCAN_EX) {
        if (FilePaths->Target) {
            MultiSzAppendString(&EnumPtrSfcIgnoreFiles, FilePaths->Target);
        }
    }

    return NO_ERROR;
}

void
AddOemF6DriversToSfcIgnoreFilesList(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:


Arguments:

    hDevInfo -

    pDeviceInfoData -

Return Value:


--*/
{
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD ScanResult;

    //
    // First check that the selected driver that we just installed is an OEM F6
    // driver.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
    if (SetupDiGetSelectedDriver(hDevInfo,
                                 pDeviceInfoData,
                                 &DriverInfoData) &&
        SetupDiGetDriverInstallParams(hDevInfo,
                                      pDeviceInfoData,
                                      &DriverInfoData,
                                      &DriverInstallParams) &&
        (DriverInstallParams.Flags & DNF_OEM_F6_INF)) {
        //
        // This is an OEM F6 driver.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (!SetupDiGetDeviceInstallParams(hDevInfo,
                                           pDeviceInfoData,
                                           &DeviceInstallParams)) {
            goto clean0;
        }

        FileQueue = SetupOpenFileQueue();

        if (FileQueue == INVALID_HANDLE_VALUE) {
            goto clean0;
        }

        DeviceInstallParams.FileQueue = FileQueue;
        DeviceInstallParams.Flags |= DI_NOVCP;

        //
        // Set the device install params to use our file queue and call
        // DIF_INSTALLDEVICEFILES to build up a list of files for this device.
        //
        if (SetupDiSetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams) &&
            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                      hDevInfo,
                                      pDeviceInfoData)) {
            SetupScanFileQueue(FileQueue,
                               SPQ_SCAN_USE_CALLBACKEX,
                               NULL,
                               pOemF6ScanQueueCallback,
                               NULL,
                               &ScanResult);
        }
    }

clean0:

    if (FileQueue != INVALID_HANDLE_VALUE) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams)) {
            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams);
        }

        SetupCloseFileQueue(FileQueue);
    }
}


BOOL
GetClassGuidForInf(
    IN  PCTSTR InfFileName,
    OUT LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if(!SetupDiGetINFClass(InfFileName,
                           ClassGuid,
                           ClassName,
                           SIZECHARS(ClassName),
                           NULL)) {
        return FALSE;
    }

    if(pSetupIsGuidNull(ClassGuid)) {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // or if it matches with multiple GUIDs, then we abort.
        //
        if(!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) || !NumGuids) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
InstallPnpClassInstallers(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HSPFILEQ FileQ
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR  SectionName = L"DeviceInfsToInstall";
    PCWSTR  IfExistsSectionName = L"DeviceInfsToInstallIfExists";
    PCWSTR  InfFileName;
    GUID    InfClassGuid;
    HKEY    hClassKey;
    BOOL    b = TRUE;

    SC_HANDLE SCMHandle, ServiceHandle;
    SERVICE_STATUS ServiceStatus;


    //
    // Before we do anything else, we have to make sure that the Plug&Play service is up and
    // running, otherwise our ConfigMgr calls will fail, and we won't be able to migrate devices.
    //
    if(SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ)) {

        if(ServiceHandle = OpenService(SCMHandle, L"PlugPlay", SERVICE_QUERY_STATUS)) {

            for(;;) {

                if(!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                    //
                    // Couldn't find out the status of the Plug&Play service--hope for the best
                    // and trudge on ahead.
                    //
                    SetupDebugPrint1( L"SETUP: QueryServiceStatus() failed. Error = %d", GetLastError() );
                    SetupDebugPrint( L"SETUP: Couldn't find out the status of the Plug&Play service" );
                    break;
                }

                if(ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                    //
                    // The service is up and running, we can do our business.
                    //
                    break;
                }

                //
                // The service hasn't started yet--print a message, then wait a second
                // and try again.
                //
                SetupDebugPrint( L"SETUP: PlugPlay service isn't running yet--sleeping 1 second..." );

                Sleep(1000);
            }

            CloseServiceHandle(ServiceHandle);
        }

        CloseServiceHandle(SCMHandle);
    }

    //
    // Get the number of lines in the section that contains the infs whose
    // classes are to be installed.
    // The section may be empty or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)
            && (InfFileName = pSetupGetField(&InfContext,1))) {
                if( !SetupDiInstallClass( hwndParent,
                                          InfFileName,
                                          DI_NOVCP | DI_FORCECOPY,
                                          FileQ ) ) {
                    SetupDebugPrint2( L"SETUP: SetupDiInstallClass() failed. Filename = %ls Error = %lx.", InfFileName, GetLastError() );
                    b = FALSE;
                }
            }
        }
    }

    //
    // Get the number of lines in the section that contains the infs whose
    // classes are to be installed if they already exist.
    // The section may be empty or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,IfExistsSectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(InfHandle,IfExistsSectionName,LineNo,&InfContext)
            && (InfFileName = pSetupGetField(&InfContext,1))) {

                //
                // Check to see if this section already exists in the registry
                //
                if (GetClassGuidForInf(InfFileName, &InfClassGuid)) {

                    if (CM_Open_Class_Key(&InfClassGuid,
                                          NULL,
                                          KEY_READ,
                                          RegDisposition_OpenExisting,
                                          &hClassKey,
                                          CM_OPEN_CLASS_KEY_INSTALLER
                                          ) == CR_SUCCESS) {

                        RegCloseKey(hClassKey);

                        //
                        // This class already exists so we need to reinstall it
                        //
                        if( !SetupDiInstallClass( hwndParent,
                                                  InfFileName,
                                                  DI_NOVCP | DI_FORCECOPY,
                                                  FileQ ) ) {
                            SetupDebugPrint2( L"SETUP: SetupDiInstallClass() failed. Filename = %ls Error = %lx.", InfFileName, GetLastError() );
                            b = FALSE;
                        }
                    }
                }
            }
        }
    }

    return( b );
}


BOOL
FlushFilesToDisk(
    IN PWSTR RootPath
    )

/*++

Routine Description:

    This function flushes the cache of a particular drive, to disk.

Arguments:

    Path to the root directory of the drive whose cache is to be flushed.

Return Value:

    Returns TRUE if the operation succeeds, or FALSE otherwise.

--*/

{
    HANDLE RootHandle;
    LONG   Error;

    //
    // Enable backup privilege.
    //
    if( !PrivilegeAlreadySet ) {
        PrivilegeAlreadySet = pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE) && pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    }
    RootHandle = CreateFile( RootPath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS,
                             0
                           );
    if( RootHandle == INVALID_HANDLE_VALUE ) {
        SetupDebugPrint2( L"SETUP: Failed to open %ls. Error = %d", RootPath, GetLastError() );
        return( FALSE );
    }

    //
    //  Flush the cache
    //
    Error = ( FlushFileBuffers( RootHandle ) )? ERROR_SUCCESS : GetLastError();
    CloseHandle( RootHandle );
    if( Error != ERROR_SUCCESS ) {
        SetupDebugPrint2( L"SETUP: FlushFileBuffers() failed. Root = %ls, Error = %d", RootPath, Error );
    }
    return( Error == ERROR_SUCCESS );
}


BOOL
SyssetupInstallNullDriver(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PVOID            DevicesInstalledStringTable    OPTIONAL
    )

/*++

Routine Description:

    This function installs a the null driver for a particular device.

Arguments:

    hDevInfo    -

    pDeviceInfoData -

Return Value:

    Returns TRUE if the null driver was successfully installed.

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD                Error;
    PWSTR                GUIDUnknownString = L"{4D36E97E-E325-11CE-BFC1-08002BE10318}";
    WCHAR                DevInstId[MAX_DEVICE_ID_LEN];

    Error = ERROR_SUCCESS;

    //
    //  Find out if the GUID of this device is GUID_NULL.
    //  If it is then set it to GUID_DEVCLASS_UNKNOWN, so that after the sysstem 
    //  is installed, Device Manager can include this device in the device tree.
    //
    if(IsEqualGUID(&(pDeviceInfoData->ClassGuid), &GUID_NULL)) {
        SetupDebugPrint( L"SETUP:            Setting GUID_DEVCLASS_UNKNOWN for this device" );
        if( !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                               pDeviceInfoData,
                                               SPDRP_CLASSGUID,
                                               (PBYTE)GUIDUnknownString,
                                               (wcslen(GUIDUnknownString) + 1)*sizeof(WCHAR) ) ) {
            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceRegistryProperty(SPDRP_CLASSGUID) failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceRegistryProperty(SPDRP_CLASSGUID) failed. Error = %d", Error );
            }
            //
            //  In case of error we just ignore the error
            //
            Error = ERROR_SUCCESS;
        }
    } else {
            WCHAR           GUIDString[ 64 ];

            pSetupStringFromGuid( &(pDeviceInfoData->ClassGuid), GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );
            SetupDebugPrint1( L"SETUP:            GUID = %ls", GUIDString );
    }

    if( !SetupDiSetSelectedDriver( hDevInfo,
                                   pDeviceInfoData,
                                   NULL ) ) {

        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetSelectedDriver() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetSelectedDriver() failed. Error = %d", Error );
        }
        return( FALSE );
    }

    //
    // Let the class installer/co-installers know they should be quiet.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
        }
    } else {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;

        if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                            pDeviceInfoData,
                                            &DeviceInstallParams ) ) {
            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
            }
        }
    }

    //
    //  First, attempt to install the null driver without setting DI_FLAGSEX_SETFAILEDINSTALL.
    //  Installation of LEGACY_* devices should succeed in this case.
    //
    //  We do this through the class installer, in case it needs to clean-up
    //  turds from a previous installation (see RAID #266793).
    //
    if(SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                 hDevInfo,
                                 pDeviceInfoData)) {
        //
        // If we were passed in a devices installed string table then add this
        // device instance id to the string table.
        //
        if (DevicesInstalledStringTable) {
            if( SetupDiGetDeviceInstanceId( hDevInfo,
                                            pDeviceInfoData,
                                            DevInstId,
                                            sizeof( DevInstId ) / sizeof( WCHAR ),
                                            NULL ) ) {
                if (pSetupStringTableAddString(DevicesInstalledStringTable, DevInstId, STRTAB_CASE_INSENSITIVE) == -1) {
                    SetupDebugPrint1( L"SETUP:            ERROR: failed to add Device = %ls to the string table!", DevInstId );
                }
            }
        }

        //
        //  Istallation succeeded.
        //
        return( TRUE );
    }

    Error = GetLastError();
    if( ((LONG)Error) < 0 ) {
        //
        //  Setupapi error code, display it in hex
        //
        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed on first attempt. Error = %lx", Error );
    } else {
        //
        //  win32 error code, display it in decimal
        //
        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed on first attempt. Error = %d", Error );
    }
    SetupDebugPrint( L"SETUP:            Trying a second time with DI_FLAGSEX_SETFAILEDINSTALL set." );

    //
    //  The first attempt to install the null driver (without setting DI_FLAGSEX_SETFAILEDINSTALL)
    //  failed.
    //  So we set the flag and try it again.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
        }
        return( FALSE );

    }
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
    if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
        }
        return( FALSE );
    }

    if(!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                  hDevInfo,
                                  pDeviceInfoData)) {
        //
        // If we were passed in a devices installed string table then add this
        // device instance id to the string table.
        //
        if (DevicesInstalledStringTable) {
            if( SetupDiGetDeviceInstanceId( hDevInfo,
                                            pDeviceInfoData,
                                            DevInstId,
                                            sizeof( DevInstId ) / sizeof( WCHAR ),
                                            NULL ) ) {
                if (pSetupStringTableAddString(DevicesInstalledStringTable, DevInstId, STRTAB_CASE_INSENSITIVE) == -1) {
                    SetupDebugPrint1( L"SETUP:            ERROR: failed to add Device = %ls to the string table!", DevInstId );
                }
            }
        }

        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %d", Error );
        }
        return( FALSE );
    }
    return( TRUE );
}

BOOL
RebuildListWithoutOldInternetDrivers(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )

/*++

Routine Description:

    This function determins whether SetupDiBuildDriverInfoList will need to be
    called again with the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag set. We first
    call SetupDiBuildDriverInfoList without this flag to allow old Internet drivers
    to be included in the best driver selection. If an old Internet driver is
    selected as the best then we need to do a validity check to verify that all
    the destination files are present on the system and correctly digitally signed.
    If both of these are true then we can allow this old internet driver to stay
    the best driver since it won't prompt for source files.

    We need to do this for the case when a user is running a previous OS and they
    get a better driver from Windows Update. We can't blindly replace the Windows
    Update driver with the drivers in the new OS since they might not be better.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    Returns TRUE if the list needs to be rebuilt with the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS
    flag and FALSE otherwise.

    Note if this API returns FALSE it either means the best driver was not an old
    internet driver or that it was but all of it's destination files are present
    and correctly digitally signed so no file copy will need to take place.

--*/

{
    BOOL                 RebuildList = FALSE;
    SP_DRVINFO_DATA      DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HSPFILEQ             FileQueue = INVALID_HANDLE_VALUE;
    DWORD                ScanResult = 0;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams
                                          ) &&
            (DriverInstallParams.Flags & DNF_OLD_INET_DRIVER)) {

            //
            // At this point we know that the best driver is an old Internet driver.
            // Now do a validity check which will verify all the source files are
            // present and digitally signed. We will also assume we need to rebuild
            // the list at this point unless we pass the validity check below.
            //
            RebuildList = TRUE;

            FileQueue = SetupOpenFileQueue();

            if (FileQueue != INVALID_HANDLE_VALUE) {

                //
                // Tell setupapi to use our file queue.
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  )) {
                    DeviceInstallParams.Flags |= DI_NOVCP;
                    DeviceInstallParams.FileQueue = FileQueue;

                    if (SetupDiSetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      )) {
                        if (SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                                      hDevInfo,
                                                      pDeviceInfoData
                                                      ) &&
                            SetupScanFileQueue(FileQueue,
                                               SPQ_SCAN_FILE_VALIDITY,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ScanResult
                                               ) &&
                            ((ScanResult == 1) ||
                             (ScanResult == 2))) {

                            //
                            // if ScanResult is 1 or 2 then no copying needs to
                            // take place because all the destination files are
                            // in their place and digitally signed.
                            //
                            RebuildList = FALSE;
                        }
                    }
                }

                //
                // Clear out the file queue handle from the device install params
                // so that we can close the file queue.
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  )) {
                    DeviceInstallParams.Flags &= ~DI_NOVCP;
                    DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

                    SetupDiSetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  );
                }

                SetupCloseFileQueue(FileQueue);
            }
        }
    }

    return RebuildList;
}

BOOL
pDoesExistingDriverNeedBackup(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PWSTR            InfPath,
    IN DWORD            InfPathSize
    )

/*++

Routine Description:

    This function determins whether the currently install driver needs to be
    backed up or not. It does this by checking if the current driver is an
    oem driver, and verifying that it is not the same as the new driver
    we are about to install.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    TRUE if the current driver needs to be backed up, FALSE otherwise.

--*/
{
    BOOL                    bBackupCurrentDriver = FALSE;
    HKEY                    Key = INVALID_HANDLE_VALUE;
    DWORD                   dwType, dwData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DRVINFO_DETAIL_DATA  DriverInfoDetailData;

    if (InfPath) {
        InfPath[0] = TEXT('\0');
    }

    //
    // Open the driver key for this device.
    //
    Key = SetupDiOpenDevRegKey ( hDevInfo,
                                 pDeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_READ );

    if (Key != INVALID_HANDLE_VALUE) {
        //
        // Get the 'InfPath' value from the registry.
        //
        dwType = REG_SZ;
        dwData = InfPathSize;
        if (RegQueryValueEx(Key,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfPath,
                            &dwData) == ERROR_SUCCESS) {
            //
            // Check if this is an oem inf
            //
            if (IsInstalledInfFromOem(InfPath)) {
                //
                // Retrieve the name of the INF associated with the selected driver
                // node.
                //
                DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
                if (SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
                    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (SetupDiGetDriverInfoDetail(hDevInfo,
                                                   pDeviceInfoData,
                                                   &DriverInfoData,
                                                   &DriverInfoDetailData,
                                                   sizeof(DriverInfoDetailData),
                                                   NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                        //
                        // If the two INFs are not the same then this means we
                        // should backup the current drivers before installing
                        // the new drivers.
                        //
                        if (lstrcmpi(pSetupGetFileTitle(DriverInfoDetailData.InfFileName),
                                     InfPath) != 0) {
                            bBackupCurrentDriver = TRUE;
                        }

                    } else {
                        SetupDebugPrint1( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d", GetLastError() );
                    }
                } else {
                    SetupDebugPrint1( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                }
            }
        }

        RegCloseKey(Key);
    }

    return bBackupCurrentDriver;
}

BOOL
SelectBestDriver(
    IN  HDEVINFO         hDevInfo,
    IN  PSP_DEVINFO_DATA pDeviceInfoData,
    OUT PBOOL            pbOemF6Driver
    )

/*++

Routine Description:

    This function selects the best driver for the specified device.
    It is assumed that SetupDiBuildDriverInfoList was called before calling
    this API.

    This API will first check the list of driver nodes for this device and
    see if any have the DNF_OEM_F6_INF flag. If they do then this INF was
    specified by the user during text mode setup by doing an F6.  We always
    want to use these drivers, even if they are not the 'best' according to
    setupapi. If there are no drivers in the list with this flag then we
    fall back to the default behavior of DIF_SELECTBESTCOMPATDRV.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    Returns the result SetupDiCallClassInstaller with DIF_SELECTBESTCOMPATDRV.

--*/

{
    DWORD index;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    BOOL bFoundOemF6Driver = FALSE;

    *pbOemF6Driver = FALSE;

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    index = 0;

    //
    // First go through the list of drivers and see if there is an OEM F6 driver
    // in the list.
    //
    while (SetupDiEnumDriverInfo(hDevInfo,
                                 pDeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 index++,
                                 &DriverInfoData
                                 )) {
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams
                                          ) &&
            (DriverInstallParams.Flags & DNF_OEM_F6_INF)) {

            bFoundOemF6Driver = TRUE;
            SetupDebugPrint( L"SETUP: Using Oem F6 driver for this device." );
            break;
        }
    }

    //
    //  If we found an Oem driver that was specified by F6 during text mode setup,
    //  then we will go through the list again and mark all drivers that are
    //  not OEM F6 drivers and BAD drivers. This way when we call
    //  DIF_SELECTBESTCOMPATDRV it will only select from the OEM F6 drivers.
    //
    if (bFoundOemF6Driver) {
        *pbOemF6Driver = TRUE;

        DriverInfoData.cbSize = sizeof(DriverInfoData);
        index = 0;

        while (SetupDiEnumDriverInfo(hDevInfo,
                                     pDeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     index++,
                                     &DriverInfoData
                                     )) {
            DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
            if (SetupDiGetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DriverInfoData,
                                              &DriverInstallParams
                                              )) {
                //
                // If this driver node does not have the DNF_OEM_F6_INF flag
                // then set the DNF_BAD_DRIVER flag so we will skip this
                // driver later when we do DIF_SELECTBESTCOMPATDRV
                //
                if (!(DriverInstallParams.Flags & DNF_OEM_F6_INF)) {
                    DriverInstallParams.Flags |= DNF_BAD_DRIVER;

                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DriverInfoData,
                                                  &DriverInstallParams
                                                  );
                }
            }
        }
    }

    return (SetupDiCallClassInstaller( DIF_SELECTBESTCOMPATDRV,
                                       hDevInfo,
                                       pDeviceInfoData ) );
}

BOOL
SkipDeviceInstallation(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN HINF             InfHandle,
    IN PCWSTR           GUIDString
    )

/*++

Routine Description:

    This function determines whether or not the installation of a particular device should be skipped.
    It should be skipped if the following conditions are met:
        - The device is already installed;
        - The GUID for the device is listed in [InstalledDevicesToSkip], in syssetup.inf

Arguments:


    hDevInfo -

    pDeviceInfoData -

    InfHandle - System setup inf handle (syssetup.inf).

    GUIDString - GUID associated to the device being checked (in string format).

Return Value:

    Returns TRUE if the installation of the device should be skipped. Otherwise, it returns FALSE.

--*/

{
    BOOL    DeviceAlreadyInstalled;
    BOOL    SafeClassInstaller = TRUE;
    WCHAR   PropertyBuffer[ MAX_PATH + 1 ];
    HKEY    Key;

    //
    //  Attempt to open the dev node's driver key
    //
    Key = SetupDiOpenDevRegKey ( hDevInfo,
                                 pDeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 MAXIMUM_ALLOWED );
    if( Key == INVALID_HANDLE_VALUE ) {
        DeviceAlreadyInstalled = FALSE;
        SetupDebugPrint( L"SETUP:            Device not yet installed." );
    } else {
        RegCloseKey( Key );
        DeviceAlreadyInstalled = TRUE;
        SetupDebugPrint( L"SETUP:            Device already installed." );
    }

    //
    // In the case of MiniSetup, we're not doing an
    // upgrade, so all we care about is if the device is
    // already installed.
    //
    if( MiniSetup ) {
        return( DeviceAlreadyInstalled );
    }

    if( DeviceAlreadyInstalled ) {
        //
        //  If the device is already installed, then check if the class installer for this
        //  device is considered safe.
        //
        SafeClassInstaller = !SetupGetLineText( NULL,
                                                InfHandle,
                                                L"InstalledDevicesToSkip",
                                                GUIDString,
                                                PropertyBuffer,
                                                sizeof( PropertyBuffer )/sizeof( WCHAR ),
                                                NULL );
    }

    return( DeviceAlreadyInstalled && !SafeClassInstaller );
}


BOOL
PrecompileInfFiles(
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
/*++

Routine Description:

    This function precompiles all the infs in %SystemRoot%\inf.
    and then builds the cache.

Arguments:

    ProgressWindow - Handle to the progress bar.

    StartAtPercent - Starting position in the progress bar.
                     It indicates that from position 0 to this position
                     the gauge is already filled.

    StopAtPercent - Ending position of the progress bar.
                    The pnp thread should not fill the progress bar beyond
                    this position

Return Value:

    Returns TRUE if at least one inf was pre-compiled. Otherwise, returns FALSE.

--*/

{
    WCHAR SavedDirectory[ MAX_PATH + 1 ];
    WCHAR InfDirectory[ MAX_PATH + 1 ];
    UINT GaugeRange;
    BOOL AlwaysFalse = FALSE;

    PINF_FILE_NAME  InfList = NULL;
    PINF_FILE_NAME  p;

    WIN32_FIND_DATA FindData;
    HANDLE  FindHandle;
    ULONG   InfCount;
    ULONG   i = 0;

    SetupDebugPrint( L"SETUP: Entering PrecompileInfFiles()" );

    //
    //  Save current directory
    //
    GetCurrentDirectory( sizeof(SavedDirectory)/sizeof(WCHAR), SavedDirectory );

    //
    //  Change current directory to %SystemRoot%\inf
    //
    if ((GetWindowsDirectory( InfDirectory, sizeof(InfDirectory)/sizeof(WCHAR) ) == 0) ||
        !pSetupConcatenatePaths(InfDirectory, L"inf", sizeof(InfDirectory)/sizeof(WCHAR), NULL)) {

        MYASSERT(FALSE);
        return FALSE;
    }

    SetCurrentDirectory( InfDirectory );
    
    //
    //  Find total number of inf files
    //
    InfCount = 0;
    FindHandle = FindFirstFile( L"*.inf", &FindData );
    if( FindHandle != INVALID_HANDLE_VALUE ) {
        do {
            //
            //  Skip directories
            //
            if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                continue;
            }
            p = MyMalloc( sizeof( INF_FILE_NAME ) ) ;
            if( p != NULL ) {
                p->InfName = pSetupDuplicateString( &FindData.cFileName[0] );
                p->Next = InfList;
                InfList = p;
                InfCount++;
            }
        } while( FindNextFile( FindHandle, &FindData ) );

        FindClose( FindHandle );
    } else {
        SetupDebugPrint1( L"SETUP: FindFirstFile( *.inf ) failed. Error = %d", GetLastError() );
    }

    //
    //  Initialize the gauge allow for pSetupInfCacheBuild step
    //
    GaugeRange = ((InfCount+1)*100/(StopAtPercent-StartAtPercent));
    SendMessage(ProgressWindow, WMX_PROGRESSTICKS, (InfCount+1), 0);
    SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

    //
    //  Prcompile each inf file
    //
    for( i = 0;
         (
           //
           //  Tick the gauge after we finished pre-compiling an inf.
           //  Note that we don't tick the gauge when i == 0 (no inf was yet processed),
           //  but we do tick the gauge when i == InfCount (all infs were pre-compiled).
           //  Note also that we use the flag AlwaysFalse, to enforce that all inf will be processed,
           //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
           //
           (i != 0) &&
           SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
           AlwaysFalse
         ) ||
         (i < InfCount);
         i++
      ) {
        HINF    hInf;

        SetupDebugPrint1( L"SETUP: Pre-compiling file: %ls", InfList->InfName );

        MYASSERT(InfList);
        hInf = SetupOpenInfFile( InfList->InfName,
                                 NULL,
                                 INF_STYLE_WIN4,
                                 NULL );

        if( hInf != INVALID_HANDLE_VALUE ) {
            SetupCloseInfFile( hInf );
        } else {
            DWORD   Error;

            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint2( L"SETUP: SetupOpenInfFile() failed. FileName = %ls, Error = %lx", InfList->InfName, Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint2( L"SETUP: SetupOpenInfFile() failed. FileName = %ls, Error = %d", InfList->InfName, Error );
            }
        }

        //
        // The file name is no longer needed
        //
        p = InfList;
        InfList = InfList->Next;
        if( p->InfName != NULL ) {
            MyFree( p->InfName );
        }
        MyFree( p );
    }

    SetupDebugPrint2( L"SETUP: Total inf files = %d, total precompiled: %d", InfCount, i );
    SetupDebugPrint( L"SETUP: Calling pSetupInfCacheBuild()" );

    pSetupInfCacheBuild(INFCACHEBUILD_REBUILD);

    //
    //  Make sure that at this point, the gauge area is filled up to the end of
    //  the area reserved for the pre-compilation of inf files.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    //
    //  Restore current directory
    //
    SetCurrentDirectory( SavedDirectory );

    SetupDebugPrint( L"SETUP: Leaving PrecompileInfFiles()" );

    return( i != 0 );
}


BOOL
InstallLegacyDevices(
    IN HWND hwndParent,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent,
    IN PVOID DevicesInstalledStringTable    OPTIONAL
    )
{
    ULONG               Index;
    SP_DEVINFO_DATA     DeviceInfoData;
    ULONG               Error;
    WCHAR               GUIDString[ 64 ];
    BOOL                b = TRUE;
    HSPFILEQ            FileQ = INVALID_HANDLE_VALUE;

    LPGUID              GuidList = NULL;
    ULONG               GuidCount = 32;
    ULONG               GuidIndex;
    ULONG               LastBatchedDetect;
    ULONG               GuidLB, GuidUB;
    HDEVINFO*           InfoSetArray = NULL;
    BOOL                AlwaysFalse = FALSE;
    UINT                GaugeRange;

    HANDLE              ThreadHandle = NULL;
    DWORD               ThreadId;
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS  Phase1Context;
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS  Phase2Context;
    WCHAR               PnpLogPath[ MAX_PATH + 1 ];
    WCHAR               LoggedDescription[ LINE_LEN + 1 ];
    DWORD               ScanQueueResult;
    SP_DRVINFO_DATA     DriverInfoData;
    ULONG               PnPFlags;
    DWORD               Result;


    SetupDebugPrint( L"SETUP: Entering InstallLegacyDevices()" );

    //
    //  Build path to pnp log file
    //
    Result = GetWindowsDirectory( PnpLogPath, sizeof(PnpLogPath)/sizeof(WCHAR) );
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!pSetupConcatenatePaths( PnpLogPath, 
                                 szPnpLogFile, 
                                 sizeof(PnpLogPath)/sizeof(WCHAR), 
                                 NULL )) {
        MYASSERT(FALSE);
        return FALSE;
    }

    //
    // Do the migration of legacy devices.
    // This is a quick operation and doesn't need to use the progress window.
    //
    // This is now performed before installation of true PnP devices
    //
    // PnPInitializationThread(NULL);

    GuidList = ( LPGUID )MyMalloc( sizeof( GUID ) * GuidCount );
    if( !GuidList ) {
        return( FALSE );
    }

    if ( !SetupDiBuildClassInfoList( 0,
                                     GuidList,
                                     GuidCount,
                                     &GuidCount ) ) {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            SetupDebugPrint1( L"SETUP: SetupDiBuildClassInfoList() failed. Error = %d", Error );
            MyFree( GuidList );

            //
            //  Fill the gauge up to the end of the area reserved for legacy devices.
            //
            GaugeRange = 100;
            SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);
            SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
            return( FALSE );
        }
        GuidList = ( LPGUID )MyRealloc( GuidList, sizeof( GUID ) * GuidCount );

        if( !SetupDiBuildClassInfoList( 0,
                                        GuidList,
                                        GuidCount,
                                        &GuidCount ) ) {
            MyFree( GuidList );
            SetupDebugPrint1( L"SETUP: SetupDiBuildClassInfoList() failed. Error = %d", Error );

            //
            //  Fill the gauge up to the end of the area reserved for legacy devices.
            //
            GaugeRange = 100;
            SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);
            SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
            return( FALSE );
        }
    }

    //
    // Sort the class GUID list based on the detection ordering specified in syssetup.inf
    //
    SortClassGuidListForDetection(GuidList, GuidCount, &LastBatchedDetect);

    InfoSetArray = (HDEVINFO*)MyMalloc( sizeof(HDEVINFO) * GuidCount );


    //
    //  Initialize the gauge.
    //  Note that since we process the device classes twice (two big 'for
    //  loops'), we divide the area of the gauge reserved for the gauge
    //  reserved for the legacy devices in 2 pieces, one for each 'for loop'.
    //
    GaugeRange = (2*GuidCount*100/(StopAtPercent-StartAtPercent));
    SendMessage(ProgressWindow, WMX_PROGRESSTICKS, 2*GuidCount, 0);
    SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

    //
    // On our first pass, we process all the detections that can be batched
    // together.  Then, on subsequent passes, we process any non-batchable
    // detections individually...
    //
    for(GuidLB = 0, GuidUB = LastBatchedDetect; GuidLB < GuidCount; GuidLB = ++GuidUB) {

        //
        //  First, create a file queue
        //
        FileQ = SetupOpenFileQueue();
        if( FileQ == INVALID_HANDLE_VALUE ) {
            SetupDebugPrint1( L"SETUP: Failed to create file queue. Error = %d", GetLastError() );
        }


        for( GuidIndex = GuidLB;
             (
               //
               //  Tick the gauge after we finished processing all the devices of a particular class.
               //  Note that we don't tick the gauge when GuidIndex == 0 (no device was yet processed),
               //  but we do tick the gauge when GuidIndex == GuidCount (all devices of the last class
               //  were processed).
               //  Note also that we use the flag AlwaysFalse, to enforce that all classes will be processed,
               //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
               //
               (GuidIndex != GuidLB) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||
             (GuidIndex <= GuidUB);
             GuidIndex++ ) {

            WCHAR       ClassDescription[ LINE_LEN + 1 ];

            InfoSetArray[ GuidIndex ] = INVALID_HANDLE_VALUE;
            ClassDescription[0] = (WCHAR)'\0';
            if( !SetupDiGetClassDescription( &GuidList[ GuidIndex ],
                                             ClassDescription,
                                             sizeof(ClassDescription)/sizeof(WCHAR),
                                            NULL ) ) {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                ClassDescription[0] = (WCHAR)'\0';
            }
            pSetupStringFromGuid( &GuidList[ GuidIndex ], GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );
            SetupDebugPrint1( L"SETUP: Installing legacy devices of class: %ls ", ClassDescription );
            SetupDebugPrint2( L"SETUP:     GuidIndex = %d, Guid = %ls", GuidIndex, GUIDString );
#ifndef DBG
            //
            //  Check if this class of devices is listed as a bad class
            //
            LoggedDescription[0] = L'\0';
            if( (GetPrivateProfileString( szLegacyClassesSection,
                                          GUIDString,
                                          L"",
                                          LoggedDescription,
                                          sizeof(LoggedDescription)/sizeof(WCHAR),
                                          PnpLogPath ) != 0) &&
                ( wcslen( LoggedDescription ) != 0 )
              ) {
                //
                //  Skip the installation of this class of devices
                //
                SetupDebugPrint1( L"SETUP:     Skipping installation of devices of class: %ls", ClassDescription );
                continue;
            }
#endif

            //
            //  Start the thread that actually does the initial part of the installation of the legacy devices (DIF_FIRSTTIMESETUP)
            //

            Phase1Context = MyMalloc( sizeof( PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ) );
            Phase1Context->hDevInfo = INVALID_HANDLE_VALUE;
            Phase1Context->Guid = GuidList[ GuidIndex ];
            Phase1Context->pClassDescription = pSetupDuplicateString(ClassDescription);
            Phase1Context->hwndParent = hwndParent;


            ThreadHandle = NULL;
            ThreadHandle = CreateThread( NULL,
                                         0,
                                         pPhase1InstallPnpLegacyDevicesThread,
                                         Phase1Context,
                                         0,
                                         &ThreadId );
            if(ThreadHandle) {
                DWORD   WaitResult;
                DWORD   ExitCode;
                BOOL    KeepWaiting;

                KeepWaiting = TRUE;

                while( KeepWaiting ) {
                    int Result;

                    //
                    //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                    //  Fix the network timeout after the network guys fix their class installer
                    //
                    WaitResult = WaitForSingleObject( ThreadHandle,
                                                      (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                 PNP_LEGACY_PHASE1_TIMEOUT );
                    if( WaitResult == WAIT_TIMEOUT ) {
                    HANDLE  hDialogEvent;

                        if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                            //
                            // Setupapi is prompting the user for a file.  Don't timeout.
                            //
                            CloseHandle( hDialogEvent );
                            KeepWaiting = TRUE;
                            continue;
                        }

                        //
                        //  Class installer is hung
                        //
                        SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase1). ClassDescription = %ls", ClassDescription );

#ifdef PRERELEASE
                        //
                        //  Ask the user if he wants to skip the installation of this class of devices
                        //
                        if( !Unattended ) {
                            Result = MessageBoxFromMessage( hwndParent,
                                                            MSG_CLASS_INSTALLER_HUNG_FIRSTTIMESETUP,
                                                            NULL,
                                                            IDS_WINNT_SETUP,
                                                            MB_YESNO | MB_ICONWARNING,
                                                            ClassDescription );
                        } else {
                            Result = IDYES;
                        }
#else
                        Result = IDYES;
#endif

                        if(Result == IDYES) {
                            //
                            //  User wants to skip this class of devices.
                            //  First find out if the thread has already returned.
                            //
                            WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                            if( WaitResult != WAIT_OBJECT_0 ) {
                                //
                                //  Thread hasn't returned yet. Skip the installation of this class of devices
                                //
                                KeepWaiting = FALSE;
                                SetupDebugPrint1( L"SETUP:    Skipping installation of legacy devices of class: %ls", ClassDescription );
                                b = FALSE;
                                //
                                //  Remember this class so that it won't be installed if GUI setup is
                                //  restarted
                                //
                                WritePrivateProfileString( szLegacyClassesSection,
                                                           GUIDString,
                                                           ClassDescription,
                                                           PnpLogPath );
                            } else{
                                //
                                //  Thread has already returned.
                                //  There is no need to skip the installation of this class of devices.
                                //  We assume that the user decided not to skip the installation of this class,
                                //  and next call to WaitForSingleObject will immediately return.
                                //
                            }
                        }
                    } else if( WaitResult == WAIT_OBJECT_0 ) {
                        //
                        //  Device Installation Thread completed.
                        //
                        KeepWaiting = FALSE;
                        if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                            if( ExitCode == ERROR_SUCCESS ) {
                                //
                                // The installation was successful
                                //
                                InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                            } else {
                                //
                                // The installation was not successful.
                                // There is no need to log the error, since the thread has already done it.
                                //
                                b = FALSE;
                            }
                        } else {
                            //
                            //  Unable to retrieve exit code. Assume success.
                            //
                            InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                            SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                            SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming devices successfully installed (phase1)." );
                        }
                        //
                        //  Deallocate all the memory that was passed to the thread.
                        //
                        MyFree(Phase1Context->pClassDescription);
                        MyFree(Phase1Context);

                    } else {
                        //
                        //  Should not occur.
                        //  In this case we don't deallocate any memory, since the thread may be running.
                        //
                        KeepWaiting = FALSE;
                        SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                        b = FALSE;
                    }
                }
                //
                // The thread handle is no longer needed at this point
                //
                CloseHandle(ThreadHandle);

            } else {
                //
                // Just do it synchronously.
                //
                Error = GetLastError();
                SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase1). Error = %d", Error );
                if( pPhase1InstallPnpLegacyDevicesThread(Phase1Context) != ERROR_SUCCESS ) {
                    //
                    // The installation was not successful.
                    // There is no need to log the error, since the thread has already done it.
                    //
                    b = FALSE;
                } else {
                    InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                }
                //
                //  Deallocate the memory passed as argument
                //
                MyFree( Phase1Context->pClassDescription );
                MyFree( Phase1Context );
            }

            //
            //  Find out if we should install devices of this class.
            //
            if( InfoSetArray[ GuidIndex ] == INVALID_HANDLE_VALUE ) {
                //
                //  If we should not install this class of devices, then go process the next class.
                //
                continue;
            }

            //
            // Now enumerate each device information element added to this set, registering
            // and then installing the files for each one.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for( Index = 0;
                 SetupDiEnumDeviceInfo( InfoSetArray[ GuidIndex ], Index, &DeviceInfoData );
                 Index++ ) {
                WCHAR   DevInstId[ MAX_DEVICE_ID_LEN ];

                Error = ERROR_SUCCESS;

                //
                //  Make sure the device is marked as 'Do not install'
                //
                if( !pSetupDiSetDeviceInfoContext( InfoSetArray[ GuidIndex ], &DeviceInfoData, FALSE ) ) {
                    SetupDebugPrint2( L"SETUP:     pSetupDiSetDeviceInfoContext() failed. Error = %lx, Index = %d", GetLastError(), Index );
                }

                //
                // Retrieve the string id for this device
                //
                DevInstId[0] = L'\0';
                if( !SetupDiGetDeviceInstanceId( InfoSetArray[ GuidIndex ],
                                                 &DeviceInfoData,
                                                 DevInstId,
                                                 sizeof( DevInstId ) / sizeof( WCHAR ),
                                                 NULL ) ) {
                    SetupDebugPrint2( L"SETUP:     Index = %d, SetupDiGetDeviceInstanceId() failed. Error = ", Index, GetLastError() );

                }
#ifndef DBG
                //
                //  Find out if this device is marked as a bad device
                //
                LoggedDescription[0] = L'\0';
                if( (GetPrivateProfileString( szLegacyClassesSection,
                                              DevInstId,
                                              L"",
                                              LoggedDescription,
                                              sizeof(LoggedDescription)/sizeof(WCHAR),
                                              PnpLogPath ) != 0) &&
                    ( wcslen( LoggedDescription ) != 0 )
                  ) {
                    //
                    //  Skip the installation of this device
                    //
                    SetupDebugPrint1( L"SETUP:     Skipping installation of legacy device: %ls", DevInstId );
                    continue;
                }
#endif


                SetupDebugPrint2( L"SETUP:     Index = %d, DeviceId = %ls", Index, DevInstId );

                Phase2Context = MyMalloc( sizeof( PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ) );
                Phase2Context->hDevInfo = InfoSetArray[ GuidIndex ];
                Phase2Context->FileQ = FileQ;
                Phase2Context->DeviceInfoData = DeviceInfoData;
                Phase2Context->pClassDescription = pSetupDuplicateString(ClassDescription);
                Phase2Context->pDeviceId = pSetupDuplicateString(DevInstId);

                ThreadHandle = NULL;;
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             pPhase2InstallPnpLegacyDevicesThread,
                                             Phase2Context,
                                             0,
                                             &ThreadId );
                if( ThreadHandle ) {
                    DWORD   WaitResult;
                    DWORD   ExitCode;
                    BOOL    KeepWaiting;

                    KeepWaiting = TRUE;
                    while( KeepWaiting ) {
                        //
                        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                        //  Fix the network timeout after the network guys fix their class installer
                        //
                        WaitResult = WaitForSingleObject( ThreadHandle,
                                                          (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                     PNP_LEGACY_PHASE2_TIMEOUT );
                        if( WaitResult == WAIT_TIMEOUT ) {
                            int Result;
                            HANDLE  hDialogEvent;

                            if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                                //
                                // Setupapi is prompting the user for a file.  Don't timeout.
                                //
                                CloseHandle( hDialogEvent );
                                KeepWaiting = TRUE;
                                continue;
                            }

                            //
                            //  Class installer is hung
                            //
                            SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase2). DeviceId = %ls", DevInstId );

#ifdef PRERELEASE
                            //
                            //  Ask the user if he wants to skip the installation of this device
                            //
                            if( !Unattended ) {
                                Result = MessageBoxFromMessage( hwndParent,
                                                                MSG_CLASS_INSTALLER_HUNG,
                                                                NULL,
                                                                IDS_WINNT_SETUP,
                                                                MB_YESNO | MB_ICONWARNING,
                                                                DevInstId );
                            } else {
                                Result = IDYES;
                            }
#else
                            Result = IDYES;
#endif

                            if(Result == IDYES) {
                                //
                                //  User wants to skip this class of devices.
                                //  First find out if the thread has already returned.
                                //
                                WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                                if( WaitResult != WAIT_OBJECT_0 ) {
                                    //
                                    //  Thread hasn't returned yet. Skip the installation of this device
                                    //
                                    KeepWaiting = FALSE;
                                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device (phase2). Device = %ls", DevInstId );
                                    b = FALSE;
                                    //
                                    //  Remember this device so that it won't be installed if GUI setup is
                                    //  restarted
                                    //
                                    WritePrivateProfileString( szLegacyDevSection,
                                                               DevInstId,
                                                               ClassDescription,
                                                               PnpLogPath );
                                } else{
                                    //
                                    //  Thread has already returned.
                                    //  There is no need to skip the installation of this device.
                                    //  We assume that the user decided not to skip the installation of this device,
                                    //  and next call to WaitForSingleObject will immediately return.
                                    //
                                }
                            }

                        } else if( WaitResult == WAIT_OBJECT_0 ) {
                            //
                            //  Device Installation Thread completed.
                            //  Find out the outcome of this phase of the installation.
                            //
                            KeepWaiting = FALSE;
                            if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                                if( ExitCode ) {
                                    //
                                    // The installation was successful
                                    //
                                } else {
                                    //
                                    // The installation was not successful.
                                    // There is no need to log the error, since the thread has already done it.
                                    //
                                    b = FALSE;
                                }
                            } else {
                                //
                                //  Unable to retrieve exit code. Assume success.
                                //
                                SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                                SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming device successfully installed (phase2)." );
                            }
                            //
                            //  Deallocate the memory passed to the thread.
                            //
                            MyFree(Phase2Context->pClassDescription);
                            MyFree(Phase2Context->pDeviceId);
                            MyFree(Phase2Context);

                        } else {
                            //
                            //  Should not occur.
                            //  In this case we do not deallocate the memory passed to the thread, since the thread may be running.
                            //
                            KeepWaiting = FALSE;
                            SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                            b = FALSE;
                        }
                    }
                    //
                    // The thread handle is no longer needed at this point
                    //
                    CloseHandle(ThreadHandle);

                } else {
                    //
                    // Unable to create the thread. Just do it syncronously
                    //
                    Error = GetLastError();
                    SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase2). Error = %d", Error );
                    if( !pPhase2InstallPnpLegacyDevicesThread(Phase2Context) ) {
                        //
                        // The installation was not successful.
                        // There is no need to log the error, since the thread has already done it.
                        //
                        SetupDebugPrint( L"SETUP:    Device not successfully installed (phase2)." );
                        b = FALSE;

                    }
                    //
                    //  Deallocate the memory that was passed as argument.
                    //
                    MyFree( Phase2Context->pClassDescription );
                    MyFree( Phase2Context->pDeviceId );
                    MyFree( Phase2Context );
                }
            }
            //
            // Find out why SetupDiEnumDeviceInfo() failed.
            //
            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"SETUP:     Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
                b = FALSE;
            } else {
                if( Index == 0 ) {
                    SetupDebugPrint1( L"SETUP:     DeviceInfoSet is empty. ClassDescription = %ls", ClassDescription );
                }
            }

        }

        //
        //  If the file queue exists, then commit it.
        //
        if( FileQ != INVALID_HANDLE_VALUE ) {
            PVOID  Context;

            //
            //  Commit file queue
            //
            if(Context = InitSysSetupQueueCallbackEx(hwndParent,
                                                     INVALID_HANDLE_VALUE,
                                                     0,
                                                     0,
                                                     NULL)) {

                WCHAR  RootPath[ MAX_PATH + 1];

                if(!SetupScanFileQueue(
                       FileQ,
                       SPQ_SCAN_FILE_VALIDITY |
                        SPQ_SCAN_PRUNE_COPY_QUEUE |
                        SPQ_SCAN_PRUNE_DELREN,
                       hwndParent,
                       NULL,
                       NULL,
                       &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never
                        // fail when you don't ask it to call a
                        // callback routine, but if it does, just
                        // go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                }


                if( ScanQueueResult != 1 ){

                    if( !SetupCommitFileQueue(hwndParent,FileQ,SysSetupQueueCallback,Context) ) {
                        b = FALSE;
                    }
                }
                TermSysSetupQueueCallback(Context);
                GetWindowsDirectory(RootPath,sizeof(RootPath)/sizeof(WCHAR));
                RootPath[3] = L'\0';
                FlushFilesToDisk( RootPath );
            }
        }

        //
        //  Now that the files were already copied, call the class installer
        //  with DIF_INSTALLDEVICE so that we can complete the installation
        //  of the device.
        //
        for( GuidIndex = GuidLB;
             (
               //
               //  Tick the gauge after we finished processing all the devices of a particular class.
               //  Note that we don't tick the gauge when GuidIndex == 0 (no device was yet processed),
               //  but we do tick the gauge when GuidIndex == GuidCount (all devices of the last class
               //  were processed).
               //  Note also that we use the flag AlwaysFalse, to enforce that all classes will be processed,
               //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
               //
               (GuidIndex != GuidLB) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||
             (GuidIndex <= GuidUB);
             GuidIndex++ ) {

            SP_DEVINFO_DATA TempDeviceInfoData;

            if( InfoSetArray[ GuidIndex ] == INVALID_HANDLE_VALUE  ) {
                continue;
            }
            //
            //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
            //  Remove the line below after the network guys fix their class installer
            //
            pSetupStringFromGuid( &GuidList[ GuidIndex ], GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );

            TempDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for( Index = 0;  SetupDiEnumDeviceInfo( InfoSetArray[ GuidIndex ], Index, &TempDeviceInfoData ); Index++ ) {
                WCHAR   DevInstId[ MAX_DEVICE_ID_LEN ];
                DWORD   InstallDevice;
                SP_DEVINSTALL_PARAMS DeviceInstallParams;
                PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS Phase3Context;

                //
                // Retrieve the string id for this device
                //
                DevInstId[0] = L'\0';
                if( !SetupDiGetDeviceInstanceId( InfoSetArray[ GuidIndex ],
                                                 &TempDeviceInfoData,
                                                 DevInstId,
                                                 sizeof( DevInstId ) / sizeof( WCHAR ),
                                                 NULL ) ) {
                    SetupDebugPrint1( L"SETUP: SetupDiGetDeviceInstanceId() failed. Error = ", GetLastError() );
                }

                //
                //  Find out if we need to call DIF_INSTALLDEVICE for this device
                //
                InstallDevice = 0;
                if( !pSetupDiGetDeviceInfoContext( InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &InstallDevice ) ) {
                    SetupDebugPrint2( L"SETUP: pSetupDiSetDeviceInfoContext() failed. Error = %lx, DeviceId = %ls ", GetLastError(), DevInstId );
                    continue;
                }
                if( !InstallDevice ) {
                    //
                    //  No need to install the device
                    //
                    SetupDebugPrint1( L"SETUP: Skipping device. DeviceId = %ls ", DevInstId );
                    continue;
                }

#ifndef DBG
                //
                //  Find out if this device is marked as a bad device
                //
                LoggedDescription[0] = L'\0';
                if( (GetPrivateProfileString( szLegacyClassesSection,
                                              DevInstId,
                                              L"",
                                              LoggedDescription,
                                              sizeof(LoggedDescription)/sizeof(WCHAR),
                                              PnpLogPath ) != 0) &&
                    ( wcslen( LoggedDescription ) != 0 )
                  ) {
                    //
                    //  Skip the installation of this device
                    //
                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device: %ls", DevInstId );
                    continue;
                }
#endif

                //
                //  Retrieve information about the driver node selected above.
                //
                DriverInfoData.cbSize = sizeof( SP_DRVINFO_DATA );
                if( !SetupDiGetSelectedDriver( InfoSetArray[ GuidIndex ],
                                               &TempDeviceInfoData,
                                               &DriverInfoData ) ) {

                    SetupDebugPrint1( L"SETUP:            SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;

                }

                //
                // Retrieve syssetup PnP flags (if any) the INF specifies for this
                // device.
                //
                PnPFlags = SyssetupGetPnPFlags(InfoSetArray[ GuidIndex ],
                                               &TempDeviceInfoData,
                                               &DriverInfoData
                                              );

                SetupDebugPrint3( L"SETUP: Installing  device: %ls, GuidIndex = %d, Index = %d", DevInstId, GuidIndex, Index );
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if(!SetupDiGetDeviceInstallParams(InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &DeviceInstallParams)) {
                    SetupDebugPrint1( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;
                }

                DeviceInstallParams.Flags &= ~DI_FORCECOPY;
                DeviceInstallParams.Flags &= ~DI_NOVCP;
                DeviceInstallParams.Flags |= DI_NOFILECOPY;
                DeviceInstallParams.FileQueue = NULL;

                if(PnPFlags & PNPFLAG_DONOTCALLCONFIGMG) {
                    //
                    // We _do not_ honor this flag for devices reported via
                    // DIF_FIRSTTIMESETUP.  The intent of this flag is to
                    // prevent us from perturbing correctly-functioning devices
                    // and potentially causing problems (e.g., moving PCI
                    // bridges or COM ports off of their boot configs).  This
                    // concern does not apply to legacy-detected devnodes.  We
                    // definitely _do_ want to bring these devices on-line now,
                    // or else devices attached to them (whether PnP or legacy)
                    // won't be found and installed.
                    //
                    SetupDebugPrint( L"SETUP: Clearing PNPFLAG_DONOTCALLCONFIGMG since this is a detected device." );

                    PnPFlags &= ~PNPFLAG_DONOTCALLCONFIGMG;
                }

                if(!SetupDiSetDeviceInstallParams(InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &DeviceInstallParams)) {
                    SetupDebugPrint1( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;
                }

                Phase3Context = MyMalloc( sizeof( PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ) );
                Phase3Context->hDevInfo = InfoSetArray[ GuidIndex ];
                Phase3Context->DeviceInfoData = TempDeviceInfoData;
                Phase3Context->pDeviceId = pSetupDuplicateString( DevInstId );
                Phase3Context->DevicesInstalledStringTable = DevicesInstalledStringTable;

                ThreadHandle = NULL;
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             pPhase3InstallPnpLegacyDevicesThread,
                                             Phase3Context,
                                             0,
                                             &ThreadId );
                if( ThreadHandle ) {
                    DWORD   WaitResult;
                    DWORD   ExitCode;
                    BOOL    KeepWaiting;

                    KeepWaiting = TRUE;
                    while( KeepWaiting ) {
                        //
                        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                        //  Fix the network timeout after the network guys fix their class installer
                        //
                        WaitResult = WaitForSingleObject( ThreadHandle,
                                                          (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                     PNP_LEGACY_PHASE3_TIMEOUT );
                        if( WaitResult == WAIT_TIMEOUT ) {
                            int Result;
                            HANDLE  hDialogEvent;

                            if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                                //
                                // Setupapi is prompting the user for a file.  Don't timeout.
                                //
                                CloseHandle( hDialogEvent );
                                KeepWaiting = TRUE;
                                continue;
                            } else {
                            }

                            //
                            //  Class installer is hung
                            //
                            SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase3). DeviceId = %ls", DevInstId );

#ifdef PRERELEASE
                            //
                            //  Ask the user if he wants to skip the installation of this class of devices
                            //
                            if( !Unattended ) {
                                Result = MessageBoxFromMessage( hwndParent,
                                                                MSG_CLASS_INSTALLER_HUNG,
                                                                NULL,
                                                                IDS_WINNT_SETUP,
                                                                MB_YESNO | MB_ICONWARNING,
                                                                DevInstId );
                            } else {
                                Result = IDYES;
                            }
#else
                            Result = IDYES;
#endif

                            if(Result == IDYES) {
                                //
                                //  User wants to skip this device.
                                //  First find out if the thread has already returned.
                                //
                                WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                                if( WaitResult != WAIT_OBJECT_0 ) {
                                    //
                                    //  Thread hasn't returned yet. Skip the installation of this device
                                    //
                                    KeepWaiting = FALSE;
                                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device (phase3). Device = %ls", DevInstId );
                                    b = FALSE;
                                    if( !SetupDiGetClassDescription( &GuidList[ GuidIndex ],
                                                                     LoggedDescription,
                                                                     sizeof(LoggedDescription)/sizeof(WCHAR),
                                                                     NULL ) ) {
                                        SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                                        //
                                        //  Assume anything for class description, since we don't really care about it,
                                        //  for logging purposes. The class description only helps identify the problematic
                                        //  device.
                                        //
                                        StringCchCopy( LoggedDescription,
                                                       sizeof(LoggedDescription)/sizeof(WCHAR),
                                                       L"1" );
                                    }
                                    //
                                    //  Remember this device so that it won't be installed if GUI setup is
                                    //  restarted
                                    //
                                    WritePrivateProfileString( szLegacyDevSection,
                                                               DevInstId,
                                                               LoggedDescription,
                                                               PnpLogPath );
                                } else{
                                    //
                                    //  Thread has already returned.
                                    //  There is no need to skip the installation of this device.
                                    //  We assume that the user decided not to skip the installation of this device,
                                    //  and next call to WaitForSingleObject will immediately return.
                                    //
                                }
                            }

                        } else if( WaitResult == WAIT_OBJECT_0 ) {
                            //
                            //  Device Installation Thread completed.
                            //  Find out the outcome of this phase of the installation.
                            //
                            KeepWaiting = FALSE;
                            if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                                if( !ExitCode ) {
                                    //
                                    // The installation was not successful.
                                    // There is no need to log the error, since the thread has already done it.
                                    //
                                    b = FALSE;
                                }
                            } else {
                                //
                                //  Unable to retrieve exit code. Assume success.
                                //
                                SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                                SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming device successfully installed (phase3)." );
                            }
                            MyFree(Phase3Context->pDeviceId);
                            MyFree(Phase3Context);

                        } else {
                            //
                            //  Should not occur
                            //
                            KeepWaiting = FALSE;
                            SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                            b = FALSE;
                        }
                    }
                    //
                    // The thread handle is no longer needed at this point
                    //
                    CloseHandle(ThreadHandle);

                } else {
                    //
                    // Unable to create the thread. Just do it syncronously.
                    //
                    Error = GetLastError();
                    SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase3). Error = %d", Error );
                    if( !pPhase3InstallPnpLegacyDevicesThread(Phase3Context) ) {
                        //
                        // The installation was not successful.
                        // There is no need to log the error, since the thread has already done it.
                        //
                        b = FALSE;
                    }
                    MyFree( Phase3Context->pDeviceId );
                    MyFree( Phase3Context );
                }
            }

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"SETUP: Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
                b = FALSE;
            }
        }

        //
        //  Get rid of the file queue, if it exists
        //
        if( FileQ != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(FileQ);
        }
    }

    //
    //  Make sure that at this point, the gauge area is filled up to the end of
    //  the area reserved for the installation of legacy devices.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    //
    //  Get rid of the list of GUIDs.
    //
    if( GuidList != NULL ) {
        MyFree( GuidList );
    }

    //
    //  Get rid of InfoSetArray, and all info sets stored on it.
    //

    if( InfoSetArray != NULL ) {
        for( GuidIndex = 0; GuidIndex < GuidCount; GuidIndex++ ) {
            if( InfoSetArray[ GuidIndex ] != INVALID_HANDLE_VALUE ) {
                SetupDiDestroyDeviceInfoList( InfoSetArray[ GuidIndex ] );
            }
        }
        MyFree( InfoSetArray );
    }
    SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
    return( b );
}



BOOL
InstallEnumeratedDevices(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent,
    IN PVOID DevicesInstalledStringTable    OPTIONAL
    )
/*++

Routine Description:

    This function enumerates and install all new PnP devices detected during
    GUI setup.

Arguments:

    hwndParent - Handle to a top level window that may be used for UI purposes.

    InfHandle - System setup inf handle (syssetup.inf).
    
    ProgressWindow -
    
    StartAtPercent - 
    
    StopAtPercent - 
    
    DevicesInstalledStringTable - If present, every device that is successfully
                                  installed should have their device instance 
                                  Id added to the string table.


Return Value:

    Returns TRUE if all enumerated hardware were installed successfully.

--*/
{
    HANDLE              hPipeEvent = NULL;
    HANDLE              hPipe = INVALID_HANDLE_VALUE;
    ULONG               Index = 0;
    ULONG               Error;
    ULONG               ulSize = 0;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    WCHAR               szBuffer[MAX_PATH];
    BOOL                b = TRUE;
    UINT                GaugeRange = 100;
    WCHAR               RootPath[ MAX_PATH + 1];
    WCHAR               PnpLogPath[ MAX_PATH + 1];
    PAF_DRIVERS         AfDrivers;
    PAF_DRIVER_ATTRIBS  SelectedAfDriver;
    PSP_DEVINFO_DATA    pDeviceInfoData = NULL;
    ULONG               PnPFlags;
    HANDLE              hBatchEvent = NULL;
    DWORD               Result;


    SetupDebugPrint( L"SETUP: Entering InstallEnumeratedDevices()" );

    //
    //  Build path to pnp log file
    //
    Result = GetWindowsDirectory( PnpLogPath, sizeof(PnpLogPath)/sizeof(WCHAR) );
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!pSetupConcatenatePaths( PnpLogPath, 
                                 szPnpLogFile, 
                                 sizeof(PnpLogPath)/sizeof(WCHAR), 
                                 NULL )) {
        MYASSERT(FALSE);
        return FALSE;
    }

    //
    //  Initialize RootPath with empty string
    //
    RootPath[0] = L'\0';

    //
    //  Initialize answer file table
    //
    AfDrivers = CreateAfDriverTable();

    //
    //  Attempt to create the event that will be used to signal the successfull
    //  creation of the named pipe
    //
    hPipeEvent = CreateEvent( NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT );
    if (hPipeEvent == NULL) {
        Error = GetLastError();
        if( Error != ERROR_ALREADY_EXISTS ) {
            SetupDebugPrint1( L"SETUP: CreateEvent() failed. Error = %d", Error );
            b = FALSE;
            goto Clean0;
        }
        //
        // If umpnpmgr has already created the event, then just open the event
        //
        hPipeEvent = OpenEvent(EVENT_MODIFY_STATE,
                           FALSE,
                           PNP_CREATE_PIPE_EVENT);

        if (hPipeEvent == NULL) {
            SetupDebugPrint1( L"SETUP: OpenEvent() failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }
    }

    //
    //  Attempt to create the event that will be used to signal the completion of
    //  processing of the last batch of devices.
    //
    hBatchEvent = CreateEvent( NULL, TRUE, FALSE, PNP_BATCH_PROCESSED_EVENT );
    if (hBatchEvent == NULL) {
        Error = GetLastError();
        if( Error != ERROR_ALREADY_EXISTS ) {
            SetupDebugPrint1( L"SETUP: CreateEvent() failed. Error = %d", Error );
            b = FALSE;
            goto Clean0;
        }
        //
        // If umpnpmgr has already created the event, then just open the event
        //
        hBatchEvent = OpenEvent(EVENT_MODIFY_STATE,
                           FALSE,
                           PNP_BATCH_PROCESSED_EVENT);

        if (hBatchEvent == NULL) {
            SetupDebugPrint1( L"SETUP: OpenEvent() failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }
    }

    //
    // create the named pipe, umpnpmgr will write requests to
    // this pipe if new hardware is found
    //
    hPipe = CreateNamedPipe(PNP_NEW_HW_PIPE,
                            PIPE_ACCESS_INBOUND,
                            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                            1,                 // only one connection
                            sizeof(szBuffer),  // out buffer size
                            sizeof(szBuffer),  // in buffer size
                            PNP_PIPE_TIMEOUT,  // default timeout
                            NULL               // default security
                            );

    //
    // signal the event now
    //
    SetEvent(hPipeEvent);

    if (hPipe == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1( L"SETUP: CreateNamedPipe() failed. Error = %d", GetLastError() );
        b = FALSE;
        goto Clean0;
    }

    //
    // Connect to the newly created named pipe.
    // If umpnpmgr is not already connected to the named pipe, then ConnectNamedPipe()
    // will succeed. Otherwise, it will fail with ERROR_PIPE_CONNECTED. Note however that
    // this is not an error condition.
    //
    if (ConnectNamedPipe(hPipe, NULL) ||
        ((Error = GetLastError()) == ERROR_PIPE_CONNECTED) ) {
        //
        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
        //           This is gauge related and needs to be fixed.
        //           We are assuming a total of 50 enumerated device.
        //
        BOOL    AlwaysFalse = FALSE;
        UINT    BogusValue = 50;

        //
        //  Initialize the gauge
        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
        //  Fix this - We are assuming a fixed number of devices
        //
        GaugeRange = (BogusValue*100/(StopAtPercent-StartAtPercent));
        SendMessage(ProgressWindow, WMX_PROGRESSTICKS, BogusValue, 0);
        SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

        //
        // listen to the named pipe by submitting read
        // requests until the named pipe is broken on the
        // other end.
        //
        for( Index = 0;
             //
             //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
             //  This is gauge related and needs to be fixed.
             //  We are assuming a constant number of enumerated devices
             //
             ( (Index != 0) &&
               (Index < BogusValue) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||                                               // This is a trick to force the gauge to be upgraded after a
                                                                // device is processed, and the pipe to be read.
             ReadFile( hPipe,
                       (LPBYTE)szBuffer,    // device instance id
                       sizeof(szBuffer),
                       &ulSize,
                       NULL );
             Index++ ) {

            SP_DRVINFO_DATA             DriverInfoData;
            SP_DEVINSTALL_PARAMS        DeviceInstallParams;
            WCHAR                       GUIDString[ 64 ];
            WCHAR                       ClassDescription[ LINE_LEN + 1 ];
            HANDLE                      ThreadHandle = NULL;
            DWORD                       ThreadId;
            PPNP_ENUM_DEV_THREAD_PARAMS Context;
            BOOL                        DeviceInstalled;
            WCHAR                       LoggedDescription[ LINE_LEN + 1 ];
            BOOL                        bOemF6Driver;

            if (lstrlen(szBuffer) == 0) {

                SetEvent(hBatchEvent);
                continue;
            }
            SetupDebugPrint2( L"SETUP: Index = %d, DeviceId = %ls", Index, szBuffer );
            //
            //  Check if this device is listed as a bad device
            //
            LoggedDescription[0] = L'\0';
            if( (GetPrivateProfileString( szEnumDevSection,
                                          szBuffer,
                                          L"",
                                          LoggedDescription,
                                          sizeof(LoggedDescription)/sizeof(WCHAR),
                                          PnpLogPath ) != 0) &&
                ( wcslen( LoggedDescription ) != 0 )
              ) {
#ifndef DBG
                //
                //  Skip the installation of this device
                //
                SetupDebugPrint1( L"SETUP:             Skipping installation of device %ls", szBuffer );
                continue;
#endif
            }
            BEGIN_SECTION(LoggedDescription);

            //
            //  Find out if we need to create an hDevinfo.
            //  We will need to create one if this is the first device that we are installing (Index == 0),
            //  or the class installer for the previous device (Index == Index - 1) is hung. If the class
            //  installer is hung then we cannot use the same hDevinfo, since the class installer has a lock
            //  on it. So we just create a new one.
            //  If the class installer for the previous device didn't hang, then there is no need to create
            //  a new hDevinfo, since we can re-use it. We do this for performance reasons.
            //
            if( hDevInfo == INVALID_HANDLE_VALUE ) {
                //
                // create a devinfo handle and device info data set to
                // pass to DevInstall
                //
                if((hDevInfo = SetupDiCreateDeviceInfoList(NULL, hwndParent))
                                == INVALID_HANDLE_VALUE) {
                    b = FALSE;
                    SetupDebugPrint1( L"SETUP: SetupDiCreateDeviceInfoList() failed. Error = %d", GetLastError() );
                    goto Clean0;
                }
                pDeviceInfoData = MyMalloc(sizeof(SP_DEVINFO_DATA));
                if( pDeviceInfoData == NULL ) {
                    b = FALSE;
                    SetupDebugPrint( L"SETUP: Unable to create pDeviceInfoData.  MyMalloc() failed." );
                    goto Clean0;
                }
                pDeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
            }

            if(!SetupDiOpenDeviceInfo(hDevInfo, szBuffer, hwndParent, 0, pDeviceInfoData)) {
                SetupDebugPrint1( L"SETUP:             SetupDiOpenDeviceInfo() failed. Error = %d", GetLastError() );
                b = FALSE;
                END_SECTION(LoggedDescription);
                continue;

            }


            //
            // Answer file support: Test the answer file to see if it has a driver
            // in its [DeviceDrivers] section.  This overrides the NT-supplied driver,
            // if one exists.
            //
            if (!SyssetupInstallAnswerFileDriver (
                    AfDrivers,
                    hDevInfo,
                    pDeviceInfoData,
                    &SelectedAfDriver
                    )) {

                //
                // No answer file driver, proceed with the standard device install
                //

                SetupDebugPrint( L"SETUP:            Device was NOT installed via answer file driver" );

                //
                //  Build a list of compatible drivers for this device
                //  (This call can be time consuming the first time it is called)
                //
                if( !SetupDiBuildDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER ) ) {
                    SetupDebugPrint1( L"SETUP:         SetupDiBuildDriverInfoList() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;
                }

                //
                //  Select the best compatible driver for this device.
                //
                if( !SelectBestDriver( hDevInfo,
                                       pDeviceInfoData,
                                       &bOemF6Driver ) ) {

                    Error = GetLastError();
                    if( Error != ERROR_NO_COMPAT_DRIVERS ) {

                        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV) failed. Error = %d", Error );
                        b = FALSE;
                        END_SECTION(LoggedDescription);
                        continue;
                    }

                    SetupDebugPrint( L"SETUP:            Compatible driver List is empty" );
                    SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

                    //
                    //  Install the null driver for this device.
                    //  This is to avoid the "Found New Hardware" popup when the
                    //  user first logs on after the system is installed.
                    //
                    if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData, DevicesInstalledStringTable ) ) {
                        SetupDebugPrint( L"SETUP:            Unable to install null driver" );
                    }

                    END_SECTION(LoggedDescription);
                    continue;
                }

                //
                // Check if we need to rebuild the driver list without including the
                // old Internet drivers.
                //
                if (RebuildListWithoutOldInternetDrivers(hDevInfo, pDeviceInfoData)) {

                    SetupDiDestroyDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER );

                    //
                    // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't include
                    // old internet drivers in the list that build.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      ))
                    {
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                        SetupDiSetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      );
                    }

                    //
                    //  Build a list of compatible drivers for this device
                    //  (This call can be time consuming the first time it is called)
                    //
                    if( !SetupDiBuildDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER ) ) {
                        SetupDebugPrint1( L"SETUP:         SetupDiBuildDriverInfoList() failed. Error = %d", GetLastError() );
                        b = FALSE;
                        continue;
                    }

                    //
                    //  Select the best compatible driver for this device.
                    //
                    if( !SelectBestDriver( hDevInfo,
                                           pDeviceInfoData,
                                           &bOemF6Driver ) ) {

                        Error = GetLastError();
                        if( Error != ERROR_NO_COMPAT_DRIVERS ) {

                            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV) failed. Error = %d", Error );
                            b = FALSE;
                            END_SECTION(LoggedDescription);
                            continue;
                        }

                        SetupDebugPrint( L"SETUP:            Compatible driver List is empty" );
                        SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

                        //
                        //  Install the null driver for this device.
                        //  This is to avoid the "Found New Hardware" popup when the
                        //  user first logs on after the system is installed.
                        //
                        if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData, DevicesInstalledStringTable ) ) {
                            SetupDebugPrint( L"SETUP:            Unable to install null driver" );
                        }

                        END_SECTION(LoggedDescription);
                        continue;
                    }
                }

            } else {
                SetupDebugPrint( L"SETUP:            Device was installed via answer file driver" );
            }

            //
            //  Retrieve information about the driver node selected above.
            //
            DriverInfoData.cbSize = sizeof( SP_DRVINFO_DATA );
            if( !SetupDiGetSelectedDriver( hDevInfo,
                                           pDeviceInfoData,
                                           &DriverInfoData ) ) {

                SetupDebugPrint1( L"SETUP:            SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                b = FALSE;
                continue;
            }
            
            //
            //  Get the GUID string for this device
            //
            GUIDString[0] = (WCHAR)'\0';
            pSetupStringFromGuid( &(pDeviceInfoData->ClassGuid), GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );

            SetupDebugPrint1( L"SETUP:            DriverType = %lx", DriverInfoData.DriverType );
            SetupDebugPrint1( L"SETUP:            Description = %ls", &(DriverInfoData.Description[0]) );
            SetupDebugPrint1( L"SETUP:            MfgName = %ls", &(DriverInfoData.MfgName[0]) );
            SetupDebugPrint1( L"SETUP:            ProviderName = %ls", &(DriverInfoData.ProviderName[0]) );
            SetupDebugPrint1( L"SETUP:            GUID = %ls", GUIDString );

            ClassDescription[0] = (WCHAR)'\0';
            if( !SetupDiGetClassDescription( &(pDeviceInfoData->ClassGuid),
                                             ClassDescription,
                                             sizeof(ClassDescription)/sizeof(WCHAR),
                                             NULL ) ) {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                ClassDescription[0] = (WCHAR)'\0';
            }
            SetupDebugPrint1( L"SETUP:            DeviceClass = %ls", ClassDescription );

            //
            // Retrieve syssetup PnP flags (if any) the INF specifies for this
            // device.
            //
            PnPFlags = SyssetupGetPnPFlags(hDevInfo, pDeviceInfoData, &DriverInfoData);

            if( SkipDeviceInstallation( hDevInfo,
                                        pDeviceInfoData,
                                        InfHandle,
                                        GUIDString ) ) {
                SetupDebugPrint( L"SETUP:            Skipping installation of this device" );
                END_SECTION(LoggedDescription);
                continue;
            }

            //
            // If the PnP flag was set that said we shouldn't call ConfigMgr
            // for this device, then set the appropriate flag in the device's
            // install params.
            //
            if(PnPFlags & PNPFLAG_DONOTCALLCONFIGMG) {

                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                                    pDeviceInfoData,
                                                    &DeviceInstallParams ) ) {
                    Error = GetLastError();
                    if( ((LONG)Error) < 0 ) {
                        //
                        //  Setupapi error code, display it in hex
                        //
                        SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
                    } else {
                        //
                        //  win32 error code, display it in decimal
                        //
                        SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
                    }
                } else {

                    DeviceInstallParams.Flags |= DI_DONOTCALLCONFIGMG;

                    if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                                        pDeviceInfoData,
                                                        &DeviceInstallParams ) ) {
                        Error = GetLastError();
                        if( ((LONG)Error) < 0 ) {
                            //
                            //  Setupapi error code, display it in hex
                            //
                            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
                        } else {
                            //
                            //  win32 error code, display it in decimal
                            //
                            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
                        }
                    }
                }
            }

            //
            //  Start the thread that actually does the installation of the device
            //
            Context = MyMalloc( sizeof(PNP_ENUM_DEV_THREAD_PARAMS) );
            Context->hDevInfo = hDevInfo;
            Context->DeviceInfoData = *pDeviceInfoData;
            Context->pDeviceDescription = pSetupDuplicateString(&(DriverInfoData.Description[0]));
            Context->pDeviceId = pSetupDuplicateString(szBuffer);
            Context->DevicesInstalledStringTable = DevicesInstalledStringTable;

            DeviceInstalled = FALSE;
            ThreadHandle = CreateThread( NULL,
                                         0,
                                         pInstallPnpEnumeratedDeviceThread,
                                         Context,
                                         0,
                                         &ThreadId );
            if(ThreadHandle) {
                DWORD   WaitResult;
                DWORD   ExitCode;
                BOOL    KeepWaiting;

                KeepWaiting = TRUE;
                while( KeepWaiting ) {
                    //
                    //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                    //  Fix the network timeout after the network guys fix their class installer
                    //
                    WaitResult = WaitForSingleObject( ThreadHandle,
                                                      (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                 PNP_ENUM_TIMEOUT );
                    if( WaitResult == WAIT_TIMEOUT ) {
                        int Result;
                        HANDLE  hDialogEvent;

                        if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                            //
                            // Setupapi is prompting the user for a file.  Don't timeout.
                            //
                            CloseHandle( hDialogEvent );
                            KeepWaiting = TRUE;
                            continue;
                        }

                        //
                        //  Class installer is hung
                        //
                        SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung. Device = %ls", &(DriverInfoData.Description[0]) );

#ifdef PRERELEASE
                        //
                        //  Ask the user if he wants to skip the installation of this device.
                        //
                        if( !Unattended ) {
                            Result = MessageBoxFromMessage( hwndParent,
                                                            MSG_CLASS_INSTALLER_HUNG,
                                                            NULL,
                                                            IDS_WINNT_SETUP,
                                                            MB_YESNO | MB_ICONWARNING,
                                                            &(DriverInfoData.Description[0]) );
                        } else {
                            Result = IDYES;
                        }
#else
                        Result = IDYES;
#endif

                        if(Result == IDYES) {
                            //
                            //  User wants to skip this device.
                            //  First find out if the thread has already returned.
                            //
                            WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                            if( WaitResult != WAIT_OBJECT_0 ) {
                                //
                                //  Thread hasn't returned yet. Skip the installation of this device.
                                //
                                KeepWaiting = FALSE;
                                SetupDebugPrint1( L"SETUP:    Skipping installation of enumerated device. Device = %ls", &(DriverInfoData.Description[0]) );
                                b = FALSE;
                                //
                                //  Remember this device so that it won't be installed if GUI setup is
                                //  restarted
                                //
                                WritePrivateProfileString( szEnumDevSection,
                                                           szBuffer,
                                                           &(DriverInfoData.Description[0]),
                                                           PnpLogPath );
                                //
                                // Since the class installer is hung, we cannot re-use the hDevInfo that was passed
                                // to the class installer. So we just ignore this one. We will create a new one for
                                // the next device to be installed.
                                //
                                hDevInfo = INVALID_HANDLE_VALUE;
                                pDeviceInfoData = NULL;
                            } else{
                                //
                                //  Thread has already returned.
                                //  There is no need to skip the installation of this device.
                                //  We assume that the user decided not to skip the installation of this device,
                                //  and next call to WaitForSingleObject will immediately return.
                                //
                            }
                        }

                    } else if( WaitResult == WAIT_OBJECT_0 ) {

                        //
                        //  Device Installation Thread completed.
                        //
                        KeepWaiting = FALSE;
                        //
                        //  Deallocate memory passed to the thread.
                        //
                        MyFree( Context->pDeviceDescription );
                        MyFree( Context->pDeviceId );
                        MyFree( Context );
                        if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                            if( ExitCode == ERROR_SUCCESS ) {
                                //
                                // The installation was successful
                                //
                                DeviceInstalled = TRUE;
                                SetupDebugPrint( L"SETUP:            Device successfully installed." );

                            } else {
                                //
                                // The installation was not successful.
                                // There is no need to log the error, since the thread has already done it.
                                //
                                SetupDebugPrint( L"SETUP:            Device not successfully installed." );
                                b = FALSE;
                            }
                        } else {
                            //
                            //  Unable to retrieve exit code. Assume success.
                            //
                            SetupDebugPrint1( L"SETUP:            GetExitCode() failed. Error = %d", GetLastError() );
                            SetupDebugPrint( L"SETUP:            Unable to retrieve thread exit code. Assuming device successfully installed." );
                        }

                    } else {
                        //
                        //  Should not occur
                        //
                        KeepWaiting = FALSE;
                        SetupDebugPrint1( L"SETUP:            WaitForSingleObject() returned %d", WaitResult );

                        // MyFree( Context->pDeviceDescription );
                        // MyFree( Context->pDeviceId );
                        // MyFree( Context );
                        b = FALSE;

                    }
                }
                //
                //  The thread handle is no longer needed.
                //
                CloseHandle(ThreadHandle);
            } else {
                //
                // Just do it synchronously.
                //
                SetupDebugPrint1( L"SETUP:            CreateThread() failed (enumerated device). Error = %d", GetLastError() );

                if( pInstallPnpEnumeratedDeviceThread(Context) != ERROR_SUCCESS ) {
                    //
                    // The installation was not successful.
                    // There is no need to log the error, since the thread has already done it.
                    //
                    SetupDebugPrint( L"SETUP:            Device not successfully installed." );
                    b = FALSE;
                } else {
                    DeviceInstalled = TRUE;
                }
                MyFree( Context->pDeviceDescription );
                MyFree( Context->pDeviceId );
                MyFree( Context );
            }


            if( DeviceInstalled ) {
                //
                // If this device came from the answer file, then change the original
                // media path from the local temp dir to the original path (typically
                // the floppy drive).
                //
                if (SelectedAfDriver) {
                    SyssetupFixAnswerFileDriverPath (
                        SelectedAfDriver,
                        hDevInfo,
                        pDeviceInfoData
                        );
                }

                //
                // If the driver we just installed was an Oem F6 driver then
                // we need to add it to the list of files that SfcInitProt
                // will leave alone during its scan.
                //
                if (bOemF6Driver) {
                    AddOemF6DriversToSfcIgnoreFilesList(hDevInfo, pDeviceInfoData);
                }
            }
            END_SECTION(LoggedDescription);
        }

        //
        // Find out why we stopped reading the pipe. If it was because the connetion
        // to the pipe was broken by umpnp, then there was nothing else to read from
        // the pipe. Otherwise, there was an error condition.
        //
        if( ( Error = GetLastError() ) != ERROR_BROKEN_PIPE ) {
            SetupDebugPrint1( L"SETUP: ReadFile( hPipe ) failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }

    } else {
        SetupDebugPrint1( L"SETUP: ConnectNamedPipe() failed. Error = %d", GetLastError() );
        b = FALSE;
        goto Clean0;
    }


Clean0:
    BEGIN_SECTION(L"InstallEnumeratedDevices cleanup");
    //
    // Make sure that at this point the gauge is filled up to the end of the
    // region reserved for the installation of the enumerated devices.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    if (hPipe != INVALID_HANDLE_VALUE) {
        DisconnectNamedPipe(hPipe);
        CloseHandle(hPipe);
    }
    if (hPipeEvent != NULL) {
        CloseHandle(hPipeEvent);
    }
    if (hBatchEvent != NULL) {
        CloseHandle(hBatchEvent);
    }

    if( hDevInfo != INVALID_HANDLE_VALUE ) {
        SetupDiDestroyDeviceInfoList( hDevInfo );
    }

    DestroyAfDriverTable (AfDrivers);

    if( pDeviceInfoData != NULL ) {
        MyFree( pDeviceInfoData );
    }
    SetupDebugPrint( L"SETUP: Leaving InstallEnumeratedDevices()" );
    END_SECTION(L"InstallEnumeratedDevices cleanup");
    return( b );
}


DWORD
pInstallPnpDevicesThread(
    PPNP_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This is the thread that does the installation of the PnP devices.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returnd TRUE if the operation succeeds, or FALSE otherwise.

--*/

{
    BOOL b;
    PPNP_THREAD_PARAMS Context;
    ULONG StartAtPercent;
    ULONG StopAtPercent;
    ULONG DeltaPercent;
    PVOID DevicesInstalledStringTable = NULL;

    Context = ThreadParams;

    //
    // Assume success.
    //
    b = TRUE;

    //
    // We don't want SetupAPI to do any RunOnce calls, as we'll do it manually
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_RUNONCE);

    //
    //  Initialize some variables that are related to the progress bar.
    //  We divide the progress window area reserved for pnp installation in 3 regions
    //  of equal size, and they will be used in the following steps:
    //          . Pre-compilation of infs
    //          . Installation of enumerated devices
    //          . Installation of legacy devices
    //          . Installation of enumerated devices that may have appeared after the installation of legacy devices
    //
    DeltaPercent = (Context->ProgressWindowStopAtPercent - Context->ProgressWindowStartAtPercent) / 4;
    StartAtPercent = Context->ProgressWindowStartAtPercent;
    StopAtPercent = Context->ProgressWindowStartAtPercent + DeltaPercent;

    //
    //  Pre-compile inf files
    //

    //
    // Before we can start precompiling inf files, let's "seed" the INF
    // directory with any OEM-supplied INFs that need to be present during
    // detection.  This should be really quick and doesn't require the
    // updating the progress window
    //
    RemainingTime = CalcTimeRemaining(Phase_PrecompileInfs);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing OEM infs");
    InstallOEMInfs();
    //
    // Add migrated drivers to the SFC exclusion list
    //
    SfcExcludeMigratedDrivers ();
    END_SECTION(L"Installing OEM infs");

    BEGIN_SECTION(L"Precompiling infs");
    PrecompileInfFiles( Context->ProgressWindow,
                        StartAtPercent,
                        StopAtPercent );
    END_SECTION(L"Precompiling infs");

    //
    // Initialize a string table that will be used to track which devices have
    // drivers successfully installed.
    //
    DevicesInstalledStringTable = pSetupStringTableInitialize();

    //
    //  This operation is very fast, so we don't need to upgrade the progress bar.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Mark PnP devices for reinstall");
        MarkPnpDevicesAsNeedReinstall(DevicesInstalledStringTable);
        END_SECTION(L"Mark PnP devices for reinstall");
    }

    //
    // Do the migration of legacy devices...at the moment all that PnPInit does
    // is migrate all the device nodes who belong to the vid load order group to
    // be put into the display class.  This is the desired result.
    //
    // This is a quick operation and doesn't need to use the progress window.
    //
    PnPInitializationThread(NULL);

    //
    //  Do installation of enumerated devices
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent += DeltaPercent;

    RemainingTime = CalcTimeRemaining(Phase_InstallEnumDevices1);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing enumerated devices");
    b = InstallEnumeratedDevices( Context->Window,
                                  Context->InfHandle,
                                  Context->ProgressWindow,
                                  StartAtPercent,
                                  StopAtPercent,
                                  DevicesInstalledStringTable );

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    CallRunOnceAndWait();
    END_SECTION(L"Installing enumerated devices");

    //
    //  Do the installation of legacy pnp devices.
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent += DeltaPercent;

    BEGIN_SECTION(L"Installing legacy devices");
    RemainingTime = CalcTimeRemaining(Phase_InstallLegacyDevices);
    SetRemainingTime(RemainingTime);
    b = InstallLegacyDevices( Context->Window,
                              Context->ProgressWindow,
                              StartAtPercent,
                              StopAtPercent,
                              DevicesInstalledStringTable ) && b;

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    CallRunOnceAndWait();
    END_SECTION(L"Installing legacy devices");


    //  Install the remaining enumerated devices that may have appeared after the
    //  installation of the legacy devices.
    //  Since this step uses the last region of the progress window,
    //  use as StopAtPercent, the value that was passed to this function,
    //  instead of the calulated value (by adding DeltaPorcent). This will
    //  ensure that at the end of this step, the gauge will be filled up
    //  completely. If we use the calculated value, then rounding error
    //  can cause the gauge not to be completelly filled up at the end of
    //  this step.
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent = Context->ProgressWindowStopAtPercent;

    BEGIN_SECTION(L"Install enumerated devices triggered by legacy devices");
    RemainingTime = CalcTimeRemaining(Phase_InstallEnumDevices2);
    SetRemainingTime(RemainingTime);
    b = InstallEnumeratedDevices( Context->Window,
                                  Context->InfHandle,
                                  Context->ProgressWindow,
                                  StartAtPercent,
                                  StopAtPercent,
                                  DevicesInstalledStringTable ) && b;

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    // since we will not be calling RunOnce again after this
    // allow devices to call RunOnce immediately
    // (other device install threads may be still running)
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_RUNONCE);
    CallRunOnceAndWait();
    END_SECTION(L"Install enumerated devices triggered by legacy devices");

    //
    //  Mark all non-present devices as needing re-install
    //  we do this a 2nd time in case a device "disappeared" due to the
    //  re-installation of a parent device
    //  This operation is very fast, so we don't need to upgrade the progress bar.
    //
    if( !MiniSetup ) {
        MarkPnpDevicesAsNeedReinstall(DevicesInstalledStringTable);
    }

    if (DevicesInstalledStringTable) {
        pSetupStringTableDestroy(DevicesInstalledStringTable);
    }

    if( Context->SendWmQuit ) {
        ULONG   Error = ERROR_SUCCESS;

        //
        //  We send WM_QUIT only if this routine was started as a separate thread.
        //  Otherwise, the WM_QUIT will be processed by the wizard, and it will make it stop.
        //
        do {
            if( !PostThreadMessage(Context->ThreadId,WM_QUIT,b,0) ) {
                Error = GetLastError();
                SetupDebugPrint1( L"SETUP: PostThreadMessage(WM_QUIT) failed. Error = %d", Error );
            }
        } while ( Error != ERROR_SUCCESS );
    }

    return( b );
}


BOOL
InstallPnpDevices(
    IN HWND  hwndParent,
    IN HINF  InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
/*++

Routine Description:

    This function creates and starts the thread responsible for installation of
    PnP devices.

Arguments:

    hwndParent - Handle to a top level window that may be used for UI purposes

    InfHandle - System setup inf handle (syssetup.inf).

    ProgressWindow - Handle to the progress bar.

    StartAtPercent - Starting position in the progress bar.
                     It indicates that from position 0 to this position
                     the gauge is already filled.

    StopAtPercent - Ending position of the progress bar.
                    The pnp thread should not fill the progress bar beyond
                    this position

Return Value:

    Returns TRUE if all the PnP devices installed successfully.

--*/

{
    BOOL Success = TRUE;
    DWORD ThreadId;
    HANDLE ThreadHandle = NULL;
    PNP_THREAD_PARAMS Context;
    MSG msg;


    Context.ThreadId = GetCurrentThreadId();
    Context.Window = hwndParent;
    Context.ProgressWindow = ProgressWindow;
    Context.InfHandle = InfHandle;
    Context.ProgressWindowStartAtPercent = StartAtPercent;
    Context.ProgressWindowStopAtPercent = StopAtPercent;
    Context.SendWmQuit = TRUE;

    ThreadHandle = CreateThread(
                        NULL,
                        0,
                        pInstallPnpDevicesThread,
                        &Context,
                        0,
                        &ThreadId
                        );
    if(ThreadHandle) {

        CloseHandle(ThreadHandle);

        //
        // Pump the message queue and wait for the thread to finish.
        //
        do {
            GetMessage(&msg,NULL,0,0);
            if(msg.message != WM_QUIT) {
                DispatchMessage(&msg);
            }
        } while(msg.message != WM_QUIT);

        Success = (BOOL)msg.wParam;

    } else {
        //
        // Just do it synchronously.
        //
        Context.SendWmQuit = FALSE;
        Success = pInstallPnpDevicesThread(&Context);
    }

    return(Success);
}


BOOL
UpdatePnpDeviceDrivers(
    )
/*++

Routine Description:

    This function goes through all the installed devices and makes sure
    it has the latest and greatest driver.

Arguments:

Return Value:

    Returns TRUE if there are no fatal errors.

--*/

{
    BOOL                                        bRet                                = FALSE;
    HINSTANCE                                   hInstNewDev;
    ExternalUpdateDriverForPlugAndPlayDevicesW  pUpdateDriverForPlugAndPlayDevicesW = NULL;
    HDEVINFO                                    DeviceInfoSet;

    //
    // We need the "UpdateDriverForPlugAndPlayDevices" function from newdev.dll.
    //
    if ( NULL == (hInstNewDev = LoadLibrary(L"newdev.dll")) )
    {
        SetupDebugPrint1(L"SETUP:     Failed to load newdev.dll. Error = %d", GetLastError());
        return bRet;
    }
    pUpdateDriverForPlugAndPlayDevicesW =
        (ExternalUpdateDriverForPlugAndPlayDevicesW) GetProcAddress(hInstNewDev, "UpdateDriverForPlugAndPlayDevicesW");
    if ( NULL == pUpdateDriverForPlugAndPlayDevicesW )
    {
        SetupDebugPrint1(L"SETUP:     Failed to get UpdateDriverForPlugAndPlayDevicesW. Error = %d", GetLastError());
    }

    //
    // Create a device information set that will be the container for
    // the device interfaces.
    //
    else if ( INVALID_HANDLE_VALUE == (DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL)) )
    {
        SetupDebugPrint1(L"SETUP:     Failed SetupDiCreateDeviceInfoList(). Error = %d", GetLastError());
    }
    else
    {
        HDEVINFO NewDeviceInfoSet;

        //
        // Get the list of all present devices.
        //
        NewDeviceInfoSet = SetupDiGetClassDevsEx(NULL,
                                                 NULL,
                                                 NULL,
                                                 DIGCF_ALLCLASSES | DIGCF_PRESENT,
                                                 DeviceInfoSet,
                                                 NULL,
                                                 NULL);
        if ( INVALID_HANDLE_VALUE == NewDeviceInfoSet )
        {
            SetupDebugPrint1(L"SETUP:     Failed SetupDiGetClassDevsEx(). Error = %d", GetLastError());
        }
        else
        {
            SP_DEVINFO_DATA DeviceInfoData;
            DWORD           dwDevice;

            //
            // Once we get this far, the default return is TRUE.
            //
            bRet = TRUE;

            //
            // Setup the device info data structutre.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            //
            // Loop through all the devices.
            //
            for ( dwDevice = 0; SetupDiEnumDeviceInfo(NewDeviceInfoSet, dwDevice, &DeviceInfoData); dwDevice++ )
            {
                SP_DEVINSTALL_PARAMS    DeviceInstallParams;
                SP_DRVINFO_DATA         NewDriverInfoData;
                PSP_DRVINFO_DETAIL_DATA pNewDriverInfoDetailData = NULL;
                DWORD                   cbBytesNeeded = 0;
                TCHAR                   szDeviceID[MAX_DEVICE_ID_LEN];

                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                NewDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

                if ( SetupDiGetDeviceInstallParams(NewDeviceInfoSet,
                                                   &DeviceInfoData,
                                                   &DeviceInstallParams) )
                {
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
                    SetupDiSetDeviceInstallParams(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  &DeviceInstallParams);
                }

                //
                // Build the list of possible drivers for this device.
                // Select the best compatible driver for this device.
                // Retrieve information about the driver node selected above.
                // Get driver info details.
                //
                if ( ( SetupDiBuildDriverInfoList(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  SPDIT_COMPATDRIVER ) ) &&

                     ( SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                                 NewDeviceInfoSet,
                                                 &DeviceInfoData ) ) &&

                     ( SetupDiGetSelectedDriver(NewDeviceInfoSet,
                                                &DeviceInfoData,
                                                &NewDriverInfoData ) ) &&

                     ( ( SetupDiGetDriverInfoDetail(NewDeviceInfoSet,
                                                    &DeviceInfoData,
                                                    &NewDriverInfoData,
                                                    NULL,
                                                    0,
                                                    &cbBytesNeeded) ) ||
                       ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ) &&

                     ( cbBytesNeeded ) &&

                     ( pNewDriverInfoDetailData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbBytesNeeded) ) &&

                     ( 0 != (pNewDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA)) ) &&

                     ( SetupDiGetDriverInfoDetail(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  &NewDriverInfoData,
                                                  pNewDriverInfoDetailData,
                                                  cbBytesNeeded,
                                                  NULL) ) &&

                     ( SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                                        &DeviceInfoData,
                                                        SPDRP_HARDWAREID,
                                                        NULL,
                                                        (LPBYTE) szDeviceID,
                                                        sizeof(szDeviceID),
                                                        NULL) ) )

                {
                    HKEY    hDevRegKey;
                    BOOL    bUpdate = TRUE,
                            bRebootFlag;

                    //
                    // Get the device's regkey, so that we can get the
                    // version of the currently installed driver.
                    //
                    if ( INVALID_HANDLE_VALUE != (hDevRegKey = SetupDiOpenDevRegKey(NewDeviceInfoSet,
                                                               &DeviceInfoData,
                                                               DICS_FLAG_GLOBAL,
                                                               0,
                                                               DIREG_DRV,
                                                               KEY_READ)) )
                    {
                        TCHAR   szInfPath[MAX_PATH],
                                szInfName[MAX_PATH];
                        DWORD   dwSize = sizeof(szInfName),
                                dwType;

                        szInfPath[0] = L'\0';
                        GetSystemWindowsDirectory(szInfPath, sizeof(szInfPath) / sizeof(TCHAR));

                        if ( ( szInfPath[0] ) &&

                             ( pSetupConcatenatePaths(szInfPath,
                                                      L"INF",
                                                      sizeof(szInfPath) / sizeof(TCHAR),
                                                      NULL) ) &&

                             ( ERROR_SUCCESS == RegQueryValueEx(hDevRegKey,
                                                                REGSTR_VAL_INFPATH,
                                                                NULL,
                                                                &dwType,
                                                                (LPBYTE) &szInfName,
                                                                &dwSize) ) &&

                             ( pSetupConcatenatePaths(szInfPath,
                                                      szInfName,
                                                      sizeof(szInfPath) / sizeof(TCHAR),
                                                      NULL) ) &&

                             ( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                                           NORM_IGNORECASE,
                                                           pNewDriverInfoDetailData->InfFileName,
                                                           -1,
                                                           szInfPath,
                                                           -1) ) )
                        {
                            //
                            // The inf we found is already in the %windir%\inf folder and is already
                            // installed.  So we don't want to install this inf again.
                            //
                            bUpdate = FALSE;
                        }

                        //
                        // Make sure we close the key.
                        //
                        RegCloseKey(hDevRegKey);
                    }

                    //
                    // Check to see if we have the possibility of a better driver and
                    // try to install it if we do.
                    //
                    if ( bUpdate &&
                         !pUpdateDriverForPlugAndPlayDevicesW(NULL,
                                                              szDeviceID,
                                                              pNewDriverInfoDetailData->InfFileName,
                                                              0,
                                                              &bRebootFlag) )
                    {
                        SetupDebugPrint1(L"SETUP:     Failed to install updated driver. Error = %d", GetLastError());
                        bRet = FALSE;
                    }
                }

                //
                // Free this if allocated.
                //
                if ( pNewDriverInfoDetailData )
                {
                    HeapFree(GetProcessHeap(), 0, pNewDriverInfoDetailData);
                }

            }

            //
            // Make sure we clean up the list.
            //
            SetupDiDestroyDeviceInfoList(NewDeviceInfoSet);
        }

        //
        // Make sure we clean up the list.
        //
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }

    FreeLibrary(hInstNewDev);

    return bRet;
}


VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount,
    OUT    PULONG LastBatchedDetect
    )
/*++

Routine Description:

        This routine sorts the supplied list of GUID based on a (partial)
        ordering specified in the [DetectionOrder] and [NonBatchedDetection]
        sections of syssetup.inf.  This allows us to maintain a detection
        ordering similar to previous versions of NT, and also to allow for
        class installers that may depend upon the successful installation of
        devices detected by other class installers.

Arguments:

        GuidList - address of the array of GUIDs to be sorted.

        GuidCount - the number of GUIDs in the array.  This number must be > 0.

        LastBatchedDetect - Supplies the address of a variable that will
            receive the index of the last GUID in the array that may be batched
            together (i.e., all detections are run, all files queued into one
            big queue, etc.).  Any GUIDs existing at higher indices must be
            processed individually, and such processing will happen _after_ the
            batched detection is completed.

Return Value:

        none.

--*/
{
    LONG LineCount, LineIndex, GuidIndex, NextTopmost;
    PCWSTR CurGuidString;
    INFCONTEXT InfContext;
    GUID CurGuid;

    MYASSERT(GuidCount > 0);

    *LastBatchedDetect = GuidCount - 1;

    //
    // First, sort the classes in syssetup.inf's [DetectionOrder] list to the
    // front...
    //
    LineCount = SetupGetLineCount(SyssetupInf, L"DetectionOrder");
    NextTopmost = 0;

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"DetectionOrder", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString(CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move the GUID from
        // it's current position to the next topmost position.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {

                if(NextTopmost != GuidIndex) {
                    //
                    // We should never be moving the GUID _down_ the list.
                    //
                    MYASSERT(NextTopmost < GuidIndex);

                    MoveMemory(&(GuidList[NextTopmost + 1]),
                               &(GuidList[NextTopmost]),
                               (GuidIndex - NextTopmost) * sizeof(GUID)
                              );

                    CopyMemory(&(GuidList[NextTopmost]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                NextTopmost++;
                break;
            }
        }
    }

    //
    // Now, move any classes in syssetup.inf's [NonBatchedDetection] list to
    // the end...
    //
    LineCount = SetupGetLineCount(SyssetupInf, L"NonBatchedDetection");

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"NonBatchedDetection", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString(CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move
        // the GUID from it's current position to the end of the list.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {
                //
                // We found a non-batched class--decrement our index that
                // points to the last batched detection class.
                //
                (*LastBatchedDetect)--;

                //
                // Now shift all the GUIDs after this one up, and move this one
                // to the last position in the array (unless, of course, it was
                // already at the last position in the array).
                //
                if(GuidIndex < (LONG)(GuidCount - 1)) {

                    MoveMemory(&(GuidList[GuidIndex]),
                               &(GuidList[GuidIndex+1]),
                               (GuidCount - (GuidIndex+1)) * sizeof(GUID)
                              );
                    CopyMemory(&(GuidList[GuidCount-1]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                break;
            }
        }
    }
}


DWORD
pPhase1InstallPnpLegacyDevicesThread(
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread does the initial part of the installation installation
    of legacy Pnp devices of a particular class.

    It invokes a class installer of a particular class with:

            - DIF_FIRSTTIMESETUP

    If it successds, it returns in the structure passed as argument
    a device info list that contains the detected legacy devices.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns a Win32 error code.

--*/

{
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS Context;

    LPGUID                pGuid;
    PWSTR                 pClassDescription;

    HDEVINFO              hEmptyDevInfo;
    ULONG                 Error;

    //
    //  Initialize variables
    //
    Context = ThreadParams;
    Context->hDevInfo = INVALID_HANDLE_VALUE;
    pGuid = &(Context->Guid);
    pClassDescription = Context->pClassDescription;

    //
    //  Assume success
    //
    Error = ERROR_SUCCESS;

    //
    //  DIF_FIRSTTIME
    //
    if((hEmptyDevInfo = SetupDiCreateDeviceInfoList(pGuid,
                                                    Context->hwndParent))
                    == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP:     SetupDiCreateDeviceInfoList() failed (phase1). Error = %d, ClassDescription = %ls", Error, pClassDescription );
        goto phase1_legacy_dev_thread_exit;
    }

    if( !SetupDiCallClassInstaller( DIF_FIRSTTIMESETUP,
                                    hEmptyDevInfo,
                                    NULL ) ) {

        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) failed (phase1). Error = %lx, ClassDescription = %ls", Error, pClassDescription );
        } else {
            SetupDebugPrint2( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) failed (phase1). Error = %lx, ClassDescription = %ls", Error, pClassDescription );
        }
        SetupDiDestroyDeviceInfoList(hEmptyDevInfo);
        goto phase1_legacy_dev_thread_exit;
    }
    //
    //  Save the info set after DIF_FIRSTTIMESETUP
    //
    Context->hDevInfo = hEmptyDevInfo;
    SetupDebugPrint1( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) succeeded (phase1). ClassDescription = %ls", pClassDescription );

phase1_legacy_dev_thread_exit:
    return(Error);
}


DWORD
pPhase2InstallPnpLegacyDevicesThread(
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread does a partial installation of a legacy device.
    It invokes a class installer with:

            - DIF_REGISTERDEVICE
            - DIF_ALLOW_INSTALL
            - DIF_INSTALLDEVICEFILES

    Note that the call with DIF_INSTALLDEVICEFILES only queue the files on the queue
    created by the parent of this handle.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns TRUE is all calls to the class installer were successfull.
    Otherwise, returns FALSE.

--*/

{
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS Context;

    HDEVINFO              hDevInfo;
    HSPFILEQ              FileQ;
    HSPFILEQ              TempFileQ = INVALID_HANDLE_VALUE;
    PSP_DEVINFO_DATA      pDeviceInfoData;
    PWSTR                 pClassDescription;
    PWSTR                 pDeviceId;

    BOOL                  b;
    ULONG                 Error;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD                 ScanQueueResult;

    //
    //  Initialize variables
    //
    Context = ThreadParams;
    hDevInfo = Context->hDevInfo;
    FileQ = Context->FileQ;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pClassDescription = Context->pClassDescription;
    pDeviceId = Context->pDeviceId;

    //
    //  Assume success
    //
    Error = ERROR_SUCCESS;
    b = TRUE;

    //
    // Let the class installer/co-installers know they should be quiet.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiGetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    DeviceInstallParams.Flags |= DI_QUIETINSTALL;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    //  Register the device
    //
    if( !SetupDiCallClassInstaller( DIF_REGISTERDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {

        SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_REGISTERDEVICE) failed (phase2). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Verify with the class installer and class-specific co-installers that the
    // driver we're about to install isn't blacklisted.
    //
    if( !SetupDiCallClassInstaller( DIF_ALLOW_INSTALL,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {
        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) failed (phase2). Error = %d, DeviceId = %ls", Error, pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }
    }

    //
    // In general, any devices being installed as a result of DIF_FIRSTTIMESETUP
    // will be using in-box drivers, and as such, will be signed.  However, it
    // is possible that a built-in class installer will report a detected device
    // that's using a 3rd-party, unsigned driver.  The ScsiAdapter class is such
    // a case.  If we _do_ encounter unsigned driver packages, we want to avoid
    // media prompting, just like we do when installing PnP-enumerated devices.
    // Unfortunately, this is complicated in the legacy case by the fact that we
    // queue all files into one big queue, then commit the queue in an all-or-
    // nothing fashion.  Thus, we don't have the same granularity that we have
    // when installing PnP-enumerated devices in a one-at-a-time fashion.
    //
    // To address this, we will first queue up all files to a "temporary" queue,
    // which we will then examine in a similar fashion to the way we handle the
    // per-device queues for PnP-enumerated devices.  If the catalog nodes
    // associated with the queue are all signed, then we'll queue up those same
    // files to our "real" queue.  If one or more catalog nodes are not signed,
    // we'll then do a queue scan based on presence checking.  If all files
    // required are present, then we'll add nothing to the "real" queue, but
    // allow the device to be subsequently installed.  If one or more required
    // files are found to be missing, we're in a bad state, because queueing
    // these files up to our "real" queue means the user will (potentially) see
    // a driver signing warning popup and/or media prompt, either of which they
    // may cancel out of.  Since the legacy device install queue is one big
    // queue containing fileops for all such device installs, cancelling its
    // committal would result in none of the files being copied for any phase2
    // install.  Thus, multimedia codecs, non-motherboard legacy COM ports, and
    // other (signed) system devices wouldn't get installed.  Since this is
    // obviously unacceptable, we instead simply skip installation for this
    // device, just as if DIF_ALLOWINSTALL had failed.  This isn't as bad as it
    // sounds, because it would be _exceedingly_ rare if a 3rd-party driver's
    // device were reported, yet all necessary files weren't present.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiGetDeviceInstallParams() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Note: this code has had the following comment (and behavior) for a _long_
    // time...
    //
    //     "we may rely on this flag being set this early"
    //
    // The DI_FORCECOPY flag actually has no effect on any setupapi activity
    // except for installation of class installer files via
    // SetupDiInstallClass(Ex).  However, it's possible some class-/co-installer
    // has developed a dependency on its presence, and since it doesn't hurt
    // anything, we'll continue to set it.
    //
    DeviceInstallParams.Flags |= DI_FORCECOPY;

    TempFileQ = SetupOpenFileQueue();
    if(TempFileQ == INVALID_HANDLE_VALUE) {
        SetupDebugPrint2( L"SETUP:         SetupOpenFileQueue() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    DeviceInstallParams.Flags |= DI_NOVCP;
    DeviceInstallParams.FileQueue = TempFileQ;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    //  Queue the device files into our temporary file queue
    //
    if(SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                 hDevInfo,
                                 pDeviceInfoData)) {
        Error = ERROR_SUCCESS;

    } else {

        Error = GetLastError();

        if(Error == ERROR_DI_DO_DEFAULT) {
            //
            // This isn't actually an error
            //
            Error = ERROR_SUCCESS;
        } else {
            SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed for TempFileQueue (phase2). Error = %lx, DeviceId = %ls", Error, pDeviceId );
        }
    }

    //
    // Disassociate the temporary file queue from the device information
    // element so that we can free it later...
    //
    DeviceInstallParams.Flags &= ~DI_NOVCP;
    DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed for disassociating TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    if(Error == ERROR_SUCCESS) {
        SetupDebugPrint1( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) suceeded for TempFileQueue (phase2). DeviceId = %ls", pDeviceId );
    } else {
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Now that we've retrieved all files operations into our temporary file
    // queue, we can "pre-verify" the catalog nodes in the queue.  If an OEM
    // INF in %windir%\Inf is unsigned, we scan the queue to see if all
    // required files are present (although not validated) in their target
    // locations.  If we're doing an upgrade, and all files are in-place, we'll
    // forego queue committal.  If we're doing a fresh-install, and all files
    // are in-place, we'll commit the empty queue on-the-spot, so that the user
    // will get the driver signing popup (based on policy), thus may
    // potentially abort the installation of this device.  If all files aren't
    // already in-place, we silently abort the device installation, as we can't
    // run the risk of queueing up potentially-cancellable fileops to the
    // "real" legacy device install queue.
    //
    if(NO_ERROR != pSetupVerifyQueuedCatalogs(TempFileQ)) {
        //
        // We only want to prune based on presence check for OEM INFs living in
        // %windir%\Inf.
        //
        SP_DRVINFO_DATA        DriverInfoData;
        SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;

        //
        // Retrieve the name of the INF associated with the selected driver
        // node.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if(!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
            SetupDebugPrint2( L"SETUP:         SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                       pDeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInfoDetailData,
                                       sizeof(DriverInfoDetailData),
                                       NULL) &&
           (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {

            SetupDebugPrint2( L"SETUP:         SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        if(pSetupInfIsFromOemLocation(DriverInfoDetailData.InfFileName, TRUE) ||
           IsInfInLayoutInf(DriverInfoDetailData.InfFileName)) {
            //
            // Either the INF lives somewhere other than %windir%\Inf, or its
            // an in-box unsigned INF.  In either case, we want to
            // abort installation of this device, otherwise we risk having the
            // user cancel the queue committal, and wipe out all the other
            // detected device installs as well.
            //
            SetupDebugPrint2( L"SETUP:         Skipping unsigned driver install for detected device (phase2). DeviceId = %ls, Inf = %ls", pDeviceId, DriverInfoDetailData.InfFileName );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;

        } else {
            //
            // Note: it doesn't really matter whether we do an "all-or-nothing"
            // scan or a pruning scan here, because we're going to abort the
            // install on anything other than a fully empty (post-scan) queue.
            // We request pruning here, because that fits better with the
            // semantics of SPQ_SCAN_PRUNE_DELREN (this flag's semantics
            // don't really fit with a non-pruning scan, as discussed in RAID
            // #280543).
            //
            if(!SetupScanFileQueue(TempFileQ,
                                   SPQ_SCAN_FILE_PRESENCE |
                                   SPQ_SCAN_PRUNE_COPY_QUEUE |
                                   SPQ_SCAN_PRUNE_DELREN,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &ScanQueueResult)) {
                //
                // SetupScanFileQueue failed for some reason (rare).  We'll
                // just commit the whole file queue...
                //
                ScanQueueResult = 0;
            }

            if(ScanQueueResult != 1) {
                //
                // Abort installation of this device, otherwise we risk having
                // the user cancel the queue committal, and wipe out all the
                // other detected device installs as well.
                //
                SetupDebugPrint1( L"SETUP:         Skipping unsigned driver install for detected device due to missing files (phase2). DeviceId = %ls", pDeviceId );
                b = FALSE;
                goto phase2_legacy_dev_thread_exit;
            }

            if(!Upgrade) {

                PVOID QCBContext;

                //
                // No fileops left in queue, but we're doing a fresh install,
                // so we still want to give user driver signing popup (logging
                // the event to setupapi.log), and let them potentially abort
                // the unsigned installation...
                //
                QCBContext = InitSysSetupQueueCallbackEx(
                                 DeviceInstallParams.hwndParent,
                                 INVALID_HANDLE_VALUE,
                                 0,
                                 0,
                                 NULL
                                );

                if(!QCBContext) {
                    SetupDebugPrint1( L"SETUP:         Failed to allocate queue callback context (phase2). DeviceId = %ls", pDeviceId );
                    b = FALSE;
                    goto phase2_legacy_dev_thread_exit;
                }

                if(!SetupCommitFileQueue(DeviceInstallParams.hwndParent,
                                         TempFileQ,
                                         SysSetupQueueCallback,
                                         QCBContext)) {
                    //
                    // User elected not to proceed with the unsigned installation.
                    //
                    SetupDebugPrint2( L"SETUP:         SetupCommitFileQueue() failed (phase2). Error = %d, Device = %ls", GetLastError(), pDeviceId );
                    b = FALSE;
                }

                TermSysSetupQueueCallback(QCBContext);

                if(!b) {
                    goto phase2_legacy_dev_thread_exit;
                }
            }
        }

    } else {
        //
        // Queue the files to be copied for this device to the "real" file queue
        //
        if( FileQ != INVALID_HANDLE_VALUE ) {
            DeviceInstallParams.Flags |= DI_NOVCP;
            DeviceInstallParams.FileQueue = FileQ;
        }

        if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
            SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        //
        //  Install the device files (queue the files)
        //
        Error = ERROR_SUCCESS;
        if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICEFILES,
                                        hDevInfo,
                                        pDeviceInfoData ) &&
            ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
          ) {

            SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed (phase2). Error = %lx, DeviceId = %ls", Error, pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }
        SetupDebugPrint1( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) suceeded (phase2). DeviceId = %ls", pDeviceId );
    }

    //
    //  Mark the device as 'Do install'
    //
    if( !pSetupDiSetDeviceInfoContext( hDevInfo, pDeviceInfoData, TRUE ) ) {
        SetupDebugPrint2( L"SETUP:         pSetupDiSetDeviceInfoContext() failed (phase2). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

phase2_legacy_dev_thread_exit:

    if(TempFileQ != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(TempFileQ);
    }

    return(b);
}


BOOL
CheckIfDeviceHasWizardPages( HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:

    This routine invokes the class installer with
    DIF_NEWDEVICEWIZARD_FINISHINSTALL to determine if the device has wizard
    pages to display.

Arguments:

    hDevInfo - The device info set.
    pDeviceInfoData - The device that needs to be marked

Return Value:

    Returns TRUE if the device has FINISHINSTALL wizard pages, FALSE otherwise
--*/

{
    SP_NEWDEVICEWIZARD_DATA ndwd = {0};
    BOOL                    b;

    // Check if this device has wizard pages that need to be shown as
    // part of the install.  If so, we will mark the device as
    // nneding a reinstall so the UI can be display later
    //

    ndwd.ClassInstallHeader.cbSize = sizeof( SP_CLASSINSTALL_HEADER );
    ndwd.ClassInstallHeader.InstallFunction = DIF_NEWDEVICEWIZARD_FINISHINSTALL;

    // Set the install params for the function
    b = SetupDiSetClassInstallParams( hDevInfo, pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER) ( &ndwd ),
                                        sizeof( ndwd ) );
    if ( b ) {

        // Invoke the class installer (and co-installers)
        b = SetupDiCallClassInstaller( DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                         hDevInfo,
                                         pDeviceInfoData );
        if ( b || (ERROR_DI_DO_DEFAULT == GetLastError())) {

            // Retrieve the install params
            b = SetupDiGetClassInstallParams( hDevInfo,
                                                pDeviceInfoData,
                                                (PSP_CLASSINSTALL_HEADER)&ndwd,
                                                sizeof(ndwd),
                                                NULL );
            if ( b ) {

                // Are there any pages?
                if ( 0 == ndwd.NumDynamicPages ) {
                    b = FALSE;
                }
                else {
                    // b is already TRUE if we made it here so no need to set
                    UINT i;

                    // We don't need the pages so destroy them
                    for ( i = 0; i < ndwd.NumDynamicPages; i++ ) {
                        DestroyPropertySheetPage( ndwd.DynamicPages[i] );
                    }
                }
            }
            else {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassInstallParams failed (phase3). Error = %lx", GetLastError() );
            }
        }
        else if ( ERROR_DI_DO_DEFAULT != GetLastError() ) {
            SetupDebugPrint1( L"SETUP: SetupDiCallClassInstaller(DIF_NEWDEVICEWIZARD_FINISHINSTALL) failed (phase3). Error = %lx", GetLastError() );
        }
    }
    else {
        SetupDebugPrint1( L"SETUP: SetupDiSetClassInstallParams failed. Error = %lx", GetLastError() );
    }

    return b;
}

BOOL
MarkDeviceAsNeedsReinstallIfNeeded(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:

    This function checks if a device has wizard pages
    (DIF_NEWDEVICEWIZARD_FINISHINSTALL pages) and sets the REINSTALL
    config flag if it does.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will set.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/
{
    DWORD ConfigFlags;
    BOOL b = TRUE;

    if (CheckIfDeviceHasWizardPages( hDevInfo, pDeviceInfoData ) ) {

        SetupDebugPrint( L"SETUP: Device has wizard pages, marking as need reinstall." );

        //
        // Get the config flags for the device and set the reinstall bit
        //
        if ( !( b = GetDeviceConfigFlags(hDevInfo, pDeviceInfoData, &ConfigFlags ) ) ) {
            SetupDebugPrint( L"SETUP:   GetDeviceConfigFlags failed. " );
        }

        if ( b ) {

            ConfigFlags |= CONFIGFLAG_REINSTALL;

            if ( !( b = SetDeviceConfigFlags(hDevInfo, pDeviceInfoData, ConfigFlags ) ) ) {

                SetupDebugPrint( L"SETUP:   SetDeviceConfigFlags failed. " );
            }
        }
    }

    return b;
}

DWORD
pPhase3InstallPnpLegacyDevicesThread(
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread completes the installation of a legacy device.
    It invokes a class installer with:

            - DIF_REGISTER_COINSTALLERS
            - DIF_INSTALLINTERFACES
            - DIF_INSTALLDEVICE

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns TRUE if all calls to the class installer were successfull.
    Otherwise, returns FALSE.

--*/

{
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS Context;

    HDEVINFO                hDevInfo;
    PSP_DEVINFO_DATA        pDeviceInfoData;
    SP_DEVINSTALL_PARAMS    DeviceInstallParams;
    PWSTR                   pDeviceId;

    BOOL                    b;
    WCHAR                   DeviceDescription[MAX_PATH];
    DWORD                   Status;
    DWORD                   Problem;
    BOOL                    fNewDevice = FALSE;
    PVOID                   DevicesInstalledStringTable;


    Context = ThreadParams;
    hDevInfo = Context->hDevInfo;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pDeviceId = Context->pDeviceId;
    DevicesInstalledStringTable = Context->DevicesInstalledStringTable;

    b = TRUE;

    //
    // Register any device-specific co-installers for this device.
    //
    if( !SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS, hDevInfo, pDeviceInfoData ) ) {
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) failed (phase3). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    }

    //
    // Install any INF/class installer-specified interfaces.
    //
    if( !SetupDiCallClassInstaller(DIF_INSTALLINTERFACES, hDevInfo, pDeviceInfoData) ) {
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_INSTALLINTERFACES) failed (phase3). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    }

    //
    // Before we install this device, we need to find out if it is a new
    // device or a reinstall.  If the problem CM_PROB_NOT_CONFIGURED is set
    // then we will consider it as a new device and check if it has wizard
    // pages after DIF_INSTALLDEVICE
    //
    if ( CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                             &Problem,
                                             (DEVINST)pDeviceInfoData->DevInst,
                                             0 ) && (Problem & CM_PROB_NOT_CONFIGURED) )
    {
        fNewDevice = TRUE;
    }

    //
    // Set the DI_FLAGSEX_RESTART_DEVICE_ONLY for legacy device installs. This
    // flag tells setupapi to only stop/start this one device and not all
    // devices that share the same drivers with this device.
    //
    // This is not critical if this fails since by default setupapi will just
    // stop/start all devices that share drivers with this device, including
    // the device itself. This can cause stop/start to take a little longer
    // if there are lots of devices sharing drivers with this device.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {

        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;

        SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams);
    }

    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed (phase3). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    } else {
        //
        // If we have been passed a string table then add the device instance Id
        // to the string table of devices that have been successfully installed.
        if (DevicesInstalledStringTable) {
            if (pSetupStringTableAddString(DevicesInstalledStringTable, pDeviceId, STRTAB_CASE_INSENSITIVE) == -1) {
                SetupDebugPrint1( L"SETUP:            ERROR: failed to add Legacy Device = %ls to the string table!", pDeviceId );
            }
        }
    }

    DeviceDescription[0] = L'\0';
    if( !SetupDiGetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_DEVICEDESC,
                                           NULL,
                                           (PBYTE)DeviceDescription,
                                           sizeof( DeviceDescription ),
                                           NULL ) ) {
        SetupDebugPrint2( L"SETUP:       SetupDiGetDeviceRegistryProperty() failed. Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
    }
    SetupDebugPrint2( L"SETUP: Device installed. DeviceId = %ls, Description = %ls", pDeviceId, DeviceDescription );


    //
    // If the device has wizard pages to show (in response to
    // DIF_NEWDEVICEWIZARD_FINISHINSTALL) then it needs to be marked as need
    // reinstall so that pages get a chance to be shown at a later time
    //
    if ( fNewDevice ) {
        b = MarkDeviceAsNeedsReinstallIfNeeded( hDevInfo, pDeviceInfoData);
    }


phase3_legacy_dev_thread_exit:
    return( b );
}


BOOL
GetDeviceConfigFlags(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDeviceInfoData,
                     DWORD* pdwConfigFlags)
/*++

Routine Description:

    This function gets the configflags of a device.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will be retrieved.
    pdwConfigFlags  - The buffer that will receive the current flags.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/
{
    BOOL    b = TRUE;
    DWORD   Error;

    //
    // Clear the output parameter
    //
    *pdwConfigFlags = 0;

    // Get the config flags for the device
    if( !SetupDiGetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_CONFIGFLAGS,
                                           NULL,
                                           (PBYTE)pdwConfigFlags,
                                           sizeof( *pdwConfigFlags ),
                                           NULL ) ) {
        Error = GetLastError();
        //
        //  ERROR_INVALID_DATA is ok. It means that the device doesn't have config flags set yet.
        //
        if( Error != ERROR_INVALID_DATA ) {
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Error = %d", Error );
            }
            b = FALSE;
        }
    }

    return b;
}

BOOL
SetDeviceConfigFlags(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDeviceInfoData,
                     DWORD dwConfigFlags)
/*++

Routine Description:

    This function sets the configflags of a device.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will set.
    dwConfigFlags   - The config flags to set.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/

{
    BOOL    b = TRUE;
    DWORD   Error;

    if( !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_CONFIGFLAGS,
                                           (PBYTE)&dwConfigFlags,
                                           sizeof( dwConfigFlags ) ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Error = %d", Error );
        }
        b = FALSE;
    }

    return b;
}


DWORD
pInstallPnpEnumeratedDeviceThread(
    PPNP_ENUM_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This is the thread that does the installation of an enumerated PnP device.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns a Win32 error code.

--*/

{
    PPNP_ENUM_DEV_THREAD_PARAMS Context;
    HDEVINFO                    hDevInfo;
    PSP_DEVINFO_DATA            pDeviceInfoData;
    PSP_DEVINSTALL_PARAMS       pDeviceInstallParams;
    PWSTR                       pDeviceDescription;
    PWSTR                       pDeviceId;
    ULONG                       Error;
    WCHAR                       RootPath[ MAX_PATH + 1];
    SP_DEVINSTALL_PARAMS        DeviceInstallParams;
    DWORD                       Status;
    DWORD                       Problem;
    BOOL                        fNewDevice = FALSE;
    HSPFILEQ                    FileQ;
    PVOID                       QContext;
    HSPFILEQ                    SavedFileQ;
    DWORD                       SavedFlags;
    DWORD                       ScanQueueResult;
    HWND                        hwndParent;
    SP_DRVINFO_DATA             pDriverInfoData;
    HKEY                        hClassKey;
    WCHAR                       InfPath[MAX_PATH];
    BOOL                        fCommitFileQueue = TRUE;
    BOOL                        fDriversChanged = FALSE;
    DWORD                       FileQueueFlags;
    PVOID                       DevicesInstalledStringTable;

    Context = ThreadParams;

    hDevInfo = Context->hDevInfo;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pDeviceInstallParams = &DeviceInstallParams;
    pDeviceDescription = Context->pDeviceDescription;
    pDeviceId = Context->pDeviceId;
    DevicesInstalledStringTable = Context->DevicesInstalledStringTable;
    InfPath[0] = TEXT('\0');

    Error = ERROR_SUCCESS;

    //
    // Queue all files to be copied into our own file queue.
    //
    FileQ = SetupOpenFileQueue();

    if ( FileQ == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupOpenFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    pDeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // Let the class installer/co-installers know that they should be quiet
    //
    pDeviceInstallParams->Flags |= DI_QUIETINSTALL;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // Install the class if it does not exist.
    //
    if (CM_Open_Class_Key(&pDeviceInfoData->ClassGuid,
                          NULL,
                          KEY_READ,
                          RegDisposition_OpenExisting,
                          &hClassKey,
                          CM_OPEN_CLASS_KEY_INSTALLER
                          ) != CR_SUCCESS) {

        HSPFILEQ                    ClassFileQ;
        PVOID                       ClassQContext;
        SP_DRVINFO_DETAIL_DATA      DriverInfoDetailData;

        ClassFileQ = SetupOpenFileQueue();

        if ( ClassFileQ == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupOpenFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // First, we have to retrieve the name of the INF associated with the
        // selected driver node.
        //
        pDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &pDriverInfoData)) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                 pDeviceInfoData,
                                 &pDriverInfoData,
                                 &DriverInfoDetailData,
                                 sizeof(DriverInfoDetailData),
                                 NULL) &&
            (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {

            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        if (!SetupDiInstallClass(NULL,
                                 DriverInfoDetailData.InfFileName,
                                 DI_NOVCP | DI_FORCECOPY,
                                 ClassFileQ)) {

            Error = GetLastError();
            SetupDebugPrint3( L"SETUP: SetupDiInstallClass(%s) failed. Error = %d, Device = %ls", DriverInfoDetailData.InfFileName, Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // Commit the file queue.
        //
        ClassQContext = InitSysSetupQueueCallbackEx(
            NULL,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

        if( ClassQContext == NULL) {
            Error = GetLastError();
            SetupDebugPrint1( L"SETUP: InitSysSetupQueueCallbackEx() failed. Error = %d", Error );
            goto enum_dev_thread_exit;
        }

        if (!SetupCommitFileQueue(
                        NULL,
                        ClassFileQ,
                        SysSetupQueueCallback,
                        ClassQContext
                        )) {
            Error = GetLastError();
        }

        TermSysSetupQueueCallback(ClassQContext);

        if ( ClassFileQ != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
            SetupCloseFileQueue( ClassFileQ );
        }

        if (Error == NO_ERROR) {
            SetupDebugPrint1( L"SETUP:            SetupDiInstallClass() succeeded. Device = %ls", pDeviceDescription );
        } else {
            //
            // We failed while installing the class so don't bother installing
            // the device.
            //
            SetupDebugPrint3( L"SETUP: SetupCommitFileQueue(%s) failed while installing Class. Error = %d, Device = %ls", DriverInfoDetailData.InfFileName, Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

    } else {

        //
        // The class already exists.
        //
        RegCloseKey(hClassKey);
    }

    //
    // Verify with the class installer and class-specific co-installers that the
    // driver we're about to install isn't blacklisted.
    //
    if( !SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   hDevInfo,
                                   pDeviceInfoData ) ) {
        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) succeeded. Device = %ls", pDeviceDescription );

    //
    // Everything checks out.  We're ready to pre-copy the driver files for this device.
    //
    pDeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    pDeviceInstallParams->Flags |= DI_FORCECOPY;

    SavedFileQ = pDeviceInstallParams->FileQueue;
    SavedFlags = pDeviceInstallParams->Flags;

    pDeviceInstallParams->FileQueue = FileQ;
    pDeviceInstallParams->Flags |= DI_NOVCP;

    //
    // If the old, or existing, driver is an 3rd party driver and not the same
    // as the current driver we are about to install, then back up the existing
    // drivers.
    //
    if (pDoesExistingDriverNeedBackup(hDevInfo, pDeviceInfoData, InfPath, sizeof(InfPath)/sizeof(WCHAR))) {
        SetupDebugPrint1( L"SETUP:            Backing up 3rd party drivers for Device = %ls", pDeviceDescription );
        pDeviceInstallParams->FlagsEx |= DI_FLAGSEX_PREINSTALLBACKUP;
    }

    //
    // Remember the parent HWND because we may need it later...
    //
    hwndParent = pDeviceInstallParams->hwndParent;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    //  Install the device files
    //
    Error = ERROR_SUCCESS;
    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICEFILES,
                                    hDevInfo,
                                    pDeviceInfoData ) &&
        ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
      ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed. Error = %lx, Device = %ls ", Error, pDeviceDescription );
        goto enum_dev_thread_exit;

    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) succeeded. Device = %ls", pDeviceDescription );

    //
    // Commit the file queue.
    //
    QContext = InitSysSetupQueueCallbackEx(
        NULL,
        INVALID_HANDLE_VALUE,
        0,0,NULL);

    //
    // "Pre-verify" the catalog nodes in the file queue.  If an OEM INF in
    // %windir%\Inf is unsigned, we scan the queue to see if all required files
    // are present (although not validated) in their target locations.  If
    // we're doing an upgrade, and all files are in-place, we'll forego queue
    // committal.  If we're doing a fresh install, we'll still commit the
    // queue, even if all files were present.  This will result in a driver
    // signing popup (based on policy).  We do this to prevent subversion of
    // driver signing due to someone "sneaking" all the files into place prior
    // to GUI setup.
    //
    if(NO_ERROR != pSetupVerifyQueuedCatalogs(FileQ)) {
        //
        // We only want to prune based on presence check for OEM INFs living in
        // %windir%\Inf.
        //
        SP_DRVINFO_DETAIL_DATA      DriverInfoDetailData;

        //
        // Retrieve the name of the INF associated with the selected driver
        // node.
        //
        pDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &pDriverInfoData)) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDeviceInfoData,
                                        &pDriverInfoData,
                                        &DriverInfoDetailData,
                                        sizeof(DriverInfoDetailData),
                                        NULL) &&
            ((Error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)) {

            SetupDebugPrint2( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // There is only one case where we want to skip commiting the file queue
        // for an unsigned drivers, and all of the following must be true:
        //
        //  - This is an upgrade.
        //  - The INF lives under %windir%\INF
        //  - The INF is NOT an in-box INF
        //  - The INF has the same name as the previous INF (if there was
        //    a previous INF)
        //  - No file copy operations (copy, delete, rename) need to be done.
        //
        if(Upgrade &&
           !pSetupInfIsFromOemLocation(DriverInfoDetailData.InfFileName, TRUE) &&
           !IsInfInLayoutInf(DriverInfoDetailData.InfFileName) &&
           ((InfPath[0] == TEXT('\0')) ||
            (lstrcmpi(InfPath, pSetupGetFileTitle(DriverInfoDetailData.InfFileName)) == 0)) &&
           SetupScanFileQueue(FileQ,
                              SPQ_SCAN_FILE_PRESENCE |
                              SPQ_SCAN_PRUNE_DELREN,
                              hwndParent,
                              NULL,
                              NULL,
                              &ScanQueueResult) &&
           (ScanQueueResult == 1)) {

            fCommitFileQueue = FALSE;
        }

    } else {
        //
        // Prun the file queue.
        //
        SetupScanFileQueue(FileQ,
                           SPQ_SCAN_FILE_VALIDITY |
                           SPQ_SCAN_PRUNE_COPY_QUEUE |
                           SPQ_SCAN_PRUNE_DELREN,
                           NULL,
                           NULL,
                           NULL,
                           &ScanQueueResult);
    }

    //
    // If this device is the computer itself (i.e., the HAL, kernel, and other
    // platform-specific files), then we shouldn't need to copy anything, since
    // all the right files were copied during textmode setup.  However, these
    // files will _not_ have been pruned from the file queue if they came from
    // HAL.INF because they're marked as COPYFLG_NOPRUNE in that INF.  This is
    // done so that doing an "update driver" from a UP HAL to an MP one works
    // properly.  (Pruning gets in the way here, since we consider the properly-
    // signed UP files on the system to be perfectly acceptable, thus don't
    // bother with copying over the MP versions.)
    //
    // In order to avoid re-copying the HAL, kernel, etc., we just always skip
    // this queue committal if the device is of class "Computer".
    //
    if(IsEqualGUID(&(pDeviceInfoData->ClassGuid), &GUID_DEVCLASS_COMPUTER)) {
        fCommitFileQueue = FALSE;
    }

    Error = ERROR_SUCCESS;

    if (fCommitFileQueue) {
        if (!SetupCommitFileQueue(
                    NULL,
                    FileQ,
                    SysSetupQueueCallback,
                    QContext
                    )) {
            Error = GetLastError();
        }
    }

    if (SetupGetFileQueueFlags(FileQ, &FileQueueFlags) &&
        (FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
        //
        // One of the driver files has changed for this device.  This means
        // a full restart of the device, and all other devices shareing
        // one of its drivers is in order.
        //
        fDriversChanged = TRUE;
    }

    TermSysSetupQueueCallback(QContext);

    if (Error != ERROR_SUCCESS) {
        SetupDebugPrint2( L"SETUP: SetupCommitFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // If no driver files changed then we only need to restart this device.
    //
    if (!fDriversChanged) {
        pDeviceInstallParams->FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
    }

    pDeviceInstallParams->FileQueue = SavedFileQ;
    pDeviceInstallParams->Flags = (SavedFlags | DI_NOFILECOPY) ;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    //  Make sure that the files get flushed to disk
    //
    GetWindowsDirectory(RootPath,sizeof(RootPath)/sizeof(WCHAR));
    RootPath[3] = L'\0';
    FlushFilesToDisk( RootPath );

    //
    // Register any device-specific co-installers for this device.
    //
    if( !SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   hDevInfo,
                                   pDeviceInfoData ) ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) succeeded. Device = %ls", pDeviceDescription );

    //
    // Install any INF/class installer-specified interfaces.
    //
    if( !SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                   hDevInfo,
                                   pDeviceInfoData) ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_INSTALLINTERFACES) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLINTERFACES) succeeded. Device = %ls", pDeviceDescription );


    //
    // Before we install this device, we need to find out if it is a new
    // device or a reinstall.  If the problem CM_PROB_NOT_CONFIGURED is set
    // then we will consider it as a new device and check if it has wizard
    // pages after DIF_INSTALLDEVICE
    //
    if ( CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                             &Problem,
                                             (DEVINST)pDeviceInfoData->DevInst,
                                             0 ) && (Problem & CM_PROB_NOT_CONFIGURED) )
    {
        fNewDevice = TRUE;
    }

    //
    //  Install the device
    //
    Error = ERROR_SUCCESS;
    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) &&
        ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
      ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %lx, Device = %ls ", Error, pDeviceDescription );
        goto enum_dev_thread_exit;

    } else {
        //
        // If we have been passed a string table then add the device instance Id
        // to the string table of devices that have been successfully installed.
        if (DevicesInstalledStringTable) {
            if (pSetupStringTableAddString(DevicesInstalledStringTable, pDeviceId, STRTAB_CASE_INSENSITIVE) == -1) {
                SetupDebugPrint1( L"SETUP:            ERROR: failed to add PnP Device = %ls to the string table!", pDeviceId );
            }
        }

        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) suceeded. Device = %ls ", pDeviceDescription );
    }

    //
    // If the device has wizard pages to show (in response to
    // DIF_NEWDEVICEWIZARD_FINISHINSTALL) then it needs to be marked as need
    // reinstall so that pages get a chance to be shown at a later time
    // note that we have to do this even for a re-install
    //
    if (!MarkDeviceAsNeedsReinstallIfNeeded( hDevInfo, pDeviceInfoData) ) {
        Error = GetLastError();
    }


enum_dev_thread_exit:
    if ( FileQ != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        if(SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {

            pDeviceInstallParams->FileQueue = INVALID_HANDLE_VALUE;
            pDeviceInstallParams->Flags &= ~DI_NOVCP;

            SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams);
        }

        SetupCloseFileQueue( FileQ );
    }

    if (Error != ERROR_SUCCESS) {
        //
        // Device installed failed, so install the NULL driver on this device.
        //
        SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

        if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData, DevicesInstalledStringTable ) ) {
            SetupDebugPrint( L"SETUP:            Unable to install null driver" );
        }
    }

    return( Error );
}


BOOL
MarkPnpDevicesAsNeedReinstall(
    PVOID DevicesInstalledStringTable OPTIONAL
    )

/*++

Routine Description:

    This function marks all non-present Pnp devices as 'need reinstall'.

Arguments:

    DevicesInstalledStringTable - If present, a string table that contains all
                                  the device instance Ids of successfully 
                                  installed devices.  If a device was 
                                  successfully installed then it should NOT be
                                  marked as needing a reinstall.
    
Return Value:

    Returns TRUE if the null if all devices were marked successfull.

--*/

{
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    ULONG           Index = 0;
    BOOL            b;
    DWORD           Error;
    WCHAR           DevInstId[MAX_DEVICE_ID_LEN];


    SetupDebugPrint( L"SETUP: Entering MarkPnpDevicesAsNeedReinstall()." );

    Error = ERROR_SUCCESS;

    //
    //  Get a list of all devices
    //
    hDevInfo = SetupDiGetClassDevs( NULL,
                                    NULL,
                                    NULL,
                                    DIGCF_ALLCLASSES );

    if( hDevInfo == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP: SetupDiGetClassDevs(DIGCF_ALLCLASSES) failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP: SetupDiGetClassDevs(DIGCF_ALLCLASSES) failed. Error = %d", Error );
        }
        SetupDebugPrint( L"SETUP: Leaving MarkPnpDevicesAsNeedReinstall(). No devices marked." );
        return( FALSE );
    }
    //
    // Assume success
    //
    b = TRUE;

    //
    // Now enumerate each device information element added to this set, and
    // mark it as 'need reinstall' if it isn't a live devnode.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for( Index = 0;
         SetupDiEnumDeviceInfo( hDevInfo, Index, &DeviceInfoData );
         Index++ ) {

        DWORD   ConfigFlags;
        ULONG   Status, Problem;

        if(CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                               &Problem,
                                               (DEVINST)DeviceInfoData.DevInst,
                                               0))
        {
            //
            // Since we were able to retrieve the devnode's status, we know that
            // it is a live devnode (not necessarily started, but at least
            // present in the hardware tree).  Thus, we don't want to mark it
            // as needing reinstall--it'll automatically get reinstalled as part
            // of our installation of all present devices (i.e., that we get
            // from the UMPNPMGR named pipe).
            //
            continue;
        }

        //
        // Check if this device instance Id is in the string table of devices
        // that have already been installed during GUI setup. If it has then
        // don't mark it with the reinstall bit since it has already been
        // installed.
        //
        // NOTE: For Windows XP we will only do this for device's in the volume
        // class.
        //
        if (DevicesInstalledStringTable &&
            IsEqualGUID(&(DeviceInfoData.ClassGuid), &GUID_DEVCLASS_VOLUME)) {

            if( SetupDiGetDeviceInstanceId( hDevInfo,
                                            &DeviceInfoData,
                                            DevInstId,
                                            sizeof( DevInstId ) / sizeof( WCHAR ),
                                            NULL ) ) {
                
                if (pSetupStringTableLookUpString( DevicesInstalledStringTable,
                                                   DevInstId,
                                                   STRTAB_CASE_INSENSITIVE
                                                   ) != -1) {
                    //
                    // We have already installed drivers on this device during
                    // GUI setup, so don't mark it with the reinstall config flag.
                    //
                    SetupDebugPrint1( L"SETUP:   Not-present Device has already been installed: %ls", DevInstId );
                    continue;
                }
            } else {
                SetupDebugPrint1( L"SETUP:   SetupDiGetDeviceInstanceId failed. Index = %d", Index );
            }
        }

        //
        // Get the config flags for the device and set the reinstall bit
        //
        if ( !( b = GetDeviceConfigFlags(hDevInfo, &DeviceInfoData, &ConfigFlags ) ) )
        {
            SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Index = %d", Index );
            continue;
        }

        ConfigFlags |= CONFIGFLAG_REINSTALL;

        if ( !( b = SetDeviceConfigFlags(hDevInfo, &DeviceInfoData, ConfigFlags ) ) ) {

            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Index = %d", Index );
            continue;
        }
    }

    //
    // Find out why SetupDiEnumDeviceInfo() failed.
    //
    Error = GetLastError();
    if( Error != ERROR_NO_MORE_ITEMS ) {
        SetupDebugPrint2( L"SETUP: Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
        b = FALSE;
    }
    SetupDebugPrint1( L"SETUP: Leaving MarkPnpDevicesAsNeedReinstall(). Devices marked = %d", Index );

    SetupDiDestroyDeviceInfoList( hDevInfo );
    return( b );
}

//
// devices installs may exist in RunOnce entries
// they are processed as a batch, as opposed to per-device
// during syssetup
//
BOOL
CallRunOnceAndWait(
    )

/*++

Routine Description:

    This function calls RunOnce and waits for a "reasonable" amount of time for it to complete
    if we don't return within a reasonable amount of time, we leave RunOnce going
    and continue with rest of install process
    if we underestimate timeout, we can cause a whole series of "class installer appears to have hung" messages

Arguments:

    None.

Return Value:

    Returns TRUE if we completed successfully
    FALSE should not be considered a fatal error, and can be ignored

--*/
{
    static CONST TCHAR pszPathRunOnce[] = REGSTR_PATH_RUNONCE;
    BOOL Success = FALSE;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL started;
    TCHAR cmdline[MAX_PATH];
    HKEY  hKey = NULL;
    LONG l;
    DWORD nValues = 0;
    DWORD timeout;

    SetupDebugPrint( L"SETUP: Entering CallRunOnceAndWait. ");

    try {
        //
        // First, open the key "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce"
        // to see if we have anything to do
        //
        if((l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszPathRunOnce,0,KEY_QUERY_VALUE,&hKey)) != ERROR_SUCCESS) {
            //
            // not considered an error
            //
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: could not open RunOnce registry, assuming no entries. ");
            Success = TRUE;
            leave;
        }

        //
        // we want to know how many items we'll be executing in RunOnce to estimate a timeout
        //
        l = RegQueryInfoKey(hKey,NULL,NULL,NULL,
                                    NULL, NULL, NULL,
                                    &nValues,
                                    NULL, NULL, NULL, NULL);
        if ( l != ERROR_SUCCESS ) {
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: could not get number of entries, assuming no entries. ");
            nValues = 0;
        }

        RegCloseKey(hKey);

        //
        // estimating timeout is a black art
        // we can try and guess for any entries in the HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce key
        // but we're in the dark if any new keys are added
        // we add '5' items to the timeout to "account" for this uncertainty. We also always run RunOnce
        //

        if (nValues == 0) {
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: calling RunOnce (no detected entries). ");
            nValues = 5;
        } else {
            SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: calling RunOnce (%u known entries). ", nValues);
            nValues += 5;
        }
        if (nValues < RUNONCE_THRESHOLD) {
            timeout =  nValues * RUNONCE_TIMEOUT;
        } else {
            timeout =  RUNONCE_THRESHOLD * RUNONCE_TIMEOUT;
        }

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        ZeroMemory(&ProcessInformation,sizeof(ProcessInformation));

        StartupInfo.cb = sizeof(StartupInfo);
        
        if (SUCCEEDED(StringCchCopy(cmdline, SIZECHARS(cmdline),TEXT("runonce -r")))) {

            started = CreateProcess(NULL,       // use application name below
                          cmdline,              // command to execute
                          NULL,                 // default process security
                          NULL,                 // default thread security
                          FALSE,                // don't inherit handles
                          0,                    // default flags
                          NULL,                 // inherit environment
                          NULL,                 // inherit current directory
                          &StartupInfo,
                          &ProcessInformation);
    
            if(started) {
    
                DWORD WaitProcStatus;
    
                do {
    
                    WaitProcStatus = WaitForSingleObjectEx(ProcessInformation.hProcess, timeout , TRUE);
    
                } while (WaitProcStatus == WAIT_IO_COMPLETION);
    
                if (WaitProcStatus == WAIT_TIMEOUT) {
                    //
                    // RunOnce is still running
                    //
                    SetupDebugPrint( L"SETUP: CallRunOnceAndWait: RunOnce may have hung and has been abandoned. ");
    
                } else if (WaitProcStatus == (DWORD)(-1)) {
                    //
                    // huh?
                    //
                    DWORD WaitProcError = GetLastError();
                    SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: WaitForSingleObjectEx failed. Error = %lx ", WaitProcError );
    
                } else {
                    //
                    // we ran, we waited, we returned
                    //
                    Success = TRUE;
                }
    
                CloseHandle(ProcessInformation.hThread);
                CloseHandle(ProcessInformation.hProcess);
    
            } else {
    
                DWORD CreateProcError;
    
                //
                // The runonce task should get picked up later by someone else (e.g., at next
                // login).
                //
                CreateProcError = GetLastError();
    
                SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: start RunOnce failed. Error = %lx ", CreateProcError );
            }
        } else {
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: failed to create command line." );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetupDebugPrint( L"SETUP: CallRunOnceAndWait: Exception! ");
        Success = FALSE;
    }

    SetupDebugPrint( L"SETUP: Leaving CallRunOnceAndWait. ");

    return Success;
}

//
// obsolete function from devmgr.c. keep the export in place for backwards compatibility
//
BOOL
DevInstallW(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDeviceInfoData
    )
{
    UNREFERENCED_PARAMETER(hDevInfo);
    UNREFERENCED_PARAMETER(pDeviceInfoData);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


ULONG
SyssetupGetPnPFlags(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData
    )
{
    DWORD Err;
    BOOL b;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    WCHAR InfSectionWithExt[255];   // MAX_SECT_NAME_LEN from setupapi\inf.h
    INFCONTEXT InfContext;
    ULONG ret = 0;

    //
    // First retrieve the name of the INF for this driver node.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDeviceInfoData,
                                   pDriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL)) {
        //
        // If we failed with ERROR_INSUFFICIENT_BUFFER, that's OK.  We're
        // guaranteed to have gotten all the static fields in the driver info
        // detail structure filled in (including the INF name and section
        // name fields).
        //
        Err = GetLastError();
        MYASSERT(Err == ERROR_INSUFFICIENT_BUFFER);
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            return ret;
        }
    }

    //
    // Now open up the INF associated with this driver node.
    //
    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // This will fail, for example, if the INF is an old-style INF.
        //
        return ret;
    }

    //
    // Get the potentially decorated install section name.
    //
    b = SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData.SectionName,
                                         InfSectionWithExt,
                                         SIZECHARS(InfSectionWithExt),
                                         NULL,
                                         NULL
                                        );
    MYASSERT(b);
    if(!b) {
        goto clean0;
    }

    //
    // Now look to see if there's a "SyssetupPnPFlags" entry in that section.
    //
    if(!SetupFindFirstLine(hInf,
                           InfSectionWithExt,
                           szSyssetupPnPFlags,
                           &InfContext)) {
        //
        // We didn't find such a line in this section.
        //
        goto clean0;
    }

    if(!SetupGetIntField(&InfContext, 1, (PINT)&ret)) {
        //
        // We failed--ensure return value is still zero.
        //
        ret = 0;
        goto clean0;
    }

clean0:

    SetupCloseInfFile(hInf);

    return ret;
}

//
// this function will tell umpnpmgr to stop server-side installs
//
VOID
PnpStopServerSideInstall(
    VOID
    )
/*++

Routine Description:

    After phase-2, server-side installs kick in to pick up software-enumerated drivers
    Call this when it's critical that we need to stop installing

Arguments:

    None.

Return Value:

    None.
    Returns when it is safe to proceed.

--*/
{
    //
    // since when we're called there should be nobody generating new devnodes, we're pretty safe
    //
    CMP_WaitNoPendingInstallEvents(INFINITE);
}

//
// this function will update HAL+kernel from NewInf
//
VOID
PnpUpdateHAL(
    VOID
    )
/*++

Routine Description:

    At very end of MiniSetup, OEM may indicate (via Unattend) that a different HAL should be installed
    This must be done very last due to that way that HAL's need to be installed, if we do this earlier
    then an app or service may pick the wrong HAL/Kernel32/other

Arguments:

    None

Return Value:

    None.
    There is nothing meaningful that can be done if this fails

--*/
{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    WCHAR HardwareID[MAX_PATH+2];
    WCHAR InfPath[MAX_PATH];
    WCHAR Answer[MAX_PATH];
    WCHAR AnswerFile[2*MAX_PATH];
    DWORD HardwareIdSize;
    DWORD dwLen;
    HINSTANCE hInstNewDev = NULL;
    ExternalUpdateDriverForPlugAndPlayDevicesW pUpdateDriverForPlugAndPlayDevicesW = NULL;
    PWSTR pSrch = NULL;
    PWSTR pHwID = NULL;
    PWSTR pInfPath = NULL;
    BOOL RebootFlag = FALSE;
    SYSTEM_INFO info;

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // If we determine we are only running on one processor (based on System Info)
    // allow use of UpdateUPHAL
    //
    GetSystemInfo(&info);

    Answer[0]=L'\0';
    if(info.dwNumberOfProcessors==1) {
        if( GetPrivateProfileString( WINNT_UNATTENDED,
                                     WINNT_U_UPDATEUPHAL,
                                     pwNull,
                                     Answer,
                                     MAX_PATH,
                                     AnswerFile )) {
            SetupDebugPrint1( L"SETUP:   UpdateUPHAL=\"%ls\"",Answer);
        }
    }

    if(!Answer[0]) {
        //
        // we didn't explicitly get an answer based on being UP - try catch-all
        //
        if( GetPrivateProfileString( WINNT_UNATTENDED,
                                     WINNT_U_UPDATEHAL,
                                     pwNull,
                                     Answer,
                                     MAX_PATH,
                                     AnswerFile )) {
            SetupDebugPrint1( L"SETUP:   UpdateHAL=\"%ls\"",Answer);
        }
    }
    if(!Answer[0]) {
        //
        // no update request
        //
        return;
    }

    //
    // split Answer into HardwareID & INF
    //
    pHwID = Answer;
    pSrch = wcschr(Answer,L',');
    if(pSrch == NULL) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    pInfPath = pSrch+1;

    //
    // trim HardwareID & prepare as a MULTI-SZ
    //
    while(pHwID[0]==L' '||pHwID[0]==L'\t') {
        pHwID++;
    }
    while(pSrch != pHwID && (pSrch[-1]==L' '||pSrch[-1]==L'\t')) {
        pSrch--;
    }
    pSrch[0]=0;
    if(!pHwID[0]) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    if (FAILED(StringCchCopy(HardwareID, SIZECHARS(HardwareID) ,pHwID))) {
        SetupDebugPrint( L"SETUP:     Failed to copy HAL hardware Id." );
        goto clean0;
    }
    HardwareIdSize = wcslen(HardwareID)+1;

    //
    // now pre-process the INF, trim & allow %windir% expansion
    //
    while(pInfPath[0]==L' '|| pInfPath[0]==L'\t') {
        pInfPath++;
    }
    pSrch = pInfPath+wcslen(pInfPath);
    while(pSrch != pInfPath && (pSrch[-1]==L' '||pSrch[-1]==L'\t')) {
        pSrch--;
    }
    pSrch[0]=0;
    if(!pInfPath[0]) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    dwLen=ExpandEnvironmentStrings(pInfPath,InfPath,MAX_PATH);
    if(dwLen==0 || dwLen > MAX_PATH) {
        SetupDebugPrint1( L"SETUP:     Expansion of \"%ls\" failed",InfPath);
        return;
    }
    SetupDebugPrint2( L"SETUP:     Preparing to install new HAL %ls from %ls",HardwareID,InfPath);

    // we need "UpdateDriverForPlugAndPlayDevices"
    // make sure we can get this before changing hardware ID
    //
    hInstNewDev = LoadLibrary(L"newdev.dll");
    if(hInstNewDev == NULL) {
        SetupDebugPrint1( L"SETUP:     Failed to load newdev.dll. Error = %d", GetLastError() );
        goto clean0;
    }
    pUpdateDriverForPlugAndPlayDevicesW = (ExternalUpdateDriverForPlugAndPlayDevicesW)
                                            GetProcAddress(hInstNewDev,
                                                            "UpdateDriverForPlugAndPlayDevicesW");
    if(pUpdateDriverForPlugAndPlayDevicesW==NULL) {
        SetupDebugPrint1( L"SETUP:     Failed to get UpdateDriverForPlugAndPlayDevicesW. Error = %d", GetLastError() );
        goto clean0;
    }

    //
    // we enumerate the Computer class, GUID={4D36E966-E325-11CE-BFC1-08002BE10318}
    // and should find a single DevNode, which is the one we need to update
    // when we actually update, we consider this a safe thing to do
    // since it should not involve any Co-Installers
    //
    hDevInfo = SetupDiGetClassDevs(&GUID_DEVCLASS_COMPUTER,NULL,NULL,DIGCF_PRESENT|DIGCF_PROFILE);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1( L"SETUP:     SetupDiGetClassDevs() failed. Error = %d", GetLastError() );
        goto clean0;
    }
    DevInfoData.cbSize = sizeof(DevInfoData);
    if(!SetupDiEnumDeviceInfo(hDevInfo,0,&DevInfoData)) {
        SetupDebugPrint1( L"SETUP:     SetupDiEnumDeviceInfo() failed. Error = %d", GetLastError() );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        goto clean0;
    }

    //
    // change the harware ID
    //
    if(!SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         &DevInfoData,
                                         SPDRP_HARDWAREID,
                                         (PBYTE)HardwareID,
                                         sizeof(HardwareID[0])*HardwareIdSize
                                         )) {
        SetupDebugPrint1( L"SETUP:     SetupDiSetDeviceRegistryProperty() failed. Error = %d", GetLastError() );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        goto clean0;
    }
    SetupDiDestroyDeviceInfoList(hDevInfo);

    //
    // now effect an update
    //
    if(!pUpdateDriverForPlugAndPlayDevicesW(NULL,HardwareID,InfPath,INSTALLFLAG_FORCE,&RebootFlag)) {
        SetupDebugPrint1( L"SETUP:     UpdateDriverForPlugAndPlayDevices() failed. Error = %d", GetLastError() );
    } else {
        SetupDebugPrint( L"SETUP:     ... new HAL installed and will be active on reboot");
    }

clean0:

    if(hInstNewDev != NULL) {
        FreeLibrary(hInstNewDev);
    }
}

BOOL
InstallOEMInfs(
    VOID
    )
/*++

Routine Description:

    This routine will install any OEM supplied INFs (and their corresponding
    catalogs) that may have been supplied to the system during an earlier phase
    of setup.  For example, the OEM can currently supply an INF for unsupported
    hardware during the textmode phase of setup by pressing "F6".

    The list of OEM INFs to be installed is supplied to us via the answer
    file in the following format:

    [Data]
    OEMDrivers=<driver-section-1>,<driver-section-2>,...

    [driver-section-1]
    OemDriverPathName=<path> (path to the driver (may use environment variables)
    OemInfName=<inf name> name of the inf to be installed from the above
               directory (there can be one or more infs in this directory, so
               this is a comma separated list)
    OemDriverFlags=<flags>

    valid flags are:
    SETUP_OEM_LDR_DEVICE        0x00000001
     //indicates that the driver was supplied via the textmode "F6" mechanism
    SETUP_OEM_MIGRATED_DRIVER   0x00000002
     //indicates that the driver was migrated from the previous system

    This function is really just a wrapper for SetupCopyOEMInf, which does
    everything we need

Arguments:

    None.

Return Value:

    TRUE indicates that all answer file-supplied drivers were installed properly

--*/
{
    HINF hAnswerFile = INVALID_HANDLE_VALUE;
    BOOL RetVal;
    INFCONTEXT LineContext;
    DWORD FieldCount, InfNameCount;
    DWORD Field, InfCount;
    DWORD CchSize;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext,InfLineContext;
    PCWSTR OemDriverPathName;
    PCWSTR OemInfName;
    DWORD  OemFlags;
    WCHAR FullInfPathBuffer[MAX_PATH];
    WCHAR FullInfPathBufferWithInf[MAX_PATH];

    RetVal = TRUE;

    hAnswerFile = pOpenAnswerFile();
    if (hAnswerFile == INVALID_HANDLE_VALUE) {
        //
        // if there is no answer file, then we can't continue.
        //
        RetVal = FALSE;
        goto clean0;
    }

    if (!SetupFindFirstLine(hAnswerFile,WINNT_DATA,WINNT_OEMDRIVERS,&LineContext)) {
        //
        // we were successful in doing nothing
        //
        RetVal = TRUE;
        goto clean0;
    }

    do {

        //
        // Each value on the line in the given section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {

            OemDriverPathName = NULL;
            OemInfName = NULL;
            OemFlags = 0;
            FullInfPathBuffer[0] = '\0';
            FullInfPathBufferWithInf[0] = '\0';

            if((SectionName = pSetupGetField(&LineContext,Field))
            && SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_PATHNAME,&FirstLineContext)) {
                //
                // the section points to a valid section, so process it.
                //
                OemDriverPathName = pSetupGetField(&FirstLineContext,1);

                if (SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_FLAGS,&FirstLineContext)) {
                    SetupGetIntField(&FirstLineContext,1,&OemFlags);
                }

                if (OemDriverPathName) {
                    CchSize = ExpandEnvironmentStrings( OemDriverPathName,
                                                        FullInfPathBuffer,
                                                        sizeof(FullInfPathBuffer)/sizeof(WCHAR) );

                    if ((CchSize == 0) ||
                        (CchSize > SIZECHARS(FullInfPathBuffer))) {
                        //
                        // The OemDriverPathName value, when expanded, will not
                        // fit into our local buffer.
                        //
                        RetVal = FALSE;
                        goto clean0;
                    }
                }

                if (SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_INFNAME,&InfLineContext)) {
                    InfNameCount = SetupGetFieldCount(&InfLineContext);
                    for (InfCount = 1; InfCount <= InfNameCount; InfCount++) {
                        OemInfName = pSetupGetField(&InfLineContext,InfCount);

                        if (OemDriverPathName && OemInfName) {

                            if (SUCCEEDED(StringCchCopy( FullInfPathBufferWithInf, 
                                                         SIZECHARS(FullInfPathBufferWithInf), 
                                                         FullInfPathBuffer )) &&
                                pSetupConcatenatePaths(
                                            FullInfPathBufferWithInf,
                                            OemInfName,
                                            sizeof(FullInfPathBufferWithInf)/sizeof(WCHAR),
                                            0 )) {

                                if (!SetupCopyOEMInf(
                                        FullInfPathBufferWithInf,
                                        (OemFlags & SETUP_OEM_MIGRATED_DRIVER) ? NULL : FullInfPathBuffer,
                                        (OemFlags & SETUP_OEM_MIGRATED_DRIVER) ? SPOST_NONE : SPOST_PATH,
                                        (OemFlags & (SETUP_OEM_MIGRATED_DRIVER | SETUP_OEM_LDR_DEVICE)) ? SP_COPY_OEM_F6_INF : 0,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL)) {
                                    RetVal = FALSE;
                                }
    
                                if (OemFlags & SETUP_OEM_LDR_DEVICE) {
                                    //
                                    // if this flag is set, we know that there is an
                                    // additional oemXXX##.inf file in the system32
                                    // directory which corresponds to the INF file we
                                    // have already copied from this directory.  We need
                                    // to seek out that file and remove it, since the INF
                                    // file we have just copied is "better" than that file.
                                    //
                                    WIN32_FIND_DATA fd;
                                    HANDLE hFind;
                                    WCHAR OldInfBuffer[MAX_PATH];
                                    PWSTR p;
    
                                    CchSize = ExpandEnvironmentStringsW(
                                                L"%SystemRoot%\\system32\\",
                                                OldInfBuffer,
                                                sizeof(OldInfBuffer)/sizeof(WCHAR));

                                    if ((CchSize != 0) &&
                                        (CchSize <= SIZECHARS(OldInfBuffer))) {
        
                                        //
                                        // Set the pointer 'p' to the end of
                                        // the path.
                                        //
                                        p = wcsrchr( OldInfBuffer, L'\\' );
                                        p += 1;
        
                                        if (pSetupConcatenatePaths(
                                                    OldInfBuffer,
                                                    L"oem?????.inf",
                                                    sizeof(OldInfBuffer)/sizeof(WCHAR),
                                                    0 )) {
            
                                            if ((hFind = FindFirstFile(OldInfBuffer, &fd)) != INVALID_HANDLE_VALUE) {
                                                do {
                                                    p = L'\0';

                                                    if (pSetupConcatenatePaths(
                                                                OldInfBuffer,
                                                                fd.cFileName,
                                                                sizeof(OldInfBuffer)/sizeof(WCHAR),
                                                                0 )) {

                                                        if (DoFilesMatch( FullInfPathBufferWithInf, OldInfBuffer )) {
                                                            SetFileAttributes(OldInfBuffer, FILE_ATTRIBUTE_NORMAL );
                                                            DeleteFile( OldInfBuffer );
                                                        }
                                                    }
                                                } while(FindNextFile( hFind, &fd ));
            
                                                FindClose( hFind );
            
                                            }
                                        }
                                    }
                                }
                            } else {
                                //
                                // We could not fit the FullInfPathBuffer with 
                                // the INF name into our local buffer.
                                //
                                RetVal = FALSE;
                            }
                        } else {
                            RetVal = FALSE;
                        }
                    }
                }
            }
        }
    } while(SetupFindNextMatchLine(&LineContext,NULL,&LineContext));


clean0:
    if (hAnswerFile != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile( hAnswerFile );
    }
    
    return(RetVal);
}


VOID
SfcExcludeMigratedDrivers (
    VOID
    )

/*++

Routine Description:

    Adds all OEM migrated boot drivers (via unsupdrv.inf) to the SFC exclusion list

Arguments:

    None

Return Value:

    None

--*/

{
    TCHAR unsupInfPath[MAX_PATH];
    TCHAR windir[MAX_PATH];
    HINF unsupdrvInf;
    INFCONTEXT ic;
    TCHAR driverId[MAX_PATH];
    TCHAR sectionFiles[MAX_PATH];
    INFCONTEXT ic2;
    TCHAR driverFilename[MAX_PATH];
    TCHAR driverSubDir[MAX_PATH];
    TCHAR driverPath[MAX_PATH];

#if defined(_AMD64_) || defined(_X86_)

    if (!FloppylessBootPath[0] ||
        !BuildPath (unsupInfPath, ARRAYSIZE(unsupInfPath), FloppylessBootPath, TEXT("$WIN_NT$.~BT")) ||
        !pSetupConcatenatePaths (unsupInfPath, TEXT("unsupdrv.inf"), ARRAYSIZE(unsupInfPath), NULL)) {
        return;
    }

#elif defined(_IA64_)

    if (!LegacySourcePath[0] ||
        !BuildPath (unsupInfPath, ARRAYSIZE(unsupInfPath), LegacySourcePath, TEXT("unsupdrv.inf"))) {
        return;
    }

#else
#error "No Target Architecture"
#endif               

    unsupdrvInf = SetupOpenInfFile (unsupInfPath, NULL, INF_STYLE_WIN4, NULL);
    if (unsupdrvInf == INVALID_HANDLE_VALUE) {
        return;
    }
    if (!GetWindowsDirectory (windir, ARRAYSIZE(windir))) {
        return;
    }

    if(SetupFindFirstLine (
            unsupdrvInf,
            TEXT("Devices"),
            NULL,
            &ic)) {
        do {
            if (!SetupGetStringField (&ic, 1, driverId, ARRAYSIZE(driverId), NULL)) {
                continue;
            }
            if (_sntprintf (sectionFiles, ARRAYSIZE(sectionFiles) - 1, TEXT("Files.%s"), driverId) < 0) {
                continue;
            }
            sectionFiles[ARRAYSIZE(sectionFiles) - 1] = 0;

            if(SetupFindFirstLine (
                    unsupdrvInf,
                    sectionFiles,
                    NULL,
                    &ic2)) {
                do {
                    if (!SetupGetStringField (&ic2, 1, driverFilename, ARRAYSIZE(driverFilename), NULL)) {
                        continue;
                    }
                    if (!SetupGetStringField (&ic2, 2, driverSubDir, ARRAYSIZE(driverSubDir), NULL)) {
                        continue;
                    }
                    if (_sntprintf (driverPath, ARRAYSIZE(driverPath) - 1, TEXT("%s\\%s\\%s"), windir, driverSubDir, driverFilename) < 0) {
                        continue;
                    }
                    driverPath[ARRAYSIZE(driverPath) - 1] = 0;
                    if (FileExists (driverPath, NULL)) {
                        MultiSzAppendString(&EnumPtrSfcIgnoreFiles, driverPath);
                    }
                } while (SetupFindNextLine(&ic2, &ic2));
            }

        } while (SetupFindNextLine(&ic, &ic));
    }

    SetupCloseInfFile (unsupdrvInf);
}


BOOL
IsInstalledInfFromOem(
    IN PCWSTR InfFileName
    )

/*++

Routine Description:

    Determine if an INF file is OEM-supplied (i.e., it's name is of the form
    "OEM<n>.INF").

Arguments:

    InfFileName - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an OEM INF.  If FALSE, it's an in-box INF (or possibly one
    that was illegally copied directly into %windir%\Inf).

--*/

{
    PCWSTR p = pSetupGetFileTitle(InfFileName);

    //
    // First check that the first 3 characters are OEM
    //
    if((*p != L'o') && (*p != L'O')) {
        return FALSE;
    }
    p++;
    if((*p != L'e') && (*p != L'E')) {
        return FALSE;
    }
    p++;
    if((*p != L'm') && (*p != L'M')) {
        return FALSE;
    }
    p++;

    //
    // Now make sure that all subsequent characters up to the dot (.) are
    // numeric.
    //
    while((*p != L'\0') && (*p != L'.')) {

        if((*p < L'0') || (*p > L'9')) {

            return FALSE;
        }

        p++;
    }

    //
    // Finally, verify that the last 4 characters are ".inf"
    //
    if(lstrcmpi(p, L".inf")) {

        return FALSE;
    }

    //
    // This is an OEM INF
    //
    return TRUE;
}

BOOL
IsInfInLayoutInf(
    IN PCWSTR InfFileName
    )

/*++

Routine Description:

    Determine if an INF file is shiped in-box with the operating system.
    This is acomplished by looking up the INF name in the [SourceDisksFiles]
    section of layout.inf

Arguments:

    InfFileName - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an in-box INF.  If FALSE, it's not an in-box INF, this
    could be an OEM<n>.INF or an inf illegaly copied into the INF directory.

--*/

{
    BOOL bInBoxInf = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT SourceId;

    hInf = SetupOpenInfFile(TEXT("layout.inf"), NULL, INF_STYLE_WIN4, NULL);

    if (hInf != INVALID_HANDLE_VALUE) {

        if(SetupGetSourceFileLocation(hInf,
                                      NULL,
                                      pSetupGetFileTitle(InfFileName),
                                      &SourceId,
                                      NULL,
                                      0,
                                      NULL)) {
            bInBoxInf = TRUE;
        }

        SetupCloseInfFile(hInf);
    }

    return bInBoxInf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\strtmenu.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    strtmenu.c

Abstract:

    Routines to manipulate menu groups and items.

    Entry points:


Author:

    Ted Miller (tedm) 5-Apr-1995
    Jaime Sasson (jaimes) 9-Aug-1995

Revision History:

    Based on various other code that has been rewritten/modified
    many times by many people.

--*/

#include "setupp.h"
#pragma hdrstop

#if 0
#define DDEDBG
#ifdef DDEDBG
#define DBGOUT(x) DbgOut x
VOID
DbgOut(
    IN PCSTR FormatString,
    ...
    )
{
    CHAR Str[256];

    va_list arglist;

    wsprintfA(Str,"SETUP (%u): ",GetTickCount());
    OutputDebugStringA(Str);

    va_start(arglist,FormatString);
    if(_vsnprintf(Str, ARRAYSIZE(Str), FormatString,arglist) < 0){
        Str[ARRAYSIZE(Str) - 1] = '\0';
    }
    va_end(arglist);
    OutputDebugStringA(Str);
    OutputDebugStringA("\n");
}
#else
#define DBGOUT(x)
#endif
#endif

BOOL
RemoveMenuGroup(
    IN PCWSTR Group,
    IN BOOL   CommonGroup
    )
{
    return( DeleteGroup( Group, CommonGroup ) );
}



BOOL
RemoveMenuItem(
    IN PCWSTR Group,
    IN PCWSTR Item,
    IN BOOL   CommonGroup
    )
{
    return( DeleteItem( Group, CommonGroup, Item, TRUE ) );
}

VOID
DeleteMenuGroupsAndItems(
    IN HINF   InfHandle
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR  SectionName = L"StartMenu.ObjectsToDelete";
    PCWSTR  ObjectType;
    PCWSTR  ObjectName;
    PCWSTR  ObjectPath;
    PCWSTR  GroupAttribute;
    BOOL    CommonGroup;
    BOOL    IsMenuItem;

    //
    // Get the number of lines in the section that contains the objects to
    // be deleted. The section may be empty or non-existant; this is not an
    // error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount <= 0) {
        return;
    }
    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)
        && (ObjectType = pSetupGetField(&InfContext,1))
        && (ObjectName = pSetupGetField(&InfContext,2))
        && (GroupAttribute = pSetupGetField(&InfContext,4))) {
            IsMenuItem = _wtoi(ObjectType);
            CommonGroup = _wtoi(GroupAttribute);
            ObjectPath = pSetupGetField(&InfContext,3);

            if( IsMenuItem ) {
                RemoveMenuItem( ObjectPath, ObjectName, CommonGroup );
            } else {
                ULONG   Size;
                PWSTR   Path;

                Size = lstrlen(ObjectName) + 1;
                if(ObjectPath != NULL) {
                    Size += lstrlen(ObjectPath) + 1;
                }
                Path = MyMalloc(Size * sizeof(WCHAR));
                if(!Path) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_MENU_REMGRP_FAIL,
                        ObjectPath,
                        ObjectName, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OUTOFMEMORY,
                        NULL,NULL);
                } else {
                    if( ObjectPath != NULL ) {
                        lstrcpy( Path, ObjectPath );
                        pSetupConcatenatePaths( Path, ObjectName, Size, NULL );
                    } else {
                        lstrcpy( Path, ObjectName );
                    }
                    RemoveMenuGroup( Path, CommonGroup );
                    MyFree(Path);
                }
            }
        }
    }
}

BOOL
AddItemsToGroup(
    IN HINF   InfHandle,
    IN PCWSTR GroupDescription,
    IN PCWSTR SectionName,
    IN BOOL   CommonGroup
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR Description;
    PCWSTR Binary;
    PCWSTR CommandLine;
    PCWSTR IconFile;
    PCWSTR IconNumberStr;
    INT IconNumber;
    PCWSTR InfoTip;
    BOOL b;
    BOOL DoItem;
    WCHAR Dummy;
    PWSTR FilePart;
    PCTSTR DisplayResourceFile = NULL;
    DWORD DisplayResource = 0;

    //
    // Get the number of lines in the section. The section may be empty
    // or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount <= 0) {
        return(TRUE);
    }

    b = TRUE;
    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)) {

            Description = pSetupGetField(&InfContext,0);
            Binary = pSetupGetField(&InfContext,1);
            CommandLine = pSetupGetField(&InfContext,2);
            IconFile = pSetupGetField(&InfContext,3);
            IconNumberStr = pSetupGetField(&InfContext,4);
            InfoTip = pSetupGetField(&InfContext,5);
            DisplayResourceFile = pSetupGetField( &InfContext, 6);
            DisplayResource = 0;
            SetupGetIntField( &InfContext, 7, &DisplayResource );

            if(Description && CommandLine ) {
                if(!IconFile) {
                    IconFile = L"";
                }
                IconNumber = (IconNumberStr && *IconNumberStr) ? wcstoul(IconNumberStr,NULL,10) : 0;

                //
                // If there's a binary name, search for it. Otherwise do the
                // item add unconditionally.
                //
                DoItem = (Binary && *Binary)
                       ? (SearchPath(NULL,Binary,NULL,0,&Dummy,&FilePart) != 0)
                       : TRUE;

                if(DoItem) {

                    b &= CreateLinkFileEx( CommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                                         GroupDescription,
                                         Description,
                                         CommandLine,
                                         IconFile,
                                         IconNumber,
                                         NULL,
                                         0,
                                         SW_SHOWNORMAL,
                                         InfoTip,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);

                }
            }
        }
    }
    return(b);
}


BOOL
DoMenuGroupsAndItems(
    IN HINF InfHandle,
    IN BOOL Upgrade
    )
{
    INFCONTEXT InfContext;
    PCWSTR GroupId,GroupDescription;
    PCWSTR GroupAttribute;
    BOOL CommonGroup;
    BOOL b;
    PCTSTR DisplayResourceFile = NULL;
    DWORD DisplayResource = 0;

    if( Upgrade ) {
        //
        //  In the upgrade case, first delet some groups and items.
        //
        DeleteMenuGroupsAndItems( InfHandle );
    }

    //
    // Iterate the [StartMenuGroups] section in the inf.
    // Each line is the name of a group that needs to be created.
    //
    if(SetupFindFirstLine(InfHandle,L"StartMenuGroups",NULL,&InfContext)) {
        b = TRUE;
    } else {
        return(FALSE);
    }

    do {
        //
        // Fetch the identifier for the group and its name.
        //
        if((GroupId = pSetupGetField(&InfContext,0))
        && (GroupDescription = pSetupGetField(&InfContext,1))
        && (GroupAttribute = pSetupGetField(&InfContext,2))) {

            CommonGroup = ( GroupAttribute && _wtoi(GroupAttribute) );

            DisplayResourceFile = pSetupGetField( &InfContext, 3);
            DisplayResource = 0;
            SetupGetIntField( &InfContext, 4, &DisplayResource );
            //
            // Create the group.
            //
            b &= CreateGroupEx( GroupDescription, CommonGroup,
                              (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                              (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);

            //
            // Now create items within the group. We do this by iterating
            // through the section in the inf that relate to the current group.
            //
            b &= AddItemsToGroup(InfHandle,GroupDescription,GroupId,CommonGroup);
        }
    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    //  Create the items (if any) for 'Start Menu'
    //
    b &= AddItemsToGroup(InfHandle,NULL,L"StartMenuItems",FALSE);

    return(TRUE);
}


BOOL
CreateStartMenuItems(
    IN HINF InfHandle
    )
{
    return(DoMenuGroupsAndItems(InfHandle,FALSE));
}

BOOL
UpgradeStartMenuItems(
    IN HINF InfHandle
    )
{
    return(DoMenuGroupsAndItems(InfHandle,TRUE));
}

BOOL
RepairStartMenuItems(
    )
{
    HINF InfHandle;
    BOOL b;

    //
    // This function is not called through Gui mode setup.
    // but is called by winlogon to repair stuff.
    //

    InitializeProfiles(FALSE);
    InfHandle = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    if( InfHandle == INVALID_HANDLE_VALUE ) {
        b = FALSE;
    } else {
        b = DoMenuGroupsAndItems(InfHandle,FALSE);
        SetupCloseInfFile(InfHandle);
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\unattend.h ===
#ifndef _UNATTEND_H_
#define _UNATTEND_H_

#define MAX_BUF MAX_INF_STRING_LENGTH

typedef enum _UNATTENDTYPE {
   UAT_STRING,
   UAT_LONGINT,
   UAT_BOOLEAN,
   UAT_NONE,
} UNATTENDTYPE;

//
// Each possible Answer from the unattended file must have a
// corresponding enumerated type present in this typedef.
// This is required since it is the method by which Pages
// can be assured that they point to the correct answer
//
typedef enum _UNATTENDENTRIES {
   UAE_PROGRAM,                 // DetachedProgram
   UAE_ARGUMENT,                // Arguments
   UAE_TIMEZONE,                // TimeZone
   UAE_FULLNAME,                // FullName
   UAE_ORGNAME,                 // OrgName
   UAE_COMPNAME,                // Computer Name
   UAE_ADMINPASS,               // Administrator Password
   UAE_PRODID,                  // Product ID
   UAE_MODE,                    // SetupMode
   UAE_AUTOLOGON,               // autoadminlogon
   UAE_PROFILESDIR,             // Profiles directory
   UAE_PROGRAMFILES,            // Program Files directory
   UAE_COMMONPROGRAMFILES,      // Program Files\Common Files directory
   UAE_PROGRAMFILES_X86,        // Program Files (x86) directory
   UAE_COMMONPROGRAMFILES_X86,  // Program Files\Common Files (x86) directory
} UNATTENDENTRIES;

#ifndef MIDL_PASS
struct _UNATTENDANSWER;
struct _UNATTENDITEM;
struct _UNATTENDPAGE;
struct _UNATTENDWIZARD;
#endif

//
// This is the callback function that checks wether or not an
// answer is valid. Called automatically by UnattendFindAnswer
//
typedef
BOOL
(* LPFNCHECKVALID)(
    struct _UNATTENDANSWER *rec
    );


//
// This is the callback function that is used to special case
// the activation code. Really useful for those dialog boxes
// which include check boxes, radio buttons, etc, etc.
//
typedef
BOOL
(* LPFNSETACTIVE)(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

//
// This structure is used to determine where and how to find
// an answer and also to determine wether or not that answer
// is present, of the correct type, etc, etc. This structure
// should never be used by anything other then the unattend
// module.
//
typedef struct _UNATTENDANSWER {
    //
    // Unique identifier for this answer.
    //
    UNATTENDENTRIES AnswerId;

    //
    // Has the answer been found in the unattend file and
    // is it known to be of the correct 'format'
    //
    BOOL Present;

    //
    // Is the answer absolutely required for setup to work?
    //
    BOOL Required;

    //
    // Was there an error in parsing the string? If so it might
    // be appropriate to display a message box notifying the
    // user of this condition
    //
    BOOL ParseErrors;

    //
    // The Answer structure. Since there are several possible
    // types, from string to numbers, a union is required
    //
    union {
        PWSTR String;
        LONG  Num;
        BOOL  Bool;
    } Answer;

    //
    // The following 3 items are the implementation dependant
    // portion of this structure. Each pointer points to
    // a string which is used in a GetPrivateProfile call.
    // Note that it is important to keep these as constant
    // pointers and that they will have to be changed when
    // an OLE model is implemented.
    //
    const PCWSTR Section;
    const PCWSTR Key;
    const PCWSTR DefaultAnswer;

    //
    // This specifies which of the members in the union is
    // the one we want ie: is it a string, an int, or a bool?
    //
    UNATTENDTYPE Type;

    //
    // This callback function is called so that the validity
    // of the answer can be determined
    //
    LPFNCHECKVALID pfnCheckValid;

} UNATTENDANSWER, *PUNATTENDANSWER;


//
// Each item on a dialog page must be represented by the following
// structure. An array of items is built and is stored in the
// structure for the page
//
typedef struct _UNATTENDITEM {
    //
    // Specifies the control id of item so that we can send
    // messages to it
    //
    DWORD ControlId;

    //
    // Reserved for special message passing
    //
    DWORD Reserved1;

    //
    // Reserved for special message passing
    //
    DWORD Reserved2;

    //
    // Callback function to call when we are trying to set active
    // the dialog. Really useful in the case radio and check boxes.
    //
    LPFNSETACTIVE pfnSetActive;

    //
    // Pointer to the answer which is associated with this item
    //
    PUNATTENDANSWER Item;

} UNATTENDITEM, *PUNATTENDITEM;


//
// Each page in the wizard must have one of the following structures
// filled out to describe its contents
//
typedef struct _UNATTENDPAGE {
    //
    // The IDD of the dialog page
    // Required so that we can correspond to a dialog box
    //
    DWORD PageId;

    //
    // RUN TIME Flag that determines if we show the page to the user
    // Is determined by wether or not the answer is present and correct
    //
    BOOL ShowPage;

    //
    // Wether or not the page has been loaded once. Since we only
    // want to copy the answer to the screen once, this acts as a
    // sentry
    //
    BOOL LoadPage;

    //
    // After we have loaded the page, should we show it no matter what?
    // Useful for the title and finish pages
    //
    BOOL NeverSkip;

    //
    // How many items we have on the page
    //
    UINT ItemCount;

    //
    // Pointer to an array of items of size ItemCount
    //
    PUNATTENDITEM Item;

} UNATTENDPAGE, *PUNATTENDPAGE;


//
// Information structure about how the unattended operation for the Wizard
// is proceeding
//
typedef struct _UNATTENDWIZARD {
    //
    // Wether or not we should show the wizard -- IGNORED since TedM
    // doesn't want to duplicated the code in PSN_WIZNEXT. Kept for
    // Future use
    //
    BOOL ShowWizard;

    //
    // Flag that indicates that we have filled the array of answers
    // specified in this structure. Since we ideally once want to do
    // this once...
    //
    BOOL Initialized;

    //
    // Wether or not the ENTIRE unattended operation was successful.
    // If he required a single input from the user, then it was not.
    // Determines if the 'finish' page is a place were the user must
    // supply some input
    //
    BOOL Successful;

    //
    // How many pages we have information about
    //
    UINT PageCount;

    //
    // Pointer to an array of pages
    //
    PUNATTENDPAGE Page;

    //
    // How many answer we have to fill
    //
    UINT AnswerCount;

    //
    // Pointer to an array of answers that are to be used
    //
    PUNATTENDANSWER Answer;

} UNATTENDWIZARD, *PUNATTENDWIZARD;


//
// Global pointer to the answer file
//
extern WCHAR AnswerFile[MAX_PATH];


//
// Constants for the wizard notification messages
//

#define WIZARD_NEXT_OK          0
#define WIZARD_NEXT_DISALLOWED  -1
#define WIZARD_ACTIVATE_PAGE    0
#define WIZARD_SKIP_PAGE        -1

#define VALIDATE_DATA_INVALID   -1
#define VALIDATE_DATA_OK        1

//
// Interface Functions
//
VOID
UnattendInitialize(
    VOID
    );

BOOL
UnattendSetActiveDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    );

// For PSN_WIZNEXT/PSN_WIZFINISH only
VOID
UnattendAdvanceIfValid (
    IN HWND  hwnd
    );

BOOL
UnattendErrorDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    );

PWSTR
UnattendFetchString(
    IN UNATTENDENTRIES entry
    );

// Wrapper to simply return a value in DWL_MSGRESULT, return value is always TRUE
BOOL
ReturnDlgResult (
    HWND hdlg,
    LRESULT Result
    );

// Sends message, returns DWL_MSGRESULT, preservs original value in DWL_MSGRESULT
LRESULT
SendDlgMessage (
    HWND hdlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );



//
// Types and routines for afpnp.c
//

typedef struct {
    PVOID Buffer;
    UINT Size;
} BUFFER, *PBUFFER;

typedef struct {
    PWSTR Start;
    PWSTR End;
    UINT Size;
} MULTISZ, *PMULTISZ;

typedef struct {
    PCWSTR Start;
    PCWSTR Current;
} MULTISZ_ENUM, *PMULTISZ_ENUM;

#define BUFFER_INIT {NULL,0}
#define MULTISZ_INIT {NULL,NULL,0}

typedef struct _tagAFDRIVERATTRIBS {
    BOOL Broken;
    BOOL Initialized;
    HINF InfHandle;
    PCWSTR FilePath;
    PCWSTR InfPath;
    PCWSTR OriginalInstallMedia;
    MULTISZ PnpIdList;
    PCWSTR ClassInstall32Section;       // no cleanup needed
    GUID Guid;
    struct _tagAFDRIVERATTRIBS *Next;
} AF_DRIVER_ATTRIBS, *PAF_DRIVER_ATTRIBS;

typedef struct {
    PAF_DRIVER_ATTRIBS Driver;
    BOOL WantAll;
} AF_DRIVER_ENUM, *PAF_DRIVER_ENUM;

typedef struct {
    PVOID DriverTable;
    PAF_DRIVER_ATTRIBS FirstDriver;
} AF_DRIVERS, *PAF_DRIVERS;


// Alloc or realloc depending on presense of Old (like c runtime realloc)
PVOID
MySmartAlloc (
    PCVOID Old,     OPTIONAL
    UINT Size
    );

// Free if p is not NULL
VOID
MySmartFree (
    PCVOID p
    );

// Allocs only if SizeNeeded outgrew size previously allocated in Buf
PVOID
ReusableAlloc (
    IN OUT  PBUFFER Buf,
    IN      UINT SizeNeeded
    );

// Cleans up BUFFER structs
VOID
ReusableFree (
    IN OUT  PBUFFER Buf
    );

// Adds a string to a MULTISZ alloc, growing/reallocating if necessary
PWSTR
MultiSzAppendString (
    IN OUT  PMULTISZ MultiSz,
    IN      PCWSTR String
    );

// Cleans up MULTISZ structs
VOID
MultiSzFree (
    IN OUT  PMULTISZ MultiSz
    );

// Simplifies logic surrounding multisz processing
BOOL
EnumFirstMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr,
    IN      PCWSTR MultiSz
    );

BOOL
EnumNextMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr
    );

// Simplifies getting string fields in loops
PCWSTR
SyssetupGetStringField (
    IN      PINFCONTEXT InfContext,
    IN      DWORD Field,
    IN OUT  PBUFFER Buf
    );


// For progress bar UI computations
INT
CountAfDrivers (
    IN      PAF_DRIVERS Drivers,
    OUT     INT *ClassInstallers        OPTIONAL
    );

// Pulls in answer file data, parses into structs
PAF_DRIVERS
CreateAfDriverTable (
    VOID
    );

VOID
DestroyAfDriverTable (
    IN      PAF_DRIVERS Drivers
    );

// Enumeration of AF_DRIVERS
BOOL
EnumFirstAfDriver (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers
    );

BOOL
EnumFirstAfDriverEx (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers,
    IN      BOOL WantAll
    );

BOOL
EnumNextAfDriver (
    IN OUT  PAF_DRIVER_ENUM EnumPtr
    );

// Builds INF list of answer file-supplied drivers for a device
BOOL
SyssetupInstallAnswerFileDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    OUT     PAF_DRIVER_ATTRIBS *AfDriver
    );

// Fixes the source INF path after installation completes
BOOL
SyssetupFixAnswerFileDriverPath (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    );


HINF
pOpenAnswerFile (
    VOID
    );

BOOL
GetAnswerFileSetting (
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR Buffer,
    IN      UINT BufferSize
    );

#endif // _UNATTEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\sif.h ===
#ifndef _SIF_H_
#define _SIF_H_

extern const WCHAR          pwGuiUnattended[];
extern const WCHAR          pwUserData[];
extern const WCHAR          pwUnattended[];
extern const WCHAR          pwAccessibility[];
extern const WCHAR          pwProgram[];
extern const WCHAR          pwArgument[];
extern const WCHAR          pwServer[];
extern const WCHAR          pwTimeZone[];
extern const WCHAR          pwGuiRunOnce[];
extern const WCHAR          pwCompatibility[];
extern const WCHAR          pwAutoLogon[];
extern const WCHAR          pwProfilesDir[];
extern const WCHAR          pwProgramFilesDir[];
extern const WCHAR          pwCommonProgramFilesDir[];
extern const WCHAR          pwProgramFilesX86Dir[];
extern const WCHAR          pwCommonProgramFilesX86Dir[];
extern const WCHAR          pwWaitForReboot[];
extern const WCHAR          pwFullName[];
extern const WCHAR          pwOrgName[];
extern const WCHAR          pwCompName[];
extern const WCHAR          pwAdminPassword[];
extern const WCHAR          pwProdId[];
extern const WCHAR          pwProductKey[];
extern const WCHAR          pwMode[];
extern const WCHAR          pwUnattendMode[];
extern const WCHAR          pwAccMagnifier[];
extern const WCHAR          pwAccReader[];
extern const WCHAR          pwAccKeyboard[];
extern const WCHAR          pwNull[];
extern const WCHAR          pwExpress[];
extern const WCHAR          pwTime[];
extern const WCHAR          pwProduct[];
extern const WCHAR          pwMsDos[];
extern const WCHAR          pwWin31Upgrade[];
extern const WCHAR          pwWin95Upgrade[];
extern const WCHAR          pwBackupImage[];
extern const WCHAR          pwServerUpgrade[];
extern const WCHAR          pwNtUpgrade[];
extern const WCHAR          pwBootPath[];
extern const WCHAR          pwLanmanNt[];
extern const WCHAR          pwServerNt[];
extern const WCHAR          pwWinNt[];
extern const WCHAR          pwNt[];
extern const WCHAR          pwInstall[];
extern const WCHAR          pwUnattendSwitch[];
extern const WCHAR          pwRunOobe[];
extern const WCHAR          pwReferenceMachine[];
extern const WCHAR          pwOptionalDirs[];
extern const WCHAR          pwUXC[];
extern const WCHAR          pwSkipMissing[];
extern const WCHAR          pwIncludeCatalog[];
extern const WCHAR          pwDrvSignPol[];
extern const WCHAR          pwNonDrvSignPol[];
extern const WCHAR          pwYes[];
extern const WCHAR          pwNo[];
extern const WCHAR          pwZero[];
extern const WCHAR          pwOne[];
extern const WCHAR          pwIgnore[];
extern const WCHAR          pwWarn[];
extern const WCHAR          pwBlock[];
extern const WCHAR          pwData[];
extern const WCHAR          pwSetupParams[];
extern const WCHAR          pwSrcType[];
extern const WCHAR          pwSrcDir[];
extern const WCHAR          pwCurrentDir[];
extern const WCHAR          pwDosDir[];
extern const WCHAR          pwGuiAttended[];
extern const WCHAR          pwProvideDefault[];
extern const WCHAR          pwDefaultHide[];
extern const WCHAR          pwReadOnly[];
extern const WCHAR          pwFullUnattended[];
extern const WCHAR          pwEulaDone[];

#define ArcPrefixLen            (lstrlen(pwArcPrefix))
#define NtPrefixLen             (lstrlen(pwNtPrefix))
#define ISUNC(sz)               ((BOOL)(sz != NULL && lstrlen(sz) > 3 && \
                                    *sz == L'\\' && *(sz+1) == L'\\'))
extern const WCHAR          pwArcType[];
extern const WCHAR          pwDosType[];
extern const WCHAR          pwUncType[];
extern const WCHAR          pwNtType[];
extern const WCHAR          pwArcPrefix[];
extern const WCHAR          pwNtPrefix[];
extern const WCHAR          pwLocalSource[];
extern const WCHAR          pwException[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\userdiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userdiff.c

Abstract:

    This module contains routines for updating the userdifr hive.

    In the following, the list of changes to be applied when a user
    logs on after an upgrade will be called UserRun.  UserRun is
    developed from three sources:

    1) The UserRun generated on the last upgrade.  This forms the
       basis for this upgrade's UserRun.

    2) The list of changes shipped with the system.  Call this
       UserShip.  The changes from all build numbers that are
       present in UserShip but not in UserRun are copied into
       UserRun.  (Note that if a build number is already present
       in UserRun, we don't copy the UserShip changes.  This
       means that changes cannot be made retroactively in UserShip.)

    3) Changes made during the current upgrade.  These changes are
       detected at run time (see watch.c).  All changes detected
       during the upgrade are added to UserRun.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// Debugging aids.
//

#if USERDIFF_DEBUG

DWORD UserdiffDebugLevel = 0;
#define dprintf(_lvl_,_x_) if ((_lvl_) <= UserdiffDebugLevel) DbgPrint _x_

#else

#define dprintf(_lvl_,_x_)

#endif

//
// Macro to calculate length of string including terminator.
//

#define SZLEN(_wcs) ((wcslen(_wcs) + 1) * sizeof(WCHAR))

//
// Context record used in this module to track registry state.
//

typedef struct _USERRUN_CONTEXT {
    BOOL UserRunLoaded;
    HKEY UserRunKey;
    HKEY BuildKey;
    HKEY FilesKey;
    HKEY HiveKey;
    ULONG FilesIndex;
    ULONG HiveIndex;
    HKEY UserShipKey;
} USERRUN_CONTEXT, *PUSERRUN_CONTEXT;

//
// Context record used in MakeUserRunEnumRoutine.
//

typedef struct _KEY_ENUM_CONTEXT {
    PUSERRUN_CONTEXT UserRunContext;
    PWCH CurrentPath;
} KEY_ENUM_CONTEXT, *PKEY_ENUM_CONTEXT;

//
// Forward declaration of local subroutines.
//

DWORD
LoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    );

DWORD
MergeUserShipIntoUserRun (
    IN OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserShipPath
    );

DWORD
CreateAndLoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    );

DWORD
OpenUserRunKeys (
    IN OUT PUSERRUN_CONTEXT Context
    );

VOID
UnloadUserRun (
    IN OUT PUSERRUN_CONTEXT Context
    );

DWORD
CheckUserShipKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
MakeUserRunEnumRoutine (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    );

DWORD
MakeAddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeAddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeDeleteValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeAddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeDeleteKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
AddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH FullPath,
    IN PWCH Path
    );

DWORD
AddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Path
    );

DWORD
AddValueDuringAddKey (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
AddKeyDuringAddKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
AddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
CreateUserRunSimpleFileKey (
    IN PUSERRUN_CONTEXT Context,
    IN DWORD Action,
    IN PWCH Name
    );

DWORD
CreateUserRunKey (
    IN PUSERRUN_CONTEXT Context,
    IN BOOL IsFileKey,
    OUT PHKEY NewKeyHandle
    );

DWORD
QueryValue (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    );

VOID
SzToMultiSz (
    IN PWCH Sz,
    OUT PWCH *MultiSz,
    OUT PDWORD MultiSzLength
    );

DWORD
MakeUserdifr (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Creates the UserRun hive based on the changes made to the current user's
    profile directory and the HKEY_CURRENT_USER key.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY userrunKey;
    USERRUN_CONTEXT context;
    DWORD error;
    DWORD disposition;
    WCHAR userRunPath[MAX_PATH + 1];
    WCHAR userShipPath[MAX_PATH + 1];

    //
    // Merge UserShip with UserRun.
    //
    // If both UserRun and UserShip exist, merge into UserRun those build
    // keys from UserShip that do no exist in UserRun.
    //
    // If the UserRun hive file doesn't exist, this means that no
    // upgrade has ever been run on this machine.  Copy the UserShip
    // hive file into place as UserRun.  This effectively does the
    // registry merge by using a file copy.
    //
    // In the unlikely event that neither UserRun nor UserShip exists,
    // create an empty UserRun.
    //

    //
    // Initialize the context record.
    //

    context.UserRunLoaded = FALSE;
    context.UserRunKey = NULL;
    context.BuildKey = NULL;
    context.FilesKey = NULL;
    context.HiveKey = NULL;

    //
    // Enable SeBackupPrivilege and SeRestorePrivilege.
    //

    pSetupEnablePrivilege( SE_BACKUP_NAME, TRUE );
    pSetupEnablePrivilege( SE_RESTORE_NAME, TRUE );

    //
    // Check to see whether UserRun exists.
    //

    error = GetWindowsDirectory(userRunPath, MAX_PATH - ARRAYSIZE(USERRUN_PATH));
    if( error == 0) {
        MYASSERT(FALSE);
        return ERROR_PATH_NOT_FOUND;
    }
    wcscat( userRunPath, TEXT("\\") );
    wcscpy( userShipPath, userRunPath );
    wcscat( userRunPath, USERRUN_PATH );
    wcscat( userShipPath, USERSHIP_PATH );

    if ( FileExists( userRunPath, NULL ) ) {

        //
        // UserRun exists.  Load it into the registry.  Check to see whether
        // UserShip exists.
        //

        error = LoadUserRun( &context, userRunPath );
        if ( error == NO_ERROR ) {

            if ( FileExists( userShipPath, NULL ) ) {

                //
                // UserShip also exists.  Merge UserShip into UserRun.
                //

                error = MergeUserShipIntoUserRun( &context, userShipPath );

            } else {

                //
                // UserShip doesn't exist.  Just use the existing UserRun.
                //
            }
        }

    } else {

        //
        // UserRun doesn't exist.  If UserShip exists, just copy the UserShip
        // hive file into place as UserRun.  If neither one exists, create
        // an empty UserRun.
        //

        if ( FileExists( userShipPath, NULL ) ) {

            //
            // UserShip exists.  Copy UserShip into UserRun.
            //

            if ( !CopyFile( userShipPath, userRunPath, TRUE ) ) {
                error = GetLastError();

            } else {

                //
                // Load the new UserRun.
                //

                error = LoadUserRun( &context, userRunPath );
            }

        } else {

            //
            // UserShip doesn't exist.  Create an empty UserRun.
            //

            error = CreateAndLoadUserRun( &context, userRunPath );
        }
    }

    //
    // Add changes from this upgrade to UserRun.
    //

    if ( error == NO_ERROR ) {

        error = OpenUserRunKeys( &context );
        if ( error == NO_ERROR ) {
            error = WatchEnum( WatchHandle, &context, MakeUserRunEnumRoutine );
        }
    }

    //
    // Unload the UserRun hive.
    //

    UnloadUserRun( &context );

    return error;

} // MakeUserdifr

DWORD
LoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    )

/*++

Routine Description:

    Loads the UserRun hive into the registry and opens the root key.

Arguments:

    Context - pointer to context record.

    UserRunPath - supplies the path to the UserRun hive file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;

    //
    // Load the UserRun hive into the registry.
    //

    error = RegLoadKey( HKEY_USERS, USERRUN_KEY, UserRunPath );
    if ( error != NO_ERROR ) {
        return error;
    }

    Context->UserRunLoaded = TRUE;

    //
    // Open the UserRun root.
    //

    error = RegOpenKeyEx( HKEY_USERS,
                          USERRUN_KEY,
                          0,
                          KEY_READ | KEY_WRITE,
                          &Context->UserRunKey );

    return error;

} // LoadUserRun

DWORD
MergeUserShipIntoUserRun (
    IN OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserShipPath
    )

/*++

Routine Description:

    Merges the UserShip hive into the UserRun hive.

Arguments:

    Context - pointer to context record.

    UserShipPath - supplies the path to the UserShip file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;

    //
    // Load the UserShip hive into the registry.
    //

    error = RegLoadKey( HKEY_USERS, USERSHIP_KEY, UserShipPath );
    if ( error == NO_ERROR ) {

        //
        // Open the UserShip root.
        //

        error = RegOpenKeyEx( HKEY_USERS,
                              USERSHIP_KEY,
                              0,
                              KEY_READ | KEY_WRITE,
                              &Context->UserShipKey );
        if ( error == NO_ERROR ) {

            //
            // Enumerate the build number keys in UserShip, looking for
            // builds that aren't represented in UserRun.
            //

            error = EnumerateKey( Context->UserShipKey,
                                  Context,
                                  NULL,     // don't enumerate values
                                  CheckUserShipKey );

            //
            // Close the UserShip root.
            //

            RegCloseKey( Context->UserShipKey );
        }

        //
        // Unload the UserShip hive.
        //

        RegUnLoadKey( HKEY_USERS, USERSHIP_KEY );
    }

    return error;

} // MergeUserShipIntoUserRun

DWORD
CreateAndLoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    )

/*++

Routine Description:

    Create a new UserRun hive and load it into the registry.

Arguments:

    Context - pointer to context record.

    UserRunPath - supplies the path to the UserRun file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;
    HKEY userRunKey;

    //
    // Create the UserRun key under HKEY_CURRENT_USER.
    //
    // NOTE: Trying to create this under HKEY_USERS doesn't work.
    //

    error = RegCreateKeyEx( HKEY_CURRENT_USER,
                            USERRUN_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &userRunKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Save the newly created UserRun key to a hive file.
    //

    error = RegSaveKey( userRunKey,
                        UserRunPath,
                        NULL );

    //
    // Close and delete the UserRun key.
    //

    RegCloseKey( userRunKey );

    RegDeleteKey( HKEY_CURRENT_USER, USERRUN_KEY );

    //
    // Now load UserRun back into the registry.
    //

    if ( error == NO_ERROR ) {
        error = LoadUserRun( Context, UserRunPath );
    }

    return error;

} // CreateAndLoadUserRun

DWORD
OpenUserRunKeys (
    IN OUT PUSERRUN_CONTEXT Context
    )

/*++

Routine Description:

    Opens the core keys in the UserRun hive.

Arguments:

    Context - pointer to context record.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;
    OSVERSIONINFO versionInfo;
    WCHAR buildNumber[12];

    //
    // Get the current build number.
    //

    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( !GetVersionEx( &versionInfo ) ) {
        return GetLastError();
    }

    wsprintf( buildNumber, TEXT("%d"), LOWORD(versionInfo.dwBuildNumber) );

    //
    // Open/create a subkey for the current build.
    //

    error = RegCreateKeyEx( Context->UserRunKey,
                            buildNumber,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->BuildKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Create a Files subkey.
    //

    error = RegCreateKeyEx( Context->BuildKey,
                            FILES_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->FilesKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Create a Hive subkey.
    //

    error = RegCreateKeyEx( Context->BuildKey,
                            HIVE_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->HiveKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Set the FilesIndex and HiveIndex so that we append to whatever
    // information already exists for the current build.
    //

    error = RegQueryInfoKey( Context->FilesKey,
                             NULL,
                             NULL,
                             NULL,
                             &Context->FilesIndex,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );
    if ( error != NO_ERROR ) {
        return error;
    }

    error = RegQueryInfoKey( Context->HiveKey,
                             NULL,
                             NULL,
                             NULL,
                             &Context->HiveIndex,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    return error;

} // OpenUserRunKeys

VOID
UnloadUserRun (
    IN OUT PUSERRUN_CONTEXT Context
    )

/*++

Routine Description:

    Unloads the UserRun hive from the registry.

Arguments:

    Context - pointer to context record.

Return Value:

    None.

--*/

{
    //
    // Close the core keys, if they are open.
    //

    if ( Context->HiveKey != NULL ) {
        RegCloseKey( Context->HiveKey );
    }
    if ( Context->FilesKey != NULL ) {
        RegCloseKey( Context->FilesKey );
    }
    if ( Context->BuildKey != NULL ) {
        RegCloseKey( Context->BuildKey );
    }

    //
    // Close the root key, if it is open.
    //

    if ( Context->UserRunKey != NULL ) {
        RegCloseKey( Context->UserRunKey );
    }

    //
    // Unload the hive, if it has been loaded.
    //

    if ( Context->UserRunLoaded ) {
        RegUnLoadKey( HKEY_USERS, USERRUN_KEY );
    }

    return;

} // UnloadUserRun

DWORD
CheckUserShipKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Checks an enumerated key in the UserShip hive to see if a corresponding
    key is present in the UserRun hive.  If not, copies the key from UserShip
    into UserRun.

Arguments:

    Context - pointer to context record.

    KeyNameLength - length in characters of key name.

    KeyName - pointer to name of key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PUSERRUN_CONTEXT context = Context;

    DWORD error;
    DWORD disposition;
    HKEY userRunBuildKey;
    HKEY userShipBuildKey;
    WCHAR path[MAX_PATH + 1];

    //
    // We have the name of a key in UserShip.  Try to open the
    // corresponding key in UserRun.
    //

    error = RegCreateKeyEx( context->UserRunKey,
                            KeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &userRunBuildKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // No error occurred.  The key was either opened or created.
    //

    if ( disposition == REG_OPENED_EXISTING_KEY ) {

        //
        // The key already existed in UserRun.  We assume that it already
        // contains the information that is in UserShip.
        //

    } else {

        //
        // The key didn't exist in UserRun.  Copy the key from UserShip
        // into UserRun.  This is done by saving the UserShip key to
        // a file, then restoring the file back under the UserRun key.
        //
        // Note that the copy operation will fail if the file already
        // exists.
        //

        error = RegOpenKeyEx( context->UserShipKey,
                              KeyName,
                              0,
                              KEY_READ,
                              &userShipBuildKey );
        if ( error == NO_ERROR ) {

            if(!GetWindowsDirectory( path, MAX_PATH - ARRAYSIZE(USERTMP_PATH))){
                MYASSERT(FALSE);
            }
            wcscat( path, TEXT("\\") );
            wcscat( path, USERTMP_PATH );

            error = RegSaveKey( userShipBuildKey,
                                path,
                                NULL );
            if ( error == NO_ERROR ) {

                error = RegRestoreKey( userRunBuildKey,
                                       path,
                                       0 );

                DeleteFile( path );
            }

            RegCloseKey( userShipBuildKey );
        }
    }

    //
    // Close the UserRun key.
    //

    RegCloseKey( userRunBuildKey );

    return error;

} // CheckUserShipKey

DWORD
MakeUserRunEnumRoutine (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    )

/*++

Routine Description:

    EnumRoutine for the MakeUserdifr operation.  Calls the appropriate
    processing routine based on the entry type (file/directory/key/value)
    and the change type (changed, new, deleted).

Arguments:

    Context - context value passed to WatchEnum.

    Entry - description of the changed entry.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PUSERRUN_CONTEXT context = Context;
    DWORD index;
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Call the appropriate processing routine.
    //

    switch ( Entry->EntryType ) {

    case WATCH_DIRECTORY:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
            dprintf( 1, ("New directory %ws\n", Entry->Name) );
            error = MakeAddDirectory( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted directory %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 2, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_FILE:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
        case WATCH_CHANGED:
            dprintf( 1, ("New or changed file %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 3, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted file %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 4, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_KEY:
        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
            dprintf( 1, ("New key %ws\n", Entry->Name) );
            error = MakeAddKey( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted key %ws\n", Entry->Name) );
            error = MakeDeleteKey( Context, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_VALUE:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
        case WATCH_CHANGED:
            dprintf( 1, ("New or changed value %ws\n", Entry->Name) );
            error = MakeAddValue( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted value %ws\n", Entry->Name) );
            error = MakeDeleteValue( Context, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    default:

        error = ERROR_INVALID_PARAMETER;
    }

    return error;

} // MakeUserRunEnumRoutine

DWORD
MakeAddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds entries to the UserRun hive for a new directory.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new directory (relative to root of watched tree).


Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    WCHAR fullpath[MAX_PATH + 1];
    PWCH path;
    BOOL ok;

    //
    // Get the full path to the new directory.  "fullpath" is the full path;
    // "path" is just this directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, fullpath );
    if ( !ok ) {
        return GetLastError();
    }

    if((wcslen(fullpath) + wcslen(Name) + 1 /* the backslash */ ) >= ARRAYSIZE(fullpath)){
        return ERROR_INSUFFICIENT_BUFFER;
    }

    wcscat( fullpath, TEXT("\\") );
    path = fullpath + wcslen(fullpath);
    wcscpy( path, Name );

    //
    // Call AddDirectory to do the recursive work.
    //

    return AddDirectory( Context, fullpath, path );

} // MakeAddDirectory

DWORD
MakeAddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a new value.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new value (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    PWCH keyName;
    PWCH valueName;
    PWCH splitPoint;
    DWORD valueType;
    PVOID valueData;
    DWORD valueDataLength;
    DWORD error;
    DWORD dword;

    //
    // Split the name into key and value portions.
    //

    splitPoint = wcsrchr( Name, TEXT('\\') );
    if ( splitPoint != NULL ) {
        keyName = Name;
        valueName = splitPoint + 1;
        *splitPoint = 0;
    } else {
        keyName = NULL;
        valueName = Name;
    }

    //
    // Query the value data.
    //

    valueData = NULL;
    error = QueryValue( keyName, valueName, &valueType, &valueData, &valueDataLength );

    //
    // Add an entry for the value.
    //

    if ( error == NO_ERROR ) {
        error = AddValue( Context, keyName, valueName, valueType, valueData, valueDataLength );
    }

    //
    // Free the value data buffer allocated by QueryValue.
    //

    if ( valueData != NULL ) {
        MyFree( valueData );
    }

    //
    // Restore the input value name string.
    //

    if ( splitPoint != NULL ) {
        *splitPoint = TEXT('\\');
    }

    return error;

} // MakeAddValue

DWORD
MakeDeleteValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a deleted value.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of deleted value (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    PWCH keyName;
    PWCH valueName;
    PWCH valueNames;
    PWCH splitPoint;
    DWORD valueNamesLength;
    DWORD error;
    DWORD dword;

    error = NO_ERROR;

    //
    // Split the name into key and value portions.  Create a MULTI_SZ
    // version of the deleted name (to match userdiff format).
    //

    splitPoint = wcsrchr( Name, TEXT('\\') );
    if ( splitPoint != NULL ) {
        keyName = Name;
        valueName = splitPoint + 1;
        *splitPoint = 0;
    } else {
        keyName = NULL;
        valueName = Name;
    }

    SzToMultiSz( valueName, &valueNames, &valueNamesLength );
    if ( valueNames == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    if ( error == NO_ERROR ) {
        error = CreateUserRunKey( Context, FALSE, &newKey );
    }

    if ( error == NO_ERROR ) {
        dword = 4;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)keyName, SZLEN(keyName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUENAMES_VALUE, 0, REG_MULTI_SZ, (PBYTE)valueNames, valueNamesLength );
    }
    if ( error == NO_ERROR ) {
        if ( *valueNames == 0 ) {
            dword = 1;
            error = RegSetValueEx( newKey, FLAGS_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
        }
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    //
    // Free the buffer allocated by SzToMultiSz.
    //

    if ( valueNames != NULL ) {
        MyFree( valueNames );
    }

    //
    // Restore the input value name string.
    //

    if ( splitPoint != NULL ) {
        *splitPoint = TEXT('\\');
    }

    return error;

} // MakeDeleteValue

DWORD
MakeAddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds entries to the UserRun hive for a new key.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new key (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    WCHAR path[MAX_PATH + 1];

    //
    // Copy the key name into a large buffer and call AddKey to do the
    // recursive work.
    //

    wcscpy( path, Name );
    return AddKey( Context, path );

} // MakeAddKey

DWORD
MakeDeleteKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a deleted key.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of deleted key (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 2;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)Name, SZLEN(Name) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // MakeDeleteKey

DWORD
AddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH FullPath,
    IN PWCH Path
    )

/*++

Routine Description:

    Recursively adds entries to the UserRun hive for a new directory
    and its subtree.

Arguments:

    Context - context value passed to WatchEnum.

    FullPath - full path to directory.

    Path - path to directory relative to root of watched directory.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;
    HANDLE findHandle;
    WIN32_FIND_DATA fileData;
    BOOL ok;

    //
    // Create an entry key for the directory and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, TRUE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 1;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ITEM_VALUE, 0, REG_SZ, (PBYTE)Path, SZLEN(Path) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    if ( error == NO_ERROR ) {

        //
        // Search the directory and add file and directory entries.
        //

        wcscat( Path, TEXT("\\*") );
        findHandle = FindFirstFile( FullPath, &fileData );
        Path[wcslen(Path) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                //
                // Append the name of the current directory entry to the path.
                //

                wcscat( Path, TEXT("\\") );
                wcscat( Path, fileData.cFileName );

                //
                // If the current entry is a file, add an entry in UserRun
                // for it.  If the current entry is a directory, call
                // AddDirectory recursively to process it.
                //

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {
                    error = CreateUserRunSimpleFileKey( Context, 3, Path );
                } else if ((wcscmp(fileData.cFileName,TEXT(".")) != 0) &&
                           (wcscmp(fileData.cFileName,TEXT("..")) != 0)) {
                    error = AddDirectory( Context, FullPath, Path );
                }

                *wcsrchr( Path, TEXT('\\') ) = 0;

                if ( error == NO_ERROR ) {
                    ok = FindNextFile( findHandle, &fileData );
                }

            } while ( (error == NO_ERROR) && ok );

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

    }

    return error;

} // AddDirectory

DWORD
AddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Path
    )

/*++

Routine Description:

    Recursively adds entries to the UserRun hive for a new key
    and its subtree.

Arguments:

    Context - context value passed to WatchEnum.

    Path - path to key relative to HKEY_CURRENT_USER.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;
    HKEY findHandle;
    KEY_ENUM_CONTEXT enumContext;

    //
    // Create an entry key for the key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 1;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)Path, SZLEN(Path) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    if ( error == NO_ERROR ) {

        //
        // Search the key and add value and key entries.
        //

        findHandle = NULL;

        error = RegOpenKeyEx( HKEY_CURRENT_USER,
                              Path,
                              0,
                              KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                              &findHandle );
        if ( error == NO_ERROR ) {

            //
            // Enumerate the values and subkeys of the key, adding entries
            // to the UserRun hive for each one.
            //

            enumContext.UserRunContext = Context;
            enumContext.CurrentPath = Path;
            error = EnumerateKey( findHandle,
                                  &enumContext,
                                  AddValueDuringAddKey,
                                  AddKeyDuringAddKey );

            RegCloseKey( findHandle );
        }
    }

    return error;

} // AddKey

DWORD
AddValueDuringAddKey (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds a value entry to UserRun during AddKey.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;

    //
    // Add the value entry to UserRun.
    //

    return AddValue( context->UserRunContext,
                     context->CurrentPath,
                     ValueName,
                     ValueType,
                     ValueData,
                     ValueDataLength );

} // AddValueDuringAddKey

DWORD
AddKeyDuringAddKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Adds a key entry to UserRun during AddKey.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    DWORD error;

    //
    // Append the key name to the path and call AddKey to do the
    // recursive work.
    //

    if( (wcslen( context->CurrentPath) + wcslen(TEXT("\\")) + wcslen(KeyName) ) < MAX_PATH) {
        wcscat( context->CurrentPath, TEXT("\\") );
        wcscat( context->CurrentPath, KeyName );
        error = AddKey( context->UserRunContext, context->CurrentPath );
    
        //
        // Remove the key name from the path.
        //
    
        *wcsrchr( context->CurrentPath, TEXT('\\') ) = 0;
    } else {
        error = ERROR_INVALID_PARAMETER;
    }

    return error;

} // AddKeyDuringAddKey

DWORD
AddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds an entry for a new value to UserRun.

Arguments:

    Context - pointer to context record.

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Create an entry key for the value and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 3;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)KeyName, SZLEN(KeyName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUENAME_VALUE, 0, REG_SZ, (PBYTE)ValueName, SZLEN(ValueName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUE_VALUE, 0, ValueType, (PBYTE)ValueData, ValueDataLength );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // AddValue

DWORD
CreateUserRunSimpleFileKey (
    IN PUSERRUN_CONTEXT Context,
    IN DWORD Action,
    IN PWCH Name
    )

/*++

Routine Description:

    Creates an entry under the Files key for the "simple" cases -- delete
    directory, add file, delete file.

Arguments:

    Context - pointer to context record.

    Action - value to store in Action value of entry.

    Name - pointer to name of the file or directory.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, TRUE, &newKey );

    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&Action, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ITEM_VALUE, 0, REG_SZ, (PBYTE)Name, SZLEN(Name) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // CreateUserRunSimpleFileKey

DWORD
CreateUserRunKey (
    IN PUSERRUN_CONTEXT Context,
    IN BOOL IsFileKey,
    OUT PHKEY NewKeyHandle
    )

/*++

Routine Description:

    Creates an indexed key in UserRun, under either the Files key or the
    Hive key.

Arguments:

    Context - pointer to context record.

    IsFileKey - indicates whether to create the key under Files or Hive.

    NewKeyHandle - returns the handle to the new key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY parentKeyHandle;
    DWORD index;
    WCHAR keyName[11];
    DWORD disposition;

    //
    // Get the handle to the parent key and the index for this entry.
    //

    if ( IsFileKey ) {
        parentKeyHandle = Context->FilesKey;
        index = ++Context->FilesIndex;
    } else {
        parentKeyHandle = Context->HiveKey;
        index = ++Context->HiveIndex;
    }

    //
    // Convert the index number into a string.
    //

    wsprintf( keyName, TEXT("%d"), index );

    //
    // Create the entry key.
    //

    return RegCreateKeyEx( parentKeyHandle,
                           keyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           NewKeyHandle,
                           &disposition );

} // CreateUserRunKey

DWORD
QueryValue (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    )

/*++

Routine Description:

    Queries the data for a value.

Arguments:

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - returns the type of the value data.

    ValueData - returns a pointer to value data.  This buffer must be
        freed by the caller using MyFree.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY hkey;
    DWORD disposition;
    DWORD error;

    //
    // Open the parent key.
    //

    if ( (KeyName == NULL) || (wcslen(KeyName) == 0) ) {
        hkey = HKEY_CURRENT_USER;
    } else {
        error = RegCreateKeyEx( HKEY_CURRENT_USER,
                                KeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkey,
                                &disposition );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    //
    // Query the value to get the length of its data.
    //

    *ValueDataLength = 0;
    *ValueData = NULL;
    error = RegQueryValueEx( hkey,
                             ValueName,
                             NULL,
                             ValueType,
                             NULL,
                             ValueDataLength );

    //
    // Allocate a buffer to hold the value data.
    //

    if ( error == NO_ERROR ) {
        *ValueData = MyMalloc( *ValueDataLength );
        if ( *ValueData == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Query the value again, this time retrieving the data.
    //

    if ( error == NO_ERROR ) {
        error = RegQueryValueEx( hkey,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 *ValueData,
                                 ValueDataLength );
        if ( error != NO_ERROR ) {
            MyFree( *ValueData );
        }
    }

    //
    // Close the parent key.
    //

    if ( hkey != HKEY_CURRENT_USER ) {
        RegCloseKey( hkey );
    }

    return error;
}

VOID
SzToMultiSz (
    IN PWCH Sz,
    OUT PWCH *MultiSz,
    OUT PDWORD MultiSzLength
    )

/*++

Routine Description:

    Creates a MULTI_SZ version of a null-terminated string.  Allocates
    a buffer, copies the string to the buffer, and appends an additional
    null terminator.

Arguments:

    Sz - pointer to the string that is to be copied.

    MultiSz - returns a pointer to the MULTI_SZ version of Sz.  The caller
        must free this buffer using MyFree.  If the allocation fails,
        MultiSz will be NULL.

    MultiSzLength - returns the length in bytes of MultiSz, including the
        null terminators.

Return Value:

    None.

--*/

{
    DWORD szlen;

    //
    // Get the length of the input string and calculate the MULTI_SZ length.
    //

    szlen = wcslen(Sz);
    *MultiSzLength = (szlen + 1 + 1) * sizeof(WCHAR);

    //
    // Allocate the MULTI_SZ buffer, copy the input string, and append
    // an additional null.
    //

    *MultiSz = MyMalloc( *MultiSzLength );
    if ( *MultiSz != NULL ) {
        wcscpy( *MultiSz, Sz );
        (*MultiSz)[szlen+1] = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\utils.cpp ===
#include "setupp.h"
#include <activation.h>
#include <LAModes.h>
#include <licdll.h>
#pragma hdrstop


extern "C"
BOOL Activationrequired(VOID)
{
    DWORD Status = ERROR_SUCCESS;
    HRESULT hr;
    DWORD WPADaysLeft = -1;
    DWORD EvalDaysLeftDontCare = 0;
    ICOMLicenseAgent*   pLicenseAgent;
    BOOL bActivcationRequired = TRUE;

    SetupDebugPrint( L"Setup: Activationrequired" );
    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        //CoCreate LicenseAgent
        if(SUCCEEDED(hr = CoCreateInstance(__uuidof(COMLicenseAgent),
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   __uuidof(ICOMLicenseAgent),
                                   (LPVOID*)&pLicenseAgent)))
        {
            pLicenseAgent->Initialize(
                WINDOWSBPC,
                LA_MODE_ONLINE_CH,
                NULL,
                &Status
                );

            if ( Status == ERROR_SUCCESS ) {

                hr = pLicenseAgent->GetExpirationInfo(
                        &WPADaysLeft,
                        &EvalDaysLeftDontCare
                        );
                if (SUCCEEDED(hr))
                {
                    bActivcationRequired = (WPADaysLeft != INT_MAX);
                }
                else
                {
                    SetupDebugPrint2( L"Setup: LicenseAgent->GetExpirationInfo hr =0x%lx WPADaysLeft=%d", hr, WPADaysLeft);
                }
            }
            else
            {
                SetupDebugPrint1( L"Setup: LicenseAgent->Initialize status = %d", Status);
            }
            pLicenseAgent->Release();
            pLicenseAgent = NULL;
        }
        else
        {
            SetupDebugPrint1( L"Setup: CoCreateInstance failed. hr=0x%lx", hr );
        }
        CoUninitialize();
    }
    return bActivcationRequired;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\watch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    watch.h

Abstract:

    Header file for watch.c

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// Enumerated entry types.
//

#define WATCH_DIRECTORY 1
#define WATCH_FILE      2
#define WATCH_KEY       3
#define WATCH_VALUE     4

//
// Enumerated change types.
//

#define WATCH_CHANGED   1
#define WATCH_DELETED   2
#define WATCH_NEW       3

//
// Structure describing an enumerated change.
//

typedef struct _WATCH_ENTRY {
    PWCH Name;
    DWORD EntryType;
    DWORD ChangeType;
} WATCH_ENTRY, *PWATCH_ENTRY;

//
// USERPROFILE is the name of the environment variable that contains
// the path the user's profile directory.
//

#define USERPROFILE TEXT("USERPROFILE")

//
// Macros for mask manipulation.
//

#define FlagOn(_mask,_flag)  (((_mask) & (_flag)) != 0)
#define FlagOff(_mask,_flag) (((_mask) & (_flag)) == 0)
#define SetFlag(_mask,_flag) ((_mask) |= (_flag))
#define ClearFlag(_mask,_flag) ((_mask) &= ~(_flag))

//
// Routines exported by watch.c
//

DWORD
WatchStart (
    OUT PVOID *WatchHandle
    );

DWORD
WatchStop (
    IN PVOID WatchHandle
    );

VOID
WatchFree (
    IN PVOID WatchHandle
    );

typedef
DWORD
(* PWATCH_ENUM_ROUTINE) (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    );

DWORD
WatchEnum (
    IN PVOID WatchHandle,
    IN PVOID Context,
    IN PWATCH_ENUM_ROUTINE EnumRoutine
    );

typedef
DWORD
(* PVALUE_ENUM_ROUTINE) (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

typedef
DWORD
(* PKEY_ENUM_ROUTINE) (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
EnumerateKey (
    IN HKEY KeyHandle,
    IN PVOID Context,
    IN PVALUE_ENUM_ROUTINE ValueEnumRoutine OPTIONAL,
    IN PKEY_ENUM_ROUTINE KeyEnumRoutine OPTIONAL
    );

BOOL
GetSpecialFolderPath (
    IN INT csidl,
    IN LPWSTR lpPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\virtmem.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    virtmem.c

Abstract:

    Routines to configure and set up virtual memory -- pagefiles, etc.

Author:

    Ted Miller (tedm) 22-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// What's the ratio of 'beginning' pagefile size to 'max' pagefile size?
//
#define MAX_PAGEFILE_RATIO          (2)

#define MAX_PAGEFILE_SIZEMB         ((2*1024) - 2)

#define TINY_WINDIR_PAGEFILE_SIZE   (2)

#define MIN_PAGEFILE_STRING_LEN     (5)
//
//  Keys and values names
//
#define  szMemoryManagementKeyPath  L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define  szPageFileValueName        L"PagingFiles"
#define  szSetupPageFileKeyPath     L"SYSTEM\\Setup\\PageFile"
#define  szSetupKey                 L"SYSTEM\\Setup"
#define  szPageFileKeyName          L"PageFile"


WCHAR ExistingPagefileDrive = 0;
BOOL  LeaveExistingPagefile = FALSE;
DWORD Zero = 0;
DWORD One = 1;
DWORD Two = 2;
DWORD Three = 3;

//
// Keep AutoReboot as the last entry as we won't be updating that key on
// upgrades.  This is for Stress so we quit setting this key on each upgrade.
//
REGVALITEM CrashDumpValues[] = {{ L"LogEvent"        ,&One,sizeof(DWORD),REG_DWORD },
                                { L"SendAlert"       ,&One,sizeof(DWORD),REG_DWORD },
                                { L"CrashDumpEnabled",&One,sizeof(DWORD),REG_DWORD },
                                { L"AutoReboot"      ,&One,sizeof(DWORD),REG_DWORD }};

VOID
LOGITEM(
    IN PCWSTR p,
    ...
    )
{
    WCHAR str[1024];
    va_list arglist;

    va_start(arglist,p);
    wvsprintf(str,p,arglist);
    va_end(arglist);

    //
    // Used to debug problem on MIPS that was the result of a chip
    // errata, when dividing 64 bit numbers with multiplies pending.
    //
    SetuplogError(
        LogSevInformation,str,0,NULL,NULL);
}


VOID
RemoveSavedPagefileSetting(
    VOID
    )
/*++

Routine Description:

    Delete our record of what the user was previously using
    for a pagefile.
    
--*/    
{
    HKEY        Key;
    
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szSetupKey,
                                        0,
                                        MAXIMUM_ALLOWED,
                                        &Key ))
    {
        RegDeleteKey( Key, szPageFileKeyName );
        RegCloseKey( Key );
    }
}

BOOL
MultiplePagefileSizes( 
    IN PWCHAR pwzData,
    OUT PDWORD totalsize
    )

/*++

Routine Description:

    Calculate the sum off all pagefile sizes.

Arguments:

    pwsData - multi_sz data read from the registry.

    totalsize - receives the sum of all pagefiles.

Return Value:

    TRUE - if this was a multistring and formatted corretly, total size will then contain the sum.
    FALSE - badly formated or not multiple pagefiles.

--*/

{
    PWCHAR pstr = NULL;
    DWORD numPagefiles = 0;
    WCHAR PagefileDrive = 0;


    if( !pwzData || !pwzData[0] || !totalsize) {
        return FALSE;
    }

    *totalsize = 0;
    pstr = pwzData;

    while( pstr[0]) {
        if( wcsstr( pstr, TEXT(" ") ) ) {
            PagefileDrive = towupper( (WCHAR)pstr[0] );
    
            // Not valid drive letter!
            if( (PagefileDrive > 'Z') ||
                (PagefileDrive < 'A') ) {
                return FALSE;
            }

            *totalsize += (int)wcstoul(wcsstr( pstr, TEXT(" ") ),NULL,10);
            pstr += (wcslen(pstr) +1);
            
            numPagefiles++;
        }
        else {
            //Invalid format
            return FALSE;
        }
    }
    return (numPagefiles > 1);
}

BOOL
RestoreOldPagefileSettings( 
    VOID
    )
/*++

Routine Description:

    Copies, the pagefile saved during textmode setup to the correct loaction.
    So from HKLM\SYSTEM\Setup\PageFile 
    to HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management.

Arguments:

Return Value:

    TRUE - Successfully restored the user's pagefile settings
    FALSE - Failed to restore settings.

--*/

{
    LONG        Error;
    HKEY        Key;
    DWORD       cbData;
    PWCHAR      Data=NULL;
    DWORD       Type;

    //
    //  Get the original page file info from
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szSetupPageFileKeyPath,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        goto c0;
    }
    //  Find out the size of the data to be retrieved
    //
    cbData = 0;
    Error = RegQueryValueEx( Key,
                             szPageFileValueName,
                             0,
                             NULL,
                             NULL,
                             &cbData );

    if( Error != ERROR_SUCCESS || (cbData/sizeof(WCHAR)) < MIN_PAGEFILE_STRING_LEN ) {
        goto c2;
    }
    //  Allocate a buffer for the data, and retrieve the data
    //

    Data = (PWCHAR)MyMalloc(cbData+2*sizeof(WCHAR));
    if( !Data ) {
        goto c2;
    }

    Error = RegQueryValueEx( Key,
                             szPageFileValueName,
                             0,
                             &Type,
                             ( LPBYTE )Data,
                             &cbData );
    if( (Error != ERROR_SUCCESS) ) {
        goto c2;
    }


    // Make sure it's doubly null terminated
    Data[cbData/2] = 0;
    Data[cbData/2+1] = 0;

    if( Data[cbData/2-1] != 0) {
        cbData += (2*sizeof(WCHAR));
    } else if( Data[cbData/2-2] != 0) {
        cbData += sizeof(WCHAR);
    }

    RegCloseKey( Key);
    // Now open key for write
    Error = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            szMemoryManagementKeyPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &Key,
                            NULL );

    if( Error != ERROR_SUCCESS) {
        goto c1;
    }
    
    Error = RegSetValueEx(  Key,
                            szPageFileValueName,
                            0,
                            REG_MULTI_SZ,
                            (PVOID)Data,
                            cbData);
    if( Error != ERROR_SUCCESS) {
        goto c2;
    }
    return TRUE;
c2:
    RegCloseKey( Key);
c1:
    if( Data) {
        MyFree( Data);
    }
c0:
    return FALSE;
}

VOID
CalculatePagefileSizes(
    OUT PDWORD PagefileMinMB,
    OUT PDWORD RecommendedPagefileMB,
    OUT PDWORD CrashDumpPagefileMinMB
    )

/*++

Routine Description:

    Calculate various key sizes relating to pagefile size.

Arguments:

    PagefileMinMB - receives the minimum recommended size for a pagefile,
        in MB.

    RecommendedPagefileMB - receives the recommended size for a pagefile,
        in MB.

    CrashDumpPagefileMinMB - receives the size in MB for a pagefile to be
        used for crashdumps.

Return Value:

    None.

--*/

{
    MEMORYSTATUSEX MemoryStatusEx;
    SYSTEM_INFO SystemInfo;
    DWORD       AvailableMB;

    MemoryStatusEx.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&MemoryStatusEx);
    GetSystemInfo(&SystemInfo);

    //
    // Figure out how much memory we have available.
    //
    AvailableMB = (DWORD)(MemoryStatusEx.ullTotalPhys / (1024*1024));

    //
    // It's likely that our calculation is off because the BIOS may
    // be eat part of our first MB.  Let's make sure we're mod-4.
    //
    AvailableMB = (AvailableMB + 3) & (0xFFFFFFF8);

    //
    // Set minimum acceptable size for the pagefile.
    //
    *PagefileMinMB = 48;

    //
    // Min size for crash dump pagefile is also physical memory+12mb.
    //
    *CrashDumpPagefileMinMB = AvailableMB + 12;

    //
    // Calculate the recommended size for the pagefile.
    // The recommended size is (memory size * 1.5)mb.
    //
    *RecommendedPagefileMB = AvailableMB + (AvailableMB >> 1);

#if 1
    //
    // Set a Maximum of 2Gig.
    //
    if( *RecommendedPagefileMB > MAX_PAGEFILE_SIZEMB ) {
        *RecommendedPagefileMB = MAX_PAGEFILE_SIZEMB;
    }
#endif

    //
    // If we're doing an upgrade, we're going to retrieve what
    // the user was using for a pagefile size.  We'll take the
    // max of our RecommendedPagefileMB and what the user had.
    //
    if(Upgrade) {
        LONG        Error;
        HKEY        Key;
        DWORD       cbData;
        PWCHAR      Data;
        DWORD       Type;

        //
        //  Get the original page file info from
        //  HKEY_LOCAL_MACHINE\SYSTEM\Setup\PageFile
        //
        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szSetupPageFileKeyPath,
                              0,
                              KEY_READ,
                              &Key );

        if( Error == ERROR_SUCCESS ) {
            //
            //  Find out the size of the data to be retrieved
            //
            cbData = 0;
            Error = RegQueryValueEx( Key,
                                     szPageFileValueName,
                                     0,
                                     NULL,
                                     NULL,
                                     &cbData );

            if( Error == ERROR_SUCCESS ) {
                //
                //  Allocate a buffer for the data, and retrieve the data
                //

                Data = (PWCHAR)MyMalloc(cbData+(2*sizeof(WCHAR)));
                if( Data ) {
                    Error = RegQueryValueEx( Key,
                                             szPageFileValueName,
                                             0,
                                             &Type,
                                             ( LPBYTE )Data,
                                             &cbData );
                    if( (Error == ERROR_SUCCESS) ) {
                        //
                        // We got the data.  Take the bigger value.
                        //

                        //Make sure string is double null terminated.
                        Data[cbData/2] = 0;
                        Data[cbData/2+1] = 0;


                        if( wcsstr( Data, TEXT(" ") ) ) {
                            DWORD ExistingPageFileSize = 0;

                            if( MultiplePagefileSizes( Data, &ExistingPageFileSize) && ExistingPageFileSize >= *RecommendedPagefileMB ) {
                                LeaveExistingPagefile = TRUE;
                                ExistingPagefileDrive = towupper( (WCHAR)Data[0] ); // points to first one in multstring
                            } else {
                                // We are here because user originally had one pagefile or the sum of all pagefiles was less the the recommended
                                ExistingPageFileSize = (int)wcstoul(wcsstr( Data, TEXT(" ") ),NULL,10);
                                if( ExistingPageFileSize >= *RecommendedPagefileMB ) {
                                    //
                                    // The user has a bigger pagefile than we think he needs.
                                    // Assume he knows better and take the bigger value.
                                    //
                                    *RecommendedPagefileMB = ExistingPageFileSize;
    
                                    //
                                    // Remember his drive letter too.  This tells us that
                                    // the user may already have a decent pagefile and
                                    // we don't need to mess with it.
                                    //
                                    ExistingPagefileDrive = towupper( (WCHAR)Data[0] );
    
                                    //
                                    // If it's not valid, nuke the flag.
                                    //
                                    if( (ExistingPagefileDrive > 'Z') ||
                                        (ExistingPagefileDrive < 'A') ) {
                                        ExistingPagefileDrive = 0;
                                    }
    
                                }
                            }
                        }
                    }

                    MyFree( Data );
                }
            }

            RegCloseKey( Key );
        }

    }

}


VOID
BuildVolumeFreeSpaceList(
    OUT DWORD VolumeFreeSpaceMB[26]
    )

/*++

Routine Description:

    Build a list of free space available on each hard drive in the system.

    The space will include space taken up by a file called \pagefile.sys
    on each drive. Existing pagefiles are marked for deletion on the next boot.

Arguments:
    VolumeFreeSpaceMB - receives free space for each of the 26 drives
        potentially describable in the drive letter namespace.
        Entries for drives that do not exist are left alone, so the caller
        should zero out the array before calling this routine.

Return Value:

    None.

--*/

{
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD FreeClusters;
    DWORD TotalClusters;
    DWORD d;
    PWCHAR p;
    ULONGLONG FreeSpace;
    INT DriveNo;
    WIN32_FIND_DATA FindData;
    WCHAR Filename[] = L"?:\\pagefile.sys";
    //
    // Space for logical drive strings. Each is x:\ + nul, and
    // there is an extra nul terminating the list.
    //
    WCHAR Buffer[(26*4)+1];

    //
    // Build up a list of free space on each available hard drive.
    //
    d = GetLogicalDriveStrings(sizeof(Buffer)/sizeof(Buffer[0]),Buffer);
    d = min( d, sizeof(Buffer)/sizeof(Buffer[0]));
    CharUpperBuff(Buffer,d);

    for(p=Buffer; *p; p+=lstrlen(p)+1) {

        DriveNo = (*p) - L'A';

        if((DriveNo >= 0) && (DriveNo < 26) && (p[1] == L':')
        && (MyGetDriveType(*p) == DRIVE_FIXED)
        && GetDiskFreeSpace(p,&SectorsPerCluster,&BytesPerSector,&FreeClusters,&TotalClusters)) {

            LOGITEM(
                L"BuildVolumeFreeSpaceList: %s, spc=%u, bps=%u, freeclus=%u, totalclus=%u\r\n",
                p,
                SectorsPerCluster,
                BytesPerSector,
                FreeClusters,
                TotalClusters
                );

            FreeSpace = UInt32x32To64(BytesPerSector * SectorsPerCluster, FreeClusters);

            LOGITEM(
                L"BuildVolumeFreeSpaceList: %s, FreeSpace = %u%u\r\n",
                p,
                (DWORD)(FreeSpace >> 32),
                (DWORD)FreeSpace
                );


            //
            // If there's already a page file here, include its size in the free space
            // for the drive. Delete the existing pagefile on the next reboot.
            //
            Filename[0] = *p;
            if(FileExists(Filename,&FindData)) {
                FreeSpace += FindData.nFileSizeLow;

                LOGITEM(
                    L"BuildVolumeFreeSpaceList: %s had %u byte pagefile, new FreeSpace = %u%u\r\n",
                    p,
                    FindData.nFileSizeLow,
                    (DWORD)(FreeSpace >> 32),
                    (DWORD)FreeSpace
                    );

                MoveFileEx(Filename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }

            VolumeFreeSpaceMB[DriveNo] = (DWORD)(FreeSpace / (1024*1024));

            LOGITEM(L"BuildVolumeFreeSpaceList: Free space on %s is %u MB\r\n",p,VolumeFreeSpaceMB[DriveNo]);
        }
    }
}


BOOL
SetUpVirtualMemory(
    VOID
    )

/*++

Routine Description:

    Configure a pagefile. If setting up a server, we attempt to set up a pagefile
    suitable for use with crashdump, meaning it has to be at least the size of
    system memory, and has to go on the nt drive. Otherwise we attempt to place
    a pagefile on the nt drive if there's enough space, and if that fails, we
    place it on any drive with any space.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
#define SYS_DRIVE_FREE_SPACE_BUFFER (100)
#define ALT_DRIVE_FREE_SPACE_BUFFER (25)
#define AnswerBufLen (4*MAX_PATH)

#define RECORD_VM_SETTINGS( Drive, Size, Buffer ) {                                                                              \
                                            PagefileDrive = Drive;                                                               \
                                            PagefileSizeMB = Size;                                                               \
                                            MaxPagefileSizeMB = __min( (VolumeFreeSpaceMB[PagefileDrive] - Buffer),              \
                                                                       PagefileSizeMB * MAX_PAGEFILE_RATIO );                    \
                                                                                                                                 \
                                            MaxPagefileSizeMB = __max( MaxPagefileSizeMB, PagefileSizeMB );                      \
                                                                                                                                 \
                                            if( PagefileSizeMB >= CrashDumpPagefileMinMB ) {                                     \
                                                EnableCrashDump = TRUE;                                                          \
                                            }                                                                                    \
                                           }


    DWORD VolumeFreeSpaceMB[26];
    DWORD PagefileMinMB;
    DWORD RecommendedPagefileMB;
    DWORD CrashDumpPagefileMinMB;
    WCHAR WindowsDirectory[MAX_PATH];
    UINT WindowsDriveNo,DriveNo;
    UINT PagefileDrive;
    BOOL EnableCrashDump;
    INT MaxSpaceDrive;
    DWORD PagefileSizeMB;
    DWORD MaxPagefileSizeMB;
    WCHAR PagefileTemplate[128];
    PWSTR PagefileSpec;
    DWORD d;
    BOOL b;
    BOOL UseExistingPageFile = FALSE;
    WCHAR AnswerFile[AnswerBufLen];
    WCHAR Answer[AnswerBufLen];
    WCHAR DriveName[] = L"?:\\";


    LOGITEM(L"SetUpVirtualMemory: ENTER\r\n");

    if( !GetWindowsDirectory(WindowsDirectory,MAX_PATH) ) {
        return FALSE;
    }
    WindowsDriveNo = (UINT)PtrToUlong(CharUpper((PWSTR)WindowsDirectory[0])) - (UINT)L'A';
    PagefileDrive = -1;
    EnableCrashDump = FALSE;

    //
    // Take care of some preliminaries.
    //
    CalculatePagefileSizes(
        &PagefileMinMB,
        &RecommendedPagefileMB,
        &CrashDumpPagefileMinMB
        );

    ZeroMemory(VolumeFreeSpaceMB,sizeof(VolumeFreeSpaceMB));
    BuildVolumeFreeSpaceList(VolumeFreeSpaceMB);

    //
    // Now figure out how large and where the pagefile will be.
    //

    //
    // ================================================================
    // 0.  See if the user already has a reasonable pagefile.
    // ================================================================
    //
    if( (Upgrade) &&
        (ExistingPagefileDrive) ) {

        //
        // See if there was multiple pagefiles or if there's enough room on the existing drive
        // for the pagefile.
        //
        if( LeaveExistingPagefile ||
            VolumeFreeSpaceMB[(UINT)(ExistingPagefileDrive - L'A')] > (RecommendedPagefileMB + ALT_DRIVE_FREE_SPACE_BUFFER) ) {

            if( RestoreOldPagefileSettings()){
                LOGITEM(L"SetUpVirtualMemory: loc 0 - keep user's pagefile settings.\r\n");
                UseExistingPageFile = TRUE;
                PagefileDrive = (UINT)(ExistingPagefileDrive - L'A');
            } else {
                // Shouldn't happen unless their pagefile syntax was bad.
                // We will continue on to create one.
                LOGITEM(L"SetUpVirtualMemory: loc 0 - Could not restore user's pagefile settings.\r\n");
            }
        }
    }


    //
    // ================================================================
    // 1.  See if the NT drive has enough space for the MAX pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > ((RecommendedPagefileMB * MAX_PAGEFILE_RATIO) + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 1\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, RecommendedPagefileMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 2.  See if any drive has enough space for the MAX pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > ((RecommendedPagefileMB * MAX_PAGEFILE_RATIO) + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 2 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, RecommendedPagefileMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 3.  See if the NT drive has enough space for the recommended pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (RecommendedPagefileMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 3\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, RecommendedPagefileMB, SYS_DRIVE_FREE_SPACE_BUFFER );

        }
    }

    //
    // ================================================================
    // 4.  See if any drive has enough space for the recommended pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (RecommendedPagefileMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 4 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, RecommendedPagefileMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 5.  See if the NT drive has enough space for the CrashDump pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (CrashDumpPagefileMinMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 5\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, CrashDumpPagefileMinMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 6.  See if any drive has enough space for the CrashDump pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (CrashDumpPagefileMinMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 6 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, CrashDumpPagefileMinMB, ALT_DRIVE_FREE_SPACE_BUFFER);

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 7.  See if the NT drive has enough space for the minimum pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (PagefileMinMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 7\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, PagefileMinMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 8.  See if any drive has enough space for the minimum pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (PagefileMinMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 8 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, PagefileMinMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 9.  Pick the drive with the most free space.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        MaxSpaceDrive = 0;
        for(DriveNo=0; DriveNo<26; DriveNo++) {
            if(VolumeFreeSpaceMB[DriveNo] > VolumeFreeSpaceMB[MaxSpaceDrive]) {
                MaxSpaceDrive = DriveNo;
            }
        }

        if( VolumeFreeSpaceMB[MaxSpaceDrive] > ALT_DRIVE_FREE_SPACE_BUFFER ) {


            //
            // We're desperate here, so don't bother checking if he's
            // removable.
            //
            LOGITEM(L"SetUpVirtualMemory: loc 9 - MaxSpaceDrive is %u\r\n",MaxSpaceDrive);

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( MaxSpaceDrive, VolumeFreeSpaceMB[MaxSpaceDrive] - ALT_DRIVE_FREE_SPACE_BUFFER, 0 );
        }
    }


    //
    // If we still don't have space for a pagefile, the user is out of luck.
    //
    if(PagefileDrive == -1) {

        LOGITEM(L"SetUpVirtualMemory: loc 10 -- out of luck\r\n");

        PagefileSpec = NULL;
        b = FALSE;

        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PAGEFILE_FAIL,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_NO_PAGING_DRIVES,
            NULL,NULL);

    } else {

        b = TRUE;

        PagefileSpec = PagefileTemplate;
        _snwprintf(
            PagefileTemplate,
            sizeof(PagefileTemplate)/sizeof(PagefileTemplate[0]),
            L"%c:\\pagefile.sys %u %u",
            PagefileDrive + L'A',
            PagefileSizeMB,
            MaxPagefileSizeMB
            );

    }

    if( b ) {
        //
        // Set pagefile in registry.  I only want to do this in the
        // case of clean installs, and on upgrades if the existing
        // pagefile wasn't big enough.  In the case of upgrades, if
        // the existing pagefile was big enough, then we will have
        // set UseExistingPageFile, which will tell us to leave the
        // registry settings as is.
        //
        if( !UseExistingPageFile ) {
            d = pSetupSetArrayToMultiSzValue(
                    HKEY_LOCAL_MACHINE,
                    szMemoryManagementKeyPath,
                    szPageFileValueName,
                    &PagefileSpec,
                    PagefileSpec ? 1 : 0
                    );

            if(d == NO_ERROR) {
                if(b) {
                    SetuplogError(
                        LogSevInformation,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_CREATED_PAGEFILE,
                        PagefileDrive+L'A',
                        PagefileSizeMB,
                        NULL,NULL);
                }
            } else {
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_PAGEFILE_FAIL, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szSetArrayToMultiSzValue,
                    d,
                    NULL,NULL);
            }



            //
            // Make sure there's at least a small pagefile
            // on the windows drive.  Ignore errors here.
            //
            if( (PagefileDrive != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[WindowsDriveNo] > TINY_WINDIR_PAGEFILE_SIZE) ) {

                //
                // There's not.  Write a second string into our buffer just past
                // the first string (remember this will become a REG_MULTI_SZ
                //
                _snwprintf(
                    PagefileTemplate,
                    sizeof(PagefileTemplate)/sizeof(PagefileTemplate[0]),
                    L"%c:\\pagefile.sys %u %u",
                    WindowsDriveNo + L'A',
                    TINY_WINDIR_PAGEFILE_SIZE,
                    TINY_WINDIR_PAGEFILE_SIZE
                    );

                pSetupAppendStringToMultiSz(
                        HKEY_LOCAL_MACHINE,
                        szMemoryManagementKeyPath,
                        0,
                        szPageFileValueName,
                        PagefileTemplate,
                        TRUE
                        );
            }


            b = b && (d == NO_ERROR);
        }
    }


    //
    // Now set the crashdump.
    //
    // The proper settings are as follows:
    //
    // Server Upgrades
    // ===============
    //     existing setting          new setting
    //         0                         3
    //         1                         1
    //
    // Workstation Upgrades
    // ====================
    //     existing setting          new setting
    //         0                         3
    //         1                         1
    //
    // Server Clean Install
    // ====================
    //     new setting
    //         1 iff pagefile < MAX_PAGEFILE_SIZEMB else 2
    //
    // Workstation Clean Install
    // =========================
    //     new setting
    //         3
    //
    //
    // Where:
    // 0 - no crash dump
    // 1 - dump all memory to crash file
    // 2 - dump kernel memory to crash file
    // 3 - dump a select set of memory (amounting to 64K) to crash file
    //


    //
    // See if the user has asked us to go a particular way
    // on the crashdump settings.
    //

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    GetPrivateProfileString( TEXT("Unattended"),
                             TEXT("CrashDumpSetting"),
                             pwNull,
                             Answer,
                             AnswerBufLen,
                             AnswerFile );
    if( lstrcmp( pwNull, Answer ) ) {
        d = wcstoul(Answer,NULL,10);

        if( d <= Three ) {
            CrashDumpValues[2].Data = &d;
        } else {
            CrashDumpValues[2].Data = &Three;
        }
    } else {

        //
        // No unattended values.  Set it manually.
        //



        //
        // Take care of clean installs first.
        //
        if( !Upgrade ) {
            if( ProductType == PRODUCT_WORKSTATION ) {
                CrashDumpValues[2].Data = &Three;
            } else {
                if( PagefileSizeMB >= MAX_PAGEFILE_SIZEMB ) {
                    CrashDumpValues[2].Data = &Two;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            }
        } else {
            //
            // Upgrade.
            //
            // Here, we need to go retrieve the current value to
            // see what's there now.  This will tell us how to migrate.
            //

            HKEY        Key;
            DWORD       cbData;
            DWORD       ExistingCrashDumpSetting = 0;
            DWORD       Type;

            d = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              L"System\\CurrentControlSet\\Control\\CrashControl",
                              0,
                              KEY_READ,
                              &Key );

            if( d == ERROR_SUCCESS ) {
                //
                //  Find out the size of the data to be retrieved
                //
                cbData = sizeof(DWORD);
                d = RegQueryValueEx( Key,
                                     CrashDumpValues[2].Name,
                                     0,
                                     &Type,
                                     ( LPBYTE )&ExistingCrashDumpSetting,
                                     &cbData );
                RegCloseKey( Key );
            }

            //
            // Make sure ExistingCrashDumpSetting is set.
            //
            if( d != ERROR_SUCCESS ) {
                ExistingCrashDumpSetting = (ProductType == PRODUCT_WORKSTATION) ? 0 : 1;
            }

            if( ProductType == PRODUCT_WORKSTATION ) {
                if( ExistingCrashDumpSetting == 0 ) {
                    CrashDumpValues[2].Data = &Three;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            } else {
                if( ExistingCrashDumpSetting == 0 ) {
                    CrashDumpValues[2].Data = &Three;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            }
        }
    }

#ifdef PRERELEASE
    if( Upgrade ) {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\CrashControl",
                CrashDumpValues,
                sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0]) - 1
                );
    } else {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\CrashControl",
                CrashDumpValues,
                sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0])
                );
    }
#else
    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\CrashControl",
            CrashDumpValues,
            sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0])
            );
#endif

    if(d == NO_ERROR) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRASHDUMPOK,
            NULL,NULL);
    } else {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRASHDUMPFAIL, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_STRING,
            szSetGroupOfValues,
            d,
            NULL,NULL);

        b = FALSE;
    }

    RemoveSavedPagefileSetting();

    LOGITEM(L"SetUpVirtualMemory: EXIT (%u)\r\n",b);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\watch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    watch.c

Abstract:

    This module contains routines for watching changes to the
    current user's profile directory and the HKEY_CURRENT_USER key.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Debugging aids.
//

#if WATCH_DEBUG

DWORD WatchDebugLevel = 0;
#define dprintf(_lvl_,_x_) if ((_lvl_) <= WatchDebugLevel) DbgPrint _x_
#define DEBUG(_x_) _x_

PWCH StartDirectoryName = TEXT("");
PWCH StartKeyName = TEXT("");
PWCH StopDirectoryName = TEXT("");
PWCH StopKeyName = TEXT("");

static PSZ Types[] = {"ACK!", "DIR  ", "FILE ", "KEY  ", "VALUE"};
static PSZ States[] = {"NONE", "CHANGED", "DELETED", "NEW", "MATCHED"};

#undef MyMalloc
#undef MyFree
#define MyMalloc MyMallocEx
#define MyFree MyFreeEx
PVOID
MyMallocEx (
    IN DWORD Size
    );
VOID
MyFreeEx (
    IN PVOID p
    );
VOID
DumpMallocStats (
    PSZ Event
    );

#else

#define dprintf(_lvl_,_x_)
#define DEBUG(_x_)
#define DumpMallocStats(_event)

#endif

//
// Additions to the change types in WatchEnum.
//

#define WATCH_NONE      0
#define WATCH_MATCHED   4


//
// Common header for container entries (directories and keys).
//

typedef struct _CONTAINER_ENTRY {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY ContainerList;
    LIST_ENTRY ObjectList;
    struct _CONTAINER_ENTRY *Parent;
    DWORD State;
#if WATCH_DEBUG
    DWORD IsDirectory;
#endif
} CONTAINER_ENTRY, *PCONTAINER_ENTRY;

//
// Common header for object entries (files and values).
//

typedef struct _OBJECT_ENTRY {
    LIST_ENTRY SiblingListEntry;
    DWORD State;
} OBJECT_ENTRY, *POBJECT_ENTRY;

//
// Macros for manipulating containers and objects.
//

#if WATCH_DEBUG
#define SetIsDirectory(_container,_isdir) (_container)->IsDirectory = (_isdir)
#else
#define SetIsDirectory(_container,_isdir)
#endif

#define InitializeContainer(_container,_state,_parent,_isdir) { \
        InitializeListHead(&(_container)->ContainerList);       \
        InitializeListHead(&(_container)->ObjectList);          \
        (_container)->Parent = (PCONTAINER_ENTRY)(_parent);     \
        (_container)->State = (_state);                         \
        SetIsDirectory((_container),(_isdir));                  \
    }

#define InitializeObject(_object,_state) (_object)->State = (_state);

#define InsertContainer(_container,_subcontainer)                                           \
        InsertTailList(&(_container)->ContainerList,&(_subcontainer)->SiblingListEntry)

#define InsertObject(_container,_object)                                        \
        InsertTailList(&(_container)->ObjectList,&(_object)->SiblingListEntry)

#define RemoveObject(_object) RemoveEntryList(&(_object)->SiblingListEntry)
#define RemoveContainer(_container) RemoveEntryList(&(_container)->SiblingListEntry)

#define GetFirstObject(_container)                                      \
        ((_container)->ObjectList.Flink != &(_container)->ObjectList ?  \
            CONTAINING_RECORD( (_container)->ObjectList.Flink,          \
                               OBJECT_ENTRY,                            \
                               SiblingListEntry ) : NULL)

#define GetNextObject(_container,_object)                                   \
        ((_object)->SiblingListEntry.Flink != &(_container)->ObjectList ?   \
            CONTAINING_RECORD( (_object)->SiblingListEntry.Flink,           \
                               OBJECT_ENTRY,                                \
                               SiblingListEntry ) : NULL)

#define GetFirstContainer(_container)                                               \
        ((_container)->ContainerList.Flink != &(_container)->ContainerList ?        \
            CONTAINING_RECORD( (_container)->ContainerList.Flink,                   \
                               CONTAINER_ENTRY,                                     \
                               SiblingListEntry ) : NULL)

#define GetNextContainer(_container)                                                        \
        ((_container)->SiblingListEntry.Flink != &(_container)->Parent->ContainerList ?     \
            CONTAINING_RECORD( (_container)->SiblingListEntry.Flink,                        \
                               CONTAINER_ENTRY,                                             \
                               SiblingListEntry ) : NULL)

#define GetParent(_container) (_container)->Parent

#define GetEntryState(_entry) (_entry)->State
#define SetEntryState(_entry,_state) ((_entry)->State = (_state))

#if WATCH_DEBUG
#define CONTAINER_NAME(_container)                                              \
        (_container)->IsDirectory ? ((PDIRECTORY_ENTRY)(_container))->Name :    \
                                    ((PKEY_ENTRY)(_container))->Name
#define OBJECT_NAME(_container,_object)                                         \
        (_container)->IsDirectory ? ((PFILE_ENTRY)(_object))->Name :            \
                                    ((PVALUE_ENTRY)(_object))->Name
#endif

//
// Structures for entries in the watch tree.
//

typedef struct _DIRECTORY_ENTRY {
    CONTAINER_ENTRY ;
    WCHAR Name[1];
} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;

typedef struct _FILE_ENTRY {
    OBJECT_ENTRY ;
    FILETIME LastWriteTime;
    WCHAR Name[1];
} FILE_ENTRY, *PFILE_ENTRY;

typedef struct _KEY_ENTRY {
    CONTAINER_ENTRY ;
    HKEY Handle;
    WCHAR Name[1];
} KEY_ENTRY, *PKEY_ENTRY;

typedef struct _VALUE_ENTRY {
    OBJECT_ENTRY ;
    DWORD Type;
    DWORD NameLength;
    DWORD ValueDataLength;
    WCHAR Name[1];
} VALUE_ENTRY, *PVALUE_ENTRY;

//
// The root of the watch tree is allocated as a ROOT_ENTRY followed by
// a DIRECTORY_ENTRY and a KEY_ENTRY.
//

typedef struct _ROOT_ENTRY {
    PDIRECTORY_ENTRY RootDirectoryEntry;
    PKEY_ENTRY RootKeyEntry;
} ROOT_ENTRY, *PROOT_ENTRY;

//
// Macro for comparing file times.
//

#define TIMES_EQUAL(_a,_b)                              \
        (((_a).dwLowDateTime  == (_b).dwLowDateTime) && \
         ((_a).dwHighDateTime == (_b).dwHighDateTime))

typedef struct _KEY_ENUM_CONTEXT {
    PKEY_ENTRY ParentKey;
    PWCH CurrentPath;
} KEY_ENUM_CONTEXT, *PKEY_ENUM_CONTEXT;


//
// Forward declaration of local subroutines.
//

VOID
WatchFreeChildren (
    IN PCONTAINER_ENTRY Container
    );

DWORD
WatchDirStart (
    IN PROOT_ENTRY Root
    );

DWORD
WatchDirStop (
    IN PROOT_ENTRY Root
    );

DWORD
WatchKeyStart (
    IN PROOT_ENTRY Root
    );

DWORD
WatchKeyStop (
    IN PROOT_ENTRY Root
    );

DWORD
AddValueAtStart (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
AddKeyAtStart (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
CheckValueAtStop (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
CheckKeyAtStop (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );


DWORD
WatchStart (
    OUT PVOID *WatchHandle
    )

/*++

Routine Description:

    Starts watching.  Captures the initial state of the Start Menu directory
    and HKEY_CURRENT_USER.

Arguments:

    WatchHandle - returns a handle for calls to the other Watch routines.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    PDIRECTORY_ENTRY rootDirectory;
    PKEY_ENTRY rootKey;
    DWORD dirSize;
    DWORD keySize;
    DWORD size;
    DWORD error;

    //
    // Calculate the size of the root entry, which includes entries for the
    // root directory and the root key.  The root directory and the root key
    // do not have names, so we don't have to allocate additional space.
    //
    // Allocate and initialize the root entry.
    //

#if !WATCH_DEBUG
    dirSize = (sizeof(DIRECTORY_ENTRY) + 7) & ~7;
    keySize = (sizeof(KEY_ENTRY) + 7) & ~7;
#else
    dirSize = (sizeof(DIRECTORY_ENTRY) + (wcslen(StartDirectoryName)*sizeof(WCHAR)) + 7) & ~7;
    keySize = (sizeof(KEY_ENTRY) + (wcslen(StartKeyName)*sizeof(WCHAR)) + 7) & ~7;
#endif

    root = MyMalloc( ((sizeof(ROOT_ENTRY) + 7) & ~7) + dirSize + keySize );
    if ( root == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    rootDirectory = (PDIRECTORY_ENTRY)(root + 1);
    rootKey = (PKEY_ENTRY)((PCHAR)rootDirectory + dirSize);

    root->RootDirectoryEntry = rootDirectory;
    root->RootKeyEntry = rootKey;

    //
    // Initialize the root directory and the root key.
    //

    InitializeContainer( rootDirectory, 0, NULL, TRUE );
    InitializeContainer( rootKey, 0, NULL, FALSE );
    rootKey->Handle = NULL;
#if !WATCH_DEBUG
    rootDirectory->Name[0] = 0;
    rootKey->Name[0] = 0;
#else
    wcscpy( rootDirectory->Name, StartDirectoryName );
    wcscpy( rootKey->Name, StartKeyName );
#endif

    //
    // Start watching the Start Menu directory and the current user key.
    //

    error = WatchDirStart( root );
    DumpMallocStats( "After WatchDirStart" );
    if ( error == NO_ERROR ) {
        error = WatchKeyStart( root );
        DumpMallocStats( "After WatchKeyStart" );
    }

    //
    // If an error occurred, free the root entry.  Otherwise, return the
    // address of the root entry as the watch handle.
    //

    if ( error != NO_ERROR ) {
        WatchFree( root );
        DumpMallocStats( "After WatchFree" );
    } else {
        *WatchHandle = root;
    }

    return error;

} // WatchStart


DWORD
WatchStop (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Stops watching.  Compares the current state of the directory and key
    to the initial state.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    DWORD error;

    root = WatchHandle;

    //
    // Stop watching the Start Menu directory and the current user key.
    // Capture the differences from the initial state.
    //

#if WATCH_DEBUG
    if ( (wcslen(StopDirectoryName) > wcslen(root->RootDirectoryEntry->Name)) ||
         (wcslen(StopKeyName) > wcslen(root->RootKeyEntry->Name)) ) {
        return ERROR_INVALID_PARAMETER;
    }
    wcscpy( root->RootDirectoryEntry->Name, StopDirectoryName );
    wcscpy( root->RootKeyEntry->Name, StopKeyName );
#endif

    error = WatchDirStop( root );
    DumpMallocStats( "After WatchDirStop" );
    if ( error == NO_ERROR ) {
        error = WatchKeyStop( root );
        DumpMallocStats( "After WatchKeyStop" );
    }

    return error;

} // WatchStop


DWORD
WatchEnum (
    IN PVOID WatchHandle,
    IN PVOID Context,
    IN PWATCH_ENUM_ROUTINE EnumRoutine
    )

/*++

Routine Description:

    Enumerates the new, changed, and deleted elements of the watched
    directory and key.  Call the EnumRoutine for each such entry.

Arguments:

    WatchHandle - handle returned by WatchStart.

    Context - context value to be passed to EnumRoutine.

    EnumRoutine - routine to call for each entry.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    PWCH name;
    PCONTAINER_ENTRY rootContainer;
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    POBJECT_ENTRY object;
    WATCH_ENTRY enumEntry;
    DWORD i;
    DWORD containerNameOffset;
    DWORD objectNameOffset;
    DWORD containerType;
    DWORD objectType;
    DWORD error;
    BOOL  bTooLong;
    WCHAR currentPath[MAX_PATH + 1];

    root = WatchHandle;

    //
    // Loop twice -- once for the watched directory and once for
    // the watched key.
    //

    for ( i = 0; i < 2; i++ ) {

        //
        // Set up for walking the appropriate tree.
        //

        if ( i == 0 ) {
            rootContainer = (PCONTAINER_ENTRY)root->RootDirectoryEntry;
            containerType = WATCH_DIRECTORY;
            objectType = WATCH_FILE;
            containerNameOffset = FIELD_OFFSET( DIRECTORY_ENTRY, Name );
            objectNameOffset = FIELD_OFFSET( FILE_ENTRY, Name );
        } else {
            rootContainer = (PCONTAINER_ENTRY)root->RootKeyEntry;
            containerType = WATCH_KEY;
            objectType = WATCH_VALUE;
            containerNameOffset = FIELD_OFFSET( KEY_ENTRY, Name );
            objectNameOffset = FIELD_OFFSET( VALUE_ENTRY, Name );
        }

        currentContainer = rootContainer;
        if( rootContainer && wcslen( (PWCH)((PCHAR)rootContainer + containerNameOffset)) > (MAX_PATH-1)) {
            SetupDebugPrint1( L"SETUP: : WatchEnum. Rootcontainer too long %s.", (PWCH)((PCHAR)rootContainer + containerNameOffset));
            continue;
        }
        wcscpy( currentPath, (PWCH)((PCHAR)rootContainer + containerNameOffset) );
        enumEntry.Name = currentPath;
        if ( wcslen(currentPath) == 0 ) {
            enumEntry.Name += 1;    // skip leading backslash
        }

        do {

            //
            // Call the EnumRoutine for each object (file/value) in the
            // container (directory/key).  All objects remaining in the
            // tree are either changed, new, or deleted.
            //

            object = GetFirstObject( currentContainer );
            while ( object != NULL ) {
                enumEntry.EntryType = objectType;
                enumEntry.ChangeType = GetEntryState( object );

                if( (wcslen( currentPath) + wcslen( L"\\") + wcslen((PWCH)((PCHAR)object + objectNameOffset))) 
                    < MAX_PATH) {
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, (PWCH)((PCHAR)object + objectNameOffset) );
                    error = EnumRoutine( Context, &enumEntry );
                    if ( error != NO_ERROR ) {
                        dprintf( 0, ("EnumRoutine returned %d\n", error) );
                        return error;
                    }
                    *wcsrchr(currentPath, L'\\') = 0;
                }
                else {
                    SetupDebugPrint1( L"SETUP: : WatchEnum. Object too long %s.", (PWCH)((PCHAR)object + objectNameOffset));
                }
                object = GetNextObject( currentContainer, object );
            }

            //
            // If the current container has subcontainers, recurse
            // into the first one.
            //

            container = GetFirstContainer( currentContainer );
            bTooLong = container && (wcslen( currentPath) + wcslen( L"\\") + wcslen((PWCH)((PCHAR)container + containerNameOffset))) >= MAX_PATH;
            if( bTooLong) {
                SetupDebugPrint1( L"SETUP: : WatchEnum. Container too long %s.", (PWCH)((PCHAR)container + containerNameOffset));
            }

            if ( container != NULL && !bTooLong) {
                currentContainer = container;
                wcscat( currentPath, L"\\" );
                wcscat( currentPath, (PWCH)((PCHAR)currentContainer + containerNameOffset) );
            } else {

                //
                // The container has no subcontainers.  Walk back up the
                // tree looking for a sibling container to process.
                //

                while ( TRUE ) {

                    //
                    // If the current container is the root container, we're done.
                    //

                    if ( currentContainer == rootContainer ) {
                        currentContainer = NULL;
                        break;
                    }

                    //
                    // If the current container is new or deleted, call
                    // the EnumRoutine.
                    //

                    if ( GetEntryState(currentContainer) != WATCH_MATCHED ) {
                        enumEntry.EntryType = containerType;
                        enumEntry.ChangeType = GetEntryState( currentContainer );
                        error = EnumRoutine( Context, &enumEntry );
                        if ( error != NO_ERROR ) {
                            dprintf( 0, ("EnumRoutine returned %d\n", error) );
                            return error;
                        }
                    }

                    //
                    // Strip the name of the current container off of the path.
                    //

                    *wcsrchr(currentPath, L'\\') = 0;

                    //
                    // If the parent container has more subcontainers, recurse
                    // into the next one.  Otherwise, move up to the parent
                    // container and try again.
                    //

                    container = GetNextContainer( currentContainer );
                    bTooLong = container && (wcslen( currentPath) + wcslen(L"\\") + wcslen( (PWCH)((PCHAR)container + containerNameOffset))) >= MAX_PATH;
                    if( bTooLong) {
                        SetupDebugPrint1( L"SETUP: : WatchEnum. Container too long %s.", (PWCH)((PCHAR)container + containerNameOffset));
                    }
                    if ( container != NULL && !bTooLong) {
                        currentContainer = container;
                        wcscat( currentPath, L"\\" );
                        wcscat( currentPath, (PWCH)((PCHAR)currentContainer + containerNameOffset) );
                        break;
                    } else {
                        currentContainer = GetParent( currentContainer );
                    }
                }
            }

        } while ( currentContainer != NULL );

    } // for

    return NO_ERROR;

} // WatchEnum


VOID
WatchFree (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Frees the watch data structures.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;

    root = WatchHandle;

    //
    // Free the directory tree, and key tree, and the root entry.
    //

    WatchFreeChildren( (PCONTAINER_ENTRY)root->RootDirectoryEntry );
    WatchFreeChildren( (PCONTAINER_ENTRY)root->RootKeyEntry );

    MyFree( root );

    DumpMallocStats( "After WatchFree" );

    return;

} // WatchFree


VOID
WatchFreeChildren (
    IN PCONTAINER_ENTRY RootContainer
    )

/*++

Routine Description:

    Frees the children of a container (directory or key).  Note that the
    container itself is not freed.

Arguments:

    RootContainer - the container whose children are to be freed.

Return Value:

    None.

--*/

{
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    PCONTAINER_ENTRY parent;
    POBJECT_ENTRY object;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    DEBUG( wcscpy( currentPath, CONTAINER_NAME(RootContainer) ) );

    //
    // Delete children starting at the root container.
    //

    currentContainer = RootContainer;

    do {

        //
        // Delete all objects (files or values) within the container.
        //

        object = GetFirstObject( currentContainer );
        while ( object != NULL ) {
            dprintf( 2, ("Deleting entry for object %ws\\%ws: %s\n", currentPath, OBJECT_NAME(currentContainer,object), States[GetEntryState(object)]) );
            RemoveObject( object );
            MyFree( object );
            object = GetFirstObject( currentContainer );
        }

        //
        // If the container has subcontainers, recurse into the first one.
        //

        container = GetFirstContainer( currentContainer );
        if ( container != NULL ) {

            currentContainer = container;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, CONTAINER_NAME(currentContainer) ) );

        } else {

            //
            // The container has no subcontainers.  Walk back up the
            // tree looking for a sibling container to process.
            //

            while ( TRUE ) {

                //
                // If the current container is the root container, we're done.
                //

                if ( currentContainer == RootContainer ) {
                    currentContainer = NULL;
                    break;
                }

                DEBUG( dprintf( 2, ("Deleting entry for container %ws: %s\n", currentPath, States[GetEntryState(currentContainer)]) ) );
                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // Free the current container.
                //

                parent = GetParent( currentContainer );
                RemoveContainer( currentContainer );
                MyFree( currentContainer );

                //
                // If the parent container has more subcontainers,
                // recurse into the first one.  Otherwise, move up
                // to the parent container and loop back to free it.
                //

                currentContainer = GetFirstContainer( parent );
                if ( currentContainer != NULL ) {
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, CONTAINER_NAME(currentContainer) ) );
                    break;
                } else {
                    currentContainer = parent;
                }
            }
        }

    } while ( currentContainer != NULL );

    return;

} // WatchFreeChildren


DWORD
WatchDirStart (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Starts watching the current user's profile directory.  Captures the
    initial state of the directory tree.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY newDirectory;
    PFILE_ENTRY newFile;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    DWORD error;
    BOOL ok;
    WCHAR currentPath[MAX_PATH + 1];

    //
    // Get the address of the root directory entry.
    //

    rootDirectory = Root->RootDirectoryEntry;
    currentDirectory = rootDirectory;

    //
    // Get the full path to the current user's profile directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, currentPath );
    if ( !ok ) {
        return GetLastError();
    }
    DEBUG( if ( wcslen( rootDirectory->Name ) != 0 ) {
        wcscat( currentPath, TEXT("\\") );
        wcscat( currentPath, rootDirectory->Name );
    } )

    do {

        //
        // Look for files/directories in the current directory.
        //

        wcscat( currentPath, L"\\*" );
        dprintf( 2, ("FindFirst for %ws\n", currentPath) );
        findHandle = FindFirstFile( currentPath, &fileData );
        currentPath[wcslen(currentPath) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {

                    //
                    // The entry returned is for a file.  Add it to the tree,
                    // capturing the file's LastWriteTime.
                    //

                    dprintf( 2, ("  found file %ws\\%ws\n", currentPath, fileData.cFileName) );
                    newFile = MyMalloc( (DWORD)(sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                        ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                    if ( newFile == NULL ) {
                        FindClose( findHandle );
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    InitializeObject( newFile, 0 );
                    wcscpy( newFile->Name, fileData.cFileName );
                    newFile->LastWriteTime = fileData.ftLastWriteTime;
                    InsertObject( currentDirectory, newFile );

                } else if ((wcscmp(fileData.cFileName,L".") != 0) &&
                           (wcscmp(fileData.cFileName,L"..") != 0)) {

                    //
                    // The entry returned is for a directory.  Add it to the tree.
                    //

                    dprintf( 2, ("  found directory %ws\\%ws\n", currentPath, fileData.cFileName) );
                    newDirectory = MyMalloc( (DWORD)(sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                             ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                    if ( newDirectory == NULL ) {
                        FindClose( findHandle );
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    InitializeContainer( newDirectory, 0, currentDirectory, TRUE );
                    wcscpy( newDirectory->Name, fileData.cFileName );
                    InsertContainer( currentDirectory, newDirectory );

                }

                //
                // Find another entry in the directory.
                //

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            //
            // All entries found.  Close the find handle.
            //

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        //
        // If the current directory has subdirectories, recurse into the
        // first one.
        //

        newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        if ( newDirectory != NULL ) {

            currentDirectory = newDirectory;
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, currentDirectory->Name );

        } else {

            //
            // The directory has no subdirectories.  Walk back up the
            // tree looking for a sibling directory to process.
            //

            while ( TRUE ) {

                //
                // If the current directory is the root directory, we're done.
                //

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                //
                // Strip the name of the current directory off of the path.
                //

                *wcsrchr(currentPath, L'\\') = 0;

                //
                // If the parent directory has more subdirectories,
                // recurse into the next one.  Otherwise, move up
                // to the parent directory and try again.
                //

                newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );
                if ( newDirectory != NULL ) {
                    currentDirectory = newDirectory;
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, currentDirectory->Name );
                    break;
                } else {
                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return NO_ERROR;

} // WatchDirStart


DWORD
WatchDirStop (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Stops watching the current user's profile directory.  Captures the
    differences between the initial state and the current state.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY directory;
    PFILE_ENTRY file;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    DWORD error;
    BOOL ok;
    WCHAR currentPath[MAX_PATH + 1];

    //
    // Get the address of the root directory entry.
    //

    rootDirectory = Root->RootDirectoryEntry;
    currentDirectory = rootDirectory;

    //
    // Get the full path to the current user's directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, currentPath );
    if ( !ok ) {
        return GetLastError();
    }
    DEBUG( if ( wcslen( rootDirectory->Name ) != 0 ) {
        wcscat( currentPath, TEXT("\\") );
        wcscat( currentPath, rootDirectory->Name );
    } )

    do {

        //
        // Look for files/directories in the current directory.
        //

        wcscat( currentPath, L"\\*" );
        dprintf( 2, ("FindFirst for %ws\n", currentPath) );
        findHandle = FindFirstFile( currentPath, &fileData );
        currentPath[wcslen(currentPath) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {

                    //
                    // The entry returned is for a file.  Check to see if
                    // this file existed at the start.
                    //

                    dprintf( 2, ("  found file %ws\\%ws\n", currentPath, fileData.cFileName) );
                    ok = FALSE;
                    file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
                    while ( file != NULL ) {
                        if ( _wcsicmp( file->Name, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
                    }

                    if ( ok ) {

                        //
                        // The file existed at the start.  If its LastWriteTime
                        // hasn't changed, remove it from the watch tree.
                        // Otherwise, mark it as changed.
                        //

                        if ( TIMES_EQUAL( file->LastWriteTime, fileData.ftLastWriteTime ) ) {
                            dprintf( 2, ("  Deleting entry for unchanged file %ws\\%ws\n", currentPath, file->Name) );
                            RemoveObject( file );
                            MyFree( file );
                        } else {
                            dprintf( 1, ("  Marking entry for changed file %ws\\%ws\n", currentPath, file->Name) );
                            SetEntryState( file, WATCH_CHANGED );
                        }

                    } else {

                        //
                        // The file is new.  Add it to the tree.
                        //

                        file = MyMalloc( (DWORD)(sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                         ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                        if ( file == NULL ) {
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        InitializeObject( file, WATCH_NEW );
                        wcscpy( file->Name, fileData.cFileName );
                        dprintf( 1, ("  Adding entry for new file %ws\\%ws\n", currentPath, file->Name) );
                        InsertObject( currentDirectory, file );
                    }

                } else if ((wcscmp(fileData.cFileName,L".") != 0) &&
                           (wcscmp(fileData.cFileName,L"..") != 0)) {

                    //
                    // The entry returned is for a directory.  Check to see if
                    // this directory existed at the start.
                    //

                    dprintf( 2, ("  found directory %ws\\%ws\n", currentPath, fileData.cFileName) );
                    ok = FALSE;
                    directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
                    while ( directory != NULL ) {
                        if ( _wcsicmp( directory->Name, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
                    }

                    if ( ok ) {

                        //
                        // The directory existed at the start.  Mark it as
                        // matched.  (We can't delete matched directories,
                        // as we do files, because they need to be in the
                        // tree for recursion.)
                        //

                        SetEntryState( directory, WATCH_MATCHED );

                    } else {

                        //
                        // The directory is new.  Add it to the tree.
                        //

                        directory = MyMalloc( (DWORD)(sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                            ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                        if ( directory == NULL ) {
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        InitializeContainer( directory, WATCH_NEW, currentDirectory, TRUE );
                        wcscpy( directory->Name, fileData.cFileName );
                        dprintf( 1, ("  Adding entry for new directory %ws\\%ws\n", currentPath, directory->Name) );
                        InsertContainer( currentDirectory, directory );
                    }

                }

                //
                // Find another entry in the directory.
                //

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            //
            // All entries found.  Close the find handle.
            //

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        //
        // Any file entries in the current directory that were not removed
        // (because they were matched), marked as changed (because the
        // file time had changed), or added (for new files) represent files
        // that have been deleted.  Mark them as such.
        //

        file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
        while ( file != NULL ) {
            if ( GetEntryState(file) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted file %ws\\%ws\n", currentPath, file->Name) );
                SetEntryState( file, WATCH_DELETED );
            }
            file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
        }

        //
        // Any subdirectory entries in the current directory that were not
        // marked as matched (directory still exists) or added (new directory)
        // represent directories that have been deleted.  Mark them as such
        // and delete the entries for the their children -- we don't need
        // these entries any more.
        //

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( directory != NULL ) {
            if ( GetEntryState(directory) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted directory %ws\\%ws\n", currentPath, directory->Name) );
                SetEntryState( directory, WATCH_DELETED );
                WatchFreeChildren( (PCONTAINER_ENTRY)directory );
            }
            directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
        }

        //
        // Find a subdirectory of the current directory that is marked as
        // matched.  We don't need to walk the subtrees for new or deleted
        // directories.
        //

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( directory != NULL ) {
            if ( GetEntryState(directory) == WATCH_MATCHED ) {
                break;
            }
            directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
        }

        //
        // If a matched subdirectory was found, recurse into it.
        //

        if ( directory != NULL ) {

            currentDirectory = directory;
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, currentDirectory->Name );

        } else {

            //
            // The directory has no matched subdirectories.  Walk back up the
            // tree looking for a sibling directory to process.
            //

            while ( TRUE ) {

                //
                // If the current directory is the root directory, we're done.
                //

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                //
                // Strip the name of the current directory off of the path.
                //

                *wcsrchr(currentPath, L'\\') = 0;

                //
                // If the parent directories has more matched subdirectories,
                // recurse into the next one.  Otherwise, move up to the
                // parent directory and try again.
                //

                directory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );
                while ( directory != NULL ) {
                    if ( GetEntryState(directory) == WATCH_MATCHED ) {
                        break;
                    }
                    directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
                }

                if ( directory != NULL ) {

                    currentDirectory = directory;
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, currentDirectory->Name );
                    break;

                } else {

                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return NO_ERROR;

} // WatchDirStop


DWORD
WatchKeyStart (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Starts watching the current user key.  Captures the initial state of the
    key tree.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENTRY rootKey;
    PKEY_ENTRY currentKey;
    PKEY_ENTRY newKey;
    DWORD error;
    KEY_ENUM_CONTEXT context;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    //
    // Get the address of the root key entry.
    //

    rootKey = Root->RootKeyEntry;
    currentKey = rootKey;
    DEBUG( wcscpy( currentPath, rootKey->Name ) );

    do {

        //
        // Open the current key.  If the current key is the root key, then
        // just use the HKEY_CURRENT_USER predefined key.  Otherwise, open
        // the current key relative to the parent key.
        //

        if ( (currentKey == rootKey)
#if WATCH_DEBUG
             && (wcslen(currentKey->Name) == 0)
#endif
           ) {
            currentKey->Handle = HKEY_CURRENT_USER;
        } else {
            error = RegOpenKeyEx(
#if WATCH_DEBUG
                                  currentKey == rootKey ?
                                    HKEY_CURRENT_USER :
#endif
                                    ((PKEY_ENTRY)GetParent(currentKey))->Handle,
                                  currentKey->Name,
                                  0,
                                  KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                  &currentKey->Handle );
            if ( error != NO_ERROR ) {
                goto cleanup;
            }
        }

        //
        // Enumerate the values and subkeys of the key, adding entries
        // to the watch tree for each one.
        //

        context.ParentKey = currentKey;
        DEBUG( context.CurrentPath = currentPath );
        error = EnumerateKey( currentKey->Handle,
                              &context,
                              AddValueAtStart,
                              AddKeyAtStart );
        if ( error != NO_ERROR ) {
            goto cleanup;
        }

        //
        // If the current key has subkeys, recurse into the first one.
        //

        newKey = (PKEY_ENTRY)GetFirstContainer( currentKey );
        if ( newKey != NULL ) {

            currentKey = newKey;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, currentKey->Name ) );

        } else {

            //
            // The key has no subkeys.  Walk back up the tree looking
            // for a sibling key to process.
            //

            while ( TRUE ) {

                //
                // Close the handle to the key.
                //

                if ( currentKey->Handle != HKEY_CURRENT_USER ) {
                    RegCloseKey( currentKey->Handle );
                }
                currentKey->Handle = NULL;

                //
                // If the current key is the root key, we're done.
                //

                if ( currentKey == rootKey ) {
                    currentKey = NULL;
                    break;
                }

                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // If the parent key has more subkeys, recurse into the next
                // one.  Otherwise, move up to the parent key and try again.
                //

                newKey = (PKEY_ENTRY)GetNextContainer( currentKey );
                if ( newKey != NULL ) {
                    currentKey = newKey;
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, currentKey->Name ) );
                    break;
                } else {
                    currentKey = (PKEY_ENTRY)GetParent( currentKey );
                }
            }
        }

    } while ( currentKey != NULL );

    return NO_ERROR;

cleanup:

    //
    // Error cleanup.  Walk back up the tree closing handles.
    //

    do {
        if ( (currentKey->Handle != NULL) && (currentKey->Handle != HKEY_CURRENT_USER) ) {
            RegCloseKey( currentKey->Handle );
        }
        currentKey->Handle = NULL;
        currentKey = (PKEY_ENTRY)GetParent( currentKey );
    } while ( currentKey != NULL );

    return error;

} // WatchKeyStart


DWORD
WatchKeyStop (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Stops watching the current user key.  Captures the differences
    between the initial state and the current state.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENTRY rootKey;
    PKEY_ENTRY currentKey;
    PKEY_ENTRY key;
    PVALUE_ENTRY value;
    DWORD error;
    KEY_ENUM_CONTEXT context;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    //
    // Get the address of the root key entry.
    //

    rootKey = Root->RootKeyEntry;
    currentKey = rootKey;
    DEBUG( wcscpy( currentPath, rootKey->Name ) );

    do {

        //
        // Open the current key.  If the current key is the root key, then
        // just use the HKEY_CURRENT_USER predefined key.  Otherwise, open
        // the current key relative to the parent key.
        //

        if ( (currentKey == rootKey)
#if WATCH_DEBUG
             && (wcslen(currentKey->Name) == 0)
#endif
           ) {
            currentKey->Handle = HKEY_CURRENT_USER;
        } else {
            error = RegOpenKeyEx(
#if WATCH_DEBUG
                                  currentKey == rootKey ?
                                    HKEY_CURRENT_USER :
#endif
                                    ((PKEY_ENTRY)GetParent(currentKey))->Handle,
                                  currentKey->Name,
                                  0,
                                  KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                  &currentKey->Handle );
            if ( error != NO_ERROR ) {
                goto cleanup;
            }
        }

        //
        // Enumerate the values and subkeys of the key, checking entries
        // in the watch tree for each one.
        //

        context.ParentKey = currentKey;
        DEBUG( context.CurrentPath = currentPath );
        error = EnumerateKey( currentKey->Handle,
                              &context,
                              CheckValueAtStop,
                              CheckKeyAtStop );
        if ( error != NO_ERROR ) {
            goto cleanup;
        }

        //
        // Any value entries in the current key that were not removed
        // (because they were matched), marked as changed (because the
        // value data had changed), or added (for new values) represent
        // values that have been deleted.  Mark them as such.
        //

        value = (PVALUE_ENTRY)GetFirstObject( currentKey );
        while ( value != NULL ) {
            if ( GetEntryState(value) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted value %ws\\%ws\n", currentPath, value->Name) );
                SetEntryState( value, WATCH_DELETED );
            }
            value = (PVALUE_ENTRY)GetNextObject( currentKey, value );
        }

        //
        // Any subkey entries in the current key that were not marked as
        // matched (subkey still exists) or added (new subkey) represent
        // subkeys that have been deleted.  Mark them as such and delete
        // the entries for the their children -- we don't need these
        // entries any more.
        //

        key = (PKEY_ENTRY)GetFirstContainer( currentKey );
        while ( key != NULL ) {
            if ( GetEntryState(key) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted key %ws\\%ws\n", currentPath, key->Name) );
                SetEntryState( key, WATCH_DELETED );
                WatchFreeChildren( (PCONTAINER_ENTRY)key );
            }
            key = (PKEY_ENTRY)GetNextContainer( key );
        }

        //
        // Find a subkey of the current directory that is marked as matched.
        // We don't need to walk the subtrees for new or deleted keys.
        //

        key = (PKEY_ENTRY)GetFirstContainer( currentKey );
        while ( key != NULL ) {
            if ( GetEntryState(key) == WATCH_MATCHED ) {
                break;
            }
            key = (PKEY_ENTRY)GetNextContainer( key );
        }

        //
        // If a matched subkey was found, recurse into it.
        //

        if ( key != NULL ) {

            currentKey = key;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, currentKey->Name ) );

        } else {

            //
            // The key has no matched subkeys.  Walk back up the
            // tree looking for a sibling key to process.
            //

            while ( TRUE ) {

                //
                // Close the handle to the key.
                //

                if ( currentKey->Handle != HKEY_CURRENT_USER ) {
                    RegCloseKey( currentKey->Handle );
                }
                currentKey->Handle = NULL;

                //
                // If the current key is the root key, we're done.
                //

                if ( currentKey == rootKey ) {
                    currentKey = NULL;
                    break;
                }

                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // If the parent key has more matched subkeys, recurse
                // into the next one.  Otherwise, move up to the parent
                // key and try again.
                //

                key = (PKEY_ENTRY)GetNextContainer( currentKey );
                while ( key != NULL ) {
                    if ( GetEntryState(key) == WATCH_MATCHED ) {
                        break;
                    }
                    key = (PKEY_ENTRY)GetNextContainer( key );
                }

                if ( key != NULL ) {
                    currentKey = key;
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, currentKey->Name ) );
                    break;
                } else {
                    currentKey = (PKEY_ENTRY)GetParent( currentKey );
                }
            }
        }

    } while ( currentKey != NULL );

    return NO_ERROR;

cleanup:

    //
    // Error cleanup.  Walk back up the tree closing handles.
    //

    do {
        if ( (currentKey->Handle != NULL) && (currentKey->Handle != HKEY_CURRENT_USER) ) {
            RegCloseKey( currentKey->Handle );
        }
        currentKey->Handle = NULL;
        currentKey = (PKEY_ENTRY)GetParent( currentKey );
    } while ( currentKey != NULL );

    return error;

} // WatchKeyStop


DWORD
EnumerateKey (
    IN HKEY KeyHandle,
    IN PVOID Context,
    IN PVALUE_ENUM_ROUTINE ValueEnumRoutine OPTIONAL,
    IN PKEY_ENUM_ROUTINE KeyEnumRoutine OPTIONAL
    )

/*++

Routine Description:

    Enumerates the values and subkeys in a key.  Calls an EnumRoutine for
    each value and subkey.

Arguments:

    KeyHandle - handle to the key to be enumerated.

    Context - context value to be passed to EnumRoutine.

    ValueEnumRoutine - routine to call for each value.  If omitted, values
        are not enumerated.

    KeyEnumRoutine - routine to call for each key.  If omitted, keys are
        not enumerated.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD keyCount;
    DWORD valueCount;
    DWORD i;
    DWORD type;
    DWORD nameLength;
    DWORD maxKeyNameLength;
    DWORD maxValueNameLength;
    DWORD dataLength;
    DWORD maxValueDataLength;
    PWCH nameBuffer;
    PVOID dataBuffer;
    FILETIME time;

    //
    // Query information about the key that is needed to query
    // its values and subkeys.
    //

    error = RegQueryInfoKey( KeyHandle,
                             NULL,
                             NULL,
                             NULL,
                             &keyCount,
                             &maxKeyNameLength,
                             NULL,
                             &valueCount,
                             &maxValueNameLength,
                             &maxValueDataLength,
                             NULL,
                             NULL );
    if ( error != NO_ERROR ) {
        return error;
    }

    if ( ValueEnumRoutine != NULL ) {

        //
        // Allocate a buffer large enough for the longest value name and
        // another buffer large enough for the longest value data.
        //

        nameBuffer = MyMalloc( (maxValueNameLength + 1) * sizeof(WCHAR) );
        if ( nameBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dataBuffer = MyMalloc( maxValueDataLength );
        if ( dataBuffer == NULL ) {
            MyFree( nameBuffer );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Query the key's values.
        //

        for ( i = 0; i < valueCount; i++ ) {

            nameLength = maxValueNameLength + 1;
            dataLength = maxValueDataLength;

            error = RegEnumValue( KeyHandle,
                                  i,
                                  nameBuffer,
                                  &nameLength,
                                  NULL,
                                  &type,
                                  dataBuffer,
                                  &dataLength );
            if ( error != NO_ERROR ) {
                MyFree( dataBuffer );
                MyFree( nameBuffer );
                return error;
            }

            //
            // Call the EnumRoutine.
            //

            error = ValueEnumRoutine( Context,
                                      nameLength,
                                      nameBuffer,
                                      type,
                                      dataBuffer,
                                      dataLength );
            if ( error != NO_ERROR ) {
                MyFree( dataBuffer );
                MyFree( nameBuffer );
                return error;
            }
        }

        //
        // Free the value data and value name buffers.
        //

        MyFree( dataBuffer );
        dataBuffer = NULL;
        MyFree( nameBuffer );
    }

    if ( KeyEnumRoutine != NULL) {

        //
        // Allocate a buffer large enough for the longest subkey name.
        //

        nameBuffer = MyMalloc( (maxKeyNameLength + 1) * sizeof(WCHAR) );
        if ( nameBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Query the key's subkeys.
        //

        for ( i = 0; i < keyCount; i++ ) {

            nameLength = maxKeyNameLength + 1;

            error = RegEnumKeyEx( KeyHandle,
                                  i,
                                  nameBuffer,
                                  &nameLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &time );
            if ( error != NO_ERROR ) {
                MyFree( nameBuffer );
                return error;
            }

            //
            // Call the EnumRoutine.
            //

            error = KeyEnumRoutine( Context,
                                    nameLength,
                                    nameBuffer );
            if ( error != NO_ERROR ) {
                MyFree( nameBuffer );
                return error;
            }
        }

        //
        // Free the key name buffer.
        //

        MyFree( nameBuffer );
    }

    return NO_ERROR;

} // EnumerateKey


DWORD
AddValueAtStart (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds a value entry to the watch tree during WatchKeyStart.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PVALUE_ENTRY newValue;

    //
    // Add the value to the tree, capturing the value data.
    //

    dprintf( 2, ("  found value %ws\\%ws\n", context->CurrentPath, ValueName) );

    newValue = MyMalloc( sizeof(VALUE_ENTRY) - sizeof(WCHAR) +
                         ((ValueNameLength + 1) * sizeof(WCHAR)) +
                         ValueDataLength );
    if ( newValue == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeObject( newValue, 0 );
    wcscpy( newValue->Name, ValueName );
    newValue->Type = ValueType;
    newValue->NameLength = ValueNameLength;
    newValue->ValueDataLength = ValueDataLength;
    memcpy( &newValue->Name + ValueNameLength + 1, ValueData, ValueDataLength );

    InsertObject( context->ParentKey, newValue );

    return NO_ERROR;

} // AddValueAtStart


DWORD
AddKeyAtStart (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Adds a key entry to the watch tree during WatchKeyStart.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PKEY_ENTRY newKey;

    //
    // Add the key to the tree.
    //

    dprintf( 2, ("  found key %ws\\%ws\n", context->CurrentPath, KeyName) );

    newKey = MyMalloc( sizeof(KEY_ENTRY) - sizeof(WCHAR) +
                       ((KeyNameLength + 1) * sizeof(WCHAR)) );
    if ( newKey == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeContainer( newKey, 0, context->ParentKey, FALSE );
    wcscpy( newKey->Name, KeyName );
    newKey->Handle = NULL;

    InsertContainer( context->ParentKey, newKey );

    return NO_ERROR;

} // AddKeyAtStart


DWORD
CheckValueAtStop (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Checks the watch tree for an enumerated value during WatchKeyStop.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PVALUE_ENTRY value;
    BOOL ok;

    //
    // Check to see if the value existed at the start.
    //

    dprintf( 2, ("  found value %ws\\%ws\n", context->CurrentPath, ValueName) );

    ok = FALSE;
    value = (PVALUE_ENTRY)GetFirstObject( context->ParentKey );
    while ( value != NULL ) {
        if ( _wcsicmp( value->Name, ValueName ) == 0 ) {
            ok = TRUE;
            break;
        }
        value = (PVALUE_ENTRY)GetNextObject( context->ParentKey, value );
    }

    if ( ok ) {

        //
        // The value existed at the start.  If its data hasn't changed,
        // remove it from the tree.  Otherwise, mark it as changed.
        //

        if ( (value->Type == ValueType) &&
             (value->ValueDataLength == ValueDataLength) &&
             (memcmp( &value->Name + value->NameLength + 1,
                      ValueData,
                      ValueDataLength ) == 0) ) {
            dprintf( 2, ("Deleting entry for unchanged value %ws\\%ws\n", context->CurrentPath, ValueName) );
            RemoveObject( value );
            MyFree( value );
        } else {
            dprintf( 1, ("  Marking entry for changed value %ws\\%ws\n", context->CurrentPath, ValueName) );
            SetEntryState( value, WATCH_CHANGED );
        }

    } else {

        //
        // The value is new.  Add it to the tree.
        //
        // Note that we do not bother to save the value's data here,
        // even though we have it in hand.  The routines that
        // populate userdifr already have to deal with querying
        // value data, so the code is simpler this way.
        //

        value = MyMalloc( sizeof(VALUE_ENTRY) - sizeof(WCHAR) +
                          ((ValueNameLength + 1) * sizeof(WCHAR)) );
        if ( value == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        InitializeObject( value, WATCH_NEW );
        wcscpy( value->Name, ValueName );
        dprintf( 1, ("  Adding entry for new value %ws\\%ws\n", context->CurrentPath, ValueName) );

        InsertObject( context->ParentKey, value );
    }

    return NO_ERROR;

} // CheckValueAtStop


DWORD
CheckKeyAtStop (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Checks the watch tree for an enumerated key during WatchKeyStop.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PKEY_ENTRY key;
    BOOL ok;

    //
    // Check to see if the subkey existed at the start.
    //

    dprintf( 2, ("  found key %ws\\%ws\n", context->CurrentPath, KeyName) );

    ok = FALSE;
    key = (PKEY_ENTRY)GetFirstContainer( context->ParentKey );
    while ( key != NULL ) {
        if ( _wcsicmp( key->Name, KeyName ) == 0 ) {
            ok = TRUE;
            break;
        }
        key = (PKEY_ENTRY)GetNextContainer( key );
    }

    if ( ok ) {

        //
        // The key existed at the start.  Mark it as matched.
        // (We can't delete matched keys, as we do values,
        // because they need to be in the tree for recursion.)
        //

        SetEntryState( key, WATCH_MATCHED );

    } else {

        //
        // The key is new.  Add it to the tree.
        //

        key = MyMalloc( sizeof(KEY_ENTRY) - sizeof(WCHAR) +
                        ((KeyNameLength + 1) * sizeof(WCHAR)) );
        if ( key == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        InitializeContainer( key, WATCH_NEW, context->ParentKey, FALSE );
        wcscpy( key->Name, KeyName );
        dprintf( 1, ("  Adding entry for new key %ws\\%ws\n", context->CurrentPath, KeyName) );
        InsertContainer( context->ParentKey, key );
    }

    return NO_ERROR;

} // CheckKeyAtStop


//
// Debug code for tracking allocates and frees.
//

#if WATCH_DEBUG

#undef MyMalloc
#undef MyFree

DWORD TotalAllocs = 0;
DWORD TotalFrees = 0;
DWORD PeakAllocs = 0;

DWORD TotalAllocated = 0;
DWORD TotalFreed = 0;
DWORD PeakAllocated = 0;

PVOID
MyMallocEx (
    DWORD Size
    )
{
    PVOID p = MyMalloc( Size + 8 );

    if ( p == NULL ) {
        dprintf( 0, ("MyMallocEx: failure allocating %d bytes\n", Size) );
        DumpMallocStats("");
        DbgBreakPoint();
        return NULL;
    }

    TotalAllocs++;
    if ( (TotalAllocs - TotalFrees) > PeakAllocs ) {
        PeakAllocs = TotalAllocs - TotalFrees;
    }
    TotalAllocated += Size;
    if ( (TotalAllocated - TotalFreed) > PeakAllocated ) {
        PeakAllocated = TotalAllocated - TotalFreed;
    }

    *(PDWORD)p = Size;
    return (PVOID)((PCHAR)p + 8);
}

VOID
MyFreeEx (
    PVOID p
    )
{
    PVOID pp = (PVOID)((PCHAR)p - 8);

    TotalFrees++;
    TotalFreed += *(PDWORD)pp;

    MyFree( pp );
}

VOID
DumpMallocStats (
    PSZ Event
    )
{
    if ( *Event != 0 ) {
        dprintf( 0, ("%s\n", Event) );
    }
    dprintf( 0, ("Allocations %d, frees %d, active allocs %d\n",
                TotalAllocs, TotalFrees, TotalAllocs - TotalFrees) );
    dprintf( 0, ("Bytes allocated %d, bytes freed %d, active bytes %d\n",
                TotalAllocated, TotalFreed, TotalAllocated - TotalFreed) );
    dprintf( 0, ("Peak allocs %d, peak bytes %d\n",
                PeakAllocs, PeakAllocated) );

    return;
}

#endif


typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPTSTR pszPath);

BOOL
GetSpecialFolderPath (
    IN INT    csidl,
    IN LPWSTR lpPath
    )
/*++

Routine Description:

    Gets the path to the requested special folder.
    (This function was copied from userenv.dll)

Arguments:

    csid   - CSIDL of the special folder
    lpPath - Path to place result in assumed to be MAX_PATH in size

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    HRESULT     hResult;
    HINSTANCE   hInstShell32;
    PFNSHGETFOLDERPATH  pfnSHGetFolderPath;


    //
    // Load the function we need
    //

    hInstShell32 = LoadLibrary(L"shell32.dll");

    if (!hInstShell32) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath() failed to load shell32. Error = %d.", GetLastError() );
        return FALSE;
    }


    pfnSHGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress (hInstShell32, "SHGetFolderPathW");

    if (!pfnSHGetFolderPath) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath() failed to find SHGetFolderPath(). Error = %d.", GetLastError() );
        FreeLibrary (hInstShell32);
        return FALSE;
    }


    //
    // Ask the shell for the folder location
    //

    hResult = pfnSHGetFolderPath (
        NULL,
        csidl | CSIDL_FLAG_CREATE,
        (HANDLE) -1,    // this specifies .Default
        0,
        lpPath);
    if (S_OK != hResult) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath: SHGetFolderPath() returned %d.", hResult );
    }

    //
    // Clean up
    //

    FreeLibrary (hInstShell32);
    return (S_OK == hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\userdiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userdiff.h

Abstract:

    Header file for userdiff.c

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// Names of hive keys and hive files.
//
// NOTE: USERRUN_PATH is also in gina\userenv\userdiff.h as USERDIFF_LOCATION
//

#define USERRUN_KEY TEXT("Userdifr")
#define USERRUN_PATH TEXT("system32\\config\\userdifr")
#define USERSHIP_KEY TEXT("Userdiff")
#define USERSHIP_PATH TEXT("system32\\config\\userdiff")
#define USERTMP_PATH TEXT("system32\\config\\userdift")

//
// Names of keys and vales in userdiff.
//
// NOTE: These are also in gina\userenv\userdiff.h and gina\userenv\userdiff.c
//

#define FILES_KEY TEXT("Files")
#define HIVE_KEY TEXT("Hive")
#define ACTION_VALUE TEXT("Action")
#define ITEM_VALUE TEXT("Item")
#define KEYNAME_VALUE TEXT("KeyName")
#define VALUENAME_VALUE TEXT("ValueName")
#define VALUENAMES_VALUE TEXT("ValueNames")
#define VALUE_VALUE TEXT("Value")
#define FLAGS_VALUE TEXT("Flags")

//
// Routine exported by userdiff.c
//

DWORD
MakeUserdifr (
    IN PVOID WatchHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\welcome.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    welcome.c

Abstract:

    Routines for welcomong the user.

Author:

    Ted Miller (tedm) 27-July-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#define HARWARE_DETECTION_BOOT_TIMEOUT  5

extern BOOLEAN
AsrIsEnabled( VOID );


//
// Setup mode (custom, typical, laptop, etc)
//
UINT SetupMode = SETUPMODE_TYPICAL;

//
// Flag telling us whether we've already prepared for installation.
//
BOOL PreparedAlready;

static HBRUSH s_hbrWindow = NULL;

VOID AdjustAndPaintWatermarkBitmap(
    IN HWND hdlg,
    IN HDC hdc
    )
/*
    Function used to adjust and paint the watermark bitmap so that it will fit correctly
    into the welcome and finish window, even if it is scalled differently than
    it would look when run on a usa build.
    some code borrowed from winnt32\dll\{rsrcutil,wizard}.c
    some code borrowed from shell\comctl32\prsht.c

Arguments:

    hdlg, input handle for the window which the dialog shall be drawn into.
    hdc, input device context of the current window.

Return Value:

    none: this is an attempt to scale the bitmap correctly for the cases
      where the win2k logo will be clipped.  In order to get a chance to scale
      the bitmap, we can not let wiz97 take care of it, and thus if this function
      fails, there will be no watermark drawn.

      We treat errors in a way similarly
      to how property sheet would, which is that while we won't die hard, we
      make sure not to use any NULL resources.

*/
{
    RECT rect;
    HBITMAP hDib;
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;
    BITMAPINFOHEADER *BitmapInfoHeader;
    BITMAPINFO *BitmapInfo;
    HDC MemDC;
    UINT ColorCount;
    HPALETTE PreviousPalette;
    HBITMAP Bitmap;
    BOOLEAN b;
    PVOID Bits;
    PVOID Bits2;
    int i;

    s_hbrWindow = GetSysColorBrush(COLOR_WINDOW);

    BlockHandle = FindResource(MyModuleHandle,MAKEINTRESOURCE(IDB_BITMAP1),RT_BITMAP);
    if(!BlockHandle) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't find resource, error %d\n",
            GetLastError());
        //nothing to clean up.
        return;
    }

    MemoryHandle = LoadResource(MyModuleHandle,BlockHandle);
    if(!MemoryHandle) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't load resource, error %d\n",
            GetLastError());
        //nothing to clean up.
        return;
    }

    BitmapInfoHeader = LockResource(MemoryHandle);
    if(BitmapInfoHeader == NULL) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't lock resource, error %d\n",
            GetLastError());
        goto c0;
    }

    // First we have to paint the background on the right side of the window
    // (this is not auto done for us because we aren't using the wizard's watermark)
    GetClientRect(hdlg,&rect);
    rect.left = BitmapInfoHeader->biWidth;
    FillRect(hdc,&rect,s_hbrWindow);

    ColorCount = (BitmapInfoHeader->biBitCount <= 8)
                ? (1 << BitmapInfoHeader->biBitCount)
                : 0;

    BitmapInfo = MyMalloc(BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD)));
    if (!BitmapInfo){
    SetupDebugPrint(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't malloc BitmapInfo.\n");
        goto c0;
    }

    CopyMemory(
        BitmapInfo,
        BitmapInfoHeader,
        BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD))
        );

    BitmapInfo->bmiHeader.biHeight = rect.bottom;
    BitmapInfo->bmiHeader.biWidth = BitmapInfoHeader->biWidth;

    hDib = CreateDIBSection(NULL,BitmapInfo,DIB_RGB_COLORS,&Bits,NULL,0);
    if(!hDib) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't create DIB, error %d\n",
            GetLastError());
        goto c1;
    }

    //
    // Create a "template" memory DC and select the DIB we created
    // into it. Passing NULL to CreateCompatibleDC creates a DC into which
    // any format bitmap can be selected. We don't want to use the dialog's
    // DC because if the pixel depth of the watermark bitmap differs from
    // the screen, we wouldn't be able to select the dib into the mem dc.
    //
    MemDC = CreateCompatibleDC(NULL);
    if(!MemDC) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't create DC, error %d\n",
            GetLastError());
        goto c2;
    }

    if (!SelectObject(MemDC,hDib)){
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't Select DC, error %d\n",
            GetLastError());
        goto c3;
    }

    //
    // Do the stretch operation from the source bitmap onto
    // the dib.
    //
    Bits2 = (LPBYTE)BitmapInfoHeader + BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD));
    SetStretchBltMode(MemDC,COLORONCOLOR);
    i = StretchDIBits(
            MemDC,
            0,0,
            BitmapInfoHeader->biWidth,
            rect.bottom,
            0,0,
            BitmapInfoHeader->biWidth,
            BitmapInfoHeader->biHeight,
            Bits2,
            (BITMAPINFO *)BitmapInfoHeader,
            DIB_RGB_COLORS,
            SRCCOPY
            );

    if(i == GDI_ERROR) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't stretch bitmap, error %d\n",
            GetLastError());
        goto c3;
    }

    i = BitBlt(hdc,0,0,BitmapInfoHeader->biWidth,rect.bottom,MemDC,0,0,SRCCOPY);
    if (0 == i){
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't paint bitmap, error %d\n",
            GetLastError());
    }

c3:
    DeleteDC(MemDC);
c2:
    DeleteObject(hDib);
c1:
    MyFree(BitmapInfo);
c0:
    DeleteObject(MemoryHandle);


}

INT_PTR
CALLBACK
WelcomeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for first wizard page of Setup.
    It essentially just welcomes the user.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    HFONT   Font;
    LOGFONT LogFont;
    WCHAR   str[20];
    int     Height;
    HDC     hdc;
    NMHDR   *NotifyParams;
    PVOID   p;
    static  BOOL FirstInit=TRUE,FirstTime=TRUE;


    switch(msg) {

    case WM_INITDIALOG:

        WizardHandle = GetParent (hdlg);
        if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
        && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = FW_BOLD;
            if(!LoadString(MyModuleHandle, IDS_WELCOME_FONT_NAME, LogFont.lfFaceName, LF_FACESIZE)){
                LogFont.lfFaceName[LF_FACESIZE - 1] = '\0';
            }
            if(!LoadString(MyModuleHandle, IDS_WELCOME_FONT_SIZE, str, ARRAYSIZE(str))){
                str[ARRAYSIZE(str) - 1] = '\0';
            }
            Height = (int)wcstoul(str,NULL,10);

            if(hdc = GetDC(hdlg)) {

                LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }

                ReleaseDC(hdlg,hdc);
            }
        }

        if(p = MyLoadString((ProductType == PRODUCT_WORKSTATION) ?
            IDS_WORKSTATION_WELCOME_1 : IDS_SERVER_WELCOME_1)) {
            //
            // Use this instead of SetText because we need to pass wParam
            // to the control.
            //
            SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_SETTEXT,0,(LPARAM)p);
            MyFree(p);
        }

        if(p = MyLoadString((ProductType == PRODUCT_WORKSTATION) ?
            IDS_WORKSTATION_WELCOME_2 : IDS_SERVER_WELCOME_2)) {
            //
            // Use this instead of SetText because we need to pass wParam
            // to the control.
            //
            SendDlgItemMessage(hdlg,IDT_STATIC_3,WM_SETTEXT,0,(LPARAM)p);
            MyFree(p);
        }

        #define SECOND 1000
        // Don't set the timer if we have a billboard, we don't show the page.
        if (FirstInit  && !Unattended && (GetBBhwnd() == NULL)) {
            SetTimer(hdlg,1,10 * SECOND,NULL);
            FirstInit = FALSE;
        }

#if 0
        //
        // Load steps text and set.
        //
        if(Preinstall) {
            //
            // Hide some text and don't display any steps.
            //
            ShowWindow(GetDlgItem(hdlg,IDT_STATIC_3),SW_HIDE);
            EnableWindow(GetDlgItem(hdlg,IDT_STATIC_3),FALSE);
        } else {
            if(p = MyLoadString(Upgrade ? IDS_STEPS_UPGRADE : IDS_STEPS)) {
                //
                // Use this instead of SetText because we need to pass wParam
                // to the control.
                //
                SendDlgItemMessage(hdlg,IDC_LIST1,WM_SETTEXT,0,(LPARAM)p);
                MyFree(p);
            }
        }

        //
        // Set up some of the static text on this page, which uses different
        // effects (boldface, different fonts, etc).
        //
        {
            HFONT Font;
            LOGFONT LogFont;
            WCHAR str[20];
            int Height;
            HDC hdc;

            //
            // First handle the text that "introduces" the title, which is in
            // the same font as the rest of the dialog, only bold.
            //
            if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
            && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                LogFont.lfWeight = FW_BOLD;
                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }
            }

            //
            // Next do the title, which is in a different font, larger and in boldface.
            //
            if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_GETFONT,0,0))
            && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                LogFont.lfWeight = FW_BOLD;
                if(!LoadString(MyModuleHandle, IDS_MSSERIF, LogFont.lfFaceName, LF_FACESIZE){
                    LogFont.lfFaceName[LF_FACESIZE - 1] = '\0';
                }
                if(!LoadString(MyModuleHandle, IDS_LARGEFONTSIZE, str, ARRAYSIZE(str)){
                    str[ARRAYSIZE(str) - 1] = '\0';
                }
                Height = (int)wcstoul(str,NULL,10);

                if(hdc = GetDC(hdlg)) {

                    LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                    if(Font = CreateFontIndirect(&LogFont)) {
                        SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                    }

                    ReleaseDC(hdlg,hdc);
                }
            }
        }
#endif
        //
        // Center the wizard dialog on-screen.
        //
        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        //
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(GetParent(hdlg), MainWindowHandle, TRUE);
        else
            pSetupCenterWindowRelativeToParent(GetParent(hdlg));
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        // No data on this page, unattended should skip it
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_TIMER:
        KillTimer(hdlg, 1);
        if (FirstTime) {
            PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
            FirstTime = FALSE;
        }
        break;

    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:

    SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
    return (LRESULT)s_hbrWindow;

    case WM_ERASEBKGND:
    AdjustAndPaintWatermarkBitmap(hdlg,(HDC)wParam);
    break;


    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(510);
            BEGIN_SECTION(L"Welcome Page");
            SetWizardButtons(hdlg,WizPageWelcome);

            if(Preinstall) {
                //
                // Show unless OEMSkipWelcome = 1
                //
                if (GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipWelcome",0,AnswerFile)) {
                    FirstTime = FALSE;
                }
                SetWindowLongPtr(
                    hdlg,
                    DWLP_MSGRESULT,
                    GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipWelcome",0,AnswerFile) ? -1 : 0
                    );
            } else {
                FirstTime = FALSE;
                if(Unattended) {
                    UnattendSetActiveDlg(hdlg,IDD_WELCOME);
                }
                else if (GetBBhwnd() != NULL)
                {
                    // If we have a billoard, don't show the page.
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            }
            break;
        case PSN_WIZNEXT:
            FirstTime = FALSE;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Welcome Page");
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


//
// global variable used for subclassing.
//
WNDPROC OldEditProc;

LRESULT
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    //
    // For setsel messages, make start and end the same.
    //
    if((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return(CallWindowProc(OldEditProc,hwnd,msg,wParam,lParam));
}


INT_PTR
CALLBACK
EulaDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page that displays the End User License
        Agreement.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    NMHDR *NotifyParams;
    HWND EditControl;
    WCHAR   EulaPath[MAX_PATH];
    static  HANDLE  hFile = NULL, hFileMapping = NULL;
    DWORD   FileSize;
    static  BYTE    *pbFile = NULL;
    static  PWSTR   EulaText = NULL;
    int     i;


    switch(msg) {

    case WM_INITDIALOG:
        //
        // If not preinstall then this was displayed at start of text mode
        // and we don't do it here.
        //
        if (EulaComplete || TextmodeEula || OemSkipEula) {
           break;
        }

        //
        // Map the file containing the licensing agreement.
        //
        if(!GetSystemDirectory(EulaPath, MAX_PATH)){
            FatalError(MSG_EULA_ERROR,0,0);
        }
        pSetupConcatenatePaths (EulaPath, L"eula.txt", MAX_PATH, NULL);

        hFile = CreateFile (
            EulaPath,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if(hFile == INVALID_HANDLE_VALUE) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        hFileMapping = CreateFileMapping (
            hFile,
            NULL,
            PAGE_READONLY,
            0, 0,
            NULL
            );
        if(hFileMapping == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        pbFile = MapViewOfFile (
            hFileMapping,
            FILE_MAP_READ,
            0, 0,
            0
            );
        if(pbFile == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        //
        // Translate the text from ANSI to Unicode.
        //
        FileSize = GetFileSize (hFile, NULL);
        if(FileSize == 0xFFFFFFFF) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        EulaText = MyMalloc ((FileSize+1) * sizeof(WCHAR));
        if(EulaText == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        MultiByteToWideChar (
            CP_ACP,
            0,
            pbFile,
            FileSize,
            EulaText,
            FileSize+1
            );

        EulaText[FileSize] = 0;

        EditControl = GetDlgItem(hdlg,IDT_EDIT1);
        OldEditProc = (WNDPROC)GetWindowLongPtr(EditControl,GWLP_WNDPROC);
        SetWindowLongPtr(EditControl,GWLP_WNDPROC,(LONG_PTR)EulaEditSubProc);
        SetWindowText(EditControl,(PCWSTR)EulaText);
        break;

    case WM_DESTROY:
        //
        // Clean up
        //
        if( EulaText )
            MyFree (EulaText);

        if (pbFile)
            UnmapViewOfFile (pbFile);

        if (hFileMapping)
            CloseHandle (hFileMapping);

        if (hFile)
            CloseHandle (hFile);

        break;

    case WM_SIMULATENEXT:
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(511);
            BEGIN_SECTION(L"Eula Page");
            SetWizardButtons(hdlg,WizPageEula);
            SetFocus(GetDlgItem(hdlg,IDYES));

            if (EulaComplete || TextmodeEula || OemSkipEula) {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Eula Page");
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                // Make sure we're initialized if we're going to show it.
                MYASSERT(EulaText);
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow the next page to be activated.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;

        case PSN_KILLACTIVE:
            if(IsDlgButtonChecked(hdlg,IDYES)) {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            } else {
                //
                // Are you sure you want to exit?
                //
                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_SURE_EXIT,
                        FALSE,
                        IDS_WINNT_SETUP,
                        MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2
                        );
                if(i == IDYES) {
                    FatalError(MSG_NOT_ACCEPT_EULA,0,0);
                } else {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
                END_SECTION(L"Eula Page");
            }
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
StepsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for "steps" dialog page. This is the one just before
    we go into the network wizard.

    When the user clicks next to go to the next page, we have to perform
    some actions to prepare. So we put up a billboard telling the user
    that we are preparing. When preparation is done, we continue.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    NMHDR *NotifyParams;
    PVOID p;
    HWND billboard;
    HCURSOR OldCursor;

    switch(msg) {

    case WM_INITDIALOG:
        break;

    case WMX_VALIDATE:
        //
        // If unattended, we put up a wait cursor instead of a billboard
        //
        PropSheet_SetWizButtons(GetParent(hdlg),0);
        OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

        if(!UiTest) {
            if(Upgrade) {
                PrepareForNetUpgrade();
            } else {
                PrepareForNetSetup();
            }
        }

        SetCursor (OldCursor);
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
#if 0
    case WM_SIMULATENEXT:
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;
#endif
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(512);
            BEGIN_SECTION(L"Pre-Network Steps Page");
            // Page does not show, hide wizard
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);

            SendDlgMessage (hdlg, WMX_VALIDATE, 0, TRUE);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            END_SECTION(L"Pre-Network Steps Page");
            break;
#if 0
        case PSN_WIZNEXT:

            UnattendAdvanceIfValid (hdlg);
            break;
#endif
        case PSN_KILLACTIVE:
            END_SECTION(L"Pre-Network Steps Page");

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

WNDPROC OldProgressProc;

BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
        case WMX_PROGRESSTICKS:
        case PBM_DELTAPOS:
        case PBM_SETRANGE:
        case PBM_SETRANGE32:
        case PBM_STEPIT:
        case PBM_SETPOS:
        case PBM_SETSTEP:
            ProgressGaugeMsgWrapper(msg, wParam, lParam);
            break;
    }
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}


INT_PTR
CALLBACK
CopyFilesDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page where we do all the work.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    static BOOL WorkFinished = FALSE;
    NMHDR *NotifyParams;
    static HCURSOR hcur;
    static FINISH_THREAD_PARAMS Context;
    static HWND    hProgress;
    DWORD   ThreadId;
    HANDLE  ThreadHandle = NULL;
    UINT    GaugeRange;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Initialize the progress indicator control.
        //
        hProgress = GetDlgItem(hdlg, IDC_PROGRESS1);
        OldProgressProc = (WNDPROC)SetWindowLongPtr(hProgress,GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
        GaugeRange = 100;
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETPOS,0,0);
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETSTEP,1,0);

        // Do calls into the billboard to prepare the progress there.
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);

        #ifdef _OCM
        //
        // the lparam is really the context pointer for ocm
        //
        Context.OcManagerContext = (PVOID)((PROPSHEETPAGE *)lParam)->lParam;
        MYASSERT(Context.OcManagerContext);
        #endif

        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(513);
            BEGIN_SECTION(L"Copying Files Page");
            SetWizardButtons(hdlg,WizPageCopyFiles);

            if(WorkFinished) {
                //
                // Don't activate; we've already been here before.
                // Nothing to do.
                //
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            } else {
                //
                // Need to prepare for installation.
                // Want next/back buttons disabled until we're done.
                //
                PropSheet_SetWizButtons(GetParent(hdlg),0);
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
                PostMessage(hdlg,WM_IAMVISIBLE,0,0);
                WorkFinished = TRUE;
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Copying Files Page");

        default:
            break;
        }

        break;

    case WM_IAMVISIBLE:
        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));

        if(!UiTest) {
            Context.ThreadId = GetCurrentThreadId();
            Context.hdlg = hdlg;
            MYASSERT(Context.OcManagerContext);

            ThreadHandle = CreateThread(
                NULL,
                0,
                FinishThread,
                &Context,
                0,
                &ThreadId
                );

            if(ThreadHandle) {
                CloseHandle(ThreadHandle);
            } else {

                SetupDebugPrint1(
                    L"SETUP: CreateThread() failed for FinishThread.  Error = %d",
                    GetLastError()
                    );
            }
        }

        break;

    case WM_MY_PROGRESS:

        if(wParam) {
            SendMessage (hProgress, PBM_STEPIT, 0, 0);
        } else {
            SendMessage (hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,lParam));
            SendMessage (hProgress, PBM_SETPOS, 0, 0);
        }
        break;

    case WMX_TERMINATE:
        //
        // Enable next and back buttons and move to next page.
        //
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
        SetCursor(hcur);
        if(!UiTest) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
LastPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for last wizard page of Setup.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    HFONT   Font;
    LOGFONT LogFont;
    WCHAR   str[20];
    int     Height;
    HDC     hdc;
    NMHDR   *NotifyParams;
    PVOID   p = NULL;

    switch(msg) {

    case WM_INITDIALOG:

        if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
        && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = FW_BOLD;
            if(!LoadString(MyModuleHandle, IDS_WELCOME_FONT_NAME, LogFont.lfFaceName, LF_FACESIZE)){
                LogFont.lfFaceName[LF_FACESIZE - 1] = '\0';
            }
            if(!LoadString(MyModuleHandle, IDS_WELCOME_FONT_SIZE, str, ARRAYSIZE(str))){
                str[ARRAYSIZE(str) - 1] = '\0';
            }
            Height = (int)wcstoul(str,NULL,10);

            if(hdc = GetDC(hdlg)) {

                LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }

                ReleaseDC(hdlg,hdc);
            }
        }
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        break;

    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:

    SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
    return (LRESULT)s_hbrWindow;

    case WM_ERASEBKGND:
    AdjustAndPaintWatermarkBitmap(hdlg,(HDC)wParam);
    break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(514);
            BEGIN_SECTION(L"Finish Page");

            if( AsrIsEnabled()) {

                if(p = MyLoadString(IDS_EMPTY_STRING)) {
                    BB_SetTimeEstimateText(p);
                    SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT, 0, (LPARAM)p);
                    SendMessage(GetParent(hdlg), WMX_BB_SETINFOTEXT, 0, (LPARAM)p);
                    MyFree(p);
                }
                else {
                    BB_SetTimeEstimateText(TEXT(""));
                    SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT, 0, (LPARAM)TEXT(""));
                    SendMessage(GetParent(hdlg), WMX_BB_SETINFOTEXT, 0, (LPARAM)TEXT(""));
                }

                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, (WPARAM)SW_HIDE, 0);
                StartStopBB(FALSE);

                PostMessage(hdlg,WM_SIMULATENEXT,0,0);
                break;
            }

            SetWizardButtons(hdlg,WizPageLast);
            if (hinstBB)
            {
                PostMessage(hdlg,WM_SIMULATENEXT,0,0);
            }
            else
            {
                //
                // Don't want back button in upgrade case, since that would
                // land us in the middle of the network upgrade. In non-upgrade
                // case we only allow the user to go back if he didn't install
                // the net, to allow him to change his mind.
                //
                if(Upgrade || (InternalSetupData.OperationFlags & SETUPOPER_NETINSTALLED)) {
                    PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_FINISH);
                }
                //
                // If NoWaitAfterGuiMode is zero, turn off Unattend mode
                //

                GetPrivateProfileString (L"Unattended", L"NoWaitAfterGuiMode", L"", str, 20, AnswerFile);
                if (!lstrcmp (str, L"0")) {
                    Unattended = FALSE;
                }

                if (Unattended) {
                    if(!UnattendSetActiveDlg(hdlg,IDD_LAST_WIZARD_PAGE))
                    {
                        END_SECTION(L"Finish Page");
                    }
                }
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Finish Page");

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
PreparingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

   Dialog procedure for "preparing computer" Wizard page.
   When the user is viewing this page we are essentially preparing
   BaseWinOptions, initializing optional components stuff, and installing P&P devices.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    WCHAR str[1024];
    NMHDR *NotifyParams;
    HCURSOR hcur;

    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(515);
            BEGIN_SECTION(L"Installing Devices Page");
            if(PreparedAlready) {
                //
                // Don't activate; we've already been here before.
                // Nothing to do.
                //
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            } else {

                if(AsrIsEnabled()) {
                    //
                    // If this is ASR, load the appropriate wizard page
                    //
                    SetWizardButtons(hdlg, WizPagePreparingAsr);
                }

                //
                // Need to prepare for installation.
                // Want next/back buttons disabled until we're done.
                //
                PropSheet_SetWizButtons(GetParent(hdlg),0);
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
                PostMessage(hdlg,WM_IAMVISIBLE,0,0);
                PreparedAlready = TRUE;
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Installing Devices Page");

        default:
            break;
        }

        break;

    case WM_IAMVISIBLE:
        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));

        OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS1),GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
        // Do calls into the billboard to prepare the progress there.
        if(!LoadString(MyModuleHandle, IDS_BB_INSTALLING_DEVICES, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT,0,(LPARAM)str);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);

        if(!UiTest) {

            ULONG StartAtPercent = 0;
            ULONG StopAtPercent = 0;
            if (AsrIsEnabled()) {
                //
                // Update the UI
                //
                SetFinishItemAttributes(hdlg,
                    IDC_ASR_PNP_BMP,
                    LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS),
                    IDC_ASR_PNP_TXT,
                    FW_BOLD
                    );
            }

            if( !MiniSetup ){
                //
                //  Set Security use 10% of gauge
                //
                StopAtPercent  = 30;

                RemainingTime = CalcTimeRemaining(Phase_InstallSecurity);
                SetRemainingTime(RemainingTime);

                BEGIN_SECTION(L"Installing security");
                SetupInstallSecurity(hdlg,
                            GetDlgItem(hdlg, IDC_PROGRESS1),
                            StartAtPercent,
                            StopAtPercent
                            );
                END_SECTION(L"Installing security");
                CallSceSetupRootSecurity();
                SetupDebugPrint(L"SETUP: CallSceSetupRootSecurity started");

            }

            //
            //  Installation of PnP devices use the last 95% of the gauge
            //
            StartAtPercent = StopAtPercent;
            StopAtPercent  = 100;

            BEGIN_SECTION(L"Installing PnP devices");

            if (UninstallEnabled) {
                //
                // If uninstall mode, revert the timeout back to 5 seconds, so
                // PNP can reboot for failed device detections
                //

                ChangeBootTimeout (HARWARE_DETECTION_BOOT_TIMEOUT);
            }

            InstallPnpDevices(hdlg,
                              SyssetupInf,
                              GetDlgItem(hdlg,IDC_PROGRESS1),
                              StartAtPercent,
                              StopAtPercent
                             );
            END_SECTION(L"Installing PnP devices");

            if (AsrIsEnabled()) {
                //
                // Update the UI
                //
                SetFinishItemAttributes(hdlg,
                    IDC_ASR_PNP_BMP,
                    LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS),
                    IDC_ASR_PNP_TXT,
                    FW_NORMAL
                    );
            }

            if( !MiniSetup ) {
                BEGIN_SECTION(L"Loading service pack (phase 2)");
                CALL_SERVICE_PACK( SVCPACK_PHASE_2, 0, 0, 0 );
                END_SECTION(L"Loading service pack (phase 2)");
            }

            if(ScreenReader) {
                InvokeExternalApplication(L"narrator.exe", L"", NULL);
            }
        }

        SetCursor(hcur);

        SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS1),GWLP_WNDPROC,(LONG_PTR)OldProgressProc );
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

        //
        // Enable next and back buttons and move to next page.
        //
        SetWizardButtons(hdlg,WizPagePreparing);
        if(!UiTest) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
SetupPreNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

{
    NMHDR *NotifyParams;
    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(516);
            // Update time remaining.
            // The network code knows how to hide the wizard pages
            // and make them visible no need to do that here.
            RemainingTime = CalcTimeRemaining(Phase_NetInstall);
            SetRemainingTime(RemainingTime);
            BEGIN_SECTION(L"Network Setup Pages");

            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            break;
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
SetupPostNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

{
    NMHDR *NotifyParams;
    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(517);
            END_SECTION(L"Network Setup Pages");
            // Hide the progress bar when we get here.
            // Just to make sure. There are scenarios where the progress bar was still visible
            //
            SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

            // update the time estimate display
            // no need to make the wizard visible. The OC manager does this if needed.
            RemainingTime = CalcTimeRemaining(Phase_OCInstall);
            SetRemainingTime(RemainingTime);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);

            if(Win32ComputerName[0]){
                SetEnvironmentVariable(L"COMPUTERNAME", Win32ComputerName);
            }
            break;
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\vdm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    Routines to configure the MS-DOS subsystem.

Author:

    Ted Miller (tedm) 27-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Keywords whose presence in config.sys indicate OS/2.
//
PCSTR Os2ConfigSysKeywords[] = { "DISKCACHE", "LIBPATH",   "PAUSEONERROR",
                                 "RMSIZE",    "RUN",       "SWAPPATH",
                                 "IOPL",      "MAXWAIT",   "MEMMAN",
                                 "PRIORITY",  "PROTSHELL", "PROTECTONLY",
                                 "THREADS",   "TIMESLICE", "TRACE",
                                 "TRACEBUF",  "DEVINFO",   NULL
                               };

//
// Keywords we migrate from the user's existing DOS config.sys
// into config.nt.
//
#define NUM_DOS_KEYWORDS 4
PCSTR DosConfigSysKeywords[NUM_DOS_KEYWORDS] = { "FCBS","BREAK","LASTDRIVE","FILES" };

BOOL
DosConfigSysExists(
    IN PCWSTR Filename
    );

BOOL
CreateConfigNt(
    IN PCWSTR ConfigDos,
    IN PCWSTR ConfigTmp,
    IN PCWSTR ConfigNt
    );

PSTR
IsolateFirstField(
    IN  PSTR   Line,
    OUT PSTR  *End,
    OUT PCHAR  Terminator
    );

BOOL
ConfigureMsDosSubsystem(
    VOID
    )

/*++

Routine Description:

    Configure the 16-bit MS-DOS subsystem.
    Currently this means creating config.nt and autoexec.nt.
    It also means creating empty config.sys, autoexec.bat, io.sys and msdos.sys
    if these files don't already exist.

    On the upgrade, the only thing that we do is to create the empty files,
    if they don't already exist.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    WCHAR ConfigDos[] = L"?:\\CONFIG.SYS";
    WCHAR ConfigTmp[MAX_PATH];
    WCHAR ConfigNt[MAX_PATH];

    WCHAR AutoexecDos[] = L"?:\\AUTOEXEC.BAT";
    WCHAR AutoexecTmp[MAX_PATH];
    WCHAR AutoexecNt[MAX_PATH];

    WCHAR IoSysFile[] = L"?:\\IO.SYS";
    WCHAR MsDosSysFile[] = L"?:\\MSDOS.SYS";

    WCHAR ControlIniFile[MAX_PATH];

    BOOL b;
    DWORD Result;

    ULONG   i;
    HANDLE  FileHandle;
    PWSTR   DosFileNames[] = {
                         ConfigDos,
                         AutoexecDos,
                         IoSysFile,
                         MsDosSysFile,
                         ControlIniFile
                         };
    DWORD   DosFileAttributes[] = {
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                                  FILE_ATTRIBUTE_NORMAL
                                  };
    //
    // Fill in drive letter of system partition.
    //
#ifdef _X86_
    ConfigDos[0] = x86SystemPartitionDrive;
    AutoexecDos[0] = x86SystemPartitionDrive;
    IoSysFile[0]   = x86SystemPartitionDrive;
    MsDosSysFile[0] = x86SystemPartitionDrive;
#else
    ConfigDos[0] = L'C';
    AutoexecDos[0] = L'C';
    IoSysFile[0]   = L'C';
    MsDosSysFile[0] = L'C';
#endif
    //
    //  Build path to control.ini file
    //
    Result = GetWindowsDirectory(ControlIniFile, MAX_PATH - ARRAYSIZE(L"control.ini"));
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths(ControlIniFile,L"control.ini",MAX_PATH,NULL);

    //
    //  Create empty config.sys, autoexec.bat, io.sys, msdos.sys and control.ini
    //  if they don't exist. This is because some 16-bit apps depend on
    //  these files and SudeepB wants this moved from VDM to setup.
    //
    for( i = 0; i < sizeof( DosFileNames ) / sizeof( PWSTR ); i++ ) {
        FileHandle = CreateFile( DosFileNames[i],
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,          // File is not to be shared
                                 NULL,       // No security attributes
                                 CREATE_NEW, // Create only if it doesn't exist
                                 DosFileAttributes[i],
                                 NULL );     // No extended attributes
        if( FileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( FileHandle );
        }
    }
    if( Upgrade ) {
        return( TRUE );
    }

    //
    // Form filenames.
    //
    if(!GetSystemDirectory(ConfigTmp,MAX_PATH)){
        MYASSERT(FALSE);
    }
    lstrcpy(ConfigNt,ConfigTmp);
    lstrcpy(AutoexecNt,ConfigTmp);
    lstrcpy(AutoexecTmp,ConfigTmp);
    pSetupConcatenatePaths(ConfigTmp,L"CONFIG.TMP",MAX_PATH,NULL);
    pSetupConcatenatePaths(ConfigNt,L"CONFIG.NT",MAX_PATH,NULL);
    pSetupConcatenatePaths(AutoexecTmp,L"AUTOEXEC.TMP",MAX_PATH,NULL);
    pSetupConcatenatePaths(AutoexecNt,L"AUTOEXEC.NT",MAX_PATH,NULL);

    //
    // If the temp files don't exist, we're done.
    // If they do, set their attributes so that we can delete them later.
    //
    if(!FileExists(ConfigTmp,NULL) || !FileExists(AutoexecTmp,NULL)) {
        return(TRUE);
    }
    SetFileAttributes(ConfigTmp,FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(AutoexecTmp,FILE_ATTRIBUTE_NORMAL);

    //
    // Get rid of any existing nt config files. We don't support
    // merging/upgrading them; we support only ooverwriting them.
    //
    SetFileAttributes(ConfigNt,FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(AutoexecNt,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(ConfigNt);
    DeleteFile(AutoexecNt);

    //
    // If a DOS config.sys exists, merge the template config.sys
    // and the dos config.sys to form the nt config.sys.
    // Otherwise move the config.sys template over to be the
    // nt config file.
    //
    if(DosConfigSysExists(ConfigDos)) {
        b = CreateConfigNt(ConfigDos,ConfigTmp,ConfigNt);
    } else {
        b = MoveFile(ConfigTmp,ConfigNt);
    }

    //
    // We don't do anything special with autoexec.bat.
    // Just move the template over to be the nt file.
    //
    if(!MoveFile(AutoexecTmp,AutoexecNt)) {
        b = FALSE;
    }

    return(b);
}


BOOL
DosConfigSysExists(
    IN PCWSTR Filename
    )

/*++

Routine Description:

    Determine whether a given file is a DOS config.sys.

Arguments:

    Filename - supplies name of file to check.

Return Value:

    TRUE if the file exists and is not an OS/2 config.sys.
    FALSE if the file does not exist or is an OS/2 config.sys.

--*/

{
    BOOL b;
    FILE *f;
    CHAR Line[512];
    UINT i;
    PCHAR p;
    CHAR c;
    PSTR End;
    PSTR filename;

    filename = pSetupUnicodeToAnsi(Filename);
    if(!filename) {
        return(FALSE);
    }

    b = FALSE;
    if(FileExists(Filename,NULL)) {

        b = TRUE;
        if(f = fopen(filename,"rt")) {

            while(b && fgets(Line, ARRAYSIZE(Line),f)) {

                if(p = IsolateFirstField(Line,&End,&c)) {
                    for(i=0; b && Os2ConfigSysKeywords[i]; i++) {

                        if(!lstrcmpiA(p,Os2ConfigSysKeywords[i])) {
                            b = FALSE;
                        }
                    }
                }
            }

            fclose(f);
        }
    }

    MyFree(filename);
    return(b);
}


BOOL
CreateConfigNt(
    IN PCWSTR ConfigDos,
    IN PCWSTR ConfigTmp,
    IN PCWSTR ConfigNt
    )

/*++

Routine Description:

    Create config.nt. This is done by merging config.tmp (copied during setup)
    and the user's existing DOS config.sys. We migrate certain lines from
    the DOS config.sys into config.nt.

Arguments:

    ConfigDos - supplies filename of DOS config.sys.

    ConfigTmp - supplies filename of template config.sys.

    ConfigNt - supplies filename of config.nt to be created.

Return Value:

    Boolean value indicating outcome.

--*/

{
    FILE *DosFile;
    FILE *NtFile;
    FILE *TmpFile;
    BOOL b;
    CHAR Line[512];
    PCHAR p;
    BOOL Found;
    BOOL SawKeyword[NUM_DOS_KEYWORDS];
    PCSTR FoundKeyword[NUM_DOS_KEYWORDS];
    PSTR FoundLine[NUM_DOS_KEYWORDS];
    UINT KeywordsFound;
    CHAR c;
    PSTR End;
    PCSTR configDos,configTmp,configNt;
    UINT i;

    //
    // Open the dos file for reading.
    // Create the nt file for writing.
    // Open the template file for reading.
    //
    b = FALSE;
    if(configDos = pSetupUnicodeToAnsi(ConfigDos)) {
        DosFile = fopen(configDos,"rt");
        MyFree(configDos);
        if(!DosFile) {
            goto err0;
        }
    } else {
        goto err0;
    }
    if(configNt = pSetupUnicodeToAnsi(ConfigNt)) {
        NtFile = fopen(configNt,"wt");
        MyFree(configNt);
        if(!NtFile) {
            goto err1;
        }
    } else {
        goto err1;
    }
    if(configTmp = pSetupUnicodeToAnsi(ConfigTmp)) {
        TmpFile = fopen(configTmp,"rt");
        MyFree(configTmp);
        if(!TmpFile) {
            goto err2;
        }
    } else {
        goto err2;
    }

    //
    // Process the DOS file. Read each line and see if it's one
    // we care about. If so, save it for later.
    //
    ZeroMemory(SawKeyword,sizeof(SawKeyword));
    KeywordsFound = 0;
    while(fgets(Line,ARRAYSIZE(Line),DosFile)) {
        //
        // Isolate the first field.
        //
        if(p = IsolateFirstField(Line,&End,&c)) {

            //
            // See if we care about this line.
            //
            for(i=0; i<NUM_DOS_KEYWORDS; i++) {
                if(!SawKeyword[i] && !lstrcmpiA(p,DosConfigSysKeywords[i])) {
                    //
                    // Remember that we saw this line and save away
                    // the rest of the line for later.
                    //
                    *End = c;
                    SawKeyword[i] = TRUE;
                    FoundKeyword[KeywordsFound] = DosConfigSysKeywords[i];
                    FoundLine[KeywordsFound] = MyMalloc(lstrlenA(p)+1);
                    if(!FoundLine[KeywordsFound]) {
                        goto err3;
                    }
                    lstrcpyA(FoundLine[KeywordsFound],p);
                    KeywordsFound++;
                    break;
                }
            }
        }
    }

    //
    // Look at each line in the template file.
    // If it's a line with a value we respect, make sure the line
    // does not exist in the DOS file. If it exists in the DOS file
    // use the DOS value instead.
    //
    while(fgets(Line,ARRAYSIZE(Line),TmpFile)) {

        //
        // Isolate the first field in the template line and
        // check against those we found in the DOS file.
        //
        Found = FALSE;
        if(p = IsolateFirstField(Line,&End,&c)) {
            for(i=0; i<KeywordsFound; i++) {
                if(!lstrcmpiA(FoundKeyword[i],p)) {
                    Found = TRUE;
                    break;
                }
            }
        }

        *End = c;
        if(Found) {
            //
            // Use value we found in the dos file.
            //
            fputs(FoundLine[i],NtFile);
        } else {
            //
            // Use line from template file as-is.
            //
            fputs(Line,NtFile);
        }
    }

    b = TRUE;

err3:
    for(i=0; i<KeywordsFound; i++) {
        MyFree(FoundLine[i]);
    }
    fclose(TmpFile);
err2:
    fclose(NtFile);
err1:
    fclose(DosFile);
err0:
    return(b);
}


PSTR
IsolateFirstField(
    IN  PSTR   Line,
    OUT PSTR  *End,
    OUT PCHAR  Terminator
    )

/*++

Routine Description:

    Isolate the first token in a line of config.sys. The first field
    starts at the first non-space/tab character, and is terminated
    by a space/tab, newline, or equals.

Arguments:

    Line - supplies pointer to line whose first field is desired.

    End - receives a pointer to the character that termianted the first
        field. That character will have been overwritten with a nul byte.

    Terminator - receives the character that terminated the first field,
        before we overwrote it with a nul byte.

Return Value:

    Pointer to the first field. If the line is blank, the return value
    will be NULL.

--*/

{
    PSTR p,q;

    //
    // Get start of first field.
    //
    p = Line;
    while((*p == ' ') || (*p == '\t')) {
        p++;
    }

    //
    // If line is empty or bogus, we're done.
    //
    if((*p == 0) || (*p == '\r') || (*p == '\n') || (*p == '=')) {
        return(NULL);
    }

    //
    // Find end of field.
    //
    q = p;
    while(*q && !strchr("\r\n \t=",*q)) {
        q++;
    }
    *End = q;
    *Terminator = *q;
    *q = 0;

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\_setup_browser.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
extern "C" {
    #include <rpcutil.h>
    #include <setup_browser.c>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\amd64\platform.c ===
#include "setupp.h"
#pragma hdrstop

WCHAR x86SystemPartitionDrive;

WCHAR FloppylessBootPath[MAX_PATH];

UINT
PlatformSpecificInit(
    VOID
    )
{
    //
    // Determine x86 system partition (usually but not always C:).
    //
    x86SystemPartitionDrive = x86DetermineSystemPartition();
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\amd64\bootini.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{

    HFILE hfile;
    ULONG FileSize;
    PUCHAR buf = NULL,p1,p2;
    BOOL b;
    CHAR TimeoutLine[256];
    CHAR szBootIni[] = "?:\\BOOT.INI";

    szBootIni[0] = (CHAR)x86SystemPartitionDrive;
    wsprintfA(TimeoutLine,"timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //

    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {
        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {
            if((_llseek(hfile,0,0) != -1)
            && (buf = MyMalloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            MyFree(buf);
        }

        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        MyFree(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.

    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);
    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        MyFree(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile, buf, (UINT)(p1 - buf)) != (UINT)(-1))
      &&  (_lwrite(hfile, TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile, p2, (UINT)(buf + FileSize - p2)) != (UINT)(-1)));

    _lclose(hfile);
    MyFree(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    if (!SetFileAttributesA(szBootIni,
                            FILE_ATTRIBUTE_READONLY | 
                            FILE_ATTRIBUTE_SYSTEM | 
                            FILE_ATTRIBUTE_ARCHIVE | 
                            FILE_ATTRIBUTE_HIDDEN)){
        //
        // If we failed to set attributes on boot.ini log the error
        //
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FAILURE_SETTING_FILE_ATTR,
            pSetupAnsiToUnicode(szBootIni),
            NULL,NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\amd64\spx86.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    Header file for x86-specific stuff in system installation module.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#if defined(_AMD64_)

WCHAR
x86DetermineSystemPartition(
    VOID
    );

extern WCHAR x86SystemPartitionDrive;
extern WCHAR FloppylessBootPath[MAX_PATH];

//
// Pci Hal property page provider (pcihal.c).
//

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    );

BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\amd64\pcihal.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pcihal.c

Abstract:

    Routines for the Pci Hal property page.

Author:

    Santosh Jodh 10-July-1998

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>

#include <strsafe.h>

#define MSG_SIZE    2048

#define Allocate(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define Release(p)  HeapFree(GetProcessHeap(), 0, (LPVOID)p)

typedef struct _PciHalPropData PCIHALPROPDATA, *PPCIHALPROPDATA;

struct _PciHalPropData {
    HKEY                LocalMachine;
    BOOLEAN             CloseKey;
    DWORD               Options;
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;    
};  

const DWORD gPciPropHelpIds[] = 
{
    IDC_PCIHAL_ICON,        (DWORD)-1,              // Icon
    IDC_PCIHAL_DEVDESC,     (DWORD)-1,              // Name of PC
    IDC_PCIHAL_ENABLE,      IDH_IRQ_ENABLE,         // Enable IRQ Routing
    IDC_PCIHAL_MSSPEC,      IDH_IRQ_MSSPEC,         // Use $PIR table
    IDC_PCIHAL_REALMODE,    IDH_IRQ_REALMODE,       // Use table from Real-mode BIOS call
    IDC_PCIHAL_SETDEFAULTS, IDH_IRQ_SETDEFAULTS,    // Set defaults for options
    IDC_PCIHAL_RESULTS,     IDH_IRQ_RESULTS,        // Status information    
    0,0
};

//
// Table used to translate status codes into string ids.
//
UINT gStatus[PIR_STATUS_MAX + 1] =              {   IDS_PCIHAL_ERROR, 
                                                    IDS_PCIHAL_ENABLED, 
                                                    IDS_PCIHAL_DISABLED,
                                                    IDS_PCIHAL_NOSTATUS
                                                };
UINT gTableStatus[PIR_STATUS_TABLE_MAX] =       {   IDS_PCIHAL_TABLE_REGISTRY, 
                                                    IDS_PCIHAL_TABLE_MSSPEC,
                                                    IDS_PCIHAL_TABLE_REALMODE,
                                                    IDS_PCIHAL_TABLE_NONE,
                                                    IDS_PCIHAL_TABLE_ERROR,                                                    
                                                    IDS_PCIHAL_TABLE_BAD,
                                                    IDS_PCIHAL_TABLE_SUCCESS
                                                };
UINT gMiniportStatus[PIR_STATUS_MINIPORT_MAX] = {   IDS_PCIHAL_MINIPORT_NORMAL, 
                                                    IDS_PCIHAL_MINIPORT_COMPATIBLE, 
                                                    IDS_PCIHAL_MINIPORT_OVERRIDE, 
                                                    IDS_PCIHAL_MINIPORT_NONE,
                                                    IDS_PCIHAL_MINIPORT_ERROR,                                                    
                                                    IDS_PCIHAL_MINIPORT_NOKEY,
                                                    IDS_PCIHAL_MINIPORT_SUCCESS,
                                                    IDS_PCIHAL_MINIPORT_INVALID
                                                };

PCIHALPROPDATA  gPciHalPropData = {0};

VOID
PciHalSetControls (
    IN HWND Dialog,
    IN DWORD Options,
    IN DWORD Attributes
    )

/*++

    Routine Description:

        This routine sets the controls on the Irq Routing page to the
        specified options.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        Options -  Pci Irq Routing options to be displayed.
        
    Return Value:

        None.
        
--*/

{
    BOOL enabled = FALSE;

    //
    // Enable the buttons depending on the options.
    //
    if (Options & PIR_OPTION_ENABLED) {

        enabled = TRUE;
        CheckDlgButton(Dialog, IDC_PCIHAL_ENABLE, 1);
    }

    CheckDlgButton(Dialog, IDC_PCIHAL_MSSPEC, Options & PIR_OPTION_MSSPEC);
    CheckDlgButton(Dialog, IDC_PCIHAL_REALMODE, Options & PIR_OPTION_REALMODE);
    
    //
    // Gray the windows not meaningful.
    //    
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_ENABLE), 
                            !(Attributes & PIR_OPTION_ENABLED)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_SETDEFAULTS), 
                            !(Attributes & PIR_OPTION_ENABLED)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_MSSPEC), 
                            enabled && !(Attributes & PIR_OPTION_MSSPEC)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_REALMODE), 
                            enabled && !(Attributes & PIR_OPTION_REALMODE)
                 );

}

LPTSTR
PciHalGetDescription (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

    Routine Description:

        This routine allocates memory and returns the device description
        for the specified device.

    Input Parameters:

        DeviceInfoSet - For the device.

        DeviceInfoData - For the device.

    Return Value:

        Pointer to the description iff successful. Else NULL.
        
--*/

{
    LPTSTR desc;
    DWORD   size;
    
    desc = NULL;
    
    //
    // Get the size of the description for this device.
    //
    size = 0;
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DEVICEDESC,
                                     NULL,
                                     NULL,
                                     0,
                                     &size
                                     );
    if (size != 0) {

        //
        // Account for the terminating NULL character.
        //
        size++;
        
        //
        // Allocate memory for the device description.
        //
        desc = Allocate(size * sizeof(TCHAR));

        if (desc != NULL) {

            //
            // Get the device description.
            //
            if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_DEVICEDESC,
                                                 NULL,
                                                 (PBYTE)desc,
                                                 size * sizeof(TCHAR),
                                                 &size) == FALSE) {

                Release(desc);
                desc = NULL;
            }
        }
    }

    return desc;
}

LPTSTR
PciHalGetStatus (
    IN DWORD Status,
    IN DWORD TableStatus,
    IN DWORD MiniportStatus
    )

/*++

    Routine Description:

        This routine converts the different status codes into
        a status string and returns the pointer to the string.
        The caller should free the memory when done using this
        string.

    Input Parameters:

        Status - Pci Irq Routing status.

        TableStatus - Pci Irq Routing Table status. Lower WORD
        indicates the source of the table. The upper WORD indicates
        the table processing status.

        MiniportStatus - Pci Irq Routing Miniport status. Lower
        WORD indicates the source of the miniport. The upper WORD
        indicates the miniport processing status.

    Return Value:

        Pointer to the status string iff successful. Else NULL.
        
--*/

{
    LPTSTR  status;
    TCHAR   temp[128];
    DWORD   statusLength;

    statusLength = MSG_SIZE;
    status = Allocate(statusLength * sizeof(TCHAR));
    if (status) {

        //
        // Get the status about Pci Irq Routing.
        //
        status[0] = TEXT('\0');
        LoadString(MyModuleHandle, gStatus[Status], status, MSG_SIZE);        

        //
        // Get the status about the source of Pci Irq Routing Table.
        //
        if ((TableStatus & 0xFFFF) < PIR_STATUS_TABLE_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gTableStatus[TableStatus & 0xFFFF], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the Pci Irq Routing table.
        //
        TableStatus >>= 16;
        if (TableStatus < PIR_STATUS_TABLE_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, gTableStatus[TableStatus], temp, ARRAYSIZE(temp));
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the source of the miniport.
        //
        if ((MiniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gMiniportStatus[MiniportStatus & 0xFFFF], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the miniport status.
        //
        MiniportStatus >>= 16;
        if (MiniportStatus < PIR_STATUS_MINIPORT_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gMiniportStatus[MiniportStatus], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }
    }

    return status;
}

BOOL
PciHalOnInitDialog (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine initializes the property sheet page on creation.
        
    Input Paramters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_INITDIALOG message.

        lParam - Pointer to the property sheet page.
        
    Return Value:

        TRUE.
        
--*/

{   
    PPCIHALPROPDATA             pciHalPropData;
    HKEY                        hKey;
    DWORD                       size;    
    DWORD                       status;
    DWORD                       tableStatus;
    DWORD                       miniportStatus;
    DWORD                       attributes;
    HICON                       hIconOld;
    HICON                       hIconNew;
    INT                         iconIndex;
    LPTSTR                      desc;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    
    pciHalPropData = (PPCIHALPROPDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    //
    // Read the Pci Irq Routing options and status from the registry.
    //
    pciHalPropData->Options = 0;
    status = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);
    details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    attributes = PIR_OPTION_ENABLED | PIR_OPTION_MSSPEC | PIR_OPTION_REALMODE;
    if (SetupDiGetDeviceInfoListDetail(pciHalPropData->DeviceInfoSet, 
                                       &details)) {

        if (RegConnectRegistry(
                (details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, 
                HKEY_LOCAL_MACHINE, 
                &pciHalPropData->LocalMachine) == ERROR_SUCCESS) {

            pciHalPropData->CloseKey = TRUE;
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                             REGSTR_PATH_PCIIR, 
                             0, 
                             KEY_READ, 
                             &hKey) == ERROR_SUCCESS) { 

                size = sizeof(pciHalPropData->Options);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_OPTIONS, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&pciHalPropData->Options, 
                                &size
                                );

                size = sizeof(status);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&status, 
                                &size);

                size = sizeof(tableStatus);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_TABLE_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&tableStatus, 
                                &size
                                );

                size = sizeof(miniportStatus);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_MINIPORT_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&miniportStatus, 
                                &size
                                );

                RegCloseKey(hKey);
            }

            //
            // Gray out the controls if the user does not have READ+WRITE access to the REGSTR_PATH_PCIIR. 
            //
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                             REGSTR_PATH_PCIIR, 
                             0, 
                             KEY_READ | KEY_WRITE, 
                             &hKey) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                attributes = 0;
                if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                                 REGSTR_PATH_BIOSINFO L"\\PciIrqRouting", 
                                 0, 
                                 KEY_READ, 
                                 &hKey) == ERROR_SUCCESS) { 

                    size = sizeof(attributes);
                    RegQueryValueEx(hKey, 
                                    L"Attributes", 
                                    NULL, 
                                    NULL, 
                                    (LPBYTE)&attributes, 
                                    &size
                                    );
                    RegCloseKey(hKey);
                }
            }
        }
    }

    //
    // Set the class icon.
    //
    if (SetupDiLoadClassIcon(   &pciHalPropData->DeviceInfoData->ClassGuid, 
                                &hIconNew, 
                                &iconIndex) == TRUE) {

        hIconOld = (HICON)SendDlgItemMessage(Dialog, 
                                             IDC_PCIHAL_ICON, 
                                             STM_SETICON,
                                             (WPARAM)hIconNew,
                                             0
                                             );
        if (hIconOld) {

            DestroyIcon(hIconOld);
        }
    }

    //
    // Set the device description.
    //
    desc = PciHalGetDescription(pciHalPropData->DeviceInfoSet, 
                                pciHalPropData->DeviceInfoData
                                );
    if (desc) {

        SetDlgItemText(Dialog, IDC_PCIHAL_DEVDESC, desc);
        Release(desc);
    }

    //
    // Set the initial state of the controls.
    //
    PciHalSetControls(Dialog, pciHalPropData->Options, attributes);

    //
    // Display status.
    //
    desc = PciHalGetStatus(status, tableStatus, miniportStatus);
    if (desc) {

        SetDlgItemText(Dialog, IDC_PCIHAL_RESULTS, desc);
        Release(desc);
    }

    //
    // Let the system set the focus.
    //   
    return TRUE;
}

BOOL
PciHalOnCommand (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the message when the user modifies something
        on the property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_COMMAND message.

        lParam - lParam of the WM_COMMAND message.
        
    Return Value:

        TRUE if this function handles the message. Else FALSE.
    
--*/

{
    BOOL status;
    BOOL enabled;

    status = FALSE;
    
    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    
        case IDC_PCIHAL_SETDEFAULTS:

            //
            // Set the controls to the default value.
            //
            status = TRUE;
            PciHalSetControls(Dialog, PIR_OPTION_DEFAULT, 0);
            break;

        case IDC_PCIHAL_ENABLE:

            //
            // Gray out the sub-options if Irq Routing is being disabled.
            //            
            status = TRUE;
            enabled = IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled);            
            break;

        default:
        
            break;
    }

    return status;
}

BOOL
PciHalOnNotify(
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the WM_NOTIFY message for the Pci Irq Routing
        property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_NOTIFY message.

        lParam - lParam of the WM_NOTIFY message.
    
    Return Value:

        TRUE if this function handles the message. Else FALSE.
        
--*/

{
    BOOL                    status = FALSE;
    HKEY                    hKey;
    DWORD                   options;
    
    switch (((LPNMHDR)lParam)->code) {
    
        case PSN_RESET:        

            //
            // User hit cancel.
            //
            status = TRUE;

            if (RegOpenKey(gPciHalPropData.LocalMachine, 
                           REGSTR_PATH_PCIIR,
                           &hKey) == ERROR_SUCCESS) {

                RegSetValueEx(hKey, 
                              REGSTR_VAL_OPTIONS, 
                              0, 
                              REG_DWORD, 
                              (CONST BYTE *)&gPciHalPropData.Options, 
                              sizeof(gPciHalPropData.Options)
                              );
                RegCloseKey(hKey);
            }
            
            break;
            
        case PSN_APPLY:

            //
            // User hit Apply or Ok.
            //
            status = TRUE;
            
            //
            // Read the different control status and write it to the registry.
            //
            options = gPciHalPropData.Options;
            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE) == BST_CHECKED)
            {
                options |= PIR_OPTION_ENABLED;
            }
            else
            {
                options &= ~PIR_OPTION_ENABLED;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_MSSPEC))
            {
                options |= PIR_OPTION_MSSPEC;
            }
            else
            {
                options &= ~PIR_OPTION_MSSPEC;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_REALMODE))
            {
                options |= PIR_OPTION_REALMODE;
            }
            else
            {
                options &= ~PIR_OPTION_REALMODE;
            }

            if (RegOpenKey(gPciHalPropData.LocalMachine, 
                           REGSTR_PATH_PCIIR, 
                           &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&options, 
                                sizeof(options));
                RegCloseKey(hKey);
            }

            //
            // Reboot if any of the options changed.
            //
            if (options != gPciHalPropData.Options)
            {
                SP_DEVINSTALL_PARAMS    deviceInstallParams;

                ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
                deviceInstallParams.cbSize = sizeof(deviceInstallParams);
                if (SetupDiGetDeviceInstallParams(gPciHalPropData.DeviceInfoSet, 
                                                  gPciHalPropData.DeviceInfoData, 
                                                  &deviceInstallParams)) {

                    deviceInstallParams.Flags |= DI_NEEDREBOOT;
                    SetupDiSetDeviceInstallParams(gPciHalPropData.DeviceInfoSet, 
                                                  gPciHalPropData.DeviceInfoData, 
                                                  &deviceInstallParams
                                                  );                    
                }
            }
            
            break;

        default:

            break;
    }

    return status;
}

INT_PTR
CALLBACK
PciHalDialogProc(
    IN HWND Dialog,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This is the DlgProc for the Pci Irq Routing property sheet page.
        
    Input Parameters:

        Standard DlgProc parameters.
        
    Return Value:

        TRUE if it handles the message. Else FALSE.
        
--*/

{
    BOOL    status = FALSE;
    PCWSTR  szHelpFile = L"devmgr.hlp";
    HICON hIconOld;
    
    switch (Message) {
    
        case WM_INITDIALOG:

            status = PciHalOnInitDialog(Dialog, wParam, lParam);
            break;

        case WM_COMMAND:

            status = PciHalOnCommand(Dialog, wParam, lParam);
            break;

        case WM_NOTIFY:

            status = PciHalOnNotify(Dialog, wParam, lParam);
            break;

        case WM_HELP:
            
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    szHelpFile, 
                    HELP_WM_HELP, 
                    (ULONG_PTR)gPciPropHelpIds
                    );
            status = TRUE;
            break;
            
        case WM_CONTEXTMENU:

            WinHelp((HWND)wParam, 
                    szHelpFile, 
                    HELP_CONTEXTMENU, 
                    (ULONG_PTR)gPciPropHelpIds
                    );
            status = TRUE;
            break;

        case WM_DESTROY:

            if (gPciHalPropData.CloseKey) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                gPciHalPropData.CloseKey = FALSE;
            }
            hIconOld = (HICON)SendDlgItemMessage(Dialog, 
                                                 IDC_PCIHAL_ICON, 
                                                 STM_GETICON,
                                                 (WPARAM)0,
                                                 0
                                                 );
            if (hIconOld) {

                DestroyIcon(hIconOld);
            }

        
        default:

            break;
    }

    return status;
}

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
    BOOL                        status;
    HPROPSHEETPAGE              pageHandle;
    PROPSHEETPAGE               page;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    SP_ADDPROPERTYPAGE_DATA     addPropertyPageData;

    switch (InstallFunction) {
    case DIF_ADDPROPERTYPAGE_ADVANCED:        
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:

        details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
        if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &details)) {

            if (RegConnectRegistry(
                    (details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, 
                    HKEY_LOCAL_MACHINE, 
                &gPciHalPropData.LocalMachine) == ERROR_SUCCESS) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                status = TRUE;
                break;
            }
        }

    default:

        status = FALSE;
        break;
    }

    if (status) {

        ZeroMemory(&addPropertyPageData, sizeof(SP_ADDPROPERTYPAGE_DATA));
        addPropertyPageData.ClassInstallHeader.cbSize = 
             sizeof(SP_CLASSINSTALL_HEADER);

        if (SetupDiGetClassInstallParams(
                DeviceInfoSet, DeviceInfoData,
                (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                sizeof(SP_ADDPROPERTYPAGE_DATA), NULL )) {

           if (addPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES) {

               //
               // Initialize our globals here.
               //
               gPciHalPropData.DeviceInfoSet    = DeviceInfoSet;
               gPciHalPropData.DeviceInfoData   = DeviceInfoData;

               //
               // Initialize our property page here.
               //
               ZeroMemory(&page, sizeof(PROPSHEETPAGE));
               page.dwSize      = sizeof(PROPSHEETPAGE);
               page.hInstance   = MyModuleHandle;
               page.pszTemplate = MAKEINTRESOURCE(IDD_PCIHAL_PROPPAGE);
               page.pfnDlgProc  = PciHalDialogProc;
               page.lParam      = (LPARAM)&gPciHalPropData;

               pageHandle = CreatePropertySheetPage(&page);
               if (pageHandle != NULL)
               {

                   addPropertyPageData.DynamicPages[addPropertyPageData.NumDynamicPages++] = pageHandle;
                    SetupDiSetClassInstallParams(
                        DeviceInfoSet, DeviceInfoData,
                        (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                        sizeof(SP_ADDPROPERTYPAGE_DATA)
                        );

                    return NO_ERROR;
               }
           }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\wizard.c ===
#include "setupp.h"
#pragma hdrstop

#ifdef _OCM
#include <ocmanage.h>
#include <ocmgrlib.h>
#endif

extern BOOLEAN
AsrIsEnabled( VOID );

typedef struct _WIZPAGE {
    UINT ButtonState;
    UINT Spare;
    PROPSHEETPAGE Page;
} WIZPAGE, *PWIZPAGE;

BOOL UiTest;

//
// "Page" that is actually a signal to fetch the net pages
// and insert them there.
//
#define WizPagePlaceholderNet   (WizPageMaximum+1)
#define WizPagePlaceholderLic   (WizPageMaximum+2)
BOOL NetWizard;

#ifdef _OCM
#define WizPageOcManager        (WizPageMaximum+3)
#define WizPageOcManagerSetup   (WizPageMaximum+4)
#define WizPageOcManagerEarly   (WizPageMaximum+5)
#define WizPageOcManagerPrenet  (WizPageMaximum+6)
#define WizPageOcManagerPostnet (WizPageMaximum+7)
#define WizPageOcManagerLate    (WizPageMaximum+8)
#endif

#define MAX_LICWIZ_PAGES MAX_NETWIZ_PAGES
#define LICENSESETUPPAGEREQUESTPROCNAME "LicenseSetupRequestWizardPages"

//
// These MUST be in the same order as the items in the WizPage enum!!!
//
WIZPAGE SetupWizardPages[WizPageMaximum] = {

    //
    // Welcome page
    //
    {
       PSWIZB_NEXT,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_WELCOME),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       WelcomeDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL                                     // ref count
    }},

    //
    // EULA page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_EULA),               // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       EulaDlgProc,                             // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_EULA,                       // title
       (LPCWSTR)IDS_EULA_SUB,                   // subtitle
    }},

    //
    // Preparing Directory page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PREPARING),          // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PreparingDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_PREPARING_INSTALL,          // title
       (LPCWSTR)IDS_PREPARING_INSTALL_SUB,      // subtitle
    }},

    //
    // Preparing ASR page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE, NULL,   // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PREPARING_ASR),          // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PreparingDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_ASR,                        // title
       (LPCWSTR)IDS_ASR_SUB,                    // subtitle
    }},


    //
    // International settings (locale, kbd layout) page
    //
    {
        PSWIZB_NEXT | PSWIZB_BACK,
        0,
     {  sizeof(PROPSHEETPAGE),                  // size of struct
        PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
        NULL,                                   // hInst (filled in at run time)
        MAKEINTRESOURCE(IDD_REGIONAL_SETTINGS), // dlg template
        NULL,                                   // icon
        NULL,                                   // title
        RegionalSettingsDlgProc,                // dlg proc
        0,                                      // lparam
        NULL,                                   // callback
        NULL,                                   // ref count
        (LPCWSTR)IDS_REGIONAL_SETTINGS,
        (LPCWSTR)IDS_REGIONAL_SETTINGS_SUB
    }},

    //
    // Name/organization page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_NAMEORG),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       NameOrgDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_NAMEORG,                    // title
       (LPCWSTR)IDS_NAMEORG_SUB                 // subtitle
    }},

    //
    // Product id page for CD
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_CD),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30CDDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_PID,                        // title
       (LPCWSTR)IDS_PID_SUB                     // subtitle
    }},

    //
    // Product id page for OEM
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_OEM),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30OemDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_OEM,                        // title
       (LPCWSTR)IDS_OEM_SUB                     // subtitle
    }},

    //
    // Product id page for Select media
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_SELECT),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30SelectDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_SELECT,                        // title
       (LPCWSTR)IDS_SELECT_SUB                     // subtitle
    }},
    //
    // Computer name page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_COMPUTERNAME),       // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       ComputerNameDlgProc,                     // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_COMPUTERNAME,               // title
       (LPCWSTR)IDS_COMPUTERNAME_SUB            // subtitle
    }},

#ifdef DOLOCALUSER
    //
    // Local user account page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_USERACCOUNT),        // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       UserAccountDlgProc,                      // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_USERNAME,                   // title
       (LPCWSTR)IDS_USERNAME_SUB                // subtitle
    }},
#endif

#ifdef _X86_
    //
    // Pentium errata page (x86 only)
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PENTIUM),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PentiumDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_FPERRATA,                   // title
       (LPCWSTR)IDS_FPERRATA_SUB                // subtitle
    }},
#endif // def _X86_

    //
    // Intermediate steps page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       StepsDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    {
       0,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       SetupPreNetDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},
    {
       0,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       SetupPostNetDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    //
    // Copying files page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_COPYFILES3),         // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       CopyFilesDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_COPYFILES,                  // title
       (LPCWSTR)IDS_COPYFILES_SUB2,             // subtitle
    }},

    //
    // Last ASR page.
    //
    {
       PSWIZB_FINISH,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_ASR_PAGE),   // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       LastPageDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    //
    // Last page.
    //
    {
       PSWIZB_FINISH,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_WIZARD_PAGE),   // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       LastPageDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }}
};


UINT InitialWizardPages[] = { WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
                              WizPageComputerName,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
#ifdef DOLOCALUSER
                              WizPageUserAccount,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                            };

UINT AsrWizardPages[] =     { WizPagePreparingAsr,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageAsrLast
                            };

UINT UpgradeWizardPages[] = { WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
                              WizPageRegionalSettings,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                            };


UINT UiTestWizardPages[] = {  WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPageComputerName,
#ifdef DOLOCALUSER
                              WizPageUserAccount,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif // def _X86_
                              WizPageSteps1,
                              WizPageCopyFiles,
                              WizPageLast
                           };


UINT MiniSetupWizardPages[] = {
                              WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
                              WizPageComputerName,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizPagePlaceholderNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                           };





#define TIME_INITIALIZE         120
#define TIME_INSTALLSECURITY    30
#define TIME_PRECOMPILEINFS     90      // calc something with #infs and throughput
#define TIME_INSTALLDEVICES     330     // How can we calc a better number?
                                        // Also Pre compile INFs is part of Device Install page
#define TIME_INSTALLENUMDEVICES1 120
#define TIME_INSTALLLEGACYDEVICES  30
#define TIME_INSTALLENUMDEVICES2 60

#define TIME_NETINSTALL         150     // need better number
#define TIME_OCINSTALL          420     // need better number
#define TIME_INSTALLCOMPONENTINFS 240   // need better number
#define TIME_INF_REGISTRATION   300     // need better number
#define TIME_RUNONCE_REGISTRATION 120     // need better number
#define TIME_SECURITYTEMPLATE   150     // need better number
#define TIME_WIN9XMIGRATION     120     // Need better number
#define TIME_SFC                420
#define TIME_SAVEREPAIR         30
#define TIME_REMOVETEMOFILES    30

#define TIME_ALL                2190

//
// The entries in this array need to correcpond to the enum SetupPhases in setuppp.h

SETUPPHASE SetupPhase[] = {
    { TIME_INITIALIZE,          FALSE },    // Initialize
    { TIME_INSTALLSECURITY,     FALSE },    // InstallSecurity
    { TIME_PRECOMPILEINFS,      FALSE },    // PrecompileInfs
    { TIME_INSTALLENUMDEVICES1, FALSE },    // InstallDevices
    { TIME_INSTALLLEGACYDEVICES, FALSE },
    { TIME_INSTALLENUMDEVICES2, FALSE },
    { TIME_NETINSTALL,          FALSE },     // NetInstall
    { TIME_OCINSTALL,           FALSE },     // OCInstall
    { TIME_INSTALLCOMPONENTINFS, FALSE},
    { TIME_INF_REGISTRATION,    FALSE},
    { TIME_RUNONCE_REGISTRATION, FALSE },     // Registration
    { TIME_SECURITYTEMPLATE,    FALSE },     // SecurityTempates
    { TIME_WIN9XMIGRATION,      TRUE },     // Win9xMigration
    { TIME_SFC,                 FALSE },     // SFC
    { TIME_SAVEREPAIR,          FALSE },     // SaveRepair
    { TIME_REMOVETEMOFILES,     FALSE }     // RemoveTempFiles
};

UINT CurrentPhase = Phase_Unknown;
ULONG RemainingTime = 0;

#ifdef _OCM
BOOL
pOcManagerPages(
    IN     PSETUP_REQUEST_PAGES  Page,
    OUT    HPROPSHEETPAGE       *WizardPageHandles,
    IN OUT UINT                 *PageCount
    );
#endif


BOOL
GetNetworkWizardPages(
       OUT HPROPSHEETPAGE *PageHandles,
    IN OUT PUINT           PageCount
    )

/*++

Routine Description:

    This routine asks net setup for its wizard pages and passes it
    a pointer to a global structure to be used later to pass info
    back and forth between base and net setups. Net setup must not
    attempt to use any fields in there yet because they are not
    filled in yet.

Arguments:

    PropSheetHandles - receives network setup wizard page handles.

    PageCount - on input, supplies number of slots in PropSheetHandles
        array. On output, receives number of handles actually placed
        in the array.

Return Value:

    If the netsetup wizard dll could not be loaded, returns FALSE.
    Otherwise returns TRUE if no error, or does not return if error.

--*/

{
    NETSETUPPAGEREQUESTPROC PageRequestProc;
    HMODULE NetSetupModule;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = NO_ERROR;

    NetSetupModule = LoadLibrary(L"NETSHELL");
    if(!NetSetupModule) {
        //
        // If the network wizard isn't around, then the legacy network inf
        // had better be.
        //
        WCHAR x[MAX_PATH];

        if(!GetSystemDirectory(x, MAX_PATH)){
            d = GetLastError();
            goto c0;
        }

        if(pSetupConcatenatePaths(x,L"NTLANMAN.INF",MAX_PATH,NULL)){
            if(FileExists(x,NULL)) {
                return(FALSE);
            }
        }
        d = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    PageRequestProc = (NETSETUPPAGEREQUESTPROC)GetProcAddress(
                                                    NetSetupModule,
                                                    NETSETUPPAGEREQUESTPROCNAME
                                                    );
    if(!PageRequestProc) {
        d = GetLastError();
        goto c0;
    }

    //
    // Net setup needs product type really early.
    //
    SetProductTypeInRegistry();

    //
    // Call net setup to get its pages.
    //
    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);
    b = PageRequestProc(PageHandles,PageCount,&InternalSetupData);

    //
    // If we get here, d is NO_ERROR. If b is FALSE this NO_ERROR will be
    // a special case to mean "the network wizard request failed."
    // In other error cases, d will have a non-0 value.
    //

c0:
    if(!b) {
        //
        // This is fatal, something is really wrong.
        //
        FatalError(MSG_LOG_NETWIZPAGE,d,0,0);
    }

    return(TRUE);
}

BOOL
GetLicenseWizardPages(
       OUT HPROPSHEETPAGE *PageHandles,
    IN OUT PUINT           PageCount
    )

/*++

Routine Description:

    This routine asks liccpa setup for its wizard pages and passes it
    a pointer to a global structure to be used later to pass info
    back and forth between base and liccpa setups. Liccpa setup must not
    attempt to use any fields in there yet because they are not
    filled in yet.

Arguments:

    PropSheetHandles - receives liccpa setup wizard page handles.

    PageCount - on input, supplies number of slots in PropSheetHandles
        array. On output, receives number of handles actually placed
        in the array.

Return Value:

    If the liccpa dll could not be loaded, returns FALSE.
    Otherwise returns TRUE if no error, or does not return if error.

--*/

{
    NETSETUPPAGEREQUESTPROC PageRequestProc;
    HMODULE LicenseSetupModule;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = NO_ERROR;

    LicenseSetupModule = LoadLibrary(L"LICCPA.CPL");
    if(!LicenseSetupModule) {
        //
        // If the license wizard isn't around, then this is a fatal error
        //
        d = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    PageRequestProc = (NETSETUPPAGEREQUESTPROC)GetProcAddress(
                                                    LicenseSetupModule,
                                                    LICENSESETUPPAGEREQUESTPROCNAME
                                                    );
    if(!PageRequestProc) {
        d = GetLastError();
        goto c0;
    }

//    //
//    // Net setup needs product type really early.
//    //
//    SetProductTypeInRegistry();

    //
    // Call liccpa setup to get its pages.
    //
    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);
    b = PageRequestProc(PageHandles,PageCount,&InternalSetupData);

    //
    // If we get here, d is NO_ERROR. If b is FALSE this NO_ERROR will be
    // a special case to mean "the license wizard request failed."
    // In other error cases, d will have a non-0 value.
    //

c0:
    if(!b) {
        //
        // This is fatal, something is really wrong.
        //
        FatalError(MSG_LOG_LICWIZPAGE,d,0,0);
    }

    return(TRUE);
}

VOID
SetWizardButtons(
    IN HWND    hdlgPage,
    IN WizPage PageNumber
    )
{
    //
    // Dirty hack to hide cancel and help buttons.
    // We don't have any help buttons but some of the other
    // components whose pages are included here might; we want to make
    // sure that for us, the help button stays removed!
    //
    EnableWindow(GetDlgItem(GetParent(hdlgPage),IDCANCEL),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlgPage),IDCANCEL),SW_HIDE);

    EnableWindow(GetDlgItem(GetParent(hdlgPage),IDHELP),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlgPage),IDHELP),SW_HIDE);

    PropSheet_SetWizButtons(GetParent(hdlgPage),SetupWizardPages[PageNumber].ButtonState);
    SetWindowLongPtr(hdlgPage,DWLP_MSGRESULT,0);
}


VOID
WizardBringUpHelp(
    IN HWND    hdlg,
    IN WizPage PageNumber
    )
{
#if 0
    BOOL b;

    b = WinHelp(
            hdlg,
            L"setupnt.hlp",
            HELP_CONTEXT,
            SetupWizardPages[PageNumber].HelpContextId
            );

    if(!b) {
        MessageBoxFromMessage(
            hdlg,
            MSG_CANT_INVOKE_WINHELP,
            NULL,
            IDS_ERROR,
            MB_ICONSTOP | MB_OK
            );
    }
#else
    UNREFERENCED_PARAMETER(hdlg);
    UNREFERENCED_PARAMETER(PageNumber);
#endif
}


VOID
WizardKillHelp(
    IN HWND hdlg
    )
{
#if 0
    WinHelp(hdlg,NULL,HELP_QUIT,0);
#else
    UNREFERENCED_PARAMETER(hdlg);
#endif
}


WNDPROC OldWizDlgProc;

INT_PTR
NewWizDlgProc(
    IN HWND hdlg,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static RECT rect;
    static BOOL Visible = TRUE;
    BOOL b = FALSE;
    //
    // Eat WM_SYSCOMMAND where wParam is SC_CLOSE.
    // Pass all other messages on.
    //
    if((msg != WM_SYSCOMMAND) || ((wParam & 0xfff0) != SC_CLOSE))
    {
        switch (msg)
        {
            // Set the progress text
            // Indicates what setup is doing.
            case WMX_SETPROGRESSTEXT:
                BB_SetProgressText((PCTSTR)lParam);
                b = TRUE;
                break;

            case WMX_BB_SETINFOTEXT:
                BB_SetInfoText((PTSTR)lParam);
                b = TRUE;
                break;

            // Enabled, disable, show, hide the progress gauge on the billboard
            // wParam should be SW_SHOW or SW_HIDE
            case WMX_BBPROGRESSGAUGE:
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ShowProgressGaugeWnd((UINT)wParam));
                b= TRUE;
                break;

            // Start, stop the billboard text.
            // This start, stops the billboard text and shows, hides the wizard pages
    case WMX_BBTEXT:
        if (hinstBB)
        {

            if (wParam != 0)
            {
                if (Visible)
                {
                    // Get the current position of the wizard
                    // We restore this position when we need to show it.
                    GetWindowRect(hdlg, &rect);

                    SetWindowPos(hdlg,
                        GetBBhwnd(),
                        0,0,0,0,
                        SWP_NOZORDER);

                    SetActiveWindow(GetBBhwnd());

                    Visible = FALSE;
                }
            }
            else
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }

            if (!StartStopBB((wParam != 0)))
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }
        }
        else
        {
            if (!Visible)
            {
                SetWindowPos(hdlg,
                    HWND_TOP,
                    rect.left,
                    rect.top,
                    rect.right-rect.left,
                    rect.bottom-rect.top,
                    SWP_SHOWWINDOW);
            }
            Visible = TRUE;
        }
        return TRUE;
/*
            case WMX_BBTEXT:
                if (hinstBB)
                {

                    if (wParam != 0)
                    {
                        ShowWindow (hdlg, SW_HIDE);
                    }
                    else
                    {
                        ShowWindow (hdlg, SW_SHOW);
                    }

                    if (!StartStopBB((wParam != 0)))
                    {
                        ShowWindow (hdlg, SW_SHOW);
                    }
                }
                else
                {
                    ShowWindow (hdlg, SW_SHOW);
                }
                b = TRUE;
                break;
*/
            default:
                b = (BOOL)CallWindowProc(OldWizDlgProc,hdlg,msg,wParam,lParam);
                break;
        }
    }

    return b;
}

#ifdef _OCM
//
// Bogus global variable necessary because there's no way to get
// a value through to the PropSheetCallback.
//
PVOID _CBx;
#endif

int
CALLBACK
WizardCallback(
    IN HWND   hdlg,
    IN UINT   code,
    IN LPARAM lParam
    )
{
    DLGTEMPLATE *DlgTemplate;
    HMENU menu;

    UNREFERENCED_PARAMETER(hdlg);

    //
    // Get rid of context sensitive help control on title bar
    //
    if(code == PSCB_PRECREATE) {
        DlgTemplate = (DLGTEMPLATE *)lParam;
        DlgTemplate->style &= ~DS_CONTEXTHELP;
    } else {
        if(code == PSCB_INITIALIZED) {
            //
            // Get rid of close item on system menu.
            // Also need to process WM_SYSCOMMAND to eliminate use
            // of Alt+F4.
            //
            if(menu = GetSystemMenu(hdlg,FALSE)) {
                EnableMenuItem(menu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
            }

            OldWizDlgProc =  (WNDPROC)SetWindowLongPtr(hdlg,DWLP_DLGPROC,(LONG_PTR)NewWizDlgProc);

#ifdef _OCM
            // inform ocm components of the wizard dialog handle

            if (_CBx)
                OcRememberWizardDialogHandle(_CBx,hdlg);
#endif
        }
    }

    return(0);
}


VOID
Wizard(
#ifdef _OCM
    IN PVOID OcManagerContext
#else
    VOID
#endif
    )
{
    PROPSHEETHEADER psh;
    PUINT PageList;
    UINT PagesInSet;
    UINT i;
    UINT PageOrdinal;
    UINT PageCount;
    UINT NetPageCount;
    UINT LicPageCount;
#ifdef _OCM
    HPROPSHEETPAGE WizardPageHandles[MAXPROPPAGES];
#else
    HPROPSHEETPAGE WizardPageHandles[WizPageMaximum+MAX_NETWIZ_PAGES+MAX_LICWIZ_PAGES];
#endif
    BOOL b;
    INT_PTR Status;
    HDC hdc;
#ifdef _OCM
    PSETUP_REQUEST_PAGES PagesFromOcManager[WizPagesTypeMax];
    OC_PAGE_CONTROLS OcPageControls,OcDetailsControls;
    SETUP_PAGE_CONTROLS OcSetupPageControls;
#endif

    //
    // Determine which set of pages to use and how many there are in the set.
    //
    if(UiTest) {
        PageList = UiTestWizardPages;
        PagesInSet = sizeof(UiTestWizardPages)/sizeof(UiTestWizardPages[0]);
    } else {
        if(Upgrade) {
            PageList = UpgradeWizardPages;
            PagesInSet = sizeof(UpgradeWizardPages)/sizeof(UpgradeWizardPages[0]);
        } else {
            if( MiniSetup ) {
                PageList = MiniSetupWizardPages;
                PagesInSet = sizeof(MiniSetupWizardPages)/sizeof(MiniSetupWizardPages[0]);
            }
            else {
                if( AsrIsEnabled() ) {
                    PageList = AsrWizardPages;
                    PagesInSet = sizeof(AsrWizardPages)/sizeof(AsrWizardPages[0]);
                } else {
                    PageList = InitialWizardPages;
                    PagesInSet = sizeof(InitialWizardPages)/sizeof(InitialWizardPages[0]);
                }
            }
        }
    }

#ifdef _OCM
    // for callbacks

    _CBx = OcManagerContext;

    // Get pages from OC Manager components.

    if(OcManagerContext) {

        Status = OcGetWizardPages(OcManagerContext,PagesFromOcManager);
        if(Status != NO_ERROR) {
            FatalError(MSG_LOG_WIZPAGES,0,0);
        }
    } else {
        ZeroMemory(PagesFromOcManager,sizeof(PagesFromOcManager));
    }
#endif

    //
    // Create each page. Some of the pages are placeholders for external pages,
    // which are handled specially.
    //

    b = TRUE;
    PageCount = 0;
    for(i=0; b && (i<PagesInSet); i++) {

        switch(PageOrdinal = PageList[i]) {

        case WizPagePlaceholderNet:

            //
            // Fetch network pages.
            //
            MYASSERT(MAX_NETWIZ_PAGES <= MAXPROPPAGES);
            NetPageCount = MAX_NETWIZ_PAGES;
            if(GetNetworkWizardPages(&WizardPageHandles[PageCount],&NetPageCount)) {
                PageCount += NetPageCount;
                NetWizard = TRUE;
            }

            break;

        case WizPagePlaceholderLic:

            if( (ProductType != PRODUCT_WORKSTATION) ) {
                //
                // Fetch license pages.
                //
                MYASSERT(MAX_LICWIZ_PAGES <= MAXPROPPAGES);
                LicPageCount = MAX_LICWIZ_PAGES;
                if(GetLicenseWizardPages(&WizardPageHandles[PageCount],&LicPageCount)) {
                    PageCount += LicPageCount;
                }
            }

            break;

        case WizPagePreparing:
            //
            // We let the PnP engine run out of process
            // and asynchronously for a MiniSetup case.
            //

            //
            // If we're doing a mini Setup, then we ONLY do
            // the preparing page if the user has asked us to
            // do pnp enumeration.
            //
            if( MiniSetup && (PnPReEnumeration == FALSE)) {
                break;
            }

            goto dodefault;
            break;

        case WizPageCopyFiles:
#ifdef _X86_

            if (Win95Upgrade) {
                SetupWizardPages[PageOrdinal].Page.pszTemplate = MAKEINTRESOURCE(IDD_COPYFILES4);
            }
#endif
#ifdef _OCM
            MYASSERT(OcManagerContext);
            SetupWizardPages[PageOrdinal].Page.lParam = (LPARAM) OcManagerContext;
#endif

            goto dodefault;
            break;


#ifdef _OCM
        case WizPageWelcome:
            //
            // If there's a welcome page from an OC Manager component
            // then use it. Otherwise use the standard setup one.
            //
            if(!pOcManagerPages(PagesFromOcManager[WizPagesWelcome],WizardPageHandles,&PageCount)) {
                goto dodefault;
            }

            break;


        case WizPageLast:
            //
            // If there's a final page from an OC Manager component
            // then use it. Otherwise use the standard setup one.
            //
            if(!pOcManagerPages(PagesFromOcManager[WizPagesFinal],WizardPageHandles,&PageCount)) {
                goto dodefault;
            }

            break;

        case WizPageOcManagerEarly:

            pOcManagerPages(PagesFromOcManager[WizPagesEarly],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerPrenet:

            pOcManagerPages(PagesFromOcManager[WizPagesPrenet],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerPostnet:

            pOcManagerPages(PagesFromOcManager[WizPagesPostnet],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerLate:

            pOcManagerPages(PagesFromOcManager[WizPagesLate],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManager:

            if(OcManagerContext && OcSubComponentsPresent(OcManagerContext)) {
                OcPageControls.TemplateModule = MyModuleHandle;
                OcPageControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_WIZARD_PAGE);
                OcPageControls.ListBox = IDC_LISTBOX;
                OcPageControls.TipText = IDT_TIP;
                OcPageControls.DetailsButton = IDB_DETAILS;
                OcPageControls.ResetButton = 0; // unused
                OcPageControls.InstalledCountText = 0; // unused
                OcPageControls.SpaceNeededText = IDT_SPACE_NEEDED_NUM;
                OcPageControls.SpaceAvailableText = IDT_SPACE_AVAIL_NUM;
                OcPageControls.InstructionsText = IDT_INSTRUCTIONS;
                OcPageControls.HeaderText = IDS_OCPAGE_HEADER;
                OcPageControls.SubheaderText = IDS_OCPAGE_SUBHEAD;
                OcPageControls.ComponentHeaderText = IDT_COMP_TITLE;

                OcDetailsControls = OcPageControls;
                OcDetailsControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_DETAILS);

                WizardPageHandles[PageCount] = OcCreateOcPage(
                                                    OcManagerContext,
                                                    &OcPageControls,
                                                    &OcDetailsControls
                                                    );

                if(WizardPageHandles[PageCount]) {
                    PageCount++;
                } else {
                    b = FALSE;
                }
            }

            break;

        case WizPageOcManagerSetup:

            if(OcManagerContext) {
                OcSetupPageControls.TemplateModule = MyModuleHandle;
                OcSetupPageControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_PROGRESS_PAGE);
                OcSetupPageControls.ProgressBar = IDC_PROGRESS;
                OcSetupPageControls.ProgressLabel = IDT_THERM_LABEL;
                OcSetupPageControls.ProgressText = IDT_TIP;
                OcSetupPageControls.AnimationControl = IDA_EXTERNAL_PROGRAM;
                OcSetupPageControls.AnimationResource = IDA_FILECOPY;
                OcSetupPageControls.ForceExternalProgressIndicator = FALSE;
                OcSetupPageControls.AllowCancel = FALSE;
                OcSetupPageControls.HeaderText = IDS_PROGPAGE_HEADER;
                OcSetupPageControls.SubheaderText = IDS_PROGPAGE_SUBHEAD;

                if(WizardPageHandles[PageCount] = OcCreateSetupPage(OcManagerContext,&OcSetupPageControls)) {
                    PageCount++;
                } else {
                    b = FALSE;
                }
            }

            break;
#endif

            case WizPageComputerName:
            if( GetProductFlavor() == 4)
            {
                // If Personal use a different template
                SetupWizardPages[PageOrdinal].Page.pszTemplate = MAKEINTRESOURCE(IDD_COMPUTERNAME2);
            }

            goto dodefault;
            break;

        default:
        dodefault:
            {
                UINT uiStrID;
            SetupWizardPages[PageOrdinal].Page.hInstance = MyModuleHandle;

            SetupWizardPages[PageOrdinal].Page.pszTitle = (PWSTR)UIntToPtr( SetupTitleStringId );
            SetupWizardPages[PageOrdinal].Page.dwFlags |= PSP_USETITLE;

            //
            // Convert resource ids to actual strings for header title and subtitle,
            // if required for this page.
            //
            if(SetupWizardPages[PageOrdinal].Page.dwFlags & PSP_USEHEADERTITLE) {

                uiStrID = (UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderTitle);
                if ((PageOrdinal == WizPageComputerName) &&
                    (GetProductFlavor() == 4))
                {
                    uiStrID = IDS_COMPUTERNAME2;
                }

                SetupWizardPages[PageOrdinal].Page.pszHeaderTitle = MyLoadString(uiStrID
                                                                        //(UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderTitle)
                                                                        );

                if(!SetupWizardPages[PageOrdinal].Page.pszHeaderTitle) {
                    SetupWizardPages[PageOrdinal].Page.dwFlags &= ~PSP_USEHEADERTITLE;
                }
            }

            if(SetupWizardPages[PageOrdinal].Page.dwFlags & PSP_USEHEADERSUBTITLE) {
                uiStrID = (UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle);
                if ((PageOrdinal == WizPageComputerName) &&
                    (GetProductFlavor() == 4))
                {
                    uiStrID = IDS_COMPUTERNAME2_SUB;
                }
                SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle = MyLoadString(uiStrID
                                                                        //(UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle)
                                                                        );

                if(!SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle) {
                    SetupWizardPages[PageOrdinal].Page.dwFlags &= ~PSP_USEHEADERSUBTITLE;
                }
            }

            WizardPageHandles[PageCount] = CreatePropertySheetPage(
                                                &SetupWizardPages[PageOrdinal].Page
                                                );

            if(WizardPageHandles[PageCount]) {
                PageCount++;
            } else {
                b = FALSE;
            }
            }
            break;
        }
    }

    if(b) {

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 |
            PSH_HEADER;
        // in order to have the watermark sized correctly for all languages,
        // we must draw the bitmap ourselves rather than letting wiz97
        // take care of it for us.
            //PSH_WATERMARK | PSH_HEADER;
        psh.hwndParent = MainWindowHandle;
        psh.hInstance = MyModuleHandle;
        psh.pszCaption = NULL;
        psh.nPages = PageCount;
        psh.nStartPage = 0;
        psh.phpage = WizardPageHandles;
        psh.pfnCallback = WizardCallback;
        //psh.pszbmWatermark = MAKEINTRESOURCE(IDB_BITMAP1);
        psh.pszbmHeader = MAKEINTRESOURCE(IDB_HEADER);

        Status = PropertySheet(&psh);
        if (Status == -1) {
            FatalError(MSG_LOG_WIZPAGES,0,0);
        }

    } else {

        FatalError(MSG_LOG_WIZPAGES,0,0);
    }

    for (i = 0; i < WizPagesTypeMax ; i++) {
        MyFree(PagesFromOcManager[i]);
    }

    return;
}


#ifdef _OCM
BOOL
pOcManagerPages(
    IN     PSETUP_REQUEST_PAGES  Page,
    OUT    HPROPSHEETPAGE       *WizardPageHandles,
    IN OUT UINT                 *PageCount
    )
{
    BOOL b;

    if(Page && Page->MaxPages) {
        MYASSERT(WizardPageHandles && PageCount);

        CopyMemory(
            &WizardPageHandles[*PageCount],
            Page->Pages,
            Page->MaxPages * sizeof(HPROPSHEETPAGE)
            );

        *PageCount += Page->MaxPages;

        b = TRUE;

    } else {

        b = FALSE;
    }

    return(b);
}
#endif


VOID
WizardUiTest(
    VOID
    )
{
    UiTest = TRUE;

    SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    MYASSERT(ARRAYSIZE(SourcePath) >= ARRAYSIZE(L"D:\\$WIN_NT$.LS"));
    lstrcpy(SourcePath,L"D:\\$WIN_NT$.LS");
#ifdef _OCM
    {
        PVOID OcManagerContext = FireUpOcManager();
        MYASSERT(OcManagerContext);
        Wizard(OcManagerContext);
        KillOcManager(OcManagerContext);
    }
#else
    Wizard();
#endif
    SetupCloseInfFile(SyssetupInf);
}

DWORD GetPhase_InitializeEstimate ()
{
    return TIME_INITIALIZE;
}

DWORD GetPhase_InstallSecurityEstimate ()
{
    return TIME_INSTALLSECURITY;
}

DWORD GetPhase_PrecompileInfsEstimate ()
{
    return TIME_PRECOMPILEINFS;
}


DWORD GetPhase_InstallDevicesEstimate ()
{
    return TIME_INSTALLDEVICES;
}
DWORD GetPhase_InstallEnumDevices1Estimate ()
{
    return TIME_INSTALLENUMDEVICES1;
}
DWORD GetPhase_InstallLegacyDevicesEstimate ()
{
    return TIME_INSTALLLEGACYDEVICES;
}
DWORD GetPhase_InstallEnumDevices2Estimate ()
{
    return TIME_INSTALLENUMDEVICES2;
}

DWORD GetPhase_NetInstallEstimate ()
{
    return TIME_NETINSTALL;
}

DWORD GetPhase_OCInstallEstimate ()
{
    return TIME_OCINSTALL;
}

DWORD GetPhase_InstallComponentInfsEstimate ()
{
    return TIME_INSTALLCOMPONENTINFS;
}

DWORD GetPhase_Inf_RegistrationEstimate ()
{
    return TIME_INF_REGISTRATION;
}

DWORD GetPhase_RunOnce_RegistrationEstimate ()
{
    return TIME_RUNONCE_REGISTRATION;
}

DWORD GetPhase_SecurityTempatesEstimate ()
{
    return TIME_SECURITYTEMPLATE;
}

LPTSTR WinRegisteries[] = { TEXT("system.dat"),
                            TEXT("User.dat"),
                            TEXT("classes.dat"),
                            TEXT("")};

DWORD GetPhase_Win9xMigrationEstimate ()
{
    // Get the size of the registery,
    // system.dat, user.dat and classes.dat(only exiss on Millennium)
    // If the size if above 3MB, do the following
    // Substract 3MB, devide by 9000 (that should give use the through put), and add 100 seconds
    DWORD dwTime = TIME_WIN9XMIGRATION;
    DWORD dwSize = 0;
    TCHAR szRegPath[MAX_PATH];
    TCHAR szRegName[MAX_PATH];
    LPTSTR pRegName = NULL;
    UINT    index = 0;
    HANDLE          hFind;
    WIN32_FIND_DATA FindData;

    SetupDebugPrint(L"SETUP: Calculating registery size");

    if (GetWindowsDirectory(szRegPath, MAX_PATH - ARRAYSIZE(L"Setup\\DefHives")))
    {
        pSetupConcatenatePaths (szRegPath, L"Setup\\DefHives", MAX_PATH, NULL);

        while (*WinRegisteries[index])
        {
            lstrcpy(szRegName, szRegPath);
            if(pSetupConcatenatePaths ( szRegName, WinRegisteries[index], MAX_PATH, NULL)){
                hFind = FindFirstFile(szRegName, &FindData);
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    SetupDebugPrint2(L"SETUP: %s size is: %2ld",
                            szRegName,
                            FindData.nFileSizeLow
                            );
                    // Don't worry about the nFileSizeHigh,
                    // if that is used the registery is over 4GB
                    dwSize += FindData.nFileSizeLow;
                    FindClose(hFind);
                }
            }
            index++;
        }
        // Anything below 3.000.000 byte is already in the base time
        if (dwSize > 3000000)
        {
            dwSize -= 3000000;
            // Estimated that for about 9000 bytes we need 1 second.
            dwTime += (dwSize/9000);
        }
        SetupDebugPrint1(L"SETUP: Calculated time for Win9x migration = %1ld seconds", dwTime);
    }

    return dwTime;
}

DWORD GetPhase_SFCEstimate ()
{
    return TIME_SFC;
}

DWORD GetPhase_SaveRepairEstimate ()
{
    return TIME_SAVEREPAIR;
}

DWORD GetPhase_RemoveTempFilesEstimate ()
{
    return TIME_REMOVETEMOFILES;
}

void SetTimeEstimates()
{

    SetupPhase[Phase_Initialize].Time = GetPhase_InitializeEstimate();
    SetupPhase[Phase_InstallSecurity].Time = GetPhase_InstallSecurityEstimate();
    SetupPhase[Phase_PrecompileInfs].Time = GetPhase_PrecompileInfsEstimate();
    SetupPhase[Phase_InstallEnumDevices1].Time = GetPhase_InstallEnumDevices1Estimate();
    SetupPhase[Phase_InstallLegacyDevices].Time = GetPhase_InstallLegacyDevicesEstimate();
    SetupPhase[Phase_InstallEnumDevices2].Time = GetPhase_InstallEnumDevices2Estimate();
    SetupPhase[Phase_OCInstall].Time = GetPhase_OCInstallEstimate();
    SetupPhase[Phase_InstallComponentInfs].Time = GetPhase_InstallComponentInfsEstimate();
    SetupPhase[Phase_Inf_Registration].Time = GetPhase_Inf_RegistrationEstimate();
    SetupPhase[Phase_RunOnce_Registration].Time = GetPhase_RunOnce_RegistrationEstimate();
    SetupPhase[Phase_SecurityTempates].Time = GetPhase_SecurityTempatesEstimate();
    SetupPhase[Phase_Win9xMigration].Time = GetPhase_Win9xMigrationEstimate();
    SetupPhase[Phase_SFC].Time = GetPhase_SFCEstimate();
    SetupPhase[Phase_SaveRepair].Time = GetPhase_SaveRepairEstimate();
    SetupPhase[Phase_RemoveTempFiles].Time = GetPhase_RemoveTempFilesEstimate();

}

// Returns the time remaining starting with the current "Phase"
DWORD CalcTimeRemaining(UINT Phase)
{
    UINT i;
    DWORD Time = 0;
    CurrentPhase = Phase;

    for (i = Phase; i < Phase_Reboot; i++)
    {
        // Is this a phase we always run or only when upgrading Win9x?
        if (!SetupPhase[i].Win9xUpgradeOnly)
        {
            Time += SetupPhase[i].Time;
        }
        else if (Win95Upgrade)
        {
            Time += SetupPhase[i].Time;
        }
    }
    return Time;
}

void SetRemainingTime(DWORD TimeInSeconds)
{
    DWORD Minutes;
    TCHAR MinuteString[MAX_PATH];
    TCHAR TimeLeft[MAX_PATH];
    int i;

    Minutes = ((TimeInSeconds)/60) +1;
    if (Minutes > 1)
    {
        if(!LoadString(MyModuleHandle, IDS_TIMEESTIMATE_MINUTES, MinuteString, ARRAYSIZE(MinuteString)))
        {
            lstrcpy(MinuteString, TEXT("Installation will complete in %d minutes or less."));
        }
        
        TimeLeft[0] = 0;
        i = _sntprintf(TimeLeft, ARRAYSIZE(TimeLeft), MinuteString, Minutes);
        TimeLeft[ARRAYSIZE(TimeLeft) - 1] = 0;
        if( (i < 0) || (i == ARRAYSIZE(TimeLeft))) {
            SetupDebugPrint(L"SETUP: SetRemainingTime: TimeLeft message truncated due to small buffer size");
        }
    }
    else
    {
        if(!LoadString(MyModuleHandle,IDS_TIMEESTIMATE_LESSTHENONEMINUTE,TimeLeft, MAX_PATH))
        {
            lstrcpy(TimeLeft,TEXT("Installation will complete in less then 1 minute."));
        }
    }
    BB_SetTimeEstimateText(TimeLeft);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\bootini.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    HFILE hfile;
    ULONG FileSize;
    PUCHAR buf = NULL,p1,p2;
    BOOL b;
    CHAR TimeoutLine[256];
    CHAR szBootIni[] = "?:\\BOOT.INI";

    szBootIni[0] = (CHAR)x86SystemPartitionDrive;

    wsprintfA(TimeoutLine,"timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //
    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {

        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {

            if((_llseek(hfile,0,0) != -1)
            && (buf = MyMalloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            MyFree(buf);
        }
        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        MyFree(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.
    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);

    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        MyFree(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile,buf        ,p1-buf             ) != (UINT)(-1))
      &&  (_lwrite(hfile,TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile,p2         ,buf+FileSize-p2    ) != (UINT)(-1)));

    _lclose(hfile);
    MyFree(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    if (!SetFileAttributesA(szBootIni,
                            FILE_ATTRIBUTE_READONLY | 
                            FILE_ATTRIBUTE_SYSTEM | 
                            FILE_ATTRIBUTE_ARCHIVE | 
                            FILE_ATTRIBUTE_HIDDEN)){
        //
        // If we failed to set attributes on boot.ini log the error
        //
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FAILURE_SETTING_FILE_ATTR,
            pSetupAnsiToUnicode(szBootIni),
            NULL, NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\amd64\syspart.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PWSTR BootFiles[] = { L"BOOT.INI",
                          L"NTLDR",
                          L"NTDETECT.COM",
                          NULL
                        };

    WCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether nt boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,L"%wc:\\%s",Drive,BootFiles[i]);

        FindHandle = FindFirstFile(FileName,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            return(FALSE);
        } else {
            FindClose(FindHandle);
        }
    }

    return(TRUE);
}


WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None.

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;
    DWORD hardDiskNumber;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if(NtDevicePath = ArcDevicePathToNtPath(L"multi(0)disk(0)rdisk(0)")) {

        //
        // The arc path for a disk device is usually linked
        // to partition0. Get rid of the partition part of the name.
        //
        CharLower(NtDevicePath);
        if(p = wcsstr(NtDevicePath,L"\\partition")) {
            *p = 0;
        }

        NtDevicePathLen = lstrlen(NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if(!wcsncmp(NtDevicePath,L"\\device\\harddisk",16)) {

            PhysicalDriveNumber = wcstoul(NtDevicePath+16,NULL,10);

            wsprintf(Buffer,L"\\\\.\\PhysicalDrive%u",PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFile(
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if(hDisk != INVALID_HANDLE_VALUE) {

                //
                // Get partition information.
                //
                DriveLayout = MyMalloc(1024);
                DriveLayoutSize = 1024;

                retry:

                b = DeviceIoControl(
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    DriveLayoutSize += 1024;
                    DriveLayout = MyRealloc(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle(hDisk);

                if(b) {

                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

                        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

                            DriveName[0] = Drive;

                            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

                                if (_wcsnicmp(Buffer, L"\\device\\harddisk", 16)) {
                                    hardDiskNumber = QueryHardDiskNumber((UCHAR) Drive);
                                    if (hardDiskNumber != (DWORD) -1) {
                                        swprintf(Buffer, TEXT("\\device\\harddisk%d"),
                                                 hardDiskNumber);
                                    }
                                }

                                if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {

                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                MyFree(DriveLayout);
            }
        }

        MyFree(NtDevicePath);
    }

    return(GotIt ? Drive : L'C');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\platform.c ===
#include "setupp.h"
#pragma hdrstop


WCHAR x86SystemPartitionDrive;

WCHAR FloppylessBootPath[MAX_PATH];


UINT
PlatformSpecificInit(
    VOID
    )
{
    //
    // Determine x86 system partition (usually but not always C:).
    //
    x86SystemPartitionDrive = x86DetermineSystemPartition();
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\pcihal.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pcihal.c

Abstract:

    Routines for the Pci Hal property page.

Author:

    Santosh Jodh 10-July-1998

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>

#include <strsafe.h>

#define MSG_SIZE    2048

#define Allocate(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define Release(p)  HeapFree(GetProcessHeap(), 0, (LPVOID)p)

typedef struct _PciHalPropData PCIHALPROPDATA, *PPCIHALPROPDATA;

struct _PciHalPropData {
    HKEY                LocalMachine;
    BOOLEAN             CloseKey;
    DWORD               Options;
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;    
};  

const DWORD gPciPropHelpIds[] = 
{
    IDC_PCIHAL_ICON,        (DWORD)-1,              // Icon
    IDC_PCIHAL_DEVDESC,     (DWORD)-1,              // Name of PC
    IDC_PCIHAL_ENABLE,      IDH_IRQ_ENABLE,         // Enable IRQ Routing
    IDC_PCIHAL_MSSPEC,      IDH_IRQ_MSSPEC,         // Use $PIR table
    IDC_PCIHAL_REALMODE,    IDH_IRQ_REALMODE,       // Use table from Real-mode BIOS call
    IDC_PCIHAL_SETDEFAULTS, IDH_IRQ_SETDEFAULTS,    // Set defaults for options
    IDC_PCIHAL_RESULTS,     IDH_IRQ_RESULTS,        // Status information    
    0,0
};

//
// Table used to translate status codes into string ids.
//
UINT gStatus[PIR_STATUS_MAX + 1] =              {   IDS_PCIHAL_ERROR, 
                                                    IDS_PCIHAL_ENABLED, 
                                                    IDS_PCIHAL_DISABLED,
                                                    IDS_PCIHAL_NOSTATUS
                                                };
UINT gTableStatus[PIR_STATUS_TABLE_MAX] =       {   IDS_PCIHAL_TABLE_REGISTRY, 
                                                    IDS_PCIHAL_TABLE_MSSPEC,
                                                    IDS_PCIHAL_TABLE_REALMODE,
                                                    IDS_PCIHAL_TABLE_NONE,
                                                    IDS_PCIHAL_TABLE_ERROR,                                                    
                                                    IDS_PCIHAL_TABLE_BAD,
                                                    IDS_PCIHAL_TABLE_SUCCESS
                                                };
UINT gMiniportStatus[PIR_STATUS_MINIPORT_MAX] = {   IDS_PCIHAL_MINIPORT_NORMAL, 
                                                    IDS_PCIHAL_MINIPORT_COMPATIBLE, 
                                                    IDS_PCIHAL_MINIPORT_OVERRIDE, 
                                                    IDS_PCIHAL_MINIPORT_NONE,
                                                    IDS_PCIHAL_MINIPORT_ERROR,                                                    
                                                    IDS_PCIHAL_MINIPORT_NOKEY,
                                                    IDS_PCIHAL_MINIPORT_SUCCESS,
                                                    IDS_PCIHAL_MINIPORT_INVALID
                                                };

PCIHALPROPDATA  gPciHalPropData = {0};

VOID
PciHalSetControls (
    IN HWND Dialog,
    IN DWORD Options,
    IN DWORD Attributes
    )

/*++

    Routine Description:

        This routine sets the controls on the Irq Routing page to the
        specified options.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        Options -  Pci Irq Routing options to be displayed.
        
    Return Value:

        None.
        
--*/

{
    BOOL enabled = FALSE;

    //
    // Enable the buttons depending on the options.
    //
    if (Options & PIR_OPTION_ENABLED) {

        enabled = TRUE;
        CheckDlgButton(Dialog, IDC_PCIHAL_ENABLE, 1);
    }

    CheckDlgButton(Dialog, IDC_PCIHAL_MSSPEC, Options & PIR_OPTION_MSSPEC);
    CheckDlgButton(Dialog, IDC_PCIHAL_REALMODE, Options & PIR_OPTION_REALMODE);
    
    //
    // Gray the windows not meaningful.
    //    
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_ENABLE), 
                            !(Attributes & PIR_OPTION_ENABLED)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_SETDEFAULTS), 
                            !(Attributes & PIR_OPTION_ENABLED)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_MSSPEC), 
                            enabled && !(Attributes & PIR_OPTION_MSSPEC)
                            );
    EnableWindow(GetDlgItem(Dialog, 
                            IDC_PCIHAL_REALMODE), 
                            enabled && !(Attributes & PIR_OPTION_REALMODE)
                 );

}

LPTSTR
PciHalGetDescription (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

    Routine Description:

        This routine allocates memory and returns the device description
        for the specified device.

    Input Parameters:

        DeviceInfoSet - For the device.

        DeviceInfoData - For the device.

    Return Value:

        Pointer to the description iff successful. Else NULL.
        
--*/

{
    LPTSTR desc;
    DWORD   size;
    
    desc = NULL;
    
    //
    // Get the size of the description for this device.
    //
    size = 0;
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DEVICEDESC,
                                     NULL,
                                     NULL,
                                     0,
                                     &size
                                     );
    if (size != 0) {

        //
        // Account for the terminating NULL character.
        //
        size++;
        
        //
        // Allocate memory for the device description.
        //
        desc = Allocate(size * sizeof(TCHAR));

        if (desc != NULL) {

            //
            // Get the device description.
            //
            if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_DEVICEDESC,
                                                 NULL,
                                                 (PBYTE)desc,
                                                 size * sizeof(TCHAR),
                                                 &size) == FALSE) {

                Release(desc);
                desc = NULL;
            }
        }
    }

    return desc;
}

LPTSTR
PciHalGetStatus (
    IN DWORD Status,
    IN DWORD TableStatus,
    IN DWORD MiniportStatus
    )

/*++

    Routine Description:

        This routine converts the different status codes into
        a status string and returns the pointer to the string.
        The caller should free the memory when done using this
        string.

    Input Parameters:

        Status - Pci Irq Routing status.

        TableStatus - Pci Irq Routing Table status. Lower WORD
        indicates the source of the table. The upper WORD indicates
        the table processing status.

        MiniportStatus - Pci Irq Routing Miniport status. Lower
        WORD indicates the source of the miniport. The upper WORD
        indicates the miniport processing status.

    Return Value:

        Pointer to the status string iff successful. Else NULL.
        
--*/

{
    LPTSTR  status;
    TCHAR   temp[128];
    DWORD   statusLength;

    statusLength = MSG_SIZE;
    status = Allocate(statusLength * sizeof(TCHAR));
    if (status) {

        //
        // Get the status about Pci Irq Routing.
        //
        status[0] = TEXT('\0');
        LoadString(MyModuleHandle, gStatus[Status], status, MSG_SIZE);        

        //
        // Get the status about the source of Pci Irq Routing Table.
        //
        if ((TableStatus & 0xFFFF) < PIR_STATUS_TABLE_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gTableStatus[TableStatus & 0xFFFF], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the Pci Irq Routing table.
        //
        TableStatus >>= 16;
        if (TableStatus < PIR_STATUS_TABLE_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, gTableStatus[TableStatus], temp, ARRAYSIZE(temp));
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the source of the miniport.
        //
        if ((MiniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gMiniportStatus[MiniportStatus & 0xFFFF], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }

        //
        // Get the status about the miniport status.
        //
        MiniportStatus >>= 16;
        if (MiniportStatus < PIR_STATUS_MINIPORT_MAX) {

            StringCchCat(status, statusLength, L"\r\n\r\n");
            temp[0] = TEXT('\0');
            LoadString(MyModuleHandle, 
                       gMiniportStatus[MiniportStatus], 
                       temp, 
                       ARRAYSIZE(temp)
                       );
            StringCchCat(status, statusLength, temp);
        }
    }

    return status;
}

BOOL
PciHalOnInitDialog (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine initializes the property sheet page on creation.
        
    Input Paramters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_INITDIALOG message.

        lParam - Pointer to the property sheet page.
        
    Return Value:

        TRUE.
        
--*/

{   
    PPCIHALPROPDATA             pciHalPropData;
    HKEY                        hKey;
    DWORD                       size;    
    DWORD                       status;
    DWORD                       tableStatus;
    DWORD                       miniportStatus;
    DWORD                       attributes;
    HICON                       hIconOld;
    HICON                       hIconNew;
    INT                         iconIndex;
    LPTSTR                      desc;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    
    pciHalPropData = (PPCIHALPROPDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    //
    // Read the Pci Irq Routing options and status from the registry.
    //
    pciHalPropData->Options = 0;
    status = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);
    details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    attributes = PIR_OPTION_ENABLED | PIR_OPTION_MSSPEC | PIR_OPTION_REALMODE;
    if (SetupDiGetDeviceInfoListDetail(pciHalPropData->DeviceInfoSet, 
                                       &details)) {

        if (RegConnectRegistry(
                (details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, 
                HKEY_LOCAL_MACHINE, 
                &pciHalPropData->LocalMachine) == ERROR_SUCCESS) {

            pciHalPropData->CloseKey = TRUE;
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                             REGSTR_PATH_PCIIR, 
                             0, 
                             KEY_READ, 
                             &hKey) == ERROR_SUCCESS) { 

                size = sizeof(pciHalPropData->Options);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_OPTIONS, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&pciHalPropData->Options, 
                                &size
                                );

                size = sizeof(status);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&status, 
                                &size);

                size = sizeof(tableStatus);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_TABLE_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&tableStatus, 
                                &size
                                );

                size = sizeof(miniportStatus);
                RegQueryValueEx(hKey, 
                                REGSTR_VAL_MINIPORT_STAT, 
                                NULL, 
                                NULL, 
                                (LPBYTE)&miniportStatus, 
                                &size
                                );

                RegCloseKey(hKey);
            }

            //
            // Gray out the controls if the user does not have READ+WRITE access to the REGSTR_PATH_PCIIR. 
            //
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                             REGSTR_PATH_PCIIR, 
                             0, 
                             KEY_READ | KEY_WRITE, 
                             &hKey) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                attributes = 0;
                if (RegOpenKeyEx(pciHalPropData->LocalMachine, 
                                 REGSTR_PATH_BIOSINFO L"\\PciIrqRouting", 
                                 0, 
                                 KEY_READ, 
                                 &hKey) == ERROR_SUCCESS) { 

                    size = sizeof(attributes);
                    RegQueryValueEx(hKey, 
                                    L"Attributes", 
                                    NULL, 
                                    NULL, 
                                    (LPBYTE)&attributes, 
                                    &size
                                    );
                    RegCloseKey(hKey);
                }
            }
        }
    }

    //
    // Set the class icon.
    //
    if (SetupDiLoadClassIcon(   &pciHalPropData->DeviceInfoData->ClassGuid, 
                                &hIconNew, 
                                &iconIndex) == TRUE) {

        hIconOld = (HICON)SendDlgItemMessage(Dialog, 
                                             IDC_PCIHAL_ICON, 
                                             STM_SETICON,
                                             (WPARAM)hIconNew,
                                             0
                                             );
        if (hIconOld) {

            DestroyIcon(hIconOld);
        }
    }

    //
    // Set the device description.
    //
    desc = PciHalGetDescription(pciHalPropData->DeviceInfoSet, 
                                pciHalPropData->DeviceInfoData
                                );
    if (desc) {

        SetDlgItemText(Dialog, IDC_PCIHAL_DEVDESC, desc);
        Release(desc);
    }

    //
    // Set the initial state of the controls.
    //
    PciHalSetControls(Dialog, pciHalPropData->Options, attributes);

    //
    // Display status.
    //
    desc = PciHalGetStatus(status, tableStatus, miniportStatus);
    if (desc) {

        SetDlgItemText(Dialog, IDC_PCIHAL_RESULTS, desc);
        Release(desc);
    }

    //
    // Let the system set the focus.
    //   
    return TRUE;
}

BOOL
PciHalOnCommand (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the message when the user modifies something
        on the property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_COMMAND message.

        lParam - lParam of the WM_COMMAND message.
        
    Return Value:

        TRUE if this function handles the message. Else FALSE.
    
--*/

{
    BOOL status;
    BOOL enabled;

    status = FALSE;
    
    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    
        case IDC_PCIHAL_SETDEFAULTS:

            //
            // Set the controls to the default value.
            //
            status = TRUE;
            PciHalSetControls(Dialog, PIR_OPTION_DEFAULT, 0);
            break;

        case IDC_PCIHAL_ENABLE:

            //
            // Gray out the sub-options if Irq Routing is being disabled.
            //            
            status = TRUE;
            enabled = IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled);            
            break;

        default:
        
            break;
    }

    return status;
}

BOOL
PciHalOnNotify(
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the WM_NOTIFY message for the Pci Irq Routing
        property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_NOTIFY message.

        lParam - lParam of the WM_NOTIFY message.
    
    Return Value:

        TRUE if this function handles the message. Else FALSE.
        
--*/

{
    BOOL                    status = FALSE;
    HKEY                    hKey;
    DWORD                   options;
    
    switch (((LPNMHDR)lParam)->code) {
    
        case PSN_RESET:        

            //
            // User hit cancel.
            //
            status = TRUE;

            if (RegOpenKey(gPciHalPropData.LocalMachine, 
                           REGSTR_PATH_PCIIR,
                           &hKey) == ERROR_SUCCESS) {

                RegSetValueEx(hKey, 
                              REGSTR_VAL_OPTIONS, 
                              0, 
                              REG_DWORD, 
                              (CONST BYTE *)&gPciHalPropData.Options, 
                              sizeof(gPciHalPropData.Options)
                              );
                RegCloseKey(hKey);
            }
            
            break;
            
        case PSN_APPLY:

            //
            // User hit Apply or Ok.
            //
            status = TRUE;
            
            //
            // Read the different control status and write it to the registry.
            //
            options = gPciHalPropData.Options;
            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE) == BST_CHECKED)
            {
                options |= PIR_OPTION_ENABLED;
            }
            else
            {
                options &= ~PIR_OPTION_ENABLED;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_MSSPEC))
            {
                options |= PIR_OPTION_MSSPEC;
            }
            else
            {
                options &= ~PIR_OPTION_MSSPEC;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_REALMODE))
            {
                options |= PIR_OPTION_REALMODE;
            }
            else
            {
                options &= ~PIR_OPTION_REALMODE;
            }

            if (RegOpenKey(gPciHalPropData.LocalMachine, 
                           REGSTR_PATH_PCIIR, 
                           &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&options, 
                                sizeof(options));
                RegCloseKey(hKey);
            }

            //
            // Reboot if any of the options changed.
            //
            if (options != gPciHalPropData.Options)
            {
                SP_DEVINSTALL_PARAMS    deviceInstallParams;

                ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
                deviceInstallParams.cbSize = sizeof(deviceInstallParams);
                if (SetupDiGetDeviceInstallParams(gPciHalPropData.DeviceInfoSet, 
                                                  gPciHalPropData.DeviceInfoData, 
                                                  &deviceInstallParams)) {

                    deviceInstallParams.Flags |= DI_NEEDREBOOT;
                    SetupDiSetDeviceInstallParams(gPciHalPropData.DeviceInfoSet, 
                                                  gPciHalPropData.DeviceInfoData, 
                                                  &deviceInstallParams
                                                  );                    
                }
            }
            
            break;

        default:

            break;
    }

    return status;
}

INT_PTR
CALLBACK
PciHalDialogProc(
    IN HWND Dialog,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This is the DlgProc for the Pci Irq Routing property sheet page.
        
    Input Parameters:

        Standard DlgProc parameters.
        
    Return Value:

        TRUE if it handles the message. Else FALSE.
        
--*/

{
    BOOL    status = FALSE;
    PCWSTR  szHelpFile = L"devmgr.hlp";
    HICON hIconOld;
    
    switch (Message) {
    
        case WM_INITDIALOG:

            status = PciHalOnInitDialog(Dialog, wParam, lParam);
            break;

        case WM_COMMAND:

            status = PciHalOnCommand(Dialog, wParam, lParam);
            break;

        case WM_NOTIFY:

            status = PciHalOnNotify(Dialog, wParam, lParam);
            break;

        case WM_HELP:
            
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    szHelpFile, 
                    HELP_WM_HELP, 
                    (ULONG_PTR)gPciPropHelpIds
                    );
            status = TRUE;
            break;
            
        case WM_CONTEXTMENU:

            WinHelp((HWND)wParam, 
                    szHelpFile, 
                    HELP_CONTEXTMENU, 
                    (ULONG_PTR)gPciPropHelpIds
                    );
            status = TRUE;
            break;

        case WM_DESTROY:

            if (gPciHalPropData.CloseKey) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                gPciHalPropData.CloseKey = FALSE;
            }
            hIconOld = (HICON)SendDlgItemMessage(Dialog, 
                                                 IDC_PCIHAL_ICON, 
                                                 STM_GETICON,
                                                 (WPARAM)0,
                                                 0
                                                 );
            if (hIconOld) {

                DestroyIcon(hIconOld);
            }

        
        default:

            break;
    }

    return status;
}

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
    BOOL                        status;
    HPROPSHEETPAGE              pageHandle;
    PROPSHEETPAGE               page;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    SP_ADDPROPERTYPAGE_DATA     addPropertyPageData;

    switch (InstallFunction) {
    case DIF_ADDPROPERTYPAGE_ADVANCED:        
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:

        details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
        if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &details)) {

            if (RegConnectRegistry(
                    (details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, 
                    HKEY_LOCAL_MACHINE, 
                &gPciHalPropData.LocalMachine) == ERROR_SUCCESS) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                status = TRUE;
                break;
            }
        }

    default:

        status = FALSE;
        break;
    }

    if (status) {

        ZeroMemory(&addPropertyPageData, sizeof(SP_ADDPROPERTYPAGE_DATA));
        addPropertyPageData.ClassInstallHeader.cbSize = 
             sizeof(SP_CLASSINSTALL_HEADER);

        if (SetupDiGetClassInstallParams(
                DeviceInfoSet, DeviceInfoData,
                (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                sizeof(SP_ADDPROPERTYPAGE_DATA), NULL )) {

           if (addPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES) {

               //
               // Initialize our globals here.
               //
               gPciHalPropData.DeviceInfoSet    = DeviceInfoSet;
               gPciHalPropData.DeviceInfoData   = DeviceInfoData;

               //
               // Initialize our property page here.
               //
               ZeroMemory(&page, sizeof(PROPSHEETPAGE));
               page.dwSize      = sizeof(PROPSHEETPAGE);
               page.hInstance   = MyModuleHandle;
               page.pszTemplate = MAKEINTRESOURCE(IDD_PCIHAL_PROPPAGE);
               page.pfnDlgProc  = PciHalDialogProc;
               page.lParam      = (LPARAM)&gPciHalPropData;

               pageHandle = CreatePropertySheetPage(&page);
               if (pageHandle != NULL)
               {

                   addPropertyPageData.DynamicPages[addPropertyPageData.NumDynamicPages++] = pageHandle;
                    SetupDiSetClassInstallParams(
                        DeviceInfoSet, DeviceInfoData,
                        (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                        sizeof(SP_ADDPROPERTYPAGE_DATA)
                        );

                    return NO_ERROR;
               }
           }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\fpu.c ===
#include "setupp.h"
#pragma hdrstop

//
// TRUE if we detected a flawed pentium chip.
//
BOOL FlawedPentium;

//
// TRUE if NPX emulation is forced on.
// Flag indicating what user wants to do.
//
BOOL CurrentNpxSetting;
BOOL UserNpxSetting;

//
// Name of value in HKLM\System\CurrentControlSet\Control\Session Manager
// controlling npx emulation.
//
PCWSTR NpxEmulationKey = L"System\\CurrentControlSet\\Control\\Session Manager";
PCWSTR NpxEmulationValue = L"ForceNpxEmulation";


BOOL
TestForDivideError(
    VOID
    );

int
ms_p5_test_fdiv(
    void
    );


VOID
CheckPentium(
    VOID
    )

/*++

Routine Description:

    Check all processor(s) for the Pentium floating-point devide errata.

Arguments:

    None.

Return Value:

    None. Global variables FlawedPentium, CurrentNpxSetting, and
    UserNpxSetting will be filled in.

--*/

{
    LONG rc;
    HKEY hKey;
    DWORD DataType;
    DWORD ForcedOn;
    DWORD DataSize;
    static LONG CheckedPentium = -1;

    //
    // If we didn't already check it CheckedPentium will become 0
    // with this increment.  If we already checked it then CheckedPentium
    // will become something greater than 0.
    //
    if(InterlockedIncrement(&CheckedPentium)) {
        return;
    }

    //
    // Perform division test to see whether pentium is flawed.
    //
    if(FlawedPentium = TestForDivideError()) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FLAWED_PENTIUM,
            0,0);
    }

    //
    // Check registry to see whether npx is currently forced on. Assume not.
    //
    CurrentNpxSetting = 0;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,NpxEmulationKey,0,KEY_QUERY_VALUE,&hKey);
    if(rc == NO_ERROR) {

        DataSize = sizeof(DWORD);
        rc = RegQueryValueEx(
                hKey,
                NpxEmulationValue,
                0,
                &DataType,
                (PBYTE)&ForcedOn,
                &DataSize
                );

        //
        // If the value isn't present then assume emulation
        // is not currently forced on. Otherwise the value tells us
        // whether emulation is forced on.
        //
        CurrentNpxSetting = (rc == NO_ERROR) ? ForcedOn : 0;
        if(rc == ERROR_FILE_NOT_FOUND) {
            rc = NO_ERROR;  // prevent bogus warning from being logged.
        }
        RegCloseKey(hKey);
    }

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UNABLE_TO_CHECK_NPX_SETTING,
            rc,
            0,0);
    }

    //
    // For now set user's choice to the current setting.
    //
    UserNpxSetting = CurrentNpxSetting;
}


BOOL
SetNpxEmulationState(
    VOID
    )

/*++

Routine Description:

    Set state of NPX emulation based on current state of global variables
    CurrentNpxSetting and UserNpxSetting.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    LONG rc;
    HKEY hKey;
    DWORD DataType;
    DWORD ForcedOn;
    DWORD DataSize;

    //
    // Nothing to to if the setting has not changed.
    //
    if(CurrentNpxSetting == UserNpxSetting) {
        return(TRUE);
    }

    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,NpxEmulationKey,0,KEY_SET_VALUE,&hKey);
    if(rc == NO_ERROR) {

        rc = RegSetValueEx(
                hKey,
                NpxEmulationValue,
                0,
                REG_DWORD,
                (PBYTE)&UserNpxSetting,
                sizeof(DWORD)
                );

        if(rc == NO_ERROR) {
            CurrentNpxSetting = UserNpxSetting;
        }

        RegCloseKey(hKey);
    }

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UNABLE_TO_SET_NPX_SETTING,
            rc,
            0,0);
    }

    return(rc == NO_ERROR);
}


BOOL
TestForDivideError(
    VOID
    )

/*++

Routine Description:

    Do a divide with a known divident/divisor pair, followed by
    a multiply to see if we get the right answer back.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the computer exhibits the
    pentium fpu bug.

--*/

{
    DWORD pick;
    DWORD processmask;
    DWORD systemmask;
    DWORD i;
    BOOL rc;

    //
    // Assume no fpu bug.
    //
    rc = FALSE;

    //
    // Fetch the affinity mask, which is also effectively a list
    // of processors
    //
    GetProcessAffinityMask(GetCurrentProcess(),&processmask,&systemmask);

    //
    // Step through the mask, testing each cpu.
    // if any is bad, we treat them all as bad
    //
    for(i = 0; i < 32; i++) {

        pick = 1 << i;

        if(systemmask & pick) {

            SetThreadAffinityMask(GetCurrentThread(), pick);

            //
            // Call the critical test function
            //
            if(ms_p5_test_fdiv()) {
                rc = TRUE;
                break;
            }
        }
    }

    //
    // Reset affinity for this thread before returning.
    //
    SetThreadAffinityMask(GetCurrentThread(), processmask);
    return(rc);
}


/***
* testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*   Copyright (c) 1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Detects early steppings of Pentium with incorrect FDIV tables using
*   'official' Intel test values. Returns 1 if flawed Pentium is detected,
*   0 otherwise.
*
*/
int ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}



BOOL
CALLBACK
PentiumDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Check the pentium.
        //
        CheckPentium();

        //
        // Set up default. If user setting is non-0, then some kind
        // of emulation is turned on (there are 2 possibilities).
        //
        CheckRadioButton(
            hdlg,
            IDC_RADIO_1,
            IDC_RADIO_2,
            UserNpxSetting ? IDC_RADIO_2 : IDC_RADIO_1
            );

        break;

    case WM_SIMULATENEXT:

        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(522);
            SetWizardButtons(hdlg,WizPagePentiumErrata);

            if (FlawedPentium || UiTest) {
                if(Unattended) {
                    //
                    // This call makes the dialog activate, meaning
                    // we end up going through the PSN_WIZNEXT code below.
                    //
                    if (!UnattendSetActiveDlg(hdlg, IDD_PENTIUM))
                    {
                        break;
                    }
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                } else {
                    SetWindowLong(hdlg,DWL_MSGRESULT, 0);
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            } else {
                SetWindowLong(hdlg,DWL_MSGRESULT,-1);
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Fetch emulation state. If user wants emulation and emulation
            // was already turned on preserve the current emulation setting.
            // Otherwise use setting 1.
            //
            if(IsDlgButtonChecked(hdlg,IDC_RADIO_2)) {
                if(!UserNpxSetting) {
                    UserNpxSetting = 1;
                }
            } else {
                UserNpxSetting = 0;
            }
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\ia64\platform.c ===
#include "setupp.h"
#pragma hdrstop


UINT
PlatformSpecificInit(
    VOID
    )
{
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\spx86.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    Header file for x86-specific stuff in system installation module.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#ifdef _X86_

VOID
CheckPentium(
    VOID
    );

BOOL
SetNpxEmulationState(
    VOID
    );

BOOL
CALLBACK
PentiumDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

WCHAR
x86DetermineSystemPartition(
    VOID
    );

extern WCHAR x86SystemPartitionDrive;
extern WCHAR FloppylessBootPath[MAX_PATH];

//
// Pci Hal property page provider (pcihal.c).
//

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    );

BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\syspart.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PWSTR BootFiles[] = { L"BOOT.INI",
                          L"NTLDR",
                          L"NTDETECT.COM",
                          NULL
                        };

    WCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether nt boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,L"%wc:\\%s",Drive,BootFiles[i]);

        FindHandle = FindFirstFile(FileName,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            return(FALSE);
        } else {
            FindClose(FindHandle);
        }
    }

    return(TRUE);
}


WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None.

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;
    DWORD hardDiskNumber;

    WCHAR TempBuffer[MAX_PATH]; //NEC98

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

  if (!IsNEC_98) {

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if(NtDevicePath = ArcDevicePathToNtPath(L"multi(0)disk(0)rdisk(0)")) {

        //
        // The arc path for a disk device is usually linked
        // to partition0. Get rid of the partition part of the name.
        //
        CharLower(NtDevicePath);
        if(p = wcsstr(NtDevicePath,L"\\partition")) {
            *p = 0;
        }

        NtDevicePathLen = lstrlen(NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if(!wcsncmp(NtDevicePath,L"\\device\\harddisk",16)) {

            PhysicalDriveNumber = wcstoul(NtDevicePath+16,NULL,10);

            wsprintf(Buffer,L"\\\\.\\PhysicalDrive%u",PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFile(
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if(hDisk != INVALID_HANDLE_VALUE) {

                //
                // Get partition information.
                //
                DriveLayout = MyMalloc(1024);
                DriveLayoutSize = 1024;

                retry:

                b = DeviceIoControl(
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    DriveLayoutSize += 1024;
                    DriveLayout = MyRealloc(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle(hDisk);

                if(b) {

                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

                        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

                            DriveName[0] = Drive;

                            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

                                if (_wcsnicmp(Buffer, L"\\device\\harddisk", 16)) {
                                    hardDiskNumber = QueryHardDiskNumber((UCHAR) Drive);
                                    if (hardDiskNumber != (DWORD) -1) {
                                        swprintf(Buffer, TEXT("\\device\\harddisk%d"),
                                                 hardDiskNumber);
                                    }
                                }

                                if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {

                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                MyFree(DriveLayout);
            }
        }

        MyFree(NtDevicePath);
    }

  } else { //NEC98

    //
    // Do not only see "multi(0)disk(0)rdisk(0)".
    //
    if(GetWindowsDirectory(TempBuffer,MAX_PATH)) {

        Drive = *TempBuffer;
        GotIt = TRUE;

    }

  } //NEC98

    return(GotIt ? Drive : L'C');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\i386\migwin95.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    migwin95.c

Abstract:

    This file contains the syssetup hooks for win9x->Nt5.0 migration. Most functions
    call out to the w95upgnt.dll where the real work is done.

Author:

    Jaime Sasson 30-Aug-1995

Revision History:

    29-Ian-1998  calinn    Added RemoveFiles_x86
    24-Jul-1997  marcw     Minor bug cleanup.
    03-Oct-1996  jimschm   Changed over to use migration DLLs
    22-Jan-1997  jimschm   Added Win95MigrationFileRemoval
    28-Feb-1997  jimschm   Added SourceDir to MIGRATE fn
     3-Apr-1997  jimschm   Added PreWin9xMigration

--*/

#include "setupp.h"
#pragma hdrstop

#define S_UNDO_INF          L"SF_UNDO.INF"
#define S_UNDO_PROFILESPATH L"PROFILESPATH"
#define S_UNDO_MOVEDFILES   L"MOVEDFILES"

typedef BOOL (WINAPI *MIGRATE) (HWND WizardParentWnd, LPCWSTR UnattendFile, LPCWSTR SourceDir);
typedef BOOL (WINAPI *FILEREMOVAL) (void);

static HANDLE g_Win95UpgNTLib;

BOOL
SpCreateSpoolerKey (
    VOID
    )
{
    HKEY SpoolerKey;
    LONG rc;
    DWORD DontCare;
    static DWORD NinetyFive = 95;

    //
    // For spooler: write an upgrade flag that will automatically be removed
    //

    rc = RegCreateKeyEx (
             HKEY_LOCAL_MACHINE,
             WINNT_WIN95UPG_SPOOLER,
             0,
             NULL,
             0,
             KEY_WRITE,
             NULL,
             &SpoolerKey,
             &DontCare
             );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    rc = RegSetValueEx (
             SpoolerKey,
             WINNT_WIN95UPG_UPGRADE_VAL,
             0,
             REG_DWORD,
             (LPBYTE) &NinetyFive,
             sizeof (NinetyFive)
             );

    RegCloseKey (SpoolerKey);

    return rc == ERROR_SUCCESS;
}

BOOL
PreWin9xMigration(
    VOID
    )
{
    BOOL b;
    
    BEGIN_SECTION(TEXT("PreWin9xMigration"));

    b = SpCreateSpoolerKey();
    if(!b){
        SetupDebugPrint(TEXT("SpCreateSpoolerKey failed"));
    }

    END_SECTION(TEXT("PreWin9xMigration"));

    return b;
}



BOOL
MigrateWin95Settings(
    IN HWND       hwndWizardParent,
    IN LPCWSTR    UnattendFile
    )
/*++

Routine Description:

    Loads w95upgnt.dll and calls W95UpgNt_Migrate.  This function
    transfers all Win9x settings to the new NT installation, and
    is completely restartable.

Arguments:

    hwndWizardParent    Handle to the wizard window, used for (rare) UI
    UnattendFile        The full Win32 path to the unattend file, to be
                        opened via Setup APIs

Return Value:

    Returns TRUE if the module was successful, or FALSE otherwise.
    GetLastError() holds a Win32 error code if not successful.

--*/
{
    MIGRATE Migrate;
    BOOL b = FALSE;
    WCHAR buffer[2048];

    g_Win95UpgNTLib = NULL;

    //
    // See if there is a replacement path for the w95upgnt.dll.
    //
    GetPrivateProfileStringW (
        WINNT_WIN95UPG_95_DIR_W,
        WINNT_WIN95UPG_NTKEY_W,
        L"",
        buffer,
        sizeof(buffer)/sizeof(WCHAR),
        UnattendFile
        );

    if (*buffer) {

        //
        // We have a replacement dll to load.
        //
        g_Win95UpgNTLib = LoadLibrary (buffer);
    }

    if (!g_Win95UpgNTLib) {

        //
        // Either there was not a replacement, or loading that replacement failed.
        //

        g_Win95UpgNTLib = LoadLibrary (L"w95upgnt.dll");

    }


    if (!g_Win95UpgNTLib) {

        return FALSE;
    }

    Migrate = (MIGRATE) GetProcAddress (g_Win95UpgNTLib, "W95UpgNt_Migrate");
    if (Migrate) {
        b = Migrate (hwndWizardParent, UnattendFile, SourcePath);
    }

    return b;
}



BOOL
Win95MigrationFileRemoval(
    void
    )
/*++

Routine Description:

    Loads w95upgnt.dll and calls W95UpgNt_FileRemoval.  This function
    deletes all Win9x-specific files and removes temporary files including
    all migration DLLs.  It is NOT restartable.

Arguments:

    none

Return Value:

    Returns TRUE if the module was successful, or FALSE otherwise.
    GetLastError() holds a Win32 error code if not successful.

--*/
{
    FILEREMOVAL FileRemoval;
    BOOL b = FALSE;

    FileRemoval = (FILEREMOVAL) GetProcAddress (g_Win95UpgNTLib, "W95UpgNt_FileRemoval");
    if (FileRemoval)
        b = FileRemoval();

    FreeLibrary (g_Win95UpgNTLib);
    return b;
}

#define SIF_REMOVEFILESX86        L"RemoveFiles.x86"

BOOL
RemoveFiles_X86 (
    IN HINF InfHandle
    )
{
    WCHAR fullPath[MAX_PATH],fileName[MAX_PATH];
    INFCONTEXT lineContext;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return TRUE;
    }
    if (SetupFindFirstLine (
            InfHandle,
            SIF_REMOVEFILESX86,
            NULL,
            &lineContext
            )) {
        do {
            if ((SetupGetStringField (&lineContext, 1, fileName, MAX_PATH, NULL)) &&
                (GetWindowsDirectory (fullPath, MAX_PATH)) &&
                (pSetupConcatenatePaths (fullPath, fileName, MAX_PATH, NULL)) &&
                (SetFileAttributes (fullPath, FILE_ATTRIBUTE_NORMAL))
                ) {
                DeleteFile (fullPath);
            }
        }
        while (SetupFindNextLine (&lineContext, &lineContext));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\testtool\x.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include "..\inc\spapip.h"
#include <stdio.h>


NTSTATUS
MyGetFileVersion(
    IN PVOID ImageBase
    );


VOID
__cdecl
wmain(
    IN int argc,
    IN WCHAR *argv[]
    )
{
    NTSTATUS Status;
    DWORD d;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID ImageBase;

    //
    // Open and map file for read.
    //
    d = OpenAndMapFileForRead(argv[1],&FileSize,&FileHandle,&MappingHandle,&ImageBase);
    if(d == NO_ERROR) {
        //
        // For some reason you have to set the low bit to make this work
        //
        MyGetFileVersion((PVOID)((ULONG)ImageBase | 1));

        UnmapAndCloseFile(FileHandle,MappingHandle,ImageBase);
    } else {
        printf("Couldn't open %ws\n",argv[1]);
    }
}




NTSTATUS
MyGetFileVersion(
    IN PVOID ImageBase
    )
{
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    NTSTATUS Status;
    ULONG IdPath[3];
    ULONG ResourceSize;
    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    ULONG VerMS,VerLS;


    IdPath[0] = (ULONG)RT_VERSION;
    IdPath[1] = (ULONG)MAKEINTRESOURCE(VS_VERSION_INFO);
    IdPath[2] = 0;

    Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    if(!NT_SUCCESS(Status)) {
        printf("Not a PE image or no version resources\n");
        goto c0;
    }

    Status = LdrAccessResource(ImageBase,DataEntry,&Resource,&ResourceSize);
    if(!NT_SUCCESS(Status)) {
        printf("Unable to access version resources\n");
        goto c0;
    }

    if((ResourceSize >= sizeof(*Resource)) && !_wcsicmp(Resource->Name,L"VS_VERSION_INFO")) {

        VerMS = Resource->FixedFileInfo.dwFileVersionMS;
        VerLS = Resource->FixedFileInfo.dwFileVersionLS;

        printf(
            "%u.%u.%u.%u\n",
            VerMS >> 16,
            VerMS & 0xffff,
            VerLS >> 16,
            VerLS & 0xffff
            );

    } else {

        printf("Invalid version resources");
    }

c0:
    return(Status);
}






































#if 0
    LPUNKNOWN pUnkOuter;
    IShellLink *psl;
    IPersistFile *ppf;
    CShellLink *this;
    BOOL b;

    b = FALSE;

    //
    // Create an IShellLink and query for IPersistFile
    //
    if(FAILED(SHCoCreateInstance(NULL,&CLSID_ShellLink,pUnkOuter,&IID_IShellLink,&psl))) {
        goto c0;
    }
    if(FAILED(psl->lpVtbl->QueryInterface(psl,&IID_IPersistFile,&ppf))) {
        goto c1;
    }

    //
    // Load the link from disk and get a pointer to
    // the actual link data.
    //
    if(FAILED(ppf->lpVtbl->Load(ppf,argv[1],0))) {
        goto c2;
    }
    this = IToClass(CShellLink,sl,psl);

    //
    // Remove the link tracking data.
    //
    Link_RemoveExtraDataSection(this,EXP_TRACKER_SIG);

    //
    // Save the link back out.
    //
    if(FAILED(ppf->lpVtbl->Save(ppf,argv[1],TRUE))) {
        goto c2;
    }

    //
    // Success.
    //
    b = TRUE;

c2:
    //
    // Release the IPersistFile object
    //
    ppf->lpVtbl->Release(ppf);
c1:
    //
    // Release the IShellLink object
    //
    psl->lpVtbl->Release(psl);
c0:
    return(b);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\batch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    batch.c

Abstract:

    This module implements batch command processing.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

ULONG InBatchMode;
HANDLE OutputFileHandle;
LARGE_INTEGER OutputFileOffset;
BOOLEAN RedirectToNULL;


#ifdef DBG

VOID
RcDumpTokenizedLine(
    PTOKENIZED_LINE Line 
    )
{
    if (Line) {
        PLINE_TOKEN  Token = Line->Tokens;
        ULONG Index        ;
        
        for(Index=0; ((Index < Line->TokenCount) && Token); Index++) {
            KdPrint(("%ws, ", Token->String));
            Token = Token->Next;
        }
        
        KdPrint(("\n"));
    } else {
        KdPrint(("Line is null!!!\n"));
    }
}

#endif
    

ULONG
pRcExecuteBatchFile(
    IN PWSTR BatchFileName,
    IN PWSTR OutputFileName,
    IN BOOLEAN Quiet
    )
{
    NTSTATUS Status = 0;
    LPCWSTR Arg;
    HANDLE FileHandle = NULL;
    HANDLE SectionHandle;
    PVOID ViewBase;
    ULONG FileSize;
    ULONG rc;
    WCHAR *s;
    WCHAR *p;
    ULONG sz;
    WCHAR *pText;
    ULONG rVal = 1;     // continue with RC
    BOOLEAN b = FALSE;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    PTOKENIZED_LINE TokenizedLine;
    BOOLEAN bCloseOutputFile = FALSE;

    if (!RcFormFullPath(BatchFileName,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }
    
    Status = SpOpenAndMapFile(
        _CmdConsBlock->TemporaryBuffer,
        &FileHandle,
        &SectionHandle,
        &ViewBase,
        &FileSize,
        FALSE
        );
        
    if( !NT_SUCCESS(Status) ) {
        if (!Quiet) {
            RcNtError(Status,MSG_CANT_OPEN_FILE);
        }
        goto exit;
    }

    pText = SpMemAlloc((FileSize+16)*sizeof(WCHAR));
    RtlZeroMemory(pText,(FileSize+16)*sizeof(WCHAR));

    Status = RtlMultiByteToUnicodeN(
        pText,
        FileSize * sizeof(WCHAR),
        &FileSize,
        ViewBase,
        FileSize
        );

    s = pText;
    sz = FileSize / sizeof(WCHAR);

    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);

    if (OutputFileName != NULL) {
        if (OutputFileHandle == NULL) {            
            if (!RcFormFullPath(OutputFileName,_CmdConsBlock->TemporaryBuffer, TRUE)) {
                RcMessageOut(MSG_INVALID_PATH);

                if (pText)
                	SpMemFree(pText);
                	
                goto exit;
            }
            
            INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

            Status = ZwCreateFile(
                &OutputFileHandle,
                FILE_GENERIC_WRITE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
				0,
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

            if (!NT_SUCCESS(Status)) {
                OutputFileHandle = NULL;
                RcMessageOut(Status);
            } else {
                bCloseOutputFile = TRUE;
            }

            OutputFileOffset.QuadPart = 0;
        } 
    }

    InBatchMode += 1;

	//
	// get each line and invoke dispatch command
	// on that line after tokenizing the arguments
	//
    while (sz) {  
		p = s;
		
        while (sz && (*p != L'\r')) {
            p += 1;
            sz--;
        }

        if (sz && (*p == L'\r')) {
            *p = 0;
            TokenizedLine = RcTokenizeLine(s);

            if (TokenizedLine->TokenCount) {
                rVal = RcDispatchCommand( TokenizedLine );

                if (rVal == 0 || rVal == 2) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }

                RcTextOut(L"\r\n");
            } else {
                b = TRUE;
            }
            
            RcFreeTokenizedLine(&TokenizedLine);

            if (b == FALSE) {
                goto exit;
            }

	        s = p + 1;
	        sz--;
	        
	        if (sz && (*s == L'\n')) {
	            s += 1;
	            sz--;
	        }
		}	    
    }
    

    SpMemFree(pText);

    InBatchMode -= 1;

    if (bCloseOutputFile) {
        ASSERT(OutputFileHandle != NULL);
        ZwClose(OutputFileHandle);
        OutputFileHandle = NULL;
    }

exit:
    return rVal;
}


ULONG
RcCmdBatch(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_BATCH_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount < 2 || (InBatchMode != 0 && 3 == TokenizedLine->TokenCount)) {
        RcMessageOut( MSG_SYNTAX_ERROR );
        return 1;
    }

    return pRcExecuteBatchFile(
        TokenizedLine->Tokens->Next->String,
        (TokenizedLine->TokenCount == 3) ? TokenizedLine->Tokens->Next->Next->String : NULL,
        FALSE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\cmds1.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmds1.c

Abstract:

    This module implements miscellaneous commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN AllowWildCards;

NTSTATUS
RcSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

NTSTATUS
RcSetFileCompression(
    LPCWSTR szFileName,
    BOOLEAN bCompress
    );
    
NTSTATUS
RcGetFileAttributes(
    LPCWSTR lpFileName,
    PULONG FileAttributes
    );

BOOLEAN
pRcCmdEnumDelFiles(
    IN  LPCWSTR Directory,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT NTSTATUS *Status,
    IN  PWCHAR DosDirectorySpec
    );
  


ULONG
RcCmdType(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPCWSTR Arg;
    HANDLE FileHandle;
    HANDLE SectionHandle;
    PVOID ViewBase;
    ULONG FileSize;
    ULONG rc;
    ULONG cbText;
    WCHAR *pText;
    NTSTATUS Status;


    if (RcCmdParseHelp( TokenizedLine, MSG_TYPE_HELP )) {
        return 1;
    }

    //
    // There should be a token for TYPE and one for the arg.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Get the argument and convert it into a full NT pathname.
    //
    Arg = TokenizedLine->Tokens->Next->String;
    if (!RcFormFullPath(Arg,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Get the argument and convert it into a full NT pathname.
    //
    if (!RcFormFullPath(Arg,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // Map in the entire file.
    //
    FileHandle = NULL;
    Status = SpOpenAndMapFile(
                             _CmdConsBlock->TemporaryBuffer,
                             &FileHandle,
                             &SectionHandle,
                             &ViewBase,
                             &FileSize,
                             FALSE
                             );

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
        return 1;
    }

    //
    // See if we think the file is Unicode. We think it's Unicode
    // if it's even length and starts with the Unicode text marker.
    //
    pText = ViewBase;
    cbText = FileSize;

    try {
        if( (cbText >= sizeof(WCHAR)) && (*pText == 0xfeff) && !(cbText & 1) ) {
            //
            // Assume it's already unicode.
            //
            pText = SpMemAlloc(cbText);
            RtlCopyMemory(pText,(WCHAR *)ViewBase+1,cbText-sizeof(WCHAR));
            pText[cbText/sizeof(WCHAR)] = 0;

        } else {
            //
            // It's not Unicode. Convert it from ANSI to Unicode.
            //
            // Allocate a buffer large enough to hold the maximum
            // unicode text.  This max size occurs when
            // every character is single-byte, and this size is
            // equal to exactly double the size of the single-byte text.
            //
            pText = SpMemAlloc((cbText+1)*sizeof(WCHAR));
            RtlZeroMemory(pText,(cbText+1)*sizeof(WCHAR));

            Status = RtlMultiByteToUnicodeN(
                                           pText,                  // output: newly allocated buffer
                                           cbText * sizeof(WCHAR), // max size of output
                                           &cbText,                // receives # bytes in unicode text
                                           ViewBase,               // input: ANSI text (mapped file)
                                           cbText                  // size of input
                                           );
        }
    }except(IN_PAGE_ERROR) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    if( NT_SUCCESS(Status) ) {
        pRcEnableMoreMode();
        RcTextOut(pText);
        pRcDisableMoreMode();
    } else {
        RcNtError(Status,MSG_CANT_READ_FILE);
    }

    if( pText != ViewBase ) {
        SpMemFree(pText);
    }
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);

    return 1;
}


ULONG
RcCmdDelete(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Final;
    BOOLEAN Confirm = FALSE;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PWSTR DelSpec = NULL;
    PWSTR DosDelSpec = NULL;
    WCHAR Text[2];
    PWSTR YesNo = NULL;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_DELETE_HELP )) {
        goto exit;
    }

    //
    // Fetch the spec for the file to be deleted and convert it
    // into a fully-qualified NT-style path.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    //
    // Leave room for appending * if necessary.
    //
    DelSpec = SpMemAlloc((wcslen(_CmdConsBlock->TemporaryBuffer)+3)*sizeof(WCHAR));
    wcscpy(DelSpec,_CmdConsBlock->TemporaryBuffer);

    //
    // Do the same thing, except now we want the DOS-style name.
    // This is used for printing in case of errors.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    DosDelSpec = SpMemAlloc((wcslen(_CmdConsBlock->TemporaryBuffer)+3)*sizeof(WCHAR));
    wcscpy(DosDelSpec,_CmdConsBlock->TemporaryBuffer);

    //
    // see if the user is authorized to delete this file
    //
    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    if (RcDoesPathHaveWildCards(_CmdConsBlock->TemporaryBuffer)) {
        Confirm = TRUE;
        if (!AllowWildCards) {
            RcMessageOut(MSG_DEL_WILDCARD_NOT_SUPPORTED);
            goto exit;
        }
    }

    //
    // Check to see whether the target specifies a directory.
    // If so, add the * so we don't need to special-case
    // the confirmation message later.
    //
    INIT_OBJA(&Obja,&UnicodeString,DelSpec);

    Status = ZwOpenFile(
        &Handle,
        FILE_READ_ATTRIBUTES,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE
        );
    if( NT_SUCCESS(Status) ) {
        ZwClose(Handle);
        SpConcatenatePaths(DelSpec,L"*");
        SpConcatenatePaths(DosDelSpec,L"*");
        Confirm = TRUE;
    }

    //
    // Fetch yes/no text
    //
    YesNo = SpRetreiveMessageText(ImageBase,MSG_YESNO,NULL,0);
    if (!YesNo) {
        Confirm = FALSE;
    }

    if (!InBatchMode) {
        while( Confirm ) {
            RcMessageOut(MSG_CONFIRM_DELETE,DosDelSpec);
            if( RcLineIn(Text,2) ) {
                if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                    //
                    // Wants to do it.
                    //
                    Confirm = FALSE;
                } else {
                    if( (Text[0] == YesNo[2]) || (Text[0] == YesNo[3]) ) {
                        //
                        // Doesn't want to do it.
                        //
                        goto exit;
                    }
                }
            }
        }
    }

    //
    // Trim back the DOS-style path so it's a path to the directory
    // containing the file or files to be deleted.
    //
    *wcsrchr(DosDelSpec,L'\\') = 0;

    // Perform deletion via callback.
    //
    Status = RcEnumerateFiles(TokenizedLine->Tokens->Next->String,
                             DelSpec,
                             pRcCmdEnumDelFiles,
                             DosDelSpec);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_FILE_ENUM_ERROR);
    }

exit:

    if (DelSpec) {
        SpMemFree(DelSpec);
    }
    if (DosDelSpec) {
        SpMemFree(DosDelSpec);
    }
    if (YesNo) {
        SpMemFree(YesNo);
    }

    return 1;
}


BOOLEAN
pRcCmdEnumDelFiles(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PWCHAR                      DosDirectorySpec
    )
{
    NTSTATUS status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    WCHAR *p;
    FILE_DISPOSITION_INFORMATION Disposition;
    unsigned u;

    *Status = STATUS_SUCCESS;

    //
    // Skip directories
    //
    if( FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        return(TRUE);
    }

    //
    // Form fully qualified NT path of the file to be deleted.
    //
    u = ((wcslen(Directory)+2)*sizeof(WCHAR)) + FileInfo->FileNameLength;
    p = SpMemAlloc(u);
    wcscpy(p,Directory);
    SpConcatenatePaths(p,FileInfo->FileName);

    INIT_OBJA(&Obja,&UnicodeString,p);

    status = ZwOpenFile(
                       &Handle,
                       (ACCESS_MASK)DELETE,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                       );

    if( !NT_SUCCESS(status) ) {
        RcTextOut(DosDirectorySpec);
        RcTextOut(L"\\");
        RcTextOut(FileInfo->FileName);
        RcTextOut(L"\r\n");
        RcNtError(status,MSG_DELETE_ERROR);
        SpMemFree(p);
        return(TRUE);
    }

#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    status = ZwSetInformationFile(
                                 Handle,
                                 &IoStatusBlock,
                                 &Disposition,
                                 sizeof(FILE_DISPOSITION_INFORMATION),
                                 FileDispositionInformation
                                 );

    ZwClose(Handle);

    if( !NT_SUCCESS(status) ) {
        RcTextOut(DosDirectorySpec);
        RcTextOut(L"\\");
        RcTextOut(FileInfo->FileName);
        RcTextOut(L"\r\n");
        RcNtError(status,MSG_DELETE_ERROR);
    }

    SpMemFree(p);

    return(TRUE);
}


ULONG
RcCmdRename(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Arg;
    WCHAR *p,*q;
    NTSTATUS Status;
    ULONG rc;


    //
    // check for help
    //
    if (RcCmdParseHelp( TokenizedLine, MSG_RENAME_HELP )) {
        return 1;
    }

    //
    // There should be a token for RENAME and one each for the source and
    // target names.
    //
    if (TokenizedLine->TokenCount != 3) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // use the console's temporary buffer
    //
    p = _CmdConsBlock->TemporaryBuffer;

    //
    // process the SOURCE filename
    //
    Arg = TokenizedLine->Tokens->Next->String;

    //
    // Convert the SOURCE filname into a DOS path so we
    // can verify if the path is allowed by our security restrictions.
    //
    if (!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(p,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the SOURCE filename into a fully qualified
    // NT-style path name.
    //
    if (!RcFormFullPath(Arg,p,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // using the same buffer for the TARGET name
    //
    q = p + wcslen(p) + 1;

    //
    // get the TARGET file name
    //
    Arg = TokenizedLine->Tokens->Next->Next->String;

    //
    // Verify that the TARGET filename does not contain
    // any path seperator characters or drive specifier
    // characters.
    //
    if( wcschr(Arg,L'\\') ) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    if( RcIsAlpha(Arg[0]) && (Arg[1] == L':') ) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Convert the DESTINATION filename into a DOS path so we
    // can verify if the path is allowed by our security restrictions.
    //
    if (!RcFormFullPath(Arg,q,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(q,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the SOURCE filename into a fully qualified
    // NT-style path name.
    //
    if (!RcFormFullPath(Arg,q,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    
    //
    // OK, looks like a plain filename specification.
    // Glom it onto the end of the relevent part of the
    // source specification so we have 2 fully qualified names.
    //
    // wcscpy(q,p);
    // wcscpy(wcsrchr(q,L'\\')+1,Arg);
    
    //
    // Call worker routine to actually do the rename.
    //
    Status = SpRenameFile(p,q,TRUE);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RENAME_ERROR, Arg);
    }

    return 1;
}


ULONG
RcCmdMkdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_MAKEDIR_HELP )) {
        return 1;
    }

    //
    // There should be a token for MKDIR and one for the target.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,TRUE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // Create the directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwCreateFile(
                         &Handle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_CREATE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                         NULL,
                         0
                         );

    if( NT_SUCCESS(Status) ) {
        ZwClose(Handle);
    } else {
        RcNtError(Status,MSG_CREATE_DIR_FAILED,TokenizedLine->Tokens->Next->String);
    }

    return 1;
}


ULONG
RcCmdRmdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    FILE_DISPOSITION_INFORMATION Disposition;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_REMOVEDIR_HELP )) {
        return 1;
    }

    //
    // There should be a token for RMDIR and one for the target.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,TRUE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                       &Handle,
                       DELETE | SYNCHRONIZE,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                       );

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RMDIR_ERROR);
        return 1;
    }

    Disposition.DeleteFile = TRUE;

    Status = ZwSetInformationFile(
                                 Handle,
                                 &IoStatusBlock,
                                 &Disposition,
                                 sizeof(FILE_DISPOSITION_INFORMATION),
                                 FileDispositionInformation
                                 );

    ZwClose(Handle);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RMDIR_ERROR);
    }

    return 1;
}


ULONG
RcCmdSetFlags(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_SETCMD_HELP )) {
        return 1;
    }
    
    if (TokenizedLine->TokenCount == 1) {
        RcTextOut( L"\r\n" );
        RcMessageOut(MSG_SET_ALLOW_WILDCARDS,AllowWildCards?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_ALLOW_ALLPATHS,AllowAllPaths?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_ALLOW_REMOVABLE_MEDIA,AllowRemovableMedia?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_NO_COPY_PROMPT,NoCopyPrompt?L"TRUE":L"FALSE");
        RcTextOut( L"\r\n" );
        return 1;
    }

    //
    // should have the priviledge to use the SET command
    //
    if (TokenizedLine->TokenCount != 4) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    if (RcGetSETCommandStatus() != TRUE) {    
        RcMessageOut(MSG_SETCMD_DISABLED);
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowallpaths")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowAllPaths = TRUE;
        } else {
            AllowAllPaths = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowwildcards")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowWildCards = TRUE;
        } else {
            AllowWildCards = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowremovablemedia")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowRemovableMedia = TRUE;
        } else {
            AllowRemovableMedia = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"nocopyprompt")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            NoCopyPrompt = TRUE;
        } else {
            NoCopyPrompt = FALSE;
        }
        return 1;
    }

    RcMessageOut(MSG_SYNTAX_ERROR);
    return 1;
}

ULONG
RcCmdAttrib(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS    Status;
    PWCHAR      AttributeString;
    ULONG       OldAttributes;
    ULONG       NewAttributes;
    BOOLEAN     SetAttribute;
    BOOLEAN     bShowHelp = TRUE;
    BOOLEAN     bChangeCompression = FALSE;

    // "attrib -h <filename>" should clear the hidden attribute
    // and not show the help
    if (TokenizedLine->TokenCount > 2){
        PWCHAR  szSecondParam = TokenizedLine->Tokens->Next->String;

        bShowHelp = !wcscmp( szSecondParam, L"/?" ); 
    }
    
    if (bShowHelp && RcCmdParseHelp( TokenizedLine, MSG_ATTRIB_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount != 3) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    
    //
    // Fetch the spec for the file to be attribed and convert it
    // into a fully-qualified NT-style path.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // see if the user is authorized to change this file
    //
    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }
   
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    Status = RcGetFileAttributes( _CmdConsBlock->TemporaryBuffer, &OldAttributes );
    
    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
        return 1;
    }

    NewAttributes = OldAttributes;
    
    for(AttributeString = TokenizedLine->Tokens->Next->String; *AttributeString; AttributeString++){
        if(*AttributeString == L'+'){
            SetAttribute = TRUE;
            AttributeString++;
        } else if(*AttributeString == L'-'){
            SetAttribute = FALSE;
            AttributeString++;
        } else {
            // attribute change should start with "+" or "-"
            if (AttributeString == TokenizedLine->Tokens->Next->String) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            // use the old state for setting or resetting (for +rsh
        }
    
        switch(*AttributeString){
            case L'h':
            case L'H':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_HIDDEN;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                    
                break;
                
            case L's':
            case L'S':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_SYSTEM;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_SYSTEM;
                    
                break;
                
            case L'r':
            case L'R':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_READONLY;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_READONLY;
                    
                break;
                
            case L'a':
            case L'A':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;
                    
                break;

            case L'c':
            case L'C':
                bChangeCompression = TRUE;

                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_COMPRESSED;
                    
                break;            
                
            default:
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;       
        }

        /*
        if (SetAttribute) {
            FileAttributes |= Attribute;
        } else {
            FileAttributes &= ~Attribute;
        }
        */
    }

    Status = RcSetFileAttributes( _CmdConsBlock->TemporaryBuffer, NewAttributes );
    
    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
    } else {
        if (bChangeCompression) {
            BOOLEAN bCompress = (NewAttributes & FILE_ATTRIBUTE_COMPRESSED) ?
                                    TRUE : FALSE;
                                    
            Status = RcSetFileCompression(_CmdConsBlock->TemporaryBuffer, bCompress);

            if ( !NT_SUCCESS(Status) )
                RcNtError(Status, MSG_ATTRIB_CANNOT_CHANGE_COMPRESSION);
        }        
    }        

    return 1;
}

NTSTATUS
RcSetFileCompression(
    LPCWSTR szFileName,
    BOOLEAN bCompress
    )
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Obja;
    HANDLE                  Handle;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    UNICODE_STRING          FileName;
    USHORT                  uCompressionType;
    
    
    INIT_OBJA(&Obja,&FileName,szFileName);
    
    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (NT_SUCCESS(Status)) {
        //
        // set & reset the compression bit also
        //
        uCompressionType = bCompress ? 
                            COMPRESSION_FORMAT_DEFAULT : COMPRESSION_FORMAT_NONE;

        Status = ZwFsControlFile(
                    Handle,                     // file handle
                    NULL,                       // event handle
                    NULL,                       // APC rountine pointer
                    NULL,                       // APC context
                    &IoStatusBlock,             // IO status block
                    FSCTL_SET_COMPRESSION,      // IOCTL code
                    &uCompressionType,          // input buffer
                    sizeof(uCompressionType),   // input buffer length
                    NULL,                       // output buffer pointer
                    0);                         // output buffer length

        DbgPrint( "ZwDeviceIoControlFile() status : %X\r\n", Status);

        ZwClose(Handle);
    }        

    return Status;
}

NTSTATUS
RcSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    NTStatus of last NT call
--*/

{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Obja;
    HANDLE                  Handle;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    UNICODE_STRING          FileName;
    USHORT                  uCompressionType;
    
    
    INIT_OBJA(&Obja,&FileName,lpFileName);
    
    //
    // Open the file ihibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //
       
            Status = ZwOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );
       
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

        }
        else {
            return Status;
        }
    }


    //
    // Set the basic attributes
    //
    ZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = ZwSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    ZwClose(Handle);

    return Status;
}

NTSTATUS
RcGetFileAttributes(
    LPCWSTR lpFileName,
    PULONG FileAttributes
    )

/*++

Routine Description:

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_REPARSE_POINT - The file is marked as a reparse point.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    INIT_OBJA(&Obja,&FileName,lpFileName);
    
    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //
       
            Status = ZwOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );
       
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }
        else {
            return Status;
        }
    }


    //
    // Query the file
    //

    Status = ZwQueryInformationFile(
                 Handle,
                 &IoStatusBlock,
                 (PVOID) &BasicInfo,
                 sizeof(BasicInfo),
                 FileBasicInformation
                 );
    
    if (NT_SUCCESS(Status)) {
        *FileAttributes = BasicInfo.FileAttributes;
    }
    
    ZwClose( Handle );

    return Status;

}


ULONG
RcCmdNet(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Share;
    WCHAR *User;
    WCHAR *pwch;
    WCHAR PasswordBuffer[64];
    WCHAR Drive[3];
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;



    //
    // check for help
    //
    if (RcCmdParseHelp( TokenizedLine, MSG_NET_USE_HELP )) {
        return 1;
    }

    //
    // There should be a token for NET and USE and one each for the server\share, and possible
    // tokens for the /u:domainname\username and password.
    //
    if ((TokenizedLine->TokenCount < 3) || (TokenizedLine->TokenCount > 5)) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // The only NET command supported is USE, so verify that the second token is that.
    //
    if (_wcsicmp(TokenizedLine->Tokens->Next->String, L"USE")){
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Get the first parameter to NET USE
    //
    Share = TokenizedLine->Tokens->Next->Next->String;

    if (*Share == L'\\') { // attempt at making a connection

        //
        // Verify the share name parameter
        //
        if (*(Share+1) != L'\\') {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }


        //
        // get the user logon context
        //
        if (TokenizedLine->TokenCount > 3) {
            
            //
            // The command has the context in it, so get it.
            //
            User = TokenizedLine->Tokens->Next->Next->Next->String;

            if (*User != L'/') {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            } 

            User++;
            pwch = User;
            while ((*pwch != UNICODE_NULL) && (*pwch != L':')) {
                pwch++;
            }

            if (*pwch != L':') {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            *pwch = UNICODE_NULL;
            pwch++;

            if (_wcsicmp(User, L"USER") && _wcsicmp(User, L"U")) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            User = pwch;

            //
            // Get the password
            //
            if (TokenizedLine->TokenCount == 4) {
                
                RcMessageOut( MSG_NET_USE_PROMPT_PASSWORD );
                RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
                RcPasswordIn( PasswordBuffer, 60 );

            } else {

                if (wcslen(TokenizedLine->Tokens->Next->Next->Next->Next->String) > 60) {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    return 1;
                }

                wcscpy(PasswordBuffer, TokenizedLine->Tokens->Next->Next->Next->Next->String);

                if ((PasswordBuffer[0] == L'*') && (PasswordBuffer[1] == UNICODE_NULL)) {

                    RcMessageOut( MSG_NET_USE_PROMPT_PASSWORD );
                    RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
                    RcPasswordIn( PasswordBuffer, 60 );

                } else if (PasswordBuffer[0] == L'"') {

                    pwch = &(PasswordBuffer[1]);

                    while (*pwch != UNICODE_NULL) {
                        pwch++;
                    }

                    pwch--;

                    if ((*pwch == L'"') && (pwch != &(PasswordBuffer[1]))) {
                        *pwch = UNICODE_NULL;
                    }

                    RtlMoveMemory(PasswordBuffer, &(PasswordBuffer[1]), (PtrToUlong(pwch) - PtrToUlong(PasswordBuffer)) + sizeof(WCHAR));
                
                }

            }

        } else {

            //
            // If we allow holding a current context, then we would use that here, but we currently
            // don't, so spew a syntax error message.
            //
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;

        }

        //
        // Call worker routine to make the connection
        //
        Status = RcDoNetUse(Share, User, PasswordBuffer, Drive);
        RtlSecureZeroMemory(PasswordBuffer, sizeof(PasswordBuffer));

        if( !NT_SUCCESS(Status) ) {
            RcNtError(Status, MSG_NET_USE_ERROR);
        } else {
            RcMessageOut(MSG_NET_USE_DRIVE_LETTER, Share, Drive);
        }

    } else { // attempt to disconnect

        //
        // Verify drive letter parameter
        //
        if ((*(Share+1) != L':') || (*(Share + 2) != UNICODE_NULL)) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }

        //
        // Verify /d parameter
        //
        User = TokenizedLine->Tokens->Next->Next->Next->String;
        
        if ((*User != L'/') || ((*(User + 1) != L'd') && (*(User + 1) != L'D'))) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }

        //
        // Call worker routine to actually do the disconnect.
        //
        Status = RcNetUnuse(Share);

        if( !NT_SUCCESS(Status) ) {
            RcNtError(Status, MSG_NET_USE_ERROR);
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\console.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    console.c

Abstract:

    This module implements the interfaces that
    provide access to the console i/o.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

//
// Notes:
//
// This code needs to be correct for DBCS. A double-byte character takes up
// 2 character spaces on the screen. This means that there is not a one-to-one
// correlation between the unicode characters we want to work with and the
// representation on the screen. For this reason, the code in this module
// does a lot of converting into the OEM charset. When represented in the
// OEM charset, strlen(x) is exactly the number of char spaces taken up
// on the screen. (The fonts used in text mode setup are all OEM charset fonts
// so that's why we use OEM).
//


#define CURSOR                SplangGetCursorChar()
#define CONSOLE_HEADER_HEIGHT 0

unsigned ConsoleX,ConsoleY;

UCHAR ConsoleLeadByteTable[128/8];
BOOLEAN ConsoleDbcs;

#define IS_LEAD_BYTE(c)  ((c < 0x80) ? FALSE : (ConsoleLeadByteTable[(c & 0x7f) / 8] & (1 << ((c & 0x7f) % 8))))
#define SET_LEAD_BYTE(c) (ConsoleLeadByteTable[(c & 0x7f)/8] |= (1 << ((c & 0x7f) % 8)))

PUCHAR ConsoleOemString;
ULONG ConsoleMaxOemStringLen;

#define CONSOLE_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLACK)
#define CONSOLE_BACKGROUND  ATT_BLACK

//
// Globals used for more mode.
//
BOOLEAN pMoreMode;
unsigned pMoreLinesOut;
unsigned pMoreMaxLines;

#define CONSOLE_MORE_ATTRIBUTE   (ATT_FG_BLACK | ATT_BG_WHITE)
#define CONSOLE_MORE_BACKGROUND  ATT_WHITE



BOOLEAN
pRcLineDown(
    BOOLEAN *pbScrolled
    );


VOID
RcConsoleInit(
    VOID
    )
{
    unsigned i;

    //
    // Build lead-byte table, set ConsoleDbcs global
    //
    RtlZeroMemory(ConsoleLeadByteTable,sizeof(ConsoleLeadByteTable));

    if(ConsoleDbcs = NLS_MB_OEM_CODE_PAGE_TAG) {

        for(i=128; i<=255; i++) {

            if((NLS_OEM_LEAD_BYTE_INFO)[i]) {

                SET_LEAD_BYTE(i);
            }
        }
    }

    //
    // Get a buffer for unicode to oem translations.
    //
    ConsoleMaxOemStringLen = 2000;
    ConsoleOemString = SpMemAlloc(ConsoleMaxOemStringLen);

    //
    // Clear screen and initialize cursor location.
    //
    pRcCls();
}


VOID
RcConsoleTerminate(
    VOID
    )
{
    ASSERT(ConsoleOemString);

    SpMemFree(ConsoleOemString);
    ConsoleOemString = NULL;
    ConsoleMaxOemStringLen = 0;
}


#define MAX_HISTORY_LINES 30

typedef struct _LINE_HISTORY {
    WCHAR Line[RC_MAX_LINE_LEN];
    ULONG Length;
} LINE_HISTORY, *PLINE_HISTORY;

LINE_HISTORY LineHistory[MAX_HISTORY_LINES];
ULONG CurPos;
ULONG NextPos;


void
RcPurgeHistoryBuffer(
    void
    )
{
    CurPos = 0;
    NextPos = 0;
    ZeroMemory( LineHistory, sizeof(LineHistory) );
}


void
RcClearToEOL(
    void
    )
{
    unsigned uWidth = _CmdConsBlock->VideoVars->ScreenWidth;
    unsigned uY = ConsoleY + (ConsoleX / uWidth);
    unsigned uX = ConsoleX % uWidth; // taking care of roll over

    SpvidClearScreenRegion(uX, uY, uWidth-uX,
        1, CONSOLE_BACKGROUND);
}

void
RcClearLines(
    unsigned uX, unsigned uY, unsigned cLines
    )
/*++
Routine Description:

This routine clears the specified number of lines with blank characters
starting from X coordinate (0 based) on lines specifed by Y coordinate

Arguments:
    uX - starting X coordinate
    uY - starting Y coordinate
    cLines - number of lines to be cleared after Y coordinate

Return Value: None
--*/
{
    unsigned uWidth = _CmdConsBlock->VideoVars->ScreenWidth;

    if (uY < _CmdConsBlock->VideoVars->ScreenWidth) {
        SpvidClearScreenRegion(uX, uY, uWidth-uX,
            1, CONSOLE_BACKGROUND);

        if (cLines && (cLines <= _CmdConsBlock->VideoVars->ScreenWidth)) {
            SpvidClearScreenRegion(0, ++uY, uWidth,
                cLines, CONSOLE_BACKGROUND);
        }
    }
}


unsigned
_RcLineIn(
    OUT PWCHAR Buffer,
    IN unsigned MaxLineLen,
    IN BOOLEAN PasswordProtect,
    IN BOOLEAN UseBuffer
    )

/*++

Routine Description:

    Get a line of input from the user. The user can type at the keyboard.
    Control is very simple, the only control character accepted is backspace.
    A cursor will be drawn as the user types to indicate where the next
    character will end up on the screen. As the user types the screen will be
    scrolled if necessary.

    The string returned will be limited to MaxLineLen-1 characters and
    0-terminated.

    NOTE: this routine deals with double-byte characters correctly.

Arguments:

    Buffer - receives the line as typed by the user. The buffer must be
        large enough to hold least 2 characters, since the string returned
        will always get a nul-termination and requesting a string that
        can have at most only a terminating nul isn't too meaningful.

    MaxLineLen - supplies the number of unicode characters that will fit
        in the buffer pointed to by Buffer (including the terminating nul).
        As described above, must be > 1.

Return Value:

    Number of characters written into Buffer, not including the terminating
    nul character.

    Upon return the global ConsoleX and ConsoleY variables will be updated
    such that ConsoleX is 0 and ConsoleY indicates the next "empty" line.
    Also the cursor will be shut off.

--*/

{
    unsigned LineLen;
    ULONG c;
    WCHAR s[2];
    UCHAR Oem[3];
    BOOL Done;
    ULONG OemLen;
    int i,j;
    ULONG OrigConsoleX;
    ULONG ulOrigY;
    BOOLEAN bScrolled = FALSE;

    ASSERT(MaxLineLen > 1);
    MaxLineLen--;       // leave room for terminating nul
    LineLen = 0;
    Done = FALSE;
    s[1] = 0;

    //
    // We use ConsoleOemString as temp storage for char lengths.
    // Make sure we don't run off the end of the buffer.
    //
    if(MaxLineLen > ConsoleMaxOemStringLen) {
        MaxLineLen = ConsoleMaxOemStringLen;
    }

    //
    // Turn cursor on.
    //
    s[0] = CURSOR;
    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

    //
    // Get characters until user hits enter.
    //
    CurPos = NextPos;
    OrigConsoleX = ConsoleX;
    ulOrigY = ConsoleY;

    if (UseBuffer) {
        LineLen = wcslen(Buffer);
        RtlZeroMemory(ConsoleOemString,ConsoleMaxOemStringLen);
        RtlUnicodeToOemN(ConsoleOemString,ConsoleMaxOemStringLen,&OemLen,Buffer,LineLen*sizeof(WCHAR));
        SpvidDisplayOemString(ConsoleOemString,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        ConsoleX += OemLen;
        RcClearToEOL();
        s[0] = CURSOR;
        SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        for (i=0; i<(int)wcslen(Buffer); i++) {
            RtlUnicodeToOemN(Oem,3,&OemLen,&Buffer[i],2*sizeof(WCHAR));
            ConsoleOemString[i] = (UCHAR)OemLen-1;
        }
    }

    do {

        c = SpInputGetKeypress();

        if(c & KEY_NON_CHARACTER) {
            if (c == KEY_UP || c == KEY_DOWN) {
                if (c == KEY_UP) {
                    if (CurPos == 0) {
                        i = MAX_HISTORY_LINES - 1;
                    } else {
                        i = CurPos - 1;
                    }
                    j = i;
                    while (LineHistory[i].Length == 0) {
                        i -= 1;
                        if (i < 0) {
                            i = MAX_HISTORY_LINES - 1;
                        }
                        if (i == j) break;
                    }
                }
                if (c == KEY_DOWN) {
                    if (CurPos == MAX_HISTORY_LINES) {
                        i = 0;
                    } else {
                        i = CurPos + 1;
                    }
                    j = i;
                    while (LineHistory[i].Length == 0) {
                        i += 1;
                        if (i == MAX_HISTORY_LINES) {
                            i = 0;
                        }
                        if (i == j) break;
                    }
                }

                if (LineHistory[i].Length) {
                    LineLen = LineHistory[i].Length;

                    if(LineLen > MaxLineLen) {
                        LineLen = MaxLineLen;
                    }

                    RtlCopyMemory(Buffer, LineHistory[i].Line, LineLen * sizeof(WCHAR));
                    Buffer[LineLen] = 0;
                    RtlZeroMemory(ConsoleOemString,ConsoleMaxOemStringLen);
                    RtlUnicodeToOemN(ConsoleOemString,ConsoleMaxOemStringLen,&OemLen,Buffer,LineLen*sizeof(WCHAR));
                    ConsoleX = OrigConsoleX;

                    // clear the old command
                    RcClearLines(ConsoleX, ulOrigY, ConsoleY - ulOrigY);

                    ConsoleY = ulOrigY;

                    // scroll if needed
                    if ((ConsoleX + OemLen) >= _CmdConsBlock->VideoVars->ScreenWidth) {
                        int cNumLines = (ConsoleX + OemLen) /
                                        _CmdConsBlock->VideoVars->ScreenWidth;
                        int cAvailLines = _CmdConsBlock->VideoVars->ScreenHeight -
                                            ConsoleY - 1;

                        if (cNumLines > cAvailLines) {
                            cNumLines -= cAvailLines;

                            SpvidScrollUp( CONSOLE_HEADER_HEIGHT,
                                _CmdConsBlock->VideoVars->ScreenHeight - 1,
                                cNumLines,
                                CONSOLE_BACKGROUND
                                );

                            ConsoleY -= cNumLines;
                            ulOrigY = ConsoleY;
                        }
                    }

                    SpvidDisplayOemString(ConsoleOemString,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    // clean up trailing spaces left by previous command
                    ConsoleX += OemLen;
                    //RcClearToEOL();
   	                s[0] = CURSOR;
  	
                    if (ConsoleX >= _CmdConsBlock->VideoVars->ScreenWidth) {
                        ConsoleY += (ConsoleX / _CmdConsBlock->VideoVars->ScreenWidth);
                        ConsoleY %= _CmdConsBlock->VideoVars->ScreenHeight;
                        ConsoleX %= _CmdConsBlock->VideoVars->ScreenWidth;
                    }

       	            SpvidDisplayString(s,CONSOLE_ATTRIBUTE, ConsoleX, ConsoleY);

                    CurPos = i;

                    for (i=0; i<(int)wcslen(Buffer); i++) {
                        RtlUnicodeToOemN(Oem,3,&OemLen,&Buffer[i],2*sizeof(WCHAR));
                        ConsoleOemString[i] = (UCHAR)OemLen-1;
                    }
                }
            }
        } else {
            //
            // Got a real unicode value, which could be CR, etc.
            //
            s[0] = (WCHAR)c;

            switch(s[0]) {

            case ASCI_ESC:
                LineLen = 0;
                ConsoleX = OrigConsoleX;
                CurPos = NextPos;
                // clear the extra lines from previous command if any
                RcClearLines(ConsoleX, ulOrigY, ConsoleY - ulOrigY);
                //RcClearToEOL();
                s[0] = CURSOR;
                ConsoleY = ulOrigY;
                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                break;

            case ASCI_BS:

                if(LineLen) {
                    LineLen--;

                    //
                    // Write a space over the current cursor location
                    // and then back up one char and write the cursor.
                    //
                    s[0] = L' ';
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    OemLen = ConsoleOemString[LineLen];
                    ASSERT(OemLen <= 2);

                    if(ConsoleX) {
                        //
                        // We might have the case where the character we just erased
                        // is a double-byte character that didn't fit on the previous
                        // line because the user typed it when the cursor was at the
                        // rightmost x position.
                        //
                        if(OemLen) {
                            //
                            // No special case needed. Decrement the x position and
                            // clear out the second half of double-byte char,
                            // if necessary.
                            //
                            ConsoleX -= OemLen;
                            if(OemLen == 2) {
                                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX+1,ConsoleY);
                            }
                        } else {
                            //
                            // Clear out the current character (which must be
                            // a double-byte character) and then hop up one line.
                            //
                            ASSERT(ConsoleX == 2);
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,0,ConsoleY);
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,1,ConsoleY);

                            ConsoleX = _CmdConsBlock->VideoVars->ScreenWidth-1;
                            ConsoleY--;
                        }
                    } else {
                        //
                        // The cursor is at x=0. This can't happen if
                        // there's a fill space at the end of the previous line,
                        // so we don't need to worry about handling that here.
                        //
                        ASSERT(OemLen != 3);
                        ConsoleX = _CmdConsBlock->VideoVars->ScreenWidth - OemLen;
                        ConsoleY--;

                        //
                        // Clear out second half of double-byte char if necessary.
                        //
                        if(OemLen > 1) {
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX+1,ConsoleY);
                        }
                    }

                    s[0] = CURSOR;
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
                }

                ulOrigY = ConsoleY;

                break;

            case ASCI_CR:
                //
                // Erase the cursor and advance the current position one line.
                //
                s[0] = L' ';
                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                ConsoleX = 0;
                pRcLineDown(0);

                //
                // We know there's room in the buffer because we accounted
                // for the terminating nul up front.
                //
                Buffer[LineLen] = 0;
                Done = TRUE;
                break;

            default:
                //
                // Plain old character. Note that it could be a double-byte char,
                // which takes up 2 char widths on the screen.
                //
                // Also disallow control chars.
                //
                if((s[0] >= L' ') && (LineLen < MaxLineLen)) {

                    //
                    // Convert to OEM, including nul byte
                    //
                    RtlUnicodeToOemN(Oem,3,&OemLen,PasswordProtect?L"*":s,2*sizeof(WCHAR));
                    OemLen--;

                    //
                    // Save the character in the caller's buffer.
                    // Also we use the ConsoleOemString buffer as temp storage space
                    // to store the length in oem chars of each char input.
                    //
                    Buffer[LineLen] = s[0];
                    ConsoleOemString[LineLen] = (UCHAR)OemLen;

                    //
                    // If the character is double-byte, then there might not be
                    // enough room on the current line for it. Check for that here.
                    //
                    if((ConsoleX+OemLen) > _CmdConsBlock->VideoVars->ScreenWidth) {

                        //
                        // Erase the cursor from the last position on the line.
                        //
                        s[0] = L' ';
                        SpvidDisplayString(
                            s,
                            CONSOLE_ATTRIBUTE,
                            _CmdConsBlock->VideoVars->ScreenWidth-1,
                            ConsoleY
                            );

                        //
                        // Adjust cursor position.
                        //
                        ConsoleX = 0;
                        // >> ulOrigY = ConsoleY;
                        bScrolled = FALSE;
                        pRcLineDown(&bScrolled);

                        //
                        // if screen scrolled then we need to adjust original Y coordinate
                        // appropriately
                        //
                        if (bScrolled && (ulOrigY > 0))
                            --ulOrigY;

                        //
                        // Special handling for this case, so backspace will
                        // work correctly.
                        //
                        ConsoleOemString[LineLen] = 0;
                    }

                    SpvidDisplayOemString(Oem,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
                    ConsoleX += OemLen;

                    if(ConsoleX == _CmdConsBlock->VideoVars->ScreenWidth) {
                        ConsoleX = 0;
                        // >> ulOrigY = ConsoleY;
                        bScrolled = FALSE;
                        pRcLineDown(&bScrolled);

                        //
                        // if screen scrolled then we need to adjust original Y coordinate
                        // appropriately
                        //
                        if (bScrolled && (ulOrigY > 0))
                            --ulOrigY;
                    }

                    //
                    // Now display cursor at cursor position for next character.
                    //
                    s[0] = CURSOR;
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    LineLen++;
                }

                break;
            }
        }
    } while(!Done);

    Buffer[LineLen] = 0;

    // save the line for future use only if its not a password
    if (LineLen && !PasswordProtect) {
        LineHistory[NextPos].Length = LineLen;
        wcscpy(LineHistory[NextPos].Line,Buffer);

        NextPos += 1;
        if (NextPos >= MAX_HISTORY_LINES) {
            NextPos = 0;
        }
    }

    return LineLen;
}


BOOLEAN
RcRawTextOut(
    IN LPCWSTR Text,
    IN LONG    Length
    )

/*++

Routine Description:

    Write a text string to the console at the current position
    (incidated by the ConsoleX and ConsoleY global variables). If the string
    is longer than will fit on the current line, it is broken up properly
    to span multiple lines. The screen is scrolled if necessary.

    This routine handles double-byte characters correctly, ensuring that
    no double-byte character is split across lines.

Arguments:

    Text - supplies the text to be output. Text strings longer than
        ConsoleMaxOemStringLen are truncated. The string need not be
        nul-terminated if Length is not -1.

    Length - supplies the number of characters to output. If -1, then
        Text is assumed to be nul-terminated and the length is
        calculated automatically.

Return Value:

    FALSE if we're in more mode and when prompted the user hit esc.
    TRUE otherwise.

    Upon return, the global variables ConsoleX and ConsoleY point at the next
    empty location on the screen.

--*/

{
    ULONG OemLen;
    ULONG len;
    ULONG i;
    UCHAR c;
    PUCHAR p;
    PUCHAR LastLead;
    BOOLEAN NewLine;
    BOOLEAN Dbcs;

    //
    // Convert the string to the OEM charset and determine the number
    // of character spaces the string will occupy on-screen, which is
    // equal to the number of bytes in the OEM representation of the string.
    // If this is not the same as the number of Unicode characters
    // in the string, then we've got a string with double-byte chars in it.
    //
    len = ((Length == -1) ? wcslen(Text) : Length);

    RtlUnicodeToOemN(
        ConsoleOemString,
        ConsoleMaxOemStringLen,
        &OemLen,
        (PVOID)Text,
        len * sizeof(WCHAR)
        );

    Dbcs = (OemLen != len);

    //
    // If we think we have a double-byte string, we better be prepared
    // to handle it properly.
    //
    if(Dbcs) {
        ASSERT(NLS_MB_OEM_CODE_PAGE_TAG);
        ASSERT(ConsoleDbcs);
    }

    //
    // Spit out the prompt in pieces until we've got all the characters
    // displayed.
    //
    ASSERT(ConsoleX < _CmdConsBlock->VideoVars->ScreenWidth);
    ASSERT(ConsoleY < _CmdConsBlock->VideoVars->ScreenHeight);
    p = ConsoleOemString;

    while(OemLen) {

        if((ConsoleX+OemLen) > _CmdConsBlock->VideoVars->ScreenWidth) {

            len = _CmdConsBlock->VideoVars->ScreenWidth - ConsoleX;

            //
            // Avoid splitting a double-byte character across lines.
            //
            if(Dbcs) {
                for(LastLead=NULL,i=0; i<len; i++) {
                    if(IS_LEAD_BYTE(p[i])) {
                        LastLead = &p[i];
                        i++;
                    }
                }
                if(LastLead == &p[len-1]) {
                    len--;
                }
            }

            NewLine = TRUE;

        } else {
            //
            // It fits on the current line, just display it.
            //
            len = OemLen;
            NewLine = ((ConsoleX+len) == _CmdConsBlock->VideoVars->ScreenWidth);
        }

        c = p[len];
        p[len] = 0;
        SpvidDisplayOemString(p,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        p[len] = c;

        p += len;
        OemLen -= len;

        if(NewLine) {
            ConsoleX = 0;
            if(!pRcLineDown(0)) {
                return(FALSE);
            }
        } else {
            ConsoleX += len;
        }
    }

    return(TRUE);
}


NTSTATUS
RcBatchOut(
    IN PWSTR strW
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG OemLen;
    ULONG len;


    len = wcslen(strW);

    RtlUnicodeToOemN(
        ConsoleOemString,
        ConsoleMaxOemStringLen,
        &len,
        (PVOID)strW,
        len * sizeof(WCHAR)
        );

    Status = ZwWriteFile(
        OutputFileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        (PVOID)ConsoleOemString,
        len,
        &OutputFileOffset,
        NULL
        );
    if (NT_SUCCESS(Status)) {
        OutputFileOffset.LowPart += len;
    }

    return Status;
}


BOOLEAN
RcTextOut(
    IN LPCWSTR Text
    )
{
    LPCWSTR p,q;


    if (InBatchMode && OutputFileHandle) {
        if (RcBatchOut( (LPWSTR)Text ) == STATUS_SUCCESS) {
            return TRUE;
        }
    }
    if (InBatchMode && RedirectToNULL) {
        return TRUE;
    }

    p = Text;
    while(*p) {
        //
        // Locate line terminator, which is cr, lf, or nul.
        //
        q = p;
        while(*q && (*q != L'\r') && (*q != L'\n')) {
            q++;
        }

        //
        // Print this segment out.
        //
        if(!RcRawTextOut(p,(LONG)(q-p))) {
            return(FALSE);
        }

        //
        // Handle cr's and lf's.
        //
        p = q;

        while((*p == L'\n') || (*p == L'\r')) {

            if(*p == L'\n') {
                if(!pRcLineDown(0)) {
                    return(FALSE);
                }
            } else {
                if(*p == L'\r') {
                    ConsoleX = 0;
                }
            }

            p++;
        }
    }

    return(TRUE);
}


BOOLEAN
pRcLineDown(
    BOOLEAN *pbScrolled
    )
{
    WCHAR *p;
    unsigned u;
    ULONG c;
    BOOLEAN b;

    if (pbScrolled)
        *pbScrolled = FALSE;

    b = TRUE;

    ConsoleY++;
    pMoreLinesOut++;

    if(ConsoleY == _CmdConsBlock->VideoVars->ScreenHeight) {
        //
        // Reached the bottom of the screen, need to scroll.
        //
        ConsoleY--;

        SpvidScrollUp(
            CONSOLE_HEADER_HEIGHT,
            _CmdConsBlock->VideoVars->ScreenHeight-1,
            1,
            CONSOLE_BACKGROUND
            );

        if (pbScrolled)
            *pbScrolled = TRUE;
    }

    //
    // If we're in more mode and we've output the max number of lines
    // allowed before requiring user input, get that input now.
    //
    if(pMoreMode
    && (pMoreLinesOut == pMoreMaxLines)
    && (p = SpRetreiveMessageText(ImageBase,MSG_MORE_PROMPT,NULL,0))) {

        //
        // Don't bother calling the format message routine, since that
        // requires some other buffer. Just strip off cr/lf manually.
        //
        u = wcslen(p);
        while(u && ((p[u-1] == L'\r') || (p[u-1] == L'\n'))) {
            p[--u] = 0;
        }

        //
        // Display the more prompt at the bottom of the screen.
        //
        SpvidClearScreenRegion(
            0,
            _CmdConsBlock->VideoVars->ScreenHeight - 1,
            _CmdConsBlock->VideoVars->ScreenWidth,
            1,
            CONSOLE_MORE_BACKGROUND
            );

        SpvidDisplayString(
            p,
            CONSOLE_MORE_ATTRIBUTE,
            2,
            _CmdConsBlock->VideoVars->ScreenHeight - 1
            );

        //
        // We don't need the prompt any more.
        //
        SpMemFree(p);

        //
        // Wait for the user to hit space, cr, or esc.
        //
        pMoreLinesOut = 0;
        while(1) {
            c = SpInputGetKeypress();
            if(c == ASCI_CR) {
                //
                // Allow one more line before prompting user.
                //
                pMoreMaxLines = 1;
                break;
            } else {
                if(c == ASCI_ESC) {
                    //
                    // User wants to stop the current command.
                    //
                    b = FALSE;
                    break;
                } else {
                    if(c == L' ') {
                        //
                        // Allow a whole page more.
                        //
                        pMoreMaxLines = _CmdConsBlock->VideoVars->ScreenHeight
                                      - (CONSOLE_HEADER_HEIGHT + 1);
                        break;
                    }
                }
            }
        }

        SpvidClearScreenRegion(
            0,
            _CmdConsBlock->VideoVars->ScreenHeight - 1,
            _CmdConsBlock->VideoVars->ScreenWidth,
            1,
            CONSOLE_BACKGROUND
            );
    }

    return(b);
}


VOID
pRcEnableMoreMode(
    VOID
    )
{
    pMoreMode = TRUE;

    pMoreLinesOut = 0;

    //
    // The maximum number of lines we allow before prompting the user
    // is the screen height minus the header area. We also reserve
    // one line for the prompt area.
    //
    pMoreMaxLines = _CmdConsBlock->VideoVars->ScreenHeight - (CONSOLE_HEADER_HEIGHT + 1);
}


VOID
pRcDisableMoreMode(
    VOID
    )
{
    pMoreMode = FALSE;
}


ULONG
RcCmdCls(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_CLS_HELP )) {
        return 1;
    }

    //
    // Call worker routine to actually do the work
    //
    pRcCls();

    return 1;
}


VOID
pRcCls(
    VOID
    )
{
    //
    // Initialize location and clear screen.
    //
    ConsoleX = 0;
    ConsoleY = CONSOLE_HEADER_HEIGHT;

    SpvidClearScreenRegion(0,0,0,0,CONSOLE_BACKGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\bootsect.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bootsect.c

Abstract:

    This module implements access to the boot sector.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include <boot98f.h>
#include <boot98f2.h>
#include <boot98n.h>
#include <bootetfs.h>
#include <bootf32.h>
#include <bootfat.h>
#include <bootntfs.h>

#pragma hdrstop

extern unsigned ConsoleX;

WCHAR           TemporaryBuffer[16384];
WCHAR           DriveLetterSpecified;
BOOLEAN         DidIt;

NTSTATUS
pSpBootCodeIoC(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN     PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    );

VOID
SpDetermineOsTypeFromBootSectorC(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    );

// prototypes
ULONG
RcStampBootSectorOntoDisk(
    VOID
    );

BOOL
RcEnumDiskRegionsCallback(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Ignore
    );

VOID
RcLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    );



ULONG
RcCmdFixBootSect(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the FIXBOOT command in the setup diagnostic
    command interpreter.

    FIXBOOT writes a new bootsector onto the system partition.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    TRUE.

--*/

{
    /*
    WCHAR   szText[2];
    PWSTR   szYesNo = NULL;
    BOOLEAN bConfirmed = FALSE;
    WCHAR   szMsg[512] = {0};
    PWSTR   szDriveSpecified = 0;
    PWSTR   szConfirmMsg = 0;
    */
    
    if (RcCmdParseHelp(TokenizedLine, MSG_FIXBOOT_HELP)) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 2) {
        //
        // a drive letter is specified
        //
        DriveLetterSpecified = TokenizedLine->Tokens->Next->String[0];
//        szDriveSpecified = TokenizedLine->Tokens->Next->String;
    } else {
        DriveLetterSpecified = 0;
    }

    /*
    if (!InBatchMode) {
        szYesNo = SpRetreiveMessageText(ImageBase, MSG_YESNO, NULL, 0);
        szConfirmMsg = SpRetreiveMessageText(ImageBase, 
                                    MSG_FIXBOOT_ARE_YOU_SURE, NULL, 0);
        
        if(!szYesNo || !szConfirmMsg) {
            bConfirmed = TRUE;
        }
        
        while (!bConfirmed) {
            swprintf(szMsg, szConfirmMsg, szDriveSpecified);
            RcTextOut(szMsg);
            
            if(RcLineIn(szText,2)) {
                if((szText[0] == szYesNo[0]) || (szText[0] == szYesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    bConfirmed = TRUE;
                } else {
                    if((szText[0] == szYesNo[2]) || (szText[0] == szYesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        break;
                    }
                }
            }
        }
    }

    if (bConfirmed)
    */
    RcStampBootSectorOntoDisk();

    return TRUE;
}

ULONG
RcStampBootSectorOntoDisk(
    VOID
    )

/*++

Routine Description:

    Setup the enumerate disk regions call, so we can do the boot sector.

Arguments:

    None.

Return Value:

    TRUE.

--*/


{
    // enumerate the partitions
    DidIt = FALSE;

    SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcEnumDiskRegionsCallback, 1 );

    if (!DidIt) {
        RcMessageOut( MSG_FIXBOOT_INVALID );
    }

    return TRUE;
}

BOOL
RcEnumDiskRegionsCallback(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Ignore
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    if (Region->PartitionedSpace) {
        if (DriveLetterSpecified) {
            if( RcToUpper(DriveLetterSpecified) == RcToUpper(Region->DriveLetter) ) {
                RcMessageOut( MSG_FIXBOOT_INFO1, Region->DriveLetter );
                RcLayBootCode( Region );
                DidIt = TRUE;
                return FALSE;
            }

        } else if (Region->IsSystemPartition) {
            DEBUG_PRINTF(( "system partition is %wc\n", Region->DriveLetter ));
            RcMessageOut( MSG_FIXBOOT_INFO1, Region->DriveLetter );
            RcLayBootCode( Region );
            DidIt = TRUE;
            return FALSE;
        }
    }

    return TRUE;
}


VOID
RcLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    )

/*++

Routine Description:

    RcLayBootCode contains the code that replaces the boot sector on the
    targetted disk region.

Arguments:

    CColonRegion - the startup partition for the system.

Return Value:

    None.

--*/

{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode = NULL;
    NTSTATUS Status;
    NTSTATUS rc;
    PUCHAR ExistingBootCodeOs = NULL;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    //PWSTR BootsectDosName = L"\\bootsect.dos";
    //PWSTR OldBootsectDosName = L"\\bootsect.bak";
    //PWSTR BootSectDosFullName, OldBootSectDosFullName, p;
    BOOLEAN IsNtBootcode,OtherOsInstalled, FileExist;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG MirrorSector;
    ULONG BytesPerSector;
    ULONG SectorsPerTrack;
    ULONG TracksPerCylinder;
    ULONGLONG ActualSectorCount, hidden_sectors, super_area_size;
    UCHAR SysId;
    ULONGLONG HiddenSectorCount,VolumeSectorCount; //NEC98
    PUCHAR DiskArraySectorData,TmpBuffer; //NEC98
    IO_STATUS_BLOCK StatusBlock;
    UCHAR InfoBuffer[2048];
    WCHAR   szText[2];
    PWSTR   szYesNo = NULL;
    BOOLEAN bConfirmed = FALSE;
    //WCHAR   szMsg[512] = {0};
    WCHAR   szDriveSpecified[8] = {0};

    if (!InBatchMode) {
        //
        // get confirmation from user before proceeding
        // 
        szYesNo = SpRetreiveMessageText(ImageBase, MSG_YESNO, NULL, 0);
        szDriveSpecified[0] = CColonRegion->DriveLetter;
        szDriveSpecified[1] = L':';
        szDriveSpecified[2] = 0;
        
        if(!szYesNo || !szDriveSpecified[0]) {
            bConfirmed = TRUE;
        }
        
        while (!bConfirmed) {
            RcMessageOut(MSG_FIXBOOT_ARE_YOU_SURE, szDriveSpecified);
            
            if(RcLineIn(szText,2)) {
                if((szText[0] == szYesNo[0]) || (szText[0] == szYesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    bConfirmed = TRUE;
                } else {
                    if((szText[0] == szYesNo[2]) || (szText[0] == szYesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        break;
                    }
                }
            }
        }
    }

    if (!bConfirmed)
        return;     // user did not want to proceed

    switch( CColonRegion->Filesystem ) {
        case FilesystemNewlyCreated:
            //
            // If the filesystem is newly-created, then there is
            // nothing to do, because there can be no previous
            // operating system.
            //
            return;

        case FilesystemNtfs:
            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);
            RcMessageOut( MSG_FIXBOOT_FS, L"NTFS" );
            break;

        case FilesystemFat:
            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);
            RcMessageOut( MSG_FIXBOOT_FS, L"FAT" );
            break;

        case FilesystemFat32:
            //
            // Special hackage required for Fat32 because its NT boot code
            // is discontiguous.
            //
            ASSERT(sizeof(Fat32BootCode) == 1536);
            NewBootCode = (!IsNEC_98) ? Fat32BootCode : PC98Fat32BootCode; //NEC98
            BootCodeSize = 512;
            RcMessageOut( MSG_FIXBOOT_FS, L"FAT32" );
            break;

        default:
            // we assume that the boot sector is corrupt if it is
            // not a FAT or NTFS boot partition.
            BootSectorCorrupt = TRUE;
            DEBUG_PRINTF(("CMDCONS: bogus filesystem %u for C:!\n",CColonRegion->Filesystem));
            RcMessageOut( MSG_FIXBOOT_NO_VALID_FS );
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion( CColonRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalCurrent );

    CColonPath = SpDupStringW( TemporaryBuffer );

    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile( &PartitionHandle,
                           FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if (!NT_SUCCESS(Status)) {
        DEBUG_PRINTF(("CMDCONS: unable to open the partition for C:!\n"));
        RcMessageOut( MSG_FIXBOOT_FAILED1 );
        return;
    }

    //
    // get disk geometry
    //

    rc = ZwDeviceIoControlFile( PartitionHandle,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                NULL,
                                0,
                                InfoBuffer,
                                sizeof( InfoBuffer ) );

    if (!NT_SUCCESS( rc )) {

        RcMessageOut( MSG_FIXBOOT_READ_ERROR );

    } else {
        //
        // retrieve the sector size and other info
        //
        BytesPerSector = ((DISK_GEOMETRY*)InfoBuffer)->BytesPerSector;
        TracksPerCylinder = ((DISK_GEOMETRY*)InfoBuffer)->TracksPerCylinder;
        SectorsPerTrack = ((DISK_GEOMETRY*)InfoBuffer)->SectorsPerTrack;
    }

    //
    // Enable extended DASD I/O so we can read the last sector on the
    // disk.
    //

    rc = ZwFsControlFile( PartitionHandle,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                FSCTL_ALLOW_EXTENDED_DASD_IO,
                                NULL,
                                0,
                                NULL,
                                0 );

    ASSERT( NT_SUCCESS(rc) );

    //
    // Allocate a buffer and read in the boot sector(s) currently on the disk.
    //

    if (BootSectorCorrupt) {

        //
        // The partition is UNKNOWN or cannot be determined by the system.
        //

        //
        // We can't determine the file system type from the boot sector, so
        // we assume it's NTFS if we find a mirror sector, and FAT otherwise.
        //

        RcMessageOut( MSG_FIXBOOT_DETERMINE );
        DEBUG_PRINTF(( "BootSectorCorrupt TRUE\n" ));

        //
        // First, attempt to find an NTFS mirror boot sector.
        //

        MirrorSector = NtfsMirrorBootSector (PartitionHandle,
                                             BytesPerSector,
                                             &ExistingBootCode);

        if (MirrorSector) {

            //
            // It's NTFS - use the mirror boot sector to recover the drive.
            //

            RcMessageOut( MSG_FIXBOOT_FOUND_NTFS );

            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);

            CColonRegion->Filesystem = FilesystemNtfs;
            IsNtBootcode = TRUE;

        } else {

            //
            // It's FAT - create a new boot sector since there's no mirror.
            //

            RcMessageOut( MSG_FIXBOOT_FOUND_FAT );

            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);

            CColonRegion->Filesystem = FilesystemFat;
            IsNtBootcode = FALSE;

            SpPtGetSectorLayoutInformation( CColonRegion,
                                            &hidden_sectors,
                                            &ActualSectorCount );

            //
            // No alignment requirement here
            //

            ExistingBootCode = SpMemAlloc(BytesPerSector);

            //
            // This will actually fail with STATUS_BUFFER_TOO_SMALL
            // but it will fill in the bpb info, which is what we want.
            //

            FmtFillFormatBuffer ( ActualSectorCount,
                                  BytesPerSector,
                                  SectorsPerTrack,
                                  TracksPerCylinder,
                                  hidden_sectors,
                                  ExistingBootCode,
                                  BytesPerSector,
                                  &super_area_size,
                                  NULL,
                                  0,
                                  &SysId );

        }

        Status = STATUS_SUCCESS;

    } else if( CColonRegion->Filesystem == FilesystemNtfs ) {

        //
        // The partition is NTFS.
        //

        //
        // We use the mirror sector to repair a NTFS file system
        // if we can find one.
        //

        MirrorSector = NtfsMirrorBootSector( PartitionHandle,
                                             BytesPerSector,
                                             &ExistingBootCode );

        if( !MirrorSector ) {

            //
            // Just use existing NTFS boot code.
            //
            Status = pSpBootCodeIoC( CColonPath,
                                    NULL,
                                    BootCodeSize,
                                    &ExistingBootCode,
                                    FILE_OPEN,
                                    FALSE,
                                    0,
                                    BytesPerSector );
        }

    } else {

        //
        // The partition is FAT.
        //

        //
        // Just use existing boot code since
        // there is no mirror sector on FAT.
        //

        Status = pSpBootCodeIoC( CColonPath,
                                NULL,
                                BootCodeSize,
                                &ExistingBootCode,
                                FILE_OPEN,
                                FALSE,
                                0,
                                BytesPerSector );

    }

    if( NT_SUCCESS(Status) ) {

        //
        // Determine the type of operating system the existing boot sector(s) are for
        // and whether that os is actually installed. Note that we don't need to call
        // this for NTFS.
        //

        // RcMessageOut( MSG_FIXBOOT_CHECKING_OS );

        if( BootSectorCorrupt ) {

            //
            // If the boot sector is corrupt, we don't assume
            // another OS was installed.
            //

            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        } else if( CColonRegion->Filesystem != FilesystemNtfs ) {

            // If the file system is FAT, DOS could have been installed
            // previously.

            SpDetermineOsTypeFromBootSectorC( CColonPath,
                                             ExistingBootCode,
                                             &ExistingBootCodeOs,
                                             &IsNtBootcode,
                                             &OtherOsInstalled,
                                             CColonRegion->DriveLetter );

        } else {

            //
            // Otherwise, it's NTFS, and another OS type
            // couldn't have been installed.
            //

            IsNtBootcode = TRUE;
            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        }

        if( NT_SUCCESS(Status) ) {

            //
            // Transfer the bpb from the existing boot sector into the boot code buffer
            // and make sure the physical drive field is set to hard disk (0x80).
            //
            // The first three bytes of the NT boot code are going to be something like
            // EB 3C 90, which is intel jump instruction to an offset in the boot sector,
            // past the BPB, to continue execution.  We want to preserve everything in the
            // current boot sector up to the start of that code.  Instead of hard coding
            // a value, we'll use the offset of the jump instruction to determine how many
            // bytes must be preserved.
            //

            RtlMoveMemory(NewBootCode+3,ExistingBootCode+3,NewBootCode[1]-1);

            if( CColonRegion->Filesystem != FilesystemFat32 ) {
                //
                // On fat32 this overwrites the BigNumFatSecs field,
                // a very bad thing to do indeed!
                //
                NewBootCode[36] = 0x80;
            }

            //
            // get Hidden sector informatin.
            //
            if( IsNEC_98 ) { //NEC98
                SpPtGetSectorLayoutInformation(
                                              CColonRegion,
                                              &HiddenSectorCount,
                                              &VolumeSectorCount    // not used
                                              );
            } //NEC98

            //
            // Write out boot code buffer, which now contains the valid bpb,
            // to the boot sector(s).
            //

            RcMessageOut( MSG_FIXBOOT_WRITING );

            Status = pSpBootCodeIoC(
                            CColonPath,
                            NULL,
                            BootCodeSize,
                            &NewBootCode,
                            FILE_OPEN,
                            TRUE,
                            0,
                            BytesPerSector
                            );


            //
            // Special case for Fat32, which has a second sector of boot code
            // at sector 12, discontiguous from the code on sector 0.
            //

            if( NT_SUCCESS(Status) && (CColonRegion->Filesystem == FilesystemFat32) ) {

                NewBootCode = (!IsNEC_98) ? Fat32BootCode + 1024
                              : PC98Fat32BootCode + 1024;                                //NEC98


                Status = pSpBootCodeIoC(
                                CColonPath,
                                NULL,
                                BootCodeSize,
                                &NewBootCode,
                                FILE_OPEN,
                                TRUE,
                                12*512,
                                BytesPerSector
                                );
            }

            //
            // Update the mirror boot sector.
            //
            if( (CColonRegion->Filesystem == FilesystemNtfs) && MirrorSector ) {

                WriteNtfsBootSector(PartitionHandle,BytesPerSector,NewBootCode,MirrorSector);

            }
        }

        if( ExistingBootCodeOs ) {
            SpMemFree(ExistingBootCodeOs);
        }
    }

    if( ExistingBootCode ) {
        SpMemFree(ExistingBootCode);
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);

    //
    // Handle the error case.
    //
    if (!NT_SUCCESS(Status)) {
        RcMessageOut( MSG_FIXBOOT_FIX_ERROR );
    } else {
        RcMessageOut( MSG_FIXBOOT_DONE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\dir.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements the dir commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

//
// global external variables
//
extern LARGE_INTEGER glBias;

typedef struct _DIR_STATS {
    unsigned            FileCount;
    LONGLONG            TotalSize;
    RcFileSystemType    fsType;
} DIR_STATS, *PDIR_STATS;

BOOLEAN
pRcDirEnumProc(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PDIR_STATS                  DirStats
    );

NTSTATUS
SpSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

NTSTATUS
SpLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );



    
ULONG
RcCmdDir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPCWSTR Dir;
    LPWSTR Path;
    LPWSTR DosPath;
    LPWSTR p;
    NTSTATUS Status;
    WCHAR Drive[4];
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    DIR_STATS DirStats;
    ULONG u;
    ULONG rc;
    PFILE_FS_VOLUME_INFORMATION     VolumeInfo;
    FILE_FS_SIZE_INFORMATION        SizeInfo;
    BYTE                            bfFSInfo[sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                                        (MAX_PATH*2)];       
    PFILE_FS_ATTRIBUTE_INFORMATION  pFSInfo = 0;


    if (RcCmdParseHelp( TokenizedLine, MSG_DIR_HELP )) {
        return 1;
    }

    //
    // If there's no argument, then we want the current directory.
    //
    Dir = (TokenizedLine->TokenCount == 2)
        ? TokenizedLine->Tokens->Next->String
        : L".";

    //
    // Canonicalize the name once to get a full DOS-style path
    // we can print out, and another time to get the NT-style path
    // we'll use to actually do the work.
    //
    if (!RcFormFullPath(Dir,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    DosPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    if (!RcFormFullPath(Dir,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    Path = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    //
    // Open up the root directory of the drive so we can query
    // the volume label, serial number, and free space.
    //
    Drive[0] = DosPath[0];
    Drive[1] = L':';
    Drive[2] = L'\\';
    Drive[3] = 0;
    if (!RcFormFullPath(Drive,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        DEBUG_PRINTF(( "couldn't open root of drive!" ));
        RcNtError( STATUS_NO_MEDIA_IN_DEVICE, MSG_NO_MEDIA_IN_DEVICE );
        goto c2;
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    pRcEnableMoreMode();

    if(NT_SUCCESS(Status)) {
        //
        // Get the volume label and serial number.
        //
        VolumeInfo = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    VolumeInfo,
                    _CmdConsBlock->TemporaryBufferSize,
                    FileFsVolumeInformation
                    );

        if(NT_SUCCESS(Status)) {
            //
            // We can tell the user the volume label and serial number.
            //
            VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/sizeof(WCHAR)] = 0;
            p = SpDupStringW(VolumeInfo->VolumeLabel);
            u = VolumeInfo->VolumeSerialNumber;

            RcMessageOut(
                *p ? MSG_DIR_BANNER1a : MSG_DIR_BANNER1b,
                RcToUpper(DosPath[0]),
                p
                );

            SpMemFree(p);

            RcMessageOut(MSG_DIR_BANNER2,u >> 16,u & 0xffff);
        }

        //
        // Get free space value for drive.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(FILE_FS_SIZE_INFORMATION),
                    FileFsSizeInformation
                    );

        if(!NT_SUCCESS(Status)) {
            SizeInfo.BytesPerSector = 0;
        }
        
        //
        // Get the type of the file system so that we can handle
        // the file times properly (NT stores the date in UTC).
        //
        RtlZeroMemory(bfFSInfo, sizeof(bfFSInfo));
        pFSInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) bfFSInfo;

        Status = ZwQueryVolumeInformationFile(
                        Handle, 
                        &IoStatusBlock,
                        pFSInfo,
                        sizeof(bfFSInfo),
                        FileFsAttributeInformation);
                        
        ZwClose(Handle);
    }

    //
    // Tell the user the full DOS path of the directory.
    //
    RcMessageOut(MSG_DIR_BANNER3,DosPath);

    //
    // Now go enumerate the directory.
    //
    RtlZeroMemory(&DirStats,sizeof(DIR_STATS));

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON:Could not get volume information, Error Code:%lx\n", Status));
        DirStats.fsType = RcUnknown;  // assume FAT file system (by default)
    } else {
        if (!wcscmp(pFSInfo->FileSystemName, L"NTFS"))
            DirStats.fsType = RcNTFS;
        else if (!wcscmp(pFSInfo->FileSystemName, L"FAT"))
            DirStats.fsType = RcFAT;
        else if (!wcscmp(pFSInfo->FileSystemName, L"FAT32"))
            DirStats.fsType = RcFAT32;
        else if (!wcscmp(pFSInfo->FileSystemName, L"CDFS"))
            DirStats.fsType = RcCDFS;
        else
            DirStats.fsType = RcUnknown;
    }

    KdPrint(("SPCMDCON: RcCmdDir detected file system type (%lx)-%ws\n",
                    DirStats.fsType, pFSInfo ? pFSInfo->FileSystemName : L"None"));
    
    Status = RcEnumerateFiles(Dir,Path,pRcDirEnumProc,&DirStats);

    pRcDisableMoreMode();

    if(NT_SUCCESS(Status)) {

        RcFormat64BitIntForOutput(DirStats.TotalSize,_CmdConsBlock->TemporaryBuffer,FALSE);
        p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
        RcMessageOut(MSG_DIR_BANNER4,DirStats.FileCount,p);
        SpMemFree(p);
        if(SizeInfo.BytesPerSector) {
            RcFormat64BitIntForOutput(
                SizeInfo.AvailableAllocationUnits.QuadPart * (LONGLONG)SizeInfo.SectorsPerAllocationUnit * (LONGLONG)SizeInfo.BytesPerSector,
                _CmdConsBlock->TemporaryBuffer,
                FALSE
                );
            p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
            RcMessageOut(MSG_DIR_BANNER5,p);
            SpMemFree(p);
        }
    } else {
        RcNtError(Status,MSG_FILE_ENUM_ERROR);
    }

c2:
    SpMemFree(Path);
    SpMemFree(DosPath);
    return 1;
}


BOOLEAN
pRcDirEnumProc(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PDIR_STATS                  DirStats
    )
{
    WCHAR           LineOut[50];
    WCHAR           *p;
    NTSTATUS        timeStatus;
    LARGE_INTEGER   *pLastWriteTime = 0;
    LARGE_INTEGER   lastWriteTime;
    LARGE_INTEGER   timeBias;
    TIME_FIELDS     timeFields;
    TIME_ZONE_INFORMATION   timeZone;

    UNREFERENCED_PARAMETER(Directory);

    DirStats->FileCount++;
    DirStats->TotalSize += FileInfo->EndOfFile.QuadPart;
    lastWriteTime = FileInfo->LastWriteTime;

    // 
    // Convert the time into local time from UTC if the file
    // system is NTFS
    //       
    switch(DirStats->fsType) {
        case RcNTFS:
        case RcCDFS:
            // localtime = UTC - bias
            lastWriteTime.QuadPart -= glBias.QuadPart;       
            break;
        
        case RcFAT:
        case RcFAT32:
        default:
            break;
    }
       
    //
    // Format the date and time, which go first.
    //
    RcFormatDateTime(&lastWriteTime,LineOut);
    RcTextOut(LineOut);

    //
    // 2 spaces for separation
    //
    RcTextOut(L"  ");

    //
    // File attributes.
    //
    p = LineOut;
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        *p++ = L'd';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        *p++ = L'a';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_READONLY) {
        *p++ = L'r';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        *p++ = L'h';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        *p++ = L's';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
        *p++ = L'c';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        *p++ = L'e';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        *p++ = L'p';
    } else {
        *p++ = L'-';
    }

    *p = 0;

    RcTextOut(LineOut);

    //
    // 2 spaces for separation
    //
    RcTextOut(L"  ");

    //
    // Now, put the size in there. Right justified and space padded
    // up to 8 chars. Oterwise unjustified or padded.
    //
    RcFormat64BitIntForOutput(FileInfo->EndOfFile.QuadPart,LineOut,TRUE);
    if(FileInfo->EndOfFile.QuadPart > 99999999i64) {
        RcTextOut(LineOut);
    } else {
        RcTextOut(LineOut+11);          // outputs 8 chars
    }

    RcTextOut(L" ");

    //
    // Finally, put the filename on the line. Need to 0-terminate it first.
    //
    wcsncpy(_CmdConsBlock->TemporaryBuffer,FileInfo->FileName,FileInfo->FileNameLength);
    ((WCHAR *)_CmdConsBlock->TemporaryBuffer)[FileInfo->FileNameLength] = 0;

    *Status = STATUS_SUCCESS;
    return((BOOLEAN)(RcTextOut(_CmdConsBlock->TemporaryBuffer) && RcTextOut(L"\r\n")));
}


NTSTATUS
RcEnumerateFiles(
    IN LPCWSTR      OriginalPathSpec,
    IN LPCWSTR      FullyQualifiedPathSpec,
    IN PENUMFILESCB Callback,
    IN PVOID        CallerData
    )
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOLEAN b;
    WCHAR *p;
    WCHAR *LastComponent = NULL;
    PFILE_BOTH_DIR_INFORMATION      DirectoryInfo;
    unsigned u;
    WCHAR *NameChar;
    BOOLEAN EndsInDot;
    WCHAR *DirectoryPart;

    //
    // Determine whether the original path spec ends with a .
    // This is used below to get around a problem with specifying
    // *. as a search specifier.
    //
    u = wcslen(OriginalPathSpec);
    if(u && (OriginalPathSpec[u-1] == L'.')) {
        EndsInDot = TRUE;
    } else {
        EndsInDot = FALSE;
    }

    //
    // Determine whether the given path points at a directory.
    // If so, we'll concatenate \* on the end and fall through
    // to the common case.
    //
    b = FALSE;

    INIT_OBJA(&Obja,&UnicodeString,FullyQualifiedPathSpec);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        b = TRUE;
    }

    if(b) {
        //
        // Directory, append \*.
        //
        p = SpMemAlloc((wcslen(FullyQualifiedPathSpec)+3)*sizeof(WCHAR));

        if (p) {
            wcscpy(p,FullyQualifiedPathSpec);
            SpConcatenatePaths(p,L"*");
            EndsInDot = FALSE;
        }            
    } else {
        //
        // Not directory, pass as-is. Note that this could be an actual
        // file, or a wild-card spec.
        //
        p = SpDupStringW((PVOID)FullyQualifiedPathSpec);
    }

    //
    // Now trim back the path/file specification so we can open the containing
    // directory for enumeration.
    //
    if (p) {
        LastComponent = wcsrchr(p,L'\\');
    } else {
        return STATUS_NO_MEMORY;
    }

    if (LastComponent) {
        *LastComponent++ = 0;
    }
    
    DirectoryPart = SpMemAlloc((wcslen(p)+2)*sizeof(WCHAR));
    wcscpy(DirectoryPart,p);
    wcscat(DirectoryPart,L"\\");
    INIT_OBJA(&Obja,&UnicodeString,p);

    if (LastComponent) {
        LastComponent[-1] = L'\\';
    }
    
    UnicodeString.Length += sizeof(WCHAR);

    Status = ZwOpenFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(p);
        SpMemFree(DirectoryPart);
        return(Status);
    }

    RtlInitUnicodeString(&UnicodeString,LastComponent);

    //
    // The following code is adapted from the implementation for
    // the FindFirstFile Win32 API, and provides additional DOS-like
    // wildcard matching semantics.
    //
    // Special case *.* to * since it is so common. Otherwise transmogrify
    // the input name according to the following rules:
    //
    // - Change all ? to DOS_QM
    // - Change all . followed by ? or * to DOS_DOT
    // - Change all * followed by a . into DOS_STAR
    //
    // These transmogrifications are all done in place.
    //
    if(!wcscmp(LastComponent,L"*.*")) {

        UnicodeString.Length = sizeof(WCHAR);       // trim down to just *

    } else {

        for(u=0, NameChar=UnicodeString.Buffer;
            u < (UnicodeString.Length/sizeof(WCHAR));
            u++, NameChar++) {

            if(u && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar-1) = DOS_STAR;
            }

            if((*NameChar == L'?') || (*NameChar == L'*')) {

                if(*NameChar == L'?') {
                    *NameChar = DOS_QM;
                }

                if(u && (*(NameChar-1) == L'.')) {
                    *(NameChar-1) = DOS_DOT;
                }
            }
        }

        if(EndsInDot && (*(NameChar - 1) == L'*')) {
            *(NameChar-1) = DOS_STAR;
        }
    }
       
    //
    // Finally, iterate the directory.
    //

    #define DIRINFO_BUFFER_SIZE ((2*MAX_PATH) + sizeof(FILE_BOTH_DIR_INFORMATION))
    DirectoryInfo = SpMemAlloc(DIRINFO_BUFFER_SIZE);

    b = TRUE;

    while(TRUE) {
        Status = ZwQueryDirectoryFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    DIRINFO_BUFFER_SIZE,
                    FileBothDirectoryInformation,
                    TRUE,
                    &UnicodeString,
                    b
                    );

        b = FALSE;

        //
        // Check termination condition
        //
        if(Status == STATUS_NO_MORE_FILES) {
            Status = STATUS_SUCCESS;
            break;
        }

        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // OK, nul-terminate filename and pass info to callback.
        //
        DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(WCHAR)] = 0;
        if(!Callback(DirectoryPart,DirectoryInfo,&Status,CallerData)) {
            break;
        }
    }

    ZwClose(Handle);
    SpMemFree(DirectoryPart);
    SpMemFree(DirectoryInfo);
    SpMemFree(p);
    return(Status);
}


VOID
RcFormat64BitIntForOutput(
    IN  LONGLONG n,
    OUT LPWSTR   Output,
    IN  BOOLEAN  RightJustify
    )
{
    WCHAR *p;
    LONGLONG d;
    BOOLEAN b;
    WCHAR c;

    //
    // Max signed 64-bit integer is 9223372036854775807 (19 digits).
    // The result will be space padded to the left so it's right-justified
    // if that flag is set. Otherwise it's just a plain 0-terminated string.
    //
    p = Output;
    d = 1000000000000000000i64;
    b = FALSE;
    do {
        c = (WCHAR)((n / d) % 10) + L'0';
        if(c == L'0') {
            if(!b && (d != 1)) {
                c = RightJustify ? L' ' : 0;
            }
        } else {
            b = TRUE;
        }
        if(c) {
            *p++ = c;
        }
    } while(d /= 10);
    *p = 0;
}

//
// This time conversion APIs should be moved to setupdd.sys 
// if more modules need this
//
NTSTATUS
SpSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    )
{
    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // LocalTime = SystemTime - TimeZoneBias
    //
    LocalTime->QuadPart = SystemTime->QuadPart - 
                TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}

//
// This time conversion APIs should be moved to setupdd.sys 
// if more modules need this
//
NTSTATUS
SpLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    )
{

    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // SystemTime = LocalTime + TimeZoneBias
    //
    SystemTime->QuadPart = LocalTime->QuadPart + 
                TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\copy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module implements the file copy command.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN NoCopyPrompt;
BOOLEAN AllowRemovableMedia;



NTSTATUS
pRcGetDeviceInfo(
    IN PWSTR FileName,      // must be an nt name
    IN PFILE_FS_DEVICE_INFORMATION DeviceInfo
    )
{
    BOOLEAN Removable = FALSE;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    PWSTR DeviceName;
    PWSTR s;


    //
    // get the device name from the file name
    //

    DeviceName = SpDupStringW( FileName );
    if (DeviceName == NULL) {
        return STATUS_OBJECT_PATH_INVALID;
    }

    s = wcschr(DeviceName+1,L'\\');
    if (!s) {
        return STATUS_OBJECT_PATH_INVALID;
    }
    s = wcschr(s+1,L'\\');
    if (s) {
        *s = 0;
    }

    INIT_OBJA(&Obja,&UnicodeString,DeviceName);

    Status = ZwCreateFile(
        &Handle,
        FILE_GENERIC_READ | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );
        
    SpMemFree(DeviceName);
    
    if(NT_SUCCESS(Status)) {
        Status = ZwQueryVolumeInformationFile(
            Handle,
            &IoStatusBlock,
            DeviceInfo,
            sizeof(FILE_FS_DEVICE_INFORMATION),
            FileFsDeviceInformation
            );
        ZwClose(Handle);
    }

    return Status;
}


NTSTATUS
RcIsFileOnRemovableMedia(
    IN PWSTR FileName,      // must be an nt name
    OUT PBOOLEAN Result
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    *Result = NT_SUCCESS(Status) && (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA) != 0;
    return Status;
}


NTSTATUS
RcIsFileOnCDROM(
    IN PWSTR FileName      // must be an nt name
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;


    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if (DeviceInfo.DeviceType != FILE_DEVICE_CD_ROM) {
            Status = STATUS_NO_MEDIA;
        }
    }
    return Status;
}


NTSTATUS
RcIsFileOnFloppy(
    IN PWSTR FileName      // must be an nt name
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;


    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if ((DeviceInfo.Characteristics & FILE_FLOPPY_DISKETTE) == 0) {
            Status = STATUS_NO_MEDIA;
        }
    }
    return Status;
}


BOOLEAN
RcGetNTFileName(
    IN LPCWSTR DosPath,
    IN LPCWSTR NTPath
    )
{
    BOOLEAN bResult = FALSE;
    extern LPWSTR _NtDrivePrefixes[26];
    WCHAR TempBuf[MAX_PATH*2];
    ULONG len;
    ULONG len2;
    LPWSTR Prefix;
    PWSTR s = NULL;

    Prefix = _NtDrivePrefixes[RcToUpper(DosPath[0])-L'A'];

    if (!Prefix) {
        return bResult;
    }

    GetDriveLetterLinkTarget((PWSTR)Prefix, &s);

    if (s) {
        len = wcslen(s);
        len2 = wcslen(DosPath) - 2;

        if (((len + len2) * sizeof(WCHAR)) < sizeof(TempBuf)){
            RtlZeroMemory(TempBuf,sizeof(TempBuf));
            RtlCopyMemory(TempBuf+len,DosPath+2,len2*sizeof(WCHAR));
            RtlCopyMemory(TempBuf,s,len*sizeof(WCHAR));

            TempBuf[len+len2] = 0;

            wcscpy((PWSTR)NTPath,TempBuf);
            bResult = TRUE;
        }
    }        

    return bResult;
}


ULONG
RcCmdCopy(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPWSTR SrcFile;
    LPWSTR DstFile;
    LPWSTR SrcDosPath = NULL;
    LPWSTR SrcNtPath = NULL;
    LPWSTR DstDosPath = NULL;
    LPWSTR DstNtPath = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LPWSTR YesNo;
    WCHAR Text[3];
    LPWSTR s;
    ULONG FileCount = 0;
    IO_STATUS_BLOCK  status_block;
    FILE_BASIC_INFORMATION fileInfo;
    WCHAR * pos;
    ULONG CopyFlags = COPY_NOVERSIONCHECK;
    BOOLEAN OnRemovableMedia;


    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_COPY_HELP )) {
        return 1;
    }

    //
    // create a good source & destination file name
    //
    if( TokenizedLine->TokenCount == 2 ) {
        SrcFile = TokenizedLine->Tokens->Next->String;
        DstFile = NULL;
    } else {
        SrcFile = TokenizedLine->Tokens->Next->String;
        DstFile = TokenizedLine->Tokens->Next->Next->String;
    }

    if (RcDoesPathHaveWildCards(SrcFile)) {
        RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
        goto exit;
    }
    //
    // Canonicalize the name once to get a full DOS-style path
    // we can print out, and another time to get the NT-style path
    // we'll use to actually do the work.
    //
    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    SrcDosPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    SrcNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    //
    // see if the source file exists
    //
    INIT_OBJA( &Obja, &UnicodeString, SrcNtPath );

    Status = ZwOpenFile(
                       &Handle,
                       FILE_READ_ATTRIBUTES,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       0
                       );

    if( NT_SUCCESS(Status) ) {
        // check to see if the destination is a directory
        Status = ZwQueryInformationFile( Handle,
                                         &status_block,
                                         (PVOID)&fileInfo,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         FileBasicInformation );

        ZwClose( Handle );

        if( !NT_SUCCESS(Status) ) {
            // something went wrong
            RcNtError( Status, MSG_CANT_COPY_FILE );
            goto exit;
        }

        if( fileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
            goto exit;
        }
    } else {
        RcMessageOut(MSG_FILE_NOT_FOUND2);
        goto exit;
    }

    //
    // create a destination file name when the user did not
    // provide one.  we use the source base file name and
    // the current drive and directory.
    //
    if ((DstFile == NULL) ||
        (wcscmp(DstFile, L".") == 0)) {
        s = wcsrchr( SrcDosPath, L'\\' );
        if( s ) {
            RcGetCurrentDriveAndDir( _CmdConsBlock->TemporaryBuffer );
            SpConcatenatePaths( _CmdConsBlock->TemporaryBuffer, s );
            DstFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );
        } else {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }
    }

    //
    // create the destination paths
    //
    if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,FALSE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    DstDosPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    //
    // check for removable media
    //
    Status = RcIsFileOnRemovableMedia(DstNtPath, &OnRemovableMedia);

    if (AllowRemovableMedia == FALSE && (!NT_SUCCESS(Status) || OnRemovableMedia)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    //
    // see if the destination file already exists
    //
    INIT_OBJA( &Obja, &UnicodeString, DstNtPath );

    Status = ZwOpenFile(
                       &Handle,
                       FILE_READ_ATTRIBUTES,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       0
                       );

    if( NT_SUCCESS(Status) ) {
        // the file exists!

        // check to see if the destination is a directory
        Status = ZwQueryInformationFile( Handle,
                                         &status_block,
                                         (PVOID)&fileInfo,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         FileBasicInformation );

        ZwClose( Handle );

        if( !NT_SUCCESS(Status) ) {
            // something went wrong
            RcNtError( Status, MSG_CANT_COPY_FILE );
            goto exit;
        }


        if( fileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            // yep, it's a directory

            // take the fully qualified source file path
            // and get the file name from it by finding the
            // last occurance of the \\ character
            pos = wcsrchr( SrcNtPath, L'\\' );

            SpMemFree( (PVOID)DstNtPath );

            // append the file name to the directory so that the copy
            // will work properly.

            if( pos != NULL ) {
                wcscat( _CmdConsBlock->TemporaryBuffer, pos );
            } else {
                wcscat( _CmdConsBlock->TemporaryBuffer, SrcNtPath );
            }

            DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

            // now check again for the file's existence
            INIT_OBJA( &Obja, &UnicodeString, DstNtPath );

            Status = ZwOpenFile(
                               &Handle,
                               FILE_READ_ATTRIBUTES,
                               &Obja,
                               &IoStatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               0
                               );

            if( NT_SUCCESS(Status) ) {
                ZwClose( Handle );
                //
                // Fetch yes/no text
                //
                if (InBatchMode == FALSE && NoCopyPrompt == FALSE) {
                    YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                    if( YesNo ) {
                        s = wcsrchr( DstNtPath, L'\\' );
                        RcMessageOut( MSG_COPY_OVERWRITE, s ? s+1 : DstNtPath );
                        if( RcLineIn( Text, 2 ) ) {
                            if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                                goto exit;
                            }
                        } else {
                            goto exit;
                        }
                        SpMemFree( YesNo );
                    }
                }
            }
        } else {
            //
            // If destination file was not compressed, copy it uncompressed.
            //
            
            if(!(fileInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)) {
                CopyFlags |= COPY_FORCENOCOMP;
            }
            
            // nope the dest wasn't a dir, ask if we should overwrite

            //
            // Fetch yes/no text
            //
            if (InBatchMode == FALSE && NoCopyPrompt == FALSE) {
                YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                if( YesNo ) {
                    s = wcsrchr( DstNtPath, L'\\' );
                    RcMessageOut( MSG_COPY_OVERWRITE, s ? s+1 : DstNtPath );
                    if( RcLineIn( Text, 2 ) ) {
                        if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                            goto exit;
                        }
                    } else {
                        goto exit;
                    }
                    SpMemFree( YesNo );
                }
            }
        }
    }

    Status = SpCopyFileUsingNames( SrcNtPath, DstNtPath, 0, CopyFlags );
    if( NT_SUCCESS(Status) ) {
        FileCount += 1;
    } else {
        RcNtError( Status, MSG_CANT_COPY_FILE );
    }

    if( FileCount ) {
        RcMessageOut( MSG_COPY_COUNT, FileCount );
    }

exit:
    if( DstFile && TokenizedLine->TokenCount == 2 ) {
        SpMemFree( DstFile );
    }
    if( SrcDosPath ) {
        SpMemFree( SrcDosPath );
    }
    if( SrcNtPath ) {
        SpMemFree( SrcNtPath );
    }
    if( DstDosPath ) {
        SpMemFree( DstDosPath );
    }
    if( DstNtPath ) {
        SpMemFree( DstNtPath );
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\cmdcons.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmdcons.h

Abstract:

    This is the main include file for the command console.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include <spprecmp.h>
#include <spcmdcon.h>
#include "msg1.h"



#define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

//
// Define maximum line length, which is the number of Unicode chars
// we will allow the user to type on a single line of input.
//
#define RC_MAX_LINE_LEN 500


//
// Variables and other stuff from setupdd.sys, passed to us
// in CommandConsole().
//
extern PCMDCON_BLOCK _CmdConsBlock;

//
// Base address where driver is loaded. Used to get messages
// from resources.
//
extern PVOID ImageBase;

//
// indicates we're running in batch mode
//
extern ULONG InBatchMode;
extern HANDLE OutputFileHandle;
extern BOOLEAN RedirectToNULL;
extern LARGE_INTEGER OutputFileOffset;

extern WCHAR _CurDrive;
extern LPWSTR _CurDirs[26];

//
// flags to override security
//
extern BOOLEAN AllowWildCards;
extern BOOLEAN AllowAllPaths;
extern BOOLEAN NoCopyPrompt;
extern BOOLEAN AllowRemovableMedia;


//
// Console routines.
//
VOID
RcConsoleInit(
    VOID
    );

VOID
RcConsoleTerminate(
    VOID
    );


#define RcLineIn(_b,_m) _RcLineIn(_b,_m,FALSE,FALSE)
#define RcLineInDefault(_b,_m) _RcLineIn(_b,_m,FALSE,TRUE)
#define RcPasswordIn(_b,_m) _RcLineIn(_b,_m,TRUE,FALSE)

unsigned
_RcLineIn(
    OUT PWCHAR   Buffer,
    IN  unsigned MaxLineLen,
    IN  BOOLEAN  PasswordProtect,
    IN BOOLEAN UseBuffer
    );

BOOLEAN
RcRawTextOut(
    IN LPCWSTR Text,
    IN LONG    Length
    );

BOOLEAN
RcTextOut(
    IN LPCWSTR Text
    );

VOID
pRcEnableMoreMode(
    VOID
    );

VOID
pRcDisableMoreMode(
    VOID
    );


//
// Message resource manipulation.
//

VOID
vRcMessageOut(
    IN ULONG    MessageId,
    IN va_list *arglist
    );

VOID
RcMessageOut(
    IN ULONG MessageId,
    ...
    );

VOID
RcNtError(
    IN NTSTATUS Status,
    IN ULONG    FallbackMessageId,
    ...
    );

ULONG
RcFormatDateTime(
    IN  PLARGE_INTEGER Time,
    OUT LPWSTR         Output
    );

//
// Current directory stuff.
//
VOID
RcInitializeCurrentDirectories(
    VOID
    );

VOID
RcTerminateCurrentDirectories(
    VOID
    );

VOID
RcAddDrive(
    WCHAR DriveLetter
    );

VOID
RcRemoveDrive(
    WCHAR DriveLetter
    );

BOOLEAN
RcFormFullPath(
    IN  LPCWSTR PartialPath,
    OUT LPWSTR  FullPath,
    IN  BOOLEAN NtPath
    );

BOOLEAN
RcIsPathNameAllowed(
    IN LPCWSTR FullPath,
    IN BOOLEAN RemovableMediaOk,
    IN BOOLEAN Mkdir
    );

BOOLEAN
RcGetNTFileName(
    IN LPCWSTR DosPath,
    IN LPCWSTR NTPath
    );

NTSTATUS
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    );

VOID
RcGetCurrentDriveAndDir(
    OUT LPWSTR Output
    );

WCHAR
RcGetCurrentDriveLetter(
    VOID
    );

BOOLEAN
RcIsDriveApparentlyValid(
    IN WCHAR DriveLetter
    );

NTSTATUS
pRcGetDeviceInfo(
    IN PWSTR FileName,      // must be an nt name
    IN PFILE_FS_DEVICE_INFORMATION DeviceInfo
    );

//
// Line parsing/tokenizing stuff.
//
typedef struct _LINE_TOKEN {
    struct _LINE_TOKEN *Next;
    LPWSTR String;
} LINE_TOKEN, *PLINE_TOKEN;

typedef struct _TOKENIZED_LINE {
    //
    // Total number of tokens.
    //
    unsigned TokenCount;

    PLINE_TOKEN Tokens;

} TOKENIZED_LINE, *PTOKENIZED_LINE;

PTOKENIZED_LINE
RcTokenizeLine(
    IN LPWSTR Line
    );

VOID
RcFreeTokenizedLine(
    IN OUT PTOKENIZED_LINE *TokenizedLine
    );


//
// Command dispatching.
//

typedef
ULONG
(*PRC_CMD_ROUTINE) (
    IN PTOKENIZED_LINE TokenizedLine
    );


typedef struct _RC_CMD {
    //
    // Name of command.
    //
    LPCWSTR Name;

    //
    // Routine that carries out the command.
    //
    PRC_CMD_ROUTINE Routine;

    //
    // Arg counts. Mandatory arg count specifies the minimum number
    // of args that MUST be present (not including the command itself).
    // MaximumArgCount specifies the maximum number that are allowed
    // to be present. -1 means any number are allowed, and the command
    // itself validates the arg count.
    //
    unsigned MinimumArgCount;
    unsigned MaximumArgCount;
    unsigned Hidden;
    BOOLEAN  Enabled;

} RC_CMD, *PRC_CMD;

ULONG
RcDispatchCommand(
    IN PTOKENIZED_LINE TokenizedLine
    );

BOOLEAN
RcDisableCommand(
    IN PRC_CMD_ROUTINE  CmdToDisable
    );
    

//
// Chartype stuff.
//
// Be careful when using these as they evaluate their arg more than once.
//
#define RcIsUpper(c)        (((c) >= L'A') && ((c) <= L'Z'))
#define RcIsLower(c)        (((c) >= L'a') && ((c) <= L'z'))
#define RcIsAlpha(c)        (RcIsUpper(c) || RcIsLower(c))
#define RcIsSpace(c)        (((c) == L' ') || (((c) >= L'\t') && ((c) <= L'\r')))
#define RcToUpper(c)        ((WCHAR)(RcIsLower(c) ? ((c)-(L'a'-L'A')) : (c)))

#define DEBUG_PRINTF( x ) KdPrint( x );
//define DEBUG_PRINTF( x )

typedef enum {
    RcUnknown, RcFAT, RcFAT32, RcNTFS, RcCDFS
} RcFileSystemType;

//
// Miscellaneous routines.
//
typedef
BOOLEAN
(*PENUMFILESCB) (
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PVOID                       CallerContext
    );

NTSTATUS
RcEnumerateFiles(
    IN LPCWSTR      OriginalPathSpec,
    IN LPCWSTR      FullyQualifiedPathSpec,
    IN PENUMFILESCB Callback,
    IN PVOID        CallerData
    );

VOID
RcFormat64BitIntForOutput(
    IN  LONGLONG n,
    OUT LPWSTR   Output,
    IN  BOOLEAN  RightJustify
    );

// implemented in mbr.c
NTSTATUS
RcReadDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    );

NTSTATUS
RcWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    );

//
// Set command helper routines
//
VOID
RcSetSETCommandStatus(
    BOOLEAN bEnabled
    );

BOOLEAN
RcGetSETCommandStatus(
    VOID
    );    
//
// Top-level routines for commands.
//
ULONG
RcCmdSwitchDrives(
    IN WCHAR DriveLetter
    );

ULONG
RcCmdFdisk(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdChdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdType(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDelete(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdSetFlags(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRename(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRepair(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdVerifier(
    IN PTOKENIZED_LINE TokenizedLine
    );   

ULONG
RcCmdBootCfg(
    IN PTOKENIZED_LINE TokenizedLine
    );   

ULONG
RcCmdMakeDiskRaw(
    IN PTOKENIZED_LINE TokenizedLine
    );   

ULONG
pRcExecuteBatchFile(
    IN PWSTR BatchFileName,
    IN PWSTR OutputFileName,
    IN BOOLEAN Quiet
    );

ULONG
RcCmdBatch(
    IN PTOKENIZED_LINE TokenizedLine
    );

BOOLEAN
RcCmdParseHelp(
    IN PTOKENIZED_LINE TokenizedLine,
    ULONG MsgId
    );

ULONG
RcCmdMkdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRmdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdChkdsk(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFormat(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdCls(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdCopy(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdExpand(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDriveMap(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdLogon(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdEnableService(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDisableService(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFixMBR(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFixBootSect(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdSystemRoot(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdHelpHelp(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdAttrib(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdNet(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdListSvc(
    IN PTOKENIZED_LINE TokenizedLine
    );


//
// struct used to track NT installation information
//

typedef struct _NT_INSTALLATION {
    LIST_ENTRY      ListEntry;
    ULONG           InstallNumber;
    WCHAR           DriveLetter;
    WCHAR           Path[MAX_PATH];
    PDISK_REGION    Region;
    WCHAR           NtNameSelectedInstall[MAX_PATH];
} NT_INSTALLATION, *PNT_INSTALLATION;

//
// redults from a full depth first scan of NT installations
//
extern LIST_ENTRY   NtInstallsFullScan;
extern ULONG        InstallCountFullScan;

//
// The maximum directory depth we scan when searching for NT Installs
//
#define MAX_FULL_SCAN_RECURSION_DEPTH 10

//
// install that we're currently logged onto
//
extern PNT_INSTALLATION SelectedInstall;

//
// global to determine the selected NT install after login
//

extern PNT_INSTALLATION SelectedInstall;

//
// persistent data structure used for enumerating
// the directory tree while looking for NT installs
//
typedef struct _RC_SCAN_RECURSION_DATA_ {

    PDISK_REGION                NtPartitionRegion;
    ULONG                       RootDirLength;

} RC_SCAN_RECURSION_DATA, *PRC_SCAN_RECURSION_DATA;

typedef struct _RC_ALLOWED_DIRECTORY{
    BOOLEAN MustBeOnInstallDrive;
    PCWSTR Directory;
} RC_ALLOWED_DIRECTORY, * PRC_ALLOWED_DIRECTORY;


BOOL
RcScanDisksForNTInstallsEnum(
    IN PPARTITIONED_DISK    Disk,
    IN PDISK_REGION         NtPartitionRegion,
    IN ULONG_PTR            Context
    );


VOID
pRcCls(
    VOID
    );

NTSTATUS
RcIsFileOnRemovableMedia(
    IN PWSTR FileName,      // must be an nt name
    OUT PBOOLEAN Result
    );

NTSTATUS
RcIsFileOnCDROM(
    IN PWSTR FileName      // must be an nt name
    );

NTSTATUS
RcIsFileOnFloppy(
    IN PWSTR FileName      // must be an nt name
    );

void
RcPurgeHistoryBuffer(
    void
    );

BOOLEAN
RcDoesPathHaveWildCards(
    IN LPCWSTR FullPath
    );

BOOLEAN
RcOpenSystemHive(
    VOID
    );

BOOLEAN
RcCloseSystemHive(
    VOID
    );

BOOLEAN
RcIsArc(
    VOID
    );



NTSTATUS
RcIsNetworkDrive(
    IN PWSTR NtFileName
    );

NTSTATUS
RcDoNetUse(
    PWSTR Share,
    PWSTR User,
    PWSTR Password,
    PWSTR Drive
    );

NTSTATUS
RcNetUnuse(
    PWSTR Drive
    );

NTSTATUS
PutRdrInKernelMode(
    VOID
    );

VOID
FORCEINLINE
RcSecureZeroStringW(
    LPWSTR String
    )
{
    if(String != NULL) {
        volatile WCHAR* sz;
        for(sz = (volatile WCHAR*) String; sz[0] != UNICODE_NULL; *sz++ = UNICODE_NULL);
    }
}

BOOLEAN
FORCEINLINE
RcPathBeginsWith(
    LPCWSTR Path,
    LPCWSTR Begin
    )
{
    size_t Len = wcslen(Begin);
    return Len != 0 && 0 == _wcsnicmp(Path, Begin, Len) && (L'\\' == Begin[Len - 1] || L'\\' == Path[Len] || UNICODE_NULL == Path[Len]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\curdir.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    This module implements the directory commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


//
// Each entry in _CurDirs always starts and ends with a \.
//

LPWSTR _CurDirs[26];
WCHAR _CurDrive;
LPWSTR _NtDrivePrefixes[26];
BOOLEAN AllowAllPaths;


VOID
RcAddDrive(
    WCHAR DriveLetter
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    WCHAR name[20];
    HANDLE Handle;
    NTSTATUS Status;

    ASSERT(_NtDrivePrefixes[(int)(DriveLetter - L'A')] == NULL);

    swprintf(name,L"\\DosDevices\\%c:", DriveLetter);

    INIT_OBJA(&Obja, &UnicodeString, name);

    Status = ZwOpenSymbolicLinkObject(&Handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &Obja);

    if (NT_SUCCESS(Status)) {
         ZwClose(Handle);
         _NtDrivePrefixes[(int)(DriveLetter - L'A')] = SpDupStringW(name);
    }
        
}



VOID
RcRemoveDrive(
    WCHAR DriveLetter
    )
{

    ASSERT(_NtDrivePrefixes[(int)(DriveLetter - L'A')] != NULL);
    
    SpMemFree(_NtDrivePrefixes[(int)(DriveLetter - L'A')]);
    _NtDrivePrefixes[(int)(DriveLetter - L'A')] = NULL;
}



VOID
RcInitializeCurrentDirectories(
    VOID
    )
{
    unsigned i;

    RtlZeroMemory( _CurDirs, sizeof(_CurDirs) );
    RtlZeroMemory( _NtDrivePrefixes, sizeof(_NtDrivePrefixes) );

    //
    // Initially, the current directory on all drives
    // is the root.
    //
    for( i=0; i<26; i++ ) {
        _CurDirs[i] = SpDupStringW(L"\\");
    }

    //
    // Now go set up the NT drive prefixes for each drive in the system.
    // For each drive letter, we see whether it exists in the \DosDevices
    // directory as a symbolic link.
    //
    for( i=0; i<26; i++ ) {    
        RcAddDrive((WCHAR)(i+L'A'));
    }

    //
    // NOTE: need to determine this by tracking the lowest
    // valid drive letter from the loop above, taking into account
    // floppy drives.
    //
    //
    _CurDrive = L'C';

    // fixed by using the drive letter for the selected install of NT
    // this is done in  in logon.c .



    return;
}


VOID
RcTerminateCurrentDirectories(
    VOID
    )
{
    unsigned i;

    for( i=0; i<26; i++ ) {
        if( _CurDirs[i] ) {
            SpMemFree(_CurDirs[i]);
            _CurDirs[i] = NULL;
        }
        if( _NtDrivePrefixes[i] ) {
            SpMemFree(_NtDrivePrefixes[i]);
            _NtDrivePrefixes[i] = NULL;
        }
    }
}


BOOLEAN
RcFormFullPath(
    IN  LPCWSTR PartialPath,
    OUT LPWSTR  FullPath,
    IN  BOOLEAN NtPath
    )

/*++

Routine Description:

    This routine is similar to the Win32 GetFullPathName() API.
    It takes an arbitrary pathspec and converts it to a full one,
    by merging in the current drive and directory if necessary.
    The output is a fully-qualified NT pathname equivalent to
    the partial spec given.

    Processing includes all your favorite Win32isms, including
    collapsing adjacent dots and slashes, stripping trailing spaces,
    handling . and .., etc.

Arguments:

    PartialPath - supplies a (dos-style) path spec of arbitrary qualification.

    FullPath - receives the equivalent fully-qualified NT path. The caller
        must ensure that this buffer is large enough.

    NtPath - if TRUE, we want a fully canonicalized NT path. Otherwise we want
        a DOS path.

Return Value:

    FALSE if failure, indicating an invalid drive spec or syntactically
    invalid path. TRUE otherwise.

--*/

{
    unsigned len;
    unsigned len2;
    LPCWSTR Prefix;
    PDISK_REGION Region;
    WCHAR Buffer[MAX_PATH*2];

    //
    // The first thing we do is to form the fully qualified path
    // by merging in the current drive and directory, if necessary.
    //
    // Check for leading drive in the form X:.
    //
    if((wcslen(PartialPath) >= 2) && (PartialPath[1] == L':') && RcIsAlpha(PartialPath[0])) {
        //
        // Got leading drive, transfer it into the target.
        //
        FullPath[0] = PartialPath[0];
        PartialPath += 2;
    } else {
        //
        // No leading drive, use current drive.
        //
        FullPath[0] = _CurDrive;
    }

    //
    // Make sure we've got a drive we think is valid.
    //
    Prefix = _NtDrivePrefixes[RcToUpper(FullPath[0])-L'A'];
    if(!Prefix) {
        return(FALSE);
    }

    FullPath[1] = L':';
    FullPath[2] = 0;

    //
    // Now deal with the path part. If the next character in the input
    // is \ then we have a rooted path, otherwise we need to merge in
    // the current directory for the drive.
    //
    if(PartialPath[0] != L'\\') {
        wcscat(FullPath,_CurDirs[RcToUpper(FullPath[0])-L'A']);
    }

    wcscat(FullPath,PartialPath);

    //
    // Disallow ending with \ except for the root.
    //
    len = wcslen(FullPath);

    if((len > 3) && (FullPath[len-1] == L'\\')) {
        FullPath[len-1] = 0;
    }

    //
    // Now that we've done this, we need to call RtlGetFullPathName_U
    // to get full win32 naming semantics, for example, stripping
    // trailing spaces, coalescing adjacent dots, processing . and .., etc.
    // We get at that API via setupdd.sys.
    //
    if(!NT_SUCCESS(SpGetFullPathName(FullPath))) {
        return(FALSE);
    }

    len = wcslen(FullPath) * sizeof(WCHAR);
    
    //
    // check if the path is too long to be 
    // handled by our routines [MAX_PATH*2] limit
    //
    // Note : RcGetNTFileName is called irrespective of whether caller
    // requested it or not to do proper error handling at the caller.
    //
    if ((len < sizeof(Buffer)) && RcGetNTFileName(FullPath, Buffer)){       
        if (NtPath)
            wcscpy(FullPath, Buffer);
    }
    else
        return FALSE;

    return TRUE;
}


VOID
RcGetCurrentDriveAndDir(
    OUT LPWSTR Output
    )
{
    ULONG len;

    Output[0] = _CurDrive;
    Output[1] = L':';
    wcscpy(Output+2,_CurDirs[_CurDrive-L'A']);

    //
    // Strip off trailing \ except in root case.
    //
    len = wcslen(Output);
    if( (len > 3) && (Output[len-1] == L'\\') ) {
        Output[len-1] = 0;
    }
}


WCHAR
RcGetCurrentDriveLetter(
    VOID
    )
{
    return(_CurDrive);
}


BOOLEAN
RcIsDriveApparentlyValid(
    IN WCHAR DriveLetter
    )
{
    return((BOOLEAN)(_NtDrivePrefixes[RcToUpper(DriveLetter)-L'A'] != NULL));
}


ULONG
RcCmdSwitchDrives(
    IN WCHAR DriveLetter
    )
{
    //
    // If there's no NT equivalent for this drive, then we can't
    // switch to it.
    //
    if( !RcIsDriveApparentlyValid(DriveLetter) ) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // NOTE should we attempt to open the root of the drive,
    // so we can mimic cmd.exe's behavior of refusing to set
    // the current drive when say there's no floppy in the drive?
    // There's really no great reason to do this except that it might
    // be a little less confusing for the user.
    //
    // No.
    //

    _CurDrive = RcToUpper(DriveLetter);

    return 1;
}


ULONG
RcCmdChdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    unsigned u;
    WCHAR *p,*Arg;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;


    if (RcCmdParseHelp( TokenizedLine, MSG_CHDIR_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 1) {
        RcGetCurrentDriveAndDir(_CmdConsBlock->TemporaryBuffer);        
        RcRawTextOut(_CmdConsBlock->TemporaryBuffer,-1);
        return 1;
    }

    p = _CmdConsBlock->TemporaryBuffer;

    //
    // Get the argument. Special case x:, to print out the
    // current directory on that drive.
    //
    Arg = TokenizedLine->Tokens->Next->String;
    if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && (Arg[2] == 0)) {

        Arg[0] = RcToUpper(Arg[0]);
        u = Arg[0] - L'A';

        if(_NtDrivePrefixes[u] && _CurDirs[u]) {
            RcTextOut(Arg);

            //
            // Strip off the terminating \ except in root case.
            //
            wcscpy(p,_CurDirs[u]);
            u = wcslen(p);
            if((u > 1) && (p[u-1] == L'\\')) {
                p[u-1] = 0;
            }
            RcTextOut(p);
            RcTextOut(L"\r\n");

        } else {
            RcMessageOut(MSG_INVALID_DRIVE);
        }

        return 1;
    }

    //
    // Got a new directory spec. Canonicalize it to a fully qualified
    // DOS-style path. Check the drive to make sure it's legal.
    //
    if(!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if(!_NtDrivePrefixes[RcToUpper(p[0])-L'A']) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // Check the directory to make sure it exists.
    //
    if(!RcFormFullPath(Arg,p,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    INIT_OBJA(&Obja,&UnicodeString,p);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if(!NT_SUCCESS(Status)) {
        RcNtError(Status,MSG_INVALID_PATH);
        return 1;
    }

    ZwClose(Handle);

    //
    // OK, it's a valid directory on a valid drive.
    // Form a path that starts and ends with \.
    //
    if(!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(p,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    p += 2;  // skip x:
    u = wcslen(p);

    if(!u || (p[u-1] != L'\\')) {
        p[u] = L'\\';
        p[u+1] = 0;
    }

    u = RcToUpper(p[-2]) - L'A';
    if(_CurDirs[u]) {
        SpMemFree(_CurDirs[u]);
    }
    _CurDirs[u] = SpDupStringW(p);

    return 1;
}

ULONG
RcCmdSystemRoot(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG u;
    WCHAR buf[MAX_PATH];


    if (RcCmdParseHelp( TokenizedLine, MSG_SYSTEMROOT_HELP )) {
        return 1;
    }

    //
    // set the current drive to the correct one.
    //

    if (SelectedInstall == NULL) {
        return 1;
    }

    _CurDrive = SelectedInstall->DriveLetter;

    //
    // set the current dir to the correct one.
    //
    RtlZeroMemory( buf, sizeof(buf) );

    wcscat( buf, L"\\" );
    wcscat( buf, SelectedInstall->Path );
    wcscat( buf, L"\\" );

    u = RcToUpper(SelectedInstall->DriveLetter) - L'A';
    if( _CurDirs[u] ) {
        SpMemFree(_CurDirs[u]);
    }
    _CurDirs[u] = SpDupStringW( buf );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\dispatch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module implements the basic command dispatcher.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

ULONG
RcCmdDoHelp(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDoExit(
    IN PTOKENIZED_LINE TokenizedLine
    );
    
RC_CMD Commands[] =  {
                        { L"ATTRIB",            RcCmdAttrib,            1, 2, 0, TRUE  },
                        { L"BATCH",             RcCmdBatch,             1, 2, 0, TRUE  },
#if !defined(_DONT_HAVE_BOOTCFG_TESTERS_)
#if defined(_X86_)
                        { L"BOOTCFG",           RcCmdBootCfg,           0,-1, 0, TRUE  }, 
#endif
#endif                       
                        { L"CD",                RcCmdChdir,             0, 1, 0, TRUE  },
                        { L"CHDIR",             RcCmdChdir,             0, 1, 0, TRUE  },
                        { L"CHKDSK",            RcCmdChkdsk,            0,-1, 0, TRUE  },
                        { L"CLS",               RcCmdCls,               0, 1, 0, TRUE  },
                        { L"COPY",              RcCmdCopy,              1, 2, 0, TRUE  },
                        { L"DEL",               RcCmdDelete,            1, 1, 0, TRUE  },
                        { L"DELETE",            RcCmdDelete,            1, 1, 0, TRUE  },
                        { L"DIR",               RcCmdDir,               0, 1, 0, TRUE  },
                        { L"DISABLE",           RcCmdDisableService,    0,-1, 0, TRUE  },
                        { L"DISKPART",          RcCmdFdisk,             0, 3, 0, TRUE  },
                        { L"ENABLE",            RcCmdEnableService,     0,-1, 0, TRUE  },
                        { L"ERASE",             RcCmdDelete,            1, 1, 1, TRUE  },
                        { L"EXIT",              RcCmdDoExit,            0, 1, 0, TRUE  },                        
                        { L"EXPAND",            RcCmdExpand,            1,-1, 0, TRUE  },
                        { L"FIXBOOT",           RcCmdFixBootSect,       0, 1, 0, TRUE  },
                        { L"FIXMBR",            RcCmdFixMBR,            0, 1, 0, TRUE  },
                        { L"FORMAT",            RcCmdFormat,            1, 3, 0, TRUE  },
                        { L"HELP",              RcCmdDoHelp,            0, 1, 0, TRUE  },                        
                        { L"LISTSVC",           RcCmdListSvc,           0, 1, 0, TRUE  },
                        { L"LOGON",             RcCmdLogon,             0, 3, 0, TRUE  },
                        { L"MAP",               RcCmdDriveMap,          0, 1, 0, TRUE  },
                        { L"MD",                RcCmdMkdir,             1, 1, 0, TRUE  },
                        { L"MKDIR",             RcCmdMkdir,             1, 1, 0, TRUE  },
                        { L"MKDISKRAW",         RcCmdMakeDiskRaw,       1, 1, 1, TRUE  },
                        { L"MORE",              RcCmdType,              1, 1, 0, TRUE  },
                        { L"NET",               RcCmdNet,               1, 5, 0, TRUE  }, 
                        { L"RD",                RcCmdRmdir,             1, 1, 0, TRUE  },
                        { L"REN",               RcCmdRename,            1, 2, 0, TRUE  },
                        { L"RENAME",            RcCmdRename,            1, 2, 0, TRUE  },
#if 0
                        { L"REPAIR",            RcCmdRepair,            1, 5, 0, TRUE  },
#endif                        
                        { L"RMDIR",             RcCmdRmdir,             1, 1, 0, TRUE  },
                        { L"SET",               RcCmdSetFlags,          0, 3, 1, TRUE  },
                        { L"SYSTEMROOT",        RcCmdSystemRoot,        0, 1, 0, TRUE  },
                        { L"TYPE",              RcCmdType,              1, 1, 0, TRUE  },
                        { L"VERIFIER",          RcCmdVerifier,          0,-1, 1, TRUE  }, 
                        { L"/?",                RcCmdHelpHelp,          0, 1, 1, TRUE  },
                        { L"?",                 RcCmdHelpHelp,          0, 1, 1, TRUE  }
                    };

#define NUM_CMDS (sizeof(Commands)/sizeof(Commands[0]))

//
// Special case: exit and reload
//
#define EXIT_COMMAND_NAME       L"EXIT"
#define RELOAD_COMMAND_NAME     L"RELOAD"
#define HELP_COMMAND_NAME       L"HELP"

// prototype
ULONG
GetStringTokenFromLine(
    IN OUT LPWSTR *Start,
    OUT    LPWSTR  Output  OPTIONAL
    );

PTOKENIZED_LINE
RcTokenizeLine(
    IN LPWSTR Line
    )
{
    ULONG len;
    WCHAR *p,*q;
    PTOKENIZED_LINE TokenizedLine;
    PLINE_TOKEN LineToken,PrevToken;

    //
    // Strip trailing space off the command.
    //
    len = wcslen(Line);
    while(len && RcIsSpace(Line[len-1])) {
        Line[--len] = 0;
    }

    //
    // Allocate and initialize a tokenized line structure.
    //
    TokenizedLine = SpMemAlloc(sizeof(TOKENIZED_LINE));
    RtlZeroMemory(TokenizedLine,sizeof(TOKENIZED_LINE));

    //
    // Now we go into a loop of skipping leading space and parsing in
    // the actual tokens.
    //
    PrevToken = NULL;
    p = Line;
    while(*p) {
        //
        // Skip leading space. Because we trimmed off trailing space,
        // we should never hit the end of the line before finding a
        // non-space character.
        //
        while(RcIsSpace(*p)) {
            p++;
        }
        ASSERT(*p);

        //
        // Allocate a line token structure for this string.
        //
        LineToken = SpMemAlloc(sizeof(LINE_TOKEN));
        RtlZeroMemory(LineToken,sizeof(LINE_TOKEN));

        //
        // Now we've got a string. First we make one pass over it
        // to determine the length, then allocate a buffer and
        // pull out the string into it.
        //
        q = p;
        len = GetStringTokenFromLine(&q,NULL);
        LineToken->String = SpMemAlloc((len+1)*sizeof(WCHAR));
        GetStringTokenFromLine(&p,LineToken->String);

        if(PrevToken) {
            PrevToken->Next = LineToken;
        } else {
            TokenizedLine->Tokens = LineToken;
        }
        PrevToken = LineToken;

        TokenizedLine->TokenCount++;
    }

    return(TokenizedLine);
}


ULONG
GetStringTokenFromLine(
    IN OUT LPWSTR *Start,
    OUT    LPWSTR  Output  OPTIONAL
    )
{
    WCHAR *p;
    ULONG len;
    BOOLEAN InQuote;

    len = 0;
    InQuote = FALSE;
    p = *Start;

    while(*p) {

        if(RcIsSpace(*p) && !InQuote) {
            //
            // Done.
            //
            break;
        }

        if(*p == L'\"') {
            InQuote = (BOOLEAN)(!InQuote);
        } else {
            if(Output) {
                Output[len] = *p;
            }
            len++;
        }

        p++;
    }

    if(Output) {
        Output[len] = 0;
    }

    *Start = p;
    return(len);
}


VOID
RcFreeTokenizedLine(
    IN OUT PTOKENIZED_LINE *TokenizedLine
    )
{
    PTOKENIZED_LINE p;
    PLINE_TOKEN q,n;

    p = *TokenizedLine;
    *TokenizedLine = NULL;

    q = p->Tokens;
    while(q) {
        n = q->Next;

        //
        // zero out every string as there may be passwords
        //
        RcSecureZeroStringW(q->String);
        SpMemFree((PVOID)q->String);
        SpMemFree(q);
        q = n;
    }

    SpMemFree(p);
}


ULONG
RcDispatchCommand(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine for dispatching a command.

Arguments:

Return Value:

--*/

{
    unsigned i;
    unsigned count;

    ASSERT(TokenizedLine->TokenCount);
    if(!TokenizedLine->TokenCount) {
        return(1);
    }

    /*
    //
    // Special case exit right up front.
    //
    if(!_wcsicmp(TokenizedLine->Tokens->String,EXIT_COMMAND_NAME)) {
        if (TokenizedLine->TokenCount > 1) {
            RcMessageOut(MSG_EXIT_HELP);
            return(1);
        } 
        return(0);
    }
    */

    if(!_wcsicmp(TokenizedLine->Tokens->String,RELOAD_COMMAND_NAME)) {
        return(2);
    }

    /*
    if(!_wcsicmp(TokenizedLine->Tokens->String,HELP_COMMAND_NAME)) {
        if( RcCmdDoHelp(TokenizedLine) ) {
            // if we got a 1, then the user just wanted a help index
            // otherwise we want to drop down and let the regular command
            // processing path handle a /? parameter.
            return(1);
        }
    }
    */

    //
    // See whether it's a drive designation.
    //
    if(RcIsAlpha(TokenizedLine->Tokens->String[0])
    && (TokenizedLine->Tokens->String[1] == L':')
    && (TokenizedLine->Tokens->String[2] == 0)) {

        RcCmdSwitchDrives(TokenizedLine->Tokens->String[0]);
        return(1);
    }

    //
    // Attempt to locate the command in our table.
    //
    for(i=0; i<NUM_CMDS; i++) {

        if(Commands[i].Enabled && !_wcsicmp(TokenizedLine->Tokens->String,Commands[i].Name)) {
            //
            // Validate arg count.
            //
            count = TokenizedLine->TokenCount - 1;
            if((count < Commands[i].MinimumArgCount) 
            || (count > Commands[i].MaximumArgCount)) {

                RcMessageOut(MSG_SYNTAX_ERROR);
            } else {

                return Commands[i].Routine(TokenizedLine);
            }

            return(1);
        }
    }

    RcMessageOut(MSG_UNKNOWN_COMMAND);

    return(1);
}

ULONG
RcCmdDoExit(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++    

Routine Description:

    Exit command routine

Arguments:
    Tokens for the command 
    
Return Value:
    1 if some error was found or help was asked for.
    0 if we need to exit

--*/
{
    ULONG   uResult = 0;    // will exit 
    
    if (RcCmdParseHelp( TokenizedLine, MSG_EXIT_HELP )) 
        uResult = 1;    // will not exit

    return uResult; 
}


ULONG
RcCmdDoHelp(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++    

Routine Description:

    Help command routine

Arguments:
    Tokens for the command 
    
Return Value:
    1 if some error was found or help was requested. 
    When help was reqeusted for a particular command
    the dispatched command's return value with "/?" as argument for
    the command

--*/
{
    ULONG           uResult = 1;
    int             i;
    PLINE_TOKEN     Token;

    if (!RcCmdParseHelp( TokenizedLine, MSG_HELPCOMMAND_HELP )) {
        if (TokenizedLine->TokenCount == 2) {
            // we assume that the user is typing HELP <command>.
            // we simply reverse the two tokens, getting <command> HELP
            // and overwrite HELP with /? [which fits since HELP is four chars long]

            // we then return a 0, which causes the dispatcher to drop into
            // the normal command processing path

            Token = TokenizedLine->Tokens;
            TokenizedLine->Tokens = TokenizedLine->Tokens->Next;
            TokenizedLine->Tokens->Next = Token;
            Token->Next = NULL;
            wcscpy( Token->String, L"/?" );

            uResult = RcDispatchCommand( TokenizedLine );
        } else {
            pRcEnableMoreMode();
            RcMessageOut( MSG_HELPCOMMAND_HELP );
            
            for( i=0; i < NUM_CMDS; i++ ) {
                if (Commands[i].Hidden == 0) {
                    RcTextOut( Commands[i].Name );
                    RcTextOut( L"\r\n" );
                }
            }

            pRcDisableMoreMode();
        }
    }
    
    return uResult;
}

/*++

Routine Description:

    Enables or disables the SET command

    Note : we avoid using direct SET command index
    into Commands array so that if some one changes
    the Commands array this routine still works
    
Arguments:

    bEnable - BOOLEAN inidicating whether to enable or disable
              the set command

Return Value:

    None
--*/
VOID
RcSetSETCommandStatus(
    BOOLEAN     bEnabled
    )
{
    int     iIndex;
    int     cElements = sizeof(Commands) / sizeof(RC_CMD);
    WCHAR   *szSetCmdName = L"SET";

    //
    // search through the dispatch table and trun on the 
    // help flag. This flag will indicate whether the set
    // command is enabled or not
    //
    for(iIndex = 0; iIndex < cElements; iIndex++) {
        if ( !wcscmp(Commands[iIndex].Name, szSetCmdName) ) {
            Commands[iIndex].Hidden = bEnabled ? 0 : 1;

            break;
        }
    }
}

/*++

Routine Description:

    Returns the SET command status

    Note : we avoid using direct SET command index
    into Commands array so that if some one changes
    the Commands array this routine still works
    
Arguments:

    None

Return Value:

    BOOLEAN inidicating whether the SET command is
    enabled or disabled.

--*/
BOOLEAN
RcGetSETCommandStatus(
    VOID
    )
{
    BOOLEAN bEnabled = FALSE;
    int     iIndex;
    int     cElements = sizeof(Commands) / sizeof(RC_CMD);
    WCHAR   *szSetCmdName = L"SET";

    //
    // search through the dispatch table and trun on the 
    // help flag. This flag will indicate whether the set
    // command is enabled or not
    //
    for(iIndex = 0; iIndex < cElements; iIndex++) {
        if ( !wcscmp(Commands[iIndex].Name, szSetCmdName) ) {
            bEnabled = (Commands[iIndex].Hidden == 0);

            break;
        }
    }

    return bEnabled;
}


BOOLEAN
RcDisableCommand(
        IN PRC_CMD_ROUTINE      CmdToDisable
        )
/*++

Routine Description:

        Disables the specified command and hides it.
        
Arguments:

    CmdToDisable - Command Routine to disable

Return Value:

    BOOLEAN inidicating whether the command was disabled or not.

--*/
{
        ULONG   Index;
        ULONG   NumCmds;
        BOOLEAN Result = FALSE;

        if (CmdToDisable) {
                NumCmds = sizeof(Commands) / sizeof(RC_CMD);
                
                for (Index=0; Index < NumCmds; Index++) {
                        //
                        // Note : Search the whole table as there might
                        // be aliases for the same command
                        //              
                        if (CmdToDisable == Commands[Index].Routine) {
                                Commands[Index].Hidden = TRUE;
                                Commands[Index].Enabled = FALSE;
                                Result = TRUE;
                        }
                }
        }

        return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\help.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This module implements the help system.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop



BOOLEAN
RcCmdParseHelp(
    IN PTOKENIZED_LINE TokenizedLine,
    ULONG MsgId
    )
{
    BOOL            doHelp = FALSE;
    PLINE_TOKEN     Token;
    LPCWSTR         Arg;


    if (TokenizedLine == NULL || TokenizedLine->Tokens == NULL ||
        TokenizedLine->Tokens->Next == NULL)
    {
        return FALSE;
    }

    // check for help
    Token = TokenizedLine->Tokens->Next;
    while(Token) {
        Arg = Token->String;
        if ((Arg[0] == L'/' || Arg[0] == L'-') && (Arg[1] == L'?' || Arg[1] == L'h' || Arg[1] == L'H')) {
            doHelp = TRUE;
            break;
        }
        Token = Token->Next;
    }

    if (doHelp) {
        //
        // Enable more mode since the help text can be quile long sometimes
        //
        pRcEnableMoreMode();
        RcMessageOut( MsgId );
        pRcDisableMoreMode();
        return TRUE;
    }

    return FALSE;
}

ULONG
RcCmdHelpHelp(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    pRcEnableMoreMode();
    RcMessageOut( MSG_HELPCOMMAND_HELP );
    pRcDisableMoreMode();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\map.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    map.c

Abstract:

    This module implements the drive mapping command.

Author:

    Wesley Witt (wesw) 21-Oct-1998
    Ted Miller  (tedm) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


LPWSTR FsTypes[] =
{
    L"     ",
    L"NEW  ",
    L"FAT16",
    L"NTFS ",
    L"FAT32",
    L"     ",
    L"     "
};



BOOL
RcDiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR UseArcNames
    )
{
    ULONGLONG RegionSizeMB;
    WCHAR ArcName[256];

    if (!SPPT_IS_REGION_PARTITIONED(Region) ||
        (Region->ExtendedType == EPTContainerPartition)) {
        return TRUE;        
    }

    if (UseArcNames) {
        SpArcNameFromRegion(
            Region,
            ArcName,
            sizeof(ArcName),
            PartitionOrdinalCurrent,
            PrimaryArcPath
            );
    } else {
        SpNtNameFromRegion(
            Region,
            ArcName,
            sizeof(ArcName),
            PartitionOrdinalCurrent
            );
    }

    RegionSizeMB = SpPtSectorCountToMB(Disk->HardDisk, Region->SectorCount);

    RcMessageOut(
        MSG_MAP_ENTRY,
        Region->DriveLetter == 0 ? L'?' : Region->DriveLetter,
        Region->DriveLetter == 0 ? L' ' : L':',
        FsTypes[Region->Filesystem],
        (ULONG)RegionSizeMB,
        ArcName
        );

    return TRUE;
}


NTSTATUS
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    )
{
    static WCHAR        targetNameBuffer[256];

    NTSTATUS            status;
    UNICODE_STRING      sourceName;
    UNICODE_STRING      targetName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              handle;


    RtlInitUnicodeString(&sourceName, SourceNameStr);

    InitializeObjectAttributes(&oa, &sourceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenSymbolicLinkObject(&handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &oa);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory(targetNameBuffer, sizeof(targetNameBuffer));
        targetName.Buffer = targetNameBuffer;
        targetName.MaximumLength = sizeof(targetNameBuffer);

        status = ZwQuerySymbolicLinkObject(handle, &targetName, NULL);
        NtClose(handle);
    }

    if (NT_SUCCESS(status))
    {
        *LinkTarget = targetName.Buffer;
    }
    else
    {
        *LinkTarget = NULL;
    }

    return status;
}


ULONG
RcCmdDriveMap(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG i;
    LPWSTR s;
    LPWSTR p;
    WCHAR buf[128];


    if (RcCmdParseHelp( TokenizedLine, MSG_MAP_HELP )) {
        return 1;
    }

    RcTextOut( L"\r\n" );

    if (TokenizedLine->TokenCount == 2 && _wcsicmp( TokenizedLine->Tokens->Next->String, L"arc" ) == 0) {
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDiskRegionEnum, 1 );
    } else {
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDiskRegionEnum, 0 );
    }

    for (i=0; i<26; i++) {
        swprintf( buf, L"\\DosDevices\\%c:",i+L'A');
        if (RcIsFileOnCDROM(buf) == STATUS_SUCCESS ||
            RcIsFileOnFloppy(buf) == STATUS_SUCCESS
             || RcIsNetworkDrive(buf) == STATUS_SUCCESS
            )
        {
            GetDriveLetterLinkTarget( buf, &s );
            RcMessageOut( MSG_MAP_ENTRY2, buf[12], s );
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\main.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module implements the main startup code.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN
RcOpenSoftwareHive(
    VOID
    );

//
// Pointer to block of interesting values and other stuff
// passed to us by setupdd.sys.
//
PCMDCON_BLOCK _CmdConsBlock;

//
// Address where we were loaded.
//
PVOID ImageBase;


VOID
RcPrintPrompt(
    VOID
    );

ULONG
GetTimestampForDriver(
    ULONG_PTR Module
    )
{
    PIMAGE_DOS_HEADER DosHdr;
    ULONG dwTimeStamp;

    __try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}

void
FormatTime(
    ULONG TimeStamp,
    LPWSTR  TimeBuf
    )
{
    static WCHAR   mnames[] = { L"JanFebMarAprMayJunJulAugSepOctNovDec" };
    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( TimeStamp, &MyTime );
    ExSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    wcsncpy( TimeBuf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    swprintf(
        &TimeBuf[3],
        L" %02d, %04d @ %02d:%02d:%02d",
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second
        );
}


BOOLEAN
LoadNonDefaultLayout(
  IN LPCWSTR BootDevicePath,
  IN LPCWSTR DirOnBootDevice,
  IN PVOID SifHandle
  )
/*++
Routine Description:

  Loads the non-default keyboard layout at users request

Arguments:

  BootDevicePath - NT/Arc boot device path
  DirOnBootDevice - Directory on boot device (e.g. i386)
  SifHandle - Handle to txtsetup.sif

Return Value:

  TRUE, if user selected a keyboard layout and its was loaded.
  Otherwise FALSE

--*/  
{
  BOOLEAN ShowMenu = FALSE;
  ULONG KeyPressed = 0;
  LARGE_INTEGER Delay;
  LONG SecondsToDelay = 5;
  WCHAR DevicePath[MAX_PATH] = {0};  

  if (BootDevicePath) {
    wcscpy(DevicePath, BootDevicePath);
    SpStringToLower(DevicePath);

    //
    // All KBD dlls are not present on floppies
    //
    if (!wcsstr(DevicePath, L"floppy")) {
      SpInputDrain();
      SpCmdConsEnableStatusText(TRUE);
      
      Delay.HighPart = -1;
      Delay.LowPart = -10000000;  

      do {
        //
        // prompt the user
        //
        SpDisplayStatusText(SP_KBDLAYOUT_PROMPT, 
              (UCHAR)(ATT_FG_BLACK | ATT_BG_WHITE),
              SecondsToDelay);

        //
        // sleep for a second
        //
        KeDelayExecutionThread(ExGetPreviousMode(), FALSE, &Delay);
        SecondsToDelay--;            

        if (SpInputIsKeyWaiting())
            KeyPressed = SpInputGetKeypress();    
      } 
      while (SecondsToDelay && KeyPressed != ASCI_CR && KeyPressed != ASCI_ESC);    

      if (KeyPressed == ASCI_CR)
        ShowMenu = TRUE;
        
      if (!ShowMenu) {
        //
        // clear status text
        //
        SpDisplayStatusOptions(DEFAULT_ATTRIBUTE, 0);  
      } else {
        //
        // allow the user to select a particular layout dll and load it
        //
        pRcCls();
        SpSelectAndLoadLayoutDll((PWSTR)DirOnBootDevice, SifHandle, TRUE);
      }

      SpCmdConsEnableStatusText(FALSE);
    }      
  }    

  return ShowMenu;
}

ULONG
CommandConsole(
    IN PCMDCON_BLOCK CmdConsBlock
    )

/*++

Routine Description:

    Top-level entry point for the command interpreter.
    Initializes global data and then goes into the processing loop.
    When the processing loop terminates, cleans up and exits.

Arguments:

    CmdConsBlock - supplies interesting values from setupdd.sys.

Return Value:

    None.

--*/

{
    PTOKENIZED_LINE TokenizedLine;
    BOOLEAN b = FALSE;
    ULONG rVal;
    WCHAR buf[64];
    NTSTATUS Status;

    SpdInitialize();

    _CmdConsBlock = CmdConsBlock;

    //
    // Make sure temporary buffer is large enough to hold a line of input
    // from the console.
    //
    ASSERT(_CmdConsBlock->TemporaryBufferSize > ((RC_MAX_LINE_LEN+1) * sizeof(WCHAR)));

    RcConsoleInit();
    RcInitializeCurrentDirectories();  
    FormatTime( GetTimestampForDriver( (ULONG_PTR)ImageBase ), buf );
    RcMessageOut( MSG_SIGNON );        

    if (LoadNonDefaultLayout(_CmdConsBlock->BootDevicePath, 
          _CmdConsBlock->DirectoryOnBootDevice, _CmdConsBlock->SifHandle)){
      pRcCls();
      RcMessageOut( MSG_SIGNON );        
    }      

    RedirectToNULL = TRUE;
    rVal = pRcExecuteBatchFile( L"\\cmdcons\\cmdcons.txt", L"\\cmdcons\\cmdcons.log", TRUE );
    RedirectToNULL = FALSE;

    if(0 == rVal || 2 == rVal) {
        goto exit;
    }

    if (SelectedInstall == NULL) {
        if (RcCmdLogon( NULL ) == FALSE) {
            rVal = 0;
            goto exit;
        }
    }

    Status = RcIsNetworkDrive((PWSTR)(_CmdConsBlock->BootDevicePath));

    if (!NT_SUCCESS(Status)) {
        RcDisableCommand(RcCmdNet);
    }

	//
	// Disable non ARC commands
	// 
	if (RcIsArc()) {
		RcDisableCommand(RcCmdFixBootSect);
		RcDisableCommand(RcCmdFixMBR);
	}

    do {
        RcPrintPrompt();
        RcLineIn(_CmdConsBlock->TemporaryBuffer,RC_MAX_LINE_LEN);
        TokenizedLine = RcTokenizeLine(_CmdConsBlock->TemporaryBuffer);
        if(TokenizedLine->TokenCount) {
            rVal = RcDispatchCommand(TokenizedLine);
            if (rVal == 0 || rVal == 2) {
                b = FALSE;
            } else {
                b = TRUE;
            }
            RcTextOut(L"\r\n");
        } else {
            b = TRUE;
        }
        RcFreeTokenizedLine(&TokenizedLine);
    } while(b);

exit:
    SpdTerminate();
    RcTerminateCurrentDirectories();
    RcConsoleTerminate();

    return rVal == 2 ? 1 : 0;
}


VOID
RcPrintPrompt(
    VOID
    )
{
    RcGetCurrentDriveAndDir(_CmdConsBlock->TemporaryBuffer);
    wcscat(_CmdConsBlock->TemporaryBuffer,L">");
    RcRawTextOut(_CmdConsBlock->TemporaryBuffer,-1);
}


VOID
RcNtError(
    IN NTSTATUS Status,
    IN ULONG    FallbackMessageId,
    ...
    )
{
    va_list arglist;

    //
    // Some NT errors receive special treatment.
    //
    switch(Status) {

    case STATUS_NO_SUCH_FILE:
        RcMessageOut(MSG_NO_FILES);
        return;

    case STATUS_NO_MEDIA_IN_DEVICE:
        RcMessageOut(MSG_NO_MEDIA_IN_DEVICE);
        return;

    case STATUS_ACCESS_DENIED:
    case STATUS_CANNOT_DELETE:
        RcMessageOut(MSG_ACCESS_DENIED);
        return;

    case STATUS_OBJECT_NAME_COLLISION:
        va_start(arglist,FallbackMessageId);
        vRcMessageOut(MSG_ALREADY_EXISTS,&arglist);
        va_end(arglist);
        return;

    case STATUS_OBJECT_NAME_INVALID:
        RcMessageOut(MSG_INVALID_NAME);
        return;

    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_NOT_FOUND:
        RcMessageOut(MSG_FILE_NOT_FOUND);
        return;

    case STATUS_DIRECTORY_NOT_EMPTY:
        RcMessageOut(MSG_DIR_NOT_EMPTY);
        return;

    case STATUS_NOT_A_DIRECTORY:
        RcMessageOut(MSG_NOT_DIRECTORY);
        return;

    case STATUS_SHARING_VIOLATION:
        RcMessageOut(MSG_SHARING_VIOLATION);
        return;

    case STATUS_CONNECTION_IN_USE:
        RcMessageOut(MSG_CONNECTION_IN_USE);
        return;
    }

    //
    // Not a apecial case, print backup message.
    //
    va_start(arglist,FallbackMessageId);
    vRcMessageOut(FallbackMessageId,&arglist);
    va_end(arglist);
}


VOID
RcDriverUnLoad(
    IN PDRIVER_OBJECT DriverObject
    )
{
}


ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    //
    // All we do here is to call back into setupdd.sys, providing the address
    // of our main entry point, which it will call later. We also save away
    // our image base.
    //
    DriverObject->DriverUnload = RcDriverUnLoad;
    CommandConsoleInterface(CommandConsole);
    ImageBase = DriverObject->DriverStart;
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\logon.c ===
#include "cmdcons.h"
#pragma hdrstop

#include <crypt.h>
#include <recovery.h>
#include <ntsamp.h>
#include <spkbd.h>

static BOOL firstTime = TRUE;
static CONST PWSTR  gszSoftwareHiveName = L"software";
static CONST PWSTR  gszSoftwareHiveKey= L"\\registry\\machine\\xSOFTWARE";
static CONST PWSTR  gszSAMHiveName = L"sam";
static CONST PWSTR  gszSAMHiveKey = L"\\registry\\machine\\security";
static CONST PWSTR  gszSystemHiveName = L"system";
static CONST PWSTR  gszSystemHiveKey = L"\\registry\\machine\\xSYSTEM";
static CONST PWSTR  gszSecurityHiveName = L"security";
static CONST PWSTR  gszSecurityHiveKey = L"\\registry\\machine\\xSECURITY";

LIST_ENTRY          NtInstalls;
ULONG               InstallCount;
LIST_ENTRY          NtInstallsFullScan;
ULONG               InstallCountFullScan;

PNT_INSTALLATION    SelectedInstall;
LARGE_INTEGER       glBias;


#define IS_VALID_INSTALL(x)  (((x) > 0) && ((x) <= InstallCount))

typedef struct _KEY_CHECK_STRUCT {
    WCHAR       *szKeyName;
    BOOLEAN     bControlSet;
} KEY_CHECK_STRUCT;

//
// forward declarations
//
BOOLEAN 
LoginRequired(
    VOID
    );

BOOLEAN
RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    );

BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    );

BOOLEAN
RcIsValidSystemHive(
    VOID
    );    
    
BOOLEAN
IsSetCommandEnabled(
    VOID
    );
    
BOOLEAN
RcDetermineCorrectControlKey(
    OUT PULONG pCorrectKey
    );
    
LARGE_INTEGER
RcGetTimeZoneBias(
    VOID
    );

VOID
RcDestroyList(
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Entry = ListHead->Flink;

    if(Entry != NULL) {
        while(Entry != ListHead) {
            PLIST_ENTRY Next = Entry->Flink;
            SpMemFree(Entry);
            Entry = Next;
        }
    }

    InitializeListHead(ListHead);
}

BOOL
RcLogonDiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR UseArcNames
    )
{
    WCHAR               buf[MAX_PATH];
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              DirectoryHandle;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    IO_STATUS_BLOCK     IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
    } Buffer;

    UNICODE_STRING      FileName;
    LPWSTR              s;
    PNT_INSTALLATION    NtInstall;


    swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );

    INIT_OBJA( &Obja, &UnicodeString, buf );

    Status = ZwOpenFile(
        &DirectoryHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    DirectoryInfo = &Buffer.DirInfo;

    RtlInitUnicodeString( &FileName, L"*" );

    while (NT_SUCCESS(Status)) {
        Status = ZwQueryDirectoryFile(
            DirectoryHandle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            DirectoryInfo,
            sizeof(Buffer),
            FileBothDirectoryInformation,
            TRUE,
            &FileName,
            FALSE
            );
        if (NT_SUCCESS(Status) && DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );
            wcsncat( buf, DirectoryInfo->FileName, DirectoryInfo->FileNameLength/sizeof(WCHAR) );
            wcscat( buf, L"\\system32\\config" );

            if (SpFileExists(buf, TRUE)) {
                swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );
                wcsncat( buf, DirectoryInfo->FileName, DirectoryInfo->FileNameLength/sizeof(WCHAR) );
                wcscat( buf, L"\\system32\\drivers" );

                if (SpFileExists(buf, TRUE)) {
                    NtInstall = (PNT_INSTALLATION) SpMemAlloc( sizeof(NT_INSTALLATION) );
                    if (NtInstall) {

                        RtlZeroMemory( NtInstall, sizeof(NT_INSTALLATION) );

                        NtInstall->InstallNumber = ++InstallCount;
                        NtInstall->DriveLetter = Region->DriveLetter;
                        NtInstall->Region = Region;
                        wcsncpy( NtInstall->Path, DirectoryInfo->FileName, 
                                    DirectoryInfo->FileNameLength/sizeof(WCHAR) );

                        InsertTailList( &NtInstalls, &NtInstall->ListEntry );
                    }
                }                    
            }
        }
    }

    ZwClose( DirectoryHandle );

    return TRUE;
}

BOOLEAN
RcScanForNTInstallEnum(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
/*++

Routine Description:

    NOTE: this routine os of type: ENUMFILESPROC (spmisc.h)                      
                          
    This routine determines if the directory which is currently being
    enumerated is an NT install directory
    
Arguments:

    DirName     - IN: the directory in which the file to enumerate exists
    FileInfo    - IN: file attributes for the file to enumerate
    ret         - OUT: return status of this procedure
    Pointer     - IN: contains persistent recursion data
   
    
Return Value:

    A linked list of SP_DISCOVERED_NT_INSTALLS, where each structure
    refers to a discovered installation of Windows

--*/
{
    PWSTR                       FileName;
    PWSTR                       FullPath;
    PWSTR                       PartialPathName;
    BOOLEAN                     IsNtInstall;
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // Ignore non-directories
    //
    if(! (FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;    // continue processing
    }

    //
    // Build the full file or dir path
    //
    
    //
    // We have to make a copy of the directory name, because the info struct
    // we get isn't NULL-terminated.
    //
    wcsncpy(
        TemporaryBuffer,
        FileInfo->FileName,
        FileInfo->FileNameLength
        );
    (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;
    FileName = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,FileName);
    FullPath = SpDupStringW(TemporaryBuffer);

    SpMemFree(FileName);
    
    //
    // Get the recursion data
    //
    RecursionData = (PRC_SCAN_RECURSION_DATA)Pointer;

    //
    // get the directory component beyond the root directory
    //
    PartialPathName = FullPath + RecursionData->RootDirLength;
    
    ASSERT(PartialPathName < (FullPath + wcslen(FullPath)));
        
    //
    // Test if the directory is an NT install
    //
    IsNtInstall = SpIsNtInDirectory(RecursionData->NtPartitionRegion,
                                    PartialPathName
                                    );

    //
    // if we found an NT install, then add it to our linked list
    //
    if(IsNtInstall) {
        
        PNT_INSTALLATION    NtInstall;
        
        NtInstall = (PNT_INSTALLATION) SpMemAlloc( sizeof(NT_INSTALLATION) );
        if (NtInstall) {
        
            RtlZeroMemory( NtInstall, sizeof(NT_INSTALLATION) );
        
            NtInstall->InstallNumber = ++InstallCountFullScan;
            NtInstall->DriveLetter = RecursionData->NtPartitionRegion->DriveLetter;
            NtInstall->Region = RecursionData->NtPartitionRegion;
            
            //
            // Note: this PartialPathName contains the '\' at the beginning of the
            //       Path, while the FileName used in RcLogonDiskRegionEnum 
            //       does not
            //
            wcsncpy( NtInstall->Path, PartialPathName, sizeof(NtInstall->Path)/sizeof(WCHAR));
        
            InsertTailList( &NtInstallsFullScan, &NtInstall->ListEntry );
        }
    }

    SpMemFree(FullPath);
    
    return TRUE;    // continue processing
}

BOOL
RcScanDisksForNTInstallsEnum(
    IN PPARTITIONED_DISK    Disk,
    IN PDISK_REGION         NtPartitionRegion,
    IN ULONG_PTR            Context
    )
/*++

Routine Description:

    This routine launches the directory level scan for NT installs.
  
Arguments:

    Disk                - the disk we are scanning
    NtPartitionRegion   - the partition we are scanning
    Context             - the persistent recursion data
    
Return Value:

    TRUE    - continue scanning
    FALSE   - stop scanning
      
--*/
{
    ULONG                       EnumReturnData;
    ENUMFILESRESULT             EnumFilesResult; 
    PWSTR                       NtPartition;
    PWSTR                       DirName;
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // make sure this is valid partition:
    //
    //  not reserved
    //  filesystem is ntfs || fat
    //
    if (((NtPartitionRegion->Filesystem != FilesystemFat) &&
         (NtPartitionRegion->Filesystem != FilesystemFat32) &&
         (NtPartitionRegion->Filesystem != FilesystemNtfs)
         ) ||
        (NtPartitionRegion->IsReserved == 1)
        ) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcScanDisksForNTInstallsEnum: skipping filesystem type %x\r\n",
           NtPartitionRegion->Filesystem
           ));

        return TRUE;
    }

    //
    // Get our context
    //
    RecursionData = (PRC_SCAN_RECURSION_DATA)Context;

    //
    // Keep track of which partition region we are dealing with
    // so that the file enumeration routine can pass this info
    // on to SpIsNtInDirectory.
    //
    RecursionData->NtPartitionRegion = NtPartitionRegion;

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Begin searching at the root directory
    //
    wcscpy(TemporaryBuffer, NtPartition);
    SpConcatenatePaths(TemporaryBuffer, L"\\");
    DirName = SpDupStringW(TemporaryBuffer);

    //
    // get the length of the root directory string less the
    // directory separator.  This will be used to remove
    // the root dir component of the pathname when we pass
    // the dir name into SpIsNtInDirectory.  We need to do this
    // because SpIsNtInDirectory adds the root dir back in.
    //
    RecursionData->RootDirLength = wcslen(DirName) - 1;

    KdPrintEx((DPFLTR_SETUP_ID, 
       DPFLTR_INFO_LEVEL, 
       "SPCMDCON: SpScanDisksForNTInstalls: Scanning: %s\n",
       DirName
       ));

    //
    // Enumerate all the directories on the current partition
    //
    // Note: if the enumeration does not return with a status of NormalReturn,
    //       we do not stop the scanning process, rather we will contine on
    //       scanning any remaining disks/partitions.
    //
    EnumFilesResult = SpEnumFilesRecursiveLimited(
        DirName,
        RcScanForNTInstallEnum,
        MAX_FULL_SCAN_RECURSION_DEPTH,
        0,
        &EnumReturnData,
        RecursionData
        );
    if (EnumFilesResult != NormalReturn) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: SpScanDisksForNTInstalls: Enum Files returned non-normal result: %x\n",
                   EnumFilesResult
                   ));
    
    }

    //
    // we are done with instance of DirName
    //
    SpMemFree(DirName);

    return TRUE;

}

NTSTATUS
RcAuthorizePasswordLogon(
    IN PWSTR UserName,
    IN PWSTR UserPassword,
    IN PNT_INSTALLATION NtInstall
    )
{
#define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    NTSTATUS            TmpStatus;
    WCHAR               KeyName[128];
    PWSTR               Hive = NULL;
    PWSTR               HiveKey = NULL;
    PUCHAR              buffer = NULL;
    PWSTR               PartitionPath = NULL;
    HANDLE              hKeySamRoot = NULL;
    HANDLE              hKeyNames = NULL;
    HANDLE              hKeyUser = NULL;
    HANDLE              hKeySystemRoot = NULL;
    HANDLE              hKeySecurityRoot = NULL;
    ULONG               ResultLength;
    ULONG               Number;
    ULONG               Rid;
    NT_OWF_PASSWORD     NtOwfPassword;
    NT_OWF_PASSWORD     UserOwfPassword;
    ULONG               i;
    BOOLEAN             NtPasswordPresent;
    BOOLEAN             NtPasswordNonNull;    
    WCHAR               PasswordBuffer[128];
    UNICODE_STRING      BootKeyPassword;
    PUNICODE_STRING     pBootKeyPassword = NULL;
    USHORT              BootKeyType = 0;
    PWCHAR              MessageText = NULL;
    UNICODE_STRING      SysKeyFileName;
    HANDLE              SysKeyHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
    PWCHAR              FloppyPath = NULL;
    BOOLEAN             bSecurityHiveLoaded = FALSE;
    BOOLEAN             bSysHiveLoaded = FALSE;
    BOOLEAN             bSamHiveLoaded = FALSE;
    BOOLEAN             bClearScreen = FALSE;

    //
    // Allocate buffers.
    //

    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target patition.
    //

    SpNtNameFromRegion(
        NtInstall->Region,
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
    
    //
    // Load the SYSTEM hive
    //  
    bSysHiveLoaded = RcOpenSystemHive();

    if (!bSysHiveLoaded){
        //
        // Note : System hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS; 
        //RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }
            
        
    //
    // Now get a key to the root of the hive we just loaded.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");
    
    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySystemRoot,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto exit;
    }

    //
    // Load the SAM hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,NtInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"sam");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\security.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\security");

    //
    // Attempt to load the key.
    //

    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));

        //
        // Note : SAM hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS;
        //RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }
    
    bSamHiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySamRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto exit;
    }

    //
    // load the "security" hive
    //
    bSecurityHiveLoaded = RcOpenHive(gszSecurityHiveName, gszSecurityHiveKey);

    if (!bSecurityHiveLoaded) {
        KdPrint(("SETUP: Unable to load hive %ws to key %ws\n", 
                    gszSecurityHiveName, gszSecurityHiveKey));

        //
        // Note : securityy hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS;
        //RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }  

    //
    // Now get a key to the root of the security hive we just loaded.
    //
    INIT_OBJA(&Obja,&UnicodeString,gszSecurityHiveKey);

    Status = ZwOpenKey(&hKeySecurityRoot,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",gszSecurityHiveName,Status));
        goto exit;
    }
        
    if (_wcsicmp(UserName,L"administrator")==0) {

        Rid = DOMAIN_USER_RID_ADMIN;

    } else { 

        //
        // Get the key to the account data base
        //

        wcscpy(KeyName,L"SAM\\Domains\\Account\\Users\\Names\\");
        wcscat(KeyName,UserName);

        INIT_OBJA(&Obja,&UnicodeString,KeyName);
        Obja.RootDirectory = hKeySamRoot;

        Status = ZwOpenKey(&hKeyNames,KEY_READ,&Obja);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        //
        // Get the RID of the user
        //

        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = 0;
        UnicodeString.Buffer = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryValueKey(
            hKeyNames,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &ResultLength
            );
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        Rid = ((PKEY_VALUE_PARTIAL_INFORMATION)_CmdConsBlock->TemporaryBuffer)->Type;
    }

    while(TRUE){   
        Status = SamRetrieveOwfPasswordUser(
            Rid,
            hKeySecurityRoot,
            hKeySamRoot,
            hKeySystemRoot,
            pBootKeyPassword,
            BootKeyType,
            &NtOwfPassword,
            &NtPasswordPresent,
            &NtPasswordNonNull
            );
    
        if (NT_SUCCESS(Status)) {
            break;
        }
        
        if (Status == STATUS_SAM_NEED_BOOTKEY_PASSWORD) {

            RcMessageOut( MSG_LOGON_PROMPT_SYSKEY_PASSWORD );
            RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
            RcPasswordIn( PasswordBuffer, sizeof(PasswordBuffer) / sizeof(WCHAR) );
            RtlInitUnicodeString( &BootKeyPassword, PasswordBuffer );
            pBootKeyPassword = &BootKeyPassword;
            BootKeyType = SamBootKeyPassword;
        }
            
        if (Status == STATUS_SAM_NEED_BOOTKEY_FLOPPY){
            
            FloppyPath = SpDupStringW(L"\\Device\\Floppy0");

            MessageText = SpRetreiveMessageText(ImageBase,MSG_LOGON_PROMPT_SYSKEY_FLOPPY,NULL,0);

            bClearScreen = TRUE;
            
            if (!SpPromptForDisk(
                    MessageText,
                    FloppyPath,
                    L"StartKey.Key",
                    TRUE,             
                    FALSE,            
                    FALSE,            
                    NULL              
                    )){
                Status = STATUS_WRONG_PASSWORD;
                goto exit;
             }
             
             INIT_OBJA( &Obja, &SysKeyFileName, L"\\Device\\Floppy0\\StartKey.Key" );
 
             Status = ZwCreateFile(&SysKeyHandle,
                                   FILE_GENERIC_READ,
                                   &Obja,
                                   &IoStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0
                                  );

             if (NT_SUCCESS(Status))
             {
                 Status = ZwReadFile(
                            SysKeyHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            (PVOID) &PasswordBuffer[0],
                            sizeof(PasswordBuffer),
                            0,
                            NULL
                            );
                 ZwClose( SysKeyHandle );

                 if (NT_SUCCESS(Status)) {
                     BootKeyPassword.Buffer = PasswordBuffer;
                     BootKeyPassword.Length = BootKeyPassword.MaximumLength = 
                         (USHORT) IoStatusBlock.Information;
                     pBootKeyPassword = &BootKeyPassword;
                     BootKeyType = SamBootKeyDisk;
                 } else {
                     goto exit;
                 }

            } else {
                goto exit;
            }
        }

        if (!NT_SUCCESS(Status) && Status != STATUS_SAM_NEED_BOOTKEY_PASSWORD && Status != STATUS_SAM_NEED_BOOTKEY_FLOPPY) {
            goto exit;
        }
    }

    if (NtPasswordPresent && !NtPasswordNonNull && *UserPassword == 0) {
        Status = STATUS_SUCCESS;
        goto exit;
    }
    
    if (!NtPasswordPresent && *UserPassword == 0) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    RtlInitUnicodeString( &UnicodeString, UserPassword );

    Status = RtlCalculateNtOwfPassword( &UnicodeString, &UserOwfPassword );
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if (!RtlEqualNtOwfPassword( &NtOwfPassword, &UserOwfPassword )) {
        Status = STATUS_WRONG_PASSWORD;
    }

    //
    // now check to see if this user has admin rights
    //

exit:
    RtlSecureZeroMemory(PasswordBuffer, sizeof(PasswordBuffer));

    if(bClearScreen)
        pRcCls();
        
    //
    // close handles
    //
    if (hKeySamRoot)
        ZwClose(hKeySamRoot);

    if (hKeySecurityRoot)
        ZwClose(hKeySecurityRoot);

    if (hKeyNames) {
        ZwClose( hKeyNames );
    }

    if (hKeyUser) {
        ZwClose( hKeyUser );
    }

    if (hKeySystemRoot)
        ZwClose(hKeySystemRoot);

    //
    // Unload the SAM hive
    //
    if (bSamHiveLoaded) {
        TmpStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TmpStatus)) {
            KdPrint(("SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TmpStatus));
        }
    }

    //
    // unload the security hive
    //
    if (bSecurityHiveLoaded) {
        if (!RcCloseHive(gszSecurityHiveKey))
            KdPrint(("SETUP: warning: unable to unload key %ws\n",gszSecurityHiveKey));
    }            

    //
    // unload system hive
    //    
    if (bSysHiveLoaded)
        RcCloseSystemHive();

    //
    // free memory
    //

    if (Hive) {
        SpMemFree( Hive );
    }
    
    if (HiveKey) {
        SpMemFree( HiveKey );
    }
    
    if (buffer) {
        SpMemFree( buffer );
    }
    
    if (PartitionPath) {
        SpMemFree( PartitionPath );
    }
    
    if (MessageText) {
        SpMemFree( MessageText );
    }
    
    if (FloppyPath) {
        SpMemFree( FloppyPath );
    }
    
    return Status;
}


ULONG
RcCmdLogon(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    #define MAX_FAILURES 3
    NTSTATUS Status;
    PLIST_ENTRY Next;
    PNT_INSTALLATION NtInstall;
    PNT_INSTALLATION OldSelectedNtInstall = SelectedInstall;
    ULONG InstallNumber;
    WCHAR Buffer[128];
    WCHAR UserNameBuffer[128];
    WCHAR PasswordBuffer[128];
    UNICODE_STRING UnicodeString;
    ULONG FailureCount = 0;
    ULONG u;
    BOOLEAN bRegCorrupted = FALSE;


    if (RcCmdParseHelp( TokenizedLine, MSG_LOGON_HELP )) {
        return 1;
    }

    //
    // Initialize list referring to the depth first search results
    // (These will be used via RcCmdBootCfg)
    //
    RcDestroyList(&NtInstallsFullScan);
    InstallCountFullScan = 0;

    //
    // Do a SHALLOW search for NT installs by default (at cmdcons boot)
    //
    RcDestroyList(&NtInstalls);
    InstallCount = 0;
    SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcLogonDiskRegionEnum, 0 );

    if (InstallCount == 0) {
        //
        // no nt installations on the machine so let the
        // user logon anyway
        //
        SelectedInstall = NULL;
        firstTime = FALSE;
        return 1;
    }

retry:

    RcTextOut( L"\r\n" );

    Next = NtInstalls.Flink;
    while ((UINT_PTR)Next != (UINT_PTR)&NtInstalls) {
        
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
        swprintf( Buffer, L"%d: %c:\\", NtInstall->InstallNumber, NtInstall->DriveLetter );
        
        wcsncat(Buffer, NtInstall->Path, MAX_APPEND_SIZE(Buffer));
        Buffer[MAX_COPY_SIZE(Buffer)] = L'\0';
        wcsncat( Buffer, L"\r\n", MAX_APPEND_SIZE(Buffer));
        Buffer[MAX_COPY_SIZE(Buffer)] = L'\0';
            
        RcTextOut( Buffer );
    }

    RcTextOut( L"\r\n" );

    if (InBatchMode) {
        if (TokenizedLine && TokenizedLine->TokenCount >= 2) {
            RtlInitUnicodeString( &UnicodeString, TokenizedLine->Tokens->Next->String );
            RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
        } else {
            InstallNumber = 1;
        }

        if(!IS_VALID_INSTALL(InstallNumber)/* InstallNumber > InstallCount*/){
            RcMessageOut( MSG_INSTALL_SELECT_ERROR );
            return 1;   // will err out
        }        
    } else {
        if (TokenizedLine && TokenizedLine->TokenCount == 2) {
            // Note : this could have been invoked only by executing a logon command
            // at the prompt
            RtlInitUnicodeString( &UnicodeString, TokenizedLine->Tokens->Next->String );
            Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );

            KdPrint(("SPCMDCON:Loging into %lx (%ws)\n", InstallNumber, 
                        TokenizedLine->Tokens->Next->String));
                        
            if (*TokenizedLine->Tokens->Next->String < L'0' || 
                    *TokenizedLine->Tokens->Next->String > L'9' ||
                    !NT_SUCCESS(Status) || !IS_VALID_INSTALL(InstallNumber)) {
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                return 1;   // just err out for the command
            }
        } else {
            RtlZeroMemory( Buffer, sizeof(Buffer) );
            RcMessageOut( MSG_INSTALL_SELECT );
            if (!RcLineIn( Buffer, 2 )) {
                if( firstTime == TRUE ) {
                    return 0;
                } else {
                    return 1;
                }
            }
            if (*Buffer < L'0' || *Buffer > L'9') {
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                goto retry;
            }
            
            RtlInitUnicodeString( &UnicodeString, Buffer );
            Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
        
            if(!NT_SUCCESS(Status) || !IS_VALID_INSTALL(InstallNumber)){
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                goto retry;
           }
        }
    }
   
    Next = NtInstalls.Flink;
    while ((UINT_PTR)Next != (UINT_PTR)&NtInstalls) {
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
        if (NtInstall->InstallNumber == InstallNumber) {
            OldSelectedNtInstall = SelectedInstall;
            SelectedInstall = NtInstall;
            break;
        }
    }

    if (SelectedInstall == NULL) {
        if( firstTime == TRUE ) {
            return 0;
        } else {
            RcMessageOut( MSG_INSTALL_SELECT_ERROR );
            goto retry;         
        }
    }
    //
    // Save the NT name of the region we selected to logon.
    //
    SpNtNameFromRegion( SelectedInstall->Region,
                        SelectedInstall->NtNameSelectedInstall,
                        sizeof(SelectedInstall->NtNameSelectedInstall),
                        PartitionOrdinalCurrent);
 
    //
    // Note : check the SYSTEM, SAM, SECURITY hives and if corrupted then
    // allow the user to log in without asking for password 
    // so that he/she may be able correct the problem
    //
    if (RcIsValidSystemHive()) {
        if (RcOpenHive( gszSAMHiveName, gszSAMHiveKey )) {                
            RcCloseHive( gszSAMHiveKey );

            if (!RcOpenHive(gszSecurityHiveName, gszSecurityHiveKey)){
                bRegCorrupted = TRUE;
                goto success_exit;
            }

            RcCloseHive(gszSecurityHiveKey);
        } else{
            bRegCorrupted = TRUE;
            goto success_exit;
        }
    }    
    else{
        bRegCorrupted = TRUE;
        goto success_exit;
    }

    //
    // Get the bias information for displaying the file times properly
    //
    glBias = RcGetTimeZoneBias();

    KdPrint(("SPCMDCON: RcGetTimeZoneBias returned : %lx-%lx\n", 
                  glBias.HighPart, glBias.LowPart));   
    
    if (InBatchMode) {
        if (TokenizedLine && TokenizedLine->TokenCount == 3) {
            Status = RcAuthorizePasswordLogon( L"Administrator", TokenizedLine->Tokens->Next->Next->String, NtInstall );
            if(NT_SUCCESS(Status)) {
                goto success_exit;
            }
        } else {
            Status = RcAuthorizePasswordLogon( L"Administrator", L"", NtInstall );
            if(NT_SUCCESS(Status