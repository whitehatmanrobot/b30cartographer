    } // else: cluster IP address was not specified
        } // catch: anything

        // Send the last step of this status report.
        srStartingClusSvc.SendLastStep( S_OK );
    }

    TraceFuncExit();

} //*** CClusSvc::ConfigureService


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::CleanupService
//
//  Description:
//      Stop, cleanup and remove the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvc::CleanupService( void )
{
    TraceFunc( "" );

    LogMsg( "[BC] Trying to stop the Cluster Service." );

    // Stop the service.
    m_cservClusSvc.Stop(
          m_pbcaParentAction->HGetSCMHandle()
        , 5000      // wait 5 seconds between queries for status.
        , 60        // query 60 times ( 5 minutes )
        );

    //
    // Restore the cluster installation state.
    //
    if ( ClRtlSetClusterInstallState( eClusterInstallStateFilesCopied ) == FALSE )
    {
        DWORD sc = GetLastError();

        LogMsg( "[BC] Could not set the cluster installation state. Throwing an exception." );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( sc )
            , IDS_ERROR_SETTING_INSTALL_STATE
            );
    } // ClRtlSetClusterInstallState() failed.

    LogMsg( "[BC] Cleaning up Cluster Service." );

    m_cservClusSvc.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );

    //
    // KB: ozano 01-18-2002 - We need to sleep here in order to have the service cleanup take place.
    // If we don't wait for some time and the user goes back, changes the IP address and hits re-analysis, service 
    // start fails with Win32ExitCode of ERROR_SERVICE_MARKED_FOR_DELETION.
    //
    Sleep( 10000 );

    // Cleanup the local quorum directory.
    {
        DWORD           sc = ERROR_SUCCESS;
        const WCHAR *   pcszQuorumDir = m_pbcaParentAction->RStrGetLocalQuorumDirectory().PszData();

        sc = TW32( DwRemoveDirectory( pcszQuorumDir ) );
        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] The local quorum directory '%s' cannot be removed. Non-fatal error %#08x occurred.\n", pcszQuorumDir, sc );
        } // if: we could not remove the local quorum directory
    }

    TraceFuncExit();

} //*** CClusSvc::CleanupService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcreate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusNetCreate.cpp
//
//  Description:
//      Contains the definition of the CClusNetCreate class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusNetCreate.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::CClusNetCreate
//
//  Description:
//      Constructor of the CClusNetCreate class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNetCreate::CClusNetCreate(
      CBaseClusterAddNode * pbcanParentActionIn
    )
    : BaseClass( pbcanParentActionIn )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusNetCreate::CClusNetCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::~CClusNetCreate
//
//  Description:
//      Destructor of the CClusNetCreate class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNetCreate::~CClusNetCreate( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusNetCreate::~CClusNetCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::Commit
//
//  Description:
//      Create and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCreate::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {

        ConfigureService();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService( );
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusNetCreate::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::Rollback
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCreate::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup this action.
    CleanupService();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusNetCreate::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvc.h
//
//  Description:
//      Header file for CClusSvc class.
//      The CClusSvc class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//  Implementation Files:
//      CClusSvc.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvc
//
//  Description:
//      The CClusSvc class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//      This class is intended to be used as the base class for other ClusSvc
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvc : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvc(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusSvc();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Create and configure the service.
    void
        ConfigureService(
              const WCHAR *     pszClusterDomainAccountNameIn
            , const WCHAR *     pszClusterAccountPwdIn
            , const WCHAR *     pszNodeIdString
            , bool              fIsVersionCheckingDisabledIn
            , DWORD             dwClusterIpAddressIn
            );

    // Cleanup and remove the service.
    void
        CleanupService();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusSvc service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusSvc;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusSvc( const CClusSvc & );

    // Assignment operator
    const CClusSvc & operator =( const CClusSvc & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusSvc service.
    CService                m_cservClusSvc;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusSvc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvcaccountconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusSvcAccountConfig.cpp
//
//  Description:
//      Contains the definition of the CClusSvcAccountConfig class.
//
//  Maintained By:
//      David Potter    (DavidP)    30-MAR-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusSvcAccountConfig.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"

// For the net local group functions.
#include <lmaccess.h>

// For NERR_Success
#include <lmerr.h>


//////////////////////////////////////////////////////////////////////////////
// Global Variables
//////////////////////////////////////////////////////////////////////////////

// Array of the names of rights to be granted to the cluster service account.
static const WCHAR * const gs_rgpcszRightsArray[] = {
      SE_SERVICE_LOGON_NAME
    , SE_BACKUP_NAME
    , SE_RESTORE_NAME
    , SE_INCREASE_QUOTA_NAME
    , SE_INC_BASE_PRIORITY_NAME
    , SE_TCB_NAME
    };

const UINT gc_uiRightsArraySize = ARRAYSIZE( gs_rgpcszRightsArray );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::CClusSvcAccountConfig
//
//  Description:
//      Constructor of the CClusSvcAccountConfig class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcAccountConfig::CClusSvcAccountConfig(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : m_pbcanParentAction( pbcanParentActionIn )
    , m_fWasAreadyInGroup( true )
    , m_fRightsGrantSuccessful( false )
    , m_fRemoveAllRights( false )

{
    TraceFunc( "" );

    DWORD   sc = ERROR_SUCCESS;

    PSID                        psidAdministrators      = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority          = SECURITY_NT_AUTHORITY;

    DWORD           dwNameSize = 0;
    DWORD           dwDomainSize = 0;
    SID_NAME_USE    snuSidNameUse;

    // Indicate that action can be rolled back.
    SetRollbackPossible( true );

    //
    // Get the Admins SID
    //
    if ( AllocateAndInitializeSid(
              &siaNtAuthority                   // identifier authority
            , 2                                 // count of subauthorities
            , SECURITY_BUILTIN_DOMAIN_RID       // subauthority 0
            , DOMAIN_ALIAS_RID_ADMINS           // subauthority 1
            , 0                                 // subauthority 2
            , 0                                 // subauthority 3
            , 0                                 // subauthority 4
            , 0                                 // subauthority 5
            , 0                                 // subauthority 6
            , 0                                 // subauthority 7
            , &psidAdministrators               // pointer to pointer to SID
            )
         == 0
       )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x occurred trying get the BUILTIN Administrators group SID.", sc );
        goto Cleanup;
    } // if: AllocateAndInitializeSid() failed

    // Assign the allocated SID to to the member variable.
    m_ssidAdminSid.Assign( psidAdministrators );


    //
    // Look up the administrators group name and store it.
    //

    // Find out how much space is required by the name.
    if ( LookupAccountSidW(
              NULL
            , psidAdministrators
            , NULL
            , &dwNameSize
            , NULL
            , &dwDomainSize
            , &snuSidNameUse
            )
         ==  FALSE
       )
    {
        sc = GetLastError();

        if ( sc != ERROR_INSUFFICIENT_BUFFER )
        {
            TW32( sc );
            LogMsg( "[BC] Error %#08x querying for the required buffer size to get the name of the Administrators group.", sc );
            goto Cleanup;
        } // if: something else has gone wrong.
        else
        {
            // This is expected.
            sc = ERROR_SUCCESS;
        } // if: ERROR_INSUFFICIENT_BUFFER was returned.
    } // if: LookupAccountSid failed

    // Allocate memory for the admin group name and the domain name.
    m_sszAdminGroupName.Assign( new WCHAR[ dwNameSize ] );

    {
        SmartSz sszDomainName( new WCHAR[ dwDomainSize ] );

        if ( m_sszAdminGroupName.FIsEmpty() || sszDomainName.FIsEmpty() )
        {
            sc = TW32( ERROR_OUTOFMEMORY );
            goto Cleanup;
        } // if: there wasn't enough memory

        // Get the admin group name.
        if ( LookupAccountSidW(
                  NULL
                , psidAdministrators
                , m_sszAdminGroupName.PMem()
                , &dwNameSize
                , sszDomainName.PMem()
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x getting the Administrators group name.", sc );
            goto Cleanup;
        } // if: LookupAccountSid failed
    }

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to get information about the administrators group. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GET_ADMIN_GROUP_INFO );
    } // if: something went wrong.

    TraceFuncExit();

} //*** CClusSvcAccountConfig::CClusSvcAccountConfig


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::~CClusSvcAccountConfig
//
//  Description:
//      Destructor of the CClusSvcAccountConfig class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcAccountConfig::~CClusSvcAccountConfig( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusSvcAccountConfig::~CClusSvcAccountConfig


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::Commit
//
//  Description:
//      Grant the required rights to the account.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Configure the account.
        ConfigureAccount();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there
        // is no collided unwind.
        //
        try
        {
            RevertAccount();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusSvcAccountConfig::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::Rollback
//
//  Description:
//      Roll the account back to the state it was in before we tried to
//      grant it the required privileges.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Bring the account back to its original state.
    RevertAccount();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusSvcAccountConfig::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::ConfigureAccount
//
//  Description:
//      Grant the account that will be the cluster service account the requried
//      privileges.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::ConfigureAccount( void )
{
    TraceFunc( "" );

    typedef CSmartResource<
        CHandleTrait<
              PLSA_UNICODE_STRING
            , NTSTATUS
            , reinterpret_cast< NTSTATUS (*)( PLSA_UNICODE_STRING ) >( LsaFreeMemory )
            , reinterpret_cast< PLSA_UNICODE_STRING >( NULL )
            >
        >
        SmartLsaUnicodeStringPtr;

    NTSTATUS                ntStatus;
    PLSA_UNICODE_STRING     plusAccountRights = NULL;
    ULONG                   ulOriginalRightsCount = 0;
    ULONG                   rgulToBeGrantedIndex[ gc_uiRightsArraySize ];
    ULONG                   ulIndex;
    ULONG                   ulIndexInner;

    CStatusReport           srConfigAcct(
          m_pbcanParentAction->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Configuring_Cluster_Service_Account
        , 0, 1
        , IDS_TASK_CONFIG_CLUSSVC_ACCOUNT
        );


    // Send the next step of this status report.
    srConfigAcct.SendNextStep( S_OK );

    // Add the cluster service account to the local admin group.
    m_fWasAreadyInGroup = FChangeAdminGroupMembership(
          m_pbcanParentAction->PSidGetServiceAccountSID()
        , true
        );

    LogMsg( "[BC] Determining the rights that need to be granted to the cluster service account." );

    // Get the list of rights already granted to the cluster service account.
    ntStatus = LsaEnumerateAccountRights(
                          m_pbcanParentAction->HGetLSAPolicyHandle()
                        , m_pbcanParentAction->PSidGetServiceAccountSID()
                        , &plusAccountRights
                        , &ulOriginalRightsCount
                        );

    if ( ntStatus != STATUS_SUCCESS )
    {
        //
        // LSA returns this error code if the account has no rights granted or denied to it
        // locally. This is not an error as far as we are concerned.
        //
        if ( ntStatus == STATUS_OBJECT_NAME_NOT_FOUND  )
        {
            ntStatus = STATUS_SUCCESS;
            LogMsg( "[BC] The account has no locally assigned rights." );
            m_fRemoveAllRights = true;
            plusAccountRights = NULL;
            ulOriginalRightsCount = 0;
        } // if: the account does not have any rights assigned locally to it.
        else
        {
            THR( ntStatus );
            LogMsg( "[BC] Error %#08x occurred trying to enumerate the cluster service account rights. Throwing an exception.", ntStatus );

            THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
        } // else: something went wrong.
    } // if: LsaEnumerateAccountRights() failed

    // Store the account rights just enumerated in a smart pointer for automatic release.
    SmartLsaUnicodeStringPtr splusOriginalRights( plusAccountRights );

    // Initialize the count of rights to be granted.
    m_ulRightsToBeGrantedCount = 0;

    // Determine which of the rights that we are going to grant the account are already granted.
    for ( ulIndex = 0; ulIndex < gc_uiRightsArraySize; ++ulIndex )
    {
        bool fRightAlreadyGranted = false;

        for ( ulIndexInner = 0; ulIndexInner < ulOriginalRightsCount; ++ulIndexInner )
        {
            const WCHAR *   pchGrantedRight         = plusAccountRights[ ulIndexInner ].Buffer;
            USHORT          usCharCount             = plusAccountRights[ ulIndexInner ].Length / sizeof( *pchGrantedRight );
            const WCHAR *   pcszToBeGrantedRight    = gs_rgpcszRightsArray[ ulIndex ];

            // Do our own string compare since LSA_UNICODE_STRING may not be '\0' terminated.
            while ( ( usCharCount > 0 ) && ( *pcszToBeGrantedRight != L'\0' ) )
            {
                if ( *pchGrantedRight != *pcszToBeGrantedRight )
                {
                    break;
                } // if: the current characters are not the same.

                --usCharCount;
                ++pcszToBeGrantedRight;
                ++pchGrantedRight;
            } // while: there are still characters to be compared

            // The strings are equal.
            if ( ( usCharCount == 0 ) && ( *pcszToBeGrantedRight == L'\0' ) )
            {
                fRightAlreadyGranted = true;
                break;
            } // if: the strings are equal

        } // for: loop through the list of rights already granted to the account

        // Is the current right already granted.
        if ( ! fRightAlreadyGranted )
        {
            // The current right is not already granted.
            rgulToBeGrantedIndex[ m_ulRightsToBeGrantedCount ] = ulIndex;

            // One more right to be granted.
            ++m_ulRightsToBeGrantedCount;
        } // if: the current right was not already granted
    } // for: loop through the list of rights that we want to grant the account

    //
    // Create an array of LSA_UNICODE_STRINGs of right names to be granted and store it in the
    // member variable.
    //
    m_srglusRightsToBeGrantedArray.Assign( new LSA_UNICODE_STRING[ m_ulRightsToBeGrantedCount ] );

    if ( m_srglusRightsToBeGrantedArray.FIsEmpty() )
    {
        LogMsg( "[BC] A memory allocation error occurred (%d bytes) trying to grant account rights.", m_ulRightsToBeGrantedCount );
        THROW_RUNTIME_ERROR(
              E_OUTOFMEMORY
            , IDS_ERROR_ACCOUNT_RIGHTS_CONFIG
            );
    } // if: memory allocation failed.

    // Initialize the array.
    for ( ulIndex = 0; ulIndex < m_ulRightsToBeGrantedCount; ++ ulIndex )
    {
        ULONG   ulCurrentRightIndex = rgulToBeGrantedIndex[ ulIndex ];

        LogMsg( "[BC] The '%ws' right will be granted.", gs_rgpcszRightsArray[ ulCurrentRightIndex ] );

        // Add it to the list of rights to be granted.
        InitLsaString(
              const_cast< WCHAR * >( gs_rgpcszRightsArray[ ulCurrentRightIndex ] )
            , m_srglusRightsToBeGrantedArray.PMem() + ulIndex
            );

    } // for: iterate through the list of rights that need to be granted

    // Grant the rights.
    ntStatus = THR( LsaAddAccountRights(
                          m_pbcanParentAction->HGetLSAPolicyHandle()
                        , m_pbcanParentAction->PSidGetServiceAccountSID()
                        , m_srglusRightsToBeGrantedArray.PMem()
                        , m_ulRightsToBeGrantedCount
                        ) );

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to grant the cluster service account rights. Throwing an exception.", ntStatus );

        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
    } // if: LsaAddAccountRights() failed

    m_fRightsGrantSuccessful = true;

    // Send the last step of this status report.
    srConfigAcct.SendNextStep( S_OK );

    TraceFuncExit();

} //*** CClusSvcAccountConfig::ConfigureAccount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::RevertAccount
//
//  Description:
//      Bring the account back to its original state.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::RevertAccount( void )
{
    TraceFunc( "" );

    // Check if we granted any rights to the service account. If we did, revoke them.
    if ( m_fRightsGrantSuccessful )
    {
        NTSTATUS ntStatus;

        // Revoke the rights.
        ntStatus = THR( LsaRemoveAccountRights(
                              m_pbcanParentAction->HGetLSAPolicyHandle()
                            , m_pbcanParentAction->PSidGetServiceAccountSID()
                            , m_fRemoveAllRights
                            , m_srglusRightsToBeGrantedArray.PMem()
                            , m_ulRightsToBeGrantedCount
                            ) );

        if ( ntStatus != STATUS_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to remove the granted cluster service account rights. Throwing an exception.", ntStatus );

            THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
        } // if: LsaRemoveAccountRights() failed
    } // if: we granted the service account any rights.

    // Check if we added the account to the admin group. If we did, remove it.
    if ( ! m_fWasAreadyInGroup )
    {
        FChangeAdminGroupMembership( m_pbcanParentAction->PSidGetServiceAccountSID(), false );
    } // if: we added the account to the admin group.

    TraceFuncExit();

} //*** CClusSvcAccountConfig::RevertAccount



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::InitLsaString
//
//  Description:
//      Initialize a LSA_UNICODE_STRING structure
//
//  Arguments:
//      pszSourceIn
//          The string used to initialize the unicode string structure.
//
//      plusUnicodeStringOut,
//          The output unicode string structure.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::InitLsaString(
      LPWSTR pszSourceIn
    , PLSA_UNICODE_STRING plusUnicodeStringOut
    )
{
    TraceFunc( "" );

    if ( pszSourceIn == NULL )
    {
        plusUnicodeStringOut->Buffer = NULL;
        plusUnicodeStringOut->Length = 0;
        plusUnicodeStringOut->MaximumLength = 0;

    } // if: input string is NULL
    else
    {
        plusUnicodeStringOut->Buffer = pszSourceIn;
        plusUnicodeStringOut->Length = static_cast< USHORT >( wcslen( pszSourceIn ) * sizeof( *pszSourceIn ) );
        plusUnicodeStringOut->MaximumLength = static_cast< USHORT >( plusUnicodeStringOut->Length + sizeof( *pszSourceIn ) );

    } // else: input string is not NULL

    TraceFuncExit();

} //*** CClusSvcAccountConfig::InitLsaString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::FChangeAdminGroupMembership
//
//  Description:
//      Adds/removes an account to/from the administrators group.
//
//  Arguments:
//      psidAccountSidIn
//          Pointer to the SID the of account to add/remove to/from administrators
//          group.
//
//      fAddIn
//          The account is added to the administrators group if this parameter
//          is true. The account is removed from the group otherwise.
//
//  Return Value:
//      true if the accound was already present/absent in/from the group.
//      false otherwise.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
bool CClusSvcAccountConfig::FChangeAdminGroupMembership(
      PSID psidAccountSidIn
    , bool fAddIn
    )
{
    TraceFunc( "" );

    bool                        fWasAlreadyInGroup          = false;
    LOCALGROUP_MEMBERS_INFO_0   lgmiLocalGroupMemberInfo;
    NET_API_STATUS              nasStatus;

    lgmiLocalGroupMemberInfo.lgrmi0_sid = psidAccountSidIn;

    if ( fAddIn )
    {
        CStatusReport   srAddAcctToAdminGroup(
                              m_pbcanParentAction->PBcaiGetInterfacePointer()
                            , TASKID_Major_Configure_Cluster_Services
                            , TASKID_Minor_Make_Cluster_Service_Account_Admin
                            , 0, 1
                            , IDS_TASK_MAKING_CLUSSVC_ACCOUNT_ADMIN
                            );

        srAddAcctToAdminGroup.SendNextStep( S_OK );

        nasStatus = NetLocalGroupAddMembers(
                          NULL
                        , m_sszAdminGroupName.PMem()
                        , 0
                        , reinterpret_cast< LPBYTE >( &lgmiLocalGroupMemberInfo )
                        , 1
                        );

        if ( nasStatus == ERROR_MEMBER_IN_ALIAS )
        {
            LogMsg( "[BC] The account was already a member of the admin group." );
            nasStatus = NERR_Success;
            fWasAlreadyInGroup = true;
            srAddAcctToAdminGroup.SendLastStep( S_OK, IDS_TASK_CLUSSVC_ACCOUNT_ALREADY_ADMIN );
        } // if: the account was already a member of the admin group.
        else
        {
            if ( nasStatus == NERR_Success )
            {
                LogMsg( "[BC] The account has been added to the admin group." );
                srAddAcctToAdminGroup.SendLastStep( S_OK );
                fWasAlreadyInGroup = false;

            } // if: everything was ok
            else
            {
                HRESULT hr = HRESULT_FROM_WIN32( TW32( nasStatus ) );
                srAddAcctToAdminGroup.SendLastStep( hr );
                LogMsg( "[BC] Error %#08x occurred adding the cluster service account to the Administrators group.", nasStatus );
            } // else: something went wrong
        } // else: the account was not already a member of the admin group.
    } // if: the account has to be added to the admin group
    else
    {
        LogMsg( "[BC] The account needs to be removed from the administrators group." );

        nasStatus = NetLocalGroupDelMembers(
                          NULL
                        , m_sszAdminGroupName.PMem()
                        , 0
                        , reinterpret_cast< LPBYTE >( &lgmiLocalGroupMemberInfo )
                        , 1
                        );

        if ( nasStatus == ERROR_NO_SUCH_MEMBER )
        {
            LogMsg( "[BC] The account was not a member of the admin group to begin with." );
            nasStatus = NERR_Success;
            fWasAlreadyInGroup = false;
        } // if: the account was not a member of the admin group.
        else
        {
            if ( nasStatus == NERR_Success )
            {
                LogMsg( "[BC] The account has been deleted from the admin group." );
                fWasAlreadyInGroup = true;
            } // if: everything was ok
            else
            {
                TW32( nasStatus );
                LogMsg( "[BC] Error %#08x occurred removing the cluster service account from the Administrators group.", nasStatus );
            } // else: something went wrong
        } // else; the account was a member of the admin group.
    } // else: the account has to be deleted from the admin group

    if ( nasStatus != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to change membership in administrators group. Throwing an exception.", nasStatus );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( nasStatus ), IDS_ERROR_ADMIN_GROUP_ADD_REMOVE );
    } // if: something went wrong.
    else
    {
        LogMsg( "[BC] The account was successfully added/deleted to/from the group '%s'.", m_sszAdminGroupName.PMem() );
    } // else: everything was hunky-dory

    RETURN( fWasAlreadyInGroup );

} //*** CClusSvcAccountConfig::FChangeAdminGroupMembership
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCleanup.h
//
//  Description:
//      Header file for CClusSvcCleanup class.
//      The CClusSvcCleanup class is an action that cleans up the cluster service.
//
//  Implementation Files:
//      CClusSvcCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusSvc base class
#include "CClusSvc.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcCleanup
//
//  Description:
//      The CClusSvcCleanup class is an action that clean up the ClusSvc service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcCleanup : public CClusSvc
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusSvcCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusSvc service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusSvc BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusSvcCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusSvcCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusSvcCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::CClusSvcCleanup
//
//  Description:
//      Constructor of the CClusSvcCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCleanup::CClusSvcCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    TraceFunc( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

    TraceFuncExit();

} //*** CClusSvcCleanup::CClusSvcCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::~CClusSvcCleanup
//
//  Description:
//      Destructor of the CClusSvcCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCleanup::~CClusSvcCleanup( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusSvcCleanup::~CClusSvcCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::Commit
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCleanup::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the cluster service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusSvcCleanup::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::Rollback
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusSvcCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccreate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCreate.cpp
//
//  Description:
//      Contains the definition of the CClusSvcCreate class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusSvcCreate.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::CClusSvcCreate
//
//  Description:
//      Constructor of the CClusSvcCreate class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCreate::CClusSvcCreate(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : BaseClass( pbcanParentActionIn )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusSvcCreate::CClusSvcCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::~CClusSvcCreate
//
//  Description:
//      Destructor of the CClusSvcCreate class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCreate::~CClusSvcCreate( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusSvcCreate::~CClusSvcCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::Commit
//
//  Description:
//      Create and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the base parent of this action is not CBaseClusterAddNode.
//
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCreate::Commit( void )
{
    TraceFunc( "" );

    // Get the parent action pointer.
    HRESULT                 hr = S_OK;
    CBaseClusterAddNode *   pcanClusterAddNode = dynamic_cast< CBaseClusterAddNode *>( PbcaGetParent() );
    CBString                bstrPassword;

    // If the parent action of this action is not CBaseClusterForm
    if ( pcanClusterAddNode == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterAddNode." );
    } // an invalid pointer was passed in.

    hr = THR( pcanClusterAddNode->GetServiceAccountCredentials().GetPassword( &bstrPassword ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrPassword ) );
    if ( FAILED( hr ) )
    {
        THROW_EXCEPTION( hr );
    }
    
    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        CStr strAccountUserPrincipalName( pcanClusterAddNode->StrGetServiceAccountUPN() );
        
        // Create the service.
        ConfigureService(
              strAccountUserPrincipalName.PszData()
            , bstrPassword
            , pcanClusterAddNode->PszGetNodeIdString()
            , pcanClusterAddNode->FIsVersionCheckingDisabled()
            , pcanClusterAddNode->DwGetClusterIPAddress()
            );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService();

        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusSvcCreate::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::Rollback
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCreate::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusSvcCreate::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccreate.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCreate.h
//
//  Description:
//      Header file for CClusSvcCreate class.
//      The CClusSvcCreate class is an action that creates the cluster service.
//
//  Implementation Files:
//      CClusSvcCreate.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusSvc base class
#include "CClusSvc.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcCreate
//
//  Description:
//      The CClusSvcCreate class is an action that creates the ClusSvc service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcCreate : public CClusSvc
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcCreate(
          CBaseClusterAddNode * pbcanParentActionIn
        );

    // Default destructor.
    ~CClusSvcCreate();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusSvc service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusSvc BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusSvcCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cenablethreadprivilege.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CEnableThreadPrivilege.cpp
//
//  Description:
//      Contains the definition of the CEnableThreadPrivilege class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CEnableThreadPrivilege.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnableThreadPrivilege::CEnableThreadPrivilege
//
//  Description:
//      Constructor of the CEnableThreadPrivilege class. Enables the specified
//      privilege.
//
//  Arguments:
//      pcszPrivilegeNameIn
//          Name of the privilege to be enabled.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnableThreadPrivilege::CEnableThreadPrivilege( const WCHAR * pcszPrivilegeNameIn )
    : m_hThreadToken( NULL )
    , m_fPrivilegeEnabled( false )
{
    TraceFunc1( "pcszPrivilegeNameIn = '%ws'", pcszPrivilegeNameIn );

    DWORD   sc  = ERROR_SUCCESS;

    do
    {
        TOKEN_PRIVILEGES    tpPrivilege;
        DWORD               dwReturnLength  = sizeof( m_tpPreviousState );
        DWORD               dwBufferLength  = sizeof( tpPrivilege );

        // Open the current thread token.
        if ( OpenThreadToken( 
                  GetCurrentThread()
                , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
                , TRUE
                , &m_hThreadToken
                )
             == FALSE
           )
        {
            sc = GetLastError();

            // If the thread has no token, then default to the process token.
            if ( sc == ERROR_NO_TOKEN )
            {
                LogMsg( "[BC] The thread has no token. Trying to open the process token." );

                if ( OpenProcessToken(
                          GetCurrentProcess()
                        , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
                        , &m_hThreadToken
                        )
                     == FALSE
                )
                {
                    sc = TW32( GetLastError() );
                    LogMsg( "[BC] Error %#08x occurred trying to open the process token.", sc );
                    break;
                } // if: OpenProcessToken() failed.

                // The process token was opened. All is well.
                sc = ERROR_SUCCESS;

            } // if: the thread has no token
            else
            {
                TW32( sc );
                LogMsg( "[BC] Error %#08x occurred trying to open the thread token.", sc );
                break;
            } // if: some other error occurred
        } // if: OpenThreadToken() failed

        //
        // Initialize the TOKEN_PRIVILEGES structure.
        //
        tpPrivilege.PrivilegeCount = 1;

        if ( LookupPrivilegeValue( NULL, pcszPrivilegeNameIn, &tpPrivilege.Privileges[0].Luid ) == FALSE )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred trying to lookup privilege value.", sc );
            break;
        } // if: LookupPrivilegeValue() failed

        tpPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        // Enable the desired privilege.
        if ( AdjustTokenPrivileges(
                  m_hThreadToken
                , FALSE
                , &tpPrivilege
                , dwBufferLength
                , &m_tpPreviousState
                , &dwReturnLength
                )
             == FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred trying to enable the privilege.", sc );
            break;
        } // if: AdjustTokenPrivileges() failed

        Assert( dwReturnLength == sizeof( m_tpPreviousState ) ); 
        
        LogMsg( "[BC] Privilege '%ws' enabled for the current thread.", pcszPrivilegeNameIn );

        // Set a flag if the privilege was not already enabled.
        m_fPrivilegeEnabled = ( m_tpPreviousState.Privileges[0].Attributes != SE_PRIVILEGE_ENABLED );
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to enable privilege '%ws'. Throwing an exception.", sc, pcszPrivilegeNameIn );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_ENABLE_THREAD_PRIVILEGE );
    } // if:something went wrong

    TraceFuncExit();

} //*** CEnableThreadPrivilege::CEnableThreadPrivilege


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnableThreadPrivilege::~CEnableThreadPrivilege
//
//  Description:
//      Destructor of the CEnableThreadPrivilege class. Restores the specified
//      privilege to its original state.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnableThreadPrivilege::~CEnableThreadPrivilege( void ) throw()
{
    TraceFunc( "" );

    DWORD sc = ERROR_SUCCESS;

    if ( m_fPrivilegeEnabled )
    {
        if ( AdjustTokenPrivileges(
                  m_hThreadToken
                , FALSE
                , &m_tpPreviousState
                , sizeof( m_tpPreviousState )
                , NULL
                , NULL
                )
             == FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred trying to restore privilege.", sc );
        } // if: AdjustTokenPrivileges() failed
        else
        {
            LogMsg( "[BC] Privilege restored.", sc );
        } // else: no errors

    } // if: the privilege was successfully enabled in the constructor
    else
    {
        LogMsg( "[BC] Privilege was enabled to begin with. Doing nothing.", sc );
    }

    if ( m_hThreadToken != NULL )
    {
        CloseHandle( m_hThreadToken );
    } // if: the thread handle was opened

    TraceFuncExit();

} //*** CEnableThreadPrivilege::~CEnableThreadPrivilege
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvcaccountconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcAccountConfig.h
//
//  Description:
//      Header file for CClusSvcAccountConfig class.
//      The CClusSvcAccountConfig class is an action that grants 
//      the required rights to the cluster service account.
//
//  Implementation Files:
//      CClusSvcAccountConfig.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For LsaClose, LSA_HANDLE, etc.
#include <ntsecapi.h>


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////

// The parent action of this action.
class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcAccountConfig
//
//  Description:
//      The CClusSvcAccountConfigAccountConfig class is an action that grants 
//      the required rights to the cluster service account.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcAccountConfig : public CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcAccountConfig( CBaseClusterAddNode * pbcanParentActionIn );

    // Default destructor.
    ~CClusSvcAccountConfig();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Grant the required rights to the account.
    //
    void Commit();

    //
    // Revert the account to its previous state.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The notification is:
        // 1. Configuring the cluster service account
        //
        return 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CAction BaseClass;

    typedef CSmartResource< CHandleTrait< PSID, PVOID, FreeSid > > SmartSid;

    typedef CSmartGenericPtr< CArrayPtrTrait< LSA_UNICODE_STRING > > SmartLSAUnicodeStringArray;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusSvcAccountConfig( const CClusSvcAccountConfig & );

    // Assignment operator
    CClusSvcAccountConfig & operator =( const CClusSvcAccountConfig & );

    // Assign the required rights to the account.
    void
        ConfigureAccount();

    // Undo the changes made in ConfigureAccount()
    void
        RevertAccount();

    // Initialize an LSA_UNICODE_STRING structure.
    void
    InitLsaString(
          LPWSTR pszSourceIn
        , PLSA_UNICODE_STRING plusUnicodeStringOut
        );

    // Add/remove an account from the administrators account.
    bool
        FChangeAdminGroupMembership( PSID psidAccountSidIn, bool fAddIn );

    
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer the parent of this action.
    CBaseClusterAddNode *           m_pbcanParentAction;

    // SID of the administrators group.
    SmartSid                        m_ssidAdminSid;

    // Name of the administrators group.
    SmartSz                         m_sszAdminGroupName;

    // Indicates if the cluster service account was already in the admin group or not.
    bool                            m_fWasAreadyInGroup;

    // List of unicode strings containing names of rights to be granted.
    SmartLSAUnicodeStringArray      m_srglusRightsToBeGrantedArray;

    // Number of strings in the above array.
    ULONG                           m_ulRightsToBeGrantedCount;

    // Indicate if all the rights assigned to this account should be removed.
    bool                            m_fRemoveAllRights;

    // Were any rights granted to the account.
    bool                            m_fRightsGrantSuccessful;

}; //*** class CClusSvcAccountConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cimpersonateuser.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CImpersonateUser.h
//
//  Description:
//      Header file for CImpersonateUser class.
//
//      The CImpersonateUser class begins impersonating a user in its 
//      constructor and automatically reverts to the original token in
//      the destructor.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CImpersonateUser
//
//  Description:
//      The CImpersonateUser class begins impersonating a user in its 
//      constructor and automatically reverts to the original token in
//      the destructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CImpersonateUser
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Construtor. Start impersonating the user whose token is passed in.
    CImpersonateUser( HANDLE hUserToken );

    // Destructor. Revert to the original token.
    ~CImpersonateUser() throw();

private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CImpersonateUser( const CImpersonateUser & );

    // Assignment operator
    const CImpersonateUser & operator =( const CImpersonateUser & );


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////

    // Handle to the token for the thread before the impersonation began.
    HANDLE              m_hThreadToken;

    // Indicates if this thread was already impersonating a client when this
    // object was constructed.
    bool        m_fWasImpersonating;

}; //*** class CImpersonateUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cenablethreadprivilege.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnableThreadPrivilege.h
//
//  Description:
//      Header file for CEnableThreadPrivilege class.
//
//      The CEnableThreadPrivilege class enables a certain privilege for the
//      current thread in its constructor and automatically restores the
//      thread privileges in the destructor.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the TOKEN_PRIVILEGES structure.
#include <ntseapi.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnableThreadPrivilege
//
//  Description:
//      The CEnableThreadPrivilege class enables a certain privilege for the
//      current thread in its constructor and automatically restores the
//      thread privileges in the destructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnableThreadPrivilege
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Construtor. Enables the privilege
    CEnableThreadPrivilege( const WCHAR * pcszPrivilegeNameIn );

    // Destructor. Restore the original state of the privilege.
    ~CEnableThreadPrivilege() throw();

private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CEnableThreadPrivilege( const CEnableThreadPrivilege & );

    // Assignment operator
    const CEnableThreadPrivilege & operator =( const CEnableThreadPrivilege & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Previous state of this privilege.
    TOKEN_PRIVILEGES    m_tpPreviousState;

    // Handle to the token for the thread that created this object.
    HANDLE              m_hThreadToken;

    // Indicates if the privilege was successfully enabled or not.
    bool                m_fPrivilegeEnabled;

}; //*** class CEnableThreadPrivilege
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cimpersonateuser.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CImpersonateUser.cpp
//
//  Description:
//      Contains the definition of the CImpersonateUser class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CImpersonateUser.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonateUser::CImpersonateUser
//
//  Description:
//      Constructor of the CImpersonateUser class. Begins impersonating the
//      user specified by the argument.
//
//  Arguments:
//      hUserToken
//          Handle to the user account token to impersonate
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CImpersonateUser::CImpersonateUser( HANDLE hUserToken )
    : m_hThreadToken( NULL )
    , m_fWasImpersonating( false )
{
    TraceFunc1( "hUserToken = %p", hUserToken );

    DWORD sc = ERROR_SUCCESS;

    do
    {

        // Check if this thread is already impersonating a client.
        {
            if (    OpenThreadToken(
                          GetCurrentThread()
                        , TOKEN_ALL_ACCESS
                        , FALSE
                        , &m_hThreadToken
                        )
                 == FALSE
               )
            {
                sc = GetLastError();

                if ( sc == ERROR_NO_TOKEN )
                {
                    // There is no thread token, so we are not impersonating - this is ok.
                    TraceFlow( "This thread is not impersonating anyone." );
                    m_fWasImpersonating = false;
                    sc = ERROR_SUCCESS;
                } // if: there is no thread token
                else
                {
                    TW32( sc );
                    LogMsg( "[BC] Error %#08x occurred opening the thread token..", sc );
                    break;
                } // else: something really went wrong
            } // if: OpenThreadToken() failed
            else
            {
                TOKEN_TYPE  ttTokenType;
                DWORD       dwReturnLength;

                if (    GetTokenInformation(
                              m_hThreadToken
                            , TokenType
                            , &ttTokenType
                            , sizeof( ttTokenType )
                            , &dwReturnLength
                            )
                     == FALSE
                   )
                {
                    sc = TW32( GetLastError() );
                    LogMsg( "[BC] Error %#08x getting thread token information.", sc );
                    break;
                } // if: GetTokenInformation() failed
                else
                {
                    Assert( dwReturnLength == sizeof( ttTokenType ) );
                    m_fWasImpersonating = ( ttTokenType == TokenImpersonation );
                    TraceFlow1( "Is this thread impersonating anyone? %d ( 0 = No ).", m_fWasImpersonating );
                } // else: GetTokenInformation() succeeded
            } // else: OpenThreadToken() succeeded
        }


        // Try to impersonate the user.
        if ( ImpersonateLoggedOnUser( hUserToken ) == FALSE )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred impersonating the logged on user.", sc );
            break;
        } // if: ImpersonateLoggedOnUser() failed

        TraceFlow( "Impersonation succeeded." );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to impersonate a user. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_IMPERSONATE_USER );
    } // if:something went wrong

    TraceFuncExit();

} //*** CImpersonateUser::CImpersonateUser


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonateUser::~CImpersonateUser
//
//  Description:
//      Destructor of the CImpersonateUser class. Reverts to the original token.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CImpersonateUser::~CImpersonateUser( void ) throw()
{
    TraceFunc( "" );

    if ( m_fWasImpersonating )
    {
        // Try to revert to the previous impersonation.
        if ( ImpersonateLoggedOnUser( m_hThreadToken ) == FALSE )
        {
            // Something failed - nothing much we can do here
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] !!! WARNING !!! Error %#08x occurred trying to revert to previous impersonation. Cannot throw exception from destructor. Application may not run properly.", sc );

        } // if: ImpersonateLoggedOnUser() failed
        else
        {
            TraceFlow( "Successfully reverted to previous impersonation." );
        } // else: ImpersonateLoggedOnUser() succeeded    
    } // if: we were impersonating someone when we started
    else
    {
        // Try to revert to self.
        if ( RevertToSelf() == FALSE )
        {
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] !!! WARNING !!! Error %#08x occurred trying to revert to self. Cannot throw exception from destructor. Application may not run properly.", sc );

        } // if: RevertToSelf() failed
        else
        {
            TraceFlow( "Successfully reverted to self." );
        } // else: RevertToSelf() succeeded
    } // else: we weren't impersonating anyone to begin with

    TraceFuncExit();

} //*** CImpersonateUser::~CImpersonateUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cexception.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CException.h
//
//  Description:
//      This file contains the declarations of base class for all exception
//      classes.
//
//  Implementation File:
//      None.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 26-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>


//////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Shorthand for throwing different exceptions.
//

#define THROW_EXCEPTION( _hrErrorCode ) \
    throw CException( _hrErrorCode, TEXT( __FILE__ ), __LINE__ )



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CException
//
//  Description:
//      The CException is the base class for all exceptions thrown by
//      functions defined in this library.
//
//      An object of this class must have the m_hrErrorCode, m_pszFile and
//      m_uiLineNumber members initialized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CException
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pszFileNameIn
        , UINT          uiLineNumberIn
        ) throw()
        : m_hrErrorCode( hrErrorCodeIn )
        , m_pszFileName( pszFileNameIn )
        , m_uiLineNumber( uiLineNumberIn )
    {
    }

    // Copy constructor.
    CException( const CException & ceSrcIn ) throw()
        : m_hrErrorCode( ceSrcIn.m_hrErrorCode )
        , m_pszFileName( ceSrcIn.m_pszFileName )
        , m_uiLineNumber( ceSrcIn.m_uiLineNumber )
    {
    }

    // Default virtual destructor.
    virtual 
        ~CException() throw() {}


    //////////////////////////////////////////////////////////////////////////
    // Public Methods
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator.
    const CException & 
        operator =( const CException & ceSrcIn ) throw()
    {
        m_hrErrorCode = ceSrcIn.m_hrErrorCode;
        m_pszFileName = ceSrcIn.m_pszFileName;
        m_uiLineNumber = ceSrcIn.m_uiLineNumber;
        return *this;
    }

    //
    // Accessor methods.
    //
    HRESULT
        HrGetErrorCode() const throw() { return m_hrErrorCode; }

    void
        SetErrorCode( HRESULT hrNewCode ) throw() { m_hrErrorCode = hrNewCode; }

    const WCHAR *
        PszGetThrowingFile() const throw() { return m_pszFileName; }

    UINT
        UiGetThrowingLine() const throw() { return m_uiLineNumber; }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private members
    //////////////////////////////////////////////////////////////////////////

    // Default construction is not allowed.
    CException();


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    HRESULT         m_hrErrorCode;
    const WCHAR *   m_pszFileName;
    UINT            m_uiLineNumber;

}; //*** class CException
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNode.h
//
//  Description:
//      Header file for CNode class.
//      The CNode class is a base class for action classes that perform
//      configuration tasks related to the node being configured.
//
//  Implementation Files:
//      CNode.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the SmartSz typedef
#include "CommonDefs.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;
class CStr;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNode
//
//  Description:
//      The CNode class is a base class for action classes that perform
//      configuration tasks related to the node being configured.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNode : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNode( CBaseClusterAction * pbcaParentActionIn );

    // Default destructor.
    ~CNode();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Configure this node.
    void
        Configure( const CStr & rcstrClusterNameIn );

    // Clean up the changes made to this node when it joined a cluster.
    void
        Cleanup();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CNode( const CNode & );

    // Assignment operator
    const CNode & operator =( const CNode & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

    // Did we change the cluster adminstrator connections list?
    bool                    m_fChangedConnectionsList;

    // The cluster administrator connections list before we changed it.
    SmartSz                 m_sszOldConnectionsList;

}; //*** class CNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CNode.cpp
//
//  Description:
//      Contains the definition of the CNode class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CNode.h"

// For the CRegistryKey class
#include "CRegistryKey.h"

// For the CStr class
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// Names of the sections in the main INF file which deal with node configuration
// and cleanup.
#define NODE_CONFIG_INF_SECTION         L"Node_Create"
#define NODE_CLEANUP_INF_SECTION        L"Node_Cleanup"

// Registry key storing the list of connections for the cluster administrator
#define CLUADMIN_CONNECTIONS_KEY_NAME       L"Software\\Microsoft\\Cluster Administrator\\Connections"

// Name of the registry value storing the list of connections for the cluster administrator
#define CLUADMIN_CONNECTIONS_VALUE_NAME     L"Connections"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::CNode
//
//  Description:
//      Constructor of the CNode class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CNode::CNode(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_pbcaParentAction( pbcaParentActionIn )
    , m_fChangedConnectionsList( false )
{
    TraceFunc( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        LogMsg( "[BC] Pointers to the parent action is NULL. Throwing an exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CNode::CNode() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    TraceFuncExit();

} //*** CNode::CNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::~CNode
//
//  Description:
//      Destructor of the CNode class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNode::~CNode( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CNode::~CNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::Configure
//
//  Description:
//      Make the changes that need to be made when a node becomes part of a
//      cluster. 
//
//  Arguments:
//      rcstrClusterNameIn
//          Name of the cluster being configured. 
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNode::Configure( const CStr & rcstrClusterNameIn )
{
    TraceFunc( "" );

    WCHAR *         pszConnectionsValue = NULL;
    DWORD           cbConnectionsValueSize = 0;
    DWORD           cchOldListLen = 0;
    CRegistryKey    rkConnectionsKey;

    //
    // Validate the parameter
    //
    if ( rcstrClusterNameIn.FIsEmpty() )
    {
        LogMsg( "[BC] The name of the cluster is empty. Throwing an exception." );
        THROW_ASSERT( E_INVALIDARG, "The name of the cluster cannot be empty." );
    } // if: the cluster name is not valid

    LogMsg( "[BC] Attempting to make miscellaneous changes to the node." );

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                                                      // optional, handle of a parent window
        , m_pbcaParentAction->HGetMainInfFileHandle()               // handle to the INF file
        , NODE_CONFIG_INF_SECTION                                   // name of the Install section
        , SPINST_REGISTRY                                           // which lines to install from section
        , NULL                                                      // optional, key for registry installs
        , NULL                                                      // optional, path for source files
        , NULL                                                      // optional, specifies copy behavior
        , NULL                                                      // optional, specifies callback routine
        , NULL                                                      // optional, callback routine context
        , NULL                                                      // optional, device information set
        , NULL                                                      // optional, device info structure
        ) == FALSE
       )
    {
        DWORD   sc = TW32( GetLastError() );

        LogMsg( "[BC] Error %#08x returned from SetupInstallFromInfSection() while trying to make miscellaneous changes to the node. Throwing an exception.", sc );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_NODE_CONFIG );
    } // if: SetupInstallFromInfSection failed

    //
    // Add the name of the cluster that this node is a part of to the list of connections
    // that will be opened when the cluster administrator is started on this node.
    // The list of connections is a comma separated list of cluster names.
    //

    LogMsg( "[BC] Adding the cluster name '%s' to the list of cluadmin connections.", rcstrClusterNameIn.PszData() );

    // Reset the state.
    m_fChangedConnectionsList = false;
    m_sszOldConnectionsList.PRelease();

    LogMsg( "[BC] Trying to read the existing Cluster Administrator remembered connections list." );

    // Open the cluster administrator connections key. Create it if it does not exist.
    rkConnectionsKey.CreateKey(
          HKEY_CURRENT_USER
        , CLUADMIN_CONNECTIONS_KEY_NAME
        );

    try
    {
        // Try and get the current value
        rkConnectionsKey.QueryValue(
              CLUADMIN_CONNECTIONS_VALUE_NAME
            , reinterpret_cast< LPBYTE * >( &pszConnectionsValue )
            , &cbConnectionsValueSize
            );

    } // try: to read the "Connections" value
    catch( CRuntimeError & crte )
    {
        // Check if this error occurred because the value did not exist
        if ( crte.HrGetErrorCode() == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            LogMsg( "[BC] The registry value '%s' does not exist. This is ok and is not an error.", CLUADMIN_CONNECTIONS_VALUE_NAME );
            cchOldListLen = 0;
        } // if: the value does not exist
        else
        {
            throw;
        } // else: something else is wrong - rethrow the exception

    } // catch: the run time error that occurred

    // Number of characters in the old list, including the terminating NULL.
    cchOldListLen = cbConnectionsValueSize / sizeof( *pszConnectionsValue );

    if ( cchOldListLen <= 1 )
    {
        LogMsg( "[BC] There are no existing Cluster Administrator remembered connections. Creating a new list with just one name in it." );

        // Write the cluster name to the value
        rkConnectionsKey.SetValue(
              CLUADMIN_CONNECTIONS_VALUE_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( rcstrClusterNameIn.PszData() )
            , ( rcstrClusterNameIn.NGetLen() + 1 ) * sizeof( WCHAR )
            );

        // We have changed the connections list.
        m_fChangedConnectionsList = true;
    } // if: there are no existing connections
    else
    {
        WCHAR *         pszSubString = NULL;
        bool            fIsInList = false;

        LogMsg( "[BC] The existing list of Cluster Administrator remembered connections is '%s'.", pszConnectionsValue );

        //
        // Is the cluster name already in the list of connections?
        //

        pszSubString = wcsstr( pszConnectionsValue, rcstrClusterNameIn.PszData() );
        while ( pszSubString != NULL )
        {
            //
            // The cluster name is a substring of the list.
            // Make sure that the cluster name is not a proper substring of an cluster name already in the list.
            //
            if (   (                                            
                        ( pszSubString == pszConnectionsValue )             // the substring was found at the beginning of the string
                     || ( *( pszSubString - 1 ) == L',' )                   // or the character before the substring is a comma
                   )                                                        // AND            
                && (    ( *( pszSubString + rcstrClusterNameIn.NGetLen() ) == L'\0' )     // the character after the substring is a '\0'
                     || ( *( pszSubString + rcstrClusterNameIn.NGetLen() ) == L',' )      // or character after the substring is a comma
                   )                                                        
               )
            {
                fIsInList = true;
                break;
            } // if: the cluster name is not a proper substring of a cluster name that is already in the list

            // Continue searching.
            pszSubString = wcsstr( pszSubString + rcstrClusterNameIn.NGetLen(), rcstrClusterNameIn.PszData() );
        } // while: the cluster name is a substring of the list of existing connections

        if ( fIsInList )
        {
            // Nothing more to be done.
            LogMsg( "[BC] The '%s' cluster is already in the list of remembered Cluster Administrator connections.", rcstrClusterNameIn.PszData() );
            goto Cleanup;
        } // if: the cluster name is already in the list

        LogMsg( "[BC] The '%s' cluster is not in the list of remembered Cluster Administrator connections.", rcstrClusterNameIn.PszData() );

        // Store the current value in the member variable for restoration in case of error.
        m_sszOldConnectionsList.Assign( pszConnectionsValue );

        // Set the new connections value.
        {
            // Define a string to hold the new connections value. Preallocate its buffer.
            CStr            strNewConnectionsValue(
                  cchOldListLen                 // length of the old list ( including terminating '\0' )
                + 1                             // for the comma
                + rcstrClusterNameIn.NGetLen()  // length of the cluster name( including terminating '\0' )
                );

            //
            // Construct the new list
            //
            strNewConnectionsValue = rcstrClusterNameIn;
            strNewConnectionsValue += L",";
            strNewConnectionsValue += m_sszOldConnectionsList.PMem();

            LogMsg( "[BC] Writing the new list of remembered Cluster Administrator connections '%s'.", strNewConnectionsValue.PszData() );

            // Write the new list.
            rkConnectionsKey.SetValue(
                  CLUADMIN_CONNECTIONS_VALUE_NAME
                , REG_SZ
                , reinterpret_cast< const BYTE * >( strNewConnectionsValue.PszData() )
                , ( strNewConnectionsValue.NGetLen() + 1 ) * sizeof( WCHAR )
                );

            // We have changed the connections list.
            m_fChangedConnectionsList = true;
        }

    } // else: there are existing connections

Cleanup:

    LogMsg( "[BC] The changes were made successfully." );

    TraceFuncExit();

} //*** CNode::Configure


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::Cleanup
//
//  Description:
//      Clean up the changes made to this node when it became part of a cluster.
//      Note that the changes made during Configure() are not really undone here -
//      we just bring the node back to an acceptable state. This is because,
//      without a transactional registry, it will be very diffult to get 
//      the registry back to the exact state it was in before Configure() was
//      called.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNode::Cleanup( void )
{
    TraceFunc( "" );

    LogMsg( "[BC] Attempting to cleanup changes made when this node was made a part of a cluster." );

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                                                      // optional, handle of a parent window
        , m_pbcaParentAction->HGetMainInfFileHandle()               // handle to the INF file
        , NODE_CLEANUP_INF_SECTION                                  // name of the Install section
        , SPINST_REGISTRY                                           // which lines to install from section
        , NULL                                                      // optional, key for registry installs
        , NULL                                                      // optional, path for source files
        , NULL                                                      // optional, specifies copy behavior
        , NULL                                                      // optional, specifies callback routine
        , NULL                                                      // optional, callback routine context
        , NULL                                                      // optional, device information set
        , NULL                                                      // optional, device info structure
        ) == FALSE                                
       )
    {
        DWORD   sc = TW32( GetLastError() );

        LogMsg( "[BC] Error %#08x was returned from SetupInstallFromInfSection() while trying to clean up miscellaneous changes. Throwing an exception.", sc );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_NODE_CLEANUP );
    } // if: SetupInstallFromInfSection failed

    if ( m_fChangedConnectionsList )
    {
        LogMsg( "[BC] Restoring the list of remembered Cluster Administrator connections to '%s'", m_sszOldConnectionsList.PMem() );

        // Open the cluster administrator connections key.
        CRegistryKey    rkConnectionsKey(
              HKEY_CURRENT_USER
            , CLUADMIN_CONNECTIONS_KEY_NAME
            );

        // If there wasn't a previous value, delete the value we set.
        // Otherwise, set the value back to the old value.
        if ( m_sszOldConnectionsList.PMem() == NULL )
        {
            // Delete the value.
            rkConnectionsKey.DeleteValue( CLUADMIN_CONNECTIONS_VALUE_NAME );
        } // if: no old value existed
        else
        {
            // Write the old list back.
            rkConnectionsKey.SetValue(
                  CLUADMIN_CONNECTIONS_VALUE_NAME
                , REG_SZ
                , reinterpret_cast< const BYTE * >( m_sszOldConnectionsList.PMem() )
                , ( (UINT) wcslen( m_sszOldConnectionsList.PMem() ) + 1 ) * sizeof( WCHAR )
                );
        } // else: old value existed

    } // if: we changed the list of cluadmin connections

    LogMsg( "[BC] The cleanup was successfully." );

    TraceFuncExit();

} //*** CNode::Cleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\clist.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CList.h
//
//  Description:
//      Header file for CList template class.
//
//      CList is a template class the provides the functionality of a linked
//      list. It has an CIterator that allows both forward and reverse
//      traversal.
//
//      This class is intended to be used instead of std::list since the
//      use of STL is prohibited in our project.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 24-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// For the CException class
#include "CException.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  template< class t_Ty >
//  class CList
//
//  Description:
//      CList is a template class the provides the functionality of a linked
//      list. It has an CIterator that allows both forward and reverse
//      traversal.
//
//      This class is implemented as a circular doubly linked list.
//--
//////////////////////////////////////////////////////////////////////////////
template< class t_Ty >
class CList
{
private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    class CNode
    {
    public:
        // Constructor
        CNode( const t_Ty & rtyDataIn, CNode * pNextIn, CNode *pPrevIn )
            : m_tyData( rtyDataIn )
            , m_pNext( pNextIn )
            , m_pPrev( pPrevIn )
        {
        } //*** CNode()

        // Member data
        t_Ty        m_tyData;
        CNode *     m_pNext;
        CNode *     m_pPrev;
    }; //*** class CNode


public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////

    class CIterator;
    friend class CIterator;

    // The iterator for this list
    class CIterator 
    {
    public:
        CIterator( CNode * pNodeIn = NULL ) throw()
            : m_pNode( pNodeIn )
        {} //*** CIterator()

        t_Ty & operator*() const throw()
        {
            return m_pNode->m_tyData;
        } //*** operator*()

        t_Ty * operator->() const throw()
        {
            return &( m_pNode->m_tyData );
        } //*** operator->()

        CIterator & operator++()
        {
            m_pNode = m_pNode->m_pNext;
            return *this;
        } //*** operator++()

        CIterator & operator--()
        {
            m_pNode = m_pNode->m_pPrev;
            return *this;
        } //*** operator--()

        bool operator==( const CIterator & rRHSIn ) const throw()
        {
            return ( m_pNode == rRHSIn.m_pNode );
        } //*** operator==()

        bool operator!=( const CIterator & rRHSIn ) const throw()
        {
            return ( m_pNode != rRHSIn.m_pNode );
        } //*** operator!=()

        CNode * PGetNodePtr() const throw()
        {
            return m_pNode;
        } //*** PGetNodePtr()

    private:
        class CList;
        friend class CList;

        CNode * m_pNode;

    }; //*** class CIterator


public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor
    CList()
        : m_cSize( 0 )
    {
        // The list is never empty. It always has the special "head" node.

        // The reinterpret_cast is required to prevent the constructor of t_Ty
        // from being called when the head node is created.
        m_pHead = reinterpret_cast< CNode * >( new char[ sizeof( *m_pHead ) ] );
        if ( m_pHead == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        m_pHead->m_pNext = m_pHead;
        m_pHead->m_pPrev = m_pHead;
    } //*** CList()

    // Default destructor
    ~CList()
    {
        Empty();

        // Cast to void * to prevent destructor call
        delete reinterpret_cast< void * >( m_pHead );
    } //*** ~CList()


    //////////////////////////////////////////////////////////////////////////
    // Member functions
    //////////////////////////////////////////////////////////////////////////

    // Add to the end of the list
    void Append( const t_Ty & rctyNewDataIn )
    {
        InsertAfter( m_pHead->m_pPrev, rctyNewDataIn );
    } //*** Append()


    // Add a new node after the input node
    void InsertAfter( const CIterator & rciNodeIn, const t_Ty & rctyDataIn )
    {
        CNode * pNode = rciNodeIn.PGetNodePtr();

        CNode * pNewNode = new CNode( rctyDataIn, pNode->m_pNext, pNode );
        if ( pNewNode == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        pNode->m_pNext->m_pPrev = pNewNode;
        pNode->m_pNext = pNewNode;

        ++m_cSize;
    } //*** InsertAfter()


    // Delete a node. After this operation the input iterator points to the next node.
    void DeleteAndMoveToNext( CIterator & riNodeIn )
    {
        CNode * pNode = riNodeIn.PGetNodePtr();

        // Move to the next node.
        ++riNodeIn;

        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
        pNode->m_pPrev->m_pNext = pNode->m_pNext;

        delete pNode;

        --m_cSize;
    } //*** Delete()

    // Delete all the elements in this list.
    void Empty()
    {
        CIterator ciCurNode( m_pHead->m_pNext );
        while( m_cSize != 0 )
        {
            DeleteAndMoveToNext( ciCurNode );
        } // while: the list is not empty
    } //*** Empty()

    // Return an iterator pointing to the first element in the list
    CIterator CiBegin() const throw()
    {
        return CIterator( m_pHead->m_pNext );
    } //*** CiBegin()

    // Return an iterator pointing past the last element in the list.
    CIterator CiEnd() const throw()
    {
        return CIterator( m_pHead );
    } //*** CiEnd()

    // Get a count of the number of elements in the list.
    int CGetSize() const throw()
    {
        return m_cSize;
    } //*** CGetSize()


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CList( const CList & );

    // Assignment operator
    const CList & operator=( const CList & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the head of the list
    CNode *     m_pHead;

    // Count of the number of elements in the list
    int         m_cSize;

}; //*** class CList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnodecleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CNodeCleanup.cpp
//
//  Description:
//      Contains the definition of the CNodeCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CNodeCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::CNodeCleanup
//
//  Description:
//      Constructor of the CNodeCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CNodeCleanup::CNodeCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{
    TraceFunc( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

    TraceFuncExit();

} //*** CNodeCleanup::CNodeCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::~CNodeCleanup
//
//  Description:
//      Destructor of the CNodeCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeCleanup::~CNodeCleanup( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CNodeCleanup::~CNodeCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::Commit
//
//  Description:
//      Cleans up a node that is no longer a part of a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeCleanup::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the miscellaneous entries made when this node joined a cluster.
    Cleanup();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CNodeCleanup::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::Rollback
//
//  Description:
//      Rollback the cleanup of this node. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CNodeCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cregistrykey.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CRegistryKey.h
//
//  Description:
//      Header file for CRegistryKey class.
//
//      The CRegistry class is the representation of a registry key.
//      See IMPORTANT NOTE in the class description.
//
//  Implementation Files:
//      CRegistryKey.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

#include <windows.h>

// For smart classes
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CRegistryKey
//
//  Description:
//      The CRegistry class is the representation of a registry key.
//
//  IMPORTANT NOTE: 
//      Due to the contained smart handle object, objects of this class 
//      have destructive copy semantics. That is, copying an object of this
//      class will invalidate the source object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CRegistryKey
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CRegistryKey( void ) throw();

    // Constructor that opens the key.
    CRegistryKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn = KEY_ALL_ACCESS
        );

    // Default destructor.
    ~CRegistryKey( void );


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Open this key.
    void 
    OpenKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn  = KEY_ALL_ACCESS
        );

    // Create this key. Open it if it already exists.
    void 
    CreateKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn  = KEY_ALL_ACCESS
        );

    // Read a value under this key.
    void QueryValue(
          const WCHAR *   pszValueNameIn
        , LPBYTE *        ppbDataOut
        , LPDWORD         pdwDataSizeBytesOut
        , LPDWORD         pdwTypeOut    = NULL
        ) const;

    // Write a value under this key.
    void SetValue(
          const WCHAR *   pszValueNameIn
        , DWORD           dwTypeIn
        , const BYTE *    cpbDataIn
        , DWORD           dwDataSizeBytesIn
        ) const;

    //
    // Rename this key.
    // Note: This function calls the NtRenameKey API with the handle returned by 
    // RegOpenKeyEx. This will work as long as we are not dealing with a remote 
    // registry key.
    //
    void RenameKey( const WCHAR * pszNewNameIn );

    // Delete a value under this key.
    void DeleteValue(
        const WCHAR * pszValueNameIn
        ) const;


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the handle to the registry key.
    HKEY HGetKey()
    {
        return m_shkKey.HHandle();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////

    // Smart registry key
    typedef CSmartResource<
        CHandleTrait< 
              HKEY 
            , LONG
            , RegCloseKey
            , reinterpret_cast< HKEY >( NULL )
            >
        >
        SmartHKey;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    SmartHKey   m_shkKey;

}; //*** class CRegistryKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cregistrykey.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CRegistryKey.cpp
//
//  Description:
//      Contains the definition of the CRegistryKey class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::CRegistryKey
//
//  Description:
//      Default constructor of the CRegistryKey class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::CRegistryKey( void ) throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CRegistryKey::CRegistryKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::CRegistryKey
//
//  Description:
//      Constructor of the CRegistryKey class. Opens the specified key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::CRegistryKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    TraceFunc1( "pszSubKeyNameIn = '%ws'", pszSubKeyNameIn );

    OpenKey( hKeyParentIn, pszSubKeyNameIn, samDesiredIn );

    TraceFuncExit();

} //*** CRegistryKey::CRegistryKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::~CRegistryKey
//
//  Description:
//      Default destructor of the CRegistryKey class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::~CRegistryKey( void ) throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CRegistryKey::~CRegistryKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::OpenKey
//
//  Description:
//      Opens the specified key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::OpenKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    TraceFunc3( "hKeyParentIn = %p, pszSubKeyNameIn = '%ws', samDesiredIn = %#x", hKeyParentIn, pszSubKeyNameIn == NULL ? L"<null>" : pszSubKeyNameIn, samDesiredIn );

    HKEY    hTempKey = NULL;
    LONG    lRetVal;

    lRetVal = TW32( RegOpenKeyExW(
                          hKeyParentIn
                        , pszSubKeyNameIn
                        , 0
                        , samDesiredIn
                        , &hTempKey
                        ) );

    // Was the key opened properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegOpenKeyExW( '%ws' ) retured error %#08x. Throwing an exception.", pszSubKeyNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_OPEN
            );
    } // if: RegOpenKeyEx failed.

    TraceFlow1( "Handle to key = %p", hTempKey );

    // Store the opened key in the member variable.
    m_shkKey.Assign( hTempKey );

    TraceFuncExit();

} //*** CRegistryKey::OpenKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::CreateKey
//
//  Description:
//      Creates the specified key. If the key already exists, this functions
//      opens the key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::CreateKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    TraceFunc3( "hKeyParentIn = %p, pszSubKeyNameIn = '%ws', samDesiredIn = %#x", hKeyParentIn, pszSubKeyNameIn == NULL ? L"<null>" : pszSubKeyNameIn, samDesiredIn );
    if ( pszSubKeyNameIn == NULL )
    {
        LogMsg( "[BC] CreateKey() - Key = NULL. This is an error! Throwing exception." );
        THROW_ASSERT( E_INVALIDARG, "The name of the subkey cannot be NULL." );
    }

    HKEY    hTempKey = NULL;
    LONG    lRetVal;

    lRetVal = TW32( RegCreateKeyExW(
                          hKeyParentIn
                        , pszSubKeyNameIn
                        , 0
                        , NULL
                        , REG_OPTION_NON_VOLATILE
                        , samDesiredIn
                        , NULL
                        , &hTempKey
                        , NULL
                        ) );

    // Was the key opened properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegCreateKeyExW( '%ws' ) retured error %#08x. Throwing an exception.", pszSubKeyNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_CREATE
            );
    } // if: RegCreateKeyEx failed.

    TraceFlow1( "Handle to key = %p", hTempKey );

    // Store the opened key in the member variable.
    m_shkKey.Assign( hTempKey );

    TraceFuncExit();

} //*** CRegistryKey::CreateKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::QueryValue
//
//  Description:
//      Reads a value under this key. The memory for this value is allocated
//      by this function. The caller is responsible for freeing this memory.
//
//  Arguments:
//      pszValueNameIn
//          Name of the value to read.
//
//      ppbDataOut
//          Pointer to the pointer to the data. Cannot be NULL.
//
//      pdwDataSizeInBytesOut
//          Number of bytes allocated in the data buffer. Cannot be NULL.
//
//      pdwTypeOut
//          Pointer to the type of the value.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAssert
//          If the parameters are incorrect.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::QueryValue(
      const WCHAR *   pszValueNameIn
    , LPBYTE *        ppbDataOut
    , LPDWORD         pdwDataSizeBytesOut
    , LPDWORD         pdwTypeOut
    ) const
{
    TraceFunc1( "pszValueNameIn = '%ws'", pszValueNameIn == NULL ? L"<null>" : pszValueNameIn );

    LONG    lRetVal             = ERROR_SUCCESS;
    DWORD   cbBufferSize        = 0;
    DWORD   cbTempBufferSize    = 0;
    DWORD   dwType              = REG_SZ;

    // Check parameters
    if (  ( pdwDataSizeBytesOut == NULL )
       || ( ppbDataOut == NULL )
       )
    {
        LogMsg( "[BC] One of the required input pointers is NULL. Throwing an exception." );
        THROW_ASSERT(
              E_INVALIDARG
            , "CRegistryKey::QueryValue() => Required input pointer in NULL"
            );
    } // if: parameters are invalid.


    // Initialize outputs.
    *ppbDataOut = NULL;
    *pdwDataSizeBytesOut = 0;

    // Get the required size of the buffer.
    lRetVal = TW32( RegQueryValueExW(
                          m_shkKey.HHandle()    // handle to key to query
                        , pszValueNameIn        // address of name of value to query
                        , 0                     // reserved
                        , &dwType               // address of buffer for value type
                        , NULL                  // address of data buffer
                        , &cbBufferSize         // address of data buffer size
                        ) );

    if ( lRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegQueryValueExW( '%ws' ) retured error %#08x. Throwing an exception.", pszValueNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_QUERY
            );
    }

    cbTempBufferSize = cbBufferSize;

    // String should be double NULL terminated if REG_MULTI_SZ type
    // String should be NULL terminated if REG_SZ or REG_EXPAND_SZ type
    if ( dwType == REG_MULTI_SZ ) 
    {
        cbTempBufferSize = cbBufferSize + ( 2 * sizeof( WCHAR ) );
    }
    else if ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) )
    {
        cbTempBufferSize = cbBufferSize + ( 1 * sizeof( WCHAR ) );
    }

    // Allocate a byte array with enough size for null termination if not already null terminated.

    SmartByteArray sbaBuffer( new BYTE[ cbTempBufferSize ] );


    if ( sbaBuffer.FIsEmpty() )
    {
        LogMsg( "[BC] CRegistryKey::QueryValue() - Could not allocate %d bytes of memory. Throwing an exception", lRetVal );
        THROW_RUNTIME_ERROR(
              THR( E_OUTOFMEMORY )
            , IDS_ERROR_REGISTRY_QUERY
            );
    }

    // Read the value.
    lRetVal = TW32( RegQueryValueExW(
                          m_shkKey.HHandle()    // handle to key to query
                        , pszValueNameIn        // address of name of value to query
                        , 0                     // reserved
                        , &dwType               // address of buffer for value type
                        , sbaBuffer.PMem()      // address of data buffer
                        , &cbBufferSize         // address of data buffer size
                        ) );

    // Was the key read properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegQueryValueExW( '%ws' ) retured error %#08x. Throwing an exception.", pszValueNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_QUERY
            );
    } // if: RegQueryValueEx failed.

    // Are we dealing with a string?
    if ( ( dwType == REG_MULTI_SZ ) || ( dwType == REG_EXPAND_SZ )  || ( dwType == REG_SZ )  )
    {
        // We are expecting a Unicode string 
        Assert( ( cbBufferSize % 2 ) == 0 );

        WCHAR * pszData = reinterpret_cast< WCHAR * >( sbaBuffer.PMem() );
        size_t  cch = cbBufferSize / sizeof( *pszData );

        switch ( dwType ) 
        {
             // Null terminate the string if not already null terminated
            case REG_SZ:
            case REG_EXPAND_SZ:
                if ( pszData[ cch - 1 ]  != L'\0' )
                {
                    pszData[ cch ] = L'\0';
                    cbBufferSize += ( 1 * sizeof( *pszData ) );
                }
                break;
            
             // Double null terminate the REG_MULTI_SZ string if not already null terminated
            case REG_MULTI_SZ: 
                if ( pszData[ cch - 2 ] != L'\0' )
                {
                    pszData[ cch ] = L'\0';
                    cbBufferSize += ( 1 * sizeof( *pszData ) );
                }
                cch++;
                if ( pszData[ cch - 2 ] != L'\0' )
                {
                    pszData[ cch ] = L'\0';
                    cbBufferSize += ( 1 * sizeof( *pszData ) );
                }
                break;
        } // switch ( dwType )
    } // if: ( ( dwType == REG_MULTI_SZ ) || ( dwType == REG_EXPAND_SZ )  || ( dwType == REG_SZ )  )

    *ppbDataOut = sbaBuffer.PRelease();
    *pdwDataSizeBytesOut = cbBufferSize;

    if ( pdwTypeOut != NULL )
    {
        *pdwTypeOut = dwType;
    }

    TraceFuncExit();

} //*** CRegistryKey::QueryValue


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::SetValue
//
//  Description:
//      Writes a value under this key.
//
//  Arguments:
//      pszValueNameIn
//          Name of the value to be set.
//
//      cpbDataIn
//          Pointer to the pointer to the data buffer.
//
//      dwDataSizeInBytesIn
//          Number of bytes in the data buffer.
//
//      pdwTypeIn
//          Type of the value.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::SetValue(
      const WCHAR *   pszValueNameIn
    , DWORD           dwTypeIn
    , const BYTE *    cpbDataIn
    , DWORD           dwDataSizeBytesIn
    ) const
{
    TraceFunc5(
          "HKEY = %p, pszValueNameIn = '%ws', dwTypeIn = %d, cpbDataIn = %p, dwDataSizeBytesIn = %d."
        , m_shkKey.HHandle()
        , pszValueNameIn
        , dwTypeIn
        , cpbDataIn
        , dwDataSizeBytesIn
        );

    DWORD scRetVal = ERROR_SUCCESS;

#ifdef DEBUG

    // Are we dealing with a string?
    if ( ( dwTypeIn == REG_MULTI_SZ ) || ( dwTypeIn == REG_EXPAND_SZ )  || ( dwTypeIn == REG_SZ )  )
    {
        // We are expecting a unicode string 
        Assert( ( dwDataSizeBytesIn % 2 ) == 0 );

        const WCHAR *   pszData = reinterpret_cast< const WCHAR * >( cpbDataIn );
        size_t          cch = dwDataSizeBytesIn / sizeof( *pszData );

        // Assert if the string we are writing to the registry is not null terminated.
        switch ( dwTypeIn ) 
        {
            case REG_SZ:
            case REG_EXPAND_SZ:
                Assert( pszData[ cch - 1 ] == L'\0' );
                break;
            
            case REG_MULTI_SZ : 
                Assert( pszData[ cch - 2 ] == L'\0' );
                Assert( pszData[ cch - 1 ] == L'\0' );
                break;
        } // switch ( dwType )
    } // if: ( ( dwType == REG_MULTI_SZ ) || ( dwType == REG_EXPAND_SZ )  || ( dwType == REG_SZ )  )

#endif

    scRetVal = TW32( RegSetValueExW(
                                  m_shkKey.HHandle()
                                , pszValueNameIn
                                , 0
                                , dwTypeIn
                                , cpbDataIn
                                , dwDataSizeBytesIn
                                ) );

    if ( scRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegSetValueExW( '%s' ) retured error %#08x. Throwing an exception.", pszValueNameIn, scRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( scRetVal )
            , IDS_ERROR_REGISTRY_SET
            );
    } // if: RegSetValueExW failed

    TraceFuncExit();

} //*** CRegistryKey::SetValue


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::RenameKey
//
//  Description:
//      Rename this key.
//
//  Arguments:
//      pszNewNameIn
//          The new name for this key.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//  IMPORTANT NOTE:
//      This function calls the NtRenameKey API with the handle returned by
//      RegOpenKeyEx. This will work as long as we are not dealing with a
//      remote registry key.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::RenameKey(
      const WCHAR *   pszNewNameIn
    )
{
    TraceFunc2(
          "HKEY = %p, pszNewNameIn = '%s'."
        , m_shkKey.HHandle()
        , pszNewNameIn
        );

    UNICODE_STRING  ustrNewName;
    DWORD           dwRetVal = ERROR_SUCCESS;

    RtlInitUnicodeString( &ustrNewName, pszNewNameIn );

    // Begin_Replace00
    //
    // BUGBUG: Vij Vasu (Vvasu) 10-APR-2000
    // Dynamically linking to NtDll.dll to allow testing on Win2K
    // Replace the section below ( Begin_Replace00 to End-Replace00 ) with
    // the single marked statment ( Begin_Replacement00 to End_Replacement00 ).
    //

    {
        typedef CSmartResource<
            CHandleTrait<
                  HMODULE
                , BOOL
                , FreeLibrary
                , reinterpret_cast< HMODULE >( NULL )
                >
            > SmartModuleHandle;

        SmartModuleHandle smhNtDll( LoadLibrary( L"NtDll.dll" ) );

        if ( smhNtDll.FIsInvalid() )
        {
            dwRetVal = GetLastError();

            LogMsg( "[BC] LoadLibrary( 'NtDll.dll' ) retured error %#08x. Throwing an exception.", dwRetVal );

            THROW_RUNTIME_ERROR(
                  dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
                , IDS_ERROR_REGISTRY_RENAME
                );
        } // if: LoadLibrary failed.

        FARPROC pNtRenameKey = GetProcAddress( smhNtDll.HHandle(), "NtRenameKey" );

        if ( pNtRenameKey == NULL )
        {
            dwRetVal = GetLastError();

            LogMsg( "[BC] GetProcAddress() retured error %#08x. Throwing an exception.", dwRetVal );

            THROW_RUNTIME_ERROR(
                  dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
                , IDS_ERROR_REGISTRY_RENAME
                );
        } // if: GetProcAddress() failed

        dwRetVal = ( reinterpret_cast< NTSTATUS (*)( HANDLE, PUNICODE_STRING ) >( pNtRenameKey ) )(
              m_shkKey.HHandle()
            , &ustrNewName
            );
    }

    // End_Replace00
    /* Begin_Replacement00 - delete this line
    dwRetVal = NtRenameKey(
          m_shkKey.HHandle()
        , &ustrNewName
        );
    End_Replacement00 - delete this line */

    if ( NT_ERROR( dwRetVal ) )
    {
        TraceFlow2( "NtRenameKey( '%ws' ) retured error %#08x. Throwing an exception.", pszNewNameIn, dwRetVal );
        LogMsg( "[BC] Error %#08x occurred renaming a key to '%ws' )", dwRetVal, pszNewNameIn );

        THROW_RUNTIME_ERROR(
              dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
            , IDS_ERROR_REGISTRY_RENAME
            );
    } // if: RegRenameKeyEx failed.

    TraceFuncExit();

} //*** CRegistryKey::RenameKey


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::DeleteValue
//
//  Description:
//      Delete a value under this key.
//
//  Arguments:
//      pszValueNameIn
//          Name of the value to be deleted.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::DeleteValue(
    const WCHAR * pszValueNameIn
    ) const
{
    TraceFunc2(
          "HKEY = %p, pszValueNameIn = '%ws'."
        , m_shkKey.HHandle()
        , pszValueNameIn
        );

    DWORD dwRetVal = TW32( RegDeleteValueW(
                                  m_shkKey.HHandle()
                                , pszValueNameIn
                                ) );

    if ( dwRetVal != ERROR_SUCCESS )
    {
        LogMsg( "[BC] RegDeleteValueW( '%s' ) retured error %#08x. Throwing an exception.", pszValueNameIn, dwRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( dwRetVal )
            , IDS_ERROR_REGISTRY_DELETE
            );
    } // if: RegDeleteValue failed.

    TraceFuncExit();

} //*** CRegistryKey::DeleteValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnodecleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNodeCleanup.h
//
//  Description:
//      Header file for CNodeCleanup class.
//      The CNodeCleanup class is an action that cleans up a node that is no
//      longer a part of a cluster.
//
//  Implementation Files:
//      CNodeCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CNode base class
#include "CNode.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNodeCleanup
//
//  Description:
//      The CNodeCleanup class is an action that cleans up a node that is no
//      longer a part of a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNodeCleanup : public CNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNodeCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CNodeCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the Node service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CNodeCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cservice.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CService.cpp
//
//  Description:
//      Contains the definition of the CService class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header file for this class.
#include "CService.h"

// For the CStr class.
#include "CStr.h"

// For the CStatusReport class
#include "CStatusReport.h"


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// String added to end of service name to get INF file section for create
#define SERVICE_CREATE_SECTION_SUFFIX L"_Create"

// String added to end of service name to get INF file section for cleanup
#define SERVICE_CLEANUP_SECTION_SUFFIX L"_Cleanup"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CService::Create
//
//  Description:
//      This function creates an entry for the service with the SCM. It does
//      this by using the SetupAPI to process service and registry related
//      entries in a section named <ServiceName>_Create in the INF file that
//      is passed in.
//
//      For example, if this object represents the ClusSvc service, then,
//      when this function is called, the AddService and the AddReg entries
//      under the [ClusSvc_Create] section are processed in the INF file
//      whose handle is hInfHandleIn.
//
//  Arguments:
//      hInfHandleIn
//          Handle to the INF file that contains the required sections
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Create(
    HINF hInfHandleIn
    )
{
    TraceFunc1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "[BC] Attempting to create the '%s' service.", m_strName.PszData() );

    DWORD   sc = ERROR_SUCCESS;
    CStr    strSectionName = m_strName + SERVICE_CREATE_SECTION_SUFFIX;

    // Process the service section
    if ( SetupInstallServicesFromInfSection(
          hInfHandleIn
        , strSectionName.PszData()
        , 0
        ) == FALSE
       )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallServicesFromInfSection failed


    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                      // optional, handle of a parent window
        , hInfHandleIn              // handle to the INF file
        , strSectionName.PszData()     // name of the Install section
        , SPINST_REGISTRY           // which lines to install from section
        , NULL                      // optional, key for registry installs
        , NULL                      // optional, path for source files
        , NULL                      // optional, specifies copy behavior
        , NULL                      // optional, specifies callback routine
        , NULL                      // optional, callback routine context
        , NULL                      // optional, device information set
        , NULL                      // optional, device info structure
        ) == FALSE
       )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallFromInfSection failed

    LogMsg( "[BC] The '%s' service has been successfully created.", m_strName.PszData() );

Cleanup:
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x returned from SetupInstallFromInfSection() while trying to create the '%s' service. Throwing an exception.", sc, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SERVICE_CREATE );
    }

    TraceFuncExit();

} //*** CService::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CService::Cleanup
//
//  Description:
//      This function cleans up a service by deregistering it with the SCM and by
//      deleting any required registry entries. It does this by using the
//      SetupAPI to process service and registry related entries in a
//      section named <ServiceName>_Cleanup in the INF file that is passed in.
//
//      For example, if this object represents the ClusSvc service, then,
//      when this function is called, the DelService and the DelReg entries
//      under the [ClusSvc_Cleanup] section are processed in the INF file
//      whose handle is hInfHandleIn.
//
//  Arguments:
//      hInfHandleIn
//          Handle to the INF file that contains the required sections
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Cleanup(
    HINF hInfHandleIn
    )
{
    TraceFunc1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "[BC] Attempting to clean up the '%s' service.", m_strName.PszData() );

    DWORD   sc = ERROR_SUCCESS;
    CStr    strSectionName = m_strName + SERVICE_CLEANUP_SECTION_SUFFIX;

    // Process the service section
    if ( SetupInstallServicesFromInfSection(
          hInfHandleIn
        , strSectionName.PszData()
        , 0
        ) == FALSE
       )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallServicesFromInfSection failed

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                      // optional, handle of a parent window
        , hInfHandleIn              // handle to the INF file
        , strSectionName.PszData()     // name of the Install section
        , SPINST_REGISTRY           // which lines to install from section
        , NULL                      // optional, key for registry installs
        , NULL                      // optional, path for source files
        , NULL                      // optional, specifies copy behavior
        , NULL                      // optional, specifies callback routine
        , NULL                      // optional, callback routine context
        , NULL                      // optional, device information set
        , NULL                      // optional, device info structure
        ) == FALSE
       )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallFromInfSection failed

    LogMsg( "[BC] The '%s' service has been successfully cleaned up.", m_strName.PszData() );

Cleanup:
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x returned from SetupInstallFromInfSection() while trying to clean up the '%s' service. Throwing an exception.", sc, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SERVICE_CLEANUP );
    }

    TraceFuncExit();

} //*** CService::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CService::Start
//
//  Description:
//      Instructs the SCM to start the service. If fWaitForServiceStartIn is
//      true, this function tests cQueryCountIn times to see if the service has
//      started, checking every ulQueryIntervalMilliSecIn milliseconds.
//
//      fWaitForServiceStartIn is false, this function returns immediately.
//
//  Arguments:
//      hServiceControlManagerIn
//          Handle to the service control manager.
//
//      fWaitForServiceStartIn
//          If true, this function waits for the service to finish starting
//          before returning. The default value is true.
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has started. The default value is 500 milliseconds.
//          This argument is used only if fWaitForServiceStartIn is true.
//
//      cQueryCountIn
//          The number of times this function will query the service to see
//          if it has started. An exception is thrown if the service is not
//          running even after querying it ulQueryCountIn times. The default
//          value is 10 times.
//          This argument is used only if fWaitForServiceStartIn is true.
//
//      pStatusReportIn
//          A pointer to the status report that should be sent while waiting for
//          the service to start. This argument is NULL by default.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If the service is not running even after the timeout has expired.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Start(
      SC_HANDLE             hServiceControlManagerIn
    , bool                  fWaitForServiceStartIn
    , ULONG                 ulQueryIntervalMilliSecIn
    , UINT                  cQueryCountIn
    , CStatusReport *       pStatusReportIn
    )
{
    TraceFunc1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "[BC] Attempting to start the '%s' service.", m_strName.PszData() );

    DWORD   sc = ERROR_SUCCESS;
    bool    fStarted = false;           // Has the service been started?
    UINT    cNumberOfQueries;           // The number of times we have queried the service.
    int     cSeqMismatchRetries = 0;    // The number of times service returned ERROR_CLUSTER_DATABASE_SEQMISMATCH.

    // Handle to the service.
    SmartSCMHandle  sscmhServiceHandle(
        OpenService(
              hServiceControlManagerIn
            , m_strName.PszData()
            , SERVICE_START | SERVICE_QUERY_STATUS
            )
        );

    if ( sscmhServiceHandle.FIsInvalid() )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x occurred while trying to open the '%s' service. Throwing an exception.", sc, m_strName.PszData() );
        goto Cleanup;
    } // if: the handle to the service could not be opened.

    // Try and start the service.
    sc = TW32( ScStartService( sscmhServiceHandle.HHandle() ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    // If we are here, then the service may not have started yet.

    // Has the caller requested that we wait for the service to start?
    if ( ! fWaitForServiceStartIn )
    {
        LogMsg( "[BC] Not waiting to see if the service has started or not." );
        goto Cleanup;
    } // if: no waiting is required.

    // We have to wait for the service to start.
    cNumberOfQueries = 0;

    do
    {
        SERVICE_STATUS  ssStatus;

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );

        // Query the service for its status.
        if ( QueryServiceStatus( sscmhServiceHandle.HHandle(), &ssStatus ) == FALSE )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred while trying to query service status. Throwing an exception.", sc );

            break;
        } // if: we could not query the service for its status.

        //
        // Set the member Win32 and Service specific exit codes.
        //
        m_scWin32ExitCode = ssStatus.dwWin32ExitCode;
        m_scServiceExitCode = ssStatus.dwServiceSpecificExitCode;

        // Check if the service has posted an error.

        // If the error is ERROR_CLUSTER_DATABASE_SEQMISMATCH then we want to sleep for 5 seconds and retry.  This
        // will only be returned by the cluster service.
        if ( ssStatus.dwServiceSpecificExitCode == ERROR_CLUSTER_DATABASE_SEQMISMATCH )
        {
            Sleep( 5000 );
            cSeqMismatchRetries++;

            if ( cSeqMismatchRetries > 3 )
            {
                sc = TW32( ssStatus.dwWin32ExitCode );

                LogMsg( "[BC] The service has returned error %#08x to query service status more than 3 times. Throwing an exception.", sc );
                break;
            } // if:

            // Try and start the service.  Ignore error and let the QueryServiceStatus() tell us if it started or not.
            sc = TW32( ScStartService( sscmhServiceHandle.HHandle() ) );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:

            continue;
        } // if: the service returned ERROR_CLUSTER_DATABASE_SEQMISMATCH
        else if ( ssStatus.dwWin32ExitCode != ERROR_SUCCESS )
        {
            sc = TW32( ssStatus.dwWin32ExitCode );
            if ( sc == ERROR_SERVICE_SPECIFIC_ERROR )
            {
                TraceFlow( "This is a service specific error code." );
                sc = TW32( ssStatus.dwServiceSpecificExitCode );
            }

            LogMsg( "[BC] The service has returned error %#08x to query service status. Throwing an exception.", sc );
            break;
        } // else if: the service itself has posted an error.

        if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
        {
            fStarted = true;
            break;
        } // if: the service is running.

        ++cNumberOfQueries;

        // Send a progress report if the caller had passed in a valid pointer.
        if ( pStatusReportIn != NULL )
        {
            pStatusReportIn->SendNextStep( S_OK );
        } // if: a status report needs to be sent while we wait

        // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );
    }
    while ( cNumberOfQueries < cQueryCountIn ); // while: loop for the required number of queries

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStarted )
    {
        LogMsg( "[BC] The service could not be started. Throwing an exception." );
        THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_SERVICE_NOT_ACTIVE ) ), IDS_ERROR_SERVICE_START );
    } // if: the maximum number of queries have been made and the service is not running.

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to start the '%s' service.", sc, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SERVICE_START );
    } // if: something has gone wrong
    else
    {
        LogMsg( "[BC] The '%s' service has been successfully started.", m_strName.PszData() );
    } // else: nothing went wrong.

    TraceFuncExit();

} //*** CService::Start


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CService::Stop
//
//  Description:
//      Instructs the SCM to stop the service. If fWaitForServiceStop is
//      true, this function tests cQueryCountIn times to see if the service has
//      stopped, checking every ulQueryIntervalMilliSecIn milliseconds.
//
//  Arguments:
//      hServiceControlManagerIn
//          Handle to the service control manager.
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has stopped. The default value is 500 milliseconds.
//
//      cQueryCountIn
//          The number of times this function will query the service to see
//          if it has stopped. An exception is thrown if the service is not
//          running even after querying it ulQueryCountIn times. The default
//          value is 10 times.
//
//      pStatusReportIn
//          A pointer to the status report that should be sent while waiting for
//          the service to stop. This argument is NULL by default.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If the service has not stopped even after the timeout has expired.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Stop(
      SC_HANDLE             hServiceControlManagerIn
    , ULONG                 ulQueryIntervalMilliSecIn
    , UINT                  cQueryCountIn
    , CStatusReport *       pStatusReportIn
    )
{
    TraceFunc( "" );

    DWORD           sc = ERROR_SUCCESS;
    SERVICE_STATUS  ssStatus;               // The service status structure.
    bool            fStopped = false;       // Has the service been stopped?
    UINT            cNumberOfQueries = 0;   // The number of times we have queried the service
                                            //   (not including the initial state query).

    LogMsg( "[BC] Attempting to stop the '%s' service.", m_strName.PszData() );

    // Smart handle to the service being stopped.
    SmartSCMHandle  sscmhServiceHandle(
        OpenService(
              hServiceControlManagerIn
            , m_strName.PszData()
            , SERVICE_STOP | SERVICE_QUERY_STATUS
            )
        );

    // Check if we could open a handle to the service.
    if ( sscmhServiceHandle.FIsInvalid() )
    {
        // We could not get a handle to the service.
        sc = GetLastError();

        // Check if the service exists.
        if ( sc == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            // Nothing needs to be done here.
            LogMsg( "[BC] The '%s' service does not exist, so it is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
            sc = ERROR_SUCCESS;
        } // if: the service does not exist
        else
        {
            // Something else has gone wrong.
            TW32( sc );
            LogMsg( "[BC] Error %#08x occurred trying to open the '%s' service.", sc, m_strName.PszData() );
        } // else: the service exists

        goto Cleanup;
    } // if: the handle to the service could not be opened.


    TraceFlow( "Querying the service for its initial state." );

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( sscmhServiceHandle.HHandle(), &ssStatus ) == 0 )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x occurred while trying to query the initial state of the '%s' service.", sc, m_strName.PszData() );
        goto Cleanup;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // Nothing needs to be done here.
        LogMsg( "[BC] The '%s' service is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
        goto Cleanup;
    } // if: the service has stopped.


    // If we are here, the service is running.
    TraceFlow( "The service is running." );


    //
    // Try and stop the service.
    //

    // If the service is stopping on its own, no need to send the stop control code.
    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
    {
        LogMsg( "[BC] The service is stopping on its own. The stop control code will not be sent." );
    } // if: the service is stopping already
    else
    {
        TraceFlow( "The stop control code will be sent now." );

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( sscmhServiceHandle.HHandle(), SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            if ( sc == ERROR_SERVICE_NOT_ACTIVE )
            {
                LogMsg( "[BC] The '%s' service is not running. Nothing more needs to be done here.", m_strName.PszData() );

                // The service is not running. Change the error code to success.
                sc = ERROR_SUCCESS;
            } // if: the service is already running.
            else
            {
                TW32( sc );
                LogMsg( "[BC] Error %#08x occurred trying to stop the '%s' service.", sc, m_strName.PszData() );
            }

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // else: the service has to be instructed to stop


    // Query the service for its state now and wait till the timeout expires
    cNumberOfQueries = 0;
    do
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( sscmhServiceHandle.HHandle(), &ssStatus ) == 0 )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred while trying to query the state of the '%s' service.", sc, m_strName.PszData() );
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            LogMsg( "[BC] The service has been stopped." );
            fStopped = true;
            sc = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cNumberOfQueries >= cQueryCountIn )
        {
            LogMsg( "[BC] The service stop wait timeout has expired." );
            break;
        } // if: number of queries has exceeded the maximum specified

        TraceFlow2(
              "Waiting for %d milliseconds before querying service status again. %d such queries remaining."
            , ulQueryIntervalMilliSecIn
            , cQueryCountIn - cNumberOfQueries
            );

        ++cNumberOfQueries;

        // Send a progress report if the caller had passed in a valid pointer.
        if ( pStatusReportIn != NULL )
        {
            pStatusReportIn->SendNextStep( S_OK );
        } // if: a status report needs to be sent while we wait

         // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );

    }
    while( true ); // while: loop infinitely

    if ( sc != ERROR_SUCCESS )
        goto Cleanup;

    if ( ! fStopped )
    {
        sc = TW32( ERROR_SERVICE_REQUEST_TIMEOUT );
        LogMsg( "[BC] The '%s' service has not stopped even after %d queries.", m_strName.PszData(), cQueryCountIn );
        goto Cleanup;
    } // if: the maximum number of queries have been made and the service is not running.

    LogMsg( "[BC] The '%s' service was successfully stopped.", m_strName.PszData() );

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        TraceFlow2( "Error %#08x has occurred trying to stop the '%s' service. Throwing exception.", sc, m_strName.PszData() );
        LogMsg( "[BC] Error %#08x has occurred trying to stop the '%s' service. Throwing an exception.", sc, m_strName.PszData() );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SERVICE_STOP );
    } // if: something has gone wrong

    TraceFuncExit();

} //*** CService::Stop

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CService::ScStartService
//
//  Description:
//      Wrapper for the Win32 API StartService().
//
//  Arguments:
//      sscmhServiceHandleIn
//
//  Return Value:
//      Win32 error code from StartService().
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CService::ScStartService(
    SC_HANDLE  hServiceIn
    )
{
    TraceFunc( "" );

    DWORD   sc = ERROR_SUCCESS;

    // Try and start the service.
    if ( StartService( hServiceIn, 0, NULL ) == FALSE )
    {
        sc = GetLastError();

        if ( sc == ERROR_SERVICE_ALREADY_RUNNING )
        {
            LogMsg( "[BC] The '%s' service is already running.", m_strName.PszData() );

            // The service is already running. Change the error code to success.
            sc = ERROR_SUCCESS;
        } // if: the service is already running.
        else
        {
            TW32( sc );
            LogMsg( "[BC] Error %#08x occurred while trying to start the '%s' service.", sc, m_strName.PszData() );
        } // else:
    } // if: an error occurred trying to start the service.

    RETURN( sc );

} //*** CService::ScStartService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnodeconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNodeConfig.h
//
//  Description:
//      Header file for CNodeConfig class.
//      The CNodeConfig class is an action that performs configuration tasks
//      related to the node being configured. These tasks are not directly
//      related to the cluster service itself, but needed by it. An example,
//      of such a task is to make set the power management scheme of the
//      node to 'Always On'. This class is used during join or form only.
//
//  Implementation Files:
//      CNodeConfig.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CNode base class
#include "CNode.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////

// The parent action of this action.
class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNodeConfig
//
//  Description:
//      The CNodeConfig class is an action that performs configuration tasks
//      related to the node being configured. These tasks are not directly
//      related to the cluster service itself, but needed by it. An example,
//      of such a task is to make set the power management scheme of the
//      node to 'Always On'.  This class is used during join or form only.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNodeConfig : public CNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNodeConfig( CBaseClusterAddNode * pbcanParentActionIn );

    // Default destructor.
    ~CNodeConfig();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Grant the required rights to the account.
    //
    void Commit();

    //
    // Revert the account to its previous state.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The notification is:
        // 1. Performing node specific configuration
        //
        return 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CNodeConfig( const CNodeConfig & );

    // Assignment operator
    CNodeConfig & operator =( const CNodeConfig & );

    
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CNodeConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\commondefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CommonDefs.h
//
//  Description:
//      This file contains a few definitions common to many classes and files.
//
//  Implementation Files:
//      None
//
//  Maintained By:
//      Vij Vasu (Vvasu) 12-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For some basic types
#include <windows.h>

// For smart classes
#include "SmartClasses.h"

// For DIRID_USER
#include <setupapi.h>

// For IUnknown
#include <Unknwn.h>

//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Directory id of the cluster files directory (currently 0x8000, defined in setupapi.h )
#define CLUSTER_DIR_DIRID                   ( DIRID_USER + 0 )

// Directory id of the localquorum directory.
#define CLUSTER_LOCALQUORUM_DIRID           ( DIRID_USER + 1 )


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

// Types of cluster configuration actions.
typedef enum
{
      eCONFIG_ACTION_NONE = -1
    , eCONFIG_ACTION_FORM
    , eCONFIG_ACTION_JOIN
    , eCONFIG_ACTION_CLEANUP
    , eCONFIG_ACTION_UPGRADE
    , eCONFIG_ACTION_MAX
} EBaseConfigAction;


//
// Smart classes
//

// Smart WCHAR array.
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >    SmartSz;

// Smart BYTE array.
typedef CSmartGenericPtr< CArrayPtrTrait< BYTE > >     SmartByteArray;

// Smart SC Manager handle.
typedef CSmartResource<
    CHandleTrait< 
          SC_HANDLE
        , BOOL
        , CloseServiceHandle
        , reinterpret_cast< SC_HANDLE >( NULL )
        >
    > SmartSCMHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cnodeconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CNodeConfig.cpp
//
//  Description:
//      Contains the definition of the CNodeConfig class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JU-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CNodeConfig.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::CNodeConfig
//
//  Description:
//      Constructor of the CNodeConfig class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeConfig::CNodeConfig(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : CNode( pbcanParentActionIn )
{
    TraceFunc( "" );

    // Indicate that action can be rolled back.
    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CNodeConfig::CNodeConfig


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::~CNodeConfig
//
//  Description:
//      Destructor of the CNodeConfig class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeConfig::~CNodeConfig( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CNodeConfig::~CNodeConfig


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::Commit
//
//  Description:
//      Perform the node specific configuration steps.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeConfig::Commit( void )
{
    TraceFunc( "" );

    CStatusReport   srConfigNode(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Configuring_Cluster_Node
        , 0, 1
        , IDS_TASK_CONFIG_NODE
        );

    // Get the parent action pointer.
    CBaseClusterAddNode *  pcanClusterAddNode = dynamic_cast< CBaseClusterAddNode *>( PbcaGetParent() );

    // If the parent action of this action is not CBaseClusterForm
    if ( pcanClusterAddNode == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterAddNode." );
    } // an invalid pointer was passed in.

    // Call the base class commit method.
    BaseClass::Commit();

    // Send the next step of this status report.
    srConfigNode.SendNextStep( S_OK );

    try
    {
        LogMsg( "[BC] Making miscellaneous changes to the node." );

        // Configure the node.
        Configure( pcanClusterAddNode->RStrGetClusterName() );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the configuration.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed commit might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            Cleanup();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srConfigNode.SendNextStep( S_OK );

    TraceFuncExit();

} //*** CNodeConfig::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::Rollback
//
//  Description:
//      Roll the node back to the state it was in before we tried to
//      configure it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeConfig::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Bring the node back to its original state.
    Cleanup();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CNodeConfig::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cservice.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CService.h
//
//  Description:
//      Header file for CService class.
//
//      The CService class is provides several routines that aid in
//      configuring a service.
//
//  Implementation Files:
//      CService.cpp
//
//  Maintained By:
//      Ozan Ozhan  (OzanO) 19-JAN-2002
//      Vij Vasu    (Vvasu) 13-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For basic types
#include <windows.h>

// For HINF
#include <setupapi.h>

// For the string class
#include "CommonDefs.h"

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////
class CStatusReport;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CService
//
//  Description:
//      The CService class is provides several routines that aid in
//      configuring a service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CService
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CService(
        const WCHAR *       pszNameIn
        )
        : m_strName( pszNameIn)
        , m_scWin32ExitCode( ERROR_SUCCESS )
        , m_scServiceExitCode( ERROR_SUCCESS )
    {
    }

    // Destructor
    ~CService() {}


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Create this service in the SCM database.
    void Create( HINF hInfHandleIn );

    // Erase this service from the SCM database.
    void Cleanup( HINF hInfHandleIn );

    // Start this service.
    void Start(
              SC_HANDLE             hServiceControlManagerIn
            , bool                  fWaitForServiceStartIn      = true
            , ULONG                 ulQueryIntervalMilliSecIn   = 500
            , UINT                  cQueryCountIn               = 10
            , CStatusReport *       pStatusReportIn             = NULL
            );

    // Stop this service.
    void Stop(
              SC_HANDLE             hServiceControlManagerIn
            , ULONG                 ulQueryIntervalMilliSecIn   = 500
            , UINT                  cQueryCountIn               = 10
            , CStatusReport *       pStatusReportIn             = NULL
            );

    // Return the m_scWin32ExitCode
    DWORD GetWin32ExitCode( void )
    {
        return m_scWin32ExitCode;
    }

    // Return the m_scServiceSpecificExitCode
    DWORD GetServiceExitCode( void )
    {
        return m_scServiceExitCode;
    }

    // Enable the service
private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    DWORD ScStartService( SC_HANDLE hServiceIn );

    // Copy constructor
    CService( const CService & );

    // Assignment operator
    const CService & operator =( const CService & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The name of this service.
    CStr                m_strName;
    DWORD               m_scWin32ExitCode;
    DWORD               m_scServiceExitCode;

}; // class CService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cstrwrapper.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CStrWrapper.cpp
//
//  Description:
//      This is a dummy file that just includes the precompiled header file
//      for this project and the CStr.cpp file. The reason for doing this
//      is that the files CStr.cpp and CStr.h are intended for use in
//      other projects as well and including pch.h directly in CStr.cpp
//      will make it more diffult to copy and use in other projects.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 27-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header file for this project
#include "pch.h"

// The implementation file for the CStr class. See the 'Description' field
// in the file comment for more details.
#include "CStr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cuuid.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CUuid.cpp
//
//  Description:
//      Contains the definition of the CUuid class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     24-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header file for this class.
#include "CUuid.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUuid::CUuid
//
//  Description:
//      Default constructor of the CUuid class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUuid::CUuid( void )
{
    TraceFunc( "" );

    RPC_STATUS  rsStatus = RPC_S_OK;

    m_pszStringUuid = NULL;

    // Create a UUID.
    rsStatus = UuidCreate( &m_uuid );
    if ( rsStatus != RPC_S_OK )
    {
        LogMsg( "[BC] Error %#08x from UuidCreate().", rsStatus );
        goto Cleanup;
    } // if: UuidCreate() failed

    // Convert it to a string.
    rsStatus = UuidToString( &m_uuid, &m_pszStringUuid );
    if ( rsStatus != RPC_S_OK )
    {
        LogMsg( "[BC] Error %#08x from UuidToString().", rsStatus );
        goto Cleanup;
    } // if: UuidToStrin() failed

Cleanup:

    if ( rsStatus != RPC_S_OK )
    {
        LogMsg( "[BC] Error %#08x occurred trying to initialize the UUID. Throwing an exception.", rsStatus );
        THROW_RUNTIME_ERROR( rsStatus, IDS_ERROR_UUID_INIT );
    } // if: something has gone wrong

    TraceFuncExit();

} //*** CUuid::CUuid


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUuid::~CUuid
//
//  Description:
//      Destructor of the CUuid class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None. 
//
//--
//////////////////////////////////////////////////////////////////////////////
CUuid::~CUuid( void )
{
    TraceFunc( "" );

    if ( m_pszStringUuid != NULL )
    {
        RpcStringFree( &m_pszStringUuid );
    } // if: the string is not NULL

    TraceFuncExit();

} //*** CUuid::~CUuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cuuid.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CUuid.h
//
//  Description:
//      Header file for CUuid class.
//
//      CUuid is a representation of a UUID (universally unique identifier)
//
//  Implementation Files:
//      CUuid.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// Required by Rpcdce.h
#include "rpc.h"

// For UUID and related functions.
#include <Rpcdce.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CUuid
//
//  Description:
//      CUuid is a representation of a UUID (universally unique identifier)
//
//--
//////////////////////////////////////////////////////////////////////////////
class CUuid
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CUuid();

    // Default destructor.
    ~CUuid();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the string that represents this UUID.
    const WCHAR *
        PszGetUuidString() const throw() { return m_pszStringUuid; }

    // Get the UUID of this object.
    const UUID &
        UuidGetUuid() const throw() { return m_uuid; }


private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    UUID        m_uuid;
    WCHAR *     m_pszStringUuid;

}; //*** class CUuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\exceptions.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Exceptions.h
//
//  Description:
//      This file contains the declarations of many exception classes.
//
//  Implementation File:
//      None.
//
//  Maintained By:
//      Ozan Ozhan (OzanO) 19-JAN-2002
//      Vij Vasu   (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>

// For the base class of all exceptions
#include "CException.h"

// For the CStr class
#include "CStr.h"


//////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Shorthand for throwing different exceptions.
//

#define THROW_ASSERT( _hrErrorCode, _pszMessage ) \
    throw CAssert( _hrErrorCode, TEXT( __FILE__ ), __LINE__, TEXT( _pszMessage ) )

#define THROW_RUNTIME_ERROR( _hrErrorCode, _stringId ) \
    throw CRuntimeError( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )

#define THROW_RUNTIME_ERROR_REF( _hrErrorCode, _stringId, _stringRefId ) \
    throw CRuntimeError( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId, _stringRefId )

#define THROW_CONFIG_ERROR( _hrErrorCode, _stringId ) \
    throw CConfigError( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )

#define THROW_ABORT( _hrErrorCode, _stringId ) \
    throw CAbortException( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )


//////////////////////////////////////////////////////////////////////
// External variable declarations
//////////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL
extern HINSTANCE g_hInstance;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CExceptionWithString
//
//  Description:
//      The class is a CException with an additional message string.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CExceptionWithString : public CException
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CException BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( uiErrorStringIdIn );
        m_strErrorRefString = NULL;
    }

    // Constructor ( character string overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( pcszErrorStringIn );
        m_strErrorRefString = NULL;
    }

    // Constructor ( string id & ref string id overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        , UINT          uiErrorRefStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( uiErrorStringIdIn );
        AssignRefString( uiErrorRefStringIdIn );
    }

    // Constructor ( character string & ref character string overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        , const WCHAR * pcszErrorRefStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( pcszErrorStringIn );
        AssignRefString( pcszErrorRefStringIn );
    }

    // Copy constructor.
    CExceptionWithString( const CExceptionWithString & cesuSrcIn )  throw()
        : BaseClass( cesuSrcIn )
        , m_fHasUserBeenNotified( cesuSrcIn.m_fHasUserBeenNotified )
    {
        AssignString( cesuSrcIn.m_strErrorString );
        AssignRefString( cesuSrcIn.m_strErrorRefString );
    }

    // Default destructor.
    ~CExceptionWithString() throw() {}



    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator.
    const CExceptionWithString & 
        operator =( const CExceptionWithString & cesuSrcIn ) throw()
    {
        *( static_cast< BaseClass * >( this ) ) = cesuSrcIn;
        AssignString( cesuSrcIn.m_strErrorString );
        AssignRefString( cesuSrcIn.m_strErrorRefString );
        m_fHasUserBeenNotified = cesuSrcIn.m_fHasUserBeenNotified;
        return *this;
    }

    //
    // Accessor methods.
    //
    const CStr &
        StrGetErrorString() const throw() { return m_strErrorString; }

    void
        SetErrorString( UINT uiErrorStringIdIn ) throw()
    {
        AssignString( uiErrorStringIdIn );
    }

    void
        SetErrorString( const WCHAR * pcszSrcIn ) throw()
    {
        AssignString( pcszSrcIn );
    }

    const CStr &
        StrGetErrorRefString() const throw() { return m_strErrorRefString; }

    void
        SetErrorRefString( UINT uiErrorRefStringIdIn ) throw()
    {
        AssignRefString( uiErrorRefStringIdIn );
    }

    void
        SetErrorRefString( const WCHAR * pcszSrcIn ) throw()
    {
        AssignRefString( pcszSrcIn );
    }

    bool
        FHasUserBeenNotified() const throw() { return m_fHasUserBeenNotified; }

    void
        SetUserNotified( bool fNotifiedIn = true ) throw() { m_fHasUserBeenNotified = fNotifiedIn; }

private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Function to set the member string ( string id overload ).
    void AssignString( UINT uiStringIdIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.LoadString( g_hInstance, uiStringIdIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }

    // Function to set the member string ( character string overload ).
    void AssignString( const WCHAR * pcszSrcIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.Assign( pcszSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }


    // Function to set the member string ( CStr overload ).
    void AssignString( const CStr & rcstrSrcIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.Assign( rcstrSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }

    // Function to set the member REF string ( REF string id overload ).
    void AssignRefString( UINT uiRefStringIdIn ) throw()
    {
        try
        {
            m_strErrorRefString.Empty();
            m_strErrorRefString.LoadString( g_hInstance, uiRefStringIdIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }

    // Function to set the member REF string ( REF character string overload ).
    void AssignRefString( const WCHAR * pcszRefSrcIn ) throw()
    {
        try
        {
            m_strErrorRefString.Empty();
            m_strErrorRefString.Assign( pcszRefSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }


    // Function to set the member REF string ( CStr overload ).
    void AssignRefString( const CStr & rcstrRefSrcIn ) throw()
    {
        try
        {
            m_strErrorRefString.Empty();
            m_strErrorRefString.Assign( rcstrRefSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    // Error message string
    CStr            m_strErrorString;

    // Error reference message string
    CStr            m_strErrorRefString;

    // Indicates if the user has been notified about this exception or not.
    bool            m_fHasUserBeenNotified;

}; //*** class CExceptionWithString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAssert
//
//  Description:
//      This class of exceptions is used to represent programming errors or 
//      invalid assumptions.
//
//      The accompanying message is not expected to be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAssert : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // CAssert ( string id overload ).
    CAssert( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CAssert( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }


}; //*** class CAssert


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CRuntimeError
//
//  Description:
//      This class of exceptions is used to signal runtime errors such as memory
//      exhaustion, failure of Win32 API calls, etc.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CRuntimeError : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload ).
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

    // Constructor ( string id & ref string id overload ).
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        , UINT          uiErrorRefStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn, uiErrorRefStringIdIn )
    {
    }

    // Constructor ( character string & character ref string overload )
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        , const WCHAR * pcszErrorRefStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn, pcszErrorRefStringIn )
    {
    }

}; //*** class CRuntimeError


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAbortException
//
//  Description:
//      This exception is thrown to indicate that the configuration operation
//      was aborted.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAbortException : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload ).
    CAbortException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CAbortException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

}; //*** class CAbortException


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CConfigError
//
//  Description:
//      This class of exceptions is used to signal errors related to cluster
//      configuration. For example, an object of this class is thrown if the
//      OS version of the computer cannot support the requested configuration
//      step.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CConfigError : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload )
    CConfigError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CConfigError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

}; //*** class CConfigError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cstr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CStr.h
//
//  Description:
//      Header file for CStr class.
//
//      CStr is a class the provides the functionality of a string of
//      characters.
//
//      This class is intended to be used instead of std::string since the
//      use of STL is prohibited in our project.
//
//  Implementation File:
//      CStr.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 24-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// For a few platform SDK functions
#include <windows.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStr
//
//  Description:
//      CStr is a class the provides the functionality of a string of
//      characters.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStr
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor
    CStr( void ) throw()
        : m_pszData( const_cast< WCHAR * >( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
    } //*** CStr()

    // Copy constructor
    CStr( const CStr & rcstrSrcIn )
        : m_pszData( const_cast< WCHAR * >( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        Assign( rcstrSrcIn );

    }  //*** CStr( const CStr & )

    // Construct using string ID
    CStr( HINSTANCE hInstanceIn, UINT nStringIdIn )
        : m_pszData( const_cast< WCHAR * >( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        LoadString( hInstanceIn, nStringIdIn );

    } //*** CStr( HINSTANCE, UINT )

    // Construct using string
    CStr( const WCHAR * pcszSrcIn )
        : m_pszData( const_cast< WCHAR * >( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        Assign( pcszSrcIn );

    } //*** CStr( const WCHAR * )

    // Construct using buffer size
    CStr( UINT cchBufferSize, WCHAR chInitialChar = ms_chNull )
        : m_pszData( const_cast< WCHAR * >( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        if ( cchBufferSize > 0 )
        {
            AllocateBuffer( cchBufferSize );

            _wcsnset( m_pszData, chInitialChar, cchBufferSize );
            m_pszData[ cchBufferSize - 1 ] = ms_chNull;
            m_nLen = (UINT) wcslen( m_pszData );
        }
    } //*** CStr( UINT cchBufferSize, WCHAR chInitialChar )

    // Destructor
    ~CStr( void ) throw()
    {
        Free();

    } //*** ~CStr()


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Assign another CStr to this one.
    void Assign( const CStr & rcstrSrcIn )
    {
        UINT nSrcLen = rcstrSrcIn.m_nLen;

        if ( nSrcLen != 0 )
        {
            AllocateBuffer( nSrcLen + 1 );
            m_nLen = nSrcLen;
            THR( StringCchCopyNW( m_pszData, m_cchBufferSize, rcstrSrcIn.m_pszData, nSrcLen ) );
            
        } // if: the source string is not empty
        else
        {
            // Clean up existing string.
            Empty();
        } // if: the source string is empty

    } //*** Assign( const CStr & )

    // Assign a character string to this one.
    void Assign( const WCHAR * pcszSrcIn )
    {
        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = (UINT) wcslen( pcszSrcIn );

            AllocateBuffer( nSrcLen + 1 );
            m_nLen = nSrcLen;
            THR( StringCchCopyNW( m_pszData, m_cchBufferSize, pcszSrcIn, nSrcLen ) );
        } // if: the source string is not NULL
        else
        {
            // Clean up existing string.
            Empty();
        } // else: the source string is NULL

    } //*** Assign( const WCHAR * )

    // Free the buffer for this string
    void Free( void ) throw()
    {
        if ( m_pszData != &ms_chNull )
        {
            delete m_pszData;
        } // if: the pointer was dynamically allocated

        m_pszData = const_cast< WCHAR * >( &ms_chNull );
        m_nLen = 0;
        m_cchBufferSize = 0;
    } //*** Free()

    // Empty this string
    void Empty( void ) throw()
    {
        if ( m_nLen != 0 )
        {
            *m_pszData = ms_chNull;
            m_nLen = 0;
        } // if: the string is not already empty
    } //*** Empty()

    // Load a string from the resource table and assign it to this string.
    void LoadString( HINSTANCE hInstIn, UINT nStringIdIn );


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get a pointer to the underlying string
    const WCHAR * PszData( void ) const throw()
    {
        return m_pszData;

    } //*** PszData()


    // Get the length of the string.
    UINT NGetLen( void ) const throw()
    {
        return m_nLen;

    } //*** NGetLen()

    // Get the size of the string buffer.
    UINT NGetSize( void ) const throw()
    {
        return m_cchBufferSize;

    } //*** NGetSize()

    // Is this string empty?
    bool FIsEmpty( void ) const throw()
    {
        return ( m_nLen == 0 );

    } //*** FIsEmpty()


    //////////////////////////////////////////////////////////////////////////
    // Public operators
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator ( const CStr & )
    const CStr & operator=( const CStr & rcstrSrcIn )
    {
        Assign( rcstrSrcIn );
        return *this;

    } //*** operator=( const CStr & )

    // Assignment operator ( const WCHAR * )
    const CStr & operator=( const WCHAR * pcszSrcIn )
    {
        Assign( pcszSrcIn );
        return *this;

    } //*** operator=( const WCHAR * )

    // Concatenation operator ( const CStr & )
    CStr operator+( const CStr & rcstrSrcIn ) const
    {
        CStr strReturn( m_nLen + rcstrSrcIn.m_nLen + 1 );

        strReturn.Assign( *this );
        strReturn.Concatenate( rcstrSrcIn.m_pszData, rcstrSrcIn.m_nLen );

        return strReturn;

    } //*** operator+( const CStr & )

    // Concatenation operator ( const WCHAR * )
    CStr operator+( const WCHAR * pcszSrcIn ) const
    {

        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = (UINT) wcslen( pcszSrcIn );
            CStr strReturn( m_nLen + nSrcLen + 1);

            strReturn.Assign( *this );
            strReturn.Concatenate( pcszSrcIn, nSrcLen );

            return strReturn;
        } // if: the string to be concatenated is not empty
        else
        {
            return *this;
        } // else: the string to be concatenated is empty

    } //*** operator+( const WCHAR * )

    // Append operator ( const CStr & )
    const CStr & operator+=( const CStr & rcstrSrcIn )
    {
        Concatenate( rcstrSrcIn.m_pszData, rcstrSrcIn.m_nLen );
        return *this;

    } //*** operator+( const CStr & )

    // Append operator ( const WCHAR * )
    const CStr & operator+=( const WCHAR * pcszSrcIn )
    {
        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = (UINT) wcslen( pcszSrcIn );
            Concatenate( pcszSrcIn, nSrcLen );
        } // if: the string to be appended is not empty

        return *this;

    } //*** operator+( const WCHAR * )


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Allocate a buffer of the required size.
    void AllocateBuffer( UINT cchBufferSizeIn );

    // Concatenation function.
    void Concatenate(
          const WCHAR * pcszStr2In
        , UINT nStr2LenIn
        )
    {
        AllocateBuffer( m_nLen + nStr2LenIn + 1);

        // Copy the strings to the destination.
        THR( StringCchCopyNW( m_pszData + m_nLen, m_cchBufferSize - m_nLen, pcszStr2In, nStr2LenIn ) );
        m_nLen += nStr2LenIn;

    } //*** Concatenate()


    //////////////////////////////////////////////////////////////////////////
    // Private class data
    //////////////////////////////////////////////////////////////////////////

    // The NULL character. All empty CStrs point here.
    static const WCHAR ms_chNull = L'\0';


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////
    WCHAR *     m_pszData;
    UINT        m_nLen;
    UINT        m_cchBufferSize;

}; //*** class CStr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cstr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CStr.cpp
//
//  Description:
//      Contains the definition of the CStr class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The header file of this class
#include "CStr.h"

// For the exceptions thrown by CStr
#include "CException.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStr::LoadString
//
//  Description:
//      Lookup a string in a string table using a string id.
//
//  Arguments:
//      hInstIn
//          Instance handle of the module containing the string table resource.
//
//      uiStringIdIn
//          Id of the string to look up
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CException
//          If the lookup fails.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
void
CStr::LoadString( HINSTANCE hInstIn, UINT nStringIdIn )
{
    TraceFunc1( "nStringIdIn = %d", nStringIdIn );

    UINT        uiCurrentSize = 0;
    WCHAR *     pszCurrentString = NULL;
    UINT        uiReturnedStringLen = 0;

    do
    {
        // Free the string allocated in the previous iteration.
        delete [] pszCurrentString;

        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        pszCurrentString = new WCHAR[ uiCurrentSize ];
        if ( pszCurrentString == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadString(
                                  hInstIn
                                , nStringIdIn
                                , pszCurrentString
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            HRESULT hrRetVal = TW32( GetLastError() );
            hrRetVal = HRESULT_FROM_WIN32( hrRetVal );
            delete [] pszCurrentString;

            THROW_EXCEPTION( hrRetVal );

        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    // Free the existing string.
    Free();

    // Store details about the newly allocated string in the member variables.
    m_pszData = pszCurrentString;
    m_nLen = uiReturnedStringLen;
    m_cchBufferSize = uiCurrentSize;

    TraceFuncExit();

} //*** CStr::LoadString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStr::AllocateBuffer
//
//  Description:
//      Allocate a buffer of cchBufferSizeIn characters. If the existing buffer is not
//      smaller than cchBufferSizeIn characters, nothing is done. Otherwise, a new
//      buffer is allocated and the old contents are filled into this buffer.
//
//  Arguments:
//      cchBufferSizeIn
//          Required size of the new buffer in characters.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CException
//          If the memory allocation fails.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CStr::AllocateBuffer( UINT cchBufferSizeIn )
{
    TraceFunc1( "cchBufferSizeIn = %d", cchBufferSizeIn );

    // Check if the buffer is already big enough
    if ( m_cchBufferSize < cchBufferSizeIn )
    {
        WCHAR * psz = new WCHAR[ cchBufferSizeIn ];
        if ( psz == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        // Copy the old data into the new buffer.
        THR( StringCchCopyNW( psz, cchBufferSizeIn, m_pszData, m_nLen ) );

        if ( m_pszData != &ms_chNull )
        {
            delete m_pszData;
        } // if: the pointer was dynamically allocated

        m_pszData = psz;
        m_cchBufferSize = cchBufferSizeIn;
    }

    TraceFuncExit();

} //*** CStr::AllocateBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\globalfuncs.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.cpp
//
//  Description:
//      Contains the definitions of a few unrelated global functions
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// Needed by Dll.h
#include "CFactory.h"

// For g_hInstance
#include "Dll.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  UINT
//  g_GenericSetupQueueCallback
//
//  Description:
//      A generic callback used by SetupAPI file operations.
//
//  Arguments:
//      pvContextIn
//          Context used by this function. Ignored.
//
//      uiNotificationIn
//          The type of notification being sent.
//
//      uiParam1In
//      uiParam2In
//          Additional notification information.
//
//
//  Return Value:
//      During the SPFILENOTIFY_DELETEERROR notification, FILEOP_SKIP is returned
//      if the file does not exist. Otherwise, FILEOP_ABORT is returned.
//
//      FILEOP_DOIT is returned in all other cases.
//
//  Exceptions Thrown:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
UINT
CALLBACK
g_GenericSetupQueueCallback(
      PVOID     // pvContextIn         // context used by the callback routine
    , UINT      uiNotificationIn    // queue notification
    , UINT_PTR  uiParam1In          // additional notification information
    , UINT_PTR  // uiParam2In          // additional notification information
    )
{
    TraceFunc( "" );

    UINT    uiRetVal = FILEOP_DOIT;

    switch( uiNotificationIn )
    {
        case SPFILENOTIFY_DELETEERROR:
        {
            // For this notification uiParam1In is a pointer to a FILEPATHS structure.
            FILEPATHS * pfFilePaths = reinterpret_cast< FILEPATHS * >( uiParam1In );

            if ( pfFilePaths->Win32Error == ERROR_FILE_NOT_FOUND )
            {
                // If the file to be deleted was not found, just skip it.
                uiRetVal = FILEOP_SKIP;
            } // if: the file to be deleted does not exist.
            else
            {
                LogMsg( 
                      "[BC] g_GenericSetupQueueCallback() => Error %#08x has occurred while deleting the '%s' file. Aborting."
                    , pfFilePaths->Win32Error
                    , pfFilePaths->Target
                    );

                uiRetVal = FILEOP_ABORT;
            } // else: some other error occurred.
        }
        break;
    }

    RETURN( uiRetVal );

} //*** g_GenericSetupQueueCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cstatusreport.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CStatusReport.h
//
//  Description:
//      Header file for CStatusReport class.
//
//      CStatusReport is a class the provides the functionality sending a
//      status report.
//
//  Implementation File:
//      CStatusReport.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    30-MAR-2001
//      Vij Vasu        (Vvasu)     05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// A few common declarations
#include "CommonDefs.h"

// For the exceptions thrown by this class.
#include "Exceptions.h"

// For the CBCAInterface class
#include "CBCAInterface.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStatusReport
//
//  Description:
//      CStatusReport is a class the provides the functionality sending a
//      status report. Each status report can have a number of steps. For
//      example, the task of creating the cluster service could have 4 steps,
//
//      The user interface is so designed that if the first step of a report is
//      sent, the last one has to be sent as well, even if an error occurs after
//      sending the first one. This class queues the last status report for 
//      sending in case and exception occurs and the last report has not been
//      sent yet.
//
//      It is not possible to send the last, outstanding status report from the
//      destructor of this class since the error code contained in the exception 
//      that is causing this object to be destroyed is not known. So, this last
//      status report is queued with the CBCAInterface object which will send this
//      report once the exception has been caught.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStatusReport
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CStatusReport(
          CBCAInterface * pbcaiInterfaceIn
        , const CLSID &   clsidTaskMajorIn
        , const CLSID &   clsidTaskMinorIn
        , ULONG           ulMinIn
        , ULONG           ulMaxIn
        , UINT            idsDescriptionStringIdIn
        )
        : m_pbcaiInterface( pbcaiInterfaceIn )
        , m_clsidTaskMajor( clsidTaskMajorIn )
        , m_clsidTaskMinor( clsidTaskMinorIn )
        , m_ulMin( ulMinIn )
        , m_ulMax( ulMaxIn )
        , m_ulNext( ulMinIn )
        , m_idsDescriptionStringId( idsDescriptionStringIdIn )
        , m_idsReferenceStringId( 0 )
        , m_fLastStepSent( false )
    {
        TraceFunc( "" );

        // Validate the parameters.
        if (    ( pbcaiInterfaceIn == NULL )
             || ( ulMinIn > ulMaxIn )
           )
        {
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The parameters for this status report are invalid." );
        } // if: the parameters are invalid

        TraceFuncExit();

    } //*** CStatusReport::CStatusReport


    // Constructor.
    CStatusReport(
          CBCAInterface * pbcaiInterfaceIn
        , const CLSID &   clsidTaskMajorIn
        , const CLSID &   clsidTaskMinorIn
        , ULONG           ulMinIn
        , ULONG           ulMaxIn
        , UINT            idsDescriptionStringIdIn
        , UINT            idsReferenceStringIdIn
        )
        : m_pbcaiInterface( pbcaiInterfaceIn )
        , m_clsidTaskMajor( clsidTaskMajorIn )
        , m_clsidTaskMinor( clsidTaskMinorIn )
        , m_ulMin( ulMinIn )
        , m_ulMax( ulMaxIn )
        , m_ulNext( ulMinIn )
        , m_idsDescriptionStringId( idsDescriptionStringIdIn )
        , m_idsReferenceStringId( idsReferenceStringIdIn )
        , m_fLastStepSent( false )
    {
        TraceFunc( "" );

        // Validate the parameters.
        if (    ( pbcaiInterfaceIn == NULL )
             || ( ulMinIn > ulMaxIn )
           )
        {
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The parameters for this status report are invalid." );
        } // if: the parameters are invalid

        TraceFuncExit();

    } //*** CStatusReport::CStatusReport

    // Default destructor.
    ~CStatusReport( void )
    {
        TraceFunc( "" );

        // If the last step has not been sent, queue it for sending. This is most probably because
        // an exception has occurred (if no exception has occurred and the last step has not been
        // sent, then it is a programming error).
        if ( ! m_fLastStepSent )
        {
            // The last step has not been sent.

            // Don't throw exceptions from destructor. An unwind may already be in progress.
            try
            {
                // Queue the last step for sending. The CBCAInterface object will fill in the
                // error code from the current exception and send this report.
                m_pbcaiInterface->QueueStatusReportCompletion(
                      m_clsidTaskMajor
                    , m_clsidTaskMinor
                    , m_ulMin
                    , m_ulMax
                    , m_idsDescriptionStringId
                    , m_idsReferenceStringId
                    );
            }
            catch( ... )
            {
                // Catch all errors. Do not rethrow this exception - the app may be terminated due to
                // a collided unwind - so log the error.

                THR( E_UNEXPECTED );

                LogMsg( "[BC] Caught an exception while trying to send the last step of a status report during cleanup." );
            }
        }

        TraceFuncExit();

    } //*** CStatusReport::~CStatusReport


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Send the next step of this report.
    void SendNextStep( HRESULT hrStatusIn, UINT idsDescriptionStringIdIn = 0, UINT idsReferenceStringIdIn = 0 )
    {
        TraceFunc( "" );

        if ( m_fLastStepSent )
        {
            LogMsg( "[BC] The last step for this status report has already been sent! Throwing an exception." );
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The last step for this status report has already been sent." );
        } // if: the last step has already been sent
        else
        {
            if ( idsDescriptionStringIdIn == 0 )
            {
                idsDescriptionStringIdIn = m_idsDescriptionStringId;
            }

            if ( idsReferenceStringIdIn == 0 )
            {
                idsReferenceStringIdIn = m_idsReferenceStringId;
            }

            m_pbcaiInterface->SendStatusReport(
                  m_clsidTaskMajor
                , m_clsidTaskMinor
                , m_ulMin
                , m_ulMax
                , m_ulNext
                , hrStatusIn
                , idsDescriptionStringIdIn
                , idsReferenceStringIdIn
                );

            ++m_ulNext;

            m_fLastStepSent = ( m_ulNext > m_ulMax );
        } // else: the last step has not been sent

        TraceFuncExit();

    } //*** CStatusReport::SendNextStep

    // Send the last step of this report, if it hasn't been sent already.
    void SendLastStep( HRESULT hrStatusIn, UINT idsDescriptionStringIdIn = 0, UINT idsReferenceStringIdIn = 0 )
    {
        TraceFunc( "" );

        if ( m_fLastStepSent )
        {
            LogMsg( "[BC] The last step for this status report has already been sent! Throwing an exception." );
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The last step for this status report has already been sent." );
        } // if: the last step has already been sent
        else
        {
            if ( idsDescriptionStringIdIn == 0 )
            {
                idsDescriptionStringIdIn = m_idsDescriptionStringId;
            }

            if ( idsReferenceStringIdIn == 0 )
            {
                idsReferenceStringIdIn = m_idsReferenceStringId;
            }

            m_pbcaiInterface->SendStatusReport(
                  m_clsidTaskMajor
                , m_clsidTaskMinor
                , m_ulMin
                , m_ulMax
                , m_ulMax
                , hrStatusIn
                , idsDescriptionStringIdIn
                , idsReferenceStringIdIn
                );

            m_fLastStepSent = true;
        } // else: the last step has not been sent

        TraceFuncExit();

    } //*** CStatusReport::SendLastStep

    // Get the description string ID.
    UINT IdsGetDescriptionStringId( void )
    {
        return m_idsDescriptionStringId;
    }

    // Set the description string ID.
    void SetDescriptionStringId( UINT idsDescriptionStringIdIn )
    {
        m_idsDescriptionStringId = idsDescriptionStringIdIn;
    }

    // Get the reference string ID.
    UINT IdsGetReferenceStringId( void )
    {
        return m_idsReferenceStringId;
    }

    // Set the reference string ID.
    void SetReferenceStringId( UINT idsReferenceStringIdIn )
    {
        m_idsReferenceStringId = idsReferenceStringIdIn;
    }

private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the interface class.
    CBCAInterface *         m_pbcaiInterface;
    
    // The major and minor class id to be sent with this status report.
    CLSID                   m_clsidTaskMajor;
    CLSID                   m_clsidTaskMinor;

    // The range for this status report
    ULONG                   m_ulMin;
    ULONG                   m_ulMax;
    ULONG                   m_ulNext;

    // The string id of the description to be sent with this status report
    UINT                    m_idsDescriptionStringId;

    // The REF string id of the description to be sent with this status report
    UINT                    m_idsReferenceStringId;

    // Flag to indicate if the last step has been sent.
    bool                    m_fLastStepSent;

}; //*** class CStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\globalfuncs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.h
//
//  Description:
//      Contains the declarations of a few unrelated global functions
//
//  Implementation Files:
//      GlobalFuncs.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Global function declarations.
//////////////////////////////////////////////////////////////////////////

// Generic callback function used by setupapi file operations.
UINT
CALLBACK
g_GenericSetupQueueCallback(
      PVOID     pvContextIn         // context used by the callback routine
    , UINT      uiNotificationIn    // queue notification
    , UINT_PTR  uiParam1In          // additional notification information
    , UINT_PTR  uiParam2In          // additional notification information
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\test\baseclustertest.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      BaseClusterTest.h
//
//  Description:
//      Header file for BaseClusterTest.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>


////////////////////////////////////////////////////////////////////////////////
// Function declarations
//////////////////////////////////////////////////////////////////////////////

void ShowUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file for the BaseCluster library.
//
//  Maintained By:
//      Ozan Ozhan      (OzanO)     22-MAR-2002
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#define USES_SYSALLOCSTRING

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

// The next three files have to be the first files to be included.If nt.h comes
// after windows.h, NT_INCLUDED will not be defined and so, winnt.h will be
// included. This will give errors later, if ntdef.h is included. But ntdef has
// types which winnt.h does not have, so the chicken and egg problem.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ComCat.h>

// For the ResUtil functions
#include <ResAPI.h>

// Contains setup API function declarations
#include <setupapi.h>

// For serveral common macros
#include <clusudef.h>

// For various cluster RTL routines and definitions.
#include <clusrtl.h>

// For CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION and other version defines.
#include <clusverp.h>

// For CsRpcGetJoinVersionData() and constants like JoinVersion_v2_0_c_ifspec
#include <ClusRPC.h>

#include <StrSafe.h>


// For debugging functions.
#define DEBUG_SUPPORT_EXCEPTIONS
#include <Debug.h>

// For TraceInterface
#include <CITracker.h>

// For LogMsg
#include <Log.h>

#include <Common.h>

// For the notification guids.
#include <Guids.h>
#include "BaseClusterGuids.h"

// For published ClusCfg guids
#include <ClusCfgGuids.h>



// For the CStr class
#include "CStr.h"

// For the CBString class
#include "CBString.h"

// A few common declarations
#include "CommonDefs.h"

// For resource ids
#include "BaseClusterStrings.h"

// For smart classes
#include "SmartClasses.h"

// For the exception classes.
#include "Exceptions.h"

// For CAction
#include "CAction.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For the CRegistryKey class
#include "CRegistryKey.h"

// For the CBCAInterface class.
#include "CBCAInterface.h"

// For the CStatusReport class
#include "CStatusReport.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\listtest\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////


#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#include <windows.h>

extern HINSTANCE g_hInstance;

// For the debugging macros.
#include "debug.h"

#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\test\ccluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      Header file for CClusCfgCallback.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the IClusCfgCallback interface
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCallback
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCallback
    : public IClusCfgCallback
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //////////////////////////////////////////////////////////////////////////

    // Constructor
    CClusCfgCallback( void );

    // Destructor
    ~CClusCfgCallback( void );


    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SendStatusReport )(
            BSTR        bstrNodeNameIn,
            CLSID       clsidTaskMajorIn,
            CLSID       clsidTaskMinorIn,
            ULONG       ulMinIn,
            ULONG       ulMaxIn,
            ULONG       ulCurrentIn,
            HRESULT     hrStatusIn,
            BSTR        bstrDescriptionIn,
            FILETIME *  pftTimeIn,
            BSTR        bstrReferenceIn
            );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                m_cRef;

}; //*** class CClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\listtest\listtest.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ListTest.cpp
//
//  Description:
//      Main file for the application used to test CList
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#include <windows.h>

HINSTANCE g_hInstance;
LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

// For the debugging macros.
#include "debug.h"

// For printf
#include <stdio.h>

// For CList
#include "CList.h"

// Globals
int g_nPrintDepth = 1;

DEFINE_MODULE( "ListTest" )

// Test class
class CTestClass
{
public:
    static int ms_nObjectNo;
    int m_nId;

    CTestClass()
    {
        ++ms_nObjectNo;
        m_nId  = ms_nObjectNo;
        wprintf( L"%*cConstructing CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
    }

    CTestClass( const CTestClass & src )
    {
        ++ms_nObjectNo;
        m_nId  = src.m_nId;
        wprintf( L"%*cConstructing CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
    }

    ~CTestClass()
    {
        wprintf( L"%*cDestroying CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
        --ms_nObjectNo;
    }

private:
    const CTestClass & operator=( const CTestClass & );

}; //*** class CTestClass

int CTestClass::ms_nObjectNo = 0;

void PrintId( CList< CTestClass >::CIterator & iter )
{
    wprintf( L"%d", iter->m_nId );
}


void PrintId( CList< CTestClass * >::CIterator & iter )
{
    wprintf( L"%d", (*iter)->m_nId );
}


void PrintId( CList< int >::CIterator & iter )
{
    wprintf( L"%d", *iter );
}


template< class t_Ty > void PrintForwardList( CList<t_Ty> & l )
{
    g_nPrintDepth += 4;
    wprintf( L"%*cPrinting forward list element ids...\n", g_nPrintDepth, L' ' );

    CList<t_Ty>::CIterator s = l.CiBegin();
    CList<t_Ty>::CIterator e = l.CiEnd();

    wprintf( L"%*c+ ", g_nPrintDepth, L' ' );
    while( s != e )
    {
        PrintId( s );
        wprintf( L" " );
        ++s;
    }

    wprintf( L" +\n" );

    g_nPrintDepth -= 4;
}

template< class t_Ty > void PrintReverseList( CList<t_Ty> & l )
{
    g_nPrintDepth += 4;
    wprintf( L"%*cPrinting reverse list element ids...\n", g_nPrintDepth, L' ' );

    CList<t_Ty>::CIterator s = l.CiEnd();
    CList<t_Ty>::CIterator e = l.CiEnd();

    wprintf( L"%*c+ ", g_nPrintDepth, L' ' );

    --s;
    while( s != e )
    {
        PrintId( s );
        wprintf( L" " );
        --s;
    }

    wprintf( L"+\n" );

    g_nPrintDepth -= 4;
}

template< class t_Ty > void CheckSize( CList<t_Ty> & l, int size )
{
    if ( l.CGetSize() != size )
    {
        wprintf( L"%*cERROR: The list should be %d. It is %d.\n", g_nPrintDepth, L' ', size, l.CGetSize() );
        throw L"List size";
    }
}

// Test a list of integers
template< class t_Ty > void TestList( t_Ty array[], int arrSize ) 
{
    int idx;

    wprintf( L"%*c|-------------------------------------------------------------------|\n", g_nPrintDepth, L' ' );
    g_nPrintDepth += 4;


    wprintf( L"\n%*cConstructing empty list.\n", g_nPrintDepth, L' ' );
    CList<t_Ty> l;
    CheckSize( l, 0 );

    {
        CList<t_Ty>::CIterator b = l.CiBegin();
        CList<t_Ty>::CIterator e = l.CiEnd();

        wprintf( L"\n%*cChecking if beginning and end of empty list are the same... ", g_nPrintDepth, L' ' );
        if ( ( b == e ) && !( b != e ) )
        {
            wprintf( L"Passed\n" );
        }
        else
        {
            wprintf( L"Failed\n" );
            throw L"Empty list iterator";
        }
    }

    wprintf( L"\n%*cPrinting empty list...\n", g_nPrintDepth, L' ' );
    PrintForwardList( l );
    PrintReverseList( l );

    {
        wprintf( L"\n%*cAdding one element to list\n", g_nPrintDepth, L' ' );
        
        l.Append( array[0] );
        CheckSize( l, 1 );

        PrintForwardList( l );
        PrintReverseList( l );
    }

    {
        wprintf( L"\n%*cAdding %d more elements\n", g_nPrintDepth, L' ', arrSize - 1 );
        CList<t_Ty>::CIterator iter = l.CiBegin();

        for ( idx = 1; idx < arrSize; )
        {
            l.InsertAfter( iter, array[idx] );
            ++iter;
            ++idx;
            CheckSize( l, idx );
        }

        PrintForwardList( l );
        PrintReverseList( l );
    }

    {
        wprintf( L"\n%*cDeleting elements\n", g_nPrintDepth, L' ', arrSize - 1 );
        CList<t_Ty>::CIterator iter = l.CiBegin();
        CList<t_Ty>::CIterator end = l.CiEnd();

        idx = arrSize;
        while( iter != end )
        {
            --idx;
            l.DeleteAndMoveToNext( iter );
            CheckSize( l, idx );
        }

        PrintForwardList( l );
        PrintReverseList( l );
    }

    g_nPrintDepth -= 4;
    wprintf( L"%*c|-------------------------------------------------------------------|\n", g_nPrintDepth, L' ' );
}


int __cdecl wmain( void )
{
    int nRetVal = 0;

    g_hInstance = GetModuleHandle( NULL );

    TraceInitializeProcess( NULL, NULL );
    TraceCreateMemoryList( g_GlobalMemoryList );

    g_tfModule = mtfMEMORYLEAKS;

    try
    {
        {
            wprintf( L"%*cTesting CTestClass list.\n", g_nPrintDepth, L' ' );
            CTestClass arr[ 4 ];

            TestList< CTestClass >( arr, 4 );
        }

        {
            wprintf( L"\n%*cTesting CTestClass pointer list.\n", g_nPrintDepth, L' ' );

            CTestClass * arr[ 5 ];
            int idx;

            for ( idx = 0; idx < 5; ++idx )
                arr[idx] = new CTestClass;

            TestList< CTestClass * >( arr, 5 );

            for ( idx = 0; idx < 5; ++idx )
                delete arr[idx];

        }

        {
            int arr[] = { 1, 2, 3, 4 };

            wprintf( L"\n%*cTesting int list.\n", g_nPrintDepth, L' ' );
            TestList< int >( arr, sizeof( arr ) / sizeof( arr[0] ) );
        }
    }
    catch( WCHAR * pszTestName )
    {
        wprintf( L"Test '%s' failed.\n", pszTestName );
    }
    catch( ... )
    {
        wprintf( L"Caught an unknown exception.\n" );
        nRetVal = 1;
    }

    TraceTerminateMemoryList( g_GlobalMemoryList );
    TraceTerminateProcess( NULL, NULL );

    return nRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\test\baseclustertest.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      BaseClusterTest.cpp
//
//  Description:
//      Main file for the test harness executable.
//      Initializes tracing, parses command line and actually call the 
//      BaseClusCfg functions.
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>
#include <objbase.h>
#include <limits.h>

#include <initguid.h>
#include "guids.h"

#include "CClusCfgCallback.h"


// Show help for this executable.
void ShowUsage()
{
    wprintf( L"\nThe syntax of this command is:\n" );
    wprintf( L"\nBaseClusterTest.exe [computer-name] {<options>}\n" );
    wprintf( L"\n<options> =\n" );
    wprintf( L"  /FORM NAME= cluster-name DOMAIN= account-domain ACCOUNT= clussvc-account\n" );
    wprintf( L"        PASSWORD= account-password IPADDR= ip-address(hex)\n" );
    wprintf( L"        SUBNET= ip-subnet-mask(hex) NICNAME= ip-nic-name\n\n" );
    wprintf( L"  /JOIN NAME= cluster-name DOMAIN= account-domain ACCOUNT= clussvc-account\n" );
    wprintf( L"        PASSWORD= account-password\n\n" );
    wprintf( L"  /CLEANUP\n" );
    wprintf( L"\nNotes:\n" );
    wprintf( L"- A space is required after an '=' sign.\n" );
    wprintf( L"- The order for the parameters has to be the same as shown above.\n" );
}


// Create the BaseCluster component.
HRESULT HrInitComponent(
      COSERVERINFO *  pcoServerInfoPtrIn
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;

    do
    {
        MULTI_QI mqiInterfaces[] = 
        {
            { &IID_IClusCfgBaseCluster, NULL, S_OK },
            { &IID_IClusCfgInitialize, NULL, S_OK }
        };

        //
        // Create and initialize the BaseClusterAction component
        //

        hr = CoCreateInstanceEx(
                  CLSID_ClusCfgBaseCluster
                , NULL
                , CLSCTX_LOCAL_SERVER 
                , pcoServerInfoPtrIn
                , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
                , mqiInterfaces
                );

        // Store the retrieved pointers in smart pointers for safe release.
        rspClusCfgBaseClusterIn.Attach( 
              reinterpret_cast< IClusCfgBaseCluster * >( mqiInterfaces[0].pItf )
            );


        CSmartIfacePtr< IClusCfgInitialize > spClusCfgInitialize;
        
        spClusCfgInitialize.Attach( reinterpret_cast< IClusCfgInitialize * >( mqiInterfaces[1].pItf ) );

        // Check if CoCreateInstanceEx() worked.
        if ( FAILED( hr ) && ( hr != CO_S_NOTALLINTERFACES ) )
        {
            wprintf( L"Could not create the BaseCluster component. Error %#08x.\n", hr );
            break;
        } // if: CoCreateInstanceEx() failed

        // Check if we got the pointer to the IClusCfgBaseCluster interface.
        hr = mqiInterfaces[0].hr;
        if ( FAILED( hr ) )
        {
            // We cannot do anything without this pointer - bail.
            wprintf( L"Could not get the IClusCfgBaseCluster pointer. Error %#08x.\n", hr );
            break;
        } // if: we could not get a pointer to the IClusCfgBaseCluster interface

        //
        // Check if we got a pointer to the IClusCfgInitialize interface
        hr = mqiInterfaces[1].hr;
        if ( hr == S_OK )
        {
            // We got the pointer - initialize the component.

            IUnknown * punk = NULL;
            IClusCfgCallback * pccb = NULL;

            hr = CClusCfgCallback::S_HrCreateInstance( &punk );
            if ( FAILED( hr ) )
            {
                wprintf( L"Could not initalize callback component. Error %#08x.\n", hr );
                break;
            }

            hr = punk->QueryInterface< IClusCfgCallback >( &pccb );
            punk->Release( );
            if ( FAILED( hr ) )
            {
                wprintf( L"Could not find IClusCfgCallback on CClusCfgCallback object. Error %#08x.\n", hr );
                break;
            }

            hr = spClusCfgInitialize->Initialize( pccb, LOCALE_SYSTEM_DEFAULT );

            if ( pccb != NULL )
            {
                pccb->Release();
            } // if: we created a callback, release it.

            if ( FAILED( hr ) )
            {
                if ( hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
                {
                    wprintf( L"Access was denied trying to initialize the BaseCluster component. This may be because remote callbacks are not supported. However, configuration will proceed.\n" );
                    hr = ERROR_SUCCESS;
                } // if: the error was ERROR_ACCESS_DENIED
                else
                {
                    wprintf( L"Could not initialize the BaseCluster component. Error %#08x occurred. Configuration will be aborted.\n", hr );
                    break;
                } // else: some other error occurred.
            } // if: something went wrong during initialization

        } // if: we got a pointer to the IClusCfgInitialize interface
        else
        {
            wprintf( L"The BaseCluster component does not provide notifications.\n" );
            if ( hr != E_NOINTERFACE )
            {
                break;
            } // if: the interface is supported, but something else went wrong.

            //
            // If the interface is not support, that is ok. It just means that
            // initialization is not required.
            //
            hr = S_OK;
        } // if: we did not get a pointer to the IClusCfgInitialize interface
    }
    while( false );

    return hr;
}


HRESULT HrFormCluster(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 16 )
        {
            wprintf( L"FORM: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to form a cluster...\n");

        // Cluster name.
        if ( ClRtlStrICmp( argv[2], L"NAME=" ) != 0 )
        {
            wprintf( L"Expected 'NAME='. Got '%s'.\n", argv[2] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterName = argv[3];
        wprintf( L"  Cluster Name = '%s'\n", pszClusterName );

        // Cluster account domain
        if ( ClRtlStrICmp( argv[4], L"DOMAIN=" ) != 0 )
        {
            wprintf( L"Expected 'DOMAIN='. Got '%s'.\n", argv[4] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        
        WCHAR * pszClusterAccountDomain = argv[5];
        wprintf( L"  Cluster Account Domain = '%s'\n", pszClusterAccountDomain );


        // Cluster account name.
        if ( ClRtlStrICmp( argv[6], L"ACCOUNT=" ) != 0 )
        {
            wprintf( L"Expected 'ACCOUNT='. Got '%s'.\n", argv[6] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountName = argv[7];
        wprintf( L"  Cluster Account Name = '%s'\n", pszClusterAccountName );


        // Cluster account password.
        if ( ClRtlStrICmp( argv[8], L"PASSWORD=" ) != 0 )
        {
            wprintf( L"Expected 'PASSWORD='. Got '%s'.\n", argv[8] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountPwd = argv[9];
        wprintf( L"  Cluster Account Password = '%s'\n", pszClusterAccountPwd );


        // Cluster IP address.
        if ( ClRtlStrICmp( argv[10], L"IPADDR=" ) != 0 )
        {
            wprintf( L"Expected 'IPADDR='. Got '%s'.\n", argv[10] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pTemp;

        ULONG ulClusterIPAddress = wcstoul( argv[11], &pTemp, 16 );
        if (   ( ( argv[11] + wcslen( argv[11] ) ) != pTemp )
            || ( ulClusterIPAddress == ULONG_MAX ) )
        {
            wprintf( L"Could not convert '%s' to an IP address.\n", argv[11] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        wprintf(
              L"  Cluster IP Address = %d.%d.%d.%d\n"
            , ( ulClusterIPAddress & 0xFF000000 ) >> 24
            , ( ulClusterIPAddress & 0x00FF0000 ) >> 16
            , ( ulClusterIPAddress & 0x0000FF00 ) >> 8
            , ( ulClusterIPAddress & 0x000000FF )
            );


        // Cluster IP subnet mask.
        if ( ClRtlStrICmp( argv[12], L"SUBNET=" ) != 0 )
        {
            wprintf( L"Expected 'SUBNET='. Got '%s'.\n", argv[12] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        ULONG ulClusterIPSubnetMask = wcstoul( argv[13], &pTemp, 16 );
        if (   ( ( argv[13] + wcslen( argv[13] ) ) != pTemp )
            || ( ulClusterIPAddress == ULONG_MAX ) )
        {
            wprintf( L"Could not convert '%s' to a subnet mask.\n", argv[13] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        wprintf(
              L"  Cluster IP subnet mask = %d.%d.%d.%d\n"
            , ( ulClusterIPSubnetMask & 0xFF000000 ) >> 24
            , ( ulClusterIPSubnetMask & 0x00FF0000 ) >> 16
            , ( ulClusterIPSubnetMask & 0x0000FF00 ) >> 8
            , ( ulClusterIPSubnetMask & 0x000000FF )
            );


        // Cluster IP NIC name.
        if ( ClRtlStrICmp( argv[14], L"NICNAME=" ) != 0 )
        {
            wprintf( L"Expected 'NICNAME='. Got '%s'.\n", argv[14] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterIPNetwork = argv[15];
        wprintf( L"  Name of the NIC for the cluster IP address = '%s'\n", pszClusterIPNetwork );


        // Indicate that a cluster should be formed when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetCreate(
                  pszClusterName
                , pszClusterAccountName
                , pszClusterAccountPwd
                , pszClusterAccountDomain
                , ulClusterIPAddress
                , ulClusterIPSubnetMask
                , pszClusterIPNetwork
                );

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#08x occurred trying to set cluster form parameters.\n", hr );
            break;
        } // if: SetCreate() failed.

        // Initiate a cluster create operation.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#08x occurred trying to create the cluster.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Cluster successfully created.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


HRESULT HrJoinCluster(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 10 )
        {
            wprintf( L"JOIN: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to join a cluster...\n");

        // Cluster name.
        if ( ClRtlStrICmp( argv[2], L"NAME=" ) != 0 )
        {
            wprintf( L"Expected 'NAME='. Got '%s'.\n", argv[2] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterName = argv[3];
        wprintf( L"  Cluster Name = '%s'\n", pszClusterName );

        // Cluster account domain
        if ( ClRtlStrICmp( argv[4], L"DOMAIN=" ) != 0 )
        {
            wprintf( L"Expected 'DOMAIN='. Got '%s'.\n", argv[4] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        
        WCHAR * pszClusterAccountDomain = argv[5];
        wprintf( L"  Cluster Account Domain = '%s'\n", pszClusterAccountDomain );


        // Cluster account name.
        if ( ClRtlStrICmp( argv[6], L"ACCOUNT=" ) != 0 )
        {
            wprintf( L"Expected 'ACCOUNT='. Got '%s'.\n", argv[6] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountName = argv[7];
        wprintf( L"  Cluster Account Name = '%s'\n", pszClusterAccountName );


        // Cluster account password.
        if ( ClRtlStrICmp( argv[8], L"PASSWORD=" ) != 0 )
        {
            wprintf( L"Expected 'PASSWORD='. Got '%s'.\n", argv[8] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountPwd = argv[9];
        wprintf( L"  Cluster Account Password = '%s'\n", pszClusterAccountPwd );


        // Indicate that a cluster should be joined when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetAdd(
                  pszClusterName
                , pszClusterAccountName
                , pszClusterAccountPwd
                , pszClusterAccountDomain
                );

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#08x occurred trying to set cluster join parameters.\n", hr );
            break;
        } // if: SetAdd() failed.

        // Initiate cluster join.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#08x occurred trying to join the cluster.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Cluster join successful.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


HRESULT HrCleanupNode(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 2 )
        {
            wprintf( L"CLEANUP: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to cleanup node...\n");

        // Indicate that the node should be cleaned up when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetCleanup();

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#08x occurred trying to set node cleanup parameters.\n", hr );
            break;
        } // if: SetCleanup() failed.

        // Initiate node cleanup.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#08x occurred trying to clean up the node.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Node successfully cleaned up.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


// The main function for this program.
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HRESULT hr = S_OK;

    // Initialize COM
    CoInitializeEx( 0, COINIT_MULTITHREADED );

    wprintf( L"\n" );

    do
    {
        COSERVERINFO    coServerInfo;
        COAUTHINFO      coAuthInfo;
        COSERVERINFO *  pcoServerInfoPtr = NULL;
        WCHAR **        pArgList = argv;
        int             nArgc = argc;

        CSmartIfacePtr< IClusCfgBaseCluster > spClusCfgBaseCluster;

        if ( nArgc <= 1 )
        {
            ShowUsage();
            break;
        }

        // Check if a computer name is specified.
        if ( *pArgList[1] != '/' )
        {
            coAuthInfo.dwAuthnSvc = RPC_C_AUTHN_WINNT;
            coAuthInfo.dwAuthzSvc = RPC_C_AUTHZ_NONE;
            coAuthInfo.pwszServerPrincName = NULL;
            coAuthInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
            coAuthInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            coAuthInfo.pAuthIdentityData = NULL;
            coAuthInfo.dwCapabilities = EOAC_NONE;
            
            coServerInfo.dwReserved1 = 0;
            coServerInfo.pwszName = pArgList[1];
            coServerInfo.pAuthInfo = &coAuthInfo;
            coServerInfo.dwReserved2 = 0;

            pcoServerInfoPtr = &coServerInfo;

            wprintf( L"Attempting cluster configuration on computer '%s'.\n", pArgList[1] );

            // Consume the arguments
            ++pArgList;
            --nArgc;
        }
        else
        {
            wprintf( L"Attempting cluster configuration on this computer.\n" );
        }

        // Initialize the BaseCluster component.
        hr = HrInitComponent( pcoServerInfoPtr, spClusCfgBaseCluster );
        if ( FAILED( hr ) )
        {
            wprintf( L"HrInitComponent() failed. Cannot configure cluster. Error %#08x.\n", hr );
            break;
        }

        // Parse the command line for options
        if ( ClRtlStrICmp( pArgList[1], L"/FORM" ) == 0 )
        {
            hr = HrFormCluster( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrFormCluster() failed. Cannot form cluster. Error %#08x.\n", hr );
                break;
            }
        } // if: form
        else if ( ClRtlStrICmp( pArgList[1], L"/JOIN" ) == 0 )
        {
            hr = HrJoinCluster( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrJoinCluster() failed. Cannot join cluster. Error %#08x.\n", hr );
                break;
            }
        } // else if: join
        else if ( ClRtlStrICmp( pArgList[1], L"/CLEANUP" ) == 0 )
        {
            hr = HrCleanupNode( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrFormCluster() failed. Cannot clean up node. Error %#08x.\n", hr );
                break;
            }
        } // else if: cleanup
        else
        {
            wprintf( L"Invalid option '%s'.\n", pArgList[1] );
            ShowUsage();
        } // else: invalid option
    }
    while( false ); // dummy do-while loop to avoid gotos.

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\test\ccluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgCallback
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CClusCfgCallback.h
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (VVasu)     07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"
#include "CClusCfgCallback.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::CClusCfgCallback()
//
//  Description:
//      Constructor of the CClusCfgCallback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::CClusCfgCallback( void )
    : m_cRef( 1 )
{
} //*** CClusCfgCallback::CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::~CClusCfgCallback()
//
//  Description:
//      Destructor of the CClusCfgCallback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::~CClusCfgCallback( void )
{
} //*** CClusCfgCallback::~CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusCfgCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CClusCfgCallback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface to the newly create object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    CClusCfgCallback *  pccb;
    HRESULT hr;

    pccb = new CClusCfgCallback();
    if ( pccb != NULL )
    {
        hr = pccb->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) );
        pccb->Release( );

    } // if: error allocating object
    else
    {
        hr = THR( E_OUTOFMEMORY );
    } // else: out of memory

    return hr;

} //*** CClusCfgCallback::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** CClusCfgCallback::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::Release( void )
{
    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        delete this;
    } // if: reference count decremented to zero

    return cRef;

} //*** CClusCfgCallback::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          If ppvOut is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    return hr;

} //*** CClusCfgCallback::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::SendStatusReport
//
//  Description:
//      Handle a progress notification
//
//  Arguments:
//      bstrNodeNameIn
//          Name of the node that sent the status report.
//
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUID identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      bstrDescriptionIn
//          String describing the notification.
//
//      pftTimeIn
//      bstrReferenceIn
//
//  Return Value:
//      Always
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    ) throw()
{
    wprintf( L"Notification ( %d, %d, %d ) =>\n  '%s' ( Error Code %#08x )\n", ulMinIn, ulMaxIn, ulCurrentIn, bstrDescriptionIn, hrStatusIn );

    return S_OK;

} //*** CClusCfgCallback::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the ClusOCM DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
// For wprintf
#include <stdio.h>

// For smart classes
#include "SmartClasses.h"

// For IClusCfgBaseCluster
#include "ClusCfgServer.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\ccluscfgcredentials.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCredentials.h
//
//  Description:
//      This file contains the declaration of the CClusCfgCredentials
//      class.
//
//      The class CClusCfgCredentials is the representation of
//      account credentials. It implements the IClusCfgCredentials interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCredentials.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-May-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCredentials
//
//  Description:
//      The class CClusCfgCredentials is the representation of a
//      cluster.
//
//  Interfaces:
//      IClusCfgCredentials
//      IClusCfgInitialize
//      IClusCfgSetCredentials
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCredentials
    : public IClusCfgCredentials
    , public IClusCfgInitialize
    , public IClusCfgSetCredentials
{
public:
    //
    // Public constructors and destructors
    //

    CClusCfgCredentials( void );
    virtual ~CClusCfgCredentials( void );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces.
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgCredentials Interfaces.
    //

    STDMETHOD( SetCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );

    STDMETHOD( GetCredentials )( BSTR * pbstrUserOut, BSTR * pbstrDomainOut, BSTR * pbstrPasswordOut );

    STDMETHOD( GetIdentity )( BSTR * pbstrUserOut, BSTR * pbstrDomainOut );

    STDMETHOD( GetPassword )( BSTR * pbstrPasswordOut );

    STDMETHOD( AssignTo )( IClusCfgCredentials * picccDestIn );

    STDMETHOD( AssignFrom )( IClusCfgCredentials * picccSourceIn );

    //
    // IClusCfgSetCredentials Interfaces.
    //

    STDMETHOD( SetDomainCredentials )( LPCWSTR pcszCredentials );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

private:

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    LCID                    m_lcid;
    IClusCfgCallback *      m_picccCallback;
    BSTR                    m_bstrAccountName;
    BSTR                    m_bstrAccountDomain;
    CEncryptedBSTR          m_encbstrPassword;

    // Private copy constructor to prevent copying.
    CClusCfgCredentials( const CClusCfgCredentials & );

    // Private assignment operator to prevent copying.
    CClusCfgCredentials & operator = ( const CClusCfgCredentials & );

    HRESULT HrInit( void );

}; //*** Class CClusCfgCredentials
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\ccluscfgcredentials.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCredentials.cpp
//
//  Header File:
//      CClusCfgCredentials.h
//
//  Description:
//      This file contains the definition of the CClusCfgCredentials
//      class.
//
//      The class CClusCfgCredentials is the representation of
//      account credentials. It implements the IClusCfgCredentials interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-May-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "EncryptedBSTR.h"
#include "CClusCfgCredentials.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCredentials" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgCredentials instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      Pointer to CClusCfgCredentials instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCredentials::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CClusCfgCredentials *   pccc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccc = new CClusCfgCredentials();
    if ( pccc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"Server: CClusCfgCredentials::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccc != NULL )
    {
        pccc->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgCredentials::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::CClusCfgCredentials
//
//  Description:
//      Constructor of the CClusCfgCredentials class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCredentials::CClusCfgCredentials( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_bstrAccountName( NULL )
    , m_bstrAccountDomain( NULL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgCredentials::CClusCfgCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::~CClusCfgCredentials
//
//  Description:
//      Desstructor of the CClusCfgCredentials class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCredentials::~CClusCfgCredentials( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrAccountName );
    TraceSysFreeString( m_bstrAccountDomain );

    TraceFuncExit();

} //*** CClusCfgCredentials::~CClusCfgCredentials


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterConfiguration -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCredentials::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgCredentials::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCredentials::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgCredentials::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgCredentials * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCredentials ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCredentials, this, 0 );
    } // else if: IID_IClusCfgCredentials
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetCredentials ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetCredentials, this, 0 );
    } // else if: IClusCfgSetCredentials
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING1( hr, riidIn, IID_IClusCfgWbemServices );

} //*** CClusCfgCredentials::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgInitialze interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    Assert( m_picccCallback == NULL );

    if ( punkCallbackIn != NULL )
    {
        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCredentials::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgCredentials interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::GetCredentials
//
//  Description:
//
//  Arguments:
//      pbstrNameOut
//      pbstrDomainOut
//      pbstrPasswordOut
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::GetCredentials(
      BSTR *    pbstrNameOut
    , BSTR *    pbstrDomainOut
    , BSTR *    pbstrPasswordOut
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrPassword = NULL;

    //  The marshaller doesn't allow null out-parameters, but just to be explicit...
    if ( pbstrNameOut != NULL )
    {
        *pbstrNameOut  = NULL;
    }

    if ( pbstrDomainOut != NULL )
    {
        *pbstrDomainOut  = NULL;
    }

    if ( pbstrPasswordOut != NULL )
    {
        *pbstrPasswordOut   = NULL;
    }

    if ( ( pbstrNameOut == NULL ) || ( pbstrDomainOut == NULL ) || ( pbstrPasswordOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrAccountName != NULL )
    {
        bstrName = SysAllocString( m_bstrAccountName );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    if ( m_bstrAccountDomain != NULL )
    {
        bstrDomain = SysAllocString( m_bstrAccountDomain );
        if ( bstrDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    hr = STHR( m_encbstrPassword.HrGetBSTR( &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pbstrNameOut = bstrName;
    bstrName = NULL;

    *pbstrDomainOut = bstrDomain;
    bstrDomain = NULL;

    *pbstrPasswordOut = bstrPassword;
    TraceMemoryDelete( bstrPassword, false );
    bstrPassword = NULL;
    hr = S_OK; // because decrypting might have returned S_FALSE

Cleanup:

    SysFreeString( bstrName );
    SysFreeString( bstrDomain );
    if ( bstrPassword != NULL )
    {
        CEncryptedBSTR::SecureZeroBSTR( bstrPassword );
        TraceSysFreeString( bstrPassword );
    }

    HRETURN( hr );

} //*** CClusCfgCredentials::GetCredentials




//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::GetIdentity
//
//  Description:
//
//  Arguments:
//      pbstrNameOut
//      pbstrDomainOut
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::GetIdentity(
      BSTR *    pbstrNameOut
    , BSTR *    pbstrDomainOut
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;

    //  The marshaller doesn't allow null out-parameters, but just to be explicit...
    if ( pbstrNameOut != NULL )
    {
        *pbstrNameOut  = NULL;
    }

    if ( pbstrDomainOut != NULL )
    {
        *pbstrDomainOut  = NULL;
    }

    if ( ( pbstrNameOut == NULL ) || ( pbstrDomainOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrAccountName != NULL )
    {
        bstrName = SysAllocString( m_bstrAccountName );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    if ( m_bstrAccountDomain != NULL )
    {
        bstrDomain = SysAllocString( m_bstrAccountDomain );
        if ( bstrDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    *pbstrNameOut = bstrName;
    bstrName = NULL;

    *pbstrDomainOut = bstrDomain;
    bstrDomain = NULL;

Cleanup:

    SysFreeString( bstrName );
    SysFreeString( bstrDomain );

    HRETURN( hr );

} //*** CClusCfgCredentials::GetCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::GetPassword
//
//  Description:
//
//  Arguments:
//      pbstrPasswordOut
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::GetPassword( BSTR * pbstrPasswordOut )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrPassword = NULL;

    //  The marshaller doesn't allow null out-parameters, but just to be explicit...
    if ( pbstrPasswordOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrPasswordOut   = NULL;

    hr = STHR( m_encbstrPassword.HrGetBSTR( &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pbstrPasswordOut = bstrPassword;
    TraceMemoryDelete( bstrPassword, false );
    bstrPassword = NULL;
    hr = S_OK; // because decrypting might have returned S_FALSE

Cleanup:

    if ( bstrPassword != NULL )
    {
        CEncryptedBSTR::SecureZeroBSTR( bstrPassword );
        TraceSysFreeString( bstrPassword );
    }

    HRETURN( hr );

} //*** CClusCfgCredentials::GetPassword


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::SetCredentials
//
//  Description:
//
//  Arguments:
//      pcszNameIn
//      pcszDomainIn
//      pcszPasswordIn
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::SetCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrNewName = NULL;
    BSTR    bstrNewDomain = NULL;

    if ( pcszNameIn != NULL )
    {
        bstrNewName = TraceSysAllocString( pcszNameIn );
        if ( bstrNewName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

    if ( pcszDomainIn != NULL )
    {
        bstrNewDomain = TraceSysAllocString( pcszDomainIn );
        if ( bstrNewDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

    //  Keep this after name and domain, to preserve password in case copying either of the others fails.
    if ( pcszPasswordIn != NULL )
    {
        size_t cchPassword = wcslen( pcszPasswordIn );
        hr = THR( m_encbstrPassword.HrSetWSTR( pcszPasswordIn, cchPassword ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if:

    if ( bstrNewName != NULL )
    {
        TraceSysFreeString( m_bstrAccountName );
        m_bstrAccountName = bstrNewName;
        bstrNewName = NULL;
    } // if:

    if ( bstrNewDomain != NULL )
    {
        TraceSysFreeString( m_bstrAccountDomain );
        m_bstrAccountDomain = bstrNewDomain;
        bstrNewDomain = NULL;
    } // if:

Cleanup:

    TraceSysFreeString( bstrNewName );
    TraceSysFreeString( bstrNewDomain );

    HRETURN( hr );

} //*** CClusCfgCredentials::SetCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::AssignTo
//
//  Description:
//
//  Arguments:
//      picccDestIn
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::AssignTo(
    IClusCfgCredentials * picccDestIn
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrPassword = NULL;

    if ( picccDestIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_encbstrPassword.HrGetBSTR( &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( picccDestIn->SetCredentials( m_bstrAccountName, m_bstrAccountDomain, bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( bstrPassword != NULL )
    {
        CEncryptedBSTR::SecureZeroBSTR( bstrPassword );
        TraceSysFreeString( bstrPassword );
    }

    HRETURN( hr );

} //*** CClusCfgCredentials::AssignTo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::AssignFrom
//
//  Description:
//
//  Arguments:
//      picccSourceIn
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::AssignFrom(
    IClusCfgCredentials * picccSourceIn
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrPassword = NULL;

    hr = THR( picccSourceIn->GetCredentials( &bstrName, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_encbstrPassword.HrSetBSTR( bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_bstrAccountName = bstrName;
    TraceMemoryAddBSTR( m_bstrAccountName );
    bstrName = NULL;

    m_bstrAccountDomain = bstrDomain;
    TraceMemoryAddBSTR( m_bstrAccountDomain );
    bstrDomain = NULL;


Cleanup:

    SysFreeString( bstrName );
    SysFreeString( bstrDomain );
    if ( bstrPassword != NULL )
    {
        CEncryptedBSTR::SecureZeroBSTR( bstrPassword );
        TraceSysFreeString( bstrPassword );
    }

    HRETURN( hr );

} //*** CClusCfgCredentials::AssignFrom


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgSetCredentials interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::SetDomainCredentials
//
//  Description:
//
//  Arguments:
//      pcszCredentialsIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::SetDomainCredentials( LPCWSTR pcszCredentialsIn )
{
    TraceFunc( "[IClusSetCfgCredentials]" );

    HRESULT hr = S_OK;
    WCHAR * pszBackslash = NULL;
    WCHAR * pszAtSign = NULL;
    BSTR    bstrName = NULL;
    BSTR    bstrDomain = NULL;

    if ( pcszCredentialsIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        LogMsg( L"Server: CClusCfgCredentials::SetDomainCredentials() was given a NULL pointer argument." );
        goto Cleanup;
    } // if:

    pszBackslash = wcschr( pcszCredentialsIn, L'\\' );
    pszAtSign = wcschr( pcszCredentialsIn, L'@' );

    //
    //  Are the credentials in domain\user format?
    //
    if ( pszBackslash != NULL )
    {
        *pszBackslash = L'\0';
        pszBackslash++;

        //
        // If no domain was specified (e.g. the account was specified in the
        // '\account' form), use the domain of the local machine.
        //

        if ( *pszBackslash == L'\0' )
        {
            //
            // A domain string was NOT specified in the credentials.
            //

            hr = THR( HrGetComputerName( ComputerNameDnsDomain, &bstrDomain, TRUE /*fBestEffortIn*/ ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if: error getting the domain name
        } // if: no domain string was specified
        else
        {
            //
            // A domain string was specified in the credentials.
            //

            bstrDomain = TraceSysAllocString( pcszCredentialsIn );
            if ( bstrDomain == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:
        } // if: domain string was specified

        bstrName = TraceSysAllocString( pszBackslash );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if: domain\user format
    else if ( pszAtSign != NULL )
    {
        //
        //  Are the credentials in user@domain format?
        //

        *pszAtSign = L'\0';
        pszAtSign++;

        bstrName = TraceSysAllocString( pcszCredentialsIn );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        bstrDomain = TraceSysAllocString( pszAtSign );
        if ( bstrDomain == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if: user@domain format
    else
    {
        //
        //  Remember this as the user and get the FQDN for the local machine,
        //  since this account is assumed to be an account local to this
        //  machine.
        //

        bstrName = TraceSysAllocString( pcszCredentialsIn );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        hr = THR( HrGetComputerName(
                          ComputerNameDnsFullyQualified
                        , &bstrDomain
                        , FALSE // fBestEffortIn
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: error getting the FQDN for the computer
    } // neither domain\user nor user@domain format

    TraceSysFreeString( m_bstrAccountName );
    m_bstrAccountName = bstrName;
    bstrName = NULL;

    TraceSysFreeString( m_bstrAccountDomain );
    m_bstrAccountDomain = bstrDomain;
    bstrDomain = NULL;

Cleanup:

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDomain );

    HRETURN( hr );

} //*** CClusCfgCredentials::SetDomainCredentials


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCredentials::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgCredentials::HrInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\criticalsection.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CriticalSection.cpp
//
//  Description:
//      This file contains the implementation of the CCriticalSection
//      class.
//
//      The class CCriticalSection is a simple wrapper around Platform SDK
//      spinlock objects.
//
//  Documentation:
//
//  Header Files:
//      CriticalSection.h
//
//  Maintained By:
//      John Franco (jfranco) 03-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CriticalSection.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CCriticalSection" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CCriticalSection class
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCriticalSection::CCriticalSection
//
//  Description:
//      Initialize this object's spin lock.
//
//  Arguments:
//      cSpinsIn
//          The number of times the lock should retry entry before calling
//          a wait function.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCriticalSection::CCriticalSection( DWORD cSpinsIn )
    : m_hrInitialization( S_OK )
{
    if ( InitializeCriticalSectionAndSpinCount( &m_csSpinlock, cSpinsIn ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        m_hrInitialization = HRESULT_FROM_WIN32( scLastError );
    }

} //*** CCriticalSection::CCriticalSection

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCriticalSection::~CCriticalSection
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCriticalSection::~CCriticalSection( void )
{
    if ( SUCCEEDED( m_hrInitialization ) )
    {
        DeleteCriticalSection( &m_csSpinlock );
    }

} //*** CCriticalSection::~CCriticalSection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\clusterutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterUtils.h
//
//  Description:
//      This file contains the implementations of the ClusterUtils
//      functions.
//
//  Maintained By:
//      Galen Barbee    (GalenB)    13-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <clusrtl.h>
#include <PropList.h>
#include <StatusReports.h>

#include <CommonStrings.h>
#include <ClusRPC.h>
#include <ClusVerp.h>

#include <initguid.h>

#define STACK_ARRAY_SIZE 256

// {DD1C1DE0-F39D-46ee-BFD1-07ABF7566705}
DEFINE_GUID( TASKID_Minor_HrCheckJoiningNodeVersion_RpcStringBindingComposeW,
0xdd1c1de0, 0xf39d, 0x46ee, 0xbf, 0xd1, 0x7, 0xab, 0xf7, 0x56, 0x67, 0x5);

// {62AF0964-4B32-4067-8BF1-8903FEC95A82}
DEFINE_GUID( TASKID_Minor_HrCheckJoiningNodeVersion_RpcBindingFromStringBindingW,
0x62af0964, 0x4b32, 0x4067, 0x8b, 0xf1, 0x89, 0x3, 0xfe, 0xc9, 0x5a, 0x82);

// {D8C0BA67-D079-45ca-A28C-C4C389DB389A}
DEFINE_GUID( TASKID_Minor_HrCheckJoiningNodeVersion_RpcBindingSetAuthInfoW,
0xd8c0ba67, 0xd079, 0x45ca, 0xa2, 0x8c, 0xc4, 0xc3, 0x89, 0xdb, 0x38, 0x9a);

// {110E29E4-2072-4916-BE66-BED556F12A7B}
DEFINE_GUID( TASKID_Minor_HrCheckJoiningNodeVersion_CsRpcGetJoinVersionData_Log,
0x110e29e4, 0x2072, 0x4916, 0xbe, 0x66, 0xbe, 0xd5, 0x56, 0xf1, 0x2a, 0x7b);

// {5EB1F008-1B49-4cf0-9FE1-B1BC8F76454A}
DEFINE_GUID( TASKID_Minor_HrCheckJoiningNodeVersion_CsRpcGetJoinVersionData,
0x5eb1f008, 0x1b49, 0x4cf0, 0x9f, 0xe1, 0xb1, 0xbc, 0x8f, 0x76, 0x45, 0x4a);


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSeparateDomainAndName
//
//  Description:
//
//
//  Arguments:
//      bstrNameIn
//      pbstrDomainOut
//      pbstrNameOut
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSeparateDomainAndName(
      BSTR      bstrNameIn
    , BSTR *    pbstrDomainOut
    , BSTR *    pbstrNameOut
    )
{
    TraceFunc( "" );

    Assert( bstrNameIn != NULL );
    Assert( ( pbstrDomainOut != NULL )
        ||  ( pbstrNameOut != NULL )
        );

    HRESULT hr = S_OK;
    WCHAR * psz = NULL;

    psz = wcschr( bstrNameIn, L'.' );
    if ( psz == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    if ( pbstrDomainOut != NULL )
    {
        psz++;  // skip the .
        *pbstrDomainOut = TraceSysAllocString( psz );
        if ( *pbstrDomainOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        psz--;  // reset back to .
    } // if:

    if ( pbstrNameOut != NULL )
    {
        *pbstrNameOut = TraceSysAllocStringLen( bstrNameIn, (UINT) ( psz - bstrNameIn ) );
        if ( *pbstrNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    HRETURN ( hr );

} //*** HrSeparateDomainAndName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAppendDomainToName
//
//  Description:
//
//
//  Arguments:
//      bstrNameIn
//      bstrDomainIn
//      pbstrDomainNameOut
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAppendDomainToName(
      BSTR      bstrNameIn
    , BSTR      bstrDomainIn
    , BSTR *    pbstrDomainNameOut
    )
{
    TraceFunc( "" );

    Assert( bstrNameIn != NULL );
    Assert( pbstrDomainNameOut != NULL );

    HRESULT hr = S_OK;
    size_t  cchName = 0;

    // Create a fully qualified node name
    if ( bstrDomainIn != NULL )
    {
        cchName = wcslen( bstrNameIn ) + wcslen( bstrDomainIn ) + 1 + 1;
        Assert( cchName <= MAXDWORD );

        *pbstrDomainNameOut = TraceSysAllocStringLen( NULL, (UINT) cchName );
        if ( *pbstrDomainNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        hr = THR( StringCchPrintfW( *pbstrDomainNameOut, cchName, L"%ws.%ws", bstrNameIn, bstrDomainIn ) );
    } // if:
    else
    {
        *pbstrDomainNameOut = TraceSysAllocString( bstrNameIn );
        if ( *pbstrDomainNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        hr = S_FALSE;
    } // else:

Cleanup:

    HRETURN( hr );

} //*** HrAppendDomainToName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsCoreResource
//
//  Description:
//      Determines whether the resource is a core resource.
//
//  Arguments:
//      hResourceIn
//
//  Return Value:
//      S_OK    - Resource is a core resource.
//      S_FALSE - Resource is not a core resource.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsCoreResource( HRESOURCE hResourceIn )
{
    TraceFunc( "" );

    Assert( hResourceIn );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags = 0;
    DWORD   cb;

    sc = TW32( ClusterResourceControl( hResourceIn, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwFlags & CLUS_FLAG_CORE )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** HrIsCoreResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsResourceOfType
//
//  Description:
//      Find out if a resource if of a specific type.
//
//  Arguments:
//      hResourceIn         - Handle to the resource to check.
//      pszResourceTypeIn   - Resource type name.
//
//  Return Value:
//      S_OK    - Resource is of specified type.
//      S_FALSE - Resource is not of specified type.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsResourceOfType(
      HRESOURCE     hResourceIn
    , const WCHAR * pszResourceTypeIn
    )
{
    TraceFunc( "" );

    Assert( hResourceIn != NULL );
    Assert( pszResourceTypeIn != NULL );

    HRESULT     hr = S_OK;
    DWORD       sc;
    WCHAR *     pszBuf = NULL;
    size_t      cchBuf = 65;
    DWORD       cb;
    int         idx;

    pszBuf = new WCHAR [ cchBuf ];
    if ( pszBuf == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < 2; idx++ )
    {
        sc = ClusterResourceControl( hResourceIn, NULL, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, NULL, 0, pszBuf, (DWORD)( cchBuf * sizeof( WCHAR ) ), &cb );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszBuf;
            pszBuf = NULL;

            cchBuf = ( cb / sizeof( WCHAR ) ) + 1; // add one in case cb is an odd size...

            pszBuf = new WCHAR [ cchBuf ];
            if ( pszBuf == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            goto Cleanup;
        } // if:

        break;
    } // for:

    if ( wcsncmp( pszBuf, pszResourceTypeIn, cchBuf ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

Cleanup:

    delete [] pszBuf;

    HRETURN( hr );

} //*** HrIsResourceOfType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetIPAddressInfo
//
//  Description:
//
//
//  Arguments:
//      hResourceIn
//      pulIPAddress
//      pulSubnetMask
//      pbstrNetworkName
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetIPAddressInfo(
      HRESOURCE hResourceIn
    , ULONG *   pulIPAddress
    , ULONG *   pulSubnetMask
    , BSTR *    pbstrNetworkName
    )
{
    TraceFunc( "" );

    Assert( hResourceIn != NULL );
    Assert( pulIPAddress != NULL );
    Assert( pulSubnetMask != NULL );
    Assert( pbstrNetworkName != NULL );

    HRESULT                     hr = S_OK;
    DWORD                       sc;
    CClusPropList               cpl;
    CLUSPROP_BUFFER_HELPER      cpbh;

    sc = TW32( cpl.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, pulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"SubnetMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, pulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( pbstrNetworkName != NULL )
    {
        sc = TW32( cpl.ScMoveToPropertyByName( L"Network" ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        cpbh = cpl.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        *pbstrNetworkName = TraceSysAllocString( cpbh.pStringValue->sz );

        if( *pbstrNetworkName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    } // if: caller wants the network name

Cleanup:

    HRETURN( hr );

} //*** HrGetIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadCredentials
//
//  Description:
//      Set credentials for the cluscfg session from an existing cluster
//      service.
//
//  Arguments:
//      bstrMachine
//      piCCSC
//
//  Return Value:
//      S_OK            - Success.
//      S_FALSE         -
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadCredentials(
      BSTR                      bstrMachine
    , IClusCfgSetCredentials *  piCCSC
    )
{
    TraceFunc( "" );

    Assert( bstrMachine != NULL );
    Assert( piCCSC != NULL );

    HRESULT                     hr = S_FALSE;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbpqsc = 128;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;

    schSCM = OpenSCManager( bstrMachine, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto CleanUp;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto CleanUp;
    } // if:

    for ( ; ; )
    {
        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbpqsc );
        if ( pqsc == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto CleanUp;
        } // if:

        if ( ! QueryServiceConfig( schClusSvc, pqsc, cbpqsc, &cbRequired ) )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbpqsc = cbRequired;
                continue;
            } // if:
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    hr = THR( piCCSC->SetDomainCredentials( pqsc->lpServiceStartName ) );

CleanUp:

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    TraceFree( pqsc );

    HRETURN( hr );

} //*** HrLoadCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetNodeNameHostingResource
//
//  Description:
//      Get the name of the node hosting the cluster resource.
//
//  Arguments:
//      hClusterIn
//      pbstrNodeName
//
//  Return Value:
//      S_OK            - Success.
//      S_FALSE         -
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNodeNameHostingResource(
      HCLUSTER  hClusterIn
    , HRESOURCE hResourceIn
    , BSTR *    pbstrNameOut
    )
{
    TraceFunc( "" );

    Assert( hClusterIn != NULL );
    Assert( hResourceIn != NULL );
    Assert( pbstrNameOut != NULL );

    HRESULT     hr = S_FALSE;
    WCHAR *     pszNodeBuffer = NULL;
    DWORD       cchNodeNameLen;
    DWORD       scLastError;

    //
    // Get the length of the node name.
    //
    cchNodeNameLen  = 0;
    GetClusterResourceState( hResourceIn, NULL, &cchNodeNameLen, NULL, NULL );  // Ignore the returned state.
    scLastError = GetLastError();

    if ( scLastError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( scLastError ) );
        goto Cleanup;
    }

    cchNodeNameLen++;  // Increment for NULL.
    pszNodeBuffer = new WCHAR[ cchNodeNameLen ];

    if ( pszNodeBuffer == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    // Try it again, this time we should get the actual node name.
    //
    GetClusterResourceState( hResourceIn, pszNodeBuffer, &cchNodeNameLen, NULL, NULL );  // Ignore the returned state.
    scLastError = GetLastError();

    if ( scLastError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( scLastError ) );
        goto Cleanup;
    }

    //
    // Alloc & assign a copy of the node name to the out arg.
    //
    *pbstrNameOut = TraceSysAllocString( pszNodeBuffer );

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    delete [] pszNodeBuffer;

    HRETURN( hr );

} //*** HrGetNodeNameHostingResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetNodeNameHostingCluster
//
//  Description:
//      Get the name of the node hosting the cluster service...
//
//  Arguments:
//      hClusterIn
//      pbstrNodeName
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNodeNameHostingCluster(
      HCLUSTER  hClusterIn
    , BSTR *    pbstrNodeName
    )
{
    TraceFunc( "" );

    Assert( hClusterIn );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HCLUSENUM   hEnum = NULL;
    DWORD       idx;
    DWORD       dwType;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, psz, &cchpsz );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // if:

            hr = STHR( HrIsResourceOfType( hRes, L"Network Name" ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrIsCoreResource( hRes ) );
                if ( FAILED( hr ) )
                {
                    break;
                } // if:


                if ( hr == S_OK )
                {
                    hr = THR( HrGetNodeNameHostingResource( hClusterIn, hRes, pbstrNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        break;
                    } // if:
                    else if( hr == S_OK )
                    {
                        goto CleanUp;
                    }
                } // if:

            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** HrGetNodeNameHostingCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetSCSIInfo
//
//  Description:
//      Get the name of the node hosting the cluster service...
//
//  Arguments:
//      hResourceIn
//      pCSAOut
//      pdwSignatureOut
//      pdwDiskNumberOut
//
//  Return Value:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetSCSIInfo(
      HRESOURCE             hResourceIn
    , CLUS_SCSI_ADDRESS *   pCSAOut
    , DWORD             *   pdwSignatureOut
    , DWORD             *   pdwDiskNumberOut
    )
{
    TraceFunc( "" );

    Assert( hResourceIn != NULL );

    HRESULT                     hr = S_OK;
    DWORD                       sc;
    CClusPropValueList          cpvl;
    CLUSPROP_BUFFER_HELPER      cpbh;

    sc = TW32( cpvl.ScGetResourceValueList( hResourceIn, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:


    // loop through all the properties.
    sc = TW32( cpvl.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    do
    {
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        cpbh = cpvl;

        switch ( cpbh.pSyntax->dw )
        {
            case CLUSPROP_SYNTAX_PARTITION_INFO :
            {
                break;
            } // case: CLUSPROP_SYNTAX_PARTITION_INFO

            case CLUSPROP_SYNTAX_DISK_SIGNATURE :
            {
                *pdwSignatureOut = cpbh.pDiskSignatureValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

            case CLUSPROP_SYNTAX_SCSI_ADDRESS :
            {
                pCSAOut->dw = cpbh.pScsiAddressValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

            case CLUSPROP_SYNTAX_DISK_NUMBER :
            {
                *pdwDiskNumberOut = cpbh.pDiskNumberValue->dw;
                break;
            } // case:

        } // switch:

        // Move to the next item.
        sc = cpvl.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        }

        sc = cpvl.ScMoveToNextValue();

    } while ( sc == ERROR_SUCCESS );

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** HrGetSCSIInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterInformation
//
//  Description:
//      Get the cluster information.  This includes the name and the version
//      info.
//
//  Arguments:
//      hClusterIn
//      pbstrClusterNameOut
//      pcviOut
//
//  Return Value:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterInformation(
    HCLUSTER                hClusterIn,
    BSTR *                  pbstrClusterNameOut,
    CLUSTERVERSIONINFO *    pcviOut
    )
{
    TraceFunc( "" );

    Assert( hClusterIn != NULL );
    Assert( pbstrClusterNameOut != NULL );

    HRESULT             hr = S_OK;
    DWORD               sc;
    WCHAR *             psz = NULL;
    DWORD               cch = 33;
    CLUSTERVERSIONINFO  cvi;

    cvi.dwVersionInfoSize = sizeof( cvi );

    if ( pcviOut == NULL )
    {
        pcviOut = &cvi;
    } // if:

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetClusterInformation( hClusterIn, psz, &cch, pcviOut );
    if ( sc == ERROR_MORE_DATA )
    {
        delete [] psz;
        psz = NULL;

        psz = new WCHAR[ ++cch ];
        if ( psz == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetClusterInformation( hClusterIn, psz, &cch, pcviOut );
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        LogMsg( __FUNCTION__ ": GetClusterInformation() failed (hr = 0x%08x).", hr );
        goto Cleanup;
    } // if:

    *pbstrClusterNameOut = TraceSysAllocString( psz );
    if ( *pbstrClusterNameOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] psz;

    HRETURN( hr );

} //*** HrGetClusterInformation


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterResourceState
//
//  Description:
//
//  Arguments:
//      hResourceIn
//      pbstrNodeNameOut
//      pbstrGroupNameOut
//      pcrsStateOut
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterResourceState(
      HRESOURCE                 hResourceIn
    , BSTR *                    pbstrNodeNameOut
    , BSTR *                    pbstrGroupNameOut
    , CLUSTER_RESOURCE_STATE *  pcrsStateOut
    )
{
    TraceFunc( "" );

    Assert( hResourceIn != NULL );

    HRESULT                 hr = S_OK;
    CLUSTER_RESOURCE_STATE  crsState = ClusterResourceStateUnknown;
    WCHAR *                 pszNodeName = NULL;
    DWORD                   cchNodeName = 33;
    WCHAR *                 pszGroupName = NULL;
    DWORD                   cchGroupName = 33;

    pszNodeName = new WCHAR[ cchNodeName ];
    if ( pszNodeName == NULL )
    {
        goto OutOfMemory;
    } // if:

    pszGroupName = new WCHAR[ cchGroupName ];
    if ( pszGroupName == NULL )
    {
        goto OutOfMemory;
    } // if:

    crsState = GetClusterResourceState( hResourceIn, pszNodeName, &cchNodeName, pszGroupName, &cchGroupName );
    if ( GetLastError() == ERROR_MORE_DATA )
    {
        crsState = ClusterResourceStateUnknown;   // reset to error condition

        delete [] pszNodeName;
        pszNodeName = NULL;
        cchNodeName++;

        delete [] pszGroupName;
        pszGroupName = NULL;
        cchGroupName++;

        pszNodeName = new WCHAR[ cchNodeName ];
        if ( pszNodeName == NULL )
        {
            goto OutOfMemory;
        } // if:

        pszGroupName = new WCHAR[ cchGroupName ];
        if ( pszGroupName == NULL )
        {
            goto OutOfMemory;
        } // if:

        crsState = GetClusterResourceState( hResourceIn, pszNodeName, &cchNodeName, pszGroupName, &cchGroupName );
        if ( crsState == ClusterResourceStateUnknown )
        {
            DWORD   sc;

            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    } // if: more data

    if ( pbstrNodeNameOut != NULL )
    {
        *pbstrNodeNameOut = TraceSysAllocString( pszNodeName );
        if ( *pbstrNodeNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pbstrGroupNameOut != NULL )
    {
        *pbstrGroupNameOut = TraceSysAllocString( pszGroupName );
        if ( *pbstrGroupNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pcrsStateOut != NULL )
    {
        *pcrsStateOut = crsState;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszNodeName;
    delete [] pszGroupName;

    HRETURN( hr );

} //*** HrGetClusterResourceState


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterQuorumResource
//
//  Description:
//      Get the information about the quorum resource.
//
//  Arguments:
//      hClusterIn
//      pbstrResourceNameOut
//      pbstrDeviceNameOut
//      pdwMaxQuorumLogSizeOut
//
//  Return Value.:
//      S_OK            - Success.
//      E_INVALIDARG    - An input argument was not specified.
//      E_OUTOFMEMORY   - Couldn't allocate memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterQuorumResource(
      HCLUSTER  hClusterIn
    , BSTR *    pbstrResourceNameOut
    , BSTR *    pbstrDeviceNameOut
    , DWORD *   pdwMaxQuorumLogSizeOut
    )
{
    TraceFunc( "" );

    Assert( hClusterIn != NULL );
    Assert( ( pbstrResourceNameOut != NULL )
        ||  ( pbstrDeviceNameOut != NULL )
        ||  ( pdwMaxQuorumLogSizeOut != NULL )
        );

    HRESULT hr = S_OK;
    DWORD   sc;
    LPWSTR  pszResourceName = NULL;
    DWORD   cchResourceName = 128;
    DWORD   cchTempResourceName = cchResourceName;
    LPWSTR  pszDeviceName = NULL;
    DWORD   cchDeviceName = 128;
    DWORD   cchTempDeviceName = cchDeviceName;
    DWORD   dwMaxQuorumLogSize = 0;

    // Allocate the resource name buffer
    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    // Allocate the device name buffer
    pszDeviceName = new WCHAR[ cchDeviceName ];
    if ( pszDeviceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetClusterQuorumResource(
                              hClusterIn
                            , pszResourceName
                            , &cchTempResourceName
                            , pszDeviceName
                            , &cchTempDeviceName
                            , &dwMaxQuorumLogSize
                            );
    if ( sc == ERROR_MORE_DATA )
    {
        delete [] pszResourceName;
        pszResourceName = NULL;

        cchResourceName = ++cchTempResourceName;

        // Allocate the resource name buffer
        pszResourceName = new WCHAR[ cchResourceName ];
        if ( pszResourceName == NULL )
        {
            goto OutOfMemory;
        } // if:

        delete [] pszDeviceName;
        pszDeviceName = NULL;

        cchDeviceName = ++cchTempDeviceName;

        // Allocate the device name buffer
        pszDeviceName = new WCHAR[ cchDeviceName ];
        if ( pszDeviceName == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetClusterQuorumResource(
                                  hClusterIn
                                , pszResourceName
                                , &cchTempResourceName
                                , pszDeviceName
                                , &cchTempDeviceName
                                , &dwMaxQuorumLogSize
                                );
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( pbstrResourceNameOut != NULL )
    {
        *pbstrResourceNameOut = TraceSysAllocString( pszResourceName );
        if ( *pbstrResourceNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pbstrDeviceNameOut != NULL )
    {
        *pbstrDeviceNameOut = TraceSysAllocString( pszDeviceName );
        if ( *pbstrDeviceNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pdwMaxQuorumLogSizeOut != NULL )
    {
        *pdwMaxQuorumLogSizeOut = dwMaxQuorumLogSize;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszResourceName;
    delete [] pszDeviceName;

    HRETURN( hr );

} //*** HrGetClusterQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrReplaceTokens
//
//  Description:
//      Replaces all instances of the search tokens with a replacement token.
//
//  Arguments:
//      pwszStringInout     - The string in which to perform replacements.
//      pwszSearchTokenIn   - The string of tokens to search for that will be replaced.
//      chReplaceTokenIn    - What the search tokens will be replaced with.
//      pcReplacementsOut   - [optional] The number of replacements performed.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrReplaceTokens(
      LPWSTR  pwszStringInout
    , LPCWSTR pwszSearchTokensIn
    , WCHAR   chReplaceTokenIn
    , DWORD * pcReplacementsOut
    )
{
    TraceFunc3(
                  "pwszString = '%ws', pwszSearchToken: '%ws%', chReplaceToken: '%ws%'"
                , ( pwszStringInout != NULL ? pwszStringInout: L"<null>" )
                , pwszSearchTokensIn
                , chReplaceTokenIn
                );

    HRESULT hr = S_OK;
    DWORD   cReps = 0;
    WCHAR * pwszStr = NULL;
    WCHAR * pwszTok = NULL;

    Assert( pwszStringInout != NULL );
    Assert( pwszSearchTokensIn != NULL );

    //
    //  For each character in pwszStringInout check it against every character in
    //  pwszSearchTokensIn and if we find a match replace the character in
    //  pwszStringInout with the chReplaceTokenIn character.
    //

    for( pwszStr = pwszStringInout; *pwszStr != L'\0'; pwszStr++ )
    {
        for( pwszTok = (WCHAR *) pwszSearchTokensIn; *pwszTok != L'\0'; pwszTok++ )
        {
            if ( *pwszStr == *pwszTok )
            {
                *pwszStr = chReplaceTokenIn;
                cReps++;
                break;
            } // if: match
        } // for: each search token
    } // for: each string element

    if ( pcReplacementsOut != NULL )
    {
        *pcReplacementsOut = cReps;
    }

    HRETURN( hr );

} //*** HrReplaceTokens


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetMaxNodeCount
//
//  Description:
//      Get the maximum node count supported by the cluster.  This value
//      could be based upon the product suite, or it could be overridden
//      by an entry in the cluster hive.
//
//  Arguments:
//      pcMaxNodesOut
//
//  Return Value:
//      S_OK        - Success.
//      S_FALSE     -
//      E_POINTER   - An output argument was not specified.
//      Other HRESULTs.
//
//  Note:
//      THIS ROUTINE IS NOT FUNCIONTAL AT THE MOMENT.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  TODO:   11-OCT-2001 GalenB
    //
    //  Need to finish this!
    //

Cleanup:

    HRETURN( hr );

} //*** HrGetMaxNodeCount


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetReferenceStringFromHResult
//
//  Description:
//      Return if the specified HRESULT is in our list.
//
//  Arguments:
//      hrIn
//      pbstrReferenceStringOut
//
//  Return Value:
//      S_OK        - Success - HRESULT is in our list.
//      S_FALSE     - HRESULT is not in our list.
//      E_POINTER   - An output argument was not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetReferenceStringFromHResult(
      HRESULT   hrIn
    , BSTR *    pbstrReferenceStringOut
    )
{
    TraceFunc( "" );

    Assert( pbstrReferenceStringOut != NULL );

    HRESULT hr = S_FALSE;
    UINT    idx;

    struct MapHResultToStringId
    {
        HRESULT hr;
        UINT    ids;
    };

    static MapHResultToStringId s_rgmhrtsi[] =
    {
          { HRESULT_FROM_WIN32( ERROR_CLUSTER_IPADDR_IN_USE ),  IDS_ERROR_IP_ADDRESS_IN_USE_REF }
        , { HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY ),            IDS_ERROR_OUTOFMEMORY_REF }
    };

    for ( idx = 0 ; idx < ARRAYSIZE( s_rgmhrtsi ) ; idx++ )
    {
        if ( hrIn == s_rgmhrtsi[ idx ].hr )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance, s_rgmhrtsi[ idx ].ids, pbstrReferenceStringOut ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            break;
        } // if: found a match
    } // for: each entry in the array

Cleanup:

    HRETURN( hr );

} //*** HrGetReferenceStringFromHResult


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrIsClusterServiceRunning
//
//  Description:
//      Is cluster service running?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK            - The cluster service is running.
//      S_FALSE         - The cluster service is NOT running.
//      HRESULT         - Something failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsClusterServiceRunning( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;

    //
    // Get the cluster state of the node.
    //

    sc = GetNodeClusterState( NULL, &dwClusterState );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_SERVICE_DOES_NOT_EXIST ) )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    if ( dwClusterState == ClusterStateRunning )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** HrIsClusterServiceRunning


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCheckJoiningNodeVersion
//
//      Check a joining node's version information against that of the cluster.
//
//  Arguments:
//      pcwszClusterNameIn  - can be null, which means to use local machine.
//      dwNodeHighestVersionIn
//      dwNodeLowestVersionIn
//      pcccbIn - for status reporting.
//
//  Return Value:
//      S_OK
//          The joining node is compatible.
//
//      HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS )
//          The joining node is NOT compatible.
//
//      Other HRESULT errors.
//
//  Remarks:
//
// Get and verify the sponsor version
//
//
// From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
// if the version of this node is not compatible with the sponsor version. Prior to this, the last
// parameter always contained a success value and the cluster versions had to be compared subsequent to this
// call. This will, however, still have to be done as long as interoperability with Win2K
// is a requirement, since Win2K sponsors do not return an error in the last parameter.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCheckJoiningNodeVersion(
      PCWSTR                pcwszClusterNameIn
    , DWORD                 dwNodeHighestVersionIn
    , DWORD                 dwNodeLowestVersionIn
    , IClusCfgCallback *    pcccbIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    RPC_STATUS          rpcs = RPC_S_OK;
    RPC_BINDING_HANDLE  hRPCBinding = NULL;
    PWSTR               pwszBindingString = NULL;
    DWORD               scJoinStatus = ERROR_SUCCESS;
    DWORD               dwSponsorNode = 0;
    DWORD               dwClusterHighestVersion = 0;
    DWORD               dwClusterLowestVersion = 0;
    DWORD               scRPC = ERROR_SUCCESS;

    //
    //  Connect to this cluster with RPC.
    //  The parameters and logic imitate OpenCluster,
    //  but the RPC interface (identified by the first parameter to RpcStringBindingComposeW) is different.
    //
    rpcs = TW32( RpcStringBindingComposeW(
          L"6e17aaa0-1a47-11d1-98bd-0000f875292e" // Special interface for CsRpcGetJoinVersionData.
        , ( pcwszClusterNameIn == NULL? L"ncalrpc": L"ncadg_ip_udp" )
        , const_cast< WCHAR* >( pcwszClusterNameIn )
        , NULL
        , NULL
        , &pwszBindingString
        ) );
    if ( rpcs != RPC_S_OK )
    {
        hr = HRESULT_FROM_WIN32( rpcs );
        THR( HrSendStatusReport(
              pcccbIn
            , TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCheckJoiningNodeVersion_RpcStringBindingComposeW
            , 1
            , 1
            , 1
            , hr
            , L"HrCheckJoiningNodeVersion() RpcStringBindingComposeW() failed."
            ) );
        goto Cleanup;
    } // if

    rpcs = TW32( RpcBindingFromStringBindingW( pwszBindingString, &hRPCBinding ) );
    if ( rpcs != RPC_S_OK )
    {
        hr = HRESULT_FROM_WIN32( rpcs );
        THR( HrSendStatusReport(
              pcccbIn
            , TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCheckJoiningNodeVersion_RpcBindingFromStringBindingW
            , 1
            , 1
            , 1
            , hr
            , L"HrCheckJoiningNodeVersion() RpcBindingFromStringBindingW() failed."
            ) );
        goto Cleanup;
    } // if

    //  Parameters to RpcBindingSetAuthInfoW copied from OpenCluster.
    rpcs = TW32( RpcBindingSetAuthInfoW(
          hRPCBinding
        , NULL
        , RPC_C_AUTHN_LEVEL_CONNECT
        , RPC_C_AUTHN_WINNT
        , NULL
        , RPC_C_AUTHZ_NAME
        ) );
    if ( rpcs != RPC_S_OK )
    {
        hr = HRESULT_FROM_WIN32( rpcs );
        THR( HrSendStatusReport(
              pcccbIn
            , TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCheckJoiningNodeVersion_RpcBindingSetAuthInfoW
            , 1
            , 1
            , 1
            , hr
            , L"HrCheckJoiningNodeVersion() RpcBindingSetAuthInfoW() failed."
            ) );
        goto Cleanup;
    } // if

    //  Now, perform the check this function advertises.
    scRPC = TW32( CsRpcGetJoinVersionData(
          hRPCBinding
        , 0
        , dwNodeHighestVersionIn
        , dwNodeLowestVersionIn
        , &dwSponsorNode
        , &dwClusterHighestVersion
        , &dwClusterLowestVersion
        , &scJoinStatus
        ) );
    hr = HRESULT_FROM_WIN32( scRPC );

    THR( HrFormatDescriptionAndSendStatusReport(
          pcccbIn
        , pcwszClusterNameIn
        , TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_HrCheckJoiningNodeVersion_CsRpcGetJoinVersionData_Log
        , 1
        , 1
        , 1
        , hr
        , L"( Node Highest, Node Lowest ) == ( %1!#08x!, %2!#08x! ), ( Cluster Highest, Cluster Lowest ) == ( %3!#08x!, %4!#08x! )."
        , dwNodeHighestVersionIn
        , dwNodeLowestVersionIn
        , dwClusterHighestVersion
        , dwClusterLowestVersion
        ) );
    if ( scRPC != ERROR_SUCCESS )
    {
        THR( HrSendStatusReport(
              pcccbIn
            , TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCheckJoiningNodeVersion_CsRpcGetJoinVersionData
            , 1
            , 1
            , 1
            , hr
            , L"HrCheckJoiningNodeVersion() CsRpcGetJoinVersionData() failed."
            ) );
        goto Cleanup;
    } // if

    if ( scJoinStatus == ERROR_SUCCESS )
    {
        DWORD   dwClusterMajorVersion = CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion );

        Assert( dwClusterMajorVersion >= ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) );

        //
        //  Only want to join clusters that are no more than one version back.
        //
        if ( dwClusterMajorVersion < ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) )
        {
            hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ) );
        } // if
    } // if
    else
    {
        hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ) );
    } // else

Cleanup:

    if ( hRPCBinding != NULL )
    {
        RpcBindingFree( &hRPCBinding );
    } // if

    if ( pwszBindingString != NULL )
    {
        RpcStringFree( &pwszBindingString );
    } // if

    HRETURN( hr );
} //*** HrCheckJoiningNodeVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetNodeNames
//
//  Description:
//      Retrieve the names of the nodes currently in a cluster.
//
//  Parameters:
//      hClusterIn
//          A handle to the cluster of interest.  Must NOT be null.
//
//      pnCountOut
//          On success, *pnCountOut returns the number of nodes in the cluster.
//
//      prgbstrNodeNamesOut
//          On success, an array of BSTRs containing the node names.
//          The caller must free each BSTR with SysFreeString, and free
//          the array with CoTaskMemFree.
//
//  Return Values:
//      S_OK
//          The out parameters contain valid information and the caller
//          must free the array and the BSTRs it contains.
//
//      E_OUTOFMEMORY, and other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNodeNames(
      HCLUSTER  hClusterIn
    , long *    pnCountOut
    , BSTR **   prgbstrNodeNamesOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    BSTR *      prgbstrNodeNames = NULL;
    long        idxNode = 0;
    HCLUSENUM   hClusEnum = NULL;
    long        cNodes = 0;

    if ( pnCountOut != NULL )
    {
        *pnCountOut = 0;
    } // if

    if ( prgbstrNodeNamesOut != NULL )
    {
        *prgbstrNodeNamesOut = NULL;
    } // if

    if ( ( pnCountOut == NULL ) || ( prgbstrNodeNamesOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if

    hClusEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_NODE );
    if ( hClusEnum == NULL )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    } // if

    cNodes = ClusterGetEnumCount( hClusEnum );

    if ( cNodes > 0 )
    {
        //
        //  Set up local copy of name array.
        //
        prgbstrNodeNames = reinterpret_cast< BSTR* >( CoTaskMemAlloc( cNodes * sizeof( BSTR ) ) );
        if ( prgbstrNodeNames == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if
        ZeroMemory( prgbstrNodeNames, cNodes * sizeof( BSTR ) );

        for ( idxNode = 0; idxNode < cNodes; idxNode += 1 )
        {
            DWORD   dwNodeType = 0;
            WCHAR   wszNodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   cchNodeName = RTL_NUMBER_OF( wszNodeName );
            DWORD   scEnum  = ERROR_SUCCESS;

            scEnum = TW32( ClusterEnum( hClusEnum, idxNode, &dwNodeType, wszNodeName, &cchNodeName ) );
            if ( scEnum != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( scEnum );
                goto Cleanup;
            } // if

            prgbstrNodeNames[ idxNode ] = SysAllocString( wszNodeName );
            if ( prgbstrNodeNames[ idxNode ] == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if
        } // for each node in the cluster

        //
        //  Copy succeeded, so transfer ownership to caller.
        //
        *pnCountOut = cNodes;
        *prgbstrNodeNamesOut = prgbstrNodeNames;
        prgbstrNodeNames = NULL;

    } // if cluster has at least one node

Cleanup:

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    } // if

    if ( prgbstrNodeNames != NULL )
    {
        //
        //  Making local copy of array must have failed midway, so
        //  clean up whatever parts of it exist.
        //
        for ( idxNode = 0; idxNode < cNodes; ++idxNode )
        {
            SysFreeString( prgbstrNodeNames[ idxNode ] );
        } // for
        CoTaskMemFree( prgbstrNodeNames );
    } // if still own local copy of array.

    HRETURN( hr );

} //*** HrGetNodeNames
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\clusterutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterUtils.h
//
//  Description:
//      This file contains the declaration of the ClusterUtils
//      functions.
//
//  Implementation Files:
//      ClusterUtils.cpp
//
//  Maintained By:
//      Galen Barbee    (GalenB)    01-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once

//
//  Cluster API Functions.
//

HRESULT
HrIsCoreResource(
    HRESOURCE hResIn
    );

HRESULT
HrIsResourceOfType(
      HRESOURCE hResIn
    , const WCHAR * pszResourceTypeIn
    );

HRESULT
HrGetIPAddressInfo(
      HRESOURCE hResIn
    , ULONG * pulIPAddress
    , ULONG * pulSubnetMask
    , BSTR * pbstrNetworkName
    );

HRESULT
HrLoadCredentials(
      BSTR bstrMachine
    , IClusCfgSetCredentials * piCCSC
    );

HRESULT
HrGetNodeNameHostingResource(
      HCLUSTER hClusterIn
    , HRESOURCE hResIn
    , BSTR * pbstrNameOut
    );

HRESULT
HrGetNodeNameHostingCluster(
      HCLUSTER hClusterIn
    , BSTR * pbstrNodeName
    );

HRESULT
HrGetNetworkOfCluster(
      HCLUSTER hClusterIn
    , BSTR * pbstrNetworkName
    );

HRESULT
HrGetSCSIInfo(
      HRESOURCE hResIn
    , CLUS_SCSI_ADDRESS  * pCSAOut
    , DWORD * pdwSignatureOut
    , DWORD * pdwDiskNumberOut
    );

HRESULT
HrGetClusterInformation(
      HCLUSTER hClusterIn
    , BSTR * pbstrClusterNameOut
    , CLUSTERVERSIONINFO * pcviOut
    );

HRESULT
HrGetClusterResourceState(
      HRESOURCE                 hResourceIn
    , BSTR *                    pbstrNodeNameOut
    , BSTR *                    pbstrGroupNameOut
    , CLUSTER_RESOURCE_STATE *  pcrsStateOut
    );

HRESULT
HrGetClusterQuorumResource(
      HCLUSTER  hClusterIn
    , BSTR *    pbstrResourceNameOut
    , BSTR *    pbstrDeviceNameOut
    , DWORD *   pdwMaxQuorumLogSizeOut
    );


//
//  String manipulation functions.
//

HRESULT
HrSeparateDomainAndName(
      BSTR bstrNameIn
    , BSTR * pbstrDomainOut
    , BSTR * pbstrNameOut );

HRESULT
HrAppendDomainToName(
      BSTR bstrNameIn
    , BSTR bstrDomainIn
    , BSTR * pbstrDomainNameOut
    );

//
//  Cluster helper functions.
//

HRESULT
HrReplaceTokens(
      LPWSTR  pwszStringInout
    , LPCWSTR pwszSearchTokensIn
    , WCHAR   chReplaceTokenIn
    , DWORD * pcReplacementsOut
    );

HRESULT
HrGetMaxNodeCount(
    DWORD * pcMaxNodesOut
    );

HRESULT
HrGetReferenceStringFromHResult(
      HRESULT   hrIn
    , BSTR *    pbstrReferenceStringOut
    );

HRESULT
HrIsClusterServiceRunning( void );

HRESULT
HrCheckJoiningNodeVersion(
      PCWSTR                pcwszClusterNameIn
    , DWORD                 dwNodeHighestVersionIn
    , DWORD                 dwNodeLowestVersionIn
    , IClusCfgCallback *    pcccbIn
    );

HRESULT
HrGetNodeNames(
      HCLUSTER  hClusterIn
    , long *    pnCountOut
    , BSTR **   prgbstrNodeNamesOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\encryptedbstr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      EncryptedBSTR.cpp
//
//  Description:
//      Class to encrypt and decrypt BSTRs.
//
//  Maintained By:
//      John Franco (jfranco) 15-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EncryptedBSTR.h"

#include "EncryptedBSTRSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\nameutil.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      NameUtil.cpp
//
//  Description:
//      Name resolution utility.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NameUtil.h"

#include "NameUtilSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>
#include <windns.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wincrypt.h>
#include <nb30.h>
#include <clusrtl.h>

#include <StrSafe.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>

#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

#include "..\wizard\WizardStrings.h"
#include <LoadString.h>
#include <StrSafe.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\cfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.cpp
//
//  Description:
//      Sucks in the CFactory code.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#pragma warning( push )
#pragma warning( disable : 4100 )
#include "CFactorySrc.cpp"
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\statusreports.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      SendStatusReports.h
//
//  Description:
//      This file contains the declaration of the SendStatusReport
//      functions.
//
//  Documentation:
//
//  Implementation Files:
//      SendStatusReports.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , const WCHAR *       pcszDescriptionIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , DWORD               dwDescriptionIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , const WCHAR *       pcszNodeNameIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , DWORD               dwDescriptionIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , const WCHAR *       pcszNodeNameIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , const WCHAR *       pcszDescriptionIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , const WCHAR *       pcszDescriptionIn
                , const WCHAR *       pcszReferenceIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , DWORD               idDescriptionIn
                , DWORD               idReferenceIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , const WCHAR *       pcszDescriptionIn
                , DWORD               idReferenceIn
                );

HRESULT __cdecl
HrFormatDescriptionAndSendStatusReport(
      IClusCfgCallback *    picccIn
    , LPCWSTR               pcszNodeNameIn
    , CLSID                 clsidMajorIn
    , CLSID                 clsidMinorIn
    , ULONG                 ulMinIn
    , ULONG                 ulMaxIn
    , ULONG                 ulCurrentIn
    , HRESULT               hrIn
    , int                   nDescriptionFormatIn
    , ...
    );

HRESULT __cdecl
HrFormatDescriptionAndSendStatusReport(
      IClusCfgCallback *    picccIn
    , PCWSTR                pcszNodeNameIn
    , CLSID                 clsidMajorIn
    , CLSID                 clsidMinorIn
    , ULONG                 ulMinIn
    , ULONG                 ulMaxIn
    , ULONG                 ulCurrentIn
    , HRESULT               hrIn
    , PCWSTR                pcszDescriptionFormatIn
    , ...
    );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , const WCHAR *       pcszNodeNameIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , const WCHAR *       pcszDescriptionIn
                , DWORD               dwRefStringIdIn
                );

HRESULT
HrSendStatusReport(
                  IClusCfgCallback *  picccIn
                , const WCHAR *       pcszNodeNameIn
                , CLSID               clsidTaskMajorIn
                , CLSID               clsidTaskMinorIn
                , ULONG               ulMinIn
                , ULONG               ulMaxIn
                , ULONG               ulCurrentIn
                , HRESULT             hrStatusIn
                , DWORD               dwDescriptionIdIn
                , DWORD               dwRefStringIdIn
                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#pragma warning( push )
#pragma warning( disable : 4100 )
#include "CITrackerSrc.cpp"
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\common\statusreports.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      SendStatusReports.cpp
//
//  Header File:
//      SendStatusReports.h
//
//  Description:
//      This file contains the definition of the SendStatusReports
//       functions.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <LoadString.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , const WCHAR *       pcszDescriptionIn
    )
{
    TraceFunc1( "pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrNodeName = NULL;
    FILETIME    ft;

    //
    //  We don't care if this succeeds.  NULL is a valid arg for node name.
    //
    THR( HrGetComputerName(
              ComputerNameDnsHostname
            , &bstrNodeName
            , TRUE // fBestEffortIn
            ) );

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                                  bstrNodeName
                                , clsidTaskMajorIn
                                , clsidTaskMinorIn
                                , ulMinIn
                                , ulMaxIn
                                , ulCurrentIn
                                , hrStatusIn
                                , pcszDescriptionIn
                                , &ft
                                , NULL
                                ) );
    } // if:

    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , DWORD               idDescriptionIn
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;
    BSTR        bstrNodeName = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    //
    //  We don't care if this succeeds.  NULL is a valid arg for node name.
    //
    THR( HrGetComputerName(
                  ComputerNameDnsHostname
                , &bstrNodeName
                , TRUE // fBestEffortIn
                ) );

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {

        hr = THR( picccIn->SendStatusReport(
                              bstrNodeName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescription
                            , &ft
                            , NULL
                            ) );
    } // if:

CleanUp:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , const WCHAR *       pcszNodeNameIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , DWORD               idDescriptionIn
    )
{
    TraceFunc1( "pcszNodeNameIn = '%ls', idDescriptionIn", pcszNodeNameIn == NULL ? L"<null>" : pcszNodeNameIn );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescription
                            , &ft
                            , NULL
                            ) );
    } // if:

CleanUp:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , const WCHAR *       pcszNodeNameIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , const WCHAR *       pcszDescriptionIn
    )
{
    TraceFunc2(   "pcszNodeName = '%ls', pcszDescriptionIn = '%ls'"
                , pcszNodeNameIn == NULL ? L"<null>" : pcszNodeNameIn
                , pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn
                );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , &ft
                            , NULL
                            ) );
    } // if:

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , const WCHAR *       pcszDescriptionIn
    , const WCHAR *       pcszReferenceIn
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    FILETIME    ft;
    BSTR        bstrNodeName = NULL;

    //
    //  We don't care if this succeeds.  NULL is a valid arg for node name.
    //
    THR( HrGetComputerName(
                  ComputerNameDnsHostname
                , &bstrNodeName
                , TRUE // fBestEffortIn
                ) );

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              bstrNodeName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , &ft
                            , pcszReferenceIn
                            ) );
    } // if:

    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , DWORD               idDescriptionIn
    , DWORD               idReferenceIn
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrReference = NULL;
    BSTR        bstrNodeName = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idReferenceIn, &bstrReference ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    //
    //  We don't care if this succeeds.  NULL is a valid arg for node name.
    //
    THR( HrGetComputerName(
                  ComputerNameDnsHostname
                , &bstrNodeName
                , TRUE // fBestEffortIn
                ) );

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              bstrNodeName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescription
                            , &ft
                            , bstrReference
                            ) );
    } // if:

CleanUp:

    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , const WCHAR *       pcszDescriptionIn
    , DWORD               idReferenceIn
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrReference = NULL;
    BSTR        bstrNodeName = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idReferenceIn, &bstrReference ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    //
    //  We don't care if this succeeds.  NULL is a valid arg for node name.
    //
    THR( HrGetComputerName(
                  ComputerNameDnsHostname
                , &bstrNodeName
                , TRUE // fBestEffortIn
                ) );

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              bstrNodeName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , &ft
                            , bstrReference
                            ) );
    } // if:

CleanUp:

    TraceSysFreeString( bstrReference );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatDescriptionAndSendStatusReport
//
//  Description:
//      Variable argument description formater version of SendStatusReport.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT __cdecl
HrFormatDescriptionAndSendStatusReport(
      IClusCfgCallback *    picccIn
    , LPCWSTR               pcszNodeNameIn
    , CLSID                 clsidTaskMajorIn
    , CLSID                 clsidTaskMinorIn
    , ULONG                 ulMinIn
    , ULONG                 ulMaxIn
    , ULONG                 ulCurrentIn
    , HRESULT               hrStatusIn
    , int                   nDescriptionFormatIn
    , ...
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrMsg = NULL;
    BSTR        bstrFormat = NULL;
    va_list     valist;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, nDescriptionFormatIn, &bstrFormat ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    va_start( valist, nDescriptionFormatIn );
    hr = HrFormatStringWithVAListIntoBSTR( bstrFormat, &bstrMsg, valist );
    va_end( valist );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrMsg
                            , &ft
                            , NULL
                            ) );
    } // if:

Cleanup:

    TraceSysFreeString( bstrFormat );
    TraceSysFreeString( bstrMsg );

    HRETURN( hr );

} //*** HrFormatDescriptionAndSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatDescriptionAndSendStatusReport
//
//  Description:
//      Variable argument description formater version of SendStatusReport.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT __cdecl
HrFormatDescriptionAndSendStatusReport(
      IClusCfgCallback *    picccIn
    , PCWSTR                pcszNodeNameIn
    , CLSID                 clsidTaskMajorIn
    , CLSID                 clsidTaskMinorIn
    , ULONG                 ulMinIn
    , ULONG                 ulMaxIn
    , ULONG                 ulCurrentIn
    , HRESULT               hrStatusIn
    , PCWSTR                pcszDescriptionFormatIn
    , ...
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrMsg = NULL;
    va_list     valist;
    FILETIME    ft;

    va_start( valist, pcszDescriptionFormatIn );
    hr = HrFormatStringWithVAListIntoBSTR( pcszDescriptionFormatIn, &bstrMsg, valist );
    va_end( valist );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrMsg
                            , &ft
                            , NULL
                            ) );
    } // if:

Cleanup:

    TraceSysFreeString( bstrMsg );

    HRETURN( hr );

} //*** HrFormatDescriptionAndSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , const WCHAR *       pcszNodeNameIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , const WCHAR *       pcszDescriptionIn
    , DWORD               dwRefStringIdIn
    )
{
    TraceFunc2(   "pcszNodeName = '%ls', pcszDescriptionIn = '%ls'"
                , pcszNodeNameIn == NULL ? L"<null>" : pcszNodeNameIn
                , pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn
                );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    FILETIME    ft;
    BSTR        bstrRef = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, dwRefStringIdIn, &bstrRef ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , &ft
                            , bstrRef
                            ) );
    } // if:

Cleanup:

    TraceSysFreeString( bstrRef );

    HRETURN( hr );

} //*** HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
      IClusCfgCallback *  picccIn
    , const WCHAR *       pcszNodeNameIn
    , CLSID               clsidTaskMajorIn
    , CLSID               clsidTaskMinorIn
    , ULONG               ulMinIn
    , ULONG               ulMaxIn
    , ULONG               ulCurrentIn
    , HRESULT             hrStatusIn
    , DWORD               idDescriptionIn
    , DWORD               idReferenceIn
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrReference = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idReferenceIn, &bstrReference ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                              pcszNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescription
                            , &ft
                            , bstrReference
                            ) );
    } // if:

CleanUp:

    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );

    HRETURN( hr );

} //*** HrSendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\dllresourceids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      DllResourceIDs.h
//
//  Description:
//      Defines identifiers for resources in dll.rc.
//
//  Maintained By:
//      John Franco (jfranco) 17-April-2002
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

#define IDR_WIZARD_TYPELIB    ( ID_DLL_START + 1 )
#define IDR_CLIENT_TYPELIB    ( ID_DLL_START + 2 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

#define COMPONENT_HAS_CATIDS

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

#include <windows.h>
#include <ntsecapi.h>
#include <wincrypt.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <prsht.h>
#include <shfusion.h>
#include <ntddscsi.h>
#include <sddl.h>

#include <WBemCli.h>
#include <ClusRTL.h>

#include <StrSafe.h>

#include <Common.h>
#include <LoadString.h>
#include <Debug.h>
#include <CriticalSection.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <ObjectCookie.h>

#include <Guids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    09-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Register.h"
#include "DllResourceIDs.h"

#include <PropList.h>
#include <EncryptedBSTR.h>
#include <DispatchHandler.h>

//
// Add object headers here
//

// Common
#include "..\Common\CClusCfgCredentials.h"

//  Server
#include "..\Server\CClusCfgServer.h"
#include "..\Server\CClusCfgNodeInfo.h"
#include "..\Server\CClusCfgClusterInfo.h"
#include "..\Server\CClusCfgCallback.h"
#include "..\Server\CEnumClusCfgManagedResources.h"
#include "..\Server\CPhysicalDisk.h"
#include "..\Server\CEnumPhysicalDisks.h"
#include "..\Server\CEnumClusterResources.h"
#include "..\Server\CClusterResource.h"
#include "..\Server\CEnumClusCfgNetworks.h"
#include "..\Server\CEnumClusCfgIPAddresses.h"
#include "..\Server\CClusCfgNetworkInfo.h"
#include "..\Server\CClusCfgIPAddressInfo.h"
#include "..\Server\CClusCfgCapabilities.h"
#include "..\Server\CLocalQuorum.h"
#include "..\Server\CEnumLocalQuorum.h"
#include "..\Server\CMajorityNodeSet.h"
#include "..\Server\CEnumMajorityNodeSet.h"
#include "..\Server\CUnknownQuorum.h"
#include "..\Server\ServerStrings.h"

// Middle Tier
#include "..\MiddleTier\TaskManager.h"
#include "..\MiddleTier\ConnectionManager.h"
#include "..\MiddleTier\ObjectManager.h"
#include "..\MiddleTier\NotificationManager.h"
#include "..\MiddleTier\ServiceManager.h"
#include "..\MiddleTier\LogManager.h"
#include "..\MiddleTier\ClusterConfiguration.h"
#include "..\MiddleTier\ManagedResource.h"
#include "..\MiddleTier\ManagedNetwork.h"
#include "..\MiddleTier\NodeInformation.h"
#include "..\MiddleTier\TaskGatherNodeInfo.h"
#include "..\MiddleTier\ConfigConnection.h"
#include "..\MiddleTier\TaskAnalyzeCluster.h"
#include "..\MiddleTier\TaskAnalyzeClusterMinConfig.h"
#include "..\MiddleTier\TaskCommitClusterChanges.h"
#include "..\MiddleTier\EnumNodeInformation.h"
#include "..\MiddleTier\TaskGatherInformation.h"
#include "..\MiddleTier\TaskCompareAndPushInformation.h"
#include "..\MiddleTier\EnumManageableResources.h"
#include "..\MiddleTier\EnumManageableNetworks.h"
#include "..\MiddleTier\TaskGatherClusterInfo.h"
#include "..\MiddleTier\EnumCookies.h"
#include "..\MiddleTier\TaskPollingCallback.h"
#include "..\MiddleTier\TaskCancelCleanup.h"
#include "..\MiddleTier\TaskVerifyIPAddress.h"
#include "..\MiddleTier\IPAddressInfo.h"
#include "..\MiddleTier\EnumIPAddresses.h"

// W2kProxy
#include "..\W2kProxy\ConfigClusApi.h"

// Wizard
#include "..\Wizard\ClusCfg.h"
#include "..\Wizard\AddNodesWizard.h"
#include "..\Wizard\CreateClusterWizard.h"
#include "..\MiddleTier\TaskGetDomains.h"

// BaseCluster
#include "..\BaseCluster\CBCAInterface.h"

// Post Config
#include "..\PostCfg\GroupHandle.h"
#include "..\PostCfg\ResourceEntry.h"
#include "..\PostCfg\IPostCfgManager.h"
#include "..\PostCfg\IPrivatePostCfgResource.h"
#include "..\PostCfg\PostCfgMgr.h"
#include "..\PostCfg\ResTypeGenScript.h"
#include "..\PostCfg\ResTypeMajorityNodeSet.h"
#include "..\PostCfg\ResTypeServices.h"

// EvictCleanup
#include "..\EvictCleanup\EvictCleanup.h"
#include "..\EvictCleanup\AsyncEvictCleanup.h"

// Startup Notify
#include "..\Startup\StartupNotify.h"

// Evict Notify
#include "..\EvictNotify\EvictNotify.h"

// IISClusCfg
#include "..\..\IISClusCfg\IISClusCfg.h"

//
// Define the debugging module name for this DLL.
//
DEFINE_MODULE( "ClusConfig" )

BEGIN_APPIDS
DEFINE_APPID( L"Cluster Configuration Server",                  APPID_ClusCfgServer,            IDS_GENERIC_LAUNCH_PERMISSIONS, IDS_GENERIC_ACCESS_PERMISSIONS, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, airaiLaunchingUser )
DEFINE_APPID( L"Cluster Node Eviction Processor",               APPID_ClusCfgEvictCleanup,      IDS_GENERIC_LAUNCH_PERMISSIONS, IDS_GENERIC_ACCESS_PERMISSIONS, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, airaiLaunchingUser )
DEFINE_APPID( L"Cluster Node Eviction Asynchronous Processor",  APPID_ClusCfgAsyncEvictCleanup, IDS_GENERIC_LAUNCH_PERMISSIONS, IDS_GENERIC_ACCESS_PERMISSIONS, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, airaiLaunchingUser )
DEFINE_APPID( L"Cluster Service Startup Notifications",         APPID_ClusCfgStartupNotify,     IDS_GENERIC_LAUNCH_PERMISSIONS, IDS_GENERIC_ACCESS_PERMISSIONS, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, airaiLaunchingUser )
DEFINE_APPID( L"Cluster Service Node Evict Notifications",      APPID_ClusCfgEvictNotify,       IDS_GENERIC_LAUNCH_PERMISSIONS, IDS_GENERIC_ACCESS_PERMISSIONS, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, airaiLaunchingUser )
END_APPIDS

//
// Classes in this Component
//
// This table is used to create the objects supported in this DLL. It also is
// used to map a name with a particular CLSID. HrCoCreateInternalInstance() uses
// this table to shortcut COM.
//
BEGIN_DLL_PUBLIC_CLASSES
CLASS_WITH_APPID(  L"ClusCfg Server",                                        CLSID_ClusCfgServer,                    CClusCfgServer::S_HrCreateInstance,             ctmApartment,   APPID_ClusCfgServer )
CLASS_WITH_APPID(  L"ClusCfg Evict Cleanup Processing",                      CLSID_ClusCfgEvictCleanup,              CEvictCleanup::S_HrCreateInstance,              ctmFree,        APPID_ClusCfgEvictCleanup )
CLASS_WITH_APPID(  L"ClusCfg Asynchronous Evict Cleanup Processing",         CLSID_ClusCfgAsyncEvictCleanup,         CAsyncEvictCleanup::S_HrCreateInstance,         ctmApartment,   APPID_ClusCfgAsyncEvictCleanup )
CLASS_WITH_APPID(  L"ClusCfg Cluster Startup Notification",                  CLSID_ClusCfgStartupNotify,             CStartupNotify::S_HrCreateInstance,             ctmFree,        APPID_ClusCfgStartupNotify )
CLASS_WITH_APPID(  L"ClusCfg Cluster Node Eviction Notification",            CLSID_ClusCfgEvictNotify,               CEvictNotify::S_HrCreateInstance,               ctmFree,        APPID_ClusCfgEvictNotify )
CLASS_WITH_CATID(  L"ClusCfg Physical Disk Enumeration",                     CLSID_EnumPhysicalDisks,                CEnumPhysicalDisks::S_HrCreateInstance,         ctmApartment,   CEnumPhysicalDisks::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg Generic Script Resource Type Configuration",    CLSID_ClusCfgResTypeGenScript,          CResTypeGenScript::S_HrCreateInstance,          ctmApartment,   CResTypeGenScript::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg Majority Node Set Resource Type Configuration", CLSID_ClusCfgResTypeMajorityNodeSet,    CResTypeMajorityNodeSet::S_HrCreateInstance,    ctmApartment,   CResTypeMajorityNodeSet::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg Cluster Capabilities",                          CLSID_ClusCfgCapabilities,              CClusCfgCapabilities::S_HrCreateInstance,       ctmApartment,   CClusCfgCapabilities::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg Local Quorum Enumeration",                      CLSID_EnumLocalQuorum,                  CEnumLocalQuorum::S_HrCreateInstance,           ctmApartment,   CEnumLocalQuorum::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg Majority Node Set Enumeration",                 CLSID_EnumMajorityNodeSet,              CEnumMajorityNodeSet::S_HrCreateInstance,       ctmApartment,   CEnumMajorityNodeSet::S_RegisterCatIDSupport )
CLASS_WITH_CATID(  L"ClusCfg IIS Resource Types Cleanup",                    CLSID_IISClusCfg,                       CIISClusCfg::S_HrCreateInstance,                ctmApartment,   CIISClusCfg::S_HrRegisterCatIDSupport )
CLASS_WITH_PROGID( L"ClusCfg Create Cluster Wizard",                         CLSID_ClusCfgCreateClusterWizard,       CCreateClusterWizard::S_HrCreateInstance,       ctmApartment,   L"Microsoft.Clustering.CreateClusterWizard.1" )
CLASS_WITH_PROGID( L"ClusCfg Add Nodes to Cluster Wizard",                   CLSID_ClusCfgAddNodesWizard,            CAddNodesWizard::S_HrCreateInstance,            ctmApartment,   L"Microsoft.Clustering.ClusterAddNodesWizard.1" )
PUBLIC_CLASS(      L"ClusCfg Service Manager",                               CLSID_ServiceManager,                   CServiceManager::S_HrCreateInstance,            ctmFree )
PUBLIC_CLASS(      L"ClusCfg Resource Type Services",                        CLSID_ClusCfgResTypeServices,           CResTypeServices::S_HrCreateInstance,           ctmFree )
END_DLL_PUBLIC_CLASSES

BEGIN_PRIVATE_CLASSES
PRIVATE_CLASS( L"ClusCfg Node Information",                     CLSID_ClusCfgNodeInfo,              CClusCfgNodeInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Cluster Information",                  CLSID_ClusCfgClusterInfo,           CClusCfgClusterInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Managed Resources Enumeration",        CLSID_EnumClusCfgManagedResources,  CEnumClusCfgManagedResources::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Physical Disk Information",            CLSID_PhysicalDisk,                 CPhysicalDisk::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Networks Enumeration",                 CLSID_EnumClusCfgNetworks,          CEnumClusCfgNetworks::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Network Information",                  CLSID_ClusCfgNetworkInfo,           CClusCfgNetworkInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg IP Address Enumeration",               CLSID_EnumClusCfgIPAddresses,       CEnumClusCfgIPAddresses::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg IP Address Information",               CLSID_ClusCfgIPAddressInfo,         CClusCfgIPAddressInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Manager",                         CLSID_TaskManager,                  CTaskManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Connection Manager",                   CLSID_ClusterConnectionManager,     CConnectionManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Object Manager",                       CLSID_ObjectManager,                CObjectManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Log Manager",                          CLSID_LogManager,                   CLogManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Notification Manager",                 CLSID_NotificationManager,          CNotificationManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Node Information Data Format",         DFGUID_NodeInformation,             CNodeInformation::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Gather Node Information",         TASK_GatherNodeInfo,                CTaskGatherNodeInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Configuration Connection",             CLSID_ConfigurationConnection,      CConfigurationConnection::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Analyze Cluster",                 TASK_AnalyzeCluster,                CTaskAnalyzeCluster::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Analyze Cluster Minimal Config",  TASK_AnalyzeClusterMinConfig,       CTaskAnalyzeClusterMinConfig::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Commit Cluster Changes",          TASK_CommitClusterChanges,          CTaskCommitClusterChanges::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Enum Node Information Format",         DFGUID_EnumNodes,                   CEnumNodeInformation::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Gather Information",              TASK_GatherInformation,             CTaskGatherInformation::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Managed Resource Data Format",         DFGUID_ManagedResource,             CManagedResource::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Managed Network Data Format",          DFGUID_NetworkResource,             CManagedNetwork::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Compare and Push Information",    TASK_CompareAndPushInformation,     CTaskCompareAndPushInformation::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Enum Manageable Resources Data Format",DFGUID_EnumManageableResources,     CEnumManageableResources::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Enum Manageable Networks Data Format", DFGUID_EnumManageableNetworks,      CEnumManageableNetworks::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Get Domains",                     TASK_GetDomains,                    CTaskGetDomains::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Polling Callback",                TASK_PollingCallback,               CTaskPollingCallback::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Base Cluster",                         CLSID_ClusCfgBaseCluster,           CBCAInterface::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Cluster Configuration Data Format",    DFGUID_ClusterConfigurationInfo,    CClusterConfiguration::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Gather Cluster Info",             TASK_GatherClusterInfo,             CTaskGatherClusterInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Enum Cookies",                         DFGUID_EnumCookies,                 CEnumCookies::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Credentials",                          CLSID_ClusCfgCredentials,           CClusCfgCredentials::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Post Configuration Manager",           CLSID_ClusCfgPostConfigManager,     CPostCfgManager::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Verify IP Address",               TASK_VerifyIPAddress,               CTaskVerifyIPAddress::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Configure Cluster API Proxy Server",   CLSID_ConfigClusApi,                CConfigClusApi::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Task Cancel Cleanup",                  TASK_CancelCleanup,                 CTaskCancelCleanup::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg IP Address Info Data Format",          DFGUID_IPAddressInfo,               CIPAddressInfo::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Enum IP Address Info Data Format",     DFGUID_EnumIPAddressInfo,           CEnumIPAddresses::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Local Quorum Information",             CLSID_LocalQuorum,                  CLocalQuorum::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Majority Node Set Information",        CLSID_MajorityNodeSet,              CMajorityNodeSet::S_HrCreateInstance )
PRIVATE_CLASS( L"ClusCfg Unknown Quorum",                       CLSID_UnknownQuorum,                CUnknownQuorum::S_HrCreateInstance )
END_PRIVATE_CLASSES

//
// Category IDs in this Component
//
// This table is used to register the Category IDs (CATIDs) used by this DLL.
//
BEGIN_CATIDTABLE
DEFINE_CATID( CATID_ClusCfgCapabilities,                    L"Cluster Configuration Cluster Capabilities" )
DEFINE_CATID( CATID_EnumClusCfgManagedResources,            L"Cluster Configuration Managed Resource Enumerators" )
DEFINE_CATID( CATID_ClusCfgResourceTypes,                   L"Cluster Configuration Resource Types" )
DEFINE_CATID( CATID_ClusCfgMemberSetChangeListeners,        L"Cluster Configuration Member Set Change Listeners" )
DEFINE_CATID( CATID_ClusCfgStartupListeners,                L"Cluster Configuration Service Startup Listeners" )
DEFINE_CATID( CATID_ClusCfgEvictListeners,                  L"Cluster Configuration Node Eviction Listeners" )
END_CATIDTABLE


BEGIN_TYPELIBS
DEFINE_TYPELIB( IDR_WIZARD_TYPELIB )
DEFINE_TYPELIB( IDR_CLIENT_TYPELIB )
END_TYPELIBS


//
//  RPC Proxy/Stub entry points
//

extern "C" {

HRESULT
STDAPICALLTYPE
ProxyStubDllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void ** ppv
    );

HRESULT
STDAPICALLTYPE
ProxyStubDllCanUnloadNow( void );

HRESULT
STDAPICALLTYPE
ProxyStubDllRegisterServer( void );

HRESULT
STDAPICALLTYPE
ProxyStubDllUnregisterServer( void );

} // extern "C"

#define DO_MODULE_INIT
HRESULT
HrLocalProcessInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( CServiceManager::S_HrProcessInitialize() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** HrLocalProcessInit

#define DO_MODULE_UNINIT
HRESULT
HrLocalProcessUninit( void )
{
    TraceFunc( "" );

    HRESULT hr;
    HRESULT hrReturn = S_OK;

    //
    //  Only want to return the last error if any should occur.
    //
    hr = THR( CServiceManager::S_HrProcessUninitialize() );
    if ( FAILED( hr ) )
    {
        hrReturn = hr;
    } // if:

    HRETURN( hrReturn );

} //*** HrLocalProcessInit

//
// Indicate that we need to have Fusion initialized and uninitialized properly
// on process attach and detach.
//
#define USE_FUSION
#define IMPLEMENT_COM_SERVER_DLL

#include "DllSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\dll\register.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "RegisterSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\asyncevictcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      AsyncEvictCleanup.cpp
//
//  Description:
//      This file contains the implementation of the CAsyncEvictCleanup
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "AsyncEvictCleanup.h"

// For IClusCfgEvictCleanup and related interfaces
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CAsyncEvictCleanup" );


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::S_HrCreateInstance
//
//  Description:
//      Creates a CAsyncEvictCleanup instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CAsyncEvictCleanup *    pAsyncEvictCleanup = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Allocate memory for the new object.
    pAsyncEvictCleanup = new CAsyncEvictCleanup();
    if ( pAsyncEvictCleanup == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pAsyncEvictCleanup->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the object could not be initialized

    hr = THR( pAsyncEvictCleanup->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pAsyncEvictCleanup != NULL )
    {
        pAsyncEvictCleanup->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CAsyncEvictCleanup::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::CAsyncEvictCleanup
//
//  Description:
//      Constructor of the CAsyncEvictCleanup class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAsyncEvictCleanup::CAsyncEvictCleanup( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "CAsyncEvictCleanup::CAsyncEvictCleanup() - Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CAsyncEvictCleanup::CAsyncEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::~CAsyncEvictCleanup
//
//  Description:
//      Destructor of the CAsyncEvictCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAsyncEvictCleanup::~CAsyncEvictCleanup( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "CAsyncEvictCleanup::~CAsyncEvictCleanup() - Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CAsyncEvictCleanup::~CAsyncEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAsyncEvictCleanup::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CAsyncEvictCleanup::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAsyncEvictCleanup::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CAsyncEvictCleanup::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAsyncEvictCleanup::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgAsyncEvictCleanup * >( this );
    } // if: IUnknown
    else if (   IsEqualIID( riidIn, IID_IDispatch ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatch, this, 0 );
    } // else if: IDispatch
    else if ( IsEqualIID( riidIn, IID_IClusCfgAsyncEvictCleanup ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgAsyncEvictCleanup, this, 0 );
    } // else if: IClusCfgAsyncEvictCleanup
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CAsyncEvictCleanup::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::HrInit
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    // Create simplified type information.
    hr = THR( TDispatchHandler< IClusCfgAsyncEvictCleanup >::HrInit( LIBID_ClusCfgClient ) );
    if ( FAILED( hr ) )
    {
       LogMsg( "[AEC] Error %#08x occurred trying to create type information for the IDispatch interface.", hr );
       goto Cleanup;
    } // if: we could not create the type info for the IDispatch interface


Cleanup:

    HRETURN( hr );

} //*** CAsyncEvictCleanup::HrInit


//////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::CleanupNode
//
//  Routine Description:
//      Cleanup a node that has been evicted.
//
//  Arguments:
//      bstrEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      nDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      nTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//  Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//--
//////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::CleanupNode(
      BSTR   bstrEvictedNodeNameIn
    , long   nDelayIn
    , long   nTimeoutIn
    )
{
    TraceFunc( "[IClusCfgAsyncEvictCleanup]" );

    HRESULT                         hr = S_OK;
    IClusCfgEvictCleanup *          pcceEvict = NULL;
    ICallFactory *                  pcfCallFactory = NULL;
    ISynchronize *                  psSync = NULL;
    AsyncIClusCfgEvictCleanup *     paicceAsyncEvict = NULL;

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IClusCfgEvictCleanup, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

#if 0
    bool    fWaitForDebugger = true;

    while ( fWaitForDebugger )
    {
        Sleep( 3000 );
    } // while: waiting for the debugger to break in
#endif

    if ( ( bstrEvictedNodeNameIn == NULL ) || ( *bstrEvictedNodeNameIn == L'\0' ) )
    {
        LogMsg( "[AEC] The local node will be cleaned up." );
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        LogMsg( "[AEC] The remote node to be cleaned up is '%ws'.", bstrEvictedNodeNameIn );

        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = bstrEvictedNodeNameIn;
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node


    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Creating the EvictCleanup component on the evicted node." );

    // Instantiate this component on the node being evicted.
    hr = THR(
        CoCreateInstanceEx(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_INPROC_SERVER
            , pcsiServerInfoPtr
            , ARRAYSIZE( mqiInterfaces )
            , mqiInterfaces
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( "[AEC] Error %#08x occurred trying to instantiate the evict processing component on the evicted node.", hr );
        goto Cleanup;
    } // if: we could not instantiate the evict processing component


    // Get a pointer to the IClusCfgEvictCleanup interface.
    pcceEvict = reinterpret_cast< IClusCfgEvictCleanup * >( mqiInterfaces[0].pItf );

    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Creating a call factory." );

    // Now, get a pointer to the ICallFactory interface.
    hr = THR( pcceEvict->QueryInterface< ICallFactory >( &pcfCallFactory ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[AEC] Error %#08x occurred trying to get a pointer to the call factory.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the call factory interface


    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Creating a call object to make an asynchronous call." );

    // Create a call factory so that we can make an asynchronous call to cleanup the evicted node.
    hr = THR(
        pcfCallFactory->CreateCall(
              __uuidof( paicceAsyncEvict )
            , NULL
            , __uuidof( paicceAsyncEvict )
            , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( "[AEC] Error %#08x occurred trying to create a call object.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the asynchronous evict interface


    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Trying to get the ISynchronize interface pointer." );

    // Get a pointer to the ISynchronize interface.
    hr = THR( paicceAsyncEvict->QueryInterface< ISynchronize >( &psSync ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the synchronization interface


    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Initiating cleanup on evicted node." );

    // Initiate cleanup
    hr = THR( paicceAsyncEvict->Begin_CleanupLocalNode( nDelayIn ) );
    if ( ( FAILED( hr ) ) && ( HRESULT_CODE( hr ) != ERROR_NONE_MAPPED ) )
    {
        LogMsg( "[AEC] Error %#08x occurred trying to initiate cleanup on evicted node.", hr );
        goto Cleanup;
    } // if: we could not initiate cleanup


    TraceFlow1( "CAsyncEvictCleanup::CleanupNode() - Waiting for cleanup to complete or timeout to occur (%d milliseconds).", nTimeoutIn );

    // Wait for specified time.
    hr = psSync->Wait( 0, nTimeoutIn);
    if ( FAILED( hr ) )
    {
        LogMsg( "[AEC] We could not wait till the cleanup completed (status code is %#08x).", hr );
        goto Cleanup;
    } // if: we could not wait till cleanup completed


    TraceFlow( "CAsyncEvictCleanup::CleanupNode() - Finishing cleanup." );

    // Finish cleanup
    hr = THR( paicceAsyncEvict->Finish_CleanupLocalNode() );
    if ( FAILED( hr ) )
    {
        LogMsg( "[AEC] Error %#08x occurred trying to finish cleanup on evicted node.", hr );
        goto Cleanup;
    } // if: we could not finish cleanup

Cleanup:
    //
    // Clean up
    //
    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had got a pointer to the IClusCfgEvictCleanup interface

    if ( pcfCallFactory != NULL )
    {
        pcfCallFactory->Release();
    } // if: we had obtained a pointer to the call factory interface

    if ( psSync != NULL )
    {
        psSync->Release();
    } // if: we had obtained a pointer to the synchronization interface

    if ( paicceAsyncEvict != NULL )
    {
        paicceAsyncEvict->Release();
    } // if: we had obtained a pointer to the asynchronous evict interface

    HRETURN( hr );

} //*** CAsyncEvictCleanup::CleanupNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\evictcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      EvictCleanup.h
//
//  Description:
//      This file contains the declaration of the CEvictCleanup
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      EvictCleanup.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgEvictCleanup
#include <ClusCfgServer.h>

// For ILogger
#include <ClusCfgClient.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEvictCleanup
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEvictCleanup
    : public IClusCfgEvictCleanup
    , public IClusCfgCallback
{
private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // IUnknown
    LONG                m_cRef;                 // Reference counter.

    // IClusCfgCallback
    BSTR                m_bstrNodeName;         // Name of the local node.
    ILogger *           m_plLogger;             // ILogger for doing logging.

    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit( void );

    // Instruct the SCM to stop a service
    DWORD
        ScStopService(
          const WCHAR * pcszServiceNameIn
        , ULONG         ulQueryIntervalMilliSecIn = 500
        , ULONG         cQueryCountIn = 10
        );

    // Wrap logging to the logger object.
    void
        LogMsg( DWORD nLogEntryTypeIn, LPCWSTR pszLogMsgIn, ... );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CEvictCleanup( void );

    // Destructor.
    ~CEvictCleanup( void );

    // Copy constructor.
    CEvictCleanup( const CEvictCleanup & );

    // Assignment operator.
    CEvictCleanup & operator =( const CEvictCleanup & );

public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgEvictCleanup methods
    //////////////////////////////////////////////////////////////////////////

    // Performs the clean up actions on the local node after it has been
    // evicted from a cluster
    STDMETHOD( CleanupLocalNode )( DWORD dwDelayIn );

    // Performs the clean up actions on a remote node after it has been
    // evicted from a cluster
    STDMETHOD( CleanupRemoteNode )( const WCHAR * pcszEvictedNodeNameIn, DWORD dwDelayIn );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( SendStatusReport )(
                      LPCWSTR       pcszNodeNameIn
                    , CLSID         clsidTaskMajorIn
                    , CLSID         clsidTaskMinorIn
                    , ULONG         ulMinIn
                    , ULONG         ulMaxIn
                    , ULONG         ulCurrentIn
                    , HRESULT       hrStatusIn
                    , LPCWSTR       pcszDescriptionIn
                    , FILETIME *    pftTimeIn
                    , LPCWSTR       pcszReference
                    );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


}; //*** class CEvictCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\testevict.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      TestEvictCleanup.h
//
//  Description:
//      Header file for TestEvictCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>


////////////////////////////////////////////////////////////////////////////////
// Function declarations
//////////////////////////////////////////////////////////////////////////////

void ShowUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\asyncevictcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      AsyncEvictCleanup.h
//
//  Description:
//      This file contains the declaration of the CAsyncEvictCleanup
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      AsyncEvictCleanup.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IClusCfgAsyncEvictCleanup
#include "ClusCfgClient.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAsyncEvictCleanup
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAsyncEvictCleanup
    : public TDispatchHandler< IClusCfgAsyncEvictCleanup >
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgAsyncEvictCleanup methods
    //////////////////////////////////////////////////////////////////////////

    // Performs the clean up actions on a node after it has been evicted from
    // a cluster
    STDMETHOD( CleanupNode )(
          BSTR  bstrEvictedNodeNameIn
        , long  nDelayIn
        , long  nTimeoutIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit( void );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CAsyncEvictCleanup( void );

    // Destructor.
    ~CAsyncEvictCleanup( void );

    // Private copy constructor to prevent copying.
    CAsyncEvictCleanup( const CAsyncEvictCleanup & );

    // Private assignment operator to prevent copying.
    CAsyncEvictCleanup & operator =( const CAsyncEvictCleanup & );


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG            m_cRef;

}; //*** class CAsyncEvictCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the EvictCleanup library.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#define USES_SYSALLOCSTRING

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

// For the windows API and types
#include <windows.h>

// For the Cluster API
#include <clusapi.h>

// For COM
#include <objbase.h>
#include <ComCat.h>

#include <StrSafe.h>

// Required to be a part of this DLL
#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <DispatchHandler.h>

#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\testevict.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      TestEvict.cpp
//
//  Description:
//      Main file for the test harness executable.
//      Initializes tracing, parses command line and actually call the 
//      IClusCfgEvictCleanup functions.
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>
#include <objbase.h>
#include <limits.h>

#include <ClusCfgGuids.h>


// Show help for this executable.
void ShowUsage()
{
    wprintf( L"The syntax of this command is:\n" );
    wprintf( L"\nTestEvict.exe [computer-name]\n" );
}


// The main function for this program.
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HRESULT             hr = S_OK;

    // Initialize COM
    CoInitializeEx( 0, COINIT_MULTITHREADED );

    wprintf( L"\nInitiates evict processing on a computer.\n" );
    wprintf( L"Note: This computer must have Whistler (and the cluster binaries) for this command to work.\n" );

    do
    {
        CSmartIfacePtr< IClusCfgEvictCleanup > spEvict;

        if ( ( argc < 1 ) || ( argc > 2 ) ) 
        {
            ShowUsage();
            break;
        }

        {
            IClusCfgEvictCleanup *     cceTemp = NULL;

            hr = CoCreateInstance(
                      CLSID_ClusCfgEvictCleanup
                    , NULL
                    , CLSCTX_LOCAL_SERVER 
                    , __uuidof( IClusCfgEvictCleanup )
                    , reinterpret_cast< void ** >( &cceTemp )
                    );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to create the ClusCfgEvict component on the local machine.\n", hr );
                break;
            }

            // Store the retrieved pointer in a smart pointer for safe release.
            spEvict.Attach( cceTemp );
        }

        // Check if a computer name is specified.
        if ( argc == 2 )
        {
            CSmartIfacePtr< ICallFactory > spCallFactory;
            CSmartIfacePtr< AsyncIClusCfgEvictCleanup > spAsyncEvict;

            wprintf( L"Attempting to asynchronously initiate evict cleanup on computer '%s'.\n", argv[1] );

            hr = spCallFactory.HrQueryAndAssign( spEvict.PUnk() );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to create a call factory.\n", hr );
                break;
            }

            {
                AsyncIClusCfgEvictCleanup *    paicceAsyncEvict = NULL;

                hr = spCallFactory->CreateCall(
                      __uuidof( paicceAsyncEvict )
                    , NULL
                    , __uuidof( paicceAsyncEvict )
                    , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
                    );

                if ( FAILED( hr ) )
                {
                    wprintf( L"Error %#x occurred trying to get a pointer to the asynchronous evict interface.\n", hr );
                    break;
                }

                spAsyncEvict.Attach( paicceAsyncEvict );
            }

            hr = spAsyncEvict->Begin_CleanupRemote( argv[ 1 ] );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to initiate asynchronous cleanup on remote computer.\n", hr );
                break;
            }
        }
        else
        {
            wprintf( L"Attempting evict cleanup on this computer.\n" );
            hr = spEvict->CleanupLocal( FALSE );
        }

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#x occurred trying to initiate evict processing.\n", hr );
            break;
        }

        wprintf( L"Evict processing successfully initiated.\n", hr );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the TestEvictCluster EXE.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
// For wprintf
#include <stdio.h>

// For smart classes
#include "SmartClasses.h"

// For IClusCfgEvict
#include "ClusCfgServer.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\exe\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\exe\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictcleanup\evictcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      EvictCleanup.cpp
//
//  Description:
//      This file contains the implementation of the CEvictCleanup
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "EvictCleanup.h"

#include "clusrtl.h"

// For IClusCfgNodeInfo and related interfaces
#include <ClusCfgServer.h>

// For IClusCfgServer and related interfaces
#include <ClusCfgPrivate.h>

// For CClCfgSrvLogger
#include <Logger.h>

// For SUCCESSFUL_CLEANUP_EVENT_NAME
#include "EventName.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEvictCleanup" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::S_HrCreateInstance
//
//  Description:
//      Creates a CEvictCleanup instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CEvictCleanup * pEvictCleanup = NULL;

#if 0
    // This loop allows debugging of the entry code of the EvictCleanup task.
    {
        BOOL    fWaitForDebug = TRUE;
        while ( fWaitForDebug )
        {
            Sleep( 5000 );
        } // while:
    }
#endif

    // Allocate memory for the new object.
    pEvictCleanup = new CEvictCleanup();
    if ( pEvictCleanup == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pEvictCleanup->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the object could not be initialized

    hr = THR( pEvictCleanup->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pEvictCleanup != NULL )
    {
        pEvictCleanup->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CEvictCleanup::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CEvictCleanup
//
//  Description:
//      Constructor of the CEvictCleanup class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictCleanup::CEvictCleanup( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "CEvictCleanup::CEvictCleanup() - Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictCleanup::CEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::~CEvictCleanup
//
//  Description:
//      Destructor of the CEvictCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictCleanup::~CEvictCleanup( void )
{
    TraceFunc( "" );

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    }
    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "CEvictCleanup::~CEvictCleanup() - Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictCleanup::~CEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictCleanup::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEvictCleanup::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictCleanup::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CEvictCleanup::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictCleanup::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgEvictCleanup * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgEvictCleanup ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgEvictCleanup, this, 0 );
    } // else if: IClusCfgEvictCleanup
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEvictCleanup::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::HrInit
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::HrInit( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    ILogManager *       plm = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = THR( CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IServiceProvider
                    , reinterpret_cast< void ** >( &psp )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    hr = THR( psp->TypeSafeQS( CLSID_LogManager, ILogManager, &plm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = THR( plm->GetLogger( &m_plLogger ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save off the local computer name.
    //  If we can't get the fully-qualified name, just get the NetBIOS name.
    //

    hr = THR( HrGetComputerName(
                      ComputerNameDnsFullyQualified
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        THR( hr );
        LogMsg( hr, L"[EC] An error occurred trying to get the fully-qualified Dns name for the local machine during initialization. Status code is= %1!#08x!.", hr );
        goto Cleanup;
    } // if: error occurred getting computer name

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( plm != NULL )
    {
        plm->Release();
    }

    HRETURN( hr );

} //*** CEvictCleanup::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CleanupLocalNode
//
//  Description:
//      This method performs the clean up actions on the local node after
//      it has been evicted from a cluster, so that the node can go back
//      to its "pre-clustered" state.
//
//  Arguments:
//      DWORD dwDelayIn
//          Number of milliseconds that this method will wait before starting
//          cleanup. If some other process cleans up this node while this thread
//          is waiting, the wait is terminated. If this value is zero, this method
//          will attempt to clean up this node immediately.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::CleanupLocalNode( DWORD dwDelayIn )
{
    TraceFunc( "[IClusCfgEvictCleanup]" );

    HRESULT                 hr = S_OK;
    IClusCfgServer *        pccsClusCfgServer = NULL;
    IClusCfgNodeInfo *      pccniNodeInfo = NULL;
    IClusCfgInitialize *    pcciInitialize = NULL;
    IClusCfgClusterInfo *   pccciClusterInfo = NULL;
    IUnknown *              punkCallback = NULL;
    HANDLE                  heventCleanupComplete = NULL;
    DWORD                   dwClusterState;
    DWORD                   sc;

#if 0
    bool                    fWaitForDebugger = true;

    while ( fWaitForDebugger )
    {
        Sleep( 3000 );
    } // while: waiting for the debugger to break in
#endif

    LogMsg( LOGTYPE_INFO, L"[EC] Trying to cleanup local node." );


    // If the caller has requested a delayed cleanup, wait.
    if ( dwDelayIn > 0 )
    {
        LogMsg( LOGTYPE_INFO, L"[EC] Delayed cleanup requested. Delaying for %1!d! milliseconds.", dwDelayIn );

        heventCleanupComplete = CreateEvent(
              NULL                              // security attributes
            , TRUE                              // manual reset event
            , FALSE                             // initial state is non-signaled
            , SUCCESSFUL_CLEANUP_EVENT_NAME     // event name
            );

        if ( heventCleanupComplete == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to create the cleanup completion event.", sc );
            goto Cleanup;
        } // if: CreateEvent() failed

        sc = TW32( ClRtlSetObjSecurityInfo(
                              heventCleanupComplete
                            , SE_KERNEL_OBJECT
                            , EVENT_ALL_ACCESS 
                            , EVENT_ALL_ACCESS 
                            , 0
                            ) );

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( LOGTYPE_ERROR, L"[BC] Error %#08x occurred trying set cleanup completion event security.", sc );
            goto Cleanup;
        } // if: ClRtlSetObjSecurityInfo failed

        // Wait for this event to get signaled or until dwDelayIn milliseconds are up.
        do
        {
            // Wait for any message sent or posted to this queue
            // or for our event to be signaled.
            sc = MsgWaitForMultipleObjects(
                  1
                , &heventCleanupComplete
                , FALSE
                , dwDelayIn         // If no one has signaled this event in dwDelayIn milliseconds, abort.
                , QS_ALLINPUT
                );

            // The result tells us the type of event we have.
            if ( sc == ( WAIT_OBJECT_0 + 1 ) )
            {
                MSG msg;

                // Read all of the messages in this next loop,
                // removing each message as we read it.
                while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
                {
                    // If it is a quit message, we are done pumping messages.
                    if ( msg.message == WM_QUIT)
                    {
                        TraceFlow( "CEvictCleanup::CleanupLocalNode() - Get a WM_QUIT message. Exit message pump loop." );
                        break;
                    } // if: we got a WM_QUIT message

                    // Otherwise, dispatch the message.
                    DispatchMessage( &msg );
                } // while: there are still messages in the window message queue

            } // if: we have a message in the window message queue
            else
            {
                if ( sc == WAIT_OBJECT_0 )
                {
                    LogMsg( LOGTYPE_INFO, L"[EC] Some other process has cleaned up this node while we were waiting. Exiting wait loop." );
                } // if: our event is signaled
                else if ( sc == WAIT_TIMEOUT )
                {
                    LogMsg( LOGTYPE_INFO, L"[EC] The wait of %1!d! milliseconds is over. Proceeding with cleanup.", dwDelayIn );
                } // else if: we timed out
                else if ( sc == -1 )
                {
                    sc = TW32( GetLastError() );
                    hr = HRESULT_FROM_WIN32( sc );
                    LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to wait for an event to be signaled.", sc );
                } // else if: MsgWaitForMultipleObjects() returned an error
                else
                {
                    hr = HRESULT_FROM_WIN32( TW32( sc ) );
                    LogMsg( LOGTYPE_ERROR, L"[EC] An error occurred trying to wait for an event to be signaled. Status code is %1!#08x!.", sc );
                } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                break;
            } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
        }
        while( true ); // do-while: loop infinitely

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: something went wrong while waiting

        TraceFlow1( "CEvictCleanup::CleanupLocalNode() - Delay of %d milliseconds completed.", dwDelayIn );
    } // if: the caller has requested delayed cleanup

    TraceFlow( "CEvictCleanup::CleanupLocalNode() - Check node cluster state." );

    // Check the node cluster state
    sc = GetNodeClusterState( NULL, &dwClusterState );
    if ( sc == ERROR_SERVICE_DOES_NOT_EXIST )
    {
        LogMsg( LOGTYPE_INFO, L"[EC] GetNodeClusterState discovered that the cluster service does not exist.  Ignoring." );
    }
    else if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to get the state of the cluster service on this node.", hr );
        goto Cleanup;
    } // else if: we could not get the node cluster state
    else
    {
        if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
        {
            LogMsg( LOGTYPE_INFO, L"[EC] This node is not part of a cluster - no cleanup is necessary." );
            goto Cleanup;
        } // if: this node is not part of a cluster

        TraceFlow( "CEvictCleanup::CleanupLocalNode() - Stopping the cluster service." );
        //
        // NOTE: GetNodeClusterState() returns ClusterStateNotRunning if the cluster service is not in the
        // SERVICE_RUNNING state. However, this does not mean that the service is not running, since it could
        // be in the SERVICE_PAUSED, SERVICE_START_PENDING, etc. states.
        //
        // So, try and stop the service anyway. Query for the service state 300 times, once every 1000 ms.
        //
        sc = TW32( ScStopService( L"ClusSvc", 1000, 300 ) );
        hr = HRESULT_FROM_WIN32( sc );
        if ( FAILED( hr ) )
        {
            LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to stop the cluster service. Aborting cleanup.", sc );
            goto Cleanup;
        } // if: we could not stop the cluster service in the specified time
    } // else: GetNodeClusterState succeeded

    //
    // If we are here, the cluster service is not running any more.
    // Create the ClusCfgServer component
    //
    hr = THR(
        CoCreateInstance(
              CLSID_ClusCfgServer
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pcciInitialize )
            , reinterpret_cast< void ** >( &pcciInitialize )
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to create the cluster configuration server.", hr );
        goto Cleanup;
    } // if: we could not create the ClusCfgServer component

    hr = THR( TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to get an IUnknown interface pointer to the IClusCfgCallback interface.", hr );
        goto Cleanup;
    } // if:

    hr = THR( pcciInitialize->Initialize( punkCallback, LOCALE_SYSTEM_DEFAULT ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to initialize the cluster configuration server.", hr );
        goto Cleanup;
    } // if: IClusCfgInitialize::Initialize() failed

    hr = THR( pcciInitialize->QueryInterface< IClusCfgServer >( &pccsClusCfgServer ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to get a pointer to the cluster configuration server.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgServer interface

    hr = THR( pccsClusCfgServer->GetClusterNodeInfo( &pccniNodeInfo ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to get the node information.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgNodeInfo interface

    hr = THR( pccniNodeInfo->GetClusterConfigInfo( &pccciClusterInfo ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to get the cluster information.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgClusterInfo interface

    hr = THR( pccciClusterInfo->SetCommitMode( cmCLEANUP_NODE_AFTER_EVICT ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to set the cluster commit mode.", hr );
        goto Cleanup;
    } // if: IClusCfgClusterInfo::SetEvictMode() failed

    TraceFlow( "CEvictCleanup::CleanupLocalNode() - Starting cleanup of this node." );

    // Do the cleanup
    hr = THR( pccsClusCfgServer->CommitChanges() );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to clean up after evict.", hr );
        goto Cleanup;
    } // if: an error occurred trying to clean up after evict

    LogMsg( LOGTYPE_INFO, L"[EC] Local node cleaned up successfully." );

Cleanup:
    //
    // Clean up
    //

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if: we had queried for an IUnknown pointer on our IClusCfgCallback interface

    if ( pccsClusCfgServer != NULL )
    {
        pccsClusCfgServer->Release();
    } // if: we had created the ClusCfgServer component

    if ( pccniNodeInfo != NULL )
    {
        pccniNodeInfo->Release();
    } // if: we had acquired a pointer to the node info interface

    if ( pcciInitialize != NULL )
    {
        pcciInitialize->Release();
    } // if: we had acquired a pointer to the initialization interface

    if ( pccciClusterInfo != NULL )
    {
        pccciClusterInfo->Release();
    } // if: we had acquired a pointer to the cluster info interface

    if ( heventCleanupComplete == NULL )
    {
        CloseHandle( heventCleanupComplete );
    } // if: we had created the cleanup complete event

    HRETURN( hr );

} //*** CEvictCleanup::CleanupLocalNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CleanupRemoteNode
//
//  Description:
//      This method performs the clean up actions on a remote node after
//      it has been evicted from a cluster, so that the node can go back
//      to its "pre-clustered" state.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node that has just been evicted. This can be the
//          NetBios name of the node, the fully qualified domain name or
//          the node IP address. If NULL, the local machine is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that this method will wait before starting
//          cleanup. If some other process cleans up this node while this thread
//          is waiting, the wait is terminated. If this value is zero, this method
//          will attempt to clean up this node immediately.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::CleanupRemoteNode( const WCHAR * pcszEvictedNodeNameIn, DWORD dwDelayIn )
{
    TraceFunc( "[IClusCfgEvictCleanup]" );

    HRESULT                 hr = S_OK;
    IClusCfgEvictCleanup *  pcceEvict = NULL;

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IClusCfgEvictCleanup, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

    if ( pcszEvictedNodeNameIn == NULL )
    {
        LogMsg( LOGTYPE_INFO, L"[EC] The local node will be cleaned up." );
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        LogMsg( LOGTYPE_INFO, L"[EC] The remote node to be cleaned up is '%1!ws!'.", pcszEvictedNodeNameIn );

        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = const_cast< LPWSTR >( pcszEvictedNodeNameIn );
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node

    // Instantiate this component remotely
    hr = THR(
        CoCreateInstanceEx(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , pcsiServerInfoPtr
            , ARRAYSIZE( mqiInterfaces )
            , mqiInterfaces
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to instantiate the evict processing component. For example, the evicted node may be down right now or not accessible.", hr );
        goto Cleanup;
    } // if: we could not instantiate the evict processing component

    // Make the evict call.
    pcceEvict = reinterpret_cast< IClusCfgEvictCleanup * >( mqiInterfaces[0].pItf );
    hr = THR( pcceEvict->CleanupLocalNode( dwDelayIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( hr, L"[EC] Error %1!#08x! occurred trying to initiate evict processing.", hr );
        goto Cleanup;
    } // if: we could not initiate evict processing

Cleanup:
    //
    // Clean up
    //
    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had got a pointer to the IClusCfgEvictCleanup interface

    HRETURN( hr );

} //*** CEvictCleanup::CleanupRemoteNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::ScStopService
//
//  Description:
//      Instructs the SCM to stop a service. This function tests
//      cQueryCountIn times to see if the service has  stopped, checking
//      every ulQueryIntervalMilliSecIn milliseconds.
//
//  Arguments:
//      pcszServiceNameIn
//          Name of the service to stop
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has stopped. The default value is 500 milliseconds.
//
//      cQueryCountIn
//          The number of times this function will query the service (not
//          including an initial query) to see if it has stopped. The default
//          value is 10 times.
//
//  Return Value:
//      ERROR_SUCCESS
//          Success.
//
//      Other Win32 error codes
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CEvictCleanup::ScStopService(
      const WCHAR * pcszServiceNameIn
    , ULONG         ulQueryIntervalMilliSecIn
    , ULONG         cQueryCountIn
    )
{
    TraceFunc( "" );

    DWORD           sc = ERROR_SUCCESS;
    SC_HANDLE       schSCMHandle = NULL;
    SC_HANDLE       schServiceHandle = NULL;

    SERVICE_STATUS  ssStatus;
    bool            fStopped = false;
    UINT            cNumberOfQueries = 0;

    LogMsg( LOGTYPE_INFO, L"[EC] Attempting to stop the '%1!ws!' service.", pcszServiceNameIn );

    // Open a handle to the service control manager.
    schSCMHandle = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS );
    if ( schSCMHandle == NULL )
    {
        sc = TW32( GetLastError() );
        LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to open a handle to the service control manager.", sc );
        goto Cleanup;
    } // if: we could not open a handle to the service control mananger

    // Open a handle to the service.
    schServiceHandle = OpenService(
          schSCMHandle
        , pcszServiceNameIn
        , SERVICE_STOP | SERVICE_QUERY_STATUS
        );

    // Check if we could open a handle to the service.
    if ( schServiceHandle == NULL )
    {
        // We could not get a handle to the service.
        sc = GetLastError();

        // Check if the service exists.
        if ( sc == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            // Nothing needs to be done here.
            LogMsg( LOGTYPE_INFO, L"[EC] The '%1!ws!' service does not exist, so it is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
            sc = ERROR_SUCCESS;
        } // if: the service does not exist
        else
        {
            // Something else has gone wrong.
            TW32( sc );
            LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to open the '%2!ws!' service.", sc, pcszServiceNameIn );
        } // else: the service exists

        goto Cleanup;
    } // if: the handle to the service could not be opened.


    TraceFlow( "CEvictCleanup::ScStopService() - Querying the service for its initial state." );

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( schServiceHandle, &ssStatus ) == 0 )
    {
        sc = TW32( GetLastError() );
        LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred while trying to query the initial state of the '%2!ws!' service.", sc, pcszServiceNameIn );
        goto Cleanup;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // Nothing needs to be done here.
        LogMsg( LOGTYPE_INFO, L"[EC] The '%1!ws!' service is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
        goto Cleanup;
    } // if: the service has stopped.

    // If we are here, the service is running.
    TraceFlow( "CEvictCleanup::ScStopService() - The service is running." );

    //
    // Try and stop the service.
    //

    // If the service is stopping on its own, no need to send the stop control code.
    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
    {
        TraceFlow( "CEvictCleanup::ScStopService() - The service is stopping on its own. The stop control code will not be sent." );
    } // if: the service is stopping already
    else
    {
        TraceFlow( "CEvictCleanup::ScStopService() - The stop control code will be sent after 30 seconds." );

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( schServiceHandle, SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            if ( sc == ERROR_SERVICE_NOT_ACTIVE )
            {
                LogMsg( LOGTYPE_INFO, L"[EC] The '%1!ws!' service is not running. Nothing more needs to be done here.", pcszServiceNameIn );

                // The service is not running. Change the error code to success.
                sc = ERROR_SUCCESS;
            } // if: the service is already running.
            else
            {
                TW32( sc );
                LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred trying to stop the '%2!ws!' service.", sc, pcszServiceNameIn );
            }

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // else: the service has to be instructed to stop


    // Query the service for its state now and wait till the timeout expires
    cNumberOfQueries = 0;
    do
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( schServiceHandle, &ssStatus ) == 0 )
        {
            sc = TW32( GetLastError() );
            LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! occurred while trying to query the state of the '%2!ws!' service.", sc, pcszServiceNameIn );
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            TraceFlow( "CEvictCleanup::ScStopService() - The service has been stopped." );
            fStopped = true;
            sc = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cNumberOfQueries >= cQueryCountIn )
        {
            TraceFlow( "CEvictCleanup::ScStopService() - The service stop wait timeout has expired." );
            break;
        } // if: number of queries has exceeded the maximum specified

        TraceFlow2(
              "CEvictCleanup::ScStopService() - Waiting for %d milliseconds before querying service status again. %d such queries remaining."
            , ulQueryIntervalMilliSecIn
            , cQueryCountIn - cNumberOfQueries
            );

        ++cNumberOfQueries;

         // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );

    }
    while ( true ); // while: loop infinitely

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStopped )
    {
        sc = TW32( ERROR_SERVICE_REQUEST_TIMEOUT );
        LogMsg( LOGTYPE_ERROR, L"[EC] The '%1!ws!' service has not stopped even after %2!d! queries.", pcszServiceNameIn, cQueryCountIn );
        goto Cleanup;
    } // if: the maximum number of queries have been made and the service is not running.

    LogMsg( LOGTYPE_INFO, L"[EC] The '%1!ws!' service was successfully stopped.", pcszServiceNameIn );

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( LOGTYPE_ERROR, L"[EC] Error %1!#08x! has occurred trying to stop the '%2!ws!' service.", sc, pcszServiceNameIn );
    } // if: something has gone wrong

    //
    // Cleanup
    //

    if ( schSCMHandle != NULL )
    {
        CloseServiceHandle( schSCMHandle );
    } // if: we had opened a handle to the service control manager

    if ( schServiceHandle != NULL )
    {
        CloseServiceHandle( schServiceHandle );
    } // if: we had opened a handle to the service being stopped

    W32RETURN( sc );

} //*** CEvictCleanup::ScStopService


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::SendStatusReport(
//        LPCWSTR       pcszNodeNameIn
//      , CLSID         clsidTaskMajorIn
//      , CLSID         clsidTaskMinorIn
//      , ULONG         ulMinIn
//      , ULONG         ulMaxIn
//      , ULONG         ulCurrentIn
//      , HRESULT       hrStatusIn
//      , LPCWSTR       pcszDescriptionIn
//      , FILETIME *    pftTimeIn
//      , LPCWSTR       pcszReferenceIn
//      )
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictCleanup::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT hr = S_OK;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %ws", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#08x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );
    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  How do we log pftTimeIn?
    //
    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReferenceIn ? pcszReferenceIn : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CEvictCleanup::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::LogMsg
//
//  Description:
//      Wraps call to LogMsg on the logger object.
//
//  Arguments:
//      nLogEntryType   - Log entry type.
//      pszLogMsgIn     - Format string.
//      ...             - Arguments.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEvictCleanup::LogMsg(
      DWORD     nLogEntryTypeIn
    , LPCWSTR   pszLogMsgIn
    , ...
    )
{
    TraceFunc( "" );

    Assert( pszLogMsgIn != NULL );
    Assert( m_plLogger != NULL );

    HRESULT hr          = S_OK;
    BSTR    bstrLogMsg  = NULL;
    LPWSTR  pszLogMsg   = NULL;
    DWORD   cch;
    va_list valist;

    va_start( valist, pszLogMsgIn );

    cch = FormatMessageW(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_STRING
                , pszLogMsgIn
                , 0
                , 0
                , (LPWSTR) &pszLogMsg
                , 0
                , &valist
                );

    va_end( valist );

    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    bstrLogMsg = TraceSysAllocStringLen( pszLogMsg, cch );
    if ( bstrLogMsg == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    m_plLogger->LogMsg( nLogEntryTypeIn, bstrLogMsg );

Cleanup:
    LocalFree( pszLogMsg );
    TraceSysFreeString( bstrLogMsg );
    TraceFuncExit();

} //*** CEvictCleanup::LogMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictnotify\evictnotify.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      EvictNotify.cpp
//
//  Description:
//      This file contains the implementation of the CEvictNotify
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB)   20-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "EvictNotify.h"

#include "clusrtl.h"

// For IClusCfgNodeInfo and related interfaces
#include <ClusCfgServer.h>

// For IClusCfgServer and related interfaces
#include <ClusCfgPrivate.h>

// For CClCfgSrvLogger
#include <Logger.h>


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEvictNotify" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::CEvictNotify
//
//  Description:
//      Constructor of the CEvictNotify class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictNotify::CEvictNotify( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    m_bstrNodeName = NULL;
    m_plLogger = NULL;

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictNotify::CEvictNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::~CEvictNotify
//
//  Description:
//      Destructor of the CEvictNotify class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictNotify::~CEvictNotify( void )
{
    TraceFunc( "" );

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    } // if:

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictNotify::~CEvictNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEvictNotify::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CEvictNotify instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictNotify::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT         hr = S_OK;
    CEvictNotify *  pEvictNotify = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Allocate memory for the new object.
    pEvictNotify = new CEvictNotify();
    if ( pEvictNotify == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pEvictNotify->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the object could not be initialized.

    hr = THR( pEvictNotify->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pEvictNotify != NULL )
    {
        pEvictNotify->Release();
    } // if: the pointer to the notification object is not NULL

    HRETURN( hr );

} //*** CEvictNotify::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictNotify::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEvictNotify::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictNotify::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CEvictNotify::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictNotify::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgEvictNotify * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgEvictNotify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgEvictNotify, this, 0 );
    } // else if: IClusCfgEvictNotify
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEvictNotify::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::HrInit
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictNotify::HrInit( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    ILogManager *       plm = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = THR( CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IServiceProvider
                    , reinterpret_cast< void ** >( &psp )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    hr = THR( psp->TypeSafeQS( CLSID_LogManager, ILogManager, &plm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = THR( plm->GetLogger( &m_plLogger ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save off the local computer name.
    //  If we can't get the fully-qualified name, just get the NetBIOS name.
    //

    hr = THR( HrGetComputerName(
                      ComputerNameDnsFullyQualified
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        THR( hr );
        LogMsg( L"[EN] An error occurred trying to get the fully-qualified Dns name for the local machine during initialization. Status code is= %1!#08x!.", hr );
        goto Cleanup;
    } // if: error occurred getting computer name

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( plm != NULL )
    {
        plm->Release();
    }

    HRETURN( hr );

} //*** CEvictNotify::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::SendNotifications
//
//  Description:
//      This method is called by the Cluster Service to inform the implementor
//      of this interface to send out notification that a node has been evicted
//      from the cluster to interested listeners.
//
//  Arguments:
//      pcszNodeNameIn
//          The name of the cluster node that was evicted.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictNotify::SendNotifications(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc( "[IClusCfgEvictNotify]" );

    HRESULT hr = S_OK;

    //
    // Send out the notifications
    //

    hr = THR( HrNotifyListeners( pcszNodeNameIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to notify cluster evict listeners.", hr );
        goto Cleanup;
    } // if: something went wrong while sending out notifications

    LogMsg( "[EN] Sending of cluster evict notifications complete for node %ws. (hr = %#08x)", pcszNodeNameIn, hr );

Cleanup:

    HRETURN( hr );

} //*** CEvictNotify::SendNotifications


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEvictNotify::HrNotifyListeners
//
//  Description:
//      Enumerate all components on the local computer registered for cluster
//      evict notification.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the enumeration.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictNotify::HrNotifyListeners(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;
    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        psleEvictListenerClsidEnum = NULL;
    ULONG               cReturned = 0;
    CATID               rgCatIdsImplemented[ 1 ];

    rgCatIdsImplemented[ 0 ] = CATID_ClusCfgEvictListeners;

    //
    // Enumerate all the enumerators registered in the
    // CATID_ClusCfgEvictListeners category
    //
    hr = THR(
            CoCreateInstance(
                  CLSID_StdComponentCategoriesMgr
                , NULL
                , CLSCTX_SERVER
                , IID_ICatInformation
                , reinterpret_cast< void ** >( &pciCatInfo )
                )
            );

    if ( FAILED( hr ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgEvictListeners category.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the ICatInformation interface

    //
    //  Get a pointer to the enumerator of the CLSIDs that belong to the
    //  CATID_ClusCfgEvictListeners category.
    //
    hr = THR(
        pciCatInfo->EnumClassesOfCategories(
              1
            , rgCatIdsImplemented
            , 0
            , NULL
            , &psleEvictListenerClsidEnum
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgEvictListeners category.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IEnumCLSID interface

    //
    //  Enumerate the CLSIDs of the registered evict listeners
    //

    do
    {
        CLSID   rgEvictListenerClsids[ uiCHUNK_SIZE ];
        ULONG   idxCLSID;

        cReturned = 0;
        hr = STHR( psleEvictListenerClsidEnum->Next( uiCHUNK_SIZE , rgEvictListenerClsids , &cReturned ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[EN] Error %#08x occurred trying enumerate evict listener components.", hr );
            goto Cleanup;
        } // if: we could not get the next set of CLSIDs

        //
        // hr may be S_FALSE here, so reset it.
        //
        hr = S_OK;

        for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
        {
            hr = THR( HrProcessListener( rgEvictListenerClsids[ idxCLSID ], pcszNodeNameIn ) );
            if ( FAILED( hr ) )
            {
                //
                // The processing of one of the listeners failed.
                // Log the error, but continue processing other listeners.
                //

                TraceMsgGUID( mtfALWAYS, "The CLSID of the failed listener is ", rgEvictListenerClsids[ idxCLSID ] );
                LogMsg( "[EN] Error %#08x occurred trying to process a cluster evict listener. Other listeners will be processed.", hr );
                hr = S_OK;
            } // if: this enumerator failed
        } // for: iterate through the returned CLSIDs
    }
    while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

Cleanup:

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( psleEvictListenerClsidEnum != NULL )
    {
        psleEvictListenerClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of evict listener CLSIDs

    HRETURN( hr );

} //*** CEvictNotify::HrNotifyListeners


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEvictNotify::HrProcessListener
//
//  Description:
//      This function instantiates a cluster evict listener component
//      and calls the appropriate methods.
//
//  Arguments:
//      rclsidListenerCLSIDIn
//          CLSID of the evict listener component
//
//      pcszNodeNameIn
//          The name of the node that was evicted.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the processing of the listener.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictNotify::HrProcessListener(
      const CLSID & rclsidListenerCLSIDIn
    , LPCWSTR       pcszNodeNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IClusCfgInitialize *    pciInitialize = NULL;
    IClusCfgEvictListener * pcslEvictListener = NULL;

    TraceMsgGUID( mtfALWAYS, "The CLSID of this evict listener is ", rclsidListenerCLSIDIn );

    //
    // Create the component represented by the CLSID passed in
    //
    hr = THR(
            CoCreateInstance(
                  rclsidListenerCLSIDIn
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( pcslEvictListener )
                , reinterpret_cast< void ** >( &pcslEvictListener )
                )
            );
    if ( FAILED( hr ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to create a cluster evict listener component.", hr );
        goto Cleanup;
    } // if: we could not create the cluster evict listener component

    // Initialize the listener if supported.
    hr = pcslEvictListener->TypeSafeQI( IClusCfgInitialize, &pciInitialize );
    if ( FAILED( hr ) && ( hr != E_NOINTERFACE ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to query for IClusCfgInitialize on the listener component.", THR( hr ) );
        goto Cleanup;
    } // if: we could not create the cluster startup listener component

    // Initialize the listener if supported.
    if ( pciInitialize != NULL )
    {
        hr = THR( pciInitialize->Initialize( static_cast< IClusCfgCallback * >( this ), GetUserDefaultLCID() ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[EN] Error %#08x occurred trying to initialize the listener component.", hr );
            goto Cleanup;
        } // if:

        pciInitialize->Release();
        pciInitialize = NULL;
    } // if: pciInitialize != NULL

    // Notify this listener.
    hr = THR( pcslEvictListener->EvictNotify( pcszNodeNameIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[EN] Error %#08x occurred trying to notify a cluster evict listener.", hr );
        goto Cleanup;
    } // if: this notification

Cleanup:

    if ( pcslEvictListener != NULL )
    {
        pcslEvictListener->Release();
    } // if: we had obtained a pointer to the evict listener interface

    if ( pciInitialize != NULL )
    {
        pciInitialize->Release();
    } // if: we obtained a pointer to the initialize interface

    HRETURN( hr );

} //*** CEvictNotify::HrProcessListener


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictNotify::SendStatusReport(
//        LPCWSTR       pcszNodeNameIn
//      , CLSID         clsidTaskMajorIn
//      , CLSID         clsidTaskMinorIn
//      , ULONG         ulMinIn
//      , ULONG         ulMaxIn
//      , ULONG         ulCurrentIn
//      , HRESULT       hrStatusIn
//      , LPCWSTR       pcszDescriptionIn
//      , FILETIME *    pftTimeIn
//      , LPCWSTR       pcszReferenceIn
//      )
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictNotify::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT hr = S_OK;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %s", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#08x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );
    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  How do we log pftTimeIn?
    //
    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReferenceIn ? pcszReferenceIn : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CEvictNotify::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictnotify\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file for the EvictNotify library.
//
//  Maintained By:
//      Galen Barbee (GalenB)   20-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#define USES_SYSALLOCSTRING

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

// For the windows API and types
#include <windows.h>

// For COM
#include <objbase.h>
#include <ComCat.h>

#include <StrSafe.h>

// Required to be a part of this DLL
#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgServer.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\exe\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      Cristian Scutaru (CScutaru) 22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
//#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <citracker.h>
#include <guids.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\exe\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\iiscluscfg\iiscluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Module Name:
//      IISClusCfg.h
//
//  Implementation Files:
//      IISClusCfg.cpp
//
//  Description:
//      Header file for the IClusCfgStarutpListener sample program.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

//
// Our Class Id GUID declaration(s)
//

#include "IISClusCfgGuids.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CIISClusCfg
//
//  Description:
//      The CIISClusCfg class is the implementation of the
//      IClusCfgStartupListener interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CIISClusCfg
:   public IClusCfgStartupListener,
    public IClusCfgEvictListener
{
private:

    // IUnknown
    LONG    m_cRef;

    // Private constructors and destructors
    CIISClusCfg( void );
    ~CIISClusCfg( void );

    // Private copy constructor to prevent copying.
    CIISClusCfg( const CIISClusCfg & rSrcIn );

    // Private assignment operator to prevent copying.
    const CIISClusCfg & operator = ( const CIISClusCfg & rSrcIn );

    HRESULT HrInit( void );
    HRESULT HrCleanupResourceTypes( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrRegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgStartupListener
    //

    STDMETHOD( Notify ) ( IUnknown * punkIn );

    //
    // IClusCfgEvictListener
    //

    STDMETHOD( EvictNotify )( LPCWSTR pcszNodeNameIn );

}; //*** class CIISClusCfg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\exe\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended 
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed 
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      Cristian Scutaru (CScutaru) 22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>

DEFINE_MODULE( "CLUSCFG" )

HINSTANCE g_hInstance;
LONG      g_cObjects;

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int 
_cdecl
main( void )
{
    HRESULT hr;

    TraceInitializeProcess( NULL, 0 );

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    CoUninitialize( );

    TraceTerminateProcess( NULL, 0 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\iiscluscfg\iiscluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Module Name:
//      CIISClusCfg.cpp
//
//  Description:
//      Main implementation for the IClusCfgStartupListener sample program.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IISClusCfg.h"

#include <lm.h>         // Required for the references in this module.


//////////////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////////////

static PCWSTR  g_apszResourceTypesToDelete[] =
{
    L"IIS Server Instance",
    L"SMTP Server Instance",
    L"NNTP Server Instance",
    L"IIS Virtual Root",

    //
    //  KB: 18-JUN-2002 GalenB
    //
    //  Since we don't think we are going to be sending this component to
    //  IIS it is simpler and faster to add this non IIS resource type to this
    //  component.  If this component is ever handed off to IIS then we
    //  need to remove this resource type from this table.
    //

    L"Time Service",
    NULL
};


//***************************************************************************
//
//  CIISClusCfg class
//
//***************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CIISClusCfg::S_HrCreateInstance
//
//  Description:
//      Create a CIISClusCfg instance.
//
//  Arguments:
//      riidIn      - ID of the interface to return.
//      ppunkOut    - The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          ppunkOut was NULL.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIISClusCfg::S_HrCreateInstance(
      IUnknown ** ppunkOut
    )
{
    HRESULT         hr = S_OK;
    CIISClusCfg *   pmsl = NULL;

    if ( ppunkOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if:

    pmsl = new CIISClusCfg();
    if ( pmsl == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if: error allocating object

    hr = pmsl->HrInit();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = pmsl->QueryInterface( IID_IUnknown,  reinterpret_cast< void ** >( ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( pmsl != NULL )
    {
        pmsl->Release();
    } // if:

    return hr;

} //*** CIISClusCfg::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIISClusCfg::S_HrRegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it
//      belongs to.
//
//  Arguments:
//      picrIn
//          Used to register/unregister our CATID support.
//
//      fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIISClusCfg::S_HrRegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    HRESULT hr = S_OK;
    CATID   rgCatIds[ 2 ];

    if ( picrIn == NULL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_ClusCfgStartupListeners;
    rgCatIds[ 1 ] = CATID_ClusCfgEvictListeners;

    if ( fCreateIn )
    {
        hr = picrIn->RegisterClassImplCategories( CLSID_IISClusCfg, RTL_NUMBER_OF( rgCatIds ), rgCatIds );
    } // if: registering

    //
    //  KB: 24-SEP-2001 GalenB
    //
    //  This code is not needed since this component has been temporarily placed in ClusCfgSrv.dll.  Our
    //  cleanup code does a tree delete the whole registry key and that cleanups up the CATID stuff.
    //

/*
    else
    {
        hr = picrIn->UnRegisterClassImplCategories( CLSID_IISClusCfg, ARRAYSIZE( rgCatIds ), rgCatIds );
    } // else: unregistering
*/

Cleanup:

    return hr;

} //*** CIISClusCfg::S_HrRegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIISClusCfg::CIISClusCfg
//
//  Description:
//      Constructor of CIISClusCfg. Initializes m_cRef to 1 to avoid
//      problems when called from DllGetClassObject. Increments the global
//      object count to avoid DLL unload.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIISClusCfg::CIISClusCfg( void )
    : m_cRef( 1 )
{
    //
    //  Increment the count of components in memory so the DLL hosting this
    //  object cannot be unloaded.
    //

    InterlockedIncrement( &g_cObjects );

} //*** CIISClusCfg::CIISClusCfg


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIISClusCfg::~CIISClusCfg
//
//  Description:
//      Destructor of CIISClusCfg. Decrements the global object count.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIISClusCfg::~CIISClusCfg( void )
{
    // There's going to be one less component in memory.
    // Decrement component count.
    InterlockedDecrement( &g_cObjects );

} //*** CIISClusCfg::~CIISClusCfg


//***************************************************************************
//
//  IUnknown interface
//
//***************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIISClusCfg::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIISClusCfg::AddRef( void )
{
    return InterlockedIncrement( &m_cRef );

} //*** CIISClusCfg::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIISClusCfg::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//      If this reaches 0, the object will be automatically deleted.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIISClusCfg::Release( void )
{
    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        delete this;
    } // if:

    return cRef;

} //*** CIISClusCfg::Release

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIISClusCfg::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//      This class implements the following interfaces:
//
//          IUnknown
//          IClusCfgStarutpListener
//
//  Arguments:
//      riidIn  - Id of interface requested.
//      ppvOut  - Pointer to the requested interface.  NULL if unsupported.
//
//  Return Value:
//      S_OK            - If the interface is available on this object.
//      E_POINTER       - ppvOut was NULL.
//      E_NOINTERFACE   - If the interface is not available.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIISClusCfg::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    if ( ppvOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        //
        // We static_cast to IClusCfgStartupListener* to avoid conflicts
        // if this class should inherit IUnknown from more than one
        // interface.
        //

        *ppvOut = static_cast< IClusCfgStartupListener * >( this );
    } // if:
    else if ( IsEqualIID( riidIn, IID_IClusCfgStartupListener ) )
    {
        *ppvOut = static_cast< IClusCfgStartupListener * >( this );
    } // else if:
    else if ( IsEqualIID( riidIn, IID_IClusCfgEvictListener ) )
    {
        *ppvOut = static_cast< IClusCfgEvictListener * >( this );
    } // else if:
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        //
        // We will return an interface pointer, so the reference counter needs to
        // be incremented.
        //

        ((IUnknown *) *ppvOut)->AddRef();
    } // if:

Cleanup:

    return hr;

} //*** CIISClusCfg::QueryInterface



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIISClusCfg::HrCleanupResourceTypes
//
//  Description:
//      This function will clean up any resource types leftover from a Windows 2000
//      cluster installation which are no longer supported.
//
//  Arguments:
//      none
//
//  Return Value:
//      S_OK
//          Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIISClusCfg::HrCleanupResourceTypes( void )
{
    HRESULT             hr                  = S_OK;
    DWORD               sc                  = ERROR_SUCCESS;
    HCLUSTER            hCluster            = NULL;
    WCHAR               szClusterName[ MAX_PATH ];
    DWORD               cchClusterName      = RTL_NUMBER_OF( szClusterName );
    CLUSTERVERSIONINFO  clusterInfo;
    PCWSTR *            ppszResType;

    //
    //  Open the local cluster service.  We can do this since we are running on the
    //  node that evicted the node, not the node that was evicted...
    //

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[IISCLUSCFG] Error opening connection to local cluster service. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    //  Check if the entire cluster is running Windows Server 2003 (NT 5.1).
    //

    sc = GetClusterInformation( hCluster, szClusterName, &cchClusterName, &clusterInfo );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[IISCLUSCFG] Error getting the cluster version information. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    //  If the whole cluster is Windows Server 2003, then the highest version will be NT51, and
    //  the lowest version will be NT5.  This is because ClusterHighestVersion is set to the
    //  min of the highest version that all nodes can "speak", and ClusterLowestVersion is set to the
    //  max of the lowest version that all nodes can speak.
    //

    if (   ( CLUSTER_GET_MAJOR_VERSION( clusterInfo.dwClusterHighestVersion ) == NT51_MAJOR_VERSION )
        && ( CLUSTER_GET_MAJOR_VERSION( clusterInfo.dwClusterLowestVersion ) == NT5_MAJOR_VERSION ) )
    {
        //
        //  We don't need to enumerate resources to make sure
        //  that no IIS resources exist before we delete the resource types.  The deletion
        //  of a resource type will fail if resources of that type exist.
        //

        for ( ppszResType = g_apszResourceTypesToDelete; *ppszResType != NULL; ++ppszResType )
        {
            //
            //  ERROR_SUCCESS: successful deletion.
            //
            //  ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: no problem.  The resource type didn't exist,
            //      so this must be a fresh Windows Server 2003 installation, not an upgrade.
            //
            //  ERROR_DIR_NOT_EMPTY: a resource of that type exists.  In this case we require manual
            //      intervention by an administrator.

            sc = DeleteClusterResourceType( hCluster, *ppszResType );
            if ( sc == ERROR_SUCCESS )
            {
                LogMsg( L"[IISCLUSCFG] Successfully deleted resource type \"%ws\". (hr = %#08x)", *ppszResType, HRESULT_FROM_WIN32( sc ) );
                continue;
            } // if: resource type was deleted.
            else if ( sc == ERROR_DIR_NOT_EMPTY )
            {
                LogMsg( L"[IISCLUSCFG] Could not delete resource type \"%ws\" because there are resources of this type. Trying the next resource type in the table... (hr = %#08x)", *ppszResType, HRESULT_FROM_WIN32( sc ) );
                continue;
            } // else if: resources of this type exist.
            else if ( sc == ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND )
            {
                LogMsg( L"[IISCLUSCFG] Could not delete resource type \"%ws\" because the resource type was not found. Trying the next resource type in the table... (hr = %#08x)", *ppszResType, HRESULT_FROM_WIN32( sc ) );
                continue;
            } // else if: resource type was not found.
            else
            {
                //
                //  We failed to delete the resource type.
                //

                //
                //  Keep track of the last failure.
                //  But don't bail out.  Keep deleting the other types.
                //

                hr = HRESULT_FROM_WIN32( sc );
                LogMsg( L"[IISCLUSCFG] Unexpected error deleting resource type \"%ws\". Trying the next resource type in the table... (hr = %#08x)", *ppszResType, hr );
            } // else: some unknown error.
        } // for: each resource type in the table.
    } // if: this cluster is 100% Windows Server 2003.

Cleanup:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    return hr;

} //*** CIISClusCfg::HrCleanupResourceTypes


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgStartupListener]
//  CIISClusCfg::Notify
//
//  Description:
//      This function gets called just after the cluster service has started.
//
//  Arguments:
//      punkIn
//          Pointer to a COM object that implements
//          IClusCfgResourceTypeCreate.
//
//  Return Value:
//      S_OK
//          Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIISClusCfg::Notify(
    IUnknown * /*unused: punkIn*/ )
{
    HRESULT hr = S_OK;

    LogMsg( L"[IISCLUSCFG] Entering startup notify... (hr = %#08x)", hr );

    hr = HrCleanupResourceTypes();

    LogMsg( L"[IISCLUSCFG] Leaving startup notify... (hr = %#08x)", hr );

    return hr;

} //*** IISClusCfg::Notify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgEvictListener]
//  CIISClusCfg::EvictNotify
//
//  Description:
//      This function gets called after a node has been evicted.
//
//  Arguments:
//      pcszNodeNameIn
//          The name of the node that has been evicted.
//
//  Return Value:
//      S_OK
//          Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIISClusCfg::EvictNotify(
    PCWSTR /* unused: pcszNodeNameIn */ )
{
    HRESULT hr = S_OK;

    LogMsg( L"[IISCLUSCFG] Entering evict cleanup notify... (hr = %#08x)", hr );

    hr = HrCleanupResourceTypes();

    LogMsg( L"[IISCLUSCFG] Leaving evict cleanup notify... (hr = %#08x)", hr );

    return hr;

} //*** IISClusCfg::EvictNotify


//***************************************************************************
//
//  Private methods
//
//***************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIISClusCfg::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - Operation completed successfully.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIISClusCfg::HrInit( void )
{
    HRESULT     hr = S_OK;

    // IUnknown
    //Assert( m_cRef == 1 );

    return hr;

} //*** CIISClusCfg::HrInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\evictnotify\evictnotify.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      EvictNotify.h
//
//  Description:
//      This file contains the declaration of the CEvictNotify
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      EvictNotify.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB)   20-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgStartup
#include "ClusCfgServer.h"

// For ILogger
#include <ClusCfgClient.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEvictNotify
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEvictNotify
    : public IClusCfgEvictNotify
    , public IClusCfgCallback
{
private:
    LONG    m_cRef;     // Reference count for this object.

    // IClusCfgCallback
    BSTR                m_bstrNodeName;         // Name of the local node.
    ILogger *           m_plLogger;             // ILogger for doing logging.

    // Second phase of a two phase constructor.
    HRESULT HrInit( void );

    // Enumerate all components on the local computer registered for cluster
    // startup notification.
    HRESULT HrNotifyListeners( LPCWSTR pcszNodeNameIn );

    // Instantiate a cluster evict listener component and call the
    // appropriate methods.
    HRESULT HrProcessListener(
        const CLSID &   rclsidListenerCLSIDIn
      , LPCWSTR         pcszNodeNameIn
      );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CEvictNotify( void );

    // Destructor.
    ~CEvictNotify( void );

    // Copy constructor.
    CEvictNotify( const CEvictNotify & );

    // Assignment operator.
    CEvictNotify & operator =( const CEvictNotify & );

public:

    //
    // IUnknown methods
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  IClusCfgEvictNotify methods
    //

    // Send out notification of cluster service startup to interested listeners
    STDMETHOD( SendNotifications )( LPCWSTR pcszNodeNameIn );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( SendStatusReport )(
                      LPCWSTR       pcszNodeNameIn
                    , CLSID         clsidTaskMajorIn
                    , CLSID         clsidTaskMinorIn
                    , ULONG         ulMinIn
                    , ULONG         ulMaxIn
                    , ULONG         ulCurrentIn
                    , HRESULT       hrStatusIn
                    , LPCWSTR       pcszDescriptionIn
                    , FILETIME *    pftTimeIn
                    , LPCWSTR       pcszReference
                    );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

}; //*** class CEvictNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\iiscluscfg\iiscluscfgguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Module Name:
//      Guids.h
//
//  Description:
//      This file contains both internal and external GUID definitions.
//
//////////////////////////////////////////////////////////////////////////////

//
//  Component CLSIDs
//

// TODO: Regenerate this GUID and rename CLSID
// {9DBE976E-32CB-426a-A8B1-26F60D1F5CCB}
DEFINE_GUID( CLSID_IISClusCfg,
0x9dbe976e, 0x32cb, 0x426a, 0xa8, 0xb1, 0x26, 0xf6, 0xd, 0x1f, 0x5c, 0xcb );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\cluscfginternalguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfgInternalGuids.h
//
//  Description:
//      Microsoft internal-use-only cluster configuration GUID definitions.
//
//  Maintained By:
//      John Franco (JFranco)   01-JUL-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
//  CoCreateable class IDs
//

// {32152BE9-DE8C-4d0f-81B0-BCE5D11ECB00}
DEFINE_GUID( CLSID_ClusCfgEvictCleanup,
0x32152be9, 0xde8c, 0x4d0f, 0x81, 0xb0, 0xbc, 0xe5, 0xd1, 0x1e, 0xcb, 0x0 );

// {08F35A72-D7C4-42f4-BC81-5188E19DFA39}
DEFINE_GUID( CLSID_ClusCfgAsyncEvictCleanup,
0x8f35a72, 0xd7c4, 0x42f4, 0xbc, 0x81, 0x51, 0x88, 0xe1, 0x9d, 0xfa, 0x39 );

// {105EEEB6-32FD-4ea9-8912-843A7FF3CA2D}
DEFINE_GUID( CLSID_ClusCfgStartupNotify,
0x105eeeb6, 0x32fd, 0x4ea9, 0x89, 0x12, 0x84, 0x3a, 0x7f, 0xf3, 0xca, 0x2d );

// {B57FF15E-D0D9-4ae9-9022-973E3BFDCDDE}
DEFINE_GUID( CLSID_ClusCfgEvictNotify,
0xb57ff15e, 0xd0d9, 0x4ae9, 0x90, 0x22, 0x97, 0x3e, 0x3b, 0xfd, 0xcd, 0xde );

// {ABD0388A-DEC1-44f3-98E1-8D5CC80B97EB}
DEFINE_GUID( CLSID_ServiceManager,
0xabd0388a, 0xdec1, 0x44f3, 0x98, 0xe1, 0x8d, 0x5c, 0xc8, 0x0b, 0x97, 0xeb );


//
//  Class IDs for use with ServiceManager::QueryService
//

// {955661BD-CCA2-4eac-91D0-A0396A28AEFD}
DEFINE_GUID( CLSID_ObjectManager,
0x955661bd, 0xcca2, 0x4eac, 0x91, 0xd0, 0xa0, 0x39, 0x6a, 0x28, 0xae, 0xfd );

// {E1813DD0-AADA-4738-B5FF-96B4189C5019}
DEFINE_GUID( CLSID_NotificationManager,
0xe1813dd0, 0xaada, 0x4738, 0xb5, 0xff, 0x96, 0xb4, 0x18, 0x9c, 0x50, 0x19 );

// {C0F615A7-F874-4521-8791-ED3B84017EF7}
DEFINE_GUID( CLSID_TaskManager,
0xc0f615a7, 0xf874, 0x4521, 0x87, 0x91, 0xed, 0x3b, 0x84, 0x01, 0x7e, 0xf7 );


//
//  Object Type Guids
//

// {1AAA3D11-4792-44e4-9D49-78FED3691A14}
DEFINE_GUID( CLSID_NodeType,
0x1aaa3d11, 0x4792, 0x44e4, 0x9d, 0x49, 0x78, 0xfe, 0xd3, 0x69, 0x1a, 0x14 );

// {D4F3D51B-1755-4953-9C8B-2495ABE5E07E}
DEFINE_GUID( CLSID_NetworkType,
0xd4f3d51b, 0x1755, 0x4953, 0x9c, 0x8b, 0x24, 0x95, 0xab, 0xe5, 0xe0, 0x7e );

// {BF3768C2-E0E5-448f-952B-25D4332DEFA3}
DEFINE_GUID( CLSID_ClusterConfigurationType,
0xbf3768c2, 0xe0e5, 0x448f, 0x95, 0x2b, 0x25, 0xd4, 0x33, 0x2d, 0xef, 0xa3 );



//
//  Data Format Guids (DFGUIDs)
//


#define DFGUID_ClusterConfigurationInfo IID_IClusCfgClusterInfo

#define DFGUID_NodeInformation IID_IClusCfgNodeInfo

#define DFGUID_EnumManageableNetworks IID_IEnumClusCfgNetworks




//
//  Tasks
//

// {3140B5A6-9AFA-4588-8CA0-9BE8F8B61506}
DEFINE_GUID( TASK_AnalyzeCluster,
0x3140b5a6, 0x9afa, 0x4588, 0x8c, 0xa0, 0x9b, 0xe8, 0xf8, 0xb6, 0x15, 0x6 );

// {8A9CAE3A-9800-4816-8927-D825C97DB8B7}
DEFINE_GUID( TASK_AnalyzeClusterMinConfig,
0x8a9cae3a, 0x9800, 0x4816, 0x89, 0x27, 0xd8, 0x25, 0xc9, 0x7d, 0xb8, 0xb7 );

// {2D03030B-F084-4807-BBAC-94269E50B56F}
DEFINE_GUID( TASK_CommitClusterChanges,
0x2d03030b, 0xf084, 0x4807, 0xbb, 0xac, 0x94, 0x26, 0x9e, 0x50, 0xb5, 0x6f );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\iiscluscfg\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Windows.h>
#include <ObjBase.h>
#include <ComCat.h>

#include <clusapi.h>

#include <Log.h>

//
// Interface definitions for IClusCfgStartupListener
//

#include <ClusCfgServer.h>

//
// Categories and ClusCfg GUIDS needed by the main program
//

#include <ClusCfgGuids.h>
#include <IISClusCfgGuids.h>

#include <StrSafe.h>

extern  LONG        g_cObjects;
extern  HINSTANCE   g_hInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\commonstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CommonStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      David Potter    (DavidP)    01-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

//////////////////////////////////////////////////////////////////////////////
//  Informational Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_INFO_NOT_MANAGED_NETWORKS                   ( ID_COMMON_START + 0 )
#define IDS_INFO_NOT_MANAGED_NETWORKS_REF               ( ID_COMMON_START + 1 )

//////////////////////////////////////////////////////////////////////////////
//  Warning Strings
//////////////////////////////////////////////////////////////////////////////

// The cluster IP address is already in use.
#define IDS_ERROR_IP_ADDRESS_IN_USE_REF                 ( ID_COMMON_START + 200 )

//////////////////////////////////////////////////////////////////////////////
//  Error Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_ERROR_NULL_POINTER                          ( ID_COMMON_START + 600 )
#define IDS_ERROR_NULL_POINTER_REF                      ( ID_COMMON_START + 601 )

#define IDS_ERROR_INVALIDARG                            ( ID_COMMON_START + 610 )
#define IDS_ERROR_INVALIDARG_REF                        ( ID_COMMON_START + 611 )

#define IDS_ERROR_OUTOFMEMORY                           ( ID_COMMON_START + 620 )
#define IDS_ERROR_OUTOFMEMORY_REF                       ( ID_COMMON_START + 621 )

#define IDS_ERROR_WIN32                                 ( ID_COMMON_START + 630 )
#define IDS_ERROR_WIN32_REF                             ( ID_COMMON_START + 631 )

#define IDS_UNKNOWN_QUORUM                              ( ID_COMMON_START + 640 )
#define IDS_DISK                                        ( ID_COMMON_START + 641 )
#define IDS_LOCALQUORUM                                 ( ID_COMMON_START + 642 )
#define IDS_MAJORITY_NODE_SET                           ( ID_COMMON_START + 643 )

#define IDS_PROCESSOR_ARCHITECTURE_UNKNOWN              ( ID_COMMON_START + 650 )
#define IDS_PROCESSOR_ARCHITECTURE_INTEL                ( ID_COMMON_START + 651 )
#define IDS_PROCESSOR_ARCHITECTURE_MIPS                 ( ID_COMMON_START + 652 )
#define IDS_PROCESSOR_ARCHITECTURE_ALPHA                ( ID_COMMON_START + 653 )
#define IDS_PROCESSOR_ARCHITECTURE_PPC                  ( ID_COMMON_START + 654 )
#define IDS_PROCESSOR_ARCHITECTURE_IA64                 ( ID_COMMON_START + 655 )
#define IDS_PROCESSOR_ARCHITECTURE_AMD64                ( ID_COMMON_START + 656 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\criticalsection.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CriticalSection.h
//
//  Implementation Files:
//      CriticalSection.cpp
//
//  Description:
//      This file contains the declaration of the CCriticalSection
//      class.
//
//      The class CCriticalSection is a simple wrapper around Platform SDK
//      spinlock objects.
//
//  Maintained By:
//      John Franco (jfranco) 03-Oct-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCriticalSection
//
//  Description:
//      The class CCriticalSection is a simple wrapper around Platform SDK
//      spinlock objects.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCriticalSection
{
public:

    CCriticalSection( DWORD cSpinsIn = RECOMMENDED_SPIN_COUNT );
    ~CCriticalSection( void );

    HRESULT HrInitialized( void ) const;

    void Enter( void );
    void Leave( void );

private:

    CCriticalSection( const CCriticalSection & );
    CCriticalSection & operator=( const CCriticalSection & );

    CRITICAL_SECTION    m_csSpinlock;
    HRESULT             m_hrInitialization;

}; //*** class CCriticalSection

//////////////////////////////////////////////////////////////////////////
//++
//
//  CCriticalSection::HrInitialized
//
//  Description:
//      Find out whether the critical section initialized itself.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK: the critical section initialized itself successfully.
//      Failure: initialization failed; the critical section is unusable.
//
//--
//////////////////////////////////////////////////////////////////////////
inline
HRESULT
CCriticalSection::HrInitialized( void ) const
{
    return m_hrInitialization;

} //*** CCriticalSection::HrInitialized


//////////////////////////////////////////////////////////////////////////
//++
//
//  CCriticalSection::Enter
//
//  Description:
//      Acquire the spin lock, blocking if necessary until
//      it becomes available.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////
inline
void
CCriticalSection::Enter( void )
{
    Assert( SUCCEEDED( m_hrInitialization ) );
    EnterCriticalSection( &m_csSpinlock );

} //*** CCriticalSection::Enter

//////////////////////////////////////////////////////////////////////////
//++
//
//  CCriticalSection::Leave
//
//  Description:
//      Release the spin lock.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      This thread must own the lock from calling CCriticalSection::Enter.
//
//--
//////////////////////////////////////////////////////////////////////////
inline void
CCriticalSection::Leave( void )
{
    Assert( SUCCEEDED( m_hrInitialization ) );
    LeaveCriticalSection( &m_csSpinlock );

} //*** CCriticalSection::Leave
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\cluscfgdef.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfgDef.h
//
//  Description:
//      This file contains constants,macros,etc needed by more than one ClusCfg Wizard
//      component.
//
//  Maintained By:
//	    Ozan Ozhan   (OzanO)    09-JUL-2001
//      Galen Barbee (GalenB)   23-FEB-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////

#define HR_S_RPC_S_SERVER_UNAVAILABLE   MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE )
#define HR_S_RPC_S_CLUSTER_NODE_DOWN    MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_CLUSTER_NODE_DOWN )
#define HR_RPC_INSUFFICIENT_BUFFER      HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER )

//
// Minimum storage size we allow on a quorum resource
//
#define MINIMUM_STORAGE_SIZE    50

//
// We'll select the smallest disk larger than the optimum storage size, if there's any, as the quorum resource
//
#define OPTIMUM_STORAGE_SIZE    500

const HRESULT   E_PROPTYPEMISMATCH = HRESULT_FROM_WIN32( ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH );
const WCHAR     g_szNameSpaceRoot[] = { L"\\\\?\\GLOBALROOT" };
const WCHAR     g_szUnknownQuorumUID[] = { L"Unknown Quorum" };

const int       STATUS_CONNECTED = 2;

//
//  Time out and wait values...
//

//
// Default timeout value for anything that doesn't use INFINITE wait within ClusCfg.
//

const DWORD CC_DEFAULT_TIMEOUT = 300000;                                                    // 5 minutes


//
//  Limiting user name lengths according to "Naming Properties" and "Example Code for Creating a User"
//  topics under Active Directory in MSDN
//

#define MAX_USERNAME_LENGTH 20


//////////////////////////////////////////////////////////////////////////////
// Server Component Macros
//////////////////////////////////////////////////////////////////////////////

#define LOG_STATUS_REPORT( _psz_, _hr_ ) \
    THR( HrSendStatusReport( \
                          m_picccCallback \
                        , TASKID_Major_Server_Log \
                        , IID_NULL \
                        , 1 \
                        , 1 \
                        , 1 \
                        , _hr_\
                        , _psz_ \
                        ) )

#define LOG_STATUS_REPORT_STRING( _pszFormat_, _arg0_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , IID_NULL \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) && SUCCEEDED( _hr_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING2( _pszFormat_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , IID_NULL \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_\
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING3( _pszFormat_, _arg0_, _arg1_, _arg2_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_, _arg2_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , IID_NULL \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_\
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_MINOR( _minor_, _psz_, _hr_ ) \
    THR( HrSendStatusReport( \
                          m_picccCallback \
                        , TASKID_Major_Server_Log \
                        , _minor_ \
                        , 1 \
                        , 1 \
                        , 1 \
                        , _hr_ \
                        , _psz_ \
                        ) )

#define LOG_STATUS_REPORT_STRING_MINOR( _minor_, _pszFormat_, _arg0_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) && SUCCEEDED( _hr_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING_MINOR2( _minor_, _pszFormat_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) && SUCCEEDED( _hr_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING_MINOR3( _minor_, _pszFormat_, _arg0_, _arg1_, _arg2_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_, _arg2_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , TASKID_Major_Server_Log \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) && SUCCEEDED( _hr_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT( _major_, _minor_, _uid_, _hr_ ) \
    THR( HrSendStatusReport( \
                          m_picccCallback \
                        , _major_ \
                        , _minor_ \
                        , 1 \
                        , 1 \
                        , 1 \
                        , _hr_\
                        , _uid_ \
                        ) )

#define STATUS_REPORT_STRING( _major_, _minor_, _idsFormat_, _arg0_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_STRING2( _major_, _minor_, _idsFormat_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_STRING3( _major_, _minor_, _idsFormat_, _arg0_, _arg1_, _arg2_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_, _arg1_, _arg2_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_NODESTRING( _node_, _major_, _minor_, _idsFormat_, _arg0_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _node_ \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_NODESTRING2( _node_, _major_, _minor_, _idsFormat_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _node_ \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_NODESTRING3( _node_, _major_, _minor_, _idsFormat_, _arg0_, _arg1_, _arg2_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_, _arg1_, _arg2_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _node_ \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }


#define STATUS_REPORT_REF( _major_, _minor_, _idsMsg_, _idsRef_, _hr_ ) \
    THR( HrSendStatusReport( \
                       m_picccCallback \
                    , _major_ \
                    , _minor_ \
                    , 1 \
                    , 1 \
                    , 1 \
                    , _hr_ \
                    , (DWORD) _idsMsg_ \
                    , (DWORD) _idsRef_ \
                    ) )

#define STATUS_REPORT_STRING_REF( _major_, _minor_, _idsFormat_, _arg0_, _idsRef_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , _idsRef_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_STRING2_REF( _major_, _minor_, _idsFormat_, _arg0_, _arg1_, _idsRef_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _idsFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        _hrTemp_ = THR( HrSendStatusReport( \
                              m_picccCallback \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , _idsRef_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }


//////////////////////////////////////////////////////////////////////////////
// PostCfg Macros
//////////////////////////////////////////////////////////////////////////////


#define STATUS_REPORT_POSTCFG( _major_, _minor_, _uid_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }


#define STATUS_REPORT_POSTCFG1( _major_, _minor_, _uid_, _hr_, _arg0_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }


#define STATUS_REPORT_MINOR_POSTCFG( _major_, _uid_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrTemp_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }


#define STATUS_REPORT_MINOR_POSTCFG1( _major_, _uid_, _hr_, _arg0_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }



#define STATUS_REPORT_MINOR_POSTCFG2( _major_, _uid_, _hr_, _arg0_ , _arg1_) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_, _arg1_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }




//  REF version MACROS


#define STATUS_REPORT_REF_POSTCFG( _major_, _minor_, _uid_, _uidref_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        BSTR    _bstrRefMsg_ = NULL; \
        HRESULT _hrMsg_; \
        HRESULT _hrRef_; \
        HRESULT _hrTemp_; \
        \
        _hrMsg_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_ ) );\
        _hrRef_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uidref_, &_bstrRefMsg_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrMsg_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , _hrRef_ == S_OK ? _bstrRefMsg_ : L"The reference for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
        TraceSysFreeString( _bstrRefMsg_ ); \
    }


#define STATUS_REPORT_REF_POSTCFG1( _major_, _minor_, _uid_, _uidref_, _hr_, _arg0_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        BSTR    _bstrRefMsg_ = NULL; \
        HRESULT _hrTemp_; \
        HRESULT _hrMsg_; \
        HRESULT _hrRef_; \
        \
        _hrMsg_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_ ) );\
        _hrRef_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uidref_, &_bstrRefMsg_, _arg0_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrMsg_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , _hrRef_ == S_OK ? _bstrRefMsg_ : L"The reference for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
        TraceSysFreeString( _bstrRefMsg_ ); \
    }


#define STATUS_REPORT_MINOR_REF_POSTCFG( _major_, _uid_, _uidref_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        BSTR    _bstrRefMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        HRESULT _hrMsg_; \
        HRESULT _hrRef_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrMsg_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_ ) ); \
        _hrRef_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uidref_, &_bstrRefMsg_ ) ); \
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrMsg_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , _hrRef_ == S_OK ? _bstrRefMsg_ : L"The reference for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
        TraceSysFreeString( _bstrRefMsg_ ); \
    }


#define STATUS_REPORT_MINOR_REF_POSTCFG1( _major_, _uid_, _uidref_, _hr_, _arg0_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        BSTR    _bstrRefMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        HRESULT _hrMsg_; \
        HRESULT _hrRef_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrMsg_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_ ) );\
        _hrRef_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uidref_, &_bstrRefMsg_, _arg0_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrMsg_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , _hrRef_ == S_OK ? _bstrRefMsg_ : L"The reference for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
        TraceSysFreeString( _bstrRefMsg_ ); \
    }



#define STATUS_REPORT_MINOR_REF_POSTCFG2( _major_, _uid_, _uidref_, _hr_, _arg0_ , _arg1_) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        BSTR    _bstrRefMsg_ = NULL; \
        HRESULT _hrTemp_; \
        CLSID   _clsidMinorId_; \
        HRESULT _hrMsg_; \
        HRESULT _hrRef_; \
        \
        _hrTemp_ = THR( CoCreateGuid( &_clsidMinorId_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _clsidMinorId_ = IID_NULL; \
        } \
        \
        _hrMsg_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_, _arg0_, _arg1_ ) );\
        _hrRef_ = THR( HrFormatStringIntoBSTR(  g_hInstance, _uidref_, &_bstrRefMsg_, _arg0_, _arg1_ ) );\
        _hrTemp_ = THR( SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _clsidMinorId_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrMsg_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , _hrRef_ == S_OK ? _bstrRefMsg_ : L"The reference for this entry could not be located." \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
        TraceSysFreeString( _bstrRefMsg_ ); \
    }


#define STATUS_REPORT_PTR_POSTCFG( _pcpcmThis_, _major_, _minor_, _uid_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrLoadStringIntoBSTR(  g_hInstance, _uid_, &_bstrMsg_ ) );\
        _hrTemp_ = THR( _pcpcmThis_->SendStatusReport( \
                              NULL \
                            , _major_ \
                            , _minor_ \
                            , 1 \
                            , 1 \
                            , 1 \
                            , _hr_ \
                            , _hrTemp_ == S_OK ? _bstrMsg_ : L"The description for this entry could not be located." \
                            , NULL \
                            , NULL \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\dispatchhandler.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      DispatchHandler.h
//
//  Description:
//      This file contains a template to use as a base class for an
//      implementation of an IDispatch-based interface.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      John Franco (jfranco) 17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Template Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  template class TDispatchHandler
// 
//  Description:
//      TDispatchHandler provides a type library-based implementation of
//      IDispatch for use by classes that implement a dual interface.
//      Instructions for use:
//          - inherit from TDispatchHandler< t_Interface > instead of
//              directly from t_Interface
//          - call HrInit with the type library's GUID when initializing
//              each instance
//          - return static_cast< TDispatchHandler< t_Interface >* >( this )
//              in response to a QueryInterface request for IID_IDispatch.
//
//  Template Arguments:
//      t_Interface
//          The dual interface implemented by the derived class.
//          Requirements for t_Interface:
//              - has dual attribute in IDL
//              - based on IDispatch
//              - included in type library
//
//--
//////////////////////////////////////////////////////////////////////////////

template < class t_Interface >
class TDispatchHandler
    : public t_Interface
{
private:

    ITypeInfo * m_ptypeinfo;

    // Private copy constructor to prevent copying.
    TDispatchHandler( const TDispatchHandler & );

    // Private assignment operator to prevent copying.
    TDispatchHandler & operator=( const TDispatchHandler & );

public:

    TDispatchHandler( void );
    virtual ~TDispatchHandler( void );

    virtual HRESULT HrInit( REFGUID rlibid );

    STDMETHOD( GetIDsOfNames )(
          REFIID        riid
        , OLECHAR **    rgszNames
        , unsigned int  cNames
        , LCID          lcid
        , DISPID *      rgDispId
        );

    STDMETHOD( GetTypeInfo )( unsigned int iTInfo, LCID lcid, ITypeInfo ** ppTInfo );

    STDMETHOD( GetTypeInfoCount )( unsigned int * pctinfo );

    STDMETHOD( Invoke )(
          DISPID            dispIdMember
        , REFIID            riid
        , LCID              lcid
        , WORD              wFlags
        , DISPPARAMS *      pDispParams
        , VARIANT *         pVarResult
        , EXCEPINFO *       pExcepInfo
        , unsigned int *    puArgErr
        );

}; //*** template class TDispatchHandler


template < class t_Interface >
TDispatchHandler< t_Interface >::TDispatchHandler( void )
    : m_ptypeinfo( NULL )
{
} //*** TDispatchHandler< t_Interface >::TDispatchHandler


template < class t_Interface >
TDispatchHandler< t_Interface >::~TDispatchHandler( void )
{
    if ( m_ptypeinfo != NULL )
    {
        m_ptypeinfo->Release();
        m_ptypeinfo = NULL;
    }

} //*** TDispatchHandler< t_Interface >::~TDispatchHandler


template < class t_Interface >
HRESULT
TDispatchHandler< t_Interface >::HrInit( REFGUID rlibidIn )
{
    HRESULT hr = S_OK;
    ITypeLib* pitypelib = NULL;

    hr = LoadRegTypeLib(
          rlibidIn
        , 1 // major version number--must match that in IDL
        , 0 // minor version number--must match that in IDL
        , LOCALE_NEUTRAL
        , &pitypelib
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pitypelib->GetTypeInfoOfGuid( __uuidof( t_Interface ), &m_ptypeinfo );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pitypelib != NULL )
    {
        pitypelib->Release();
    }
    return hr;

} //*** TDispatchHandler< t_Interface >::HrInit


template < class t_Interface >
STDMETHODIMP
TDispatchHandler< t_Interface >::GetIDsOfNames(
      REFIID        riid
    , OLECHAR **    rgszNames
    , unsigned int  cNames
    , LCID          lcid
    , DISPID *      rgDispId
    )
{
    return m_ptypeinfo->GetIDsOfNames( rgszNames, cNames, rgDispId );

} //*** TDispatchHandler< t_Interface >::GetIDsOfNames


template < class t_Interface >
STDMETHODIMP
TDispatchHandler< t_Interface >::GetTypeInfo(
      unsigned int  iTInfo
    , LCID          lcid
    , ITypeInfo **  ppTInfo
    )
{
    HRESULT hr = S_OK;
    if ( ppTInfo == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppTInfo = NULL;

    if ( iTInfo > 0 )
    {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto Cleanup;
    }

    m_ptypeinfo->AddRef();
    *ppTInfo = m_ptypeinfo;

Cleanup:

    return hr;

} //*** TDispatchHandler< t_Interface >::GetTypeInfo


template < class t_Interface >
STDMETHODIMP
TDispatchHandler< t_Interface >::GetTypeInfoCount(
    unsigned int * pctinfo
    )
{
    HRESULT hr = S_OK;
    if ( pctinfo == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    
    *pctinfo = 1;

Cleanup:

    return hr;

} //*** TDispatchHandler< t_Interface >::GetTypeInfoCount


template < class t_Interface >
STDMETHODIMP
TDispatchHandler< t_Interface >::Invoke(
      DISPID            dispIdMember
    , REFIID            riid
    , LCID              lcid
    , WORD              wFlags
    , DISPPARAMS *      pDispParams
    , VARIANT *         pVarResult
    , EXCEPINFO *       pExcepInfo
    , unsigned int *    puArgErr
    )
{
    return m_ptypeinfo->Invoke( this, dispIdMember, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr );

} //*** TDispatchHandler< t_Interface >::Invoke
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\cluscfgguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfgGuids.h
//
//  Description:
//      This file contains external GUID definitions.
//
//////////////////////////////////////////////////////////////////////////////

//
//  Category IDs
//

// {4653EEC4-2788-4ebd-A831-7E0D9F82D6E7}
DEFINE_GUID( CATID_ClusCfgCapabilities,
0x4653eec4, 0x2788, 0x4ebd, 0xa8, 0x31, 0x7e, 0xd, 0x9f, 0x82, 0xd6, 0xe7 );

// {02A34F88-D31A-4688-BDDD-38A739E4F89B}
DEFINE_GUID( CATID_EnumClusCfgManagedResources,
0x2a34f88, 0xd31a, 0x4688, 0xbd, 0xdd, 0x38, 0xa7, 0x39, 0xe4, 0xf8, 0x9b );

// {7C4CAE52-CAC9-499d-82C6-BC6A2177E556}
DEFINE_GUID( CATID_ClusCfgResourceTypes,
0x7c4cae52, 0xcac9, 0x499d, 0x82, 0xc6, 0xbc, 0x6a, 0x21, 0x77, 0xe5, 0x56 );

// {8A43EAD4-10F1-440d-8DAA-1FE38D1698CD}
DEFINE_GUID( CATID_ClusCfgMemberSetChangeListeners,
0x8a43ead4, 0x10f1, 0x440d, 0x8d, 0xaa, 0x1f, 0xe3, 0x8d, 0x16, 0x98, 0xcd );

// {DF406DB4-7872-4a99-BB3C-14A9C33933D1}
DEFINE_GUID( CATID_ClusCfgStartupListeners,
0xdf406db4, 0x7872, 0x4a99, 0xbb, 0x3c, 0x14, 0xa9, 0xc3, 0x39, 0x33, 0xd1 );

// {D5B7210F-29A2-4a89-8F3F-FC00D7313C18}
DEFINE_GUID( CATID_ClusCfgEvictListeners,
0xd5b7210f, 0x29a2, 0x4a89, 0x8f, 0x3f, 0xfc, 0x0, 0xd7, 0x31, 0x3c, 0x18 );


//
//  Class IDs
//

// {6A370489-BB52-4727-B740-08F494163478}
DEFINE_GUID( CLSID_ClusCfgResTypeServices,
0x6a370489, 0xbb52, 0x4727, 0xb7, 0x40, 0x8, 0xf4, 0x94, 0x16, 0x34, 0x78 );

//
//  Major Task IDs for categorizing callback notifications from server components.
//

// {B8453B8F-92FD-4350-A6D9-551FD018B791}
DEFINE_GUID( TASKID_Major_Checking_For_Existing_Cluster,
0xb8453b8f, 0x92fd, 0x4350, 0xa6, 0xd9, 0x55, 0x1f, 0xd0, 0x18, 0xb7, 0x91 );

// {93C32F99-39CA-4d38-9D7F-2707CA0EAF46}
DEFINE_GUID( TASKID_Major_Establish_Connection,
0x93c32f99, 0x39ca, 0x4d38, 0x9d, 0x7f, 0x27, 0x7, 0xca, 0xe, 0xaf, 0x46 );

// {CC5E57B1-4520-4672-B4BA-A288EC42946E}
DEFINE_GUID( TASKID_Major_Check_Node_Feasibility,
0xcc5e57b1, 0x4520, 0x4672, 0xb4, 0xba, 0xa2, 0x88, 0xec, 0x42, 0x94, 0x6e);

// {036BF567-2377-4bb3-8AE1-E4104E2EB3C5}
DEFINE_GUID( TASKID_Major_Find_Devices,
0x36bf567, 0x2377, 0x4bb3, 0x8a, 0xe1, 0xe4, 0x10, 0x4e, 0x2e, 0xb3, 0xc5 );

// {EBC8AEFF-10C3-4d5b-AC17-FC0F4C3871B7}
DEFINE_GUID( TASKID_Major_Check_Cluster_Feasibility,
0xebc8aeff, 0x10c3, 0x4d5b, 0xac, 0x17, 0xfc, 0xf, 0x4c, 0x38, 0x71, 0xb7 );

// {E25968DA-9C7B-42db-ADA9-BC4E34F17E6E}
DEFINE_GUID( TASKID_Major_Reanalyze,
0xe25968da, 0x9c7b, 0x42db, 0xad, 0xa9, 0xbc, 0x4e, 0x34, 0xf1, 0x7e, 0x6e );

// {6D47AF1F-7F17-4b80-8FAB-3A2D19B1233D}
DEFINE_GUID( TASKID_Major_Configure_Resource_Types,
0x6d47af1f, 0x7f17, 0x4b80, 0x8f, 0xab, 0x3a, 0x2d, 0x19, 0xb1, 0x23, 0x3d );

// {7C5F0774-1611-42b5-AF3C-6E124AC4D36B}
DEFINE_GUID( TASKID_Major_Configure_Cluster_Services,
0x7c5f0774, 0x1611, 0x42b5, 0xaf, 0x3c, 0x6e, 0x12, 0x4a, 0xc4, 0xd3, 0x6b);

// {411BCDEC-69D3-4485-8D5D-E19EE77A6DD4}
DEFINE_GUID( TASKID_Major_Configure_Resources,
0x411bcdec, 0x69d3, 0x4485, 0x8d, 0x5d, 0xe1, 0x9e, 0xe7, 0x7a, 0x6d, 0xd4 );

// {64ECA0EA-9CB6-4324-9702-DF15C696C30A}
DEFINE_GUID( TASKID_Major_Client_Log,
0x64eca0ea, 0x9cb6, 0x4324, 0x97, 0x2, 0xdf, 0x15, 0xc6, 0x96, 0xc3, 0xa );

// {05AA0768-5F49-49cd-AFDC-96F9D51802D4}
DEFINE_GUID( TASKID_Major_Server_Log,
0x5aa0768, 0x5f49, 0x49cd, 0xaf, 0xdc, 0x96, 0xf9, 0xd5, 0x18, 0x2, 0xd4 );

// {CD36919C-9F31-46b4-A29D-AC87F4E6CC93}
DEFINE_GUID( TASKID_Major_Client_And_Server_Log,
0xcd36919c, 0x9f31, 0x46b4, 0xa2, 0x9d, 0xac, 0x87, 0xf4, 0xe6, 0xcc, 0x93 );

// {6279EE6C-E99C-47ca-A61E-039C75C5C982}
DEFINE_GUID( TASKID_Major_Gather_Resources,
0x6279ee6c, 0xe99c, 0x47ca, 0xa6, 0x1e, 0x3, 0x9c, 0x75, 0xc5, 0xc9, 0x82);

// {5D59A58F-27B4-418d-81D8-1EA68068B3A3}
DEFINE_GUID( TASKID_Major_Gather_Networks,
0x5d59a58f, 0x27b4, 0x418d, 0x81, 0xd8, 0x1e, 0xa6, 0x80, 0x68, 0xb3, 0xa3);


//
// Task IDs for updating the progress bar.
//

// {FDC75680-7DBB-42ca-8003-E4CDB01FF062}
DEFINE_GUID( TASKID_Major_Update_Progress,
0xfdc75680, 0x7dbb, 0x42ca, 0x80, 0x3, 0xe4, 0xcd, 0xb0, 0x1f, 0xf0, 0x62 );

//
//  Resource Types
//

// {CC558763-3386-42ef-B150-BE793344D45F}
DEFINE_GUID( RESTYPE_PhysicalDisk,
0xcc558763, 0x3386, 0x42ef, 0xb1, 0x50, 0xbe, 0x79, 0x33, 0x44, 0xd4, 0x5f );

// {F004656D-5B48-4580-A1F4-C3EC14983D1E}
DEFINE_GUID( RESTYPE_LocalQuorum,
0xf004656d, 0x5b48, 0x4580, 0xa1, 0xf4, 0xc3, 0xec, 0x14, 0x98, 0x3d, 0x1e );

// {56BFAE11-D2F7-4f4f-9952-55AF19BAC3E9}
DEFINE_GUID( RESTYPE_MajorityNodeSet,
0x56bfae11, 0xd2f7, 0x4f4f, 0x99, 0x52, 0x55, 0xaf, 0x19, 0xba, 0xc3, 0xe9);

// {E61ADE71-C79A-4fda-B1DB-A9B8D20C8B14}
DEFINE_GUID( RESTYPE_IPAddress,
0xe61ade71, 0xc79a, 0x4fda, 0xb1, 0xdb, 0xa9, 0xb8, 0xd2, 0xc, 0x8b, 0x14 );

// {C1D2FE1E-D332-445f-8DA1-12E5E2D37CBF}
DEFINE_GUID( RESTYPE_NetworkName,
0xc1d2fe1e, 0xd332, 0x445f, 0x8d, 0xa1, 0x12, 0xe5, 0xe2, 0xd3, 0x7c, 0xbf );

// {D495B46C-9E0A-4c2b-87B7-FE0C8FA1B32A}
DEFINE_GUID( RESTYPE_GenericApplication,
0xd495b46c, 0x9e0a, 0x4c2b, 0x87, 0xb7, 0xfe, 0xc, 0x8f, 0xa1, 0xb3, 0x2a);

// {F372184D-DFDB-4370-A005-E1EF301B23A4}
DEFINE_GUID( RESTYPE_GenericScript,
0xf372184d, 0xdfdb, 0x4370, 0xa0, 0x5, 0xe1, 0xef, 0x30, 0x1b, 0x23, 0xa4 );

// {DF34FB92-EB0D-453f-ACA9-BF804B8E29BD}
DEFINE_GUID( RESTYPE_GenericService,
0xdf34fb92, 0xeb0d, 0x453f, 0xac, 0xa9, 0xbf, 0x80, 0x4b, 0x8e, 0x29, 0xbd);

// {94D40016-7929-43cb-9141-9F266E4DD379}
DEFINE_GUID( RESTYPE_DHCPService,
0x94d40016, 0x7929, 0x43cb, 0x91, 0x41, 0x9f, 0x26, 0x6e, 0x4d, 0xd3, 0x79);

// {41AE0AA4-2E98-4494-A3DD-167F71C8D630}
DEFINE_GUID( RESTYPE_DTC,
0x41ae0aa4, 0x2e98, 0x4494, 0xa3, 0xdd, 0x16, 0x7f, 0x71, 0xc8, 0xd6, 0x30);

// {71504DB2-153B-481b-9D92-8178C00B365D}
DEFINE_GUID( RESTYPE_FileShare,
0x71504db2, 0x153b, 0x481b, 0x9d, 0x92, 0x81, 0x78, 0xc0, 0xb, 0x36, 0x5d);

// {473959AD-E9C6-4ea1-B23E-D13D994E0987}
DEFINE_GUID( RESTYPE_PrintSpooler,
0x473959ad, 0xe9c6, 0x4ea1, 0xb2, 0x3e, 0xd1, 0x3d, 0x99, 0x4e, 0x9, 0x87);

// {CC2E36C3-3337-4b03-B352-9750C19F31F8}
DEFINE_GUID( RESTYPE_WINSService,
0xcc2e36c3, 0x3337, 0x4b03, 0xb3, 0x52, 0x97, 0x50, 0xc1, 0x9f, 0x31, 0xf8);

//
//  Core resources - special 'RESTYPEs' for specifying dependencies.
//

// {29E11D1A-83DE-4f7d-B585-2A51EAF84D61}
DEFINE_GUID( RESTYPE_ClusterNetName,
0x29e11d1a, 0x83de, 0x4f7d, 0xb5, 0x85, 0x2a, 0x51, 0xea, 0xf8, 0x4d, 0x61);

// {F22D82AE-7CF5-4de1-879A-D9627C13F194}
DEFINE_GUID( RESTYPE_ClusterIPAddress,
0xf22d82ae, 0x7cf5, 0x4de1, 0x87, 0x9a, 0xd9, 0x62, 0x7c, 0x13, 0xf1, 0x94);

// {1AD3811C-3832-4a61-9F3E-24741C49A7B0}
DEFINE_GUID( RESTYPE_ClusterQuorum,
0x1ad3811c, 0x3832, 0x4a61, 0x9f, 0x3e, 0x24, 0x74, 0x1c, 0x49, 0xa7, 0xb0);

//
//  Resource Class Types
//

// {12453A47-8C5E-4837-BAC6-B254B8F264CC}
DEFINE_GUID( RESCLASSTYPE_StorageDevice,
0x12453a47, 0x8c5e, 0x4837, 0xba, 0xc6, 0xb2, 0x54, 0xb8, 0xf2, 0x64, 0xcc );

// {2B66E547-4BDF-4ff7-8881-E42CC7664AE4}
DEFINE_GUID( RESCLASSTYPE_QuorumResource,
0x2b66e547, 0x4bdf, 0x4ff7, 0x88, 0x81, 0xe4, 0x2c, 0xc7, 0x66, 0x4a, 0xe4);

// {91EFC60F-C1A3-4bfb-8093-38512F25DAB6}
DEFINE_GUID( RESCLASSTYPE_CoreIPAddress,
0x91efc60f, 0xc1a3, 0x4bfb, 0x80, 0x93, 0x38, 0x51, 0x2f, 0x25, 0xda, 0xb6);

// {D2E3EB68-346F-4cb2-BC0E-83655FC51793}
DEFINE_GUID( RESCLASSTYPE_CoreNetworkName,
0xd2e3eb68, 0x346f, 0x4cb2, 0xbc, 0xe, 0x83, 0x65, 0x5f, 0xc5, 0x17, 0x93);

// {57A80E0F-6F18-458b-A72A-D1170C479390}
DEFINE_GUID( RESCLASSTYPE_IPAddress,
0x57a80e0f, 0x6f18, 0x458b, 0xa7, 0x2a, 0xd1, 0x17, 0xc, 0x47, 0x93, 0x90 );

// {BBA69EB9-F5D0-487b-92AE-1BA10F392158}
DEFINE_GUID( RESCLASSTYPE_NetworkName,
0xbba69eb9, 0xf5d0, 0x487b, 0x92, 0xae, 0x1b, 0xa1, 0xf, 0x39, 0x21, 0x58 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\dynamicarray.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      DynamicArray.h
//
//  Description:
//      This file contains an array template that doesn't throw exceptions.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      John Franco (jfranco) 22-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Template Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment > template
// 
//  Description:
//      DynamicArray stores a variable number of Items in a contiguous block
//      of memory.  It intends to be similar to std::vector, with the main
//      difference being that it handles errors through return values rather
//      than exceptions.
//
//  Template Arguments:
//      Item - the type of the elements in the array.
//          requirements for Item:
//              - default constructor
//
//      Assignment
//          The function that overwrites one Item with another; default is
//          one that assumes Item has an assignment operator that never fails.
//
//          requirements for Assignment:
//              - default constructor
//              - HRESULT operator()( Item &, const Item & ) const;
//              or, PredecessorFunction can be a pointer to a function
//              taking two Item references and returning an HRESULT.
//
//--
//////////////////////////////////////////////////////////////////////////////

namespace Generics
{

template < class Item >
struct DefaultAssignment
{
    HRESULT operator()( Item& rItemDestInOut, const Item& crItemSourceIn ) const
    {
        rItemDestInOut = crItemSourceIn;
        return S_OK;
    }
};


template < class Item, class Assignment = DefaultAssignment<Item> >
class DynamicArray
{
    public:

        typedef Item*           Iterator;
        typedef const Item*     ConstIterator;

        DynamicArray( void );
        ~DynamicArray( void );

            HRESULT HrReserve( size_t cNewCapacityIn );
            HRESULT HrResize( size_t cNewSizeIn, const Item& crItemFillerIn = Item() );
            HRESULT HrPushBack( const Item& crItemToPushIn );
            HRESULT HrPopBack( void );
            HRESULT HrRemove( Iterator ItemToRemoveIn );
            HRESULT HrCompact( void );
            void    Clear( void );
            void    Swap( DynamicArray& rOtherInOut );

            size_t  CCapacity( void ) const;
            size_t  Count( void ) const;
            bool    BEmpty( void ) const;

            Iterator        ItBegin( void );
            ConstIterator   ItBegin( void ) const;

            Iterator        ItEnd( void );
            ConstIterator   ItEnd( void ) const;

            Item&       operator[]( size_t idxItemIn );
            const Item& operator[]( size_t idxItemIn ) const;

    private:

        DynamicArray( const DynamicArray& );
            DynamicArray& operator=( const DynamicArray& );

            HRESULT HrRaiseCapacity( size_t cAmountIn );

        Item*       m_prgItems;
        size_t      m_cItems;
        size_t      m_cCapacity;
        Assignment  m_opAssign;
}; //*** class DynamicArray< Item, Assignment >


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::DynamicArray
//
//  Description:
//      Initializes the array as empty.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
DynamicArray< Item, Assignment >::DynamicArray( void ):
    m_prgItems( NULL ), m_cItems( 0 ), m_cCapacity( 0 ), m_opAssign() {}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::~DynamicArray
//
//  Description:
//      Frees any memory held by the array, invoking destructors of any
//      objects within the array.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
DynamicArray< Item, Assignment >::~DynamicArray( void )
{
    Clear();
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrPushBack
//
//  Description:
//      Appends a copy of an object onto the end of the array,
//      growing the array if necessary.
//
//  Arguments:
//      crItemToPushIn -    The object to copy onto the end of the array.
//
//  Return Values:
//      S_OK    -   The array has added a copy of the object to its end.
//
//      Failure -   Something went wrong, and the array's size is unchanged.
//
//  Remarks:
//
//      Analogous to std::vector::push_back.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline HRESULT DynamicArray< Item, Assignment >::HrPushBack( const Item& crItemToPushIn )
{
    HRESULT hr = S_OK;
    
    //  Raise capacity if necessary.
    if ( m_cCapacity == 0 )
    {
        hr = HrRaiseCapacity( 1 );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else if ( m_cItems == m_cCapacity )
    {
        hr = HrRaiseCapacity( m_cCapacity );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //  Copy crItemToPushIn into space just after any current contents.
    hr = m_opAssign( m_prgItems[ m_cItems ], crItemToPushIn );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_cItems += 1;

Cleanup:

    return hr;
} //*** DynamicArray< Item, Assignment >::HrPushBack


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrPopBack
//
//  Description:
//      Discards the last element of the array, if one exists.
//
//  Arguments:
//      crItemToPushIn  -   The object to copy onto the end of the array.
//
//  Return Values:
//      S_OK    -   The array has added a copy of the object to its end.
//
//  Remarks:
//
//      Analogous to std::vector::pop_back.
//
//      This does not destroy the last object in the array; it merely marks
//      that position as unused.  To free the resources associated with the
//      popped object, call HrCompact.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline HRESULT DynamicArray< Item, Assignment >::HrPopBack( void )
{
    HRESULT hr = S_FALSE;

    if ( m_cItems > 0 )
    {
        m_cItems -= 1;
        hr = S_OK;
    }

    return hr;
} //*** DynamicArray< Item, Assignment >::HrPopBack


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrResize
//
//  Description:
//      Change the effective size of the array.
//
//  Arguments:
//      cNewSizeIn
//          The array's new size.
//
//      crItemFillerIn
//          If the array is growing, copy this item into the spaces after the
//          array's current contents.
//
//  Return Values:
//      S_OK
//          Subsequent calls to Count will return cNewSizeIn, and indexing
//          into the array with any value from zero up to cNewSizeIn - 1
//          will return a valid object reference.
//
//      Failure
//          Something went wrong and the size is unchanged.
//
//  Remarks:
//
//      Analogous to std::vector::resize.
//
//      If cNewSizeIn is not greater than the array's capacity, the array
//      performs no memory reallocations.  To force the array to consume only
//      the memory necessary to contain the new size, call HrCompact.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
HRESULT DynamicArray< Item, Assignment >::HrResize( size_t cNewSizeIn, const Item& crItemFillerIn )
{
    HRESULT hr = S_OK;
    size_t  idx = 0;

    //  Raise capacity if necessary.
    if ( cNewSizeIn > m_cCapacity )
    {
        hr = HrRaiseCapacity( cNewSizeIn - m_cCapacity );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //  Fill any empty spaces with crItemFillerIn.
    for ( idx = m_cItems; idx < cNewSizeIn; ++idx )
    {
        hr = m_opAssign( m_prgItems[ idx ], crItemFillerIn );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    m_cItems = cNewSizeIn;
    
Cleanup:

    return hr;
} //*** DynamicArray< Item, Assignment >::HrResize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrReserve
//
//  Description:
//      Set a lower bound for the array's capacity.
//
//  Arguments:
//      cNewCapacityIn
//          The desired lower bound for the array's capacity.
//
//  Return Values:
//      S_OK
//          Subsequent operations that change the array's size--HrResize,
//          HrPushBack, HrPopBack, HrRemove--will not cause a memory
//          reallocation as long as the size does not exceed cNewCapacityIn.
//          Also, subsequent calls to CCapacity will return a value not less
//          than cNewCapacityIn.
//
//          (Calling Clear does reset the capacity to zero, however.)
//
//      Failure
//          Something went wrong, and the capacity is unchanged.
//
//  Remarks:
//
//      Analogous to std::vector::reserve.
//
//      If cNewCapacityIn is not greater than the array's capacity, the array's
//      capacity does not change.  To force the array to consume only
//      the memory necessary to contain the current size, call HrCompact.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline HRESULT DynamicArray< Item, Assignment >::HrReserve( size_t cNewCapacityIn )
{
    HRESULT hr = S_OK;
    
    if ( cNewCapacityIn > m_cCapacity )
    {
        hr = HrRaiseCapacity( cNewCapacityIn - m_cCapacity );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    
Cleanup:

    return hr;
} //*** DynamicArray< Item, Assignment >::HrReserve


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrRemove
//
//  Description:
//      Eliminate a particular element from the array.
//
//  Arguments:
//      ItemToRemoveIn
//          A pointer to the element to remove.
//
//  Return Values:
//      S_OK
//          The array's size has decreased by one, and the given element is
//          gone.
//
//      E_INVALIDARG
//          The given pointer was not within the array's valid range.
//
//      Other failures
//          Something went wrong; those items preceding that given are
//          unchanged, but others may have been overwritten by their successors.
//
//  Remarks:
//
//      Analogous to std::vector::erase.
//
//      This moves all successors to the element up by one, taking linear time.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
HRESULT DynamicArray< Item, Assignment >::HrRemove( Iterator ItemToRemoveIn )
{
    HRESULT hr = S_OK;
    Iterator it;
    
    if ( ( ItemToRemoveIn < m_prgItems ) || ( ItemToRemoveIn >= ItEnd() ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Move all items after ItemToRemoveIn forward by one, overwriting *ItemToRemoveIn.
    for ( it = ItemToRemoveIn + 1; it != ItEnd(); ++it )
    {
        hr = m_opAssign( *( it - 1 ), *it );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    
    m_cItems -= 1;
    
Cleanup:

    return hr;
} //*** DynamicArray< Item, Assignment >::HrRemove


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrCompact
//
//  Description:
//      Force the array to consume just enough memory to hold its current
//      contents, performing a reallocation if necessary.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - The array's size is now the same as its capacity.
//
//      Failure - Something went wrong; the array is unchanged.
//
//  Remarks:
//
//      No analogue in std::vector.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
HRESULT DynamicArray< Item, Assignment >::HrCompact( void )
{
    HRESULT hr = S_OK;
    Item* prgNewArray = NULL;
    
    if ( m_cItems < m_cCapacity ) // Otherwise, it's already compact.
    {
        if ( m_cItems > 0 )
        {
            size_t idx = 0;

            //  Allocate just enough memory to hold the current contents.            
            prgNewArray = new Item[ m_cItems ];
            if ( prgNewArray == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            //  Copy the current contents into the newly allocated memory.
            for ( idx = 0; idx < m_cItems; ++idx )
            {
                hr = m_opAssign( prgNewArray[ idx ], m_prgItems[ idx ] );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }

            //  Take ownership of the new memory and discard the old.
            delete[] m_prgItems;
            m_prgItems = prgNewArray;
            prgNewArray = NULL;
            m_cCapacity = m_cItems;
        }
        else // No current contents, so just dump everything.
        {
            Clear();
        }
    }
    
Cleanup:

    if ( prgNewArray != NULL )
    {
        delete[] prgNewArray;
    }
    
    return hr;
} //*** DynamicArray< Item, Assignment >::HrCompact


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::Clear
//
//  Description:
//      Reset the array to its original, empty state, and release any
//      currently allocated memory.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//      Analogous to std::vector::clear.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
void DynamicArray< Item, Assignment >::Clear( void )
{
    if ( m_prgItems != NULL )
    {
        delete[] m_prgItems;
        m_prgItems = NULL;
        m_cItems = 0;
        m_cCapacity = 0;
    }
} //*** DynamicArray< Item, Assignment >::Clear


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::Swap
//
//  Description:
//      Swaps the contents of this array with another.
//
//  Arguments:
//      rOtherInOut - The array with which to swap.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//      Analogous to std::vector::swap.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
void DynamicArray< Item, Assignment >::Swap( DynamicArray& rOtherInOut )
{
    if ( this != &rOtherInOut )
    {
        Item*   prgItemStash = m_prgItems;
        size_t  cCountStash = m_cItems;
        size_t  cCapacityStash = m_cCapacity;
        
        m_prgItems = rOtherInOut.m_prgItems;
        rOtherInOut.m_prgItems = prgItemStash;
        
        m_cItems = rOtherInOut.m_cItems;
        rOtherInOut.m_cItems = cCountStash;
        
        m_cCapacity = rOtherInOut.m_cCapacity;
        rOtherInOut.m_cCapacity = cCapacityStash;
    }
} //*** DynamicArray< Item, Assignment >::Swap


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::CCapacity
//
//  Description:
//      Provide the array's current capacity.
//
//  Arguments:
//      None.
//
//  Return Values:
//      The array's current capacity.
//
//  Remarks:
//
//      Analogous to std::vector::capacity.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline size_t DynamicArray< Item, Assignment >::CCapacity( void ) const
{
    return m_cCapacity;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::Count
//
//  Description:
//      Provide the array's current size.
//
//  Arguments:
//      None.
//
//  Return Values:
//      The array's current size.
//
//  Remarks:
//
//      Analogous to std::vector::size.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline size_t DynamicArray< Item, Assignment >::Count( void ) const
{
    return m_cItems;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::BEmpty
//
//  Description:
//      Report whether the array contains anything.
//
//  Arguments:
//      None.
//
//  Return Values:
//      true    - The array contains nothing.
//      false   - The array contains something.
//
//  Remarks:
//
//      Analogous to std::vector::empty.  Synonymous with Count() == 0.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline bool DynamicArray< Item, Assignment >::BEmpty( void ) const
{
    return ( m_cItems == 0 );
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::ItBegin
//
//  Description:
//      Provide a pointer to the array's first element.
//
//  Arguments:
//      None.
//
//  Return Values:
//      A pointer to the array's first element if one exists, ItEnd() if not.
//
//  Remarks:
//
//      Analogous to std::vector::begin.
//
//      The const overload provides a read-only pointer.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline __TYPENAME DynamicArray< Item, Assignment >::Iterator DynamicArray< Item, Assignment >::ItBegin( void )
{
    return m_prgItems;
}

template < class Item, class Assignment >
inline __TYPENAME DynamicArray< Item, Assignment >::ConstIterator DynamicArray< Item, Assignment >::ItBegin( void ) const
{
    return m_prgItems;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::ItEnd
//
//  Description:
//      Provide a "one past end" pointer to the array's contents.
//
//  Arguments:
//      None.
//
//  Return Values:
//      A "one past end" pointer to the array's contents if any exist,
//      ItBegin() if not.
//
//  Remarks:
//
//      Analogous to std::vector::end.
//
//      A "one past end" pointer allows enumeration of all the array's
//      contents by the common loop,
//          for (it = a.ItBegin(); it != a.ItEnd(); ++it).
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline __TYPENAME DynamicArray< Item, Assignment >::Iterator DynamicArray< Item, Assignment >::ItEnd( void )
{
    return ( m_prgItems + m_cItems );
}

template < class Item, class Assignment >
inline __TYPENAME DynamicArray< Item, Assignment >::ConstIterator DynamicArray< Item, Assignment >::ItEnd( void ) const
{
    return ( m_prgItems + m_cItems );
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::operator[]
//
//  Description:
//      Provide subscripted, constant-time access to the array's contents.
//
//  Arguments:
//      idxItemIn   - The zero-based index of the item desired.
//
//  Return Values:
//      A reference to the item at the given position.
//
//  Remarks:
//
//      Analogous to std::vector::operator[].
//      The const overload provides read-only access.
//      This makes no attempt at range-checking; the caller should use
//      Count() to determine whether the index is valid.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
inline Item& DynamicArray< Item, Assignment >::operator[]( size_t idxItemIn )
{
    return m_prgItems[ idxItemIn ];
}

template < class Item, class Assignment >
inline const Item& DynamicArray< Item, Assignment >::operator[]( size_t idxItemIn ) const
{
    return m_prgItems[ idxItemIn ];
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DynamicArray< Item, Assignment >::HrRaiseCapacity
//
//  Description:
//      Increase the array's capacity.
//
//  Arguments:
//      cAmountIn   - The amount by which to increase the array's capacity.
//
//  Return Values:
//      S_OK
//          The array has enough memory to hold an additional cAmountIn items.
//
//      Failure
//          Something went wrong, and the capacity is unchanged.
//
//  Remarks:
//
//      No analogue in std::vector; this is a private function.
//
//--
//////////////////////////////////////////////////////////////////////////////
template < class Item, class Assignment >
HRESULT DynamicArray< Item, Assignment >::HrRaiseCapacity( size_t cAmountIn )
{
    HRESULT hr = S_OK;
    size_t  idx = 0;
    Item*   prgNewArray = NULL;

    if ( cAmountIn == 0 ) // Nothing to do.
    {
        goto Cleanup;
    }

    //  Allocate enough space for the new capacity
    prgNewArray = new Item[ m_cCapacity + cAmountIn ];
    if ( prgNewArray == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //  Copy the current contents into the new space.
    for ( idx = 0; idx < m_cItems; ++idx )
    {
        hr = m_opAssign( prgNewArray[ idx ], m_prgItems[ idx ] );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //  Take ownership of the new space.
    if ( m_prgItems != NULL )
    {
        delete[] m_prgItems;
    }

    m_prgItems = prgNewArray;
    prgNewArray = NULL;
    m_cCapacity += cAmountIn;

Cleanup:

    if ( prgNewArray != NULL )
    {
        delete[] prgNewArray;
    }
    
    return hr;
} //*** DynamicArray< Item, Assignment >::HrRaiseCapacity


} //*** Generics namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\eventname.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EventName.h
//
//  Description:
//      Header file containing the name of an event that is used to synchronize
//      post configuration with startup notification.
//
//  Maintained By:
//      Vij Vasu (VVasu) 27-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define POSTCONFIG_COMPLETE_EVENT_NAME      L"Global\\Microsoft Cluster Configuration Post Configuration Completion Event"
#define SUCCESSFUL_CLEANUP_EVENT_NAME       L"Global\\Microsoft Cluster Configuration Successful Cleanup Completion Event"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\encryptedbstrsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      EncryptedBSTRSrc.cpp
//
//  Description:
//      Class to encrypt and decrypt BSTRs.
//
//  Maintained By:
//      John Franco (jfranco) 15-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "EncryptedBSTR.h"

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFNCRYPTPROTECTMEMORY)( LPVOID, DWORD, DWORD );
typedef BOOL (*PFNCRYPTUNPROTECTMEMORY)( LPVOID, DWORD, DWORD );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCryptRoutines
//
//  Description:
//      CryptProtectMemory and CryptUnprotectMemory are not available on early
//      releases of XP Client, which the admin pack must support.  Therefore,
//      we cannot link to those routines implicitly.  CCryptRoutines wraps the
//      work of loading crypt32.dll dynamically and looking for the exported
//      functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCryptRoutines
{
private:
    PFNCRYPTPROTECTMEMORY   m_pfnCryptProtectMemory;
    PFNCRYPTUNPROTECTMEMORY m_pfnCryptUnprotectMemory;
    HMODULE                 m_hmodCrypt32;
    LONG                    m_nRefCount;
    CRITICAL_SECTION        m_cs;
    BOOL                    m_fCritSecInitialized;
    DWORD                   m_scLoadStatus;

    static BOOL S_FBogusCryptRoutine( LPVOID, DWORD, DWORD );

public:
    CCryptRoutines( void )
        : m_pfnCryptProtectMemory( NULL )
        , m_pfnCryptUnprotectMemory( NULL )
        , m_hmodCrypt32( NULL )
        , m_nRefCount( 0 )
        , m_fCritSecInitialized( FALSE )
        , m_scLoadStatus( ERROR_SUCCESS )
    {
        m_fCritSecInitialized = InitializeCriticalSectionAndSpinCount( &m_cs, RECOMMENDED_SPIN_COUNT );
        if ( m_fCritSecInitialized == FALSE )
        {
            TW32( GetLastError() );
        } // if

    } //*** CCryptRoutines::CCryptRoutines

    ~CCryptRoutines( void )
    {
        if ( m_hmodCrypt32 != NULL )
        {
            FreeLibrary( m_hmodCrypt32 );
        }

        if ( m_fCritSecInitialized )
        {
            DeleteCriticalSection( &m_cs );
        }

    } //*** CCryptRoutines::~CCryptRoutines

    void AddReferenceToRoutines( void );
    void ReleaseReferenceToRoutines( void );

    BOOL
    CryptProtectMemory(
        IN OUT          LPVOID          pDataIn,             // in out data to encrypt
        IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
        IN              DWORD           dwFlags              // CRYPTPROTECTMEMORY_* flags from wincrypt.h
        );

    BOOL
    CryptUnprotectMemory(
        IN OUT          LPVOID          pDataIn,             // in out data to decrypt
        IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
        IN              DWORD           dwFlags              // CRYPTPROTECTMEMORY_* flags from wincrypt.h
        );

}; //*** class CCryptRoutines

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

static CCryptRoutines   g_crCryptRoutines;


//****************************************************************************
//
//  CCryptRoutines
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRoutines::AddReferenceToRoutines
//
//  Description:
//      Add a reference to the routines and load the addresses of the APIs
//      if not already done so.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CCryptRoutines::AddReferenceToRoutines( void )
{
    TraceFunc( "" );

    if ( m_fCritSecInitialized )
    {
        EnterCriticalSection( &m_cs );

        m_nRefCount += 1;

        if ( m_nRefCount == 1 )
        {
            Assert( m_hmodCrypt32 == NULL );

            //
            // Load the DLL containing the APIs.
            //

            m_hmodCrypt32 = LoadLibraryW( L"crypt32.dll" );
            if ( m_hmodCrypt32 == NULL )
            {
                m_scLoadStatus = TW32( GetLastError() );
                goto Cleanup;
            } // if: error loading the DLL

            //
            // Get the address of the APIs.
            //

            m_pfnCryptProtectMemory = reinterpret_cast< PFNCRYPTPROTECTMEMORY >( GetProcAddress( m_hmodCrypt32, "CryptProtectMemory" ) );
            if ( m_pfnCryptProtectMemory == NULL )
            {
                m_scLoadStatus = TW32( GetLastError() );
                goto Cleanup;
            } // if

            m_pfnCryptUnprotectMemory = reinterpret_cast< PFNCRYPTUNPROTECTMEMORY >( GetProcAddress( m_hmodCrypt32, "CryptUnprotectMemory" ) );
            if ( m_pfnCryptProtectMemory == NULL )
            {
                m_scLoadStatus = TW32( GetLastError() );
                m_pfnCryptProtectMemory = NULL;
                goto Cleanup;
            } // if
        } // if: first reference
    } // if critical section is initialized.

Cleanup:

    if ( m_pfnCryptProtectMemory == NULL )
    {
        m_pfnCryptProtectMemory = S_FBogusCryptRoutine;
    } // if

    if ( m_pfnCryptUnprotectMemory == NULL )
    {
        m_pfnCryptUnprotectMemory = S_FBogusCryptRoutine;
    } // if

    if ( m_fCritSecInitialized )
    {
        LeaveCriticalSection( &m_cs );
    } // if

    TraceFuncExit();

} //*** CCryptRoutines::AddReferenceToRoutines

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRoutines::ReleaseReferenceToRoutines
//
//  Description:
//      Release a reference to the routines and free the library if this was
//      the last reference.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CCryptRoutines::ReleaseReferenceToRoutines( void )
{
    TraceFunc( "" );

    if ( m_fCritSecInitialized )
    {
        EnterCriticalSection( &m_cs );

        m_nRefCount -= 1;

        if ( m_nRefCount == 0 )
        {
            Assert( m_hmodCrypt32 != NULL );
            if ( m_hmodCrypt32 != NULL )
            {
                FreeLibrary( m_hmodCrypt32 );
                m_hmodCrypt32 = NULL;
                m_pfnCryptProtectMemory = NULL;
                m_pfnCryptUnprotectMemory = NULL;
            } // if
        } // if: last reference was released

        LeaveCriticalSection( &m_cs );
    } // if

    TraceFuncExit();

} //*** CCryptRoutines::ReleaseReferenceToRoutines

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRoutines::CryptProtectMemory
//
//  Description:
//      Encrypt memory.  Required since XP doesn't have CryptProtectMemory.
//
//  Arguments:
//      pDataIn
//      cbDataIn
//      dwFlags
//
//  Return Values:
//      TRUE        - Operation was successful.
//      FALSE       - Operation failed.  Call GetLastError().
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CCryptRoutines::CryptProtectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to encrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags              // CRYPTPROTECTMEMORY_* flags from wincrypt.h
    )
{
    TraceFunc( "" );

    BOOL    fSuccess    = TRUE;
    DWORD   sc          = ERROR_SUCCESS;

    fSuccess = (*m_pfnCryptProtectMemory)( pDataIn, cbDataIn, dwFlags );
    if ( fSuccess == FALSE )
    {
        sc = TW32( GetLastError() );
    }

#ifdef DEBUG
    // Only needed for debug builds because TW32 might overwrite the last error.
    SetLastError( sc );
#endif
    RETURN( fSuccess );

} //*** CCryptRoutines::CryptProtectMemory

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRoutines::CryptUnprotectMemory
//
//  Description:
//      Decrypt memory.  Required since XP doesn't have CryptUnprotectMemory.
//
//  Arguments:
//      pDataIn
//      cbDataIn
//      dwFlags
//
//  Return Values:
//      TRUE        - Operation was successful.
//      FALSE       - Operation failed.  Call GetLastError().
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CCryptRoutines::CryptUnprotectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to decrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags              // CRYPTPROTECTMEMORY_* flags from wincrypt.h
    )
{
    TraceFunc( "" );

    BOOL    fSuccess    = TRUE;
    DWORD   sc          = ERROR_SUCCESS;

    fSuccess = (*m_pfnCryptUnprotectMemory)( pDataIn, cbDataIn, dwFlags );
    if ( fSuccess == FALSE )
    {
        sc = TW32( GetLastError() );
    }

#ifdef DEBUG
    // Only needed for debug builds because TW32 might overwrite the last error.
    SetLastError( sc );
#endif
    RETURN( fSuccess );

} //*** CCryptRoutines::CryptUnprotectMemory


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRoutines::S_FBogusCryptRoutine
//
//  Description:
//      Stand-in function for when the routines are not available.
//
//  Arguments:
//      LPVOID
//      DWORD
//      DWORD
//
//  Return Values:
//      TRUE        - Pretend always to succeed.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CCryptRoutines::S_FBogusCryptRoutine( LPVOID, DWORD, DWORD )
{
    return TRUE;

} //*** CCryptRoutines::S_FBogusCryptRoutine


//****************************************************************************
//
//  CEncryptedBSTR
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEncryptedBSTR::CEncryptedBSTR
//
//  Description:
//      Default constructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEncryptedBSTR::CEncryptedBSTR( void )
{
    TraceFunc( "" );

    m_dbBSTR.cbData = 0;
    m_dbBSTR.pbData = NULL;

    g_crCryptRoutines.AddReferenceToRoutines();

    TraceFuncExit();

} //*** CEncryptedBSTR::CEncryptedBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEncryptedBSTR::~CEncryptedBSTR
//
//  Description:
//      Destructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEncryptedBSTR::~CEncryptedBSTR( void )
{
    TraceFunc( "" );

    Erase();

    g_crCryptRoutines.ReleaseReferenceToRoutines();

    TraceFuncExit();

} //*** CEncryptedBSTR::~CEncryptedBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEncryptedBSTR::HrSetWSTR
//
//  Description:
//      Set new data into this object to be stored as encrypted data.
//
//  Arguments:
//      pcwszIn     - String to store.
//      cchIn       - Number of characters in the string, not including NUL.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEncryptedBSTR::HrSetWSTR(
      PCWSTR    pcwszIn
    , size_t    cchIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DATA_BLOB   dbEncrypted = { 0, NULL };
        
    if ( cchIn > 0 )
    {
        BOOL        fSuccess = FALSE;
        DWORD       cbStringAndNull = (DWORD) ( ( cchIn + 1 ) * sizeof( *pcwszIn ) );
        DWORD       cBlocks = ( cbStringAndNull / CRYPTPROTECTMEMORY_BLOCK_SIZE ) + 1;
        DWORD       cbMemoryRequired = cBlocks * CRYPTPROTECTMEMORY_BLOCK_SIZE;

        dbEncrypted.pbData = new BYTE[ cbMemoryRequired ];
        if ( dbEncrypted.pbData == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
        dbEncrypted.cbData = cbMemoryRequired;

        CopyMemory( dbEncrypted.pbData, pcwszIn, cbStringAndNull );
        fSuccess = g_crCryptRoutines.CryptProtectMemory( dbEncrypted.pbData, dbEncrypted.cbData, CRYPTPROTECTMEMORY_SAME_PROCESS );
        if ( fSuccess == FALSE )
        {
            DWORD scLastError = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( scLastError );
            goto Cleanup;
        } // if: error from CryptProtectMemory

        Erase();
        m_dbBSTR = dbEncrypted;
        dbEncrypted.pbData = NULL;
        dbEncrypted.cbData = 0;
    } // if: input data is not empty
    else
    {
        Erase();
    } // else: input data is empty

Cleanup:

    if ( dbEncrypted.pbData != NULL )
    {
        delete [] dbEncrypted.pbData;
    }

    HRETURN( hr );

} //*** CEncryptedBSTR::HrSetWSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEncryptedBSTR::HrGetBSTR
//
//  Description:
//      Retrieve an unencrypted copy of the data.
//
//  Arguments:
//      pbstrOut    - BSTR to return data in.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEncryptedBSTR::HrGetBSTR( BSTR * pbstrOut ) const
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BYTE *  pbDecrypted = NULL;

    if ( pbstrOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *pbstrOut = NULL;

    if ( m_dbBSTR.cbData > 0 )
    {
        BOOL fSuccess = FALSE;

        pbDecrypted = new BYTE[ m_dbBSTR.cbData ];
        if ( pbDecrypted == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        CopyMemory( pbDecrypted, m_dbBSTR.pbData, m_dbBSTR.cbData );
        fSuccess = g_crCryptRoutines.CryptUnprotectMemory( pbDecrypted, m_dbBSTR.cbData, CRYPTPROTECTMEMORY_SAME_PROCESS );
        if ( fSuccess == FALSE )
        {
            DWORD scLastError = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( scLastError );
            goto Cleanup;
        } // if: error from CryptUnprotectMemory

        *pbstrOut = TraceSysAllocString( reinterpret_cast< const OLECHAR* >( pbDecrypted ) );
        if ( *pbstrOut == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    } // if: data is not empty
    else // nothing to decrypt
    {
        hr = S_FALSE;
    } // else: data is empty

Cleanup:

    if ( pbDecrypted != NULL )
    {
        ::SecureZeroMemory( pbDecrypted, m_dbBSTR.cbData );
        delete [] pbDecrypted;
    }

    HRETURN( hr );

} //*** CEncryptedBSTR::HrGetBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEncryptedBSTR::HrAssign
//
//  Description:
//      Make a copy of another encrypted BSTR object to replace the
//      content we are currently holding.
//
//  Arguments:
//      rSourceIn   - Object to copy.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Error allocating memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEncryptedBSTR::HrAssign( const CEncryptedBSTR & rSourceIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BYTE *  pbCopy = NULL;

    if ( rSourceIn.m_dbBSTR.cbData > 0 )
    {
        pbCopy = new BYTE[ rSourceIn.m_dbBSTR.cbData ];
        if ( pbCopy == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
        CopyMemory( pbCopy, rSourceIn.m_dbBSTR.pbData, rSourceIn.m_dbBSTR.cbData );

        Erase();
        m_dbBSTR.cbData = rSourceIn.m_dbBSTR.cbData;
        m_dbBSTR.pbData = pbCopy;
        pbCopy = NULL;
    } // if: input data is not empty
    else
    {
        Erase();
    } // else: input data is empty

Cleanup:

    if ( pbCopy != NULL )
    {
        ::SecureZeroMemory( pbCopy, rSourceIn.m_dbBSTR.cbData );
        delete [] pbCopy;
    }

    HRETURN( hr );

} //*** CEncryptedBSTR::HrAssign
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\guids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Guids.h
//
//  Description:
//      This file defines GUIDs used by multiple parts of clcfgsrv.dll.
//
//  Maintained By:
//      Galen Barbee (GalenB)   18-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//
//  App IDs
//

// {800A4EE1-1664-4bd5-ADF2-4DF2ECC09B40}
DEFINE_GUID( APPID_ClusCfgServer,
0x800a4ee1, 0x1664, 0x4bd5, 0xad, 0xf2, 0x4d, 0xf2, 0xec, 0xc0, 0x9b, 0x40 );

// {3FF0DA8E-E7B2-4c97-B470-056F8A4A53C0}
DEFINE_GUID( APPID_ClusCfgEvictCleanup,
0x3ff0da8e, 0xe7b2, 0x4c97, 0xb4, 0x70, 0x5, 0x6f, 0x8a, 0x4a, 0x53, 0xc0 );

// {F45FBDD5-A533-4d9d-A06A-5AEDA9692BE4}
DEFINE_GUID( APPID_ClusCfgAsyncEvictCleanup,
0xf45fbdd5, 0xa533, 0x4d9d, 0xa0, 0x6a, 0x5a, 0xed, 0xa9, 0x69, 0x2b, 0xe4 );

// {50503499-D11E-401a-82AE-33065AC0B9AE}
DEFINE_GUID( APPID_ClusCfgStartupNotify,
0x50503499, 0xd11e, 0x401a, 0x82, 0xae, 0x33, 0x6, 0x5a, 0xc0, 0xb9, 0xae );

// {8ECDF581-A4B0-4052-A8E1-BC6653B59555}
DEFINE_GUID( APPID_ClusCfgEvictNotify,
0x8ecdf581, 0xa4b0, 0x4052, 0xa8, 0xe1, 0xbc, 0x66, 0x53, 0xb5, 0x95, 0x55 );

//  Class IDs
//

// {8AEC052B-066A-4dee-8B20-FA8046ADD999}
DEFINE_GUID( CLSID_ClusCfgServer,
0x8aec052b, 0x66a, 0x4dee, 0x8b, 0x20, 0xfa, 0x80, 0x46, 0xad, 0xd9, 0x99 );

// {C662DFBA-C57A-4098-9D66-3E106E4EB83E}
DEFINE_GUID( CLSID_ClusCfgCredentials,
0xc662dfba, 0xc57a, 0x4098, 0x9d, 0x66, 0x3e, 0x10, 0x6e, 0x4e, 0xb8, 0x3e );

// {9be7f4a7-918b-47e3-be74-a13d6a453571}
DEFINE_GUID( CLSID_ClusCfgNodeInfo,
0x9be7f4a7, 0x918b, 0x47e3, 0xb3, 0x74, 0xa1, 0x3d, 0x6a, 0x45, 0x35, 0x71 );

// {f77f10a7-7c64-4ff6-b7e6-af2f7ba1df81}
DEFINE_GUID( CLSID_ClusCfgClusterInfo,
0xf77f10a7, 0x7c64, 0x4ff6, 0xb7, 0xe6, 0xaf, 0x2f, 0x7b, 0xa1, 0xdf, 0x81 );

// {C337213E-5B74-45e7-84BA-3EDAD49F01F6}
DEFINE_GUID( CLSID_EnumClusCfgManagedResources,
0xc337213e, 0x5b74, 0x45e7, 0x84, 0xba, 0x3e, 0xda, 0xd4, 0x9f, 0x1, 0xf6 );

// {57720043-DC9E-4796-B252-8F5B87F8C1C9}
DEFINE_GUID( CLSID_PhysicalDisk,
0x57720043, 0xdc9e, 0x4796, 0xb2, 0x52, 0x8f, 0x5b, 0x87, 0xf8, 0xc1, 0xc9 );

// {7F64E62A-61EE-43c4-B3E5-F7C69A6B304C}
DEFINE_GUID( CLSID_EnumClusCfgNetworks,
0x7f64e62a, 0x61ee, 0x43c4, 0xb3, 0xe5, 0xf7, 0xc6, 0x9a, 0x6b, 0x30, 0x4c );

// {77F09965-4D3A-4f82-864D-4479B6218330}
DEFINE_GUID( CLSID_ClusCfgNetworkInfo,
0x77f09965, 0x4d3a, 0x4f82, 0x86, 0x4d, 0x44, 0x79, 0xb6, 0x21, 0x83, 0x30 );

// {6CD35DF9-AB7D-428a-AD87-72EDB35A2D0D}
DEFINE_GUID( CLSID_EnumClusCfgIPAddresses,
0x6cd35df9, 0xab7d, 0x428a, 0xad, 0x87, 0x72, 0xed, 0xb3, 0x5a, 0x2d, 0xd );

// {3E6296AA-936B-4ca2-B67F-6DF55D7F0081}
DEFINE_GUID( CLSID_ClusCfgIPAddressInfo,
0x3e6296aa, 0x936b, 0x4ca2, 0xb6, 0x7f, 0x6d, 0xf5, 0x5d, 0x7f, 0x0, 0x81 );

// {71D13B29-4667-41fb-B4E3-F26418895CDA}
DEFINE_GUID( CLSID_EnumPhysicalDisks,
0x71d13b29, 0x4667, 0x41fb, 0xb4, 0xe3, 0xf2, 0x64, 0x18, 0x89, 0x5c, 0xda );

// {0BE8BAD9-3E6B-47c0-BC0B-86EBBA1C36C5}
DEFINE_GUID( CLSID_ClusCfgCapabilities,
0xbe8bad9, 0x3e6b, 0x47c0, 0xbc, 0xb, 0x86, 0xeb, 0xba, 0x1c, 0x36, 0xc5 );

// {C6348E14-53B9-4fae-866F-50FEF691D70E}
DEFINE_GUID( CLSID_LocalQuorum,
0xc6348e14, 0x53b9, 0x4fae, 0x86, 0x6f, 0x50, 0xfe, 0xf6, 0x91, 0xd7, 0xe );

// {0CAD2D20-218D-4dbb-B067-24464090C2DD}
DEFINE_GUID( CLSID_EnumLocalQuorum,
0xcad2d20, 0x218d, 0x4dbb, 0xb0, 0x67, 0x24, 0x46, 0x40, 0x90, 0xc2, 0xdd );

// {FD507CFA-3515-494a-A0B9-C9FB917A384C}
DEFINE_GUID( CLSID_MajorityNodeSet,
0xfd507cfa, 0x3515, 0x494a, 0xa0, 0xb9, 0xc9, 0xfb, 0x91, 0x7a, 0x38, 0x4c );

// {75C0791D-7670-44bb-B273-2D405C26DF28}
DEFINE_GUID( CLSID_EnumMajorityNodeSet,
0x75c0791d, 0x7670, 0x44bb, 0xb2, 0x73, 0x2d, 0x40, 0x5c, 0x26, 0xdf, 0x28 );

// {6A4CF650-88DD-489a-9A1E-A24A142440E0}
DEFINE_GUID( CLSID_UnknownQuorum,
0x6a4cf650, 0x88dd, 0x489a, 0x9a, 0x1e, 0xa2, 0x4a, 0x14, 0x24, 0x40, 0xe0 );

// {3A4E77CE-18FD-4200-A57A-41B821D15573}
DEFINE_GUID( CLSID_EnumUnknownQuorum,
0x3a4e77ce, 0x18fd, 0x4200, 0xa5, 0x7a, 0x41, 0xb8, 0x21, 0xd1, 0x55, 0x73 );

// {7D1CEAA2-F8FF-4e94-8FF5-CA716B3EFED4}
DEFINE_GUID( CLSID_ClusCfgBaseCluster,
0x7d1ceaa2, 0xf8ff, 0x4e94, 0x8f, 0xf5, 0xca, 0x71, 0x6b, 0x3e, 0xfe, 0xd4 );

// {B7CCC7D2-C122-4e14-B830-F3FB3D4954AA}
DEFINE_GUID( CLSID_ClusCfgPostConfigManager,
0xb7ccc7d2, 0xc122, 0x4e14, 0xb8, 0x30, 0xf3, 0xfb, 0x3d, 0x49, 0x54, 0xaa );

// {215A6C84-64BD-42cf-9B67-6E2D0CEF4EA4}
DEFINE_GUID( CLSID_ConfigurationConnection,
0x215a6c84, 0x64bd, 0x42cf, 0x9b, 0x67, 0x6e, 0x2d, 0xc, 0xef, 0x4e, 0xa4 );

// {DD18F356-E387-496f-A8FF-65822CBF2970}
DEFINE_GUID( CLSID_ConfigClusApi,
0xdd18f356, 0xe387, 0x496f, 0xa8, 0xff, 0x65, 0x82, 0x2c, 0xbf, 0x29, 0x70 );

// {D513C4F4-1D34-44a3-83D4-812651DB8918}
DEFINE_GUID( CLSID_ClusCfgResTypeGenScript,
0xd513c4f4, 0x1d34, 0x44a3, 0x83, 0xd4, 0x81, 0x26, 0x51, 0xdb, 0x89, 0x18 );

// {B6870B44-0BDF-4b46-AC1F-6C691B622EDF}
DEFINE_GUID( CLSID_ClusCfgResTypeMajorityNodeSet,
0xb6870b44, 0xbdf, 0x4b46, 0xac, 0x1f, 0x6c, 0x69, 0x1b, 0x62, 0x2e, 0xdf );


//
//  Class IDs for use with ServiceManager::QueryService
//

// {0F200768-212B-4b80-BA31-2F0933BE8583}
DEFINE_GUID( CLSID_ClusterConnectionManager,
0x0f200768, 0x212b, 0x4b80, 0xba, 0x31, 0x2f, 0x09, 0x33, 0xbe, 0x85, 0x83 );

// {8FDA8FA4-8763-479f-B9B1-2202B280D293}
DEFINE_GUID( CLSID_LogManager,
0x8fda8fa4, 0x8763, 0x479f, 0xb9, 0xb1, 0x22, 0x2, 0xb2, 0x80, 0xd2, 0x93 );



//
// Object Type Guids
//

// {1143DCB3-2C27-4cec-A442-392903065F7F}
DEFINE_GUID( CLSID_ClusterType,
0x1143dcb3, 0x2c27, 0x4cec, 0xa4, 0x42, 0x39, 0x29, 0x3, 0x6, 0x5f, 0x7f );

// {09EBC765-9730-4a89-8B26-8F72DF534226}
DEFINE_GUID( CLSID_ManagedResourceType,
0x9ebc765, 0x9730, 0x4a89, 0x8b, 0x26, 0x8f, 0x72, 0xdf, 0x53, 0x42, 0x26 );

// {FC07A1A2-2E49-41bb-8C39-CB524F8BCEA9}
DEFINE_GUID( CLSID_IPAddressType,
0xfc07a1a2, 0x2e49, 0x41bb, 0x8c, 0x39, 0xcb, 0x52, 0x4f, 0x8b, 0xce, 0xa9 );

// {1FF64B28-ABCC-4141-87F7-73D495FC36BA}
DEFINE_GUID( CLSID_TaskVerifyIPAddressCompletionCookieType,
0x1ff64b28, 0xabcc, 0x4141, 0x87, 0xf7, 0x73, 0xd4, 0x95, 0xfc, 0x36, 0xba );

// {6803B9B3-05D1-41ac-89FB-AF98854FD9CC}
DEFINE_GUID( CLSID_ClusterCompletionCookie,
0x6803b9b3, 0x5d1, 0x41ac, 0x89, 0xfb, 0xaf, 0x98, 0x85, 0x4f, 0xd9, 0xcc);


//
// Data Format Guids (DFGUIDs)
//

#define DFGUID_EnumManageableResources IID_IEnumClusCfgManagedResources

#define DFGUID_EnumNodes IID_IEnumNodes

#define DFGUID_ConnectionInfoFormat IID_IConnectionInfo

#define DFGUID_ManagedResource IID_IClusCfgManagedResourceInfo

#define DFGUID_NetworkResource IID_IClusCfgNetworkInfo

#define DFGUID_EnumCookies IID_IEnumCookies

#define DFGUID_IPAddressInfo IID_IClusCfgIPAddressInfo

#define DFGUID_EnumIPAddressInfo IID_IEnumClusCfgIPAddresses

#define DFGUID_StandardInfo IID_IStandardInfo


//
//  Tasks
//

#define TASK_GatherNodeInfo IID_ITaskGatherNodeInfo

#define TASK_GatherInformation IID_ITaskGatherInformation

#define TASK_CompareAndPushInformation IID_ITaskCompareAndPushInformation

// {E64C6934-C780-48b5-894E-776964666963}
DEFINE_GUID( TASK_GetDomains,
0xE64C6934, 0xC780, 0x48b5, 0x89, 0x4E, 0x77, 0x69, 0x64, 0x66, 0x69, 0x63 );

#define TASK_GatherClusterInfo IID_ITaskGatherClusterInfo

// {DED79AFF-D087-47bb-A82A-6DEB53EB277D}
DEFINE_GUID( TASK_PollingCallback,
0xded79aff, 0xd087, 0x47bb, 0xa8, 0x2a, 0x6d, 0xeb, 0x53, 0xeb, 0x27, 0x7d );

// {394A16C8-2DA7-4198-BEC4-82441A3F2642}
DEFINE_GUID( TASK_CancelCleanup,
0x394a16c8, 0x2da7, 0x4198, 0xbe, 0xc4, 0x82, 0x44, 0x1a, 0x3f, 0x26, 0x42 );


#define TASK_VerifyIPAddress IID_ITaskVerifyIPAddress


//
//  IDs for non-IDL interfaces
//

// {B27A7584-FCB4-4242-8684-89990B27AED0}
DEFINE_GUID( IID_IPostCfgManager,
0xb27a7584, 0xfcb4, 0x4242, 0x86, 0x84, 0x89, 0x99, 0xb, 0x27, 0xae, 0xd0 );

// {2DC2EC9D-451C-431a-B1B3-77B15B4D1C19}
DEFINE_GUID( IID_IPrivatePostCfgResource,
0x2dc2ec9d, 0x451c, 0x431a, 0xb1, 0xb3, 0x77, 0xb1, 0x5b, 0x4d, 0x1c, 0x19 );

// {CB9724AB-14B9-4385-970D-4D715CC25E60}
DEFINE_GUID( IID_IClusCfgWbemServices,
0xcb9724ab, 0x14b9, 0x4385, 0x97, 0x0d, 0x4d, 0x71, 0x5c, 0xc2, 0x5e, 0x60 );

// {97F95C65-E484-4098-861A-842D7A0C59DF}
DEFINE_GUID( IID_IClusCfgSetWbemObject,
0x97f95c65, 0xe484, 0x4098, 0x86, 0x1a, 0x84, 0x2d, 0x7a, 0xc, 0x59, 0xdf );

// {58624046-DD8A-43ce-BCDE-B3037BE348CA}
DEFINE_GUID( IID_IClusCfgSetClusterNodeInfo,
0x58624046, 0xdd8a, 0x43ce, 0xbc, 0xde, 0xb3, 0x3, 0x7b, 0xe3, 0x48, 0xca );

// {9CD0BEF4-A8FE-47b8-B0D0-20A4B9D71D7D}
DEFINE_GUID( IID_IClusCfgSetClusterHandles,
0x9cd0bef4, 0xa8fe, 0x47b8, 0xb0, 0xd0, 0x20, 0xa4, 0xb9, 0xd7, 0x1d, 0x7d );

// {1738F344-509C-489f-B8D7-217A711EDF60}
DEFINE_GUID( IID_IClusCfgPhysicalDiskProperties,
0x1738f344, 0x509c, 0x489f, 0xb8, 0xd7, 0x21, 0x7a, 0x71, 0x1e, 0xdf, 0x60 );

// {7B382C01-BB6E-4175-AE23-979574B5707B}
DEFINE_GUID( IID_IClusCfgPartitionProperties,
0x7b382c01, 0xbb6e, 0x4175, 0xae, 0x23, 0x97, 0x95, 0x74, 0xb5, 0x70, 0x7b );

// {5AC459D4-7B78-41f6-8E9A-F17AACDC29D6}
DEFINE_GUID( IID_IClusCfgLoadResource,
0x5ac459d4, 0x7b78, 0x41f6, 0x8e, 0x9a, 0xf1, 0x7a, 0xac, 0xdc, 0x29, 0xd6 );

// {FDA69D69-23FD-4880-969A-D505DA177F70}
DEFINE_GUID( IID_IClusCfgSetPollingCallback,
0xfda69d69, 0x23fd, 0x4880, 0x96, 0x9a, 0xd5, 0x5, 0xda, 0x17, 0x7f, 0x70 );

// {2F36ED9B-86E0-45a1-A8F2-3F598E660AE0}
DEFINE_GUID( IID_IClusCfgClusterNetworkInfo,
0x2f36ed9b, 0x86e0, 0x45a1, 0xa8, 0xf2, 0x3f, 0x59, 0x8e, 0x66, 0xa, 0xe0 );


//
//  Minor Task IDs
//

// {00AF4C3F-47D5-4e6a-9EF0-6D719A32EE5C}
DEFINE_GUID( TASKID_Minor_Not_Managed_Networks,
0xaf4c3f, 0x47d5, 0x4e6a, 0x9e, 0xf0, 0x6d, 0x71, 0x9a, 0x32, 0xee, 0x5c );

// {58902BD5-3F45-4626-A667-8433A5D7A6DC}
DEFINE_GUID( TASKID_Minor_Validating_Credentials,
0x58902bd5, 0x3f45, 0x4626, 0xa6, 0x67, 0x84, 0x33, 0xa5, 0xd7, 0xa6, 0xdc );

// {29516FCF-2080-4cab-B4F8-E51C8C7D4042}
DEFINE_GUID( TASKID_Minor_Errors_To_Warnings_Point,
0x29516fcf, 0x2080, 0x4cab, 0xb4, 0xf8, 0xe5, 0x1c, 0x8c, 0x7d, 0x40, 0x42 );

// {32CE48AD-95F2-45ed-8BC2-51BA599B3906}
DEFINE_GUID( TASKID_Minor_Disconnecting_From_Server,
0x32ce48ad, 0x95f2, 0x45ed, 0x8b, 0xc2, 0x51, 0xba, 0x59, 0x9b, 0x39, 0x6 );

// {E88B08DD-2460-4df1-B5C2-28587DD164EA}
DEFINE_GUID( TASKID_Minor_Connecting,
0xe88b08dd, 0x2460, 0x4df1, 0xb5, 0xc2, 0x28, 0x58, 0x7d, 0xd1, 0x64, 0xea );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\insertionsort.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      InsertionSort.h
//
//  Description:
//      This file contains templates to perform an insertion sort on an array.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      John Franco (jfranco) 1-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Template Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  InsertionSort< Item, PredecessorFunction > template
// 
//  Description:
//      InsertionSort(Start, Size, Precedes)
//      reorders the array of Size elements beginning at Start so that
//      for all p and q in [Start, Start + Size),
//      Precedes(*p, *q) implies p < q.
//
//      The notation [begin, end) refers to a half-open interval, so that
//          for ( Item* pItem = begin; pItem < end; ++pItem )
//      iterates through all elements in the array, and
//          end - begin
//      gives the number of elements in the array.
//
//  Template Arguments:
//      Item - the type of the elements in the array.
//          requirements for Item:
//              - copy constructor
//              - assignment operator
//
//      PredecessorFunction
//          The function that determines whether one element should precede
//          another in the sort order
//
//          requirements for PredecessorFunction:
//              - bool operator()( const Item &, const Item & ) const;
//              or, PredecessorFunction can be a pointer to a function
//              taking two Items and returning a bool.
//
//  Function Arguments:
//      pArrayStartIn
//          A pointer to the first element of the array.
//
//      cArraySizeIn
//          The number of elements in the array.
//
//      rPrecedesIn
//          An instance of the predecessor function class, or a pointer to
//          a function with the appropriate signature.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////

template < class Item, class PredecessorFunction >
void
InsertionSort(
    Item * pArrayStartIn
    , size_t cArraySizeIn
    , const PredecessorFunction & rPrecedesIn )
{
    Assert( pArrayStartIn != NULL );

    Item * pCurrentItem;
    Item * pSortedLocation;
    Item * pNextToCopy;
    Item * pArrayEnd = pArrayStartIn + cArraySizeIn;

    //
    // Insertion sort algorithm; for a good description, see "Introduction to Algorithms"
    // by Cormen, Leiserson, and Rivest.
    //

    //
    //  Loop invariant: all items to the left of pCurrentItem are in sorted order.
    //  Arrays of size zero or one are considered to be already sorted, so start
    //  pCurrentItem at second element in the array (if more than one element exists).
    //
    for ( pCurrentItem = pArrayStartIn + 1; pCurrentItem < pArrayEnd; ++pCurrentItem )
    {
        //
        //  Find where the current item needs to go to make the loop invariant true for pCurrentItem + 1.
        //  This could be a binary search, but collections of large enough size that it matters
        //  should use a quick sort instead.
        //
        pSortedLocation = pCurrentItem;
        while ( ( pSortedLocation > pArrayStartIn )
            &&     rPrecedesIn( *pCurrentItem, *( pSortedLocation - 1 ) )
            )
        {
            --pSortedLocation;
        }

        // Does the current item need to move?
        if ( pSortedLocation != pCurrentItem )
        {
            // Store the current item.
            Item tempItem( *pCurrentItem ); // declared inline to avoid requiring default constructor for Item

            // Move all items in [pSortedLocation, pCurrentItem) to the right by one.
            for ( pNextToCopy = pCurrentItem ; pNextToCopy > pSortedLocation; --pNextToCopy )
            {
                *pNextToCopy = *( pNextToCopy - 1 );
            }

            // Copy the current item into its proper location
            *pSortedLocation = tempItem;
            
        } // if item not in sorted location
        
    } // for each item in array
    
} //*** InsertionSort


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LessThan<Item> and InsertionSort<Item> templates
//
//  Description:
//      These templates overload InsertionSort<Item, PredecessorFunction>
//      to make PredecessorFunction use the less-than operator by default when
//      the user provides no explicit predecessor function.
//
//      Passing an instance of a function object allows the compiler to inline
//      the comparison operation, which is impossible with a function pointer.
//
//  Template parameters:
//
//      Item - the type of the elements in the array.
//          requirements for Item:
//              - bool operator < ( const Item & ) const
//                  alternatively, Item can be a built-in type, like int
//              - those from InsertionSort<Item, PredecessorFunction>
//
//--
//////////////////////////////////////////////////////////////////////////////

template < class Item >
struct LessThan
{
    bool operator()( const Item & rLeftIn, const Item & rRightIn ) const
    {
        return ( rLeftIn < rRightIn );
    }
};


template < class Item >
inline void
InsertionSort( Item * pBeginIn, size_t cArraySizeIn )
{
    InsertionSort( pBeginIn, cArraySizeIn, LessThan< Item >() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\encryptedbstr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      EncryptedBSTR.h
//
//  Description:
//      Class to encrypt and decrypt BSTRs.
//
//  Maintained By:
//      John Franco (jfranco) 15-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEncryptedBSTR
//
//  Description:
//      Class to encrypt and decrypt BSTRs.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEncryptedBSTR
{
private:

    DATA_BLOB   m_dbBSTR;

    // Private copy constructor to prevent copying.
    CEncryptedBSTR( const CEncryptedBSTR & );

    // Private assignment operator to prevent copying.
    CEncryptedBSTR & operator=( const CEncryptedBSTR & );

public:

    CEncryptedBSTR( void );
    ~CEncryptedBSTR( void );

    HRESULT HrSetBSTR( BSTR bstrIn );
    HRESULT HrSetWSTR( PCWSTR pcwszIn, size_t cchIn );
    HRESULT HrGetBSTR( BSTR * pbstrOut ) const;
    HRESULT HrAssign( const CEncryptedBSTR& rSourceIn );
    BOOL    IsEmpty( void ) const;
    void    Erase( void );

    static  void SecureZeroBSTR( BSTR bstrIn );

}; //*** class CEncryptedBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  CEncryptedBSTR::HrSetBSTR
//
//  Description:
//      Set a string into this class.
//
//  Arguments:
//      bstrIn
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
HRESULT
CEncryptedBSTR::HrSetBSTR( BSTR bstrIn )
{
    TraceFunc( "" );

    HRESULT hr;
    size_t  cchBSTR = SysStringLen( bstrIn );

    hr = THR( HrSetWSTR( bstrIn, cchBSTR ) );

    HRETURN( hr );

} //*** CEncryptedBSTR::HrSetBSTR


//////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  CEncryptedBSTR::IsEmpty
//
//  Description:
//      Reports whether the string is empty or not.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE    - String is empty.
//      FALSE   - String is not empty.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
BOOL
CEncryptedBSTR::IsEmpty( void ) const
{
    TraceFunc( "" );

    RETURN( m_dbBSTR.cbData == 0 );

} //*** CEncryptedBSTR::IsEmpty

//////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  CEncryptedBSTR::Erase
//
//  Description:
//      Erase the string.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
void
CEncryptedBSTR::Erase( void )
{
    TraceFunc( "" );

    if ( m_dbBSTR.cbData > 0 )
    {
        Assert( m_dbBSTR.pbData != NULL );
        delete [] m_dbBSTR.pbData;
        m_dbBSTR.pbData = NULL;
        m_dbBSTR.cbData = 0;
    }

    TraceFuncExit();

} //*** CEncryptedBSTR::Erase

//////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  CEncryptedBSTR::SecureZeroBSTR
//
//  Description:
//      Zero out the string in a secure manner.
//
//  Arguments:
//      bstrIn
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
inline
void
CEncryptedBSTR::SecureZeroBSTR( BSTR bstrIn )
{
    TraceFunc( "" );

    UINT cchBSTR = SysStringLen( bstrIn );

    if ( cchBSTR > 0 )
    {
        ::SecureZeroMemory( bstrIn, cchBSTR * sizeof( *bstrIn ) );
    }

    TraceFuncExit();

} //*** CEncryptedBSTR::SecureZeroBSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\nameutilsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      NameUtilSrc.cpp
//
//  Description:
//      Name resolution utility.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>

// {6968D735-ADBB-4748-A36E-7CEE0FE21116}
DEFINE_GUID( TASKID_Minor_Multiple_DNS_Records_Found,
0x6968d735, 0xadbb, 0x4748, 0xa3, 0x6e, 0x7c, 0xee, 0xf, 0xe2, 0x11, 0x16);

// {D86FAAD9-2514-451e-B359-435AF35E6038}
DEFINE_GUID( TASKID_Minor_FQDN_DNS_Binding_Succeeded,
0xd86faad9, 0x2514, 0x451e, 0xb3, 0x59, 0x43, 0x5a, 0xf3, 0x5e, 0x60, 0x38);

// {B2359972-F6B8-433d-949B-DB1CEE009321}
DEFINE_GUID( TASKID_Minor_FQDN_DNS_Binding_Failed,
0xb2359972, 0xf6b8, 0x433d, 0x94, 0x9b, 0xdb, 0x1c, 0xee, 0x0, 0x93, 0x21);

// {2FF4B2F0-800C-44db-9131-F60B30F76CB4}
DEFINE_GUID( TASKID_Minor_NETBIOS_Binding_Failed,
0x2ff4b2f0, 0x800c, 0x44db, 0x91, 0x31, 0xf6, 0xb, 0x30, 0xf7, 0x6c, 0xb4);

// {D40532E1-9286-4dbd-A559-B62DCC218929}
DEFINE_GUID( TASKID_Minor_NETBIOS_Binding_Succeeded,
0xd40532e1, 0x9286, 0x4dbd, 0xa5, 0x59, 0xb6, 0x2d, 0xcc, 0x21, 0x89, 0x29);

// {D0AB3284-8F62-4f55-8938-DA6A583604E0}
DEFINE_GUID( TASKID_Minor_NETBIOS_Name_Conversion_Succeeded,
0xd0ab3284, 0x8f62, 0x4f55, 0x89, 0x38, 0xda, 0x6a, 0x58, 0x36, 0x4, 0xe0);

// {66F8E4AA-DF71-4973-A4A3-115EB6FE9986}
DEFINE_GUID( TASKID_Minor_NETBIOS_Name_Conversion_Failed,
0x66f8e4aa, 0xdf71, 0x4973, 0xa4, 0xa3, 0x11, 0x5e, 0xb6, 0xfe, 0x99, 0x86);

// {5F18ED71-07EC-46d3-ADB9-71F1C7794DB2}
DEFINE_GUID( TASKID_Minor_NETBIOS_Reset_Failed,
0x5f18ed71, 0x7ec, 0x46d3, 0xad, 0xb9, 0x71, 0xf1, 0xc7, 0x79, 0x4d, 0xb2);

// {A6DCB5E1-1FDF-4c94-ADBA-EE18F72B8197}
DEFINE_GUID( TASKID_Minor_NETBIOS_LanaEnum_Failed,
0xa6dcb5e1, 0x1fdf, 0x4c94, 0xad, 0xba, 0xee, 0x18, 0xf7, 0x2b, 0x81, 0x97);


//  Constants for use by FQName functions.
const WCHAR     g_wchIPDomainMarker = L'|';
const WCHAR     g_wchDNSDomainMarker = L'.';
const size_t    g_cchIPAddressMax = INET_ADDRSTRLEN;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CountDnsRecords
//
//  Description:
//      Given a list of DNS records, counts the number of records in the list
//      having a given type and section.
//
//  Arguments:
//      pdnsRecordListIn
//          Pointer to the first record in the list; can be null, which causes
//          a return value of zero.
//
//      nTypeIn
//          The type of record to count.
//
//      dnsSectionIn
//          The kind of record section to count.
//
//
//  Return Values:
//      The number of records having the given type and section,
//      or zero if the list is empty.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
UINT
CountDnsRecords(
      PDNS_RECORD pdnsRecordListIn
    , WORD nTypeIn
    , DNS_SECTION dnsSectionIn )
{
    UINT cRecords = 0;
    PDNS_RECORD pdnsCurrent = pdnsRecordListIn;

    while ( pdnsCurrent != NULL )
    {
        if ( ( pdnsCurrent->wType == nTypeIn )
            && ( (DNS_SECTION) pdnsCurrent->Flags.S.Section == dnsSectionIn ) )
        {
            cRecords += 1;
        }
        pdnsCurrent = pdnsCurrent->pNext;
    }

    return cRecords;
} //*** CountDnsRecords

//////////////////////////////////////////////////////////////////////////////
//++
//
//  FindDnsRecord
//
//  Description:
//      Given a list of DNS records, searches for the first record in the list
//      having a given type and section.
//
//  Arguments:
//      pdnsRecordListIn
//          Pointer to the first record in the list; can be null, which causes
//          a return value of null.
//
//      nTypeIn
//          The type of record to find.
//
//      dnsSectionIn
//          The kind of record section to find.
//
//  Return Values:
//      A pointer to the first record having the given type and section,
//      or null if the list is empty.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
PDNS_RECORD
FindDnsRecord(
      PDNS_RECORD pdnsRecordListIn
    , WORD nTypeIn
    , DNS_SECTION dnsSectionIn )
{
    PDNS_RECORD pdnsCurrent = pdnsRecordListIn;
    
    while ( ( pdnsCurrent != NULL )
        && ( ( pdnsCurrent->wType != nTypeIn )
            || ( (DNS_SECTION) pdnsCurrent->Flags.S.Section != dnsSectionIn ) ) )
    {
        pdnsCurrent = pdnsCurrent->pNext;
    }

    return pdnsCurrent;
} //*** FindDnsRecord

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateBinding
//
//  Description:
//      Create a binding string from a name.
//
//  Arguments:
//      pcccbIn         - IClusCfgCallback interface for sending status reports.
//      pclsidLogIn     - Major task ID for status reports.
//      pcwszNameIn     - Name (FQDN) to create a binding string for.
//      pbstrBindingOut - Binding string created.
//
//  Return Values:
//      S_OK
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateBinding(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszNameIn
    , BSTR *                pbstrBindingOut
    )
{
    TraceFunc1( "pcwszNameIn = '%ws'", pcwszNameIn );

    HRESULT hr = S_FALSE; // This will always be set by the time we get to Cleanup, so the value doesn't matter.

    DNS_STATUS  dsDnsStatus;
    LPWSTR      pszIPAddress = NULL;
    PDNS_RECORD pResults = NULL;
    BSTR        bstrNotification = NULL;
    BOOL        fFallbackToNetbios = TRUE;

    Assert( pcwszNameIn != NULL );
    Assert( pbstrBindingOut != NULL );
    Assert( *pbstrBindingOut == NULL );

    dsDnsStatus = DnsQuery(
                      pcwszNameIn
                    , DNS_TYPE_A
                    , ( DNS_QUERY_STANDARD
                      | DNS_QUERY_BYPASS_CACHE
                      | DNS_QUERY_TREAT_AS_FQDN
                      )
                    , NULL
                    , &pResults
                    , NULL
                    );
    if ( dsDnsStatus == ERROR_SUCCESS )
    {
        PDNS_RECORD pdnsTypeARecord = FindDnsRecord( pResults, DNS_TYPE_A, DnsSectionAnswer );
        if ( pdnsTypeARecord != NULL )
        {
            ULONG ulIPAddress = pdnsTypeARecord->Data.A.IpAddress;
            DWORD scConversion = ERROR_SUCCESS;
            
            //
            // Send a warning to the UI if there is more than one DNS record.
            //
            if ( CountDnsRecords( pResults, DNS_TYPE_A, DnsSectionAnswer ) > 1 )
            {
                if ( pcccbIn != NULL )
                {
                    THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_MULTIPLE_DNS_RECORDS_FOUND, &bstrNotification, pcwszNameIn ) );

                    hr = THR( pcccbIn->SendStatusReport( pcwszNameIn,
                                                         *pclsidLogIn,
                                                         TASKID_Minor_Multiple_DNS_Records_Found,
                                                         1,
                                                         1,
                                                         1,
                                                         S_FALSE,
                                                         bstrNotification,
                                                         NULL,
                                                         NULL
                                                         ) );
                    //  ignore error
                }

            } // if: more than one result returned.

            //
            // Convert the IP address to a string.
            //

            scConversion = TW32( ClRtlTcpipAddressToString( ulIPAddress, &pszIPAddress ) );
            if ( scConversion != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( scConversion );
                goto Cleanup;
            }
            TraceMemoryAddLocalAddress( pszIPAddress );

            *pbstrBindingOut = TraceSysAllocString( pszIPAddress );
            if ( *pbstrBindingOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }


            //
            // Indicate we were successful in the UI.
            //
            if ( pcccbIn != NULL )
            {
                THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FQDN_DNS_BINDING_SUCCEEDED, &bstrNotification, pcwszNameIn, *pbstrBindingOut ) );

                hr = THR( pcccbIn->SendStatusReport( pcwszNameIn,
                                                     *pclsidLogIn,
                                                     TASKID_Minor_FQDN_DNS_Binding_Succeeded,
                                                     1,
                                                     1,
                                                     1,
                                                     S_OK,
                                                     bstrNotification,
                                                     NULL,
                                                     NULL
                                                     ) );
            } // if: IClusCfgCallback interface available
            else
            {
                hr = S_OK;
            }

            fFallbackToNetbios = FALSE;
        } // if type A dns record found
    } // if: DnsQuery() succeeded

    if ( fFallbackToNetbios )
    {
        //
        // If there were any failures in the call to DnsQuery, fall back to
        // performing a NetBIOS name resolution.
        //

        if ( pcccbIn != NULL )
        {
            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FQDN_DNS_BINDING_FAILED, &bstrNotification, pcwszNameIn ) );

            hr = THR( pcccbIn->SendStatusReport( pcwszNameIn,
                                                 TASKID_Major_Client_And_Server_Log,
                                                 TASKID_Minor_FQDN_DNS_Binding_Failed,
                                                 1,
                                                 1,
                                                 1,
                                                 MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, dsDnsStatus ),
                                                 bstrNotification,
                                                 NULL,
                                                 NULL
                                                 ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: IClusCfgCallback interface available

        //
        // Try to resolve the name with NetBIOS.
        //
        hr = THR( HrGetNetBIOSBinding( pcccbIn, pclsidLogIn, pcwszNameIn, pbstrBindingOut ) );
        if ( hr != S_OK )   // Non-S_OK success codes are actually failures.
        {
            //
            //  If all else fails, use the name and attempt to bind to it.
            //

            *pbstrBindingOut = TraceSysAllocString( pcwszNameIn );
            if ( *pbstrBindingOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            hr = S_FALSE;
            goto Cleanup;
        } // if: NetBIOS name resolution failed
    } // else if: no DNS server or no DNS name

Cleanup:

#ifdef DEBUG
    if ( FAILED( hr ) )
    {
        Assert( *pbstrBindingOut == NULL );
    }
#endif

    TraceSysFreeString( bstrNotification );
    TraceLocalFree( pszIPAddress );

    if ( pResults != NULL )
    {
        DnsRecordListFree( pResults, DnsFreeRecordListDeep );
    }

    HRETURN( hr );

} //*** HrCreateBinding


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetNetBIOSBinding
//
//  Description:
//      Get the IP address for a name from NetBIOS.
//
//  Arguments:
//      pcccbIn         - IClusCfgCallback interface for sending status reports.
//      pclsidLogIn     - Major task ID for status reports.
//      pcwszNameIn     - Name (FQDN) to create a binding string for.
//      pbstrBindingOut - Binding string created.
//
//  Return Values:
//      S_OK    - The operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNetBIOSBinding(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszNameIn
    , BSTR *                pbstrBindingOut
    )
{
    TraceFunc1( "pcwszNameIn = '%ws'", pcwszNameIn );

    HRESULT     hr = S_OK;
    DWORD       cch;
    BOOL        fSuccess;
    WCHAR       szNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    NCB         ncb;
    UCHAR       rguchNcbCallName[ RTL_NUMBER_OF( ncb.ncb_callname ) ];
    UCHAR       rguchNameBuffer[ sizeof( FIND_NAME_HEADER ) + sizeof( FIND_NAME_BUFFER ) ];
    LANA_ENUM   leLanaEnum;
    UCHAR       idx;
    size_t      idxNcbCallname;
    BSTR        bstrNotification = NULL;
    LPWSTR      pszIPAddress = NULL;

    FIND_NAME_HEADER * pfnh = (FIND_NAME_HEADER *) &rguchNameBuffer[ 0 ];
    FIND_NAME_BUFFER * pfnb = (FIND_NAME_BUFFER *) &rguchNameBuffer[ sizeof( FIND_NAME_HEADER ) ];

    Assert( pcwszNameIn != NULL );
    Assert( pbstrBindingOut != NULL );
    Assert( *pbstrBindingOut == NULL );

    //
    // Convert the DNS hostname to a computername (e.g. NetBIOS name).
    //
    cch = ARRAYSIZE( szNetBIOSName );
    Assert( cch == MAX_COMPUTERNAME_LENGTH + 1 );
    fSuccess = DnsHostnameToComputerName( pcwszNameIn, szNetBIOSName, &cch );
    if ( fSuccess == FALSE )
    {
        hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, TW32( GetLastError() ) );

        if ( pcccbIn != NULL )
        {
            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_FAILED, &bstrNotification, pcwszNameIn ) );

            hr = THR( pcccbIn->SendStatusReport(
                                      pcwszNameIn
                                    , *pclsidLogIn
                                    , TASKID_Minor_NETBIOS_Name_Conversion_Failed
                                    , 1
                                    , 1
                                    , 1
                                    , hr
                                    , bstrNotification
                                    , NULL
                                    , NULL
                                    ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: IClusCfgCallback interface available

        goto Cleanup;
    } // if: DnsHostNameToComputerName failed

    if ( pcccbIn != NULL )
    {
        THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_SUCCEEDED, &bstrNotification, pcwszNameIn, szNetBIOSName ) );

        hr = THR( pcccbIn->SendStatusReport(
                                  pcwszNameIn
                                , TASKID_Major_Client_And_Server_Log
                                , TASKID_Minor_NETBIOS_Name_Conversion_Succeeded
                                , 1
                                , 1
                                , 1
                                , S_OK
                                , bstrNotification
                                , NULL
                                , NULL
                                ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: IClusCfgCallback interface available

    //
    // Convert the name to the format required by the Netbios API.
    //

    if ( WideCharToMultiByte(
              CP_ACP    // ANSI code page
            , 0         // fail on unmapped characters
            , szNetBIOSName
            , -1        // string is null-terminated
            , (LPSTR) rguchNcbCallName
            , sizeof( rguchNcbCallName)
            , NULL      // no default characters
            , NULL      // don't indicate default character use
            ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

    //
    // The format of the ncb_callname string when using the NCBFINDNAME
    // command looks like this:
    //          name<space><space><nul>
    // Where all characters after the name are spaces and the <nul>
    // is at the last character position of the buffer.  The <nul>
    // is actually not a NUL-terminator, but is instead a port number.
    //
    for ( idxNcbCallname = strlen( reinterpret_cast< char * >( rguchNcbCallName ) )
        ; idxNcbCallname < RTL_NUMBER_OF( rguchNcbCallName ) - 1
        ; idxNcbCallname++ )
    {
        rguchNcbCallName[ idxNcbCallname ] = ' '; // space character
    } // for: each character space after the name

    // Specify a 0 port number, which means query the workstation service.
    rguchNcbCallName[ RTL_NUMBER_OF( rguchNcbCallName ) - 1 ] = 0;

    //
    //  Try to find the name using NetBIOS.
    //

    ZeroMemory( &ncb, sizeof( ncb ) );

    //
    //  Enumerate the network adapters
    //
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (PUCHAR) &leLanaEnum;
    ncb.ncb_length = sizeof( LANA_ENUM );

    Netbios( &ncb );
    if ( ncb.ncb_retcode != NRC_GOODRET )
    {
        hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, ncb.ncb_retcode );

        if ( pcccbIn != NULL )
        {
            THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_LANAENUM_FAILED, &bstrNotification ) );

            hr = THR( pcccbIn->SendStatusReport(
                                      pcwszNameIn
                                    , TASKID_Major_Client_And_Server_Log
                                    , TASKID_Minor_NETBIOS_LanaEnum_Failed
                                    , 1
                                    , 1
                                    , 1
                                    , hr
                                    , bstrNotification
                                    , NULL
                                    , NULL
                                    ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: IClusCfgCallback interface available

        goto Cleanup;
    } // if: the Netbios API failed

    //
    //  Reset each adapter and try to find the name.
    //
    for ( idx = 0; idx < leLanaEnum.length; idx++ )
    {
        //
        //  Reset the adapter.
        //
        ncb.ncb_command     = NCBRESET;
        ncb.ncb_lana_num    = leLanaEnum.lana[ idx ];

        Netbios( &ncb );
        if ( ncb.ncb_retcode != NRC_GOODRET )
        {
            hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, ncb.ncb_retcode );

            if ( pcccbIn != NULL )
            {
                THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_RESET_FAILED, &bstrNotification, leLanaEnum.lana[ idx ] ) );

                hr = THR( pcccbIn->SendStatusReport(
                                          pcwszNameIn
                                        , TASKID_Major_Client_And_Server_Log
                                        , TASKID_Minor_NETBIOS_Reset_Failed
                                        , 1
                                        , 1
                                        , 1
                                        , hr
                                        , bstrNotification
                                        , NULL
                                        , NULL
                                        ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            } // if: IClusCfgCallback interface available

            //
            //  Continue with the next adapter.
            //
            continue;
        } // if: NetBIOS reset failed

        //
        // Find the name on the next adapter.
        //
        ncb.ncb_command = NCBFINDNAME;
        ncb.ncb_buffer = rguchNameBuffer;
        ncb.ncb_length = sizeof( rguchNameBuffer );

        pfnh->node_count = 1;

        CopyMemory( ncb.ncb_callname, rguchNcbCallName, sizeof( ncb.ncb_callname ) );

        Netbios( &ncb );
        if ( ncb.ncb_retcode == NRC_GOODRET )
        {
            DWORD scConversion;
            ULONG ulIPAddress = *((u_long UNALIGNED *) &pfnb->source_addr[ 2 ]);

            TraceLocalFree( pszIPAddress );
            scConversion = TW32( ClRtlTcpipAddressToString( ulIPAddress, &pszIPAddress ) );
            if ( scConversion != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( scConversion );
                goto Cleanup;
            }
            TraceMemoryAddLocalAddress( pszIPAddress );

            *pbstrBindingOut = TraceSysAllocString( pszIPAddress );
            if ( *pbstrBindingOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            if ( pcccbIn != NULL )
            {
                LPWSTR  pszConnectoidName = NULL;

                TW32( ClRtlGetConnectoidNameFromLANA( leLanaEnum.lana[ idx ], &pszConnectoidName ) );
                THR( HrFormatStringIntoBSTR(
                              g_hInstance
                            , IDS_TASKID_MINOR_NETBIOS_BINDING_SUCCEEDED
                            , &bstrNotification
                            , szNetBIOSName
                            , *pbstrBindingOut
                            , leLanaEnum.lana[ idx ]
                            , ( pszConnectoidName == NULL ? L"" : pszConnectoidName )
                            ) );

                THR( pcccbIn->SendStatusReport(
                                          pcwszNameIn
                                        , *pclsidLogIn
                                        , TASKID_Minor_NETBIOS_Binding_Succeeded
                                        , 1
                                        , 1
                                        , 1
                                        , S_OK
                                        , bstrNotification
                                        , NULL
                                        , NULL
                                        ) );
                LocalFree( pszConnectoidName );
            } // if: IClusCfgCallback interface available
            else
            {
                hr = S_OK;
            }

            break;   // done!
        } // if: the Netbios API succeeded

        hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, ncb.ncb_retcode );

        if ( pcccbIn != NULL )
        {
            LPWSTR  pszConnectoidName = NULL;
            HRESULT hrSendStatusReport;

            TW32( ClRtlGetConnectoidNameFromLANA( leLanaEnum.lana[ idx ], &pszConnectoidName ) );
            THR( HrFormatStringIntoBSTR(
                          g_hInstance
                        , IDS_TASKID_MINOR_NETBIOS_BINDING_FAILED
                        , &bstrNotification
                        , szNetBIOSName
                        , leLanaEnum.lana[ idx ]
                        , ( pszConnectoidName == NULL ? L"" : pszConnectoidName )
                        ) );

            hrSendStatusReport = THR( pcccbIn->SendStatusReport(
                                          pcwszNameIn
                                        , TASKID_Major_Client_And_Server_Log
                                        , TASKID_Minor_NETBIOS_Binding_Failed
                                        , 1
                                        , 1
                                        , 1
                                        , hr
                                        , bstrNotification
                                        , NULL
                                        , NULL
                                        ) );
            LocalFree( pszConnectoidName );
            if ( FAILED( hrSendStatusReport ) )
            {
                if ( hr == S_OK )
                {
                    hr = hrSendStatusReport;
                }
                goto Cleanup;
            }
        } // if: IClusCfgCallback interface available
    } // for: each LAN adapter

    Assert( SUCCEEDED( hr ) );

    if ( ( hr == S_OK ) && ( *pbstrBindingOut == NULL ) )
    {
        hr = S_FALSE;
    }

Cleanup:

    Assert( ( hr != S_OK ) || ( *pbstrBindingOut != NULL ) );

    TraceSysFreeString( bstrNotification );
    TraceLocalFree( pszIPAddress );

    HRETURN( hr );

} //*** HrGetNetBIOSBinding

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsValidIPAddress
//
//  Description:
//      Determine whether a string represents a valid IP address.
//
//  Arguments:
//      pcwszAddressIn - The string to examine.
//
//  Return Values:
//      S_OK -      The string represents a valid IP address.
//      S_FALSE -   The string does not represent a valid IP address.
//
//      Possible failure codes from ClRtlTcpipStringToAddress.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsValidIPAddress(
      LPCWSTR   pcwszAddressIn
    )
{
    TraceFunc( "" );

    //  Return value.
    HRESULT hr = S_OK;

    //  Variables for converting the string.
    ULONG   ulAddress = 0;
    DWORD   scConversionResult = 0;

    scConversionResult = ClRtlTcpipStringToAddress( pcwszAddressIn, &ulAddress );
    if ( scConversionResult == ERROR_INVALID_PARAMETER )
    {
        hr = S_FALSE;
    }
    else if ( scConversionResult != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scConversionResult );
    }

    HRETURN( hr );

} //*** HrIsValidIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateHostnameLabel
//
//  Description:
//      Determine whether a string is a valid hostname label.
//
//  Arguments:
//      pcwszLabelIn            - The string to examine.
//      fAcceptNonRFCCharsIn    - Treat non-RFC characters as valid.
//
//  Return Values:
//      S_OK
//          The string is a valid hostname label.
//
//      HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME )
//          The string contains non-RFC characters, and the caller has
//          requested such characters be rejected.
//
//      Other errors returned from DnsValidateName, converted to HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateHostnameLabel(
      LPCWSTR   pcwszLabelIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD scDnsValidateName = ERROR_SUCCESS;

    scDnsValidateName = DnsValidateName_W( pcwszLabelIn, DnsNameHostnameLabel );
    if ( scDnsValidateName != ERROR_SUCCESS )
    {
        if ( ( scDnsValidateName != DNS_ERROR_NON_RFC_NAME ) || ( fAcceptNonRFCCharsIn == FALSE ) )
        {
            hr = HRESULT_FROM_WIN32( scDnsValidateName );
        }
    }

    HRETURN( hr );

} //*** HrValidateHostnameLabel


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateClusterNameLabel
//
//  Description:
//      Determine whether a string is a valid cluster name label.
//
//  Arguments:
//      pcwszLabelIn            - The string to examine.
//      fAcceptNonRFCCharsIn    - Treat non-RFC characters as valid.
//
//  Return Values:
//      S_OK
//          The string is a valid cluster name label.
//
//      HRESULT_FROM_WIN32( ERROR_NOT_FOUND )
//          The string is empty.
//
//      HRESULT_FROM_WIN32( ERROR_DS_NAME_TOO_LONG )
//          The string's NetBIOS representation would be too long.
//
//      HRESULT_FROM_WIN32( DNS_ERROR_INVALID_NAME_CHAR )
//          The string contains invalid characters.
//
//      HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME )
//          The string contains non-RFC characters, and the caller has
//          requested such characters be rejected.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_COMPUTERNAME )
//          The string is not valid for some other reason.
//
//  Remarks:
//      This checks for NetBIOS compatibility; DnsValidateName does not.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateClusterNameLabel(
      LPCWSTR   pcwszLabelIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // (jfranco, bugs 398108 and 398112)
    // KB:  DnsValidateName does not check the conversion of its argument
    //      to OEM characters, which happens when CBaseClusterAddNode::SetClusterName
    //      calls DnsHostnameToComputerNameW.  ClRtlIsNetNameValid does
    //      perform this check (in addition to those performed by DnsValidateName),
    //      and indicates whether the name has a valid
    //      OEM conversion and whether that conversion is too long.

    CLRTL_NAME_STATUS clrtlStatus = NetNameOk;
    ClRtlIsNetNameValid( pcwszLabelIn, &clrtlStatus, FALSE ); // ignore return; use status enum instead
    switch ( clrtlStatus )
    {
        case NetNameOk:
            break;

        case NetNameEmpty:
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
            break;

        case NetNameTooLong:
            hr = HRESULT_FROM_WIN32( ERROR_DS_NAME_TOO_LONG );
            break;

        case NetNameInvalidChars:
            hr = HRESULT_FROM_WIN32( DNS_ERROR_INVALID_NAME_CHAR );
            break;

        case NetNameDNSNonRFCChars:
            if ( fAcceptNonRFCCharsIn == FALSE )
            {
                hr = HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME );
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_COMPUTERNAME );
            break;
    } // switch ( clrtlStatus )

    HRETURN( hr );

} //*** HrValidateClusterNameLabel


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateDomainName
//
//  Description:
//      Determine whether a string is valid as a domain name.
//
//  Arguments:
//      pcwszDomainIn           - The string to examine.
//      fAcceptNonRFCCharsIn    - Treat non-RFC characters as valid.
//
//  Return Values:
//      S_OK
//          The string is valid as a domain name.
//
//      Possible failure codes from DnsValidateName (with DnsNameDomain as the
//          second parameter), converted to HRESULTs.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateDomainName(
      LPCWSTR   pcwszDomainIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT     hr              = S_OK;
    DNS_STATUS  scValidName     = ERROR_SUCCESS;
    bool        fNameIsValid    = false;

    scValidName  = DnsValidateName( pcwszDomainIn, DnsNameDomain );
    fNameIsValid = (  ( scValidName == ERROR_SUCCESS )
                   || (   ( scValidName == DNS_ERROR_NON_RFC_NAME )
                       && fAcceptNonRFCCharsIn ) );
    if ( fNameIsValid == FALSE )
    {
        hr = HRESULT_FROM_WIN32( scValidName );
    }

    HRETURN( hr );

} //*** HrValidateDomainName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateFQDN
//
//  Description:
//      Determine whether a string is valid as a fully-qualified domain name.
//
//  Arguments:
//      pwcszFQDNIn             - The string to examine.
//      fAcceptNonRFCCharsIn    - Treat non-RFC characters as valid.
//
//  Return Values:
//      S_OK
//          The string is valid as a fully-qualified domain name.
//
//      HRESULT_FROM_WIN32( ERROR_NOT_FOUND )
//          The hostname label part of the string is empty.
//
//      HRESULT_FROM_WIN32( ERROR_DS_NAME_TOO_LONG )
//          The hostname label's NetBIOS representation would be too long.
//
//      HRESULT_FROM_WIN32( DNS_ERROR_INVALID_NAME_CHAR )
//          The string contains invalid characters.
//
//      HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME )
//          The string contains non-RFC characters, and the caller has
//          requested such characters be rejected.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME )
//          The string is only a hostname label, without a domain name.
//
//      HRESULT_FROM_WIN32( ERROR_INVALID_COMPUTERNAME )
//          The string is not valid for some other reason.
//
//      Other failure codes from DnsValidateName (with DnsNameHostnameFull
//          as the second parameter), converted to HRESULTs.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateFQDN(
      LPCWSTR   pwcszFQDNIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    //  Give DnsValidateName the first shot at it.
    {
        DNS_STATUS  scValidName     = ERROR_SUCCESS;
        bool        fNameIsValid    = false;

        scValidName     = DnsValidateName( pwcszFQDNIn, DnsNameHostnameFull );
        fNameIsValid    = (  ( scValidName == ERROR_SUCCESS )
                          || (  ( scValidName == DNS_ERROR_NON_RFC_NAME )
                             && fAcceptNonRFCCharsIn ) );
        if ( fNameIsValid == FALSE )
        {
            hr = HRESULT_FROM_WIN32( scValidName );
            goto Cleanup;
        }
    }

    //  Force it to be an FQDN rather than a simple hostname label,
    //  which passes the DnsValidateName test above.
    {
        const WCHAR *   pwchMarker  = wcschr( pwcszFQDNIn, g_wchDNSDomainMarker );

        if ( pwchMarker == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME );
            goto Cleanup;
        }

        hr = HrValidateDomainName( pwchMarker + 1, true );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    HRETURN( hr );

} //*** HrValidateFQDN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMakeFQN
//
//  Description:
//      Creates an FQName for a given machine and domain.
//
//  Arguments:
//      pcwszMachineIn
//          The machine part of the FQName; can be a hostname label, an FQDN,
//          an IP address, or an FQIP.  If it's an FQDN or an FQIP,
//          the function passes it through as the result and ignores
//          the domain argument.
//
//      pcwszDomainIn
//          The domain part of the FQName; can be null, which means to use
//          the local machine's domain.  Only used if pcwszMachineIn does
//          not contain a domain name.
//
//      fAcceptNonRFCCharsIn
//          Treat non-RFC characters as valid.
//
//      pbstrFQNOut
//          The resulting FQName; to be freed with SysFreeString.
//
//      pefeoOut
//          If creation failed, indicates the source of the problem:
//          the machine name, the domain name, or a system error (such as
//          memory allocation).  Can be null if the caller doesn't care.
//
//  Return Values:
//      S_OK - pbstrFQNOut points to a valid FQName.
//
//      An error - pbstrFQNOut points to nothing and doesn't need to be freed.
//
//  Remarks:
//      An FQName extends standard fully-qualified domain names by allowing
//      the machine label part of the name to be an IP address.  It also
//      provides a way to associate an IP address with a domain, which is
//      necessary to prevent the creation of cross-domain clusters when using
//      IP addresses to identify the cluster nodes.
//
//      The format of an FQName can be either of the following:
//          [hostname label] [dot] [domain]
//          [IP address] [pipe] [domain]
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrMakeFQN(
      LPCWSTR           pcwszMachineIn
    , LPCWSTR           pcwszDomainIn
    , bool              fAcceptNonRFCCharsIn
    , BSTR *            pbstrFQNOut
    , EFQNErrorOrigin * pefeoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrValidationError = S_OK;
    BSTR    bstrLocalDomain = NULL;
    LPCWSTR pcwszDomainToUse = NULL;
    WCHAR   wchDomainMarker = g_wchIPDomainMarker; // initialize to IP address case

    Assert( pcwszMachineIn != NULL );
    Assert( pbstrFQNOut != NULL );
    Assert( *pbstrFQNOut == NULL );

    //
    //  If pcwszMachineIn is already an FQN, just pass it through.
    //
    hr = STHR( HrIsValidFQN( pcwszMachineIn, fAcceptNonRFCCharsIn, &hrValidationError ) );
    if ( hr == S_OK )
    {
        *pbstrFQNOut = TraceSysAllocString( pcwszMachineIn );
        if ( *pbstrFQNOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto SystemError;
        }
        goto Cleanup;
    }
    else if ( FAILED( hr ) )
    {
        goto SystemError;
    }

    //
    //  Make sure to return the proper error in the non-RFC case.
    //
    if ( hrValidationError == HRESULT_FROM_WIN32( DNS_ERROR_NON_RFC_NAME ) )
    {
        hr = THR( hrValidationError );
        goto LabelError;
    }

    //
    //  Check whether the machine is a valid label or IP address.
    //
    hr = STHR( HrIsValidIPAddress( pcwszMachineIn ) );
    if ( FAILED( hr ) )
    {
        goto SystemError;
    }
    else if ( hr == S_FALSE )
    {
        hr = THR( HrValidateHostnameLabel( pcwszMachineIn, fAcceptNonRFCCharsIn ) );
        if ( FAILED( hr ) )
        {
            goto LabelError;
        }
        wchDomainMarker = g_wchDNSDomainMarker;
    }

    //
    //  If caller passed in a domain, check whether the domain is valid.
    //
    if ( pcwszDomainIn != NULL )
    {
        hr = THR( HrValidateDomainName( pcwszDomainIn, fAcceptNonRFCCharsIn ) );
        if ( FAILED( hr ) )
        {
            goto DomainError;
        }
        pcwszDomainToUse = pcwszDomainIn;
    }
    else //  Otherwise, get local machine's domain.
    {
        hr = THR( HrGetComputerName(
                          ComputerNamePhysicalDnsDomain
                        , &bstrLocalDomain
                        , FALSE // fBestEffortIn
                        ) );
        if ( FAILED( hr ) )
        {
            goto SystemError;
        }

        pcwszDomainToUse = bstrLocalDomain;
    } // caller passed no domain

    //
    //  Append the domain to the machine, with the domain marker in between.
    //
    hr = THR( HrFormatStringIntoBSTR( L"%1!ws!%2!wc!%3!ws!", pbstrFQNOut, pcwszMachineIn, wchDomainMarker, pcwszDomainToUse ) );
    if ( FAILED( hr ) )
    {
        goto SystemError;
    }

    goto Cleanup;

LabelError:

    if ( pefeoOut != NULL )
    {
        *pefeoOut = feoLABEL;
    }
    goto Cleanup;

DomainError:

    if ( pefeoOut != NULL )
    {
        *pefeoOut = feoDOMAIN;
    }
    goto Cleanup;

SystemError:

    if ( pefeoOut != NULL )
    {
        *pefeoOut = feoSYSTEM;
    }
    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrLocalDomain );

    HRETURN( hr );

} //*** HrMakeFQN



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFQNToBindingString
//
//  Description:
//      Maps an FQName to a binding string.
//
//  Arguments:
//      pcccbIn         - Passed through to HrCreateBinding.
//      pclsidLogIn     - Passed through to HrCreateBinding.
//      pcwszFQNIn      - The FQName to map.
//      pbstrBindingOut - The resulting binding string.
//
//  Return Values:
//      S_OK - pbstrBindingOut points to a valid binding string.
//
//      An error - pbstrBindingOut points to nothing and doesn't need to be freed.
//
//  Remarks:
//
//      This function does work equivalent to HrCreateBinding for FQNames,
//      passing an FQDN through to HrCreateBinding, and simply returning the
//      IP address from an FQIP.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFQNToBindingString(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszFQNIn
    , BSTR *                pbstrBindingOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( pbstrBindingOut != NULL );
    Assert( *pbstrBindingOut == NULL );

    hr = STHR( HrIsValidFQN( pcwszFQNIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = THR( HrCreateBinding( pcccbIn, pclsidLogIn, pcwszFQNIn, pbstrBindingOut ) );
        goto Cleanup;
    } // else if:

    //  If it's an FQDN, pass through to HrCreateBinding.
    hr = STHR( HrFQNIsFQDN( pcwszFQNIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_OK )
    {
        hr = STHR( HrCreateBinding( pcccbIn, pclsidLogIn, pcwszFQNIn, pbstrBindingOut ) );
    }
    else //  Otherwise, extract IP address and return it.
    {
        WCHAR *         pwchDomainMarker = wcschr( pcwszFQNIn, g_wchIPDomainMarker );
        const size_t    cchAddress = pwchDomainMarker - pcwszFQNIn;
        WCHAR           wszIPAddress[ g_cchIPAddressMax    ];

        // g_cchIPAddressMax includes terminating null, so cchAddress can't be equal.
        if ( cchAddress >= g_cchIPAddressMax )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        }

        hr = THR( StringCchCopyNW( wszIPAddress, RTL_NUMBER_OF( wszIPAddress ), pcwszFQNIn, cchAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        *pbstrBindingOut = TraceSysAllocString( wszIPAddress );
        if ( *pbstrBindingOut == NULL)
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    } // pcwszFQNIn is an FQIP

Cleanup:

    HRETURN( hr );

} //*** HrFQNToBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFindDomainInFQN
//
//  Description:
//      Determines the location of the domain part of an FQName.
//
//  Arguments:
//      pcwszFQNIn
//          The FQName of interest.
//
//      pidxDomainOut
//          Receives the zero-based index of the first character of the domain
//          name in the string.
//
//  Return Values:
//      S_OK
//          The FQName is valid and the location to which pidxDomainOut
//          points contains the value described above.
//
//      An error
//          The location to which pidxDomainOut might contain anything.
//
//  Remarks:
//
//      Use this function, rather than wcschr(), to find a domain in an FQN.
//      For example, after the invocation
//          HrFindDomainInFQN( szName, &idxDomain );
//      returns success, the expression
//          szName + idxDomain
//      yields a null-terminated string containing just the domain.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFindDomainInFQN(
      LPCWSTR   pcwszFQNIn
    , size_t *  pidxDomainOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR * pwchDomainMarker = NULL;

    Assert( pcwszFQNIn != NULL );
    Assert( pidxDomainOut != NULL );

    hr = STHR( HrIsValidFQN( pcwszFQNIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_FALSE )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    *pidxDomainOut = 0;

    pwchDomainMarker = wcschr( pcwszFQNIn, g_wchIPDomainMarker );
    if ( pwchDomainMarker == NULL )
    {
        pwchDomainMarker = wcschr( pcwszFQNIn, g_wchDNSDomainMarker );
        if ( pwchDomainMarker == NULL )
        {
            //  If the string has neither marker, it's not a valid FQN,
            //  but given that the string passed HrIsValidFQN,
            //  this probably won't ever happen.
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        }
    }

    *pidxDomainOut = pwchDomainMarker - pcwszFQNIn + 1; // +1 because domain begins after marker

Cleanup:

    HRETURN( hr );

} //*** HrFindDomainInFQN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrExtractPrefixFromFQN
//
//  Description:
//      Makes a copy of the prefix part (either a hostname label or
//      an IP address) of an FQName.
//
//  Arguments:
//      pcwszFQNIn
//          The FQName of interest.
//
//      pbstrPrefixOut
//          Receives a newly allocated string containing just the prefix.
//
//  Return Values:
//      S_OK
//          The FQName is valid and the caller must free the string
//          to which pbstrPrefixOut points by calling SysFreeString.
//
//      An error
//          The caller must not attempt to free the string to which
//          pbstrPrefixOut points.
//
//  Remarks:
//      Use this function, rather than wcschr(), to split the prefix out of an FQN.
//      For example, after the invocation
//          HrFindDomainInFQN( szName, &bstrPrefix );
//      returns success, the bstrPrefix is a BSTR containing just the prefix.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrExtractPrefixFromFQN(
      LPCWSTR   pcwszFQNIn
    , BSTR *    pbstrPrefixOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    size_t  idxDomain = 0;
    size_t  cchPrefix = 0;

    Assert( pcwszFQNIn != NULL );
    Assert( pbstrPrefixOut != NULL );

    hr = THR( HrFindDomainInFQN( pcwszFQNIn, &idxDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    cchPrefix = idxDomain - 1; // -1 excludes the domain marker.
    *pbstrPrefixOut = TraceSysAllocStringLen( pcwszFQNIn, ( UINT ) cchPrefix );
    if ( *pbstrPrefixOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** HrExtractPrefixFromFQN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFQNIsFQDN
//
//  Description:
//      Determines whether an FQName is a fully-qualified domain name.
//
//  Arguments:
//      pcwszFQNIn  - The FQName of interest.
//
//  Return Values:
//      S_OK        - The FQName is a valid FQDN.
//      S_FALSE     - The FQName is valid, but it's not an FQDN.
//      An error    - The FQName is not valid, or something else went wrong.
//
//  Remarks:
//      Use this function, rather than wcschr() or DnsValidateName(),
//      to determine whether an FQName is an FQDN.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFQNIsFQDN(
      LPCWSTR   pcwszFQNIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR * pwchDomainMarker = NULL;

    Assert( pcwszFQNIn != NULL );

    hr = HrIsValidFQN( pcwszFQNIn, true );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_FALSE )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    pwchDomainMarker = wcschr( pcwszFQNIn, g_wchIPDomainMarker );
    if ( pwchDomainMarker != NULL )
    {
        hr = S_FALSE;
    }

Cleanup:

    HRETURN( hr );

} //*** HrFQNIsFQDN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFQNIsFQIP
//
//  Description:
//      Determines whether an FQName is an FQIP.
//
//  Arguments:
//      pcwszFQNIn  - The FQName of interest.
//
//  Return Values:
//      S_OK        - The FQName is a valid FQIP.
//      S_FALSE     - The FQName is valid, but it's not an FQIP.
//      An error    - The FQName is not valid, or something else went wrong.
//
//  Remarks:
//      Use this function, rather than wcschr(),
//      to determine whether an FQName is an FQIP.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFQNIsFQIP(
      LPCWSTR   pcwszFQNIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR * pwchDomainMarker = NULL;

    Assert( pcwszFQNIn != NULL );

    hr = HrIsValidFQN( pcwszFQNIn, true );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_FALSE )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    pwchDomainMarker = wcschr( pcwszFQNIn, g_wchIPDomainMarker );
    if ( pwchDomainMarker == NULL )
    {
        hr = S_FALSE;
    }

Cleanup:

    HRETURN( hr );

} //*** HrFQNIsFQIP


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsValidFQN
//
//  Description:
//      Determines whether a string is a valid FQName.
//
//  Arguments:
//      pcwszFQNIn
//          The string to examine.
//
//      fAcceptNonRFCCharsIn
//          Treat non-RFC characters as valid.
//
//      phrValidationErrorOut
//          If the string is not valid, indicates the reason why.
//
//  Return Values:
//      S_OK    - The string is a valid FQName.
//      S_FALSE - The string is not a valid FQName.
//      E_POINTER - The pcwszFQNIn parameter was NULL.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsValidFQN(
      LPCWSTR   pcwszFQNIn
    , bool      fAcceptNonRFCCharsIn
    , HRESULT * phrValidationErrorOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    const WCHAR *   pwchMarker = NULL;
    HRESULT         hrValidationError = S_OK;

    if ( pcwszFQNIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  If the name contains an IP domain marker...
    pwchMarker = wcschr( pcwszFQNIn, g_wchIPDomainMarker );
    if ( pwchMarker != NULL )
    {
        //  Check whether string preceding domain marker is a valid IP address.
        {
            WCHAR           wszIPAddress[ g_cchIPAddressMax    ];
            const size_t    cchAddress = pwchMarker - pcwszFQNIn;

            // g_cchIPAddressMax includes terminating null, so cchAddress can't be equal.
            if ( cchAddress >= g_cchIPAddressMax )
            {
                hrValidationError = HRESULT_FROM_WIN32( ERROR_DS_NAME_TOO_LONG );
                hr = S_FALSE;
                goto Cleanup;
            }

            hr = THR( StringCchCopyNW( wszIPAddress, RTL_NUMBER_OF( wszIPAddress ), pcwszFQNIn, cchAddress ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = HrIsValidIPAddress( wszIPAddress );
            if ( hr != S_OK ) // proceed only if valid
            {
                hrValidationError = E_INVALIDARG;
                goto Cleanup;
            }
        } // checking for valid ip address

        //  Check whether string following domain marker is a valid domain name.
        {
            hr = HrValidateDomainName( pwchMarker + 1, fAcceptNonRFCCharsIn );
            if ( FAILED( hr ) )
            {
                hrValidationError = hr;
                hr = S_FALSE;
                goto Cleanup;
            }
        } // checking for valid domain name

    } // if: found IP domain marker
    else //  Otherwise, check whether whole string is a valid FQDN.
    {
        hr = HrValidateFQDN( pcwszFQNIn, fAcceptNonRFCCharsIn );
        if ( FAILED( hr ) )
        {
            hrValidationError = hr;
            hr = S_FALSE;
            goto Cleanup;
        }
    } // else: not an FQIP

Cleanup:

    if ( FAILED( hrValidationError ) && ( phrValidationErrorOut != NULL ) )
    {
        *phrValidationErrorOut = hrValidationError;
    }

    HRETURN( hr );

} //*** HrIsValidFQN

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateFQNPrefix
//
//  Description:
//
//  Arguments:
//      pcwszPrefixIn
//      fAcceptNonRFCCharsIn
//
//  Return Values:
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateFQNPrefix(
      LPCWSTR   pcwszPrefixIn
    , bool      fAcceptNonRFCCharsIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = HrIsValidIPAddress( pcwszPrefixIn );
    if ( hr == S_FALSE )
    {
        hr = HrValidateHostnameLabel( pcwszPrefixIn, fAcceptNonRFCCharsIn );
    }

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** HrValidateFQNPrefix


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetFQNDisplayName
//
//  Description:
//      Makes a copy of the prefix part (either a hostname label or
//      an IP address) of an FQName, or a copy of the whole string if it's
//      not an FQName.
//
//  Arguments:
//      pcwszNameIn
//          The string of interest.
//
//      pbstrShortNameOut
//          Receives a newly allocated string containing either the FQName
//          prefix (in the FQName case) or a copy of the whole string.
//
//  Return Values:
//      S_OK
//          The caller must free the string to which pbstrShortNameOut points
//          by calling SysFreeString.
//
//      An error
//          The caller must not attempt to free the string to which
//          pbstrShortNameOut points.
//
//  Remarks:
//      This function just wraps HrExtractPrefixFromFQN to make a copy of
//      the whole string (rather than return an error) if it's not a valid FQN.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetFQNDisplayName(
      LPCWSTR   pcwszNameIn
    , BSTR *    pbstrShortNameOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( pcwszNameIn != NULL );
    Assert( pbstrShortNameOut != NULL );

    //
    //  If the name is fully-qualified, use just the prefix.
    //
    hr = STHR( HrIsValidFQN( pcwszNameIn, true ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else if ( hr == S_OK )
    {
        hr = THR( HrExtractPrefixFromFQN( pcwszNameIn, pbstrShortNameOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else // Otherwise, use the name as is.
    {
        *pbstrShortNameOut = TraceSysAllocString( pcwszNameIn );
        if ( *pbstrShortNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

Cleanup:

    HRETURN( hr );

} //*** HrGetFQNDisplayName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\nameutil.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      NameUtil.h
//
//  Description:
//      Name resolution utility.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
//  (jfranco, bug #462673)  The effective limit for names passed to
//  DnsValidateName needs to be DNS_MAX_NAME_LENGTH - 2, because the value
//  mentioned in its MSDN topic (255) includes the terminating null and an
//  automatically inserted final dot.
//
#define ADJUSTED_DNS_MAX_NAME_LENGTH ( DNS_MAX_NAME_LENGTH - 2 )


HRESULT
HrCreateBinding(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszNameIn
    , BSTR *                pbstrBindingOut
    );

HRESULT
HrGetNetBIOSBinding(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszNameIn
    , BSTR *                pbstrBindingOut
    );

HRESULT
HrIsValidIPAddress(
      LPCWSTR   pcwszAddressIn
    );

HRESULT
HrValidateHostnameLabel(
      LPCWSTR   pcwszLabelIn
    , bool      fAcceptNonRFCCharsIn
    );

HRESULT
HrValidateClusterNameLabel(
      LPCWSTR   pcwszLabelIn
    , bool      fAcceptNonRFCCharsIn
    );

HRESULT
HrValidateDomainName(
      LPCWSTR   pcwszDomainIn
    , bool      fAcceptNonRFCCharsIn
    );

HRESULT
HrValidateFQDN(
      LPCWSTR   pcwszFQDNIn
    , bool      fAcceptNonRFCCharsIn
    );

enum EFQNErrorOrigin
{
    feoLABEL = 0,
    feoDOMAIN,
    feoSYSTEM
};

HRESULT
HrMakeFQN(
      LPCWSTR           pcwszMachineIn // can be a hostname label, an FQDN, an FQN, or an IP address
    , LPCWSTR           pcwszDomainIn // can be null, which means to use local machine's domain
    , bool              fAcceptNonRFCCharsIn
    , BSTR *            pbstrFQNOut
    , EFQNErrorOrigin * pefeoOut = NULL
    );

HRESULT
HrFQNToBindingString(
      IClusCfgCallback *    pcccbIn
    , const CLSID *         pclsidLogIn
    , LPCWSTR               pcwszFQNIn
    , BSTR *                pbstrBindingOut
    );

HRESULT
HrFindDomainInFQN(
      LPCWSTR   pcwszFQNIn
    , size_t *  pidxDomainOut
    );

HRESULT
HrExtractPrefixFromFQN(
      LPCWSTR   pcwszFQNIn
    , BSTR *    pbstrPrefixOut
    );

HRESULT
HrFQNIsFQDN(
      LPCWSTR   pcwszFQNIn
    );

HRESULT
HrFQNIsFQIP(
      LPCWSTR   pcwszFQNIn
    );

HRESULT
HrIsValidFQN(
      LPCWSTR   pcwszFQNIn
    , bool      fAcceptNonRFCCharsIn
    , HRESULT * phrValidationErrorOut = NULL
    );

HRESULT
HrValidateFQNPrefix(
      LPCWSTR   pcwszPrefixIn
    , bool      fAcceptNonRFCCharsIn = true
    );
    
HRESULT
HrGetFQNDisplayName(
      LPCWSTR   pcwszNameIn
    , BSTR *    pbstrShortNameOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\internalguids\cluscfginternalguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfgInternalGuids.cpp
//
//  Description:
//      Values for Microsoft internal-use-only cluster configuration guids.
//
//  Maintained By:
//      John Franco (JFranco) 02-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>
#include <ClusCfgInternalGuids.h>
#include <cluscfgclient_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\objectcookie.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectCookie.h
//
//  Description:
//      OBJECTCOOKIE definition
//
//  Maintained By:
//      Geoffrey Pease (GPease) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef DWORD OBJECTCOOKIE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\logger.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Logger.h
//
//  Description:
//      ClCfgSrv Logger definition.
//
//  Maintained By:
//      David Potter (DavidP)   11-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Definitions
//////////////////////////////////////////////////////////////////////////////

class CClCfgSrvLogger;

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClCfgSrvLogger
//
//  Description:
//      Manages a logging stream to a file.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClCfgSrvLogger
    : public ILogger
{
private:
    // IUnknown
    LONG                            m_cRef;             // Reference counter.

private: // Methods
    //
    // Constructors, destructors, and initializers
    //

    CClCfgSrvLogger( void );
    ~CClCfgSrvLogger( void );
    STDMETHOD( HrInit )( void );

    // Private copy constructor to prevent copying.
    CClCfgSrvLogger( const CClCfgSrvLogger & );

    // Private assignment operator to prevent copying.
    CClCfgSrvLogger & operator=( const CClCfgSrvLogger & );

public: // Methods

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT
        S_HrLogStatusReport(
          ILogger *     plLogger
        , LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

    //
    // IUnknown Interfaces
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // ILogger
    //
    STDMETHOD( LogMsg )( DWORD nLogEntryTypeIn, LPCWSTR pcszMsgIn );

}; //*** class CClCfgSrvLogger

//////////////////////////////////////////////////////////////////////////////
//  Global Function Prototypes
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\inc\resourceidranges.h ===
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      ResourceIdRanges.h
//
//  Description:
//      This file contains resource id ranges for the ClusCfg Wizard Components
//      component.
//
//  Maintained By:
//	    Ozan Ozhan   (OzanO)    11-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////

// The IDs for DLL resource strings.
#define ID_DLL_START                        0

#define IDR_MANIFEST                        500

#define ID_DLL_END                          599


// The range for PostCfg string IDs.
#define ID_POSTCFG_START                    600
#define ID_POSTCFG_END                      999

// The range for BaseCluster string IDs.
#define ID_BCA_START                        1000
#define ID_BCA_END                          1999

// The range for Wizard string IDs.
#define ID_WIZ_START                        2000
#define ID_WIZ_END                          3999

// The range for Server string IDs.
#define ID_CCS_START                        4000
#define ID_CCS_END                          5999

// The range for W2KProxy string IDs.
#define ID_CCW2K_START                      6000
#define ID_CCW2K_END                        6999

// The range for MiddleTier string IDs.
#define ID_MT_START                         7000
#define ID_MT_END                           7999

// The range for common string IDs.
#define ID_COMMON_START                     8000
#define ID_COMMON_END                       8999
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\clusterconfiguration.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ClusterConfiguration.h
//
//  Description:
//      CClusterConfiguration implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CClusterConfiguration
class CClusterConfiguration
    : public IExtendObjectManager
    , public IClusCfgClusterInfo
    , public IGatherData  // private
{
private:
    // IUnknown
    LONG                        m_cRef;

    // Async/IClusCfgClusterInfo
    ECommitMode             m_ecmCommitChangesMode;
    BSTR                    m_bstrClusterName;          // Cluster Name
    BSTR                    m_bstrClusterBindingString; // Cluster binding string.
    BOOL                    m_fHasNameChanged;          // If the cluster name has changed...
    ULONG                   m_ulIPAddress;              // Cluster IP Address
    ULONG                   m_ulSubnetMask;             // Cluster Subnet Mask
    IClusCfgCredentials *   m_picccServiceAccount;      // Cluster service account credentials
    IClusCfgNetworkInfo *   m_punkNetwork;              // Cluster network that the IP/subnet should be hosted.
    DWORD                   m_cMaxNodes;                // Maximun number of nodes allowed in this cluster.

    // IExtendObjectManager

private: // Methods
    CClusterConfiguration( void );
    ~CClusterConfiguration( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgClusterInfo
    STDMETHOD( SetCommitMode )( ECommitMode ecmNewModeIn );
    STDMETHOD( GetCommitMode )( ECommitMode * pecmCurrentModeOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );
    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );
    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppiccniOut );
    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * piccniIn );
    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppicccCredentialsOut );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );
    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                      OBJECTCOOKIE cookieIn
                    , REFCLSID     rclsidTypeIn
                    , LPCWSTR      pcszName
                    , LPUNKNOWN *  ppunkOut
                    );

}; //*** class CClusterConfiguration
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\clusterconfiguration.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterConfiguration.cpp
//
//  Description:
//      CClusterConfiguration implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterConfiguration.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CClusterConfiguration")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterConfiguration::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterConfiguration::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CClusterConfiguration * pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcc = new CClusterConfiguration;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CClusterConfiguration::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::CClusterConfiguration
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterConfiguration::CClusterConfiguration( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterConfiguration::CClusterConfiguration

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::HrInit
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IClusCfgClusterInfo
    Assert( m_bstrClusterName == NULL );
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_picccServiceAccount == NULL );
    Assert( m_punkNetwork == NULL );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );
    Assert( m_bstrClusterBindingString == NULL );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CClusterConfiguration::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::~CClusterConfiguration
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterConfiguration::~CClusterConfiguration( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrClusterName );
    TraceSysFreeString( m_bstrClusterBindingString );

    if ( m_picccServiceAccount != NULL )
    {
        m_picccServiceAccount->Release();
    }

    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterConfiguration::~CClusterConfiguration

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgClusterInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
    } // else if: IClusCfgClusterInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusterConfiguration::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterConfiguration::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterConfiguration::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusterConfiguration::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterConfiguration::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterConfiguration::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CClusterConfiguration::Release


// ************************************************************************
//
//  IClusCfgClusterInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetCommitMode( ECommitMode * pecmCurrentModeOut )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetCommitMode( ECommitMode * pecmCurrentModeOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pecmCurrentModeOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pecmCurrentModeOut = m_ecmCommitChangesMode;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetCommitMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetCommitMode( ECommitMode ecmCurrentModeIn )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetCommitMode( ECommitMode ecmCurrentModeIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ecmCommitChangesMode = ecmCurrentModeIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetCommitMode

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrClusterName == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrNameOut = SysAllocString( m_bstrClusterName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetName

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrClusterName );
    m_bstrClusterName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::SetName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetIPAddress(
//      ULONG * pulDottedQuadOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetIPAddress(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pulDottedQuadOut = m_ulIPAddress;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetIPAddress(
//      ULONG ulDottedQuadIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetIPAddress(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulIPAddress = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetIPAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetSubnetMask(
//      ULONG * pulDottedQuadOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetSubnetMask(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pulDottedQuadOut = m_ulSubnetMask;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetSubnetMask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetSubnetMask(
//      ULONG ulDottedQuadIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetSubnetMask(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulSubnetMask = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetSubnetMask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetNetworkInfo(
//      IClusCfgNetworkInfo ** ppiccniOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppiccniOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( ppiccniOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_punkNetwork == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
        goto Cleanup;
    }

    *ppiccniOut = TraceInterface( L"CClusterConfiguration!GetNetworkInfo", IClusCfgNetworkInfo, m_punkNetwork, 0 );
    (*ppiccniOut)->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetNetworkInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::SetNetworkInfo(
//      IClusCfgNetworkInfo * piccniIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetNetworkInfo(
    IClusCfgNetworkInfo * piccniIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    IClusCfgNetworkInfo * punkNew;

    if ( piccniIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( piccniIn->TypeSafeQI( IClusCfgNetworkInfo, &punkNew ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
    }

    m_punkNetwork = punkNew;    // no addref!

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::SetNetworkInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetClusterServiceAccountCredentials(
//      IClusCfgCredentials ** ppicccCredentialsOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppicccCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT     hr = S_OK;

    if ( m_picccServiceAccount == NULL )
    {
        hr = THR( HrCoCreateInternalInstance( CLSID_ClusCfgCredentials,
                                              NULL,
                                              CLSCTX_INPROC_HANDLER,
                                              IID_IClusCfgCredentials,
                                              reinterpret_cast< void ** >( &m_picccServiceAccount )
                                              ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    if ( ppicccCredentialsOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *ppicccCredentialsOut = TraceInterface( L"ClusCfgCredentials!ClusterConfig", IClusCfgCredentials, m_picccServiceAccount, 0 );
    (*ppicccCredentialsOut)->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetClusterServiceAccountCredentials


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetBindingString(
//      BSTR * pbstrBindingStringOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrClusterBindingString == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrClusterBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetBindingString

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetBindingString(
//      LPCWSTR bstrBindingStringIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetBindingString(
    LPCWSTR pcszBindingStringIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ws'", ( pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn ) );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrClusterBindingString  );
    m_bstrClusterBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::SetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::GetMaxNodeCount
//
//  Description:
//      Get the maximum number of nodes supported in this cluster.
//
//  Arguments:
//      pcMaxNodesOut
//
//  Return Value:
//      S_OK
//          Success;
//
//      E_POINTER
//          pcMaxNodesOut is NULL.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if (pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pcMaxNodesOut = m_cMaxNodes;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetMaxNodeCount


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;

    IServiceProvider *    psp;

    IObjectManager *      pom   = NULL;
    IClusCfgClusterInfo * pcci  = NULL;
    IClusCfgCredentials * piccc = NULL;
    IClusCfgNetworkInfo * pccni = NULL;
    IUnknown *            punk  = NULL;
    IGatherData *         pgd   = NULL;

    if ( punkIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Make sure this is what we think it is.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgClusterInfo, &pcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Gather Cluster Name
    //

    hr = THR( pcci->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrClusterName );

    //
    //  Gather Cluster binding string
    //

    hr = STHR( pcci->GetBindingString( &m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrClusterBindingString );

    //
    //  Gather IP Address
    //

    hr = STHR( pcci->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather Subnet Mask
    //

    hr = STHR( pcci->GetSubnetMask( &m_ulSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Find out our cookie.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               cookieParentIn,
                               m_bstrClusterName,
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather the network.
    //

    hr = STHR( pcci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( CManagedNetwork::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather the info, but since this object isn't going to be
    //  reflected in the cookie tree, pass it a parent of ZERO
    //  so it won't gather the secondary IP addresses.
    //
    hr = THR( pgd->Gather( 0, pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &m_punkNetwork ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather Account Name and Domain.
    //

    hr = THR( pcci->GetClusterServiceAccountCredentials( &piccc  ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( HrCoCreateInternalInstance( CLSID_ClusCfgCredentials,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IClusCfgCredentials,
                                          reinterpret_cast< void ** >( &m_picccServiceAccount )
                                          ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_picccServiceAccount->AssignFrom( piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = STHR( pcci->GetMaxNodeCount( &m_cMaxNodes ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Anything else to gather??
    //

    hr = S_OK;

Cleanup:

    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pcci != NULL )
    {
        pcci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    TraceSysFreeString( m_bstrClusterName );
    m_bstrClusterName = NULL;

    m_fHasNameChanged = FALSE;
    m_ulIPAddress = 0;
    m_ulSubnetMask = 0;
    if ( m_picccServiceAccount != NULL )
    {
        m_picccServiceAccount->Release();
        m_picccServiceAccount = NULL;
    }
    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
        m_punkNetwork = NULL;
    }
    goto Cleanup;

} //*** CClusterConfiguration::Gather


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CClusterConfiguration::FindObject(
//      OBJECTCOOKIE        cookieIn,
//      REFCLSID            rclsidTypeIn,
//      LPCWSTR             pcszNameIn,
//      LPUNKNOWN *         punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::FindObject(
    OBJECTCOOKIE        cookieIn,
    REFCLSID            rclsidTypeIn,
    LPCWSTR             pcszNameIn,
    LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_PENDING;

    //
    //  Check parameters.
    //

    //  We need to represent a ClusterType.
    if ( !IsEqualIID( rclsidTypeIn, CLSID_ClusterConfigurationType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  Gotta have a cookie
    if ( cookieIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to have a name.
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Try to save the name. We don't care if this fails as it will be
    //  over-ridden when the information is retrieved from the node.
    //
    m_bstrClusterName = TraceSysAllocString( pcszNameIn );

    //
    //  Get the pointer.
    //
    if ( ppunkOut != NULL )
    {
        hr = THR( QueryInterface( DFGUID_ClusterConfigurationInfo,
                                  reinterpret_cast< void ** > ( ppunkOut )
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: ppunkOut

    //
    //  Tell caller that the data is pending.
    //
    hr = E_PENDING;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::FindObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\configconnection.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ConfigurationConnection.h
//
//  Description:
//      CConfigurationConnection implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConfigurationConnection
class
CConfigurationConnection
    : public IConfigurationConnection
    , public IClusCfgServer
    , public IClusCfgCallback
    , public IClusCfgCapabilities
    , public IClusCfgVerify
{
private:
    // IUnknown
    LONG                m_cRef;

    // IConfigurationConnection
    IGlobalInterfaceTable * m_pgit;                     // Global Interface Table
    DWORD                   m_cookieGITServer;          // Goblal Interface Table cookie -- Server interface
    DWORD                   m_cookieGITVerify;          // Goblal Interface Table cookie -- Server interface
    DWORD                   m_cookieGITCallbackTask;    // Goblal Interface Table cookie -- polling callback task interface
    IClusCfgCallback *      m_pcccb;                    // Marshalled callback interface
    BSTR                    m_bstrLocalComputerName;    // Local computer name FQDN
    BSTR                    m_bstrLocalHostname;        // Local computer hostname
    HRESULT                 m_hrLastStatus;             // Last status of connection.
    BSTR                    m_bstrBindingString;              // String used to bind to the server.

private: // Methods
    CConfigurationConnection( void );
    ~CConfigurationConnection( void );
    STDMETHOD( HrInit )( void );

    HRESULT HrRetrieveServerInterface( IClusCfgServer ** ppccsOut );
    HRESULT HrStartPolling( OBJECTCOOKIE cookieIn );
    HRESULT HrStopPolling( void );
    HRESULT HrSetSecurityBlanket( IClusCfgServer * pccsIn );
    HRESULT HrIsLocalComputer( LPCWSTR pcszNameIn, size_t cchNameIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConfigurationConnection
    STDMETHOD( ConnectTo )( OBJECTCOOKIE cookieIn );
    STDMETHOD( ConnectToObject )( OBJECTCOOKIE cookieIn, REFIID riidIn, LPUNKNOWN * ppunkOut );

    // IClusCfgServer
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );
    STDMETHOD( CommitChanges )( void );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                  LPCWSTR       pcszNodeNameIn
                , CLSID         clsidTaskMajorIn
                , CLSID         clsidTaskMinorIn
                , ULONG         ulMinIn
                , ULONG         ulMaxIn
                , ULONG         ulCurrentIn
                , HRESULT       hrStatusIn
                , LPCWSTR       pcszDescriptionIn
                , FILETIME *    pftTimeIn
                , LPCWSTR       pcszReferenceIn
                );

    // IClusCfgCapabilities
    STDMETHOD( CanNodeBeClustered )( void );

    // IClusCfgVerify
    STDMETHOD( VerifyCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );
    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR pcszClusterNameIn );
    STDMETHOD( VerifyConnectionToNode )( LPCWSTR pcszNodeNameIn );

}; //*** class CConfigurationConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connectioninfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionInfo.cpp
//
//  Description:
//      CConnectionInfo implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConnectionInfo.h"

DEFINE_THISCLASS("CConnectionInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionInfo::S_HrCreateInstance(
//      OBJECTCOOKIE cookieParentIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionInfo::S_HrCreateInstance(
    IUnknown **  ppunkOut,
    OBJECTCOOKIE cookieParentIn
    )
{
    TraceFunc1( "ppunkOut, cookieParentIn = %u", cookieParentIn );

    HRESULT             hr = S_OK;
    CConnectionInfo *   pci = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pci = new CConnectionInfo;
    if ( pci == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pci->HrInit( cookieParentIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR(  pci->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pci != NULL )
    {
        pci->Release();
    }

    HRETURN( hr );

} //*** CConnectionInfo::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionInfo::CConnectionInfo
//
//////////////////////////////////////////////////////////////////////////////
CConnectionInfo::CConnectionInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionInfo::CConnectionInfo

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::HrInit(
//      OBJECTCOOKIE cookieParentIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::HrInit(
    OBJECTCOOKIE cookieParentIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IConnectionInfo
    Assert( m_pcc == NULL );
    m_cookieParent = cookieParentIn;

    HRETURN( hr );

} //*** CConnectionInfo::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionInfo::~CConnectionInfo
//
//////////////////////////////////////////////////////////////////////////////
CConnectionInfo::~CConnectionInfo( void )
{
    TraceFunc( "" );

    if ( m_pcc != NULL )
    {
        m_pcc->Release();
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionInfo::~CConnectionInfo


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConnectionInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::QueryInterface(
      REFIID    riidin
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidin, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidin, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConnectionInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidin, IID_IConnectionInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConnectionInfo, this, 0 );
    } // else if: IConnectionInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidin );

} //*** CConnectionInfo::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CConnectionInfo::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CConnectionInfo::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CConnectionInfo::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CConnectionInfo::Release


//****************************************************************************
//
//  IConnectionInfo
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::GetConnection(
//      IConfigurationConnection ** pccOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::GetConnection(
    IConfigurationConnection ** pccOut
    )
{
    TraceFunc( "[IConnectionInfo]" );
    Assert( pccOut != NULL );

    HRESULT hr = S_OK;

    if ( pccOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( m_pcc == NULL )
    {
        *pccOut = NULL;
        hr = S_FALSE;
    }
    else
    {
        *pccOut = m_pcc;
        (*pccOut)->AddRef();
    }

Cleanup:

    HRETURN( hr );

} //*** CConnectionInfo::GetConnection

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::SetConnection(
//      IConfigurationConnection * pccIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::SetConnection(
    IConfigurationConnection * pccIn
    )
{
    TraceFunc( "[IConnectionInfo]" );

    HRESULT hr = S_OK;

    if ( m_pcc != NULL )
    {
        m_pcc->Release();
        m_pcc = NULL;
    }

    m_pcc = pccIn;

    if ( m_pcc != NULL )
    {
        m_pcc->AddRef();
    }

    HRETURN( hr );

} //*** CConnectionInfo::SetConnection


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::GetParent(
//      OBJECTCOOKIE * pcookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::GetParent(
    OBJECTCOOKIE * pcookieOut
    )
{
    TraceFunc( "[IConnectionInfo]" );

    HRESULT hr = S_OK;

    if ( pcookieOut == NULL )
        goto InvalidPointer;

    Assert( m_cookieParent != NULL );

    *pcookieOut = m_cookieParent;

    if ( m_cookieParent == NULL )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CConnectionInfo::GetParent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connectioninfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionInfo.h
//
//  Description:
//      CConnectionInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConnectionInfo
class CConnectionInfo
    : public IConnectionInfo
{
private:
    // IUnknown
    LONG                m_cRef;

    // IConnectionInfo
    IConfigurationConnection *  m_pcc;
    OBJECTCOOKIE                m_cookieParent;

private: // Methods
    CConnectionInfo( void );
    ~CConnectionInfo( void );
    STDMETHOD( HrInit )( OBJECTCOOKIE pcookieParentIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            OBJECTCOOKIE pcookieParentIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConnectionInfo
    STDMETHOD( GetConnection )( IConfigurationConnection ** pccOut );
    STDMETHOD( SetConnection )( IConfigurationConnection * pccIn );
    STDMETHOD( GetParent )( OBJECTCOOKIE * pcookieOut );

}; //*** class CConnectionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\configconnection.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ConfigurationConnection.cpp
//
//  Description:
//      CConfigurationConnection implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskPollingCallback.h"
#include "ConfigConnection.h"
#include <ClusCfgPrivate.h>
#include <nameutil.h>

DEFINE_THISCLASS("CConfigurationConnection");


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateServerObject
//
//  Description:
//      Create a ClusCfgServer object and get three interfaces from it
//      for use by CConfigurationConnection::ConnectTo().
//
//  Arguments:
//      pcwszMachineNameIn
//          The machine on which to create the object.  Can be NULL, which
//          creates the object on the local machine.
//      ppccsOut
//          The IClusCfgServer interface on the newly created object.
//      ppccvOut
//          The IClusCfgVerify interface on the newly created object.
//      ppcciOut
//          The IClusCfgInitialize interface on the newly created object.
//
//  Return Values:
//      S_OK -      Creation succeeded and all returned interfaces are valid.
//
//      Possible failure codes from CoCreateInstanceEx or QueryInterface.
//
//  Remarks:
//      This function consolidates code that was duplicated in two parts of
//      CConfigurationConnection::ConnectTo().
//
//      On failure, all returned pointers are NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrCreateServerObject(
      LPCWSTR                 pcwszMachineNameIn
    , IClusCfgServer **       ppccsOut
    , IClusCfgVerify **       ppccvOut
    , IClusCfgInitialize **   ppcciOut
    )
{
    TraceFunc( "" );
    Assert( ppccsOut != NULL );
    Assert( ppccvOut != NULL );
    Assert( ppcciOut != NULL );

    HRESULT hr = S_OK;

    COSERVERINFO    serverinfo;
    COSERVERINFO *  pserverinfo = NULL;
    MULTI_QI        rgmqi[ 3 ];
    CLSCTX          ctx = CLSCTX_INPROC_SERVER;
    size_t          idx;

    ZeroMemory( rgmqi, sizeof( rgmqi ) );

    if ( ( ppccsOut == NULL ) || ( ppccvOut == NULL ) || ( ppcciOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppccsOut = NULL;
    *ppccvOut = NULL;
    *ppcciOut = NULL;

    rgmqi[ 0 ].pIID = &IID_IClusCfgVerify;
    rgmqi[ 1 ].pIID = &IID_IClusCfgServer;
    rgmqi[ 2 ].pIID = &IID_IClusCfgInitialize;

    if ( pcwszMachineNameIn != NULL )
    {
        ZeroMemory( &serverinfo, sizeof( serverinfo ) );
        serverinfo.pwszName = const_cast< LPWSTR >( pcwszMachineNameIn );
        pserverinfo = &serverinfo;
        ctx = CLSCTX_REMOTE_SERVER;
    }

    hr = CoCreateInstanceEx(
                  CLSID_ClusCfgServer
                , NULL
                , ctx
                , pserverinfo
                , ARRAYSIZE( rgmqi )
                , rgmqi
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    for ( idx = 0; idx < ARRAYSIZE( rgmqi ); ++idx )
    {
        if ( FAILED( rgmqi[ idx ].hr ) )
        {
            hr = THR( rgmqi[ idx ].hr );
            goto Cleanup;
        } // if: qi failed
    }

    *ppccvOut = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgVerify, reinterpret_cast< IClusCfgVerify * >( rgmqi[ 0 ].pItf ), 1 );
    *ppccsOut = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgServer, reinterpret_cast< IClusCfgServer * >( rgmqi[ 1 ].pItf ), 1 );
    *ppcciOut = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgInitialize, reinterpret_cast< IClusCfgInitialize * >( rgmqi[ 2 ].pItf ), 1 );
    ZeroMemory( rgmqi, sizeof( rgmqi ) ); // Done with these; don't clean them up.

Cleanup:

    for ( idx = 0; idx < ARRAYSIZE( rgmqi ); ++idx )
    {
        if ( rgmqi[ idx ].pItf != NULL )
        {
            rgmqi[ idx ].pItf->Release();
        }
    }

    HRETURN( hr );

} //*** HrCreateServerObject


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CConfigurationConnection *  pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcc = new CConfigurationConnection;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::CConfigurationConnection
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigurationConnection::CConfigurationConnection( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigurationConnection::CConfigurationConnection

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::HrInit
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    //  IConfigurationConnection
    Assert( m_cookieGITServer == 0 );
    Assert( m_cookieGITVerify == 0 );
    Assert( m_cookieGITCallbackTask == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_bstrLocalComputerName == NULL );
    Assert( m_bstrLocalHostname == NULL );
    Assert( m_hrLastStatus == S_OK );
    Assert( m_bstrBindingString == NULL );

    //
    //  Figure out the local computer name.
    //
    hr = THR( HrGetComputerName(
                      ComputerNameDnsFullyQualified
                    , &m_bstrLocalComputerName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrLocalHostname
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::~CConfigurationConnection
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigurationConnection::~CConfigurationConnection( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrLocalComputerName );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pgit != NULL )
    {
        if ( m_cookieGITServer != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITServer ) );
        }

        if ( m_cookieGITVerify != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITVerify ) );
        }

        if ( m_cookieGITCallbackTask != 0 )
        {
            THR( HrStopPolling() );
        } // if:

        m_pgit->Release();
    }

    TraceSysFreeString( m_bstrBindingString );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigurationConnection::~CConfigurationConnection


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConfigurationConnection * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConfigurationConnection ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConfigurationConnection, this, 0 );
    } // else if: IConfigurationConnection
    else if ( IsEqualIID( riidIn, IID_IClusCfgServer ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
    } // else if: IClusCfgServer
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_IClusCfgCapabilities ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
    } // else if: IClusCfgCapabilities
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
    } // else if: IClusCfgVerify
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigurationConnection::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigurationConnection::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigurationConnection::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CConfigurationConnection::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigurationConnection::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigurationConnection::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CConfigurationConnection::Release


//****************************************************************************
//
//  IConfigurationConnection
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::ConnectTo(
//      OBJECTCOOKIE    cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::ConnectTo(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[IConfigurationConnection]" );

    //
    //  VARIABLES
    //

    HRESULT hr;

    LCID    lcid;
    bool    fConnectingToNode;

    CLSID           clsidType;
    CLSID           clsidMinorId;
    const CLSID *   pclsidMajor;
    const CLSID *   pclsidMinor;

    IServiceProvider *  psp;
    IClusCfgCallback *  pcccb;  // don't free!
    ITaskManager *      ptm   = NULL;

    BSTR    bstrName = NULL;
    BSTR    bstrDescription = NULL;
    BSTR    bstrMappedHostname = NULL;
    BSTR    bstrDisplayName = NULL;
    size_t  idxTargetDomain = 0;

    IUnknown *                          punk = NULL;
    IObjectManager *                    pom = NULL;
    IStandardInfo *                     psi = NULL;
    IClusCfgInitialize *                pcci = NULL;
    IClusCfgServer *                    pccs = NULL;
    IClusCfgPollingCallbackInfo *       pccpcbi = NULL;
    IClusCfgVerify *                    pccv = NULL;
    IClusCfgNodeInfo *                  pccni = NULL;
    IClusCfgClusterInfo *               pccci = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::ConnectTo() Thread id %d", GetCurrentThreadId() );

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                reinterpret_cast< void ** >( &m_pgit )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        psp->Release();        //   release promptly
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Figure out our locale.
    //
    lcid = GetUserDefaultLCID();
    Assert( lcid != 0 );    // What do we do if it is zero?

    //
    //  Get the name of the node to contact.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo, cookieIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    psi = TraceInterface( L"ConfigConnection!IStandardInfo", IStandardInfo, psi, 1 );

    hr = THR( psi->GetName( &bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrName );

    hr = STHR( HrGetFQNDisplayName( bstrName, &bstrDisplayName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    LogMsg( L"[MT] The name to connect to is '%ws'.", bstrDisplayName );

    hr = THR( HrFindDomainInFQN( bstrName, &idxTargetDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psi->GetType( &clsidType ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Figure out where to logging information in the UI.
    //

    if ( IsEqualIID( clsidType, CLSID_NodeType ) )
    {
        fConnectingToNode = true;
        pclsidMajor = &TASKID_Major_Establish_Connection;
    }
    else if ( IsEqualIID( clsidType, CLSID_ClusterConfigurationType ) )
    {
        fConnectingToNode = false;
        pclsidMajor = &TASKID_Major_Checking_For_Existing_Cluster;
    }
    else
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  If the connection is to the local machine, then invoke the server INPROC
    //

    hr = STHR( HrIsLocalComputer( bstrName, SysStringLen( bstrName ) ) );

    if ( hr == S_OK )
    {
        LogMsg( L"[MT] Requesting a local connection to '%ws'.", bstrDisplayName );

        //
        //  Requesting connection to local computer.
        //

        hr = THR( HrCreateServerObject( NULL, &pccs, &pccv, &pcci ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccs, IID_IClusCfgServer, &m_cookieGITServer ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccv, IID_IClusCfgVerify, &m_cookieGITVerify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcccb = static_cast< IClusCfgCallback * >( this );

        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;

    }
    else
    {
        LogMsg( L"[MT] Requesting a remote connection to '%ws'.", bstrDisplayName );

        //
        //  Create a binding context for the remote server.
        //

        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;

        hr = STHR( HrFQNToBindingString( this, pclsidMajor, bstrName, &m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
            goto Cleanup;
        }

        //
        //  Report this connection request.
        //

        if ( fConnectingToNode )
        {
            //
            //  Add in the major task in case it hasn't been added yet.
            //

            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_REMOTE_CONNECTION_REQUESTS, &bstrDescription ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( SendStatusReport(
                          m_bstrLocalHostname
                        , TASKID_Major_Establish_Connection
                        , TASKID_Minor_Remote_Node_Connection_Requests
                        , 1
                        , 1
                        , 1
                        , S_OK
                        , bstrDescription
                        , NULL
                        , NULL
                        ) );

            //
            //  Add the specific minor task instance.
            //  Generate a new GUID for this report so that it won't wipe out
            //  any other reports like this.
            //

            hr = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            pclsidMajor = &TASKID_Minor_Remote_Node_Connection_Requests;
            pclsidMinor = &clsidMinorId;

        } // if: connecting to a node
        else
        {
            pclsidMajor = &TASKID_Major_Checking_For_Existing_Cluster;
            pclsidMinor = &TASKID_Minor_Requesting_Remote_Connection;

        } // else: connecting to a cluster

        hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_REQUESTING_REMOTE_CONNECTION, &bstrDescription, bstrDisplayName, bstrName + idxTargetDomain, m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( SendStatusReport(
                      m_bstrLocalHostname
                    , *pclsidMajor
                    , *pclsidMinor
                    , 1
                    , 1
                    , 1
                    , S_OK
                    , bstrDescription
                    , NULL
                    , NULL
                    ) );

        //
        //  Create the connection to the node.
        //

        hr = HrCreateServerObject( m_bstrBindingString, &pccs, &pccv, &pcci );
        if ( hr == HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed because the RPC is not available.", bstrDisplayName, m_bstrBindingString );
            //
            //  Make the error into a success and update the status.
            //
            hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
            goto Cleanup;
        }
        else if( hr == HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed because one or more classes are not registered.", bstrDisplayName, m_bstrBindingString );
            // Known error.  It must be a downlevel node.
            goto Cleanup;
        }
        else if ( FAILED( hr ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed. (hr=%#08x)", bstrDisplayName, m_bstrBindingString, hr );
            THR( hr );
            goto Cleanup;
        }

        //
        //  Save interfaces away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccv, IID_IClusCfgVerify, &m_cookieGITVerify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pccs->SetBindingString( m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccs, IID_IClusCfgServer, &m_cookieGITServer ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

// commented out by GalenB since this is investigative code.
//        hr = THR( HrSetSecurityBlanket( pccs ) );
//        if ( FAILED( hr ) )
//            goto Cleanup;

        //
        //  Since VerifyConnection below may send a status report to the UI then we
        //  need to start polling now so that they will indeed show up in the UI...
        //

        pcccb = NULL;   // we're polling.

        hr = THR( pccs->TypeSafeQI( IClusCfgPollingCallbackInfo, &pccpcbi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pccpcbi->SetPollingMode( true ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrStartPolling( cookieIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Verify our connection.
        //

        if ( fConnectingToNode )
        {
            hr = STHR( pccv->VerifyConnectionToNode( bstrName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = STHR( pccv->VerifyConnectionToCluster( bstrName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

/*
        3-SEPT-2002 GalenB

        Temporarily commented out until a better solution is available...

        if ( hr == S_FALSE )
        {
            hr = THR( HRESULT_FROM_WIN32( ERROR_CONNECTION_REFUSED ) );
            goto Cleanup;
        }
*/

    } // else: run server remotely

    //
    //  Initialize the server.
    //
    hr = pcci->Initialize( pcccb, lcid );
    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        LogMsg( L"[MT] The cluster service on node '%ws' is down.", bstrDisplayName );
    } // else if:
    else
    {
        THR( hr );
    }

    {
        //
        //  KB: 15-AUG-2001 jfranco bug 413056
        //
        //  Map the FQN back to a hostname and reset the standard info object's
        //  name to the hostname, so that later lookups in the object manager
        //  find the right instance.
        //

        //  Save result from server initialization to propagate back to caller.
        HRESULT hrServerInit = hr;
        hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( fConnectingToNode )
        {
            hr = THR( pccni->GetName( &bstrMappedHostname ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrMappedHostname );

        } //    Connecting to node
        else // Connecting to cluster
        {
            hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( pccci->GetName( &bstrMappedHostname ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrMappedHostname );
        }

        hr = THR( psi->SetName( bstrMappedHostname ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  Restore result from server initialization to propagate back to caller.
        hr = hrServerInit;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccpcbi != NULL )
    {
        pccpcbi->Release();
    } // if: pccpcbi
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom
    if ( ptm != NULL )
    {
        ptm->Release();
    } //if: ptm
    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi
    if ( pcci != NULL )
    {
        pcci->Release();
    } // if: pcci

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrMappedHostname );
    TraceSysFreeString( bstrDisplayName );

    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccv != NULL )
    {
        pccv->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }

    m_hrLastStatus = hr;

    HRETURN( hr );

} //*** CConfigurationConnection::ConnectTo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::ConnectToObject(
//      OBJECTCOOKIE    cookieIn,
//      REFIID          riidIn,
//      LPUNKNOWN *     ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::ConnectToObject(
    OBJECTCOOKIE    cookieIn,
    REFIID          riidIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IConfigurationConnection]" );

    HRESULT hr;
    CLSID   clsid;

    IServiceProvider *  psp;

    IUnknown *       punk = NULL;
    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::ConnectToObject() Thread id %d", GetCurrentThreadId() );

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Retrieve the type of the object.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    psi = TraceInterface( L"ConfigConnection!IStandardInfo", IStandardInfo, psi, 1 );

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( !IsEqualIID( clsid, CLSID_NodeType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Return the requested interface.
    //

    hr = THR( QueryInterface( riidIn, reinterpret_cast< void ** > ( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    HRETURN( hr );

} //*** CConfigurationConnection::ConnectToObject


//****************************************************************************
//
//  IClusCfgServer
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetClusterNodeInfo(
//      IClusCfgNodeInfo ** ppClusterNodeInfoOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT             hr;
    IClusCfgServer *    pccs = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::GetClusterNodeInfo() Thread id %d", GetCurrentThreadId() );

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetClusterNodeInfo( ppClusterNodeInfoOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetManagedResourcesEnum(
//      IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *        pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetManagedResourcesEnum( ppEnumManagedResourcesOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetManagedResourcesEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetNetworksEnum(
//      IEnumClusCfgNetworks ** ppEnumNetworksOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *    pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetNetworksEnum( ppEnumNetworksOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetNetworksEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::CommitChanges( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *    pccs = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::CommitChanges() Thread id %d", GetCurrentThreadId() );

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->CommitChanges(  ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::CommitChanges


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConfigurationConnection::GetBindingString(
//      BSTR * pbstrBindingOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc1( "[IClusCfgServer] pbstrBindingStringOut = %p", pbstrBindingStringOut );

    HRESULT hr = S_FALSE;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  If local server, then there isn't a binding context.
    if ( m_bstrBindingString == NULL )
    {
        Assert( hr == S_FALSE );
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} // CConfigurationConnection::GetBinding


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::SetBindingString(
//      LPCWSTR pcszBindingStringIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::SetBindingString(
    LPCWSTR pcszBindingStringIn
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::SetBindingString


//****************************************************************************
//
//  IClusCfgVerify
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyCredentials(
//      LPCWSTR pcszUserIn,
//      LPCWSTR pcszDomainIn,
//      LPCWSTR pcszPasswordIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyCredentials(
    LPCWSTR pcszUserIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccv->VerifyCredentials( pcszUserIn, pcszDomainIn, pcszPasswordIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyConnectionToCluster(
//      LPCWSTR pcszClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyConnectionToCluster(
    LPCWSTR pcszClusterNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszClusterNameIn = '%ws'", pcszClusterNameIn );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccv->VerifyConnectionToCluster( pcszClusterNameIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyConnectionToNode(
//      LPCWSTR pcszNodeNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyConnectionToNode(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszNodeNameIn = '%ws'", pcszNodeNameIn );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( pccv->VerifyConnectionToNode( pcszNodeNameIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyConnection


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::SendStatusReport(
//        LPCWSTR     pcszNodeNameIn
//      , CLSID       clsidTaskMajorIn
//      , CLSID       clsidTaskMinorIn
//      , ULONG       ulMinIn
//      , ULONG       ulMaxIn
//      , ULONG       ulCurrentIn
//      , HRESULT     hrStatusIn
//      , LPCWSTR     ocszDescriptionIn
//      , FILETIME *  pftTimeIn
//      , LPCWSTR     pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::SendStatusReport(
      LPCWSTR     pcszNodeNameIn
    , CLSID       clsidTaskMajorIn
    , CLSID       clsidTaskMinorIn
    , ULONG       ulMinIn
    , ULONG       ulMaxIn
    , ULONG       ulCurrentIn
    , HRESULT     hrStatusIn
    , LPCWSTR     ocszDescriptionIn
    , FILETIME *  pftTimeIn
    , LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

//        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                          pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrLocalHostname
                        , clsidTaskMajorIn
                        , clsidTaskMinorIn
                        , ulMinIn
                        , ulMaxIn
                        , ulCurrentIn
                        , hrStatusIn
                        , ocszDescriptionIn
                        , pftTimeIn
                        , pcszReferenceIn
                        ) );

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

}  //*** CConfigurationConnection::SendStatusReport


//****************************************************************************
//
//  IClusCfgCapabilities
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::CanNodeBeClustered( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgCapabilities]" );

    HRESULT hr;

    IClusCfgServer *        pccs = NULL;
    IClusCfgCapabilities *  pccc = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::CanNodeBeClustered() Thread id %d", GetCurrentThreadId() );

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->TypeSafeQI( IClusCfgCapabilities, &pccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( pccc->CanNodeBeClustered(  ) );

Cleanup:

    if ( pccc != NULL )
    {
        pccc->Release();
    }

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::CanNodeBeClustered

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrStartPolling(
//      OBJECTCOOKIE    cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrStartPolling(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IServiceProvider *      psp   = NULL;
    IUnknown *              punk  = NULL;
    ITaskManager *          ptm   = NULL;
    ITaskPollingCallback *  ptpcb = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::HrStartPolling() Thread id %d", GetCurrentThreadId() );

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        psp->Release();        //   release promptly
        goto Cleanup;
    }

    //
    //  Create the task object.
    //

    hr = THR( ptm->CreateTask( TASK_PollingCallback, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( ITaskPollingCallback, &ptpcb ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
    //

    hr = THR( m_pgit->RegisterInterfaceInGlobal( ptpcb, IID_ITaskPollingCallback, &m_cookieGITCallbackTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptpcb->SetServerInfo( m_cookieGITServer, cookieIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptm->SubmitTask( ptpcb ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    if ( ptm != NULL )
    {
        ptm->Release();
    } // if:

    if ( ptpcb != NULL )
    {
        ptpcb->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrStartPolling

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrStopPolling( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrStopPolling( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    ITaskPollingCallback *  ptpcb = NULL;

    TraceFlow1( "[MT] CConfigurationConnection::HrStopPolling() Thread id %d", GetCurrentThreadId() );

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITCallbackTask, TypeSafeParams( ITaskPollingCallback, &ptpcb ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptpcb->StopTask() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITCallbackTask ) );

Cleanup:

    if ( ptpcb != NULL )
    {
        ptpcb->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrStopPolling

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrSetSecurityBlanket( IClusCfgServer * pccsIn )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrSetSecurityBlanket( IClusCfgServer * pccsIn )
{
    TraceFunc( "" );
    Assert( pccsIn != NULL );

    HRESULT             hr = S_FALSE;
    IClientSecurity *   pCliSec;

    hr = THR( pccsIn->TypeSafeQI( IClientSecurity, &pCliSec ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pCliSec->SetBlanket(
                        pccsIn,
                        RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE,
                        NULL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_NONE
                        ) );

        pCliSec->Release();

        if ( FAILED( hr ) )
        {
            LogMsg( L"[MT] Failed to set the security blanket on the server object. (hr = %#08x)", hr );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrSetSecurityBlanket

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConfigurationConnection::HrIsLocalComputer(
//        LPCWSTR pcszNameIn
//      , size_t cchNameIn
//      )
//
//  Parameters:
//      pcszNameIn
//          FQDN or Hostname name to match against local computer name.
//
//      cchNameIn
//          Length, in characters, of pcszNameIn, NOT including terminating null.
//
//  Return Values:
//      S_OK
//          Succeeded. Name matches local computer name.
//
//      S_FALSE
//          Succeeded. Name does not match local computer name.
//
//      E_INVALIDARG
//          pcszNameIn was NULL.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrIsLocalComputer(
      LPCWSTR   pcszNameIn
    , size_t    cchNameIn
)
{
    TraceFunc1( "pcszNameIn = '%s'", pcszNameIn );

    HRESULT hr = S_OK;  // assume success!

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( NStringCchCompareNoCase( pcszNameIn, cchNameIn + 1, m_bstrLocalComputerName, SysStringLen( m_bstrLocalComputerName ) + 1 ) == 0 )
    {
        // Found a match.
        goto Cleanup;
    }

    if ( NStringCchCompareNoCase( pcszNameIn, cchNameIn + 1, m_bstrLocalHostname, SysStringLen( m_bstrLocalHostname ) + 1 ) == 0 )
    {
        // Found a match
        goto Cleanup;
    }

    if ( ( pcszNameIn[ 0 ] == L'.' ) && ( pcszNameIn[ 1 ] == L'\0' ) )
    {
        goto Cleanup;
    }

    hr = S_FALSE;   //  didn't match

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::HrIsLocalComputer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connectionmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionMgr.h
//
//  Description:
//      Connection Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConnectionManager
class CConnectionManager
    : public IConnectionManager
{
private:
    // IUnknown
    LONG        m_cRef;

private: // Methods
    CConnectionManager( void );
    ~CConnectionManager( void );
    STDMETHOD( HrInit )( void );


    HRESULT
        HrGetNodeConnection(
            OBJECTCOOKIE                cookieIn,
            IConfigurationConnection ** ppccOut
            );
    HRESULT
        HrGetClusterConnection(
            OBJECTCOOKIE                cookieIn,
            IConfigurationConnection ** ppccOut
            );
    HRESULT
        HrStoreConnection(
            IConnectionInfo *           pciIn,
            IConfigurationConnection *  pccIn,
            IUnknown **                 ppunkOut
            );

    HRESULT
        HrGetConfigurationConnection(
            OBJECTCOOKIE        cookieIn,
            IConnectionInfo *   pciIn,
            IUnknown **         ppunkOut
            );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConnectionManager
    STDMETHOD( GetConnectionToObject )( OBJECTCOOKIE  cookieIn,
                                        IUnknown **   ppunkOut
                                        );

}; //*** class CConnectionManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connectionmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ConnectionManager.cpp
//
//  Description:
//      Connection Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ConnectionManager.h"

DEFINE_THISCLASS("CConnectionManager")
#define THISCLASS CConnectionManager

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CConnectionManager *    pcm = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcm = new CConnectionManager();
    if ( pcm == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcm->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcm->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcm != NULL )
    {
        pcm->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::S_HrCreateInstance;

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager::CConnectionManager
//
//////////////////////////////////////////////////////////////////////////////
CConnectionManager::CConnectionManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionManager::CConnectionManager

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionManager::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::HrInit( void )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 1 );

    HRETURN( S_OK );

} //*** CConnectionManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager::~CConnectionManager
//
//////////////////////////////////////////////////////////////////////////////
CConnectionManager::~CConnectionManager( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionManager::~CConnectionManager


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConnectionManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConnectionManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConnectionManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConnectionManager, this, 0 );
    } // else if: IConnectionManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConnectionManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CConnectionManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CConnectionManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CConnectionManager::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CConnectionManager::Release

// ************************************************************************
//
// IConnectionManager
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionManager::GetConnectionToObject(
//      OBJECTCOOKIE    cookieIn,
//      IUnknown **     ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::GetConnectionToObject(
    OBJECTCOOKIE    cookieIn,
    IUnknown **     ppunkOut
    )
{
    TraceFunc1( "[IConnectionManager] cookieIn = %#x", cookieIn );

    HRESULT hr;
    CLSID   clsid;

    OBJECTCOOKIE        cookieParent;

    IServiceProvider *  psp;

    BSTR                       bstrName  = NULL;
    IUnknown *                 punk      = NULL;
    IObjectManager *           pom       = NULL;
    IConnectionInfo *          pci       = NULL;
    IConnectionInfo *          pciParent = NULL;
    IStandardInfo *            psi       = NULL;
    IConfigurationConnection * pcc       = NULL;

    //
    //  Validate parameters
    //
    if ( cookieIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Collect the managers needed to complete this method.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    psp->Release();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Check to see if we already have a connection cached.
    //

    //
    //  Get the connection info for this cookie.
    //

    hr = THR( pom->GetObject( DFGUID_ConnectionInfoFormat,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IConnectionInfo, &pci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pci = TraceInterface( L"ConnectionManager!IConnectionInfo", IConnectionInfo, pci, 1 );

    punk->Release();
    punk = NULL;

    //
    //  See if there is a current connection.
    //

    hr = STHR( pci->GetConnection( &pcc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Check to see if the parent has a connection.
        //

        //
        //  Get the standard info for this cookie.
        //

        hr = THR( pom->GetObject( DFGUID_StandardInfo,
                                  cookieIn,
                                  &punk
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        psi = TraceInterface( L"ConnectionManager!IStandardInfo", IStandardInfo, psi, 1 );

        punk->Release();
        punk = NULL;

        hr = STHR( psi->GetType( &clsid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( !IsEqualIID( clsid, CLSID_NodeType )
          && !IsEqualIID( clsid, CLSID_ClusterConfigurationType )
           )
        {
            hr = STHR( psi->GetParent( &cookieParent ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //  Release it.
            psi->Release();
            psi = NULL;

            //
            //  If there is a parent, follow it.
            //

            if ( hr == S_OK )
            {
                //
                //  Get the connection info for this cookie.
                //

                hr = THR( pom->GetObject( DFGUID_ConnectionInfoFormat,
                                          cookieParent,
                                          &punk
                                          ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                hr = THR( punk->TypeSafeQI( IConnectionInfo, &pciParent ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                pciParent = TraceInterface( L"ConnectionManager!IConnectionInfo", IConnectionInfo, pciParent, 1 );

                punk->Release();
                punk = NULL;

                //
                //  See if there is a current connection.
                //

                hr = STHR( pciParent->GetConnection( &pcc ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                //
                // TODO:    gpease  08-MAR-2000
                //          Find a better error code.
                //
                //if ( hr == S_FALSE )
                //    goto InvalidArg;

            } // if: parent found
        } // if: not a node or cluster
        else
        {
            psi->Release();
            psi = NULL;
        }

    } // if: no established connection

    //
    //  Did we have to contact the parent to get to the child?
    //

    if ( pcc != NULL )
    {
        //
        //  Reuse the existing connection.
        //
        hr = THR( pcc->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
        goto Cleanup;
    }

    //
    //  Need to build a connection to the object because the object doesn't
    //  have a parent and it doesn't currently have a connection.
    //

    //
    //  Find out what type of object it is.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    psi = TraceInterface( L"ConnectionManager!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create the appropriate connection for that type of object.
    //

    if ( IsEqualIID( clsid, CLSID_NodeType ) )
    {
        hr = THRE( HrGetConfigurationConnection( cookieIn, pci, ppunkOut ), HR_S_RPC_S_CLUSTER_NODE_DOWN );
    } // if: node
    else if ( IsEqualIID( clsid, CLSID_ClusterConfigurationType ) )
    {
        hr = THRE( HrGetConfigurationConnection( cookieIn, pci, ppunkOut ), HR_S_RPC_S_SERVER_UNAVAILABLE );
    } // if: cluster
    else
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND ) );
        goto Cleanup;

    } // else: no connection support

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrName );

    if ( pci != NULL )
    {
        pci->Release();
    } // if: pci

    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    if ( pciParent != NULL )
    {
        pciParent->Release();
    } // if: pciParent

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if: pcc

    HRETURN( hr );

} //*** CConnectionManager::GetConnectionToObject

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetConfigurationConnection(
//      OBJECTCOOKIE        cookieIn,
//      IConnectionInfo *   pciIn,
//      IUnknown **         ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetConfigurationConnection(
    OBJECTCOOKIE        cookieIn,
    IConnectionInfo *   pciIn,
    IUnknown **         ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    IConfigurationConnection * pccNode      = NULL;
    IConfigurationConnection * pccCluster   = NULL;
    IConfigurationConnection * pcc          = NULL;

    // Try and connect to the node using the new server.
    hr = HrGetNodeConnection( cookieIn, &pccNode );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        Assert( *ppunkOut == NULL );
        goto Cleanup;
    } // if:

    // Try and connect to the node using the W2K object.
    if ( hr == HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ) )
    {
        HRESULT hrCluster = THR( HrGetClusterConnection( cookieIn, &pccCluster ) );

        if ( hrCluster == S_OK )
        {
            Assert( pccCluster != NULL );
            Assert( pcc == NULL );

            pcc = pccCluster;
            pccCluster = NULL;

            hr = hrCluster;
        } // if:
    } // if: failed to get a node connection

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    if ( pcc == NULL )
    {
        Assert( pccNode != NULL );
        pcc = pccNode;
        pccNode = NULL;
    }

    //
    //  VERY IMPORTANT: Store the connection and retrieve the IUnknown pointer
    //  only if the result is S_OK.
    //

    if ( hr == S_OK )
    {
        THR( HrStoreConnection( pciIn, pcc, ppunkOut ) );
    }

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    if ( pccNode != NULL )
    {
        pccNode->Release();
    }

    if ( pccCluster != NULL )
    {
        pccCluster->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetConfigurationConnection

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetNodeConnection(
//      OBJECTCOOKIE                cookieIn,
//      IConfigurationConnection ** ppccOut
//      )
//
//  This connection may be valid even if the ConnectTo call fails.
//  -That means that there is no cluster installed on the target node.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetNodeConnection(
    OBJECTCOOKIE                cookieIn,
    IConfigurationConnection ** ppccOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr;
    IConfigurationConnection *  pcc = NULL;

    // Check the pointers in.
    Assert( ppccOut != NULL );
    Assert( *ppccOut == NULL );

    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ConfigurationConnection
                    , NULL
                    , CLSCTX_SERVER
                    , TypeSafeParams( IConfigurationConnection, &pcc )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Don't wrap - we want to handle some of the failures.
    hr = pcc->ConnectTo( cookieIn );

    switch( hr )
    {
        // Known valid return codes.
        case HR_S_RPC_S_SERVER_UNAVAILABLE:
            break;

        // Known error codes.
        case HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ):
            // This means the ClusCfg server is not available.
            goto Cleanup;

        case HR_S_RPC_S_CLUSTER_NODE_DOWN:
            // This means the service is not running on that node.
            Assert( *ppccOut == NULL );
            goto Cleanup;

        default:
            if( FAILED( hr ) )
            {
                THR( hr );
                goto Cleanup;
            }
    } // switch:

    // Return the connection.
    *ppccOut = pcc;
    pcc = NULL;

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetNodeConnection

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetClusterConnection(
//      OBJECTCOOKIE                cookieIn,
//      IConfigurationConnection ** ppccOut
//      )
//
//
//  This connection must succeede completely to return a valid object.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetClusterConnection(
    OBJECTCOOKIE                cookieIn,
    IConfigurationConnection ** ppccOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr;
    IConfigurationConnection *  pcc = NULL;

    // Check the pointers in.
    Assert( ppccOut != NULL );
    Assert( *ppccOut == NULL );

    //
    // Should be a downlevel cluster.
    //
    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ConfigClusApi
                    , NULL
                    , CLSCTX_SERVER
                    , TypeSafeParams( IConfigurationConnection, &pcc )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Don't wrap - we want to handle some of the failures.
    hr = pcc->ConnectTo( cookieIn );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        goto Cleanup;
    } // if:

    // Handle the expected error messages.

    // If the cluster service is not running, then the endpoint
    // is unavailable and we cannot connect to it.
    if ( hr == HRESULT_FROM_WIN32( EPT_S_NOT_REGISTERED ) )
    {
        goto Cleanup;
    }

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // if:

    // Return the connection.
    *ppccOut = pcc;
    pcc = NULL;

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetClusterConnection

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrStoreConnection(
//      IConnectionInfo *           pciIn,
//      IConfigurationConnection *  pccIn,
//      IUnknown **                 ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrStoreConnection(
    IConnectionInfo *           pciIn,
    IConfigurationConnection *  pccIn,
    IUnknown **                 ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    //
    //  Save it away to be used next time.
    //
    //  TODO:   gpease  08-MAR-2000
    //          If we failed to save away the connection, does
    //          the caller need to know this? I don't think so.
    //
    THR( pciIn->SetConnection( pccIn ) );

    hr = THR( pccIn->QueryInterface( IID_IUnknown,
                                   reinterpret_cast< void ** >( ppunkOut )
                                   ) );

    HRETURN( hr );

} //*** CConnectionManager::HrStoreConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connpointenum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnPointEnum.cpp
//
//  Description:
//      Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ConnPointEnum.h"

DEFINE_THISCLASS("CConnPointEnum")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CConnPointEnum *    pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcc = new CConnPointEnum();
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConnPointEnum::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::CConnPointEnum
//
//--
//////////////////////////////////////////////////////////////////////////////
CConnPointEnum::CConnPointEnum( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnPointEnum::CConnPointEnum

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::HrInit
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::HrInit( void )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IConnectionPoint
    Assert( m_pCPList == NULL );

    HRETURN( S_OK );

} //*** CConnPointEnum::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConnPointEnum::~CConnPointEnum
//
//--
//////////////////////////////////////////////////////////////////////////////
CConnPointEnum::~CConnPointEnum( void )
{
    TraceFunc( "" );

    while ( m_pCPList != NULL )
    {
        SCPEntry * pentry;

        pentry = m_pCPList;
        m_pCPList = m_pCPList->pNext;

        if ( pentry->punk != NULL )
        {
            pentry->punk->Release();
        }

        TraceFree( pentry );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnPointEnum::~CConnPointEnum


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConnPointEnum::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumConnectionPoints * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumConnectionPoints ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumConnectionPoints, this, 0 );
    } // else if: IEnumConnectionPoints
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConnPointEnum::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConnPointEnum::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnPointEnum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CConnPointEnum::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConnPointEnum::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnPointEnum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CConnPointEnum::Release


//****************************************************************************
//
//  IEnumConnectionPoints
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::Next(
//      ULONG               cConnectionsIn,
//      LPCONNECTIONPOINT * ppCPOut,
//      ULONG *             pcFetchedOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::Next(
    ULONG               cConnectionsIn,
    LPCONNECTIONPOINT * ppCPOut,
    ULONG *             pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_FALSE;
    ULONG   celt;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    }

    if ( m_pIter != NULL )
    {
        for( celt = 0; celt < cConnectionsIn; )
        {
            hr = THR( m_pIter->punk->TypeSafeQI( IConnectionPoint, &ppCPOut[ celt ] ) );
            if ( FAILED( hr ) )
                goto Error;

            ppCPOut[ celt ] = TraceInterface( L"ConnPointEnum!IConnectionPoint", IConnectionPoint, ppCPOut[ celt ], 1 );

            celt ++;
            m_pIter = m_pIter->pNext;
            if( m_pIter == NULL )
                break;
        }
    }
    else
    {
        celt = 0;
    }

    if ( celt != cConnectionsIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = celt;
    }

Cleanup:
    HRETURN( hr );

Error:
    while ( celt > 0 )
    {
        celt --;
        ppCPOut[ celt ]->Release();
    }
    goto Cleanup;

} //*** CConnPointEnum::Next

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::Skip(
//      ULONG cConnectionsIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::Skip(
    ULONG cConnectionsIn
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_FALSE;
    ULONG   celt;

    if ( m_pIter != NULL )
    {
        for ( celt = 0; celt < cConnectionsIn; celt ++ )
        {
            m_pIter = m_pIter->pNext;

            if ( m_pIter == NULL )
                break;
        }
    }

    if ( m_pIter == NULL )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    HRETURN( hr );

} //*** CConnPointEnum::Skip

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::Reset( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_pIter = m_pCPList;

    HRETURN( hr );

} //*** CConnPointEnum::Reset

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::Clone(
//      IEnumConnectionPoints ** ppEnum
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::Clone(
    IEnumConnectionPoints ** ppEnum
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr;

    CConnPointEnum * pcpenum = new CConnPointEnum();
    if ( pcpenum == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcpenum->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcpenum->HrCopy( this ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcpenum->TypeSafeQI( IEnumConnectionPoints, ppEnum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *ppEnum = TraceInterface( L"ConnPointEnum!IEnumConnectionPoints", IEnumConnectionPoints, *ppEnum, 1 );

    //
    //  Release our ref and make sure we don't free it on the way out.
    //

    pcpenum->Release();
    pcpenum = NULL;

Cleanup:

    if ( pcpenum != NULL )
    {
        delete pcpenum;
    }

    HRETURN( hr );

} //*** CConnPointEnum::Clone


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::HrCopy(
//      CConnPointEnum * pECPIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::HrCopy(
    CConnPointEnum * pECPIn
    )
{
    TraceFunc1( "pECPIn = %p", pECPIn );

    HRESULT hr = S_OK;

    SCPEntry * pentry;

    Assert( m_pCPList == NULL );

    for( pentry = pECPIn->m_pCPList; pentry != NULL; pentry = pentry->pNext )
    {
        SCPEntry * pentryNew = (SCPEntry *) TraceAlloc( 0, sizeof(SCPEntry) );
        if ( pentryNew == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        pentryNew->iid = pentry->iid;
        hr = THR( pentry->punk->TypeSafeQI( IUnknown, &pentryNew->punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pentryNew->punk = TraceInterface( L"ConnPointEnum!IUnknown", IUnknown, pentryNew->punk, 1 );

        pentryNew->pNext = m_pCPList;
        m_pCPList = pentryNew;
    }

    m_pIter = m_pCPList;

Cleanup:

    HRETURN( hr );

} //*** CConnPointEnum::CConnPointEnum

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::HrAddConnection(
//      REFIID riidIn,
//      IUnknown * punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::HrAddConnection(
      REFIID        riidIn
    , IUnknown *    punkIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    SCPEntry *  pentry;

    //
    //  Check to see if the interface is already registered.
    //

    for ( pentry = m_pCPList; pentry != NULL; pentry = pentry->pNext )
    {
        if ( pentry->iid == riidIn )
        {
            hr = THR( CO_E_OBJISREG );
            goto Cleanup;
        }
    } // for: pentry

    //
    //  Not registered; add it.
    //

    pentry = (SCPEntry *) TraceAlloc( 0, sizeof( SCPEntry ) );
    if ( pentry == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( punkIn->TypeSafeQI( IUnknown, &pentry->punk ) );
    Assert( hr == S_OK );
    if ( FAILED( hr ) )
    {
        TraceFree( pentry );
        goto Cleanup;
    } // if:

    pentry->punk = TraceInterface( L"ConnPointEnum!IUnknown", IUnknown, pentry->punk, 1 );

    pentry->iid   = riidIn;
    pentry->pNext = m_pCPList;
    m_pCPList     = pentry;
    m_pIter       = m_pCPList;

    LogMsg( L"[CConnPointEnum::HrAddConnection] punk %#08x added to the connection point enumerator. (hr=%#08x)", punkIn, hr );

Cleanup:
    HRETURN( hr );

} //*** CConnPointEnum::HrAddConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\cpinotifyui.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CPINotifyUI.cpp
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CPINotifyUI.h"
#include "EnumCPINotifyUI.h"

DEFINE_THISCLASS("CCPINotifyUI")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCPINotifyUI::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCPINotifyUI::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CCPINotifyUI *  pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcc = new CCPINotifyUI();
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CCPINotifyUI::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPINotifyUI::CCPINotifyUI
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCPINotifyUI::CCPINotifyUI( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CCPINotifyUI::CCPINotifyUI

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPINotifyUI::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IConnectionPoint
    Assert( m_penum == NULL );

    m_penum = new CEnumCPINotifyUI();
    if ( m_penum == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( m_penum->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // INotifyUI

Cleanup:

    HRETURN( hr );

} //*** CCPINotifyUI::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CCPINotifyUI::~CCPINotifyUI
//
//////////////////////////////////////////////////////////////////////////////
CCPINotifyUI::~CCPINotifyUI( void )
{
    TraceFunc( "" );

    if ( m_penum != NULL )
    {
        m_penum->Release();
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CCPINotifyUI::~CCPINotifyUI


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPINotifyUI::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConnectionPoint * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConnectionPoint ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConnectionPoint, this, 0 );
    } // else if: IConnectionPoint
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCPINotifyUI::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPINotifyUI::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCPINotifyUI::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCPINotifyUI::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPINotifyUI::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCPINotifyUI::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CCPINotifyUI::Release


// ************************************************************************
//
// IConnectionPoint
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::GetConnectionInterface(
//      IID * pIIDOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::GetConnectionInterface(
    IID * pIIDOut
    )
{
    TraceFunc( "[IConnectionPoint] pIIDOut" );

    HRESULT hr = S_OK;

    if ( pIIDOut == NULL )
        goto InvalidPointer;

    *pIIDOut = IID_INotifyUI;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CCPINotifyUI::GetConnectionInterface

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::GetConnectionPointContainer(
//      IConnectionPointContainer * * ppcpcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::GetConnectionPointContainer(
    IConnectionPointContainer * * ppcpcOut
    )
{
    TraceFunc( "[IConnectionPoint] ppcpcOut" );

    HRESULT hr;

    IServiceProvider * psp = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               ppcpcOut
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }

    HRETURN( hr );

} //*** CCPINotifyUI::GetConnectionPointContainer

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::Advise(
//      IUnknown * pUnkSinkIn,
//      DWORD * pdwCookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::Advise(
    IUnknown * pUnkSinkIn,
    DWORD * pdwCookieOut
    )
{
    TraceFunc( "[IConnectionPoint]" );

    HRESULT hr;

    if ( pdwCookieOut == NULL )
        goto InvalidPointer;

    if ( pUnkSinkIn == NULL )
        goto InvalidArg;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrAddConnection( pUnkSinkIn, pdwCookieOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CCPINotifyUI::Advise

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::Unadvise(
//      DWORD dwCookieIn
//      )
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::Unadvise(
    DWORD dwCookieIn
    )
{
    TraceFunc1( "[IConncetionPoint] dwCookieIn = %#x", dwCookieIn );

    HRESULT hr;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrRemoveConnection( dwCookieIn ) );

    HRETURN( hr );

} //*** CCPINotifyUI::Unadvise

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::EnumConnections(
//  IEnumConnections * * ppEnumOut
//  )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::EnumConnections(
    IEnumConnections * * ppEnumOut
    )
{
    TraceFunc( "[IConnectionPoint] ppEnumOut" );

    HRESULT hr;

    if ( ppEnumOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( m_penum->Clone( ppEnumOut ) );

Cleanup:
    HRETURN( hr );

} //*** CCPINotifyUI::EnumConnections


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPINotifyUI::ObjectChanged(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::ObjectChanged(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc1( "[INotifyUI] cookieIn = %ld", cookieIn );

    CONNECTDATA         cd = { NULL };
    HRESULT             hr;
    INotifyUI *         pnui;
    IEnumConnections *  pec = NULL;

    hr = THR( m_penum->Clone( &pec ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[INotifyUI] Error cloning connection point enum. Cookie %ld. (hr=%#08x)", cookieIn, hr );
        goto Cleanup;
    } // if:

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[INotifyUI] Error reseting connection point enum. Cookie %ld. (hr=%#08x)", cookieIn, hr );
        goto Cleanup;
    } // if:

    for ( ;; )
    {
        if ( cd.pUnk != NULL )
        {
            cd.pUnk->Release();
            cd.pUnk = NULL;
        } // if

        hr = STHR( pec->Next( 1, &cd, NULL ) );
        if ( FAILED( hr ) )
        {
            LogMsg( L"[INotifyUI] Error calling Next() on the enumerator. Cookie %ld. (hr=%#08x)", cookieIn, hr );
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break; // exit condition
        } // if:

        hr = THR( cd.pUnk->TypeSafeQI( INotifyUI, &pnui ) );
        if ( FAILED( hr ) )
        {
            //
            //  Don't stop on error.
            //

            LogMsg( L"[INotifyUI] Error QI'ing for the INotifyUI interface. Cookie %ld. (hr=%#08x)", cookieIn, hr );
            continue;
        } // if:

        hr = THR( pnui->ObjectChanged( cookieIn ) );
        if ( FAILED( hr ) )
        {
            LogMsg( L"[INotifyUI] Error delivery object changed message for cookie %ld to connection point. (hr=%#08x)", cookieIn, hr );
        } // if:

        //
        //  Don't stop on error.
        //

        pnui->Release();
    } // for:

    hr = S_OK;

Cleanup:

    if ( cd.pUnk != NULL )
    {
        cd.pUnk->Release();
    } // if:

    if ( pec != NULL )
    {
        pec->Release();
    } // if:

    HRETURN( hr );

} //*** CCPINotifyUI::ObjectChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\cpicluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CPIClusCfgCallback.h
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumCPICCCB;

// CCPIClusCfgCallback
class CCPIClusCfgCallback
    : public IConnectionPoint
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference count

    // IConnectionPoint
    CEnumCPICCCB *      m_penum;    //  Connection enumerator

    // INotifyUI

private: // Methods
    CCPIClusCfgCallback( void );
    ~CCPIClusCfgCallback( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IConnectionPoint
    STDMETHOD( GetConnectionInterface )( IID * pIIDOut );
    STDMETHOD( GetConnectionPointContainer )( IConnectionPointContainer ** ppcpcOut );
    STDMETHOD( Advise )( IUnknown * pUnkSinkIn, DWORD * pdwCookieOut );
    STDMETHOD( Unadvise )( DWORD dwCookieIn );
    STDMETHOD( EnumConnections )( IEnumConnections ** ppEnumOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
          LPCWSTR    pcszNodeNameIn
        , CLSID      clsidTaskMajorIn
        , CLSID      clsidTaskMinorIn
        , ULONG      ulMinIn
        , ULONG      ulMaxIn
        , ULONG      ulCurrentIn
        , HRESULT    hrStatusIn
        , LPCWSTR    pcszDescriptionIn
        , FILETIME * pftTimeIn
        , LPCWSTR    pcszReferenceIn
        );

}; //*** class CCPIClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\connpointenum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConnPointEnum.h
//
//  Description:
//      Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CNotificationManager;

//  Link list of connection points
typedef struct _SCPEntry
{
    struct _SCPEntry *  pNext;  //  Next item in list
    CLSID               iid;    //  Interface ID
    IUnknown *          punk;   //  Punk to object
} SCPEntry;

// ConnPointEnum
class CConnPointEnum
    : public IEnumConnectionPoints
{
friend class CNotificationManager;
private:
    // IUnknown
    LONG            m_cRef;

    // IEnumConnectionPoints
    SCPEntry *      m_pCPList;      //  List of connection points
    SCPEntry *      m_pIter;        //  Iter - don't free

private: // Methods
    CConnPointEnum( void );
    ~CConnPointEnum( void );
    STDMETHOD( HrInit )( void );

    HRESULT HrCopy( CConnPointEnum * pECPIn );
    HRESULT HrAddConnection( REFIID riidIn, IUnknown * punkIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumConnectionPoints
    STDMETHOD( Next )( ULONG cConnections, LPCONNECTIONPOINT * ppCP, ULONG * pcFetched );
    STDMETHOD( Skip )( ULONG cConnections );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnectionPoints ** ppEnum );

}; //*** class CConnPointEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\cpinotifyui.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CPINotifyUI.h
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumCPINotifyUI;

// CCPINotifyUI
class CCPINotifyUI
    : public IConnectionPoint
    , public INotifyUI
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference count

    // IConnectionPoint
    CEnumCPINotifyUI *  m_penum;    //  Connection enumerator

    // INotifyUI

private: // Methods
    CCPINotifyUI( void );
    ~CCPINotifyUI( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IConnectionPoint
    STDMETHOD( GetConnectionInterface )( IID * pIIDOut );
    STDMETHOD( GetConnectionPointContainer )( IConnectionPointContainer ** ppcpcOut );
    STDMETHOD( Advise )( IUnknown * pUnkSinkIn, DWORD * pdwCookieOut );
    STDMETHOD( Unadvise )( DWORD dwCookieIn );
    STDMETHOD( EnumConnections )( IEnumConnections ** ppEnumOut );

    // INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; //*** class CCPINotifyUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcookies.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumCookies.cpp
//
//  Description:
//      CEnumCookies implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    08-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EnumCookies.h"
#include "ObjectManager.h"

DEFINE_THISCLASS("CEnumCookies")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCookies::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCookies::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CEnumCookies *  pec = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pec = new CEnumCookies;
    if ( pec == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pec->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pec->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CEnumCookies::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCookies::CEnumCookies
//
//////////////////////////////////////////////////////////////////////////////
CEnumCookies::CEnumCookies( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCookies::CEnumCookies

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCookies::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumCookies
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );
    Assert( m_cCookies == 0 );

    HRETURN( hr );

} //*** CEnumCookies::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCookies::~CEnumCookies
//
//////////////////////////////////////////////////////////////////////////////
CEnumCookies::~CEnumCookies( void )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        TraceFree( m_pList );

    } // if: m_pList

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCookies::~CEnumCookies


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCookies::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumCookies * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumCookies ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumCookies, this, 0 );
    } // else if: IEnumCookies
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumCookies::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCookies::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCookies::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumCookies::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCookies::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCookies::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumCookies::Release


//****************************************************************************
//
//  IEnumCookies
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Next( 
//      ULONG celt, 
//      IClusCfgNetworkInfo * rgNetworksOut[],
//      ULONG * pceltFetchedOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Next( 
    ULONG celt, 
    OBJECTCOOKIE rgcookieOut[], 
    ULONG * pceltFetchedOut 
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;
    ULONG   cIter = 0;

    //
    //  Check parameters
    //
    if ( rgcookieOut == NULL )
        goto InvalidPointer;

    //
    //  Loop and copy the cookies.
    //
    while ( m_cIter < m_cCookies && cIter < celt )
    {
        rgcookieOut[ cIter++ ] = m_pList[ m_cIter++ ];
    } // for each remaining cookie, up to requested count (at most).

    Assert( hr == S_OK );

    if ( cIter != celt )
    {
        hr = S_FALSE;
    }

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = cIter;
    }

Cleanup:    
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CEnumCookies::Next


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Skip( 
//      ULONG celt 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Skip( 
    ULONG celt 
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter >= m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CEnumCookies::Skip


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Reset( void )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumCookies::Reset


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Clone( 
//      IEnumCookies ** ppenumOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Clone( 
    IEnumCookies ** ppenumOut 
    )
{
    TraceFunc( "[IEnumCookies]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumCookies::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCookies::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cCookies;

Cleanup:
    HRETURN( hr );

} //*** CEnumCookies::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\cpicluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CPIClusCfgCallback.cpp
//
//  Description:
//      IClusCfgCallback Connection Point implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CPIClusCfgCallback.h"
#include "EnumCPICCCB.h"
#include <ClusterUtils.h>

DEFINE_THISCLASS("CCPIClusCfgCallback")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::S_HrCreateInstance
//
//  Description:
//      Create an object of this type.
//
//  Arguments:
//      ppunkOut    - IUnknown pointer for this interface.
//
//  Return Values:
//      S_OK            - Success.
//      E_POINTER       - A required output argument was not specified.
//      E_OUTOFMEMORY   - Memory could not be allocated.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCPIClusCfgCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CCPIClusCfgCallback *   pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pcc = new CCPIClusCfgCallback();
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CCPIClusCfgCallback::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::CCPIClusCfgCallback
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCPIClusCfgCallback::CCPIClusCfgCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CCPIClusCfgCallback::CCPIClusCfgCallback

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::HrInit
//
//  Description:
//      Initialize the object after it has been constructed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IConnectionPoint
    Assert( m_penum == NULL );

    m_penum = new CEnumCPICCCB();
    if ( m_penum == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( m_penum->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // IClusCfgCallback

Cleanup:

    HRETURN( hr );

} //*** CCPIClusCfgCallback::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::~CCPIClusCfgCallback
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCPIClusCfgCallback::~CCPIClusCfgCallback( void )
{
    TraceFunc( "" );

    if ( m_penum != NULL )
    {
        m_penum->Release();
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CCPIClusCfgCallback::~CCPIClusCfgCallback


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConnectionPoint * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConnectionPoint ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConnectionPoint, this, 0 );
    } // else if: IConnectionPoint
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCPIClusCfgCallback::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::AddRef
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCPIClusCfgCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCPIClusCfgCallback::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCPIClusCfgCallback::Release
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//
//--
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCPIClusCfgCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CCPIClusCfgCallback::Release


//****************************************************************************
//
// IConnectionPoint
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IConnectionPoint]
//  CCPIClusCfgCallback::GetConnectionInterface
//
//  Description:
//      Get the interface ID for the connection point.
//
//  Arguments:
//      pIIDOut     - Interface ID that is returned.
//
//  Return Values:
//      S_OK    - Success.
//      E_POINTER   - A required output argument was not specified.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::GetConnectionInterface(
    IID * pIIDOut
    )
{
    TraceFunc( "[IConnectionPoint] pIIDOut" );

    HRESULT hr = S_OK;

    if ( pIIDOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pIIDOut = IID_IClusCfgCallback;

Cleanup:

    HRETURN( hr );

} //*** CCPIClusCfgCallback::GetConnectionInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IConnectionPoint]
//  CCPIClusCfgCallback::GetConnectionPointContainer
//
//  Description:
//      Get the connection point container.
//
//  Arguments:
//      ppcpcOut    - Connection point container interface that is returned.
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::GetConnectionPointContainer(
    IConnectionPointContainer * * ppcpcOut
    )
{
    TraceFunc( "[IConnectionPoint] ppcpcOut" );

    HRESULT hr;

    IServiceProvider * psp = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               ppcpcOut
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    HRETURN( hr );

} //*** CCPIClusCfgCallback::GetConnectionPointContainer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IConnectionPoint]
//  CCPIClusCfgCallback::Advise
//
//  Description:
//      Register to receive notifications.
//
//  Arguments:
//      pUnkSinkIn
//          Interface to use for notifications.  Must support IClusCfgCallback.
//
//      pdwCookieOut
//          Cookie representing advise request.  Used in call to Unadvise.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A required output argument was not specified.
//
//      E_INVALIDARG
//          A required input argument was not specified.
//
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::Advise(
      IUnknown *    pUnkSinkIn
    , DWORD *       pdwCookieOut
    )
{
    TraceFunc( "[IConnectionPoint]" );

    HRESULT hr;

    if ( pdwCookieOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( pUnkSinkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrAddConnection( pUnkSinkIn, pdwCookieOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CCPIClusCfgCallback::Advise

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IConnectionPoint]
//  CCPIClusCfgCallback::Unadvise
//
//  Description:
//      Unregister for notifications.
//
//  Arguments:
//      dwCookieIn  - Cookie returned from Advise.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::Unadvise(
    DWORD dwCookieIn
    )
{
    TraceFunc1( "[IConncetionPoint] dwCookieIn = %#x", dwCookieIn );

    HRESULT hr;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrRemoveConnection( dwCookieIn ) );

    HRETURN( hr );

} //*** CCPIClusCfgCallback::Unadvise

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IConnectionPoint]
//  CCPIClusCfgCallback::EnumConnections
//
//  Description:
//      Enumerate connections in the container.
//
//  Arguments:
//      ppEnumOut
//          Interface to enumerator being returned.  Caller must call Release()
//          on this interface when done with it.
//
//  Return Values:
//      S_OK        - Success.
//      E_POINTER   - A required output argument was not specified.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::EnumConnections(
    IEnumConnections * * ppEnumOut
    )
{
    TraceFunc( "[IConnectionPoint] ppEnumOut" );

    HRESULT hr;

    if ( ppEnumOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_penum->Clone( ppEnumOut ) );

Cleanup:

    HRETURN( hr );

} //*** CCPIClusCfgCallback::EnumConnections


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgCallback]
//  CCPIClusCfgCallback::SendStatusReport
//
//  Description:
//      Send a status report.
//
//  Arguments:
//      pcszNodeNameIn
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//      hrStatusIn
//      pcszDescriptionIn
//      pftTimeIn
//      pcszReferenceIn
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs from connection points.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    CONNECTDATA cd = { NULL };

    HRESULT             hr;
    HRESULT             hrResult = S_OK;
    IClusCfgCallback *  pcccb;
    FILETIME            ft;
    BSTR                bstrReferenceString = NULL;
    LPCWSTR             pcszReference = NULL;
    IEnumConnections *  pec = NULL;

    //
    // If no reference string was specified, see if there is one available
    // for the specified HRESULT.
    //

    if (    ( pcszReferenceIn == NULL )
        &&  ( hrStatusIn != S_OK )
        &&  ( hrStatusIn != S_FALSE )
        )
    {
        hr = STHR( HrGetReferenceStringFromHResult( hrStatusIn, &bstrReferenceString ) );
        if ( hr == S_OK )
        {
            pcszReference = bstrReferenceString;
        }
    } // if: no reference string was specified
    else
    {
        pcszReference = pcszReferenceIn;
    }

    //
    //  Clone the enumerator in case we are re-entered on the same thread.
    //

    hr = THR( m_penum->Clone( &pec ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Reset the enumerator to the first element.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Loop through each connection point in the container and send it
    // the notification.
    //

    for ( ;; )
    {
        if ( cd.pUnk != NULL )
        {
            cd.pUnk->Release();
            cd.pUnk = NULL;
        }

        hr = STHR( pec->Next( 1, &cd, NULL ) );
        if ( FAILED( hr ) )
            break;

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break; // exit condition
        }

        hr = THR( cd.pUnk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
        if ( FAILED( hr ) )
        {
            continue;   // igore the error and continue
        }

        if ( pftTimeIn == NULL )
        {
            GetSystemTimeAsFileTime( &ft );
            pftTimeIn = &ft;
        } // if:

        hr = THR( pcccb->SendStatusReport(
                 pcszNodeNameIn
               , clsidTaskMajorIn
               , clsidTaskMinorIn
               , ulMinIn
               , ulMaxIn
               , ulCurrentIn
               , hrStatusIn
               , pcszDescriptionIn
               , pftTimeIn
               , pcszReference
               ) );
        if ( hr != S_OK )
        {
            hrResult = hr;
        }

        pcccb->Release();

    } // for: ever (each connection point)

Cleanup:

    if ( cd.pUnk != NULL )
    {
        cd.pUnk->Release();
    } // if:

    if ( pec != NULL )
    {
        pec->Release();
    } // if:

    TraceSysFreeString( bstrReferenceString );

    HRETURN( hrResult );

} //*** CCPIClusCfgCallback::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcookies.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumCookies.h
//
//  Description:
//      CEnumCookies implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    08-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CObjectManager;

// CEnumCookies
class CEnumCookies
    : public IEnumCookies
{
friend class CObjectManager;
private:
    // IUnknown
    LONG                m_cRef;

    // IEnumCookies
    ULONG               m_cAlloced; // Size of the array.
    ULONG               m_cIter;    // Our iter counter.
    OBJECTCOOKIE *      m_pList;    // Array of cookies.
    DWORD               m_cCookies; // Number of array items in use

private: // Methods
    CEnumCookies( void );
    ~CEnumCookies( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumCookies
    STDMETHOD( Next )( ULONG celt, OBJECTCOOKIE rgcookieOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumCookies ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** class CEnumCookies
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcpicccb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      EnumCPICCCB.cpp
//
//  Description:
//      IClusCfgCallback Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EnumCPICCCB.h"

DEFINE_THISCLASS("CEnumCPICCCB")

#define PUNK_BUFFER_GROW_SIZE   10

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPICCCB class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::S_HrCreateInstance
//
//  Description:
//      Create a CEnumCPICCCB instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CEnumCPICCCB *  pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CEnumCPICCCB();
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit() );  // fIsCloneIn = FALSE
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCPICCCB::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::CEnumCPICCCB
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCPICCCB::CEnumCPICCCB( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCPICCCB::CEnumCPICCCB


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::~CEnumCPICCCB
//
//  Description:
//      Default destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCPICCCB::~CEnumCPICCCB( void )
{
    TraceFunc( "" );

    IUnknown * punk = NULL;

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;

            punk = m_pList[ m_cAlloced ];

            AssertMsg( m_fIsClone || punk == NULL, "Someone didn't Unadvise before releasing the last Reference." );
            if ( punk != NULL )
            {
                punk->Release();
            }

        } // while: m_cAlloced

        TraceFree( m_pList );
    } // while:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCPICCCB::~CEnumCPICCCB


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPICCCB -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPICCCB::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumCPICCCB::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPICCCB::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumCPICCCB::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumConnections * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumConnections ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumConnections, this, 0 );
    } // else if: IEnumConnections
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumCPICCCB::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPICCCB -- IEnumConnectionPoints interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::Next
//
//  Description:
//      Enumerator Next method.
//
//  Arguments:
//      cConnectionsIn
//          How many items requested.  Also tells us how bing rgcd.
//
//      rgcdOut
//          Array that gets the data.
//
//      pcFetchedOut
//          How many did we place in the array.
//
//  Return Values:
//      S_OK
//          Success.
//
//      S_FALSE
//          cConnectionsIn > *pcFetchedOut.  Did not return as many items
//          as the caller asked for.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Next(
    ULONG cConnectionsIn,
    LPCONNECTDATA rgcd,
    ULONG *pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    ULONG   cIter;
    HRESULT hr = S_FALSE;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    } // if:

    for( cIter = 0
       ; ( cIter < cConnectionsIn ) && ( m_cIter < m_cCurrent )
       ; m_cIter++
       )
    {
        IUnknown * punk = m_pList[ m_cIter ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IUnknown, &rgcd[ cIter ].pUnk ) );
            if ( FAILED( hr ) )
                goto Error;

            rgcd[ cIter ].pUnk = TraceInterface( L"EnumCPICCCB!IUnknown", IUnknown, rgcd[ cIter ].pUnk, 1 );

            rgcd[ cIter ].dwCookie = m_cIter + 1;

            cIter ++;
        } // if:

    } // for: cIter

    if ( cIter != cConnectionsIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    } // else:

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = cIter;
    } // if:

Cleanup:

    HRETURN( hr );

Error:
    while ( cIter != 0 )
    {
        cIter --;
        rgcd[ cIter ].pUnk->Release();
    } // while:

    goto Cleanup;

} //*** CEnumCPICCCB::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::Skip
//
//  Description:
//      Enumerator Skip method.
//
//  Arguments:
//      cConnectionsIn
//          Number of items to skip.
//
//  Return Values:
//      S_OK
//          Success.
//
//      S_FALSE
//          The number to skip put us at the end of the list.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Skip(
    ULONG cConnectionsIn
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter += cConnectionsIn;
    if ( m_cIter >= m_cCurrent )
    {
        m_cIter = m_cCurrent;
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CEnumCPICCCB::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::Reset
//
//  Description:
//      Enumerator Reset method.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumCPICCCB::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::Clone
//
//  Description:
//      Enumerator Clone method.
//
//  Arguments:
//      ppEnumOut
//          The new enumerator that we are cloning ourselves into.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Clone(
    IEnumConnections **ppEnumOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr;

    CEnumCPICCCB * pecp = new CEnumCPICCCB();
    if ( pecp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pecp->HrInit( TRUE ) ); // fIsCloneIn = TRUE
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecp->HrCopy( this ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecp->TypeSafeQI( IEnumConnections, ppEnumOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppEnumOut = TraceInterface( L"EnumCPICCCB!IEnumConnections", IEnumConnections, *ppEnumOut, 1 );

    pecp->Release();
    pecp = NULL;

Cleanup:

    if ( pecp != NULL )
    {
        delete pecp;
    } // if:

    HRETURN( hr );

} //*** CEnumCPICCCB::Clone


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI -- Public methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::HrAddConnection
//
//  Description:
//      Add a connection point container to our list of clients.
//
//  Arguments:
//      punkIn
//          The new client object.
//
//      pdwCookieOut
//          Cookie used to find this client object in our list.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrAddConnection(
    IUnknown * punkIn,
    DWORD * pdwCookieOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    ULONG cIter;

    if ( pdwCookieOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  See if there is an openning in the currently allocated list.
    //

    for ( cIter = 0; cIter < m_cCurrent; cIter ++ )
    {
        if ( m_pList[ cIter ] == NULL )
        {
            //
            //  Found an openning... try to use it.
            //

            hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );

            m_pList[ cIter ] = TraceInterface( L"CEnumCPICCCB!IUnknown", IUnknown, m_pList[ cIter ], 1 );

            *pdwCookieOut = cIter + 1;

            //  Doesn't matter if it succeeded or fail, exit.
            goto Cleanup;
        }
    }

    if ( m_cCurrent == m_cAlloced )
    {
        IUnknown ** pNewList;

        //
        //  Try making some more space.
        //

        pNewList = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, ( m_cAlloced + PUNK_BUFFER_GROW_SIZE ) * sizeof( IUnknown * ) );
        if ( pNewList == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        CopyMemory( pNewList, m_pList, m_cCurrent * sizeof( IUnknown * ) );
        TraceFree( m_pList );

        m_pList = pNewList;
        m_cAlloced += PUNK_BUFFER_GROW_SIZE;
    }

    //
    //  Add it to the list.
    //

    hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ m_cCurrent ] ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_pList[ m_cCurrent ] = TraceInterface( L"CEnumCPICCCB!IUnknown", IUnknown, m_pList[ m_cCurrent ], 1 );

    m_cCurrent ++;
    *pdwCookieOut = m_cCurrent; // starts at ONE, not ZERO

Cleanup:

    HRETURN( hr );

} //*** CEnumCPICCCB::HrAddConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::HrRemoveConnection
//
//  Description:
//      Remove the client identified by the passed in cookie from the list.
//
//  Arguments:
//      dwCookieIn
//          The cookie of the client that is to be removed from the list.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrRemoveConnection(
    DWORD dwCookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( dwCookieIn == 0 || dwCookieIn > m_cCurrent )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    if ( m_pList[ dwCookieIn - 1 ] == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_pList[ dwCookieIn - 1 ]->Release();
    m_pList[ dwCookieIn - 1 ] = NULL;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumCPICCCB::HrRemoveConnection


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPICCCB -- Private methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::HrInt
//
//  Description:
//      Do any initialization that may fail here.
//
//  Arguments:
//      fIsCloneIn
//          Is this instance a clone?
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrInit(
    BOOL fIsCloneIn // = FALSE
    )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumConnectionPoints
    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );
    Assert( m_fIsClone == FALSE );

    m_fIsClone = fIsCloneIn;

    // INotifyUI

    HRETURN( S_OK );

} //*** CEnumCPICCCB::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPICCCB::HrCopy
//
//  Description:
//      Copy from the passed in enumerator.
//
//  Arguments:
//      pecpIn
//          The source that we are to copy from.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrCopy(
    CEnumCPICCCB * pecpIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    ULONG cIter;

    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_pList == 0 );

    m_pList = (IUnknown**) TraceAlloc( HEAP_ZERO_MEMORY, pecpIn->m_cCurrent * sizeof( IUnknown * ) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    m_cCurrent = m_cAlloced = pecpIn->m_cCurrent;
    m_cIter = 0;

    for ( cIter = 0; cIter < pecpIn->m_cCurrent; cIter ++ )
    {
        //
        //  Does the source have a pointer at the current index?  If it does then "copy" it,
        //  otherwise NULL out that index in our copy...
        //

        if ( pecpIn->m_pList[ cIter ] != NULL )
        {
            hr = THR( pecpIn->m_pList[ cIter ]->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            m_pList[ cIter ] = TraceInterface( L"EnumCPICCCB!IUnknown", IUnknown, m_pList[ cIter ], 1 );
        } // if:
        else
        {
            m_pList[ cIter ] = NULL;
        } // else:
    } // for:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumCPICCCB::HrCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumipaddresses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumIPAddresses.h
//
//  Description:
//      CEnumIPAddresses implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumIPAddresses
class CEnumIPAddresses
    : public IExtendObjectManager
    , public IEnumClusCfgIPAddresses
{
private:
    // IUnknown
    LONG                        m_cRef;     //  Reference counter

    // IEnumClusCfgNetworks
    ULONG                       m_cAlloced; //  Allocation size of the list
    ULONG                       m_cIter;    //  Out iter
    IClusCfgIPAddressInfo **    m_pList;    //  List of interfaces

private: // Methods
    CEnumIPAddresses( void );
    ~CEnumIPAddresses( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgNetworks
    STDMETHOD( Next )( ULONG celt, IClusCfgIPAddressInfo * rgNetworksOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                      OBJECTCOOKIE  cookieParent
                    , REFCLSID      rclsidTypeIn
                    , LPCWSTR       pcszNameIn
                    , LPUNKNOWN *   ppunkOut
                    );

}; //*** class CEnumIPAddresses
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcpinotifyui.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      EnumCPINotifyUI.cpp
//
//  Description:
//      INotifyUI Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EnumCPINotifyUI.h"

DEFINE_THISCLASS("CEnumCPINotifyUI")

#define PUNK_BUFFER_GROW_SIZE   10

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::S_HrCreateInstance
//
//  Description:
//      Create a CEnumCPINotifyUI instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEnumCPINotifyUI *  pecnui = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pecnui = new CEnumCPINotifyUI();
    if ( pecnui == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pecnui->HrInit() );   // fIsCloneIn = FALSE
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecnui->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pecnui != NULL )
    {
        pecnui->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::CEnumCPINotifyUI
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCPINotifyUI::CEnumCPINotifyUI( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCPINotifyUI::CEnumCPINotifyUI


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::~CEnumCPINotifyUI
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCPINotifyUI::~CEnumCPINotifyUI( void )
{
    TraceFunc( "" );

    IUnknown * punk = NULL;

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;

            punk = m_pList[ m_cAlloced ];

            AssertMsg( m_fIsClone || punk == NULL, "Someone didn't Unadvise before releasing the last Reference." );
            if ( punk != NULL )
            {
                punk->Release();
            } // if:
        } // while: m_cAlloced

        TraceFree( m_pList );
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCPINotifyUI::~CEnumCPINotifyUI


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPINotifyUI::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumCPINotifyUI::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPINotifyUI::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if:

    CRETURN( cRef );

} //*** CEnumCPINotifyUI::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumConnections * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumConnections ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumConnections, this, 0 );
    } // else if: IEnumConnections
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumCPINotifyUI::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI -- IEnumConnectionPoints interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::Next
//
//  Description:
//      Enumerator Next method.
//
//  Arguments:
//      cConnectionsIn
//          How many items requested.  Also tells us how bing rgcd.
//
//      rgcdOut
//          Array that gets the data.
//
//      pcFetchedOut
//          How many did we place in the array.
//
//  Return Values:
//      S_OK
//          Success.
//
//      S_FALSE
//          cConnectionsIn > *pcFetchedOut.  Did not return as many items
//          as the caller asked for.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Next(
      ULONG         cConnectionsIn
    , LPCONNECTDATA rgcdOut
    , ULONG *       pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    ULONG   cIter;

    HRESULT hr = S_FALSE;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    } // if:

    for( cIter = 0
       ; ( cIter < cConnectionsIn ) && ( m_cIter < m_cCurrent )
       ; m_cIter ++
       )
    {
        IUnknown * punk = m_pList[ m_cIter ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IUnknown, &rgcdOut[ cIter ].pUnk ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            rgcdOut[ cIter ].pUnk = TraceInterface( L"EnumCPINotifyUI!IUnknown", IUnknown, rgcdOut[ cIter ].pUnk, 1 );
            rgcdOut[ cIter ].dwCookie = m_cIter + 1;

            cIter ++;
        } // if:

    } // for: cIter

    if ( cIter != cConnectionsIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    } // else:

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = cIter;
    } // if:

Cleanup:

    HRETURN( hr );

Error:

    while ( cIter != 0 )
    {
        cIter--;
        rgcdOut[ cIter ].pUnk->Release();
    } // while:

    goto Cleanup;

} //*** CEnumCPINotifyUI::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::Skip
//
//  Description:
//      Enumerator Skip method.
//
//  Arguments:
//      cConnectionsIn
//          Number of items to skip.
//
//  Return Values:
//      S_OK
//          Success.
//
//      S_FALSE
//          The number to skip put us at the end of the list.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Skip(
    ULONG cConnectionsIn
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter += cConnectionsIn;
    if ( m_cIter >= m_cCurrent )
    {
        m_cIter = m_cCurrent;
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::Reset
//
//  Description:
//      Enumerator Reset method.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumCPINotifyUI::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::Clone
//
//  Description:
//      Enumerator Clone method.
//
//  Arguments:
//      ppEnumOut
//          The new enumerator that we are cloning ourselves into.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Clone(
    IEnumConnections ** ppEnumOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    CEnumCPINotifyUI * pecp = new CEnumCPINotifyUI();
    if ( pecp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pecp->HrInit( TRUE ) );   // fIsCloneIn = TRUE
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecp->HrCopy( this ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecp->TypeSafeQI( IEnumConnections, ppEnumOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppEnumOut = TraceInterface( L"EnumCPINotifyUI!IEnumConnections", IEnumConnections, *ppEnumOut, 1 );

    pecp->Release();
    pecp = NULL;

Cleanup:

    if ( pecp != NULL )
    {
        delete pecp;
    } // if:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::Clone


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI -- Public methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::HrAddConnection
//
//  Description:
//      Add a connection point container to our list of clients.
//
//  Arguments:
//      punkIn
//          The new client object.
//
//      pdwCookieOut
//          Cookie used to find this client object in our list.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrAddConnection(
      IUnknown *    punkIn
    , DWORD *       pdwCookieOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    ULONG cIter;

    if ( pdwCookieOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  See if there is an openning in the currently allocated list.
    //

    for ( cIter = 0; cIter < m_cCurrent; cIter ++ )
    {
        if ( m_pList[ cIter ] == NULL )
        {
            //
            //  Found an openning... try to use it.
            //

            hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );

            m_pList[ cIter ] = TraceInterface( L"CEnumCPINotifyUI!IUnknown", IUnknown, m_pList[ cIter ], 1 );

            *pdwCookieOut = cIter + 1;

            //  Doesn't matter if it succeeded or fail, exit.
            goto Cleanup;
        } // if:
    } // for:

    if ( m_cCurrent == m_cAlloced )
    {
        IUnknown ** pNewList;

        //
        //  Try making some more space.
        //

        pNewList = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, ( m_cAlloced + PUNK_BUFFER_GROW_SIZE ) * sizeof( IUnknown * ) );
        if ( pNewList == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        CopyMemory( pNewList, m_pList, m_cCurrent * sizeof( IUnknown * ) );
        TraceFree( m_pList );

        m_pList = pNewList;
        m_cAlloced += PUNK_BUFFER_GROW_SIZE;
    } // if:

    //
    //  Add it to the list.
    //

    hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ m_cCurrent ] ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_pList[ m_cCurrent ] = TraceInterface( L"CEnumCPINotifyUI!IUnknown", IUnknown, m_pList[ m_cCurrent ], 1 );

    m_cCurrent ++;
    *pdwCookieOut = m_cCurrent; // starts at ONE, not ZERO

Cleanup:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::HrAddConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::HrRemoveConnection
//
//  Description:
//      Remove the client identified by the passed in cookie from the list.
//
//  Arguments:
//      dwCookieIn
//          The cookie of the client that is to be removed from the list.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrRemoveConnection(
    DWORD dwCookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( dwCookieIn == 0 || dwCookieIn > m_cCurrent )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    if ( m_pList[ dwCookieIn - 1 ] == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_pList[ dwCookieIn - 1 ]->Release();
    m_pList[ dwCookieIn - 1 ] = NULL;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::HrRemoveConnection


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCPINotifyUI -- Private methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::HrInt
//
//  Description:
//      Do any initialization that may fail here.
//
//  Arguments:
//      fIsCloneIn
//          Is this instance a clone?
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrInit(
    BOOL fIsCloneIn     // = FALSE
    )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumConnectionPoints
    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );
    Assert( m_fIsClone == FALSE );

    m_fIsClone = fIsCloneIn;

    // INotifyUI

    HRETURN( S_OK );

} //*** CEnumCPINotifyUI::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCPINotifyUI::HrCopy
//
//  Description:
//      Copy from the passed in enumerator.
//
//  Arguments:
//      pecpIn
//          The source that we are to copy from.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrCopy(
    CEnumCPINotifyUI * pecpIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    ULONG   cIter;

    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_pList == NULL );

    m_pList = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, pecpIn->m_cCurrent * sizeof( IUnknown * ) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    m_cCurrent = m_cAlloced = pecpIn->m_cCurrent;
    m_cIter = 0;

    for ( cIter = 0; cIter < pecpIn->m_cCurrent; cIter++ )
    {
        //
        //  Does the source have a pointer at the current index?  If it does then "copy" it,
        //  otherwise NULL out that index in our copy...
        //

        if ( pecpIn->m_pList[ cIter ] != NULL )
        {
            hr = THR( pecpIn->m_pList[ cIter ]->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            m_pList[ cIter ] = TraceInterface( L"EnumCPINotifyUI!IUnknown", IUnknown, m_pList[ cIter ], 1 );
        } // if:
        else
        {
            m_pList[ cIter ] = NULL;
        } // else:
    } // for:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumCPINotifyUI::HrCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcpinotifyui.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumCPINotifyUI.h
//
//  Description:
//      INotifyUI Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCPINotifyUI;

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCPINotifyUI
//
//  Description:
//      The class CEnumCPINotifyUI is an enumerator of connection points
//      that are "advised" for notify UI callbacks.
//
//  Interfaces:
//      IEnumConnections
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCPINotifyUI
    : public IEnumConnections
{
friend class CCPINotifyUI;
private:
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    // IEnumConnections
    ULONG               m_cAlloced;     //  Alloced number of entries
    ULONG               m_cCurrent;     //  Number of entries currently used
    ULONG               m_cIter;        //  The Iter
    IUnknown **         m_pList;        //  List of sinks (IUnknown)
    BOOL                m_fIsClone;     //  Is this instance a clone?

    // INotifyUI

private: // Methods
    CEnumCPINotifyUI( void );
    ~CEnumCPINotifyUI( void );

    // Private copy constructor to prevent copying.
    CEnumCPINotifyUI( const CEnumCPINotifyUI & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCPINotifyUI & operator = ( const CEnumCPINotifyUI & nodeSrc );

    HRESULT HrInit( BOOL fIsCloneIn = FALSE );
    HRESULT HrCopy( CEnumCPINotifyUI * pecpIn );
    HRESULT HrAddConnection( IUnknown * punkIn, DWORD * pdwCookieOut );
    HRESULT HrRemoveConnection( DWORD dwCookieIn );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    //  IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  IEnumConnections
    //

    STDMETHOD( Next )( ULONG cConnectionsIn, LPCONNECTDATA rgcdOut, ULONG * pcFetchedOut );
    STDMETHOD( Skip )( ULONG cConnectionsIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnections ** ppEnumOut );

}; //*** class CEnumCPINotifyUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumipaddresses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      EnumIPAddresses.cpp
//
//  Description:
//      CEnumIPAddress implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IPAddressInfo.h"
#include "EnumIPAddresses.h"

DEFINE_THISCLASS("CEnumIPAddresses")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumIPAddresses::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumIPAddresses::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEnumIPAddresses *  peipa = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    peipa = new CEnumIPAddresses;
    if ( peipa == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( peipa->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( peipa->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( peipa != NULL )
    {
        peipa->Release();
    }

    HRETURN( hr );

} //*** CEnumIPAddresses::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumIPAddresses::CEnumIPAddresses
//
//////////////////////////////////////////////////////////////////////////////
CEnumIPAddresses::CEnumIPAddresses( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumIPAddresses::CEnumIPAddresses

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumClusCfgIPAddresses

    HRETURN( hr );

} //*** CEnumIPAddresses::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumIPAddresses::~CEnumIPAddresses
//
//////////////////////////////////////////////////////////////////////////////
CEnumIPAddresses::~CEnumIPAddresses( void )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            (m_pList[ m_cAlloced ])->Release();
        }
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumIPAddresses::~CEnumIPAddresses


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumIPAddresses::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumClusCfgIPAddresses * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
    } // else if: IEnumClusCfgIPAddresses
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumIPAddresses::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumIPAddresses::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumIPAddresses::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumIPAddresses::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumIPAddresses::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumIPAddresses::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumIPAddresses::Release


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumIPAddresses::FindObject(
//        OBJECTCOOKIE    cookieIn
//      , REFCLSID        rclsidTypeIn
//      , LPCWSTR         pcszNameIn
//      , LPUNKNOWN *     punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = S_FALSE;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( rclsidTypeIn != CLSID_IPAddressType )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_IPAddressType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pec = TraceInterface( L"CEnumIPAddresses!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = THR( pec->Count( &cookieCount ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
    {
        // The error text is better than the coding value.
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgIPAddressInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgIPAddressInfo *) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pom->GetObject( DFGUID_IPAddressInfo,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumIPAddressInfo,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CEnumIPAddresses::FindObject


//****************************************************************************
//
//  IEnumClusCfgIPAddresses
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Next(
//      ULONG celt,
//      IClusCfgNode ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Next(
    ULONG celt,
    IClusCfgIPAddressInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    ULONG   celtFetched;

    HRESULT hr = S_FALSE;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgIPAddressInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
        {
            goto CleanupList;
        }

        rgOut[ celtFetched ] = TraceInterface( L"EnumIPAddresses!IClusCfgIPAddressInfo", IClusCfgIPAddressInfo, rgOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release();
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

} //*** CEnumIPAddresses::Next


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CEnumIPAddresses::Skip


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumIPAddresses::Reset


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Clone(
//      IEnumClusCfgIPAddresses ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Clone(
    IEnumClusCfgIPAddresses ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumIPAddresses::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );

} //*** CEnumIPAddresses::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumcpicccb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumCPICCCB.h
//
//  Description:
//      IClusCfgCallback Connection Point Enumerator implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCPICCCB
//
//  Description:
//      The class CEnumCPICCCB is an enumerator of connection points
//      that are "advised" for callbacks.
//
//  Interfaces:
//      IEnumConnections
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCPICCCB
    : public IEnumConnections
{
friend class CCPIClusCfgCallback;
private:
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    // IEnumConnections
    ULONG               m_cAlloced;     //  Alloced number of entries
    ULONG               m_cCurrent;     //  Number of entries currently used
    ULONG               m_cIter;        //  The Iter
    IUnknown * *        m_pList;        //  List of sinks (IUnknown)
    BOOL                m_fIsClone;     //  Is this instance a clone?

    // INotifyUI

private:
    CEnumCPICCCB( void );
    ~CEnumCPICCCB( void );

    // Private copy constructor to prevent copying.
    CEnumCPICCCB( const CEnumCPICCCB & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCPICCCB & operator = ( const CEnumCPICCCB & nodeSrc );

    HRESULT HrInit( BOOL fIsCloneIn = FALSE );
    HRESULT HrCopy( CEnumCPICCCB * pecpIn );
    HRESULT HrAddConnection( IUnknown * punkIn, DWORD * pdwCookieOut );
    HRESULT HrRemoveConnection( DWORD dwCookieIn );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    //  IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  IEnumConnections
    //

    STDMETHOD( Next )( ULONG cConnectionsIn, LPCONNECTDATA rgcdIn, ULONG * pcFetchedOut );
    STDMETHOD( Skip )( ULONG cConnectionsIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnections ** ppEnumOut );

}; //*** class CEnumCPICCCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enummanageablenetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableNetworks.cpp
//
//  Description:
//      CEnumManageableNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ManagedNetwork.h"
#include "EnumManageableNetworks.h"

DEFINE_THISCLASS("CEnumManageableNetworks")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumManageableNetworks::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumManageableNetworks::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CEnumManageableNetworks *   pemn = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pemn = new CEnumManageableNetworks;
    if ( pemn == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pemn->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pemn->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pemn != NULL )
    {
        pemn->Release();
    }

    HRETURN( hr );

} //*** CEnumManageableNetworks::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableNetworks::CEnumManageableNetworks
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableNetworks::CEnumManageableNetworks( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumManageableNetworks::CEnumManageableNetworks

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumClusCfgNetworks
    Assert( m_cAlloced == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    HRETURN( hr );

} //*** CEnumManageableNetworks::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableNetworks::~CEnumManageableNetworks
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableNetworks::~CEnumManageableNetworks( void )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            AssertMsg( m_pList[ m_cAlloced ], "This shouldn't happen." );
            if ( m_pList[ m_cAlloced ] != NULL )
            {
                (m_pList[ m_cAlloced ])->Release();
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumManageableNetworks::~CEnumManageableNetworks


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumManageableNetworks::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumClusCfgNetworks * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgNetworks ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
    } // else if: IEnumClusCfgNetworks
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumManageableNetworks::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableNetworks::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumManageableNetworks::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableNetworks::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumManageableNetworks::Release


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumManageableNetworks::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = S_FALSE;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( rclsidTypeIn != CLSID_NetworkType )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_NetworkType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pec = TraceInterface( L"CEnumManageableNetworks!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = THR( pec->Count( &cookieCount ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
    {
        // The error text is better than the coding value.
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgNetworkInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgNetworkInfo *) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pom->GetObject( DFGUID_NetworkResource,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumManageableNetworks,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CEnumManageableNetworks::FindObject


//****************************************************************************
//
//  IEnumClusCfgNetworks
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Next(
//      ULONG celt,
//      IClusCfgNetworkInfo ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Next(
    ULONG celt,
    IClusCfgNetworkInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    ULONG   celtFetched;

    HRESULT hr = S_FALSE;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgNetworkInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
        {
            goto CleanupList;
        }

        rgOut[ celtFetched ] = TraceInterface( L"CEnumManageableNetworks!IClusCfgNetworkInfo", IClusCfgNetworkInfo, rgOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release();
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

} //*** CEnumManageableNetworks::Next


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CEnumManageableNetworks::Skip


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumManageableNetworks::Reset


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Clone(
//      IEnumClusCfgNetworks ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Clone(
    IEnumClusCfgNetworks ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumManageableNetworks::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );

} //*** CEnumManageableNetworks::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enummanageableresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableResources.cpp
//
//  Description:
//      CEnumManageableResources implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ManagedResource.h"
#include "EnumManageableResources.h"

DEFINE_THISCLASS("CEnumManageableResources")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumManageableResources::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumManageableResources::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CEnumManageableResources *  pemr = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pemr = new CEnumManageableResources;
    if ( pemr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pemr->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pemr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pemr != NULL )
    {
        pemr->Release();
    }

    HRETURN( hr );

} //*** CEnumManageableResources::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableResources::CEnumManageableResources
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableResources::CEnumManageableResources( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumManageableResources::CEnumManageableResources

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumClusCfgManagedResources
    Assert( m_cAlloced == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    HRETURN( hr );

} //*** CEnumManageableResources::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableResources::~CEnumManageableResources
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableResources::~CEnumManageableResources( void )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            AssertMsg( m_pList[ m_cAlloced ], "This shouldn't happen" );
            if ( m_pList[ m_cAlloced ] != NULL )
            {
                (m_pList[ m_cAlloced ])->Release();
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumManageableResources::~CEnumManageableResources


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumManageableResources::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumManageableResources::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableResources::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumManageableResources::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableResources::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumManageableResources::Release


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumManageableResources::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = S_FALSE;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD objectCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( rclsidTypeIn != CLSID_ManagedResourceType )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_ManagedResourceType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pec = TraceInterface( L"CEnumClusCfgManagedResources!IEnumCookies", IEnumCookies, pec, 1 );


    hr = pec->Count( &objectCount );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_cAlloced = objectCount;

    if ( m_cAlloced == 0 )
    {
        // The error text is better than the coding value.
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgManagedResourceInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgManagedResourceInfo *) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pom->GetObject( DFGUID_ManagedResource,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumManageableResources,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CEnumManageableResources::FindObject


//****************************************************************************
//
//  IEnumClusCfgManagedResources
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Next(
//      ULONG celt,
//      IClusCfgNetworkInfo ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Next(
    ULONG celt,
    IClusCfgManagedResourceInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    ULONG   celtFetched;

    HRESULT hr = S_FALSE;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgManagedResourceInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
        {
            goto CleanupList;
        }

        rgOut[ celtFetched ] = TraceInterface( L"CEnumManageableResources!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, rgOut[ celtFetched ], 1  );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release();
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

} //*** CEnumManageableResources::Next


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CEnumManageableResources::Skip


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumManageableResources::Reset


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Clone(
//      IEnumClusCfgManagedResources ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Clone(
    IEnumClusCfgManagedResources ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumManageableResources::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );

} //*** CEnumManageableResources::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enummanageablenetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableNetworks.h
//
//  Description:
//      CEnumManageableNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumManageableNetworks
class CEnumManageableNetworks
    : public IExtendObjectManager
    , public IEnumClusCfgNetworks
{
private:
    // IUnknown
    LONG                            m_cRef;     //  Reference counter

    // IEnumClusCfgNetworks
    ULONG                           m_cAlloced; //  Current allocation size of list
    ULONG                           m_cIter;    //  Our iter counter
    IClusCfgNetworkInfo **          m_pList;    //  Our copy of the list of networks.

private: // Methods
    CEnumManageableNetworks( void );
    ~CEnumManageableNetworks( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgNetworks
    STDMETHOD( Next )( ULONG celt, IClusCfgNetworkInfo * rgNetworksOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; //*** class CEnumManageableNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumnodeinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumNodeInformation.h
//
//  Description:
//      CEnumNodeInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumNodeInformation
class CEnumNodeInformation
    : public IExtendObjectManager
    , public IEnumNodes
{
private:
    // IUnknown
    LONG                    m_cRef;

    // IEnumNodes
    ULONG                   m_cAlloced; //  Number in list
    ULONG                   m_cIter;    //  Iter current value.
    IClusCfgNodeInfo **     m_pList;    //  List of IClusCfgNodeInfo-s

    // IObjectManager

private: // Methods
    CEnumNodeInformation( void );
    ~CEnumNodeInformation( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumNodes
    STDMETHOD( Next )( ULONG celt, IClusCfgNodeInfo * rgNodesOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumNodes ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; //*** class CEnumNodeInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enummanageableresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableResources.h
//
//  Description:
//      CEnumManageableResources implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumManageableResources
class CEnumManageableResources
    : public IExtendObjectManager
    , public IEnumClusCfgManagedResources
{
private:
    // IUnknown
    LONG                            m_cRef;         //  Ref count

    // IEnumClusCfgManagedResources
    ULONG                           m_cAlloced;     //  Current allocated size of the list.
    ULONG                           m_cIter;        //  Our iter counter
    IClusCfgManagedResourceInfo **  m_pList;        //  List of interfaces

private: // Methods
    CEnumManageableResources( void );
    ~CEnumManageableResources( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgManagedResources
    STDMETHOD( Next )( ULONG celt, IClusCfgManagedResourceInfo * rgResourcesOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppenumOut );
    STDMETHOD( Count )( DWORD* pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; //*** class CEnumManageableResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\ipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      IPAddressInfo.h
//
//  Description:
//      This file contains the declaration of the CIPAddressInfo
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

class CEnumIPAddresses;

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CIPAddressInfo
//
//  Description:
//      The class IPAddressInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgIPAddressInfo
//      IGatherData
//      IExtendObjectManager
//
//--
//////////////////////////////////////////////////////////////////////////////
class CIPAddressInfo
    : public IExtendObjectManager
    , public IClusCfgIPAddressInfo
    , public IGatherData // private
{
friend class CEnumIPAddresses;
public:
    //
    // Public constructors and destructors
    //

    CIPAddressInfo( void );
    virtual ~CIPAddressInfo( void );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IGatherData
    //

    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    //
    // IClusCfgIPAddressInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuad );

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuad );

    // IObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    ULONG                   m_ulIPAddress;
    ULONG                   m_ulIPSubnet;
    BSTR                    m_bstrUID;
    BSTR                    m_bstrName;

    // IExtendObjectManager

    // Private copy constructor to prevent copying.
    CIPAddressInfo( const CIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CIPAddressInfo & operator = ( const CIPAddressInfo & nodeSrc );

    STDMETHOD( HrInit )( void );
    STDMETHOD( LoadName )( void );

}; //*** Class CIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\enumnodeinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumNodeInformation.cpp
//
//  Description:
//      Node Information object implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NodeInformation.h"
#include "EnumNodeInformation.h"

DEFINE_THISCLASS("CEnumNodeInformation")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumNodeInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumNodeInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumNodeInformation *  peni = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    peni = new CEnumNodeInformation;
    if ( peni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( peni->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( peni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( peni != NULL )
    {
        peni->Release();
    }

    HRETURN( hr );

} //*** CEnumNodeInformation::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumNodeInformation::CEnumNodeInformation
//
//////////////////////////////////////////////////////////////////////////////
CEnumNodeInformation::CEnumNodeInformation( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumNodeInformation::CEnumNodeInformation

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IEnumNodes
    //Assert( m_pList == NULL );
    //Assert( m_cIter == 0 );

    HRETURN( hr );

} //*** CEnumNodeInformation::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumNodeInformation::~CEnumNodeInformation
//
//////////////////////////////////////////////////////////////////////////////
CEnumNodeInformation::~CEnumNodeInformation( void )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;

            if( m_pList[m_cAlloced] )
            {
                (m_pList[m_cAlloced])->Release();
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumNodeInformation::~CEnumNodeInformation


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumNodeInformation::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumNodes * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumNodes ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumNodes, this, 0 );
    } // else if: IEnumNodes
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumNodeInformation::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumNodeInformation::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumNodeInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumNodeInformation::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumNodeInformation::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumNodeInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumNodeInformation::Release


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumNodeInformation::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = S_FALSE;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( rclsidTypeIn != CLSID_NodeType )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_NodeType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pec = TraceInterface( L"CEnumNodeInformation!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = pec->Count( &cookieCount );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
    {
        // The error text is better than the coding value.
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgNodeInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgNodeInfo *) );
    if ( m_pList == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pom->GetObject( DFGUID_NodeInformation,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
        {
            Assert( m_pList[ m_cIter ] == NULL );
            goto Cleanup;
        }

        Assert( m_pList[ m_cIter ] != NULL );
        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumNodes,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CEnumNodeInformation::FindObject


//****************************************************************************
//
//  IEnumNodes
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Next(
//      ULONG celt,
//      IClusCfgNode ** rgNodesOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Next(
    ULONG celt,
    IClusCfgNodeInfo * rgNodesOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumNodes]" );

    ULONG   celtFetched;

    HRESULT hr = S_FALSE;

    //
    //  Check parameters
    //

    if ( rgNodesOut == NULL || celt == 0 )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgNodesOut, celt * sizeof(rgNodesOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgNodeInfo, &rgNodesOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
        {
            goto CleanupList;
        }

        rgNodesOut[ celtFetched ] = TraceInterface( L"CEnumNodeInformation!IClusCfgNodeInfo", IClusCfgNodeInfo, rgNodesOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgNodesOut[ celtFetched ]->Release();
        rgNodesOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

} //*** CEnumNodeInformation::Next


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumNodes]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CEnumNodeInformation::Skip


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Reset( void )
{
    TraceFunc( "[IEnumNodes]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CEnumNodeInformation::Reset


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Clone(
//      IEnumNodes ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Clone(
    IEnumNodes ** ppenumOut
    )
{
    TraceFunc( "[IEnumNodes]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumNodeInformation::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );

} //*** CEnumNodeInformation::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\ipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CIPAddressInfo.cpp
//
//  Description:
//      This file contains the definition of the CIPAddressInfo
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "IPAddressInfo.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CIPAddressInfo" );

/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CIPAddressInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//      E_POINTER
//      E_OUTOFMEMORY
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CIPAddressInfo *    pipai = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pipai = new CIPAddressInfo();
    if ( pipai == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pipai->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pipai->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pipai != NULL )
    {
        pipai->Release();
    } // if:

    HRETURN( hr );

} //*** CIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::CIPAddressInfo
//
//  Description:
//      Constructor of the CIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressInfo::CIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CIPAddressInfo::CIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::~CIPAddressInfo
//
//  Description:
//      Desstructor of the CIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressInfo::~CIPAddressInfo( void )
{
    TraceFunc( "" );

    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CIPAddressInfo::~CIPAddressInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CIPAddressInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

   CRETURN( cRef );

} //*** CIPAddressInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgIPAddressInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgIPAddressInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
    } // else if:
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
    } // else if: IGatherData
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CIPAddressInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IObjectManager interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::FindObject
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::FindObject(
      OBJECTCOOKIE        cookieIn
    , REFCLSID            rclsidTypeIn
    , LPCWSTR             pcszNameIn
    , LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = S_OK;

    //
    //  Check parameters.
    //

    //  We need a cookie.
    if ( cookieIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to be representing a IPAddressType
    if ( ! IsEqualIID( rclsidTypeIn, CLSID_IPAddressType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to have a name.
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Not found, nor do we know how to make a task to find it!
    //
    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CIPAddressInfo::FindObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IGatherData interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::Gather
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT                         hr;
    IClusCfgIPAddressInfo *         pccipai = NULL;

    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    //
    //  Grab the right interface.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgIPAddressInfo, &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Transfer the information.
    //

    //
    //  Transfer the IP Address
    //

    hr = THR( pccipai->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Transfer the Subnet mask
    //

    hr = THR( pccipai->GetSubnetMask( &m_ulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Transfer the UID
    //

    hr = THR( pccipai->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Compute our name
    //

    hr = THR( LoadName() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    } // if:

    HRETURN( hr );

Error:
    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
    } // if:

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    } // if:
    m_ulIPAddress = 0;
    m_ulIPSubnet = 0;
    goto Cleanup;

} //*** CIPAddressInfo::Gather


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IClusCfgIPAddressInfo interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetUID
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CIPAddressInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetUIDGetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetIPAddress( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut != NULL )
    {
        *pulDottedQuadOut = m_ulIPAddress;
        hr = S_OK;
    } // if:
    else
    {
        hr = THR( E_POINTER );
    } // else:

    HRETURN( hr );

} //*** CIPAddressInfo::GetNetworkGetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::SetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::SetIPAddress( ULONG ulDottedQuad )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CIPAddressInfo::SetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetSubnetMask( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut != NULL )
    {
        *pulDottedQuadOut = m_ulIPSubnet;
        hr = S_OK;
    } // if:
    else
    {
        hr = THR( E_POINTER );
    } // else:

    HRETURN( hr );

} //*** CIPAddressInfo::GetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::SetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::SetSubnetMask( ULONG ulDottedQuad )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CIPAddressInfo::SetSubnetMask

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CIPAddressInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::LoadName
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::LoadName( void )
{
    TraceFunc( "" );
    Assert( m_ulIPAddress != 0 );
    Assert( m_ulIPSubnet != 0 );

    HRESULT                 hr = S_OK;
    LPWSTR                  pszIPAddress = NULL;
    LPWSTR                  pszIPSubnet = NULL;
    DWORD                   sc;
    WCHAR                   sz[ 256 ];

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPAddress, &pszIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPSubnet, &pszIPSubnet ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"%ws:%ws", pszIPAddress, pszIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_bstrName = TraceSysAllocString( sz );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:

    if ( pszIPAddress != NULL )
    {
        LocalFree( pszIPAddress );
    } // if:

    if ( pszIPSubnet != NULL )
    {
        LocalFree( pszIPSubnet );
    } // if:

    HRETURN( hr );

} //*** CIPAddressInfo::LoadName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\logger.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Logger.cpp
//
//  Description:
//      ClCfgSrv Logger implementation.
//
//  Maintained By:
//      David Potter (DavidP)   11-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Logger.h"

DEFINE_THISCLASS("CClCfgSrvLogger")


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::S_HrCreateInstance
//
//  Description:
//      Create an instance of this object.
//
//  Arguments:
//      ppunkOut    - IUnknown pointer to be returned.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClCfgSrvLogger::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClCfgSrvLogger *   pccsl = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsl = new CClCfgSrvLogger();
    if ( pccsl == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsl->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsl->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pccsl != NULL )
    {
        pccsl->Release();
    } // if:

    HRETURN( hr );

} //*** CClCfgSrvLogger::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::CClCfgSrvLogger
//
//--
//////////////////////////////////////////////////////////////////////////////
CClCfgSrvLogger::CClCfgSrvLogger( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CClCfgSrvLogger::CClCfgSrvLogger

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClCfgSrvLogger::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( m_cRef == 1 );

    // Open the log file.
    hr = THR( HrLogOpen() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Release the critical section on the log file.
    hr = THR( HrLogRelease() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClCfgSrvLogger::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::~CClCfgSrvLogger
//
//--
//////////////////////////////////////////////////////////////////////////////
CClCfgSrvLogger::~CClCfgSrvLogger( void )
{
    TraceFunc( "" );

    Assert( m_cRef == 0 );

    // Close the log file.
    THR( HrLogClose() );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClCfgSrvLogger::~CClCfgSrvLogger


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ILogger * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ILogger ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ILogger, this, 0 );
    } // else if: ILogger
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClCfgSrvLogger::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CClCfgSrvLogger::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClCfgSrvLogger::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClCfgSrvLogger::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CClCfgSrvLogger::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClCfgSrvLogger::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CClCfgSrvLogger::Release


//****************************************************************************
//
// ILogger
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::LogMsg
//
//  Description:
//      Write the message to the log.
//
//  Arguments:
//      nLogEntryTypeIn - Log entry type.
//      pcszMsgIn       - Message to write.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::LogMsg(
      DWORD     nLogEntryTypeIn
    , LPCWSTR   pcszMsgIn
    )
{
    TraceFunc( "[ILogger]" );

    HRESULT     hr = S_OK;

    ::LogMsg( nLogEntryTypeIn, pcszMsgIn );

    HRETURN( hr );

} //*** CClCfgSrvLogger::LogMsg


//****************************************************************************
//
// Global Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClCfgSrvLogger::S_HrLogStatusReport(
//      LPCWSTR     pcszNodeNameIn,
//      CLSID       clsidTaskMajorIn,
//      CLSID       clsidTaskMinorIn,
//      ULONG       ulMinIn,
//      ULONG       ulMaxIn,
//      ULONG       ulCurrentIn,
//      HRESULT     hrStatusIn,
//      LPCWSTR     pcszDescriptionIn,
//      FILETIME *  pftTimeIn,
//      LPCWSTR     pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClCfgSrvLogger::S_HrLogStatusReport(
      ILogger *     plLogger
    , LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    FILETIME        ft;
    BSTR            bstrLogMsg  = NULL;
    BSTR            bstrDisplayName = NULL;
    OLECHAR         wszTaskMajorGuid[ MAX_COM_GUID_STRING_LEN ] = { L'\0' };
    OLECHAR         wszTaskMinorGuid[ MAX_COM_GUID_STRING_LEN ] = { L'\0' };
    PCWSTR          pwcszNameToUse = NULL;

    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  Need to log the timestamp param.
    //

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if: no file time specified

    //
    //  If the node name is fully-qualified, use just the prefix.
    //
    if ( (pcszNodeNameIn != NULL) && (HrIsValidFQN( pcszNodeNameIn, true /* fAcceptNonRFCCharsIn */ ) == S_OK) )
    {
        THR( HrGetFQNDisplayName( pcszNodeNameIn, &bstrDisplayName ) );
    } // if: node name is a valid FQN

    if ( bstrDisplayName == NULL )
    {
        pwcszNameToUse = pcszNodeNameIn;
    }
    else
    {
        pwcszNameToUse = bstrDisplayName;
    }

    StringFromGUID2( clsidTaskMajorIn, wszTaskMajorGuid, ( int ) RTL_NUMBER_OF( wszTaskMajorGuid ) );
    StringFromGUID2( clsidTaskMinorIn, wszTaskMinorGuid, ( int ) RTL_NUMBER_OF( wszTaskMajorGuid ) );

    hr = THR( HrFormatStringIntoBSTR(
                       L"%1!ws!: %2!ws! (hr=%3!#08x!, %4!ws!, %5!ws!, %6!u!, %7!u!, %8!u!), %9!ws!"
                     , &bstrLogMsg
                     , pwcszNameToUse       // 1
                     , pcszDescriptionIn    // 2
                     , hrStatusIn           // 3
                     , wszTaskMajorGuid     // 4
                     , wszTaskMinorGuid     // 5
                     , ulMinIn              // 6
                     , ulMaxIn              // 7
                     , ulCurrentIn          // 8
                     , pcszReferenceIn      // 9
                     ) );

    if ( SUCCEEDED( hr ) )
    {
        plLogger->LogMsg( hrStatusIn, bstrLogMsg );
    }
    else
    {
        hr = S_OK;
    }

    TraceSysFreeString( bstrLogMsg );
    TraceSysFreeString( bstrDisplayName );

    HRETURN( hr );

} //*** CClCfgSrvLogger::S_HrLogStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\logmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      LogManager.cpp
//
//  Description:
//      Log Manager implementation.
//
//  Maintained By:
//      David Potter (DavidP)   07-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Logger.h"
#include "LogManager.h"

DEFINE_THISCLASS("CLogManager")


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CLogManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLogManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    CLogManager *       plm = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        plm = new CLogManager();
        if ( plm == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( plm->HrInit() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( plm->TypeSafeQI( IUnknown, ppunkOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // if: service manager doesn't exist
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( psp->TypeSafeQS( CLSID_LogManager, IUnknown, ppunkOut ) );
        psp->Release();

    } // else: service manager exists

Cleanup:

    if ( plm != NULL )
    {
        plm->Release();
    }

    HRETURN( hr );

} //*** CLogManager::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLogManager::CLogManager
//
//--
//////////////////////////////////////////////////////////////////////////////
CLogManager::CLogManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_plLogger == NULL );
    Assert( m_cookieCompletion == 0 );
    Assert( m_hrResult == S_OK );
    Assert( m_bstrLogMsg == NULL );
    Assert( m_pcpcb == NULL );
    Assert( m_dwCookieCallback == NULL );

    TraceFuncExit();

} //*** CLogManager::CLogManager

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    hr = THR( CClCfgSrvLogger::S_HrCreateInstance( reinterpret_cast< IUnknown ** >( &m_plLogger ) ) );

    HRETURN( hr );

} //*** CLogManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLogManager::~CLogManager
//
//--
//////////////////////////////////////////////////////////////////////////////
CLogManager::~CLogManager( void )
{
    TraceFunc( "" );

    Assert( m_cRef == 0 );

    THR( StopLogging() );

    // Release the ILogger interface.
    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
        m_plLogger = NULL;
    }

    // Decrement the global count of objects.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CLogManager::~CLogManager


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLogManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ILogManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ILogManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ILogManager, this, 0 );
    } // else if: ILogManager
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CLogManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CLogManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLogManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CLogManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CLogManager::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLogManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CLogManager::Release


//****************************************************************************
//
// ILogManager
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::StartLogging
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::StartLogging( void )
{
    TraceFunc( "[ILogManager]" );

    HRESULT                     hr = S_OK;
    IServiceProvider *          psp = NULL;
    IConnectionPointContainer * pcpc = NULL;

    //
    // If not done already, get the connection point.
    //

    if ( m_pcpcb == NULL )
    {
        hr = THR( CServiceManager::S_HrGetManagerPointer( &psp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS(
                          CLSID_NotificationManager
                        , IConnectionPointContainer
                        , &pcpc
                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint(
                              IID_IClusCfgCallback
                            , &m_pcpcb
                            ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: connection point callback not retrieved yet

    //
    //  Register to get notification (if needed)
    //

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pcpcb->Advise( static_cast< IClusCfgCallback * >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: advise cookie not retrieved yet

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    HRETURN( hr );

} //*** CLogManager::StartLogging

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::StopLogging
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::StopLogging( void )
{
    TraceFunc( "[ILogManager]" );

    HRESULT     hr = S_OK;

    // Unadvise the IConnectionPoint interface.
    if ( m_dwCookieCallback != 0 )
    {
        Assert( m_pcpcb != NULL );
        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_dwCookieCallback = 0;
    }

    // Release the IConnectionPoint interface.
    if ( m_pcpcb != NULL )
    {
        Assert( m_dwCookieCallback == 0 );
        m_pcpcb->Release();
        m_pcpcb = NULL;
    }

Cleanup:

    HRETURN( hr );

} //*** CLogManager::StopLogging


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::GetLogger
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::GetLogger( ILogger ** ppLoggerOut )
{
    TraceFunc( "[ILogManager]" );

    HRESULT     hr = S_OK;

    if ( ppLoggerOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppLoggerOut = NULL;

    if ( m_plLogger != NULL )
    {
        hr = THR( m_plLogger->TypeSafeQI( ILogger, ppLoggerOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: we have the logger interface
    else
    {
        hr = THR( E_NOINTERFACE );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CLogManager::GetLogger



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CLogManager::SendStatusReport(
//      LPCWSTR     pcszNodeNameIn,
//      CLSID       clsidTaskMajorIn,
//      CLSID       clsidTaskMinorIn,
//      ULONG       ulMinIn,
//      ULONG       ulMaxIn,
//      ULONG       ulCurrentIn,
//      HRESULT     hrStatusIn,
//      LPCWSTR     pcszDescriptionIn,
//      FILETIME *  pftTimeIn,
//      LPCWSTR     pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::SendStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CLogManager::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\managednetwork.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedNetwork.h
//
//  Description:
//      CManagedNetwork implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumManageableNetworks;

// CManagedNetwork
class CManagedNetwork
    : public IExtendObjectManager
    , public IClusCfgNetworkInfo
    , public IEnumClusCfgIPAddresses
    , public IGatherData  // Private Interface
{
friend class CEnumManageableNetworks;
private:
    // IUnknown
    LONG                m_cRef;

    // Async/IClusCfgNetworkInfo
    BSTR                m_bstrUID;                      // Unique Identifier
    BSTR                m_bstrName;                     // Display Name
    BSTR                m_bstrDescription;              // Description
    BOOL                m_fGathered;                    // TRUE if the object has already gathered its information
    BOOL                m_fHasNameChanged;              // If the name was changed by the user....
    BOOL                m_fHasDescriptionChanged;       // If the description was changed by the user...
    BOOL                m_fIsPublic;                    // If the interface is for public traffic...
    BOOL                m_fIsPrivate;                   // If the interface is for private traffic...
    IUnknown *          m_punkPrimaryAddress;           // Primary IP address info.
    ULONG               m_cAllocedIPs;                  //  Count of allocated IPs
    ULONG               m_cCurrentIPs;                  //  Count of currently used IPs
    ULONG               m_cIter;                        //  Iter counter
    IUnknown **         m_ppunkIPs;                     //  List of child IP addresses

    // IExtendObjectManager

private: // Methods
    CManagedNetwork( void );
    ~CManagedNetwork( void );
    STDMETHOD( HrInit )( void );
    STDMETHOD( EnumChildrenAndTransferInformation )( OBJECTCOOKIE cookieIn, IEnumClusCfgIPAddresses * pecciaIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNetworkInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );
    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );
    STDMETHOD( GetPrimaryNetworkAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut );
    STDMETHOD( SetPrimaryNetworkAddress )( IClusCfgIPAddressInfo * pIPAddressIn );
    STDMETHOD( IsPublic )( void );
    STDMETHOD( SetPublic )( BOOL fIsPublicIn );
    STDMETHOD( IsPrivate )( void );
    STDMETHOD( SetPrivate )( BOOL fIsPrivateIn );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

    // IEnumClusCfgIPAddresses
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** class CManagedNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\logmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      LogManager.h
//
//  Description:
//      Log Manager implementation.
//
//  Maintained By:
//      David Potter (DavidP)   07-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Forward Class Definitions
//////////////////////////////////////////////////////////////////////////////

class CLogManager;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CLogManager
//
//  Description:
//      Logs notifications to the log file.
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CLogManager
    : public ILogManager
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;                 // Reference counter.

    // ILogManager
    ILogger *           m_plLogger;             // ILogger for doing logging.

    // IClusCfgCallback
    OBJECTCOOKIE        m_cookieCompletion;     // Completion cookie.
    HRESULT             m_hrResult;             // Result of the analyze task.
    BSTR                m_bstrLogMsg;           // Reusable logging buffer.
    IConnectionPoint *  m_pcpcb;                // IClusCfgCallback Connection Point.
    DWORD               m_dwCookieCallback;     // Notification registration cookie.

private: // Methods
    CLogManager( void );
    ~CLogManager( void );
    STDMETHOD( HrInit )( void );

    // Private copy constructor to prevent copying.
    CLogManager( const CLogManager & );

    // Private assignment operator to prevent copying.
    CLogManager & operator=( const CLogManager & );

public: // Methods

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // ILogManager
    //
    STDMETHOD( StartLogging )( void );
    STDMETHOD( StopLogging )( void );
    STDMETHOD( GetLogger )( ILogger ** ppLoggerOut );

    //
    //  IClusCfgCallback
    //
    STDMETHOD( SendStatusReport )(
          LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

}; //*** class CLogManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\managedresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ManagedResource.cpp
//
//  Description:
//      CManagedResource implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ManagedResource.h"

DEFINE_THISCLASS("CManagedResource")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CManagedResource::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CManagedResource::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CManagedResource *  pmr = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pmr = new CManagedResource;
    if ( pmr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pmr->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pmr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pmr != NULL )
    {
        pmr->Release();
    }

    HRETURN( hr );

} //*** CManagedResource::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::CManagedResource
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedResource::CManagedResource( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedResource::CManagedResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::HrInit
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IClusCfgManagedResourceInfo
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_bstrType == NULL );
    Assert( m_fIsManaged == FALSE );
    Assert( m_fIsQuorumResource == FALSE );
    Assert( m_fIsQuorumCapable == FALSE );
    Assert( m_fIsQuorumResourceMultiNodeCapable == FALSE );
    Assert( m_pbPrivateData == NULL );
    Assert( m_cbPrivateData == 0 );
    Assert( m_cookieResourcePrivateData == 0 );
    Assert( m_cookieVerifyQuorum == 0 );

    Assert( m_dlmDriveLetterMapping.dluDrives[ 0 ] == dluUNKNOWN );

    // IExtendObjectManager

    Assert( m_pgit == NULL );
    hr = THR( CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                reinterpret_cast< void ** >( &m_pgit )
                                ) );

    HRETURN( hr );

} //*** CManagedResource::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::~CManagedResource
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedResource::~CManagedResource( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrUID );
    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrType );

    TraceFree( m_pbPrivateData );

    if ( m_pgit != NULL )
    {
        if ( m_cookieResourcePrivateData != 0 )
        {
            //
            //  TODO:   05-DEC-2001 GalenB
            //
            //  These THRs are causing invalid parameter popups.  Need to figure out why
            //  this is happening, but since it is a shutdown it is not a pressing need.
            //

            /*THR*/( m_pgit->RevokeInterfaceFromGlobal( m_cookieResourcePrivateData ) );
        } // if:

        if ( m_cookieVerifyQuorum != 0 )
        {
            /*THR*/( m_pgit->RevokeInterfaceFromGlobal( m_cookieVerifyQuorum ) );
        } // if:

        m_pgit->Release();
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedResource::~CManagedResource


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceData ) )
    {
        //
        //  If this cookie is not 0 then the server object's interface is in the GIT and it
        //  supported this interface.  If the server object supported the interface then we
        //  will too.
        //

        if ( m_cookieResourcePrivateData != 0 )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceData, this, 0 );
        } // if:
        else
        {
            *ppvOut = NULL;
            hr = E_NOINTERFACE;
        } // else:
    } // else if: IClusCfgManagedResourceData
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        //
        //  If this cookie is not 0 then the server object's interface is in the GIT and it
        //  supported this interface.  If the server object supported the interface then we
        //  will too.
        //

        if ( m_cookieVerifyQuorum != 0 )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
        } // if:
        else
        {
            *ppvOut = NULL;
            hr = E_NOINTERFACE;
        } // else:
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    //
    //  Since we don't always want to support IClusCfgManagedResourceData then we
    //  need to ignore it here since we don't want an errant pop-up complaining
    //  to the user that this interface is not supported.  It is expected that
    //  we won't always support this interface.
    //

    QIRETURN_IGNORESTDMARSHALLING2(
          hr
        , riidIn
        , IID_IClusCfgManagedResourceData
        , IID_IClusCfgVerifyQuorum
        );


} //*** CManagedResource::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedResource::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedResource::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CManagedResource::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedResource::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedResource::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CManagedResource::Release


// ************************************************************************
//
// IClusCfgManagedResourceInfo
//
// ************************************************************************


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::GetUID(
//      BSTR * pbstrUIDOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrUID == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CManagedResource::GetUID

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrName == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CManagedResource::GetName

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetName(
//      BSTR bstrNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK; // Bug #294649
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:
    HRETURN( hr );

} //*** CManagedResource::SetName

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::IsManaged
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedResource::IsManaged

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetManaged(
//      BOOL fIsManagedIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] fIsManagedIn = '%s'", BOOLTOSTRING( fIsManagedIn ) );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CManagedResource::SetManaged

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::IsQuorumResource
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumResource )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedResource::IsQuorumResource

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetQuorumResource(
//      BOOL fIsQuorumResourceIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetQuorumResource(
    BOOL fIsQuorumResourceIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] fIsQuorumResourceIn = '%ws'", BOOLTOSTRING( fIsQuorumResourceIn ) );

    //
    //  Since this is a client side proxy object for a server object there is no need
    //  to validate this input.  It will be validated by the server object if, and when,
    //  we send it down to the server...
    //

    m_fIsQuorumResource = fIsQuorumResourceIn;

    HRETURN( S_OK );

} //*** CManagedResource::SetQuorumResource

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::IsQuorumCapable
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

    HRETURN( hr );

} //*** CManagedResource::IsQuorumCapable

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetQuorumCapable
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CManagedResource::SetQuorumCapable

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::GetDriveLetterMappings(
//      SDriveLetterMapping * pdlmDriveLetterMappingOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    *pdlmDriveLetterMappingOut = m_dlmDriveLetterMapping;

    HRETURN( S_OK );

} //*** CManagedResource::GetDriveLetterMappings

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetDriveLetterMappings(
//      SDriveLetterMapping dlmDriveLetterMappingIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_dlmDriveLetterMapping = dlmDriveLetterMappingIn;

    HRETURN( S_OK );

} //*** CManagedResource::SetDriveLetterMappings

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::IsManagedByDefault
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsManagedByDefault )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedResource::IsManagedByDefault

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetManagedByDefault(
//      BOOL fIsManagedByDefaultIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] fIsManagedByDefaultIn = '%s'", BOOLTOSTRING( fIsManagedByDefaultIn ) );

    m_fIsManagedByDefault = fIsManagedByDefaultIn;

    HRETURN( S_OK );

} //*** CManagedResource::SetManagedByDefault


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::Gather
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::Gather(
      OBJECTCOOKIE    cookieParentIn
    , IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT                         hr;
    IClusCfgManagedResourceInfo *   pccmri = NULL;
    IClusCfgManagedResourceData *   piccmrd = NULL;
    BYTE *                          pbBuffer = NULL;
    DWORD                           cbBuffer = 0;
    IClusCfgVerifyQuorum *          piccvq = NULL;

    //
    //  Check parameters
    //

    if ( punkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Find the inteface we need to gather our info.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Gather UID
    //

    hr = THR( pccmri->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Gather Name
    //

    hr = THR( pccmri->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrName );

    //
    //  Gather IsManaged
    //

    hr = STHR( pccmri->IsManaged() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hr == S_OK )
    {
        m_fIsManaged = TRUE;
    }
    else
    {
        m_fIsManaged = FALSE;
    }

    //
    //  Gather IsManagedByDefault
    //

    hr = STHR( pccmri->IsManagedByDefault() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hr == S_OK )
    {
        m_fIsManagedByDefault = TRUE;
    }
    else
    {
        m_fIsManagedByDefault = FALSE;
    }

    //
    //  Gather Quorum Capable
    //

    hr = STHR( pccmri->IsQuorumCapable() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hr == S_OK )
    {
        m_fIsQuorumCapable = TRUE;
    }
    else
    {
        m_fIsQuorumCapable = FALSE;
    }

    //
    //  Gather if resource is the quorum resource.
    //

    hr = STHR( pccmri->IsQuorumResource() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        m_fIsQuorumResource = TRUE;
    }
    else
    {
        m_fIsQuorumResource = FALSE;
    }

    //
    //  Gather Device Mappings
    //

    hr = STHR( pccmri->GetDriveLetterMappings( &m_dlmDriveLetterMapping ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_FALSE )
    {
        //  Make sure this is nuked
        ZeroMemory( &m_dlmDriveLetterMapping, sizeof(m_dlmDriveLetterMapping) );
    }

    //
    //  Gather the resource's private data, if it supports it...
    //

    hr = punkIn->TypeSafeQI( IClusCfgManagedResourceData, &piccmrd );
    if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // if:
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Error;
    } // if:
    else
    {
        if ( m_cookieResourcePrivateData != 0 )
        {
            hr = THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieResourcePrivateData ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            m_cookieResourcePrivateData = 0;
        } // if:

        hr = THR( m_pgit->RegisterInterfaceInGlobal( piccmrd, IID_IClusCfgManagedResourceData, &m_cookieResourcePrivateData ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        Assert( m_pbPrivateData == NULL );

        cbBuffer = 512;      // pick some reasonable starting value

        pbBuffer = (BYTE *) TraceAlloc( 0, cbBuffer );
        if ( pbBuffer == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        hr = piccmrd->GetResourcePrivateData( pbBuffer, &cbBuffer );
        if ( hr == HR_RPC_INSUFFICIENT_BUFFER )
        {
            TraceFree( pbBuffer );
            pbBuffer = NULL;

            pbBuffer = (BYTE *) TraceAlloc( 0, cbBuffer );
            if ( pbBuffer == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            hr = piccmrd->GetResourcePrivateData( pbBuffer, &cbBuffer );
        } // if:

        if ( hr == S_OK )
        {
            m_pbPrivateData = pbBuffer;
            m_cbPrivateData = cbBuffer;

            pbBuffer = NULL;    // give away ownership
        } // if:
        else if ( hr == S_FALSE )
        {
            hr = S_OK;
        } // else if:
        else
        {
            THR( hr );
            goto Error;
        } // else:
    } // else:

    //
    //  Gather the resource's verify quorum interface, if it supports it...
    //

    hr = punkIn->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
    if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // if:
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Error;
    } // if:
    else
    {
        if ( m_cookieVerifyQuorum != 0 )
        {
            hr = THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieVerifyQuorum ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            m_cookieVerifyQuorum = 0;
        } // if:

        hr = THR( m_pgit->RegisterInterfaceInGlobal( piccvq, IID_IClusCfgVerifyQuorum, &m_cookieVerifyQuorum ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If this resource is quorum capable then gather its multi node support.
        //

        if ( m_fIsQuorumCapable )
        {
            //
            // Does this quorum resource support multi node clusters?
            //

            hr = STHR( piccvq->IsMultiNodeCapable() );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            if ( hr == S_OK )
            {
                m_fIsQuorumResourceMultiNodeCapable = TRUE;
            }
            else
            {
                m_fIsQuorumResourceMultiNodeCapable = FALSE;
            }
        } // if: device is quorum capable
        else
        {
            m_fIsQuorumResourceMultiNodeCapable = FALSE;
        }
    } // else:

    //
    //  Anything else to gather??
    //

    hr = S_OK;

    goto Cleanup;

Error:

    //
    //  On error, invalidate all data.
    //
    TraceSysFreeString( m_bstrUID );
    m_bstrUID = NULL;

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    TraceSysFreeString( m_bstrType );
    m_bstrType = NULL;

    m_fIsManaged = FALSE;
    m_fIsQuorumCapable = FALSE;
    m_fIsQuorumResourceMultiNodeCapable = FALSE;
    m_fIsQuorumResource = FALSE;

    ZeroMemory( &m_dlmDriveLetterMapping, sizeof( m_dlmDriveLetterMapping ) );

Cleanup:

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    if ( piccmrd != NULL )
    {
        piccmrd->Release();
    } // if:

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    TraceFree( pbBuffer );

    HRETURN( hr );

} //*** CManagedResource::Gather


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CManagedResource::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = S_OK;

    //
    //  Validate arguments.
    //

    if ( cookieIn == 0 )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( rclsidTypeIn != CLSID_ManagedResourceType )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( QueryInterface( DFGUID_ManagedResource, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CManagedResource::FindObject


// ************************************************************************
//
//  IClusCfgManagedResourceData
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::GetResourcePrivateData
//
//  Description:
//      Return the private data for this resource when it is hosted on the
//      cluster.
//
//  Arguments:
//      pbBufferOut
//
//      pcbBufferInout
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          No data available.
//
//      ERROR_INSUFFICIENT_BUFFER as an HRESULT
//          When the passed in buffer is too small to hold the data.
//          pcbBufferOutIn will contain the size required.
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::GetResourcePrivateData(
      BYTE *    pbBufferOut
    , DWORD *   pcbBufferInout
    )
{
    TraceFunc( "[IClusCfgManagedResourceData]" );
    Assert( pcbBufferInout != NULL );

    HRESULT hr = S_OK;
    DWORD   cb;

    if ( pcbBufferInout == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  There might not be any actual private data for the resource
    //  that we are proxying for.  All Middle Tier objects will
    //  support the IClusCfgManagedResourceData interface, even
    //  if the server side object does not.  S_FALSE is the way
    //  to indicate in the Middle Tier that there is no data
    //  available.
    //

    if ( ( m_pbPrivateData == NULL ) || ( m_cbPrivateData == 0 ) )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Save off the input buffer size.
    //

    cb = *pcbBufferInout;

    //
    //  Set the out param buffer size since we always want
    //  to return it.
    //

    *pcbBufferInout = m_cbPrivateData;

    if ( cb >= m_cbPrivateData )
    {
        Assert( pbBufferOut != NULL );
        CopyMemory( pbBufferOut, m_pbPrivateData, m_cbPrivateData );
    } // if:
    else
    {
        hr = HR_RPC_INSUFFICIENT_BUFFER;
    } // else:

Cleanup:

    HRETURN( hr );

} //*** CManagedResource::GetResourcePrivateData


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::SetResourcePrivateData
//
//  Description:
//      Accept the private data for this resource from another hosted instance
//      when this node is being added to the cluster.
//
//  Arguments:
//      pcbBufferIn
//
//      cbBufferIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetResourcePrivateData(
      const BYTE *  pcbBufferIn
    , DWORD         cbBufferIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceData]" );
    Assert( pcbBufferIn != NULL );
    Assert( cbBufferIn > 0 );
    Assert( m_cookieResourcePrivateData != 0 );
    Assert( m_pgit != NULL );

    HRESULT                         hr = S_OK;
    BYTE *                          pb = NULL;
    IClusCfgManagedResourceData *   piccmrd = NULL;

    if ( ( pcbBufferIn == NULL ) || ( cbBufferIn == 0 ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    pb = (BYTE * ) TraceAlloc( 0, cbBufferIn );
    if ( pb == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    CopyMemory( pb, pcbBufferIn, cbBufferIn );

    if ( ( m_pbPrivateData != NULL ) && ( m_cbPrivateData > 0 ) )
    {
        TraceFree( m_pbPrivateData );
    } // if:

    m_pbPrivateData = pb;
    m_cbPrivateData = cbBufferIn;

    //
    //  Now push the new data down to the server side object.
    //

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieResourcePrivateData, TypeSafeParams( IClusCfgManagedResourceData, &piccmrd ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccmrd->SetResourcePrivateData( m_pbPrivateData, m_cbPrivateData ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( piccmrd != NULL )
    {
        piccmrd->Release();
    } // if:

    HRETURN( hr );

} //*** CManagedResource::SetResourcePrivateData


// ************************************************************************
//
//  IClusCfgVerifyQuorum
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//      In this class we need to ensure that we can connect to the proper
//      disk share.  The data about what share to connect to should have
//      already been set using SetResourcePrivateData() above.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );
    Assert( m_cookieVerifyQuorum != 0 );
    Assert( m_pgit != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  piccvq = NULL;

    //
    //  Get the interface to the server object from the GIT.
    //

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieVerifyQuorum, TypeSafeParams( IClusCfgVerifyQuorum, &piccvq ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Call through to the server object.
    //

    hr = STHR( piccvq->PrepareToHostQuorumResource() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    HRETURN( hr );

} //*** CManagedResource::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedResource::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the share needs to be torn down.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );
    Assert( m_cookieVerifyQuorum != 0 );
    Assert( m_pgit != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  piccvq = NULL;

    //
    //  Get the interface to the server object from the GIT.
    //

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieVerifyQuorum, TypeSafeParams( IClusCfgVerifyQuorum, &piccvq ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Call through to the server object.
    //

    hr = STHR( piccvq->Cleanup( cccrReasonIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    HRETURN( hr );

} //*** CManagedResource::Cleanup

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::IsMultiNodeCapable
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumResourceMultiNodeCapable )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedResource::IsMultiNodeCapable


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedResource::SetMultiNodeCapable
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedResource::SetMultiNodeCapable( BOOL fMultiNodeCapableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CManagedResource::SetMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\middletierguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      MiddleTierGuids.h
//
//  Description:
//      This file contains the guids used in MiddleTier.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-FEB-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//
//  Minor Task IDs
//

// {342EAA5D-EF9E-49de-8A14-5E5463401020}
DEFINE_GUID( TASKID_Minor_BeginTask_CoCreate_Service_Manager,
0x342eaa5d, 0xef9e, 0x49de, 0x8a, 0x14, 0x5e, 0x54, 0x63, 0x40, 0x10, 0x20);

// {B798626A-CCE5-4403-9E89-714036AA7C6A}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_Notification_Manager,
0xb798626a, 0xcce5, 0x4403, 0x9e, 0x89, 0x71, 0x40, 0x36, 0xaa, 0x7c, 0x6a);

// {21CC21CB-FBD5-45c8-B6E1-A26E85DE426F}
DEFINE_GUID( TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint,
0x21cc21cb, 0xfbd5, 0x45c8, 0xb6, 0xe1, 0xa2, 0x6e, 0x85, 0xde, 0x42, 0x6f);

// {70DBDF3F-F4A3-46b7-BB99-E3E4A8FD3ECA}
DEFINE_GUID( TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint_QI_INotifyUI,
0x70dbdf3f, 0xf4a3, 0x46b7, 0xbb, 0x99, 0xe3, 0xe4, 0xa8, 0xfd, 0x3e, 0xca);

// {F0972FFF-4453-4047-84A6-9EC4076D4647}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_TaskManager,
0xf0972fff, 0x4453, 0x4047, 0x84, 0xa6, 0x9e, 0xc4, 0x7, 0x6d, 0x46, 0x47);

// {02BD5229-289B-4543-9CC5-103C818ED3FB}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_ObjectManager,
0x2bd5229, 0x289b, 0x4543, 0x9c, 0xc5, 0x10, 0x3c, 0x81, 0x8e, 0xd3, 0xfb);

// {001EEE37-48FA-46c3-AA76-ADF0AFB101B9}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject,
0x1eee37, 0x48fa, 0x46c3, 0xaa, 0x76, 0xad, 0xf0, 0xaf, 0xb1, 0x1, 0xb9);

// {6FC0DE15-0E2A-4b89-A7EE-0B23C76AF7BE}
DEFINE_GUID( TASKID_Minor_BeginTask_SetStatus,
0x6fc0de15, 0xe2a, 0x4b89, 0xa7, 0xee, 0xb, 0x23, 0xc7, 0x6a, 0xf7, 0xbe);

// {8B3CD36A-2128-48d9-8594-1FB2A8CFEBF8}
DEFINE_GUID( TASKID_Minor_BeginTask_ObjectChanged,
0x8b3cd36a, 0x2128, 0x48d9, 0x85, 0x94, 0x1f, 0xb2, 0xa8, 0xcf, 0xeb, 0xf8);

// {5456765D-BF37-4fc6-9B9D-4B0DFEB52F92}
DEFINE_GUID( TASKID_Minor_BeginTask_Win32Error,
0x5456765d, 0xbf37, 0x4fc6, 0x9b, 0x9d, 0x4b, 0xd, 0xfe, 0xb5, 0x2f, 0x92);

// {B4A70325-9676-4e9e-857E-C05DF11C0B4E}
DEFINE_GUID( TASKID_Minor_ObjectChanged_Win32Error,
0xb4a70325, 0x9676, 0x4e9e, 0x85, 0x7e, 0xc0, 0x5d, 0xf1, 0x1c, 0xb, 0x4e);

// {CACAF6D3-8701-4957-8E46-0DA460ADF87E}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateCompletionCookie,
0xcacaf6d3, 0x8701, 0x4957, 0x8e, 0x46, 0xd, 0xa4, 0x60, 0xad, 0xf8, 0x7e);

// {85F0D366-B2DE-45c4-BD17-91426E5217F5}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateTask,
0x85f0d366, 0xb2de, 0x45c4, 0xbd, 0x17, 0x91, 0x42, 0x6e, 0x52, 0x17, 0xf5);

// {1F4DD563-1033-4fef-8203-3F85AB303292}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateTask_QI,
0x1f4dd563, 0x1033, 0x4fef, 0x82, 0x3, 0x3f, 0x85, 0xab, 0x30, 0x32, 0x92);

// {C2665106-1D2F-4915-A383-C0A66A40FCB7}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SetCookie,
0xc2665106, 0x1d2f, 0x4915, 0xa3, 0x83, 0xc0, 0xa6, 0x6a, 0x40, 0xfc, 0xb7);

// {FF1193DA-A11A-4c2f-B8AB-D9B36C0AF6EC}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SetCompletionCookie,
0xff1193da, 0xa11a, 0x4c2f, 0xb8, 0xab, 0xd9, 0xb3, 0x6c, 0xa, 0xf6, 0xec);

// {D6DA7600-974B-4573-BC00-B1F47A478282}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SubmitTask,
0xd6da7600, 0x974b, 0x4573, 0xbc, 0x0, 0xb1, 0xf4, 0x7a, 0x47, 0x82, 0x82);

// {AE51A218-0D13-412b-B53B-B96C8FD37388}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetObject,
0xae51a218, 0xd13, 0x412b, 0xb5, 0x3b, 0xb9, 0x6c, 0x8f, 0xd3, 0x73, 0x88);

// {E59966AF-F01E-4398-8D80-737525C5320C}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetObject_QI,
0xe59966af, 0xf01e, 0x4398, 0x8d, 0x80, 0x73, 0x75, 0x25, 0xc5, 0x32, 0xc);

// {941FCD0F-2F59-48ea-9C9E-2354FCB12E7F}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetStatus,
0x941fcd0f, 0x2f59, 0x48ea, 0x9c, 0x9e, 0x23, 0x54, 0xfc, 0xb1, 0x2e, 0x7f);

// {FBC23EAD-AE0C-47f4-B2A6-97BB9E9C4DA5}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject,
0xfbc23ead, 0xae0c, 0x47f4, 0xb2, 0xa6, 0x97, 0xbb, 0x9e, 0x9c, 0x4d, 0xa5);

// {2EB0D9CE-D86E-47e9-87AA-B89534D2C5D0}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject_QI,
0x2eb0d9ce, 0xd86e, 0x47e9, 0x87, 0xaa, 0xb8, 0x95, 0x34, 0xd2, 0xc5, 0xd0);

// {ED7CC4A7-E681-4c3b-BD48-5C43A2C28331}
DEFINE_GUID( TASKID_Minor_WaitForCluster_OutOfMemory,
0xed7cc4a7, 0xe681, 0x4c3b, 0xbd, 0x48, 0x5c, 0x43, 0xa2, 0xc2, 0x83, 0x31);

// {FDB648B4-B632-4e3a-B4B6-0D9976DBB7ED}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetName,
0xfdb648b4, 0xb632, 0x4e3a, 0xb4, 0xb6, 0xd, 0x99, 0x76, 0xdb, 0xb7, 0xed);

// {31F05D8E-0E72-463a-89D4-6A20439A0D48}
DEFINE_GUID( TASKID_Minor_CountNodes_FindObject,
0x31f05d8e, 0xe72, 0x463a, 0x89, 0xd4, 0x6a, 0x20, 0x43, 0x9a, 0xd, 0x48);

// {C1683A23-F943-4539-A1CA-589E1BCE11FE}
DEFINE_GUID( TASKID_Minor_CountNodes_FindObject_QI,
0xc1683a23, 0xf943, 0x4539, 0xa1, 0xca, 0x58, 0x9e, 0x1b, 0xce, 0x11, 0xfe);

// {06B67A64-6F85-410b-BA5F-7DCA5172CD49}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_Count,
0x6b67a64, 0x6f85, 0x410b, 0xba, 0x5f, 0x7d, 0xca, 0x51, 0x72, 0xcd, 0x49);

// {547919D9-E4EF-4948-84F7-A8783C4B65AB}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_FindObject,
0x547919d9, 0xe4ef, 0x4948, 0x84, 0xf7, 0xa8, 0x78, 0x3c, 0x4b, 0x65, 0xab);

// {22BFD3BF-9077-46d0-BF7B-360E8B2E51EE}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_FindObject_QI,
0x22bfd3bf, 0x9077, 0x46d0, 0xbf, 0x7b, 0x36, 0xe, 0x8b, 0x2e, 0x51, 0xee);

// {5F9FCEDC-1FBC-4bec-9524-0BAD86D41F0C}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_OutOfMemory,
0x5f9fcedc, 0x1fbc, 0x4bec, 0x95, 0x24, 0xb, 0xad, 0x86, 0xd4, 0x1f, 0xc);

// {E1CB34AB-A503-434a-832D-E6FF0E3AFD22}
DEFINE_GUID( TASKID_Minor_GatherInformation_FindObject,
0xe1cb34ab, 0xa503, 0x434a, 0x83, 0x2d, 0xe6, 0xff, 0xe, 0x3a, 0xfd, 0x22);

// {135D7254-3E5F-4808-AF7A-E0F819242E7A}
DEFINE_GUID( TASKID_Minor_GatherInformation_FindObject_QI,
0x135d7254, 0x3e5f, 0x4808, 0xaf, 0x7a, 0xe0, 0xf8, 0x19, 0x24, 0x2e, 0x7a);

// {C764E6DC-A61A-43cb-A94F-4C75ADDCB0FA}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_Next,
0xc764e6dc, 0xa61a, 0x43cb, 0xa9, 0x4f, 0x4c, 0x75, 0xad, 0xdc, 0xb0, 0xfa);

// {00910AE8-2DF8-498a-8D95-D6B4C377CC20}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetObject,
0x910ae8, 0x2df8, 0x498a, 0x8d, 0x95, 0xd6, 0xb4, 0xc3, 0x77, 0xcc, 0x20);

// {82649EC7-6277-4eb5-82F7-EA149FA0C59F}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetObject_QI,
0x82649ec7, 0x6277, 0x4eb5, 0x82, 0xf7, 0xea, 0x14, 0x9f, 0xa0, 0xc5, 0x9f);

// {A3A398A5-B508-4b14-B1F5-B9D703FC8B84}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetName,
0xa3a398a5, 0xb508, 0x4b14, 0xb1, 0xf5, 0xb9, 0xd7, 0x3, 0xfc, 0x8b, 0x84);

// {826AE014-19E5-41b2-89BC-8511FEE95D7A}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject,
0x826ae014, 0x19e5, 0x41b2, 0x89, 0xbc, 0x85, 0x11, 0xfe, 0xe9, 0x5d, 0x7a);

// {C60A3304-DE02-427a-8A2E-F6269AC8FB0D}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject_QI,
0xc60a3304, 0xde02, 0x427a, 0x8a, 0x2e, 0xf6, 0x26, 0x9a, 0xc8, 0xfb, 0xd);

// {5F1F6DBB-ED39-4951-AF43-AEE096894118}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CreateTask,
0x5f1f6dbb, 0xed39, 0x4951, 0xaf, 0x43, 0xae, 0xe0, 0x96, 0x89, 0x41, 0x18);

// {62B97544-6D8F-4631-A98F-BB51174CDC1C}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_QI_GatherNodeInfo,
0x62b97544, 0x6d8f, 0x4631, 0xa9, 0x8f, 0xbb, 0x51, 0x17, 0x4c, 0xdc, 0x1c);

// {BC27FEBB-2EE4-44e3-9446-007E196FDA14}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetCompletionCookie,
0xbc27febb, 0x2ee4, 0x44e3, 0x94, 0x46, 0x0, 0x7e, 0x19, 0x6f, 0xda, 0x14);

// {E7A6830C-E8E8-4398-9A69-63F97B1CED51}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetCookie,
0xe7a6830c, 0xe8e8, 0x4398, 0x9a, 0x69, 0x63, 0xf9, 0x7b, 0x1c, 0xed, 0x51);

// {EBFFD21B-8C76-4b59-A6B2-710F6B632982}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetJoining,
0xebffd21b, 0x8c76, 0x4b59, 0xa6, 0xb2, 0x71, 0xf, 0x6b, 0x63, 0x29, 0x82);

// {387AA6B4-27E8-43fc-A648-077476D475C7}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SubmitTask,
0x387aa6b4, 0x27e8, 0x43fc, 0xa6, 0x48, 0x7, 0x74, 0x76, 0xd4, 0x75, 0xc7);

// {D95A524F-09F7-4635-A5FF-E776129C992D}
DEFINE_GUID( TASKID_Minor_GatherInformation_GetStatus,
0xd95a524f, 0x9f7, 0x4635, 0xa5, 0xff, 0xe7, 0x76, 0x12, 0x9c, 0x99, 0x2d);

// {41CE2C9D-A57E-4bde-A9AA-2309ED15F241}
DEFINE_GUID( TASKID_Minor_GatherInformation_OutOfMemory,
0x41ce2c9d, 0xa57e, 0x4bde, 0xa9, 0xaa, 0x23, 0x9, 0xed, 0x15, 0xf2, 0x41);

// {F7BB5004-500F-4094-A7F7-95742D4AFD5D}
DEFINE_GUID( TASKID_Minor_BeginTask_Advise,
0xf7bb5004, 0x500f, 0x4094, 0xa7, 0xf7, 0x95, 0x74, 0x2d, 0x4a, 0xfd, 0x5d);

// {CDA70081-9627-4671-BBC3-0FA65B93A5ED}
DEFINE_GUID( TASKID_Minor_BeginTask_Unadvise,
0xcda70081, 0x9627, 0x4671, 0xbb, 0xc3, 0xf, 0xa6, 0x5b, 0x93, 0xa5, 0xed);

// {E3300019-A3AE-4f3e-87DB-599EAE8FB7C9}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_Next,
0xe3300019, 0xa3ae, 0x4f3e, 0x87, 0xdb, 0x59, 0x9e, 0xae, 0x8f, 0xb7, 0xc9);

// {7ED16DED-D6FD-4c39-B922-DAFCB7837C6D}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetName,
0x7ed16ded, 0xd6fd, 0x4c39, 0xb9, 0x22, 0xda, 0xfc, 0xb7, 0x83, 0x7c, 0x6d);

// {8C2523D6-3530-4915-8749-EA9498D72207}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CreateTask,
0x8c2523d6, 0x3530, 0x4915, 0x87, 0x49, 0xea, 0x94, 0x98, 0xd7, 0x22, 0x7);

// {DCDC9B6A-A9E6-4919-B5FD-E859BEC1FACA}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_QI_GatherNodeInfo,
0xdcdc9b6a, 0xa9e6, 0x4919, 0xb5, 0xfd, 0xe8, 0x59, 0xbe, 0xc1, 0xfa, 0xca);

// {52FEE1B7-B603-4942-A508-2FE991A9ABD4}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetCookie,
0x52fee1b7, 0xb603, 0x4942, 0xa5, 0x8, 0x2f, 0xe9, 0x91, 0xa9, 0xab, 0xd4);

// {9AF871B2-C843-4086-8AC3-28755E078BDB}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetCompletionCookie,
0x9af871b2, 0xc843, 0x4086, 0x8a, 0xc3, 0x28, 0x75, 0x5e, 0x7, 0x8b, 0xdb);

// {70FC1231-B5DE-463b-B30C-C93A6C74C64E}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject,
0x70fc1231, 0xb5de, 0x463b, 0xb3, 0xc, 0xc9, 0x3a, 0x6c, 0x74, 0xc6, 0x4e);

// {D34C8E79-EDF3-4aaa-9B6C-CB439F654088}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject_QI,
0xd34c8e79, 0xedf3, 0x4aaa, 0x9b, 0x6c, 0xcb, 0x43, 0x9f, 0x65, 0x40, 0x88);

// {CF14436D-2012-4652-A34D-A572B3445A2F}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SubmitTask,
0xcf14436d, 0x2012, 0x4652, 0xa3, 0x4d, 0xa5, 0x72, 0xb3, 0x44, 0x5a, 0x2f);

// {72A04E74-2D14-4ad8-8E12-4AFBA56FD0E0}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes, 
0x72a04e74, 0x2d14, 0x4ad8, 0x8e, 0x12, 0x4a, 0xfb, 0xa5, 0x6f, 0xd0, 0xe0);

// {9AEB5CCD-C7CF-4890-9BDD-238E8F68C101}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_FindObject,
0x9aeb5ccd, 0xc7cf, 0x4890, 0x9b, 0xdd, 0x23, 0x8e, 0x8f, 0x68, 0xc1, 0x1);

// {B9C3B658-477D-4ed1-A92D-B7CF2D11D751}
DEFINE_GUID( TASKID_Minor_CheckMembership_FindObject,
0xb9c3b658, 0x477d, 0x4ed1, 0xa9, 0x2d, 0xb7, 0xcf, 0x2d, 0x11, 0xd7, 0x51);

// {C96092B1-FCAE-41b3-89DE-BC8970395C9F}
DEFINE_GUID( TASKID_Minor_CheckMembership_FindObject_QI,
0xc96092b1, 0xfcae, 0x41b3, 0x89, 0xde, 0xbc, 0x89, 0x70, 0x39, 0x5c, 0x9f);

// {40A6A866-D4F1-44eb-A201-2B73CD4EE7F0}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_Next,
0x40a6a866, 0xd4f1, 0x44eb, 0xa2, 0x1, 0x2b, 0x73, 0xcd, 0x4e, 0xe7, 0xf0);

// {14757B27-5DDC-4309-A726-CB2485D29C44}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_IsMemberOfCluster,
0x14757b27, 0x5ddc, 0x4309, 0xa7, 0x26, 0xcb, 0x24, 0x85, 0xd2, 0x9c, 0x44);

// {9F022D5F-47D4-4aa1-96EB-CB10FD42DEFF}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetClusterConfigInfo,
0x9f022d5f, 0x47d4, 0x4aa1, 0x96, 0xeb, 0xcb, 0x10, 0xfd, 0x42, 0xde, 0xff);

// {D8AD7746-5724-484b-A98D-990E5C956E43}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetName,
0xd8ad7746, 0x5724, 0x484b, 0xa9, 0x8d, 0x99, 0xe, 0x5c, 0x95, 0x6e, 0x43);

// {318F9A4A-B4A9-4762-B45E-0A87FAB04D00}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetNodeName,
0x318f9a4a, 0xb4a9, 0x4762, 0xb4, 0x5e, 0xa, 0x87, 0xfa, 0xb0, 0x4d, 0x0);

// {045D9A03-BED1-47b5-A8B9-69D5E05B0D1F}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_FormatMessage,
0x45d9a03, 0xbed1, 0x47b5, 0xa8, 0xb9, 0x69, 0xd5, 0xe0, 0x5b, 0xd, 0x1f);

// {EA7534CF-7B9A-453f-B18C-7231158BD08D}
DEFINE_GUID( TASKID_Minor_CheckMembership_FormatMessage,
0xea7534cf, 0x7b9a, 0x453f, 0xb1, 0x8c, 0x72, 0x31, 0x15, 0x8b, 0xd0, 0x8d);

// {865756F5-BF17-4ab9-92AE-2C505639C2F8}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains, 
0x865756f5, 0xbf17, 0x4ab9, 0x92, 0xae, 0x2c, 0x50, 0x56, 0x39, 0xc2, 0xf8);

// {6365C266-455B-41a9-A38D-B282503C8A4D}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_HrFindDomainInClusterFQN, 
0x6365c266, 0x455b, 0x41a9, 0xa3, 0x8d, 0xb2, 0x82, 0x50, 0x3c, 0x8a, 0x4d);

// {173799DB-D5FB-474a-AE35-64EAF23A108B}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_FindObject, 
0x173799db, 0xd5fb, 0x474a, 0xae, 0x35, 0x64, 0xea, 0xf2, 0x3a, 0x10, 0x8b);

// {38C1F1E3-028E-4bdb-81C6-0CF1C4A211CA}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_QI, 
0x38c1f1e3, 0x28e, 0x4bdb, 0x81, 0xc6, 0xc, 0xf1, 0xc4, 0xa2, 0x11, 0xca);

// {8FC4E667-4FB8-414a-AB51-7920725DBDED}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_Count, 
0x8fc4e667, 0x4fb8, 0x414a, 0xab, 0x51, 0x79, 0x20, 0x72, 0x5d, 0xbd, 0xed);

// {81F83A94-38EE-4bd7-820E-21945AD063D8}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_New, 
0x81f83a94, 0x38ee, 0x4bd7, 0x82, 0xe, 0x21, 0x94, 0x5a, 0xd0, 0x63, 0xd8);

// {83ECD619-B2F5-47c1-85E1-E7588AD0F04A}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_Next, 
0x83ecd619, 0xb2f5, 0x47c1, 0x85, 0xe1, 0xe7, 0x58, 0x8a, 0xd0, 0xf0, 0x4a);

// {53BB4986-3F87-4370-820A-5DE36ADFC6C3}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_GetName, 
0x53bb4986, 0x3f87, 0x4370, 0x82, 0xa, 0x5d, 0xe3, 0x6a, 0xdf, 0xc6, 0xc3);

// {D4DF6184-025D-431d-BDDB-905A789B74F8}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_HrFindDomainInNodeFQN, 
0xd4df6184, 0x25d, 0x431d, 0xbd, 0xdb, 0x90, 0x5a, 0x78, 0x9b, 0x74, 0xf8);

// {D4140D9F-1EB7-405d-9E33-076482DA294B}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_FormatMessage, 
0xd4140d9f, 0x1eb7, 0x405d, 0x9e, 0x33, 0x7, 0x64, 0x82, 0xda, 0x29, 0x4b);

// {356D737D-2756-4b87-831B-44A8FEAC3448}
DEFINE_GUID( TASKID_Minor_CheckNodeDomains_LoadString, 
0x356d737d, 0x2756, 0x4b87, 0x83, 0x1b, 0x44, 0xa8, 0xfe, 0xac, 0x34, 0x48);

// {822A1887-125A-424a-B5B1-A8ADEEFD184E}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Find_Object_QI,
0x822a1887, 0x125a, 0x424a, 0xb5, 0xb1, 0xa8, 0xad, 0xee, 0xfd, 0x18, 0x4e);

// {42E2F3FE-156A-4cd4-946F-97DCBEC2C186}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Next,
0x42e2f3fe, 0x156a, 0x4cd4, 0x94, 0x6f, 0x97, 0xdc, 0xbe, 0xc2, 0xc1, 0x86);

// {0E172EB7-4FFB-40d7-8990-01C0F04CFA66}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Reset_Node_Enumerator,
0xe172eb7, 0x4ffb, 0x40d7, 0x89, 0x90, 0x1, 0xc0, 0xf0, 0x4c, 0xfa, 0x66);

// {9640D17D-9909-41d4-BE3E-FB10D9E66F61}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Skip_To_Node,
0x9640d17d, 0x9909, 0x41d4, 0xbe, 0x3e, 0xfb, 0x10, 0xd9, 0xe6, 0x6f, 0x61);

// {6DCF3C66-AA7C-439b-A6DE-E8483E15ED1A}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Find_Outer_Node_Next,
0x6dcf3c66, 0xaa7c, 0x439b, 0xa6, 0xde, 0xe8, 0x48, 0x3e, 0x15, 0xed, 0x1a);

// {1C2FD906-9A61-4026-971F-6531024BB37C}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_FindObject,
0x1c2fd906, 0x9a61, 0x4026, 0x97, 0x1f, 0x65, 0x31, 0x2, 0x4b, 0xb3, 0x7c);

// {36F87D37-E163-4963-902B-8002D6094FE9}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_FindObject_QI,
0x36f87d37, 0xe163, 0x4963, 0x90, 0x2b, 0x80, 0x2, 0xd6, 0x9, 0x4f, 0xe9);

// {CD1941CD-AD7E-48d9-94DC-06DDE0F08DAA}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_GetDLM,
0xcd1941cd, 0xad7e, 0x48d9, 0x94, 0xdc, 0x6, 0xdd, 0xe0, 0xf0, 0x8d, 0xaa);

// {6CB8B165-D342-46ba-9317-214A881E8BFE}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_GetNodeName,
0x6cb8b165, 0xd342, 0x46ba, 0x93, 0x17, 0x21, 0x4a, 0x88, 0x1e, 0x8b, 0xfe);

// {51D2D015-0EAE-414d-9BE9-1C36F50A81EE}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Find_Inner_Node_Next,
0x51d2d015, 0xeae, 0x414d, 0x9b, 0xe9, 0x1c, 0x36, 0xf5, 0xa, 0x81, 0xee);

// {918A6180-7140-4048-BB39-775DACEC0668}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_FindObject,
0x918a6180, 0x7140, 0x4048, 0xbb, 0x39, 0x77, 0x5d, 0xac, 0xec, 0x6, 0x68);

// {82DDA1FC-7DA9-4367-AB57-2148B3E34BE0}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_FindObject_QI,
0x82dda1fc, 0x7da9, 0x4367, 0xab, 0x57, 0x21, 0x48, 0xb3, 0xe3, 0x4b, 0xe0);

// {EA3D3ED3-D429-434e-865A-99A3A7DB971E}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_GetDLM,
0xea3d3ed3, 0xd429, 0x434e, 0x86, 0x5a, 0x99, 0xa3, 0xa7, 0xdb, 0x97, 0x1e);

// {6FC10675-2BD6-40e5-8DCB-5B7AC77CEDAD}
DEFINE_GUID( TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_GetNodeName,
0x6fc10675, 0x2bd6, 0x40e5, 0x8d, 0xcb, 0x5b, 0x7a, 0xc7, 0x7c, 0xed, 0xad);

// {9967C0A3-97A4-473c-BE64-89BE5E28ACBB}
DEFINE_GUID( TASKID_Minor_System_Drive_Letter_Conflict_Error,
0x9967c0a3, 0x97a4, 0x473c, 0xbe, 0x64, 0x89, 0xbe, 0x5e, 0x28, 0xac, 0xbb);

// {5C127BC8-40C5-427b-92B1-0D70A369C1BF}
DEFINE_GUID( TASKID_Minor_System_Drive_Letter_Conflict_Warning,
0x5c127bc8, 0x40c5, 0x427b, 0x92, 0xb1, 0xd, 0x70, 0xa3, 0x69, 0xc1, 0xbf);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Find_Formed_Node,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Find_Formed_Node_Next,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_CompareNetworks_NodeInfo_FindObject,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_CompareResources_NodeInfo_FindObject_QI,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {932AACD5-2D37-4c51-B2FF-E279FF2BF96D}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object,
0x932aacd5, 0x2d37, 0x4c51, 0xb2, 0xff, 0xe2, 0x79, 0xff, 0x2b, 0xf9, 0x6d);

// {B8F19E4E-D34E-4740-833A-99265A33A5E0}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object_QI,
0xb8f19e4e, 0xd34e, 0x4740, 0x83, 0x3a, 0x99, 0x26, 0x5a, 0x33, 0xa5, 0xe0);

// {18EAD8A8-9E7D-4885-9360-15AE2E7D4148}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Next,
0x18ead8a8, 0x9e7d, 0x4885, 0x93, 0x60, 0x15, 0xae, 0x2e, 0x7d, 0x41, 0x48);

// {C4896D7E-F32A-4a79-8F02-E0D5005BFBA1}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Get_Quorum_UID,
0xc4896d7e, 0xf32a, 0x4a79, 0x8f, 0x2, 0xe0, 0xd5, 0x0, 0x5b, 0xfb, 0xa1);

// {ADFBE9CD-AC9B-450c-9655-2ADD2E414580}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Reset,
0xadfbe9cd, 0xac9b, 0x450c, 0x96, 0x55, 0x2a, 0xdd, 0x2e, 0x41, 0x45, 0x80);

// {74F939BF-6C06-40ca-9D23-9E7EF8147217}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Next,
0x74f939bf, 0x6c06, 0x40ca, 0x9d, 0x23, 0x9e, 0x7e, 0xf8, 0x14, 0x72, 0x17);

// {C4B183CF-9C19-4ed5-BF95-A52170EC5CA9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object,
0xc4b183cf, 0x9c19, 0x4ed5, 0xbf, 0x95, 0xa5, 0x21, 0x70, 0xec, 0x5c, 0xa9);

// {260446BA-0D48-468a-B6F4-F14A315AF771}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object_QI,
0x260446ba, 0xd48, 0x468a, 0xb6, 0xf4, 0xf1, 0x4a, 0x31, 0x5a, 0xf7, 0x71);

// {C7115544-E677-4700-9065-D6E4B7472E2B}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Next,
0xc7115544, 0xe677, 0x4700, 0x90, 0x65, 0xd6, 0xe4, 0xb7, 0x47, 0x2e, 0x2b);

// {18E698F5-6F9F-40d4-A81B-3D711F8B46A8}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetUID,
0x18e698f5, 0x6f9f, 0x40d4, 0xa8, 0x1b, 0x3d, 0x71, 0x1f, 0x8b, 0x46, 0xa8);

// {45FA6F19-83D3-4597-8383-E427685A9654}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetName,
0x45fa6f19, 0x83d3, 0x4597, 0x83, 0x83, 0xe4, 0x27, 0x68, 0x5a, 0x96, 0x54);

// {241B61F5-08D9-45b2-83A6-CB2632E25556}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object,
0x241b61f5, 0x8d9, 0x45b2, 0x83, 0xa6, 0xcb, 0x26, 0x32, 0xe2, 0x55, 0x56);

// {100CC244-19CC-4f22-B1CF-9E4CB97F1589}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object_QI,
0x100cc244, 0x19cc, 0x4f22, 0xb1, 0xcf, 0x9e, 0x4c, 0xb9, 0x7f, 0x15, 0x89);

// {ED0C2913-F414-4cad-A87B-AD03B5B3EFF9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Next,
0xed0c2913, 0xf414, 0x4cad, 0xa8, 0x7b, 0xad, 0x3, 0xb5, 0xb3, 0xef, 0xf9);

// {6D2B1639-5F69-4638-8091-C94421FD5690}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetUID,
0x6d2b1639, 0x5f69, 0x4638, 0x80, 0x91, 0xc9, 0x44, 0x21, 0xfd, 0x56, 0x90);

// {1FD0B09A-42FC-4d2e-82FB-AF2B80899578}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetName,
0x1fd0b09a, 0x42fc, 0x4d2e, 0x82, 0xfb, 0xaf, 0x2b, 0x80, 0x89, 0x95, 0x78);

// {C2B337AF-F069-4f51-B094-AC1E52237E81}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsManageable,
0xc2b337af, 0xf069, 0x4f51, 0xb0, 0x94, 0xac, 0x1e, 0x52, 0x23, 0x7e, 0x81);

// {351ED057-2974-4e13-96F5-4D0B25119736}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetManaged,
0x351ed057, 0x2974, 0x4e13, 0x96, 0xf5, 0x4d, 0xb, 0x25, 0x11, 0x97, 0x36);

// {64F7FADA-E29F-4bff-A7AA-D9AE2D4C6FF9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetResName,
0x64f7fada, 0xe29f, 0x4bff, 0xa7, 0xaa, 0xd9, 0xae, 0x2d, 0x4c, 0x6f, 0xf9);

// {22F2511B-D66E-4293-B14E-54BDF79F0AEC}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Cluster,
0x22f2511b, 0xd66e, 0x4293, 0xb1, 0x4e, 0x54, 0xbd, 0xf7, 0x9f, 0xa, 0xec);

// {3A68E842-092B-42f8-B3DC-AFD27FFF70F1}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_GetUID,
0x3a68e842, 0x92b, 0x42f8, 0xb3, 0xdc, 0xaf, 0xd2, 0x7f, 0xff, 0x70, 0xf1);

// {1A4108DF-BD13-4032-9CBF-36626658F156}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_True,
0x1a4108df, 0xbd13, 0x4032, 0x9c, 0xbf, 0x36, 0x62, 0x66, 0x58, 0xf1, 0x56);

// {26D53BBF-7649-4d90-9C32-EF4CBFB834AE}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_False,
0x26d53bbf, 0x7649, 0x4d90, 0x9c, 0x32, 0xef, 0x4c, 0xbf, 0xb8, 0x34, 0xae);

// {066375FC-9F94-4cc1-BF6A-3676E2733619}
DEFINE_GUID( TASKID_Minor_Create_Resource_GetUID,
0x66375fc, 0x9f94, 0x4cc1, 0xbf, 0x6a, 0x36, 0x76, 0xe2, 0x73, 0x36, 0x19);

// {BD8FF82B-9C3B-420f-892E-80B0E484F2F5}
DEFINE_GUID( TASKID_Minor_Create_Resource_FindObject,
0xbd8ff82b, 0x9c3b, 0x420f, 0x89, 0x2e, 0x80, 0xb0, 0xe4, 0x84, 0xf2, 0xf5);

// {C87EA962-1711-49db-9FDB-ED4768BA8701}
DEFINE_GUID( TASKID_Minor_Create_Resource_FindObject_QI,
0xc87ea962, 0x1711, 0x49db, 0x9f, 0xdb, 0xed, 0x47, 0x68, 0xba, 0x87, 0x1);

// {8A8DB3C4-4AC9-4746-9B09-3442735020A5}
DEFINE_GUID( TASKID_Minor_Create_Resource_Gather,
0x8a8db3c4, 0x4ac9, 0x4746, 0x9b, 0x9, 0x34, 0x42, 0x73, 0x50, 0x20, 0xa5);

// {135F96E8-3C89-48ec-AF53-46424621033D}
DEFINE_GUID( TASKID_Minor_Create_Resource_QI,
0x135f96e8, 0x3c89, 0x48ec, 0xaf, 0x53, 0x46, 0x42, 0x46, 0x21, 0x3, 0x3d);

// {FDF30CC5-B392-4ddb-8CA6-360AC8138C69}
DEFINE_GUID( TASKID_Minor_Check_Common_FindObject,
0xfdf30cc5, 0xb392, 0x4ddb, 0x8c, 0xa6, 0x36, 0xa, 0xc8, 0x13, 0x8c, 0x69);

// {8D801358-7C6B-4699-9DAE-E4E7C0CED09D}
DEFINE_GUID( TASKID_Minor_Check_Common_FindObject_QI,
0x8d801358, 0x7c6b, 0x4699, 0x9d, 0xae, 0xe4, 0xe7, 0xc0, 0xce, 0xd0, 0x9d);

// {DC8A5E76-FE76-41ef-9171-EFFC272C81B4}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Next,
0xdc8a5e76, 0xfe76, 0x41ef, 0x91, 0x71, 0xef, 0xfc, 0x27, 0x2c, 0x81, 0xb4);

// {F0DABE6E-348F-4308-BC7E-5C781536E938}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_FindObject,
0xf0dabe6e, 0x348f, 0x4308, 0xbc, 0x7e, 0x5c, 0x78, 0x15, 0x36, 0xe9, 0x38);

// {8A3EB407-824F-4908-B675-3F2C79A4A2FF}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_FindObject_QI,
0x8a3eb407, 0x824f, 0x4908, 0xb6, 0x75, 0x3f, 0x2c, 0x79, 0xa4, 0xa2, 0xff);

// {79D4E66E-D75B-4492-8383-3D322E128551}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_Next,
0x79d4e66e, 0xd75b, 0x4492, 0x83, 0x83, 0x3d, 0x32, 0x2e, 0x12, 0x85, 0x51);

// {2D2D5E3B-F524-4a29-B969-F7274315C102}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_GetUID,
0x2d2d5e3b, 0xf524, 0x4a29, 0xb9, 0x69, 0xf7, 0x27, 0x43, 0x15, 0xc1, 0x2);

// {EE31B8EE-4588-4475-AFBF-9920B8E7F557}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_FindObject,
0xee31b8ee, 0x4588, 0x4475, 0xaf, 0xbf, 0x99, 0x20, 0xb8, 0xe7, 0xf5, 0x57);

// {F02940F8-B2FB-4dc7-9A06-10EFE276CFB5}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_FindObject_QI,
0xf02940f8, 0xb2fb, 0x4dc7, 0x9a, 0x6, 0x10, 0xef, 0xe2, 0x76, 0xcf, 0xb5);

// {5152ACA0-2011-4ac8-ACC7-B5BA6A300A66}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Next,
0x5152aca0, 0x2011, 0x4ac8, 0xac, 0xc7, 0xb5, 0xba, 0x6a, 0x30, 0xa, 0x66);

// {DA0CA708-E77B-46e8-A6E3-F18D1FBC95E0}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumResources_FindObject,
0xda0ca708, 0xe77b, 0x46e8, 0xa6, 0xe3, 0xf1, 0x8d, 0x1f, 0xbc, 0x95, 0xe0);

// {5F1CD55C-4581-42f0-A474-2A95A22987AD}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumResources_FindObject_QI,
0x5f1cd55c, 0x4581, 0x42f0, 0xa4, 0x74, 0x2a, 0x95, 0xa2, 0x29, 0x87, 0xad);

// {A47B3BA8-E3FB-4ddf-A38C-D90B38408E59}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetwork_Next,
0xa47b3ba8, 0xe3fb, 0x4ddf, 0xa3, 0x8c, 0xd9, 0xb, 0x38, 0x40, 0x8e, 0x59);

// {A1CA99F5-7109-484e-97A4-782681ACA8B3}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_NextNode,
0xa1ca99f5, 0x7109, 0x484e, 0x97, 0xa4, 0x78, 0x26, 0x81, 0xac, 0xa8, 0xb3);

// {B389AF6F-19B1-4e2f-B625-77AF3630272D}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Next_FindObject,
0xb389af6f, 0x19b1, 0x4e2f, 0xb6, 0x25, 0x77, 0xaf, 0x36, 0x30, 0x27, 0x2d);

// {1837239C-C526-4121-A76E-0A5E0CEABDC0}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Reset,
0x1837239c, 0xc526, 0x4121, 0xa7, 0x6e, 0xa, 0x5e, 0xc, 0xea, 0xbd, 0xc0);

// {297F270C-F27E-4f22-9FFE-DD6D29FBE296}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Next,
0x297f270c, 0xf27e, 0x4f22, 0x9f, 0xfe, 0xdd, 0x6d, 0x29, 0xfb, 0xe2, 0x96);

// {A6DA4ED7-B022-4837-AC90-78DF0B788064}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_GetUID,
0xa6da4ed7, 0xb022, 0x4837, 0xac, 0x90, 0x78, 0xdf, 0xb, 0x78, 0x80, 0x64);

// {4CD0FECB-B1C7-49dc-AB03-5D014919E421}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject,
0x4cd0fecb, 0xb1c7, 0x49dc, 0xab, 0x3, 0x5d, 0x1, 0x49, 0x19, 0xe4, 0x21);

// {33A004D1-B5CA-4a15-B752-93D64E69C647}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject_QI,
0x33a004d1, 0xb5ca, 0x4a15, 0xb7, 0x52, 0x93, 0xd6, 0x4e, 0x69, 0xc6, 0x47);

// {AC7F4906-4CB0-47ca-B214-3912C79BE775}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_Next,
0xac7f4906, 0x4cb0, 0x47ca, 0xb2, 0x14, 0x39, 0x12, 0xc7, 0x9b, 0xe7, 0x75);

// {5C9D5D27-CFA9-4a1a-A967-0C91C1E783E2}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_IsPublic,
0x5c9d5d27, 0xcfa9, 0x4a1a, 0xa9, 0x67, 0xc, 0x91, 0xc1, 0xe7, 0x83, 0xe2);

// {30CCB655-3AE5-42df-8450-815296960705}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_IsPrivate,
0x30ccb655, 0x3ae5, 0x42df, 0x84, 0x50, 0x81, 0x52, 0x96, 0x96, 0x7, 0x5);

// {9BEE7C48-9BF3-4185-9064-83A40F4FD7D5}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_GetUID,
0x9bee7c48, 0x9bf3, 0x4185, 0x90, 0x64, 0x83, 0xa4, 0xf, 0x4f, 0xd7, 0xd5);

// {20F9961D-88BB-4f84-B37B-96C8AF50EE22}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_IsPublicNetworkAvailable,
0x20f9961d, 0x88bb, 0x4f84, 0xb3, 0x7b, 0x96, 0xc8, 0xaf, 0x50, 0xee, 0x22);

// {898B5BE8-8EF7-4174-9870-51794F17DCEB}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_IsPrivateNetworkAvailable,
0x898b5be8, 0x8ef7, 0x4174, 0x98, 0x70, 0x51, 0x79, 0x4f, 0x17, 0xdc, 0xeb);

// {2B3DA2F5-2FE4-4ebf-8329-8E468658C86A}
DEFINE_GUID( TASKID_Minor_CompareNetworks_IsPublic_FormatMessage,
0x2b3da2f5, 0x2fe4, 0x4ebf, 0x83, 0x29, 0x8e, 0x46, 0x86, 0x58, 0xc8, 0x6a);

// {B4662124-8936-4ea5-9A10-BB9D561B7ADA}
DEFINE_GUID( TASKID_Minor_CompareNetworks_IsPrivate_FormatMessage,
0xb4662124, 0x8936, 0x4ea5, 0x9a, 0x10, 0xbb, 0x9d, 0x56, 0x1b, 0x7a, 0xda);

// {6438F7AF-767C-46d2-8A5E-F0589D97951C}
DEFINE_GUID( TASKID_Minor_CreateNetwork_GetUID,
0x6438f7af, 0x767c, 0x46d2, 0x8a, 0x5e, 0xf0, 0x58, 0x9d, 0x97, 0x95, 0x1c);

// {97FEC5B9-7A4B-49ec-89C7-87C7818EDF25}
DEFINE_GUID( TASKID_Minor_CreateNetwork_FindObject,
0x97fec5b9, 0x7a4b, 0x49ec, 0x89, 0xc7, 0x87, 0xc7, 0x81, 0x8e, 0xdf, 0x25);

// {AE5A5682-5C27-4e33-B580-8DE3E6BEDF43}
DEFINE_GUID( TASKID_Minor_CreateNetwork_FindObject_QI,
0xae5a5682, 0x5c27, 0x4e33, 0xb5, 0x80, 0x8d, 0xe3, 0xe6, 0xbe, 0xdf, 0x43);

// {E06795C9-C796-409e-BC41-CF7C094399F4}
DEFINE_GUID( TASKID_Minor_CreateNetwork_Gather,
0xe06795c9, 0xc796, 0x409e, 0xbc, 0x41, 0xcf, 0x7c, 0x9, 0x43, 0x99, 0xf4);

// {F4299F9D-5682-42a4-A199-FBA3F7F79CDB}
DEFINE_GUID( TASKID_Minor_CreateNetwork_QI,
0xf4299f9d, 0x5682, 0x42a4, 0xa1, 0x99, 0xfb, 0xa3, 0xf7, 0xf7, 0x9c, 0xdb);

// {0ED1309D-B4B8-419a-B516-17987B862450}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject,
0xed1309d, 0xb4b8, 0x419a, 0xb5, 0x16, 0x17, 0x98, 0x7b, 0x86, 0x24, 0x50);

// {291B68A8-EFC4-4ba4-96D5-C70ECAED2378}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject_QI,
0x291b68a8, 0xefc4, 0x4ba4, 0x96, 0xd5, 0xc7, 0xe, 0xca, 0xed, 0x23, 0x78);

// {B3BB91E8-95D2-4df7-B1F0-19ECA8AEB1F3}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_EnumNode_Next,
0xb3bb91e8, 0x95d2, 0x4df7, 0xb1, 0xf0, 0x19, 0xec, 0xa8, 0xae, 0xb1, 0xf3);

// {F2B650B0-EB7E-43fd-B308-26DD085CA4FE}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_GetConnectionObject,
0xf2b650b0, 0xeb7e, 0x43fd, 0xb3, 0x8, 0x26, 0xdd, 0x8, 0x5c, 0xa4, 0xfe);

// {0E0BC8DE-6558-4fea-BAB5-E64259F8FA8C}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_ConnectionManager,
0xe0bc8de, 0x6558, 0x4fea, 0xba, 0xb5, 0xe6, 0x42, 0x59, 0xf8, 0xfa, 0x8c);

// {9C80CF68-C9A6-4b2c-A7F3-31E5F9AA0B36}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_ConfigConnection_QI,
0x9c80cf68, 0xc9a6, 0x4b2c, 0xa7, 0xf3, 0x31, 0xe5, 0xf9, 0xaa, 0xb, 0x36);

// {23D9B0CC-8CA0-4532-9245-1703C4CF05D0}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_GetClusterVersion,
0x23d9b0cc, 0x8ca0, 0x4532, 0x92, 0x45, 0x17, 0x3, 0xc4, 0xcf, 0x5, 0xd0);

// {794B6A37-85D9-400c-9446-38115D12F2E8}`
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName,
0x794b6a37, 0x85d9, 0x400c, 0x94, 0x46, 0x38, 0x11, 0x5d, 0x12, 0xf2, 0xe8);

// {BF2291E2-998C-4cc0-9AA7-5E4E41285044}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FormatString,
0xbf2291e2, 0x998c, 0x4cc0, 0x9a, 0xa7, 0x5e, 0x4e, 0x41, 0x28, 0x50, 0x44);

// {360FF725-66DE-4833-9EBD-6EB00C30CB8A}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_IsMemberOfCluster,
0x360ff725, 0x66de, 0x4833, 0x9e, 0xbd, 0x6e, 0xb0, 0xc, 0x30, 0xcb, 0x8a);

// {323E1796-5285-4fed-8CC3-B50A145A7813}
DEFINE_GUID( TASKID_Minor_CheckInteroperability,
0x323e1796, 0x5285, 0x4fed, 0x8c, 0xc3, 0xb5, 0xa, 0x14, 0x5a, 0x78, 0x13);

// {786D2E6E-448A-4b83-8E90-03974528B1EE}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_CheckJoiningNodeVersion,
0x786d2e6e, 0x448a, 0x4b83, 0x8e, 0x90, 0x3, 0x97, 0x45, 0x28, 0xb1, 0xee);

// {462C6516-C855-4622-9299-1CD2D4C27EAC}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_GetNodeInfo,
0x462c6516, 0xc855, 0x4622, 0x92, 0x99, 0x1c, 0xd2, 0xd4, 0xc2, 0x7e, 0xac);

// {73F18E00-56D9-49eb-8D9B-AFFC08186BC3}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_GetClusterConfigInfo,
0x73f18e00, 0x56d9, 0x49eb, 0x8d, 0x9b, 0xaf, 0xfc, 0x8, 0x18, 0x6b, 0xc3);

// {0E041CD6-4E86-480e-A5E2-114F7C7E9B5D}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_ClusterInfoEx_QI,
0xe041cd6, 0x4e86, 0x480e, 0xa5, 0xe2, 0x11, 0x4f, 0x7c, 0x7e, 0x9b, 0x5d);

// {3CA8DF73-8310-40a9-9429-109805A25A62}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_FindObject,
0x3ca8df73, 0x8310, 0x40a9, 0x94, 0x29, 0x10, 0x98, 0x5, 0xa2, 0x5a, 0x62);

// {0C9BF0DE-5512-44a0-B502-557C0E95416A}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_FindObject_QI,
0xc9bf0de, 0x5512, 0x44a0, 0xb5, 0x2, 0x55, 0x7c, 0xe, 0x95, 0x41, 0x6a);

// {AD611B3F-948C-41d6-9379-6D139AD7D426}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Count,
0xad611b3f, 0x948c, 0x41d6, 0x93, 0x79, 0x6d, 0x13, 0x9a, 0xd7, 0xd4, 0x26);

// {E7BF32C6-AFC1-4e65-805E-727416CD8C56}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Reset,
0xe7bf32c6, 0xafc1, 0x4e65, 0x80, 0x5e, 0x72, 0x74, 0x16, 0xcd, 0x8c, 0x56);

// {ABF39F3E-8E8B-4a46-A4DF-B9348FB7577B}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next,
0xabf39f3e, 0x8e8b, 0x4a46, 0xa4, 0xdf, 0xb9, 0x34, 0x8f, 0xb7, 0x57, 0x7b);

// {E834435A-71DF-4695-BA0A-88E884100559}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_OutOfMemory,
0xe834435a, 0x71df, 0x4695, 0xba, 0xa, 0x88, 0xe8, 0x84, 0x10, 0x5, 0x59);

// {E834435A-71DF-4695-BA0A-88E88410055a}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable,
0xe834435a, 0x71df, 0x4695, 0xba, 0xa, 0x88, 0xe8, 0x84, 0x10, 0x5, 0x5a);

// {CA8148D2-43BF-4b87-B160-8E7157B38871}
DEFINE_GUID( TASKID_Minor_BeginTask_CoCreate_ServiceManager,
0xca8148d2, 0x43bf, 0x4b87, 0xb1, 0x60, 0x8e, 0x71, 0x57, 0xb3, 0x88, 0x71);

// {C43488F6-E9F9-4d94-B916-78E876017524}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ObjectManager,
0xc43488f6, 0xe9f9, 0x4d94, 0xb9, 0x16, 0x78, 0xe8, 0x76, 0x1, 0x75, 0x24);

// {E36BE0F5-2F33-449e-95E3-537D10C38426}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_NotificationManager,
0xe36be0f5, 0x2f33, 0x449e, 0x95, 0xe3, 0x53, 0x7d, 0x10, 0xc3, 0x84, 0x26);

// {4E2FBE24-E98C-4fb5-845C-173EFE7645CF}
DEFINE_GUID( TASKID_Minor_BeginTask_FindConnectionPoint,
0x4e2fbe24, 0xe98c, 0x4fb5, 0x84, 0x5c, 0x17, 0x3e, 0xfe, 0x76, 0x45, 0xcf);

// {AE4C7616-1A0E-420e-B608-4B5F8F6B7B16}
DEFINE_GUID( TASKID_Minor_BeginTask_QI_pnui,
0xae4c7616, 0x1a0e, 0x420e, 0xb6, 0x8, 0x4b, 0x5f, 0x8f, 0x6b, 0x7b, 0x16);

// {0C39239E-F590-45dc-BD61-0CFE87E11159}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ClusterConnectionManager,
0xc39239e, 0xf590, 0x45dc, 0xbd, 0x61, 0xc, 0xfe, 0x87, 0xe1, 0x11, 0x59);

// {5742FB88-7180-43f3-9969-29506E3B3BC6}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_StandardInfo,
0x5742fb88, 0x7180, 0x43f3, 0x99, 0x69, 0x29, 0x50, 0x6e, 0x3b, 0x3b, 0xc6);

// {28AEFD58-FDB7-478c-AED1-933C3DFCC4AE}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_StandardInfo_QI,
0x28aefd58, 0xfdb7, 0x478c, 0xae, 0xd1, 0x93, 0x3c, 0x3d, 0xfc, 0xc4, 0xae);

// {43527583-74CC-4abe-868D-D50EB3623316}
DEFINE_GUID( TASKID_Minor_BeginTask_GetName,
0x43527583, 0x74cc, 0x4abe, 0x86, 0x8d, 0xd5, 0xe, 0xb3, 0x62, 0x33, 0x16);

// {7DACE324-695E-48bf-8EA4-00F4DCE2FCAF}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject_QI_m_pccs,
0x7dace324, 0x695e, 0x48bf, 0x8e, 0xa4, 0x0, 0xf4, 0xdc, 0xe2, 0xfc, 0xaf);

// {2F47A4E0-BA74-4ac0-B7D8-582A4AD2C8A0}
DEFINE_GUID( TASKID_Minor_BeginTask_QI_pccc,
0x2f47a4e0, 0xba74, 0x4ac0, 0xb7, 0xd8, 0x58, 0x2a, 0x4a, 0xd2, 0xc8, 0xa0);

// {1EEA1B8B-9D30-4cb1-99AF-43B16FDD40A8}
DEFINE_GUID( TASKID_Minor_BeginTask_CanNodeBeClustered,
0x1eea1b8b, 0x9d30, 0x4cb1, 0x99, 0xaf, 0x43, 0xb1, 0x6f, 0xdd, 0x40, 0xa8);

// {6D453A8F-7E4A-43b3-A510-6F0994A8388A}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_QI_Failed,
0x6d453a8f, 0x7e4a, 0x43b3, 0xa5, 0x10, 0x6f, 0x9, 0x94, 0xa8, 0x38, 0x8a);

// {97FEDAD7-62C6-4160-90F3-47F2DACAAA16}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_Failed,
0x97fedad7, 0x62c6, 0x4160, 0x90, 0xf3, 0x47, 0xf2, 0xda, 0xca, 0xaa, 0x16);

// {0F24E7FD-4CEB-4c07-A7B6-70DFBF9F4D9B}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_Next,
0xf24e7fd, 0x4ceb, 0x4c07, 0xa7, 0xb6, 0x70, 0xdf, 0xbf, 0x9f, 0x4d, 0x9b);

// {E79F53D5-4EAF-40f8-9DB3-0C562FBF1F97}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_GetUID,
0xe79f53d5, 0x4eaf, 0x40f8, 0x9d, 0xb3, 0xc, 0x56, 0x2f, 0xbf, 0x1f, 0x97);

// {823C1D94-D130-4b77-8FA5-0E4E8F4048A1}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject,
0x823c1d94, 0xd130, 0x4b77, 0x8f, 0xa5, 0xe, 0x4e, 0x8f, 0x40, 0x48, 0xa1);

// {357189DE-6009-489e-AE6D-746256ED56D5}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pccmriClientSide,
0x357189de, 0x6009, 0x489e, 0xae, 0x6d, 0x74, 0x62, 0x56, 0xed, 0x56, 0xd5);

// {79A880DB-316C-4c2d-8D02-E281125CB89D}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pgd,
0x79a880db, 0x316c, 0x4c2d, 0x8d, 0x2, 0xe2, 0x81, 0x12, 0x5c, 0xb8, 0x9d);

// {23C1373D-6471-431c-AD07-2B29605CCAB8}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_Gather,
0x23c1373d, 0x6471, 0x431c, 0xad, 0x7, 0x2b, 0x29, 0x60, 0x5c, 0xca, 0xb8);

// {583B3111-A81F-4951-8B2C-2C9356469313}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_IsQuorumCapable,
0x583b3111, 0xa81f, 0x4951, 0x8b, 0x2c, 0x2c, 0x93, 0x56, 0x46, 0x93, 0x13);

// {B487E965-B64F-4c29-9982-CFF8856EE7BD}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_Next,
0xb487e965, 0xb64f, 0x4c29, 0x99, 0x82, 0xcf, 0xf8, 0x85, 0x6e, 0xe7, 0xbd);

// {73BA6A91-294B-4446-B16D-99A98F59EAD4}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetSize,
0x73ba6a91, 0x294b, 0x4446, 0xb1, 0x6d, 0x99, 0xa9, 0x8f, 0x59, 0xea, 0xd4);

// {A305BEFF-5BA8-40ec-BD14-021AECD4C163}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetNEWQuorumedDevice,
0xa305beff, 0x5ba8, 0x40ec, 0xbd, 0x14, 0x2, 0x1a, 0xec, 0xd4, 0xc1, 0x63);

// {59720E26-9517-455d-810A-22F6ED7764BA}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetOLDQuorumedDevice,
0x59720e26, 0x9517, 0x455d, 0x81, 0xa, 0x22, 0xf6, 0xed, 0x77, 0x64, 0xba);

// {DBD77FC5-7E1B-43fc-985D-3E4352993682}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_QI_peccp,
0xdbd77fc5, 0x7e1b, 0x43fc, 0x98, 0x5d, 0x3e, 0x43, 0x52, 0x99, 0x36, 0x82);

// {82879908-860B-491e-AB76-25985BBE87F2}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_GetName,
0x82879908, 0x860b, 0x491e, 0xab, 0x76, 0x25, 0x98, 0x5b, 0xbe, 0x87, 0xf2);

// {D322C829-070F-417b-BB9F-04C7092734AA}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FormatMessage,
0xd322c829, 0x70f, 0x417b, 0xbb, 0x9f, 0x4, 0xc7, 0x9, 0x27, 0x34, 0xaa);

// {AB02009E-E118-4107-8E88-639A198B111F}
DEFINE_GUID(TASKID_Minor_GatherResources_EnumResources_SetQuorumCapable,
0xab02009e, 0xe118, 0x4107, 0x8e, 0x88, 0x63, 0x9a, 0x19, 0x8b, 0x11, 0x1f);

// {7AE1050F-2A8D-4b71-AF98-BD5FC6983A1E}
DEFINE_GUID( TASKID_Minor_GatherResources_Failed,
0x7ae1050f, 0x2a8d, 0x4b71, 0xaf, 0x98, 0xbd, 0x5f, 0xc6, 0x98, 0x3a, 0x1e);

// {7090D190-E227-4b3f-AEE3-9BB8970E2171}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_Next,
0x7090d190, 0xe227, 0x4b3f, 0xae, 0xe3, 0x9b, 0xb8, 0x97, 0xe, 0x21, 0x71);

// {0FF8B900-077F-4ea2-A32D-82232F14B57F}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_GetUID,
0xff8b900, 0x77f, 0x4ea2, 0xa3, 0x2d, 0x82, 0x23, 0x2f, 0x14, 0xb5, 0x7f);

// {81B91246-E3B5-4620-8155-AB189BD734E7}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject,
0x81b91246, 0xe3b5, 0x4620, 0x81, 0x55, 0xab, 0x18, 0x9b, 0xd7, 0x34, 0xe7);

// {0F6E5610-9640-47d7-80B6-A7C41BB801DC}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pccniLocal,
0xf6e5610, 0x9640, 0x47d7, 0x80, 0xb6, 0xa7, 0xc4, 0x1b, 0xb8, 0x1, 0xdc);

// {A36B3A00-78A9-442b-BBA2-A2219F36221E}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pgd,
0xa36b3a00, 0x78a9, 0x442b, 0xbb, 0xa2, 0xa2, 0x21, 0x9f, 0x36, 0x22, 0x1e);

// {D0895D03-3056-475d-BE91-C875681E5906}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_Gather,
0xd0895d03, 0x3056, 0x475d, 0xbe, 0x91, 0xc8, 0x75, 0x68, 0x1e, 0x59, 0x6);

// {6CAB7D74-DFD8-4260-BB51-3B02A7A060D2}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_GetName,
0x6cab7d74, 0xdfd8, 0x4260, 0xbb, 0x51, 0x3b, 0x2, 0xa7, 0xa0, 0x60, 0xd2);

// {DDDEAA8B-6E7C-4748-8AE8-555399B02E15}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage,
0xdddeaa8b, 0x6e7c, 0x4748, 0x8a, 0xe8, 0x55, 0x53, 0x99, 0xb0, 0x2e, 0x15);

// {20E452C0-96CA-44cd-8CC3-191B5712D7F4}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetUID,
0x20e452c0, 0x96ca, 0x44cd, 0x8c, 0xc3, 0x19, 0x1b, 0x57, 0x12, 0xd7, 0xf4);

// {C31C6231-2102-4595-85BB-2D28322775F1}
DEFINE_GUID( TASKID_Minor_Marking_Quorum_Capable_Resource,
0xc31c6231, 0x2102, 0x4595, 0x85, 0xbb, 0x2d, 0x28, 0x32, 0x27, 0x75, 0xf1);

// {14A900DF-1C06-475a-986E-AC3523FE9A2F}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_CoCreate_ServiceManager,
0x14a900df, 0x1c06, 0x475a, 0x98, 0x6e, 0xac, 0x35, 0x23, 0xfe, 0x9a, 0x2f);

// {0BB14957-05BC-43e3-A2D0-8E5AD1B91018}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_QS_ObjectManager,
0xbb14957, 0x5bc, 0x43e3, 0xa2, 0xd0, 0x8e, 0x5a, 0xd1, 0xb9, 0x10, 0x18);

// {8614BC60-373B-4f57-B737-9C6619B8A87D}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ConnectionManager,
0x8614bc60, 0x373b, 0x4f57, 0xb7, 0x37, 0x9c, 0x66, 0x19, 0xb8, 0xa8, 0x7d);

// {12116CA5-C0EB-4073-B850-FB64A32D6BE1}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_QS_NotificationManager,
0x12116ca5, 0xc0eb, 0x4073, 0xb8, 0x50, 0xfb, 0x64, 0xa3, 0x2d, 0x6b, 0xe1);

// {706948F5-9D79-4ef7-BD29-EA6191375125}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_FindConnectionPoint,
0x706948f5, 0x9d79, 0x4ef7, 0xbd, 0x29, 0xea, 0x61, 0x91, 0x37, 0x51, 0x25);

// {4363DCC3-9770-4aef-9026-A8A46100758F}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_FindConnectionPoint_QI,
0x4363dcc3, 0x9770, 0x4aef, 0x90, 0x26, 0xa8, 0xa4, 0x61, 0x0, 0x75, 0x8f);

// {0B98DDB9-3765-40ef-A2C6-7E2E57156253}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo,
0xb98ddb9, 0x3765, 0x40ef, 0xa2, 0xc6, 0x7e, 0x2e, 0x57, 0x15, 0x62, 0x53);

// {D0091DE4-55C3-4d09-B706-81EAD19120DB}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo_QI_psi,
0xd0091de4, 0x55c3, 0x4d09, 0xb7, 0x6, 0x81, 0xea, 0xd1, 0x91, 0x20, 0xdb);

// {DB1FC868-1D44-41f4-B805-9AC8FAF5C694}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetName,
0xdb1fc868, 0x1d44, 0x41f4, 0xb8, 0x5, 0x9a, 0xc8, 0xfa, 0xf5, 0xc6, 0x94);

// {20926479-AA45-47a6-9DF7-E0144D5D03AB}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject,
0x20926479, 0xaa45, 0x47a6, 0x9d, 0xf7, 0xe0, 0x14, 0x4d, 0x5d, 0x3, 0xab);

// {93DC925D-EF1A-43c0-8818-9AD21C621DF5}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject_QI_pccs,
0x93dc925d, 0xef1a, 0x43c0, 0x88, 0x18, 0x9a, 0xd2, 0x1c, 0x62, 0x1d, 0xf5);

// {50FF0070-2123-4b7e-B16F-888784596D33}
DEFINE_GUID( TASKID_Minor_BeginTask_GetClusterNodeInfo,
0x50ff0070, 0x2123, 0x4b7e, 0xb1, 0x6f, 0x88, 0x87, 0x84, 0x59, 0x6d, 0x33);

// {FEC1CD2A-F587-4f26-B613-8156DBC80050}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_NodeInformation,
0xfec1cd2a, 0xf587, 0x4f26, 0xb6, 0x13, 0x81, 0x56, 0xdb, 0xc8, 0x0, 0x50);

// {1CAAC823-18B3-426b-8452-FBADA6A48D66}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_NodeInformation_QI_pgd,
0x1caac823, 0x18b3, 0x426b, 0x84, 0x52, 0xfb, 0xad, 0xa6, 0xa4, 0x8d, 0x66);

// {46DBC66F-4C50-400b-A9B8-191CCF60ED11}
DEFINE_GUID( TASKID_Minor_BeginTask_GetParent,
0x46dbc66f, 0x4c50, 0x400b, 0xa9, 0xb8, 0x19, 0x1c, 0xcf, 0x60, 0xed, 0x11);

// {193CC9C7-174A-4f58-8B46-6DFA68595171}
DEFINE_GUID( TASKID_Minor_BeginTask_Gather,
0x193cc9c7, 0x174a, 0x4f58, 0x8b, 0x46, 0x6d, 0xfa, 0x68, 0x59, 0x51, 0x71);

// {C18E8743-4862-4e82-A5EE-AF0A4FECDFAB}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetConnectionObject,
0xc18e8743, 0x4862, 0x4e82, 0xa5, 0xee, 0xaf, 0xa, 0x4f, 0xec, 0xdf, 0xab);

// {AC33F963-060C-4b68-AAB4-33BEC30A8CA7}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_ConfigConnection_QI,
0xac33f963, 0x60c, 0x4b68, 0xaa, 0xb4, 0x33, 0xbe, 0xc3, 0xa, 0x8c, 0xa7);

// {6CAA814A-A022-40a5-BE97-C2A857442D97}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetNodeInfo, 
0x6caa814a, 0xa022, 0x40a5, 0xbe, 0x97, 0xc2, 0xa8, 0x57, 0x44, 0x2d, 0x97);

// {F4D34546-A433-4457-B6B9-6BCDE97805D8}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetConfigInfo, 
0xf4d34546, 0xa433, 0x4457, 0xb6, 0xb9, 0x6b, 0xcd, 0xe9, 0x78, 0x5, 0xd8);

// {42885837-8687-45fa-B4D6-3415FE9D7B10}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_ClusterInfoEx_QI, 
0x42885837, 0x8687, 0x45fa, 0xb4, 0xd6, 0x34, 0x15, 0xfe, 0x9d, 0x7b, 0x10);

// {B2587592-3B4C-4aff-A475-7384A32BBE68}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_HrFindDomainInFQN, 
0xb2587592, 0x3b4c, 0x4aff, 0xa4, 0x75, 0x73, 0x84, 0xa3, 0x2b, 0xbe, 0x68);

// {1FBC86D1-8837-421d-BEE6-E068ACB8CA71}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetNodeNames, 
0x1fbc86d1, 0x8837, 0x421d, 0xbe, 0xe6, 0xe0, 0x68, 0xac, 0xb8, 0xca, 0x71);

// {71E63CD2-4C42-44e5-9699-8C3CC6E24251}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_HrMakeFQN, 
0x71e63cd2, 0x4c42, 0x44e5, 0x96, 0x99, 0x8c, 0x3c, 0xc6, 0xe2, 0x42, 0x51);

// {1B606398-7193-4a48-AFBD-98AC8BACB690}
DEFINE_GUID( TASKID_Minor_Remote_Node_Connection_Requests,
0x1b606398, 0x7193, 0x4a48, 0xaf, 0xbd, 0x98, 0xac, 0x8b, 0xac, 0xb6, 0x90);

// {26015CA7-EAE1-43f4-AC1E-718D80629E93}
DEFINE_GUID( TASKID_Minor_Requesting_Remote_Connection,
0x26015ca7, 0xeae1, 0x43f4, 0xac, 0x1e, 0x71, 0x8d, 0x80, 0x62, 0x9e, 0x93);

// {66080927-EF7D-43e1-8752-3A4D51B21FB3}
DEFINE_GUID( TASKID_Minor_Cluster_Name_Match,
0x66080927, 0xef7d, 0x43e1, 0x87, 0x52, 0x3a, 0x4d, 0x51, 0xb2, 0x1f, 0xb3);

// {FC036E7F-4785-4234-8AAA-D7F7162D39BC}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_FormatMessage1,
0xfc036e7f, 0x4785, 0x4234, 0x8a, 0xaa, 0xd7, 0xf7, 0x16, 0x2d, 0x39, 0xbc);

// {F5689B48-954E-417f-AB96-C00BF2CB61AE}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetObject,
0xf5689b48, 0x954e, 0x417f, 0xab, 0x96, 0xc0, 0xb, 0xf2, 0xcb, 0x61, 0xae);

// {42162DB8-4E4A-4f26-8C82-C224F7E2B412}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetObject_QI,
0x42162db8, 0x4e4a, 0x4f26, 0x8c, 0x82, 0xc2, 0x24, 0xf7, 0xe2, 0xb4, 0x12);

// {6FB4AF3C-6304-407c-AC9D-CDB558350CF7}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetName,
0x6fb4af3c, 0x6304, 0x407c, 0xac, 0x9d, 0xcd, 0xb5, 0x58, 0x35, 0xc, 0xf7);

// {A678963B-9173-4393-B21B-0B4337B28EE2}
DEFINE_GUID( TASKID_Minor_No_Nodes_To_Process,
0xa678963b, 0x9173, 0x4393, 0xb2, 0x1b, 0xb, 0x43, 0x37, 0xb2, 0x8e, 0xe2);

// {ED3FF704-C8E8-42a4-AACF-E3498CCEF79F}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_GetResourcePrivateData,
0xed3ff704, 0xc8e8, 0x42a4, 0xaa, 0xcf, 0xe3, 0x49, 0x8c, 0xce, 0xf7, 0x9f);

// {71911EEC-7D22-4a63-8E9F-89FBB61D6FFF}
DEFINE_GUID( TASKID_Minor_HrCheckQuorumCapabilities_QI,
0x71911eec, 0x7d22, 0x4a63, 0x8e, 0x9f, 0x89, 0xfb, 0xb6, 0x1d, 0x6f, 0xff);

// {8FA3B29F-74DC-4eef-81C0-918F6CF80B5B}
DEFINE_GUID( TASKID_Minor_HrCheckQuorumCapabilities_PrepareToHostQuorumResource,
0x8fa3b29f, 0x74dc, 0x4eef, 0x81, 0xc0, 0x91, 0x8f, 0x6c, 0xf8, 0xb, 0x5b);

// {CC1F0811-3AD3-4dc6-A027-169CDB2AA161}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_SetResourcePrivateData,
0xcc1f0811, 0x3ad3, 0x4dc6, 0xa0, 0x27, 0x16, 0x9c, 0xdb, 0x2a, 0xa1, 0x61);

// {57B94464-98A7-43df-BC1A-258569CB61B8}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_Out_Of_Memory1,
0x57b94464, 0x98a7, 0x43df, 0xbc, 0x1a, 0x25, 0x85, 0x69, 0xcb, 0x61, 0xb8);

// {FF45BDDC-CC47-43b6-9663-7FD6081D8F0E}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_Out_Of_Memory2,
0xff45bddc, 0xcc47, 0x43b6, 0x96, 0x63, 0x7f, 0xd6, 0x8, 0x1d, 0x8f, 0xe);

// {D80DFD6B-5146-4f2f-8136-1051A2738DEB}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_NodeResource_QI,
0xd80dfd6b, 0x5146, 0x4f2f, 0x81, 0x36, 0x10, 0x51, 0xa2, 0x73, 0x8d, 0xeb);

// {083DAE77-C38E-47eb-9090-45DF54C3F42C}
DEFINE_GUID( TASKID_Minor_HrResourcePrivateDataExchange_ClusterResource_QI,
0x83dae77, 0xc38e, 0x47eb, 0x90, 0x90, 0x45, 0xdf, 0x54, 0xc3, 0xf4, 0x2c);

// {F9D3FCD7-933E-48e7-8943-35B0F8208934}
DEFINE_GUID( TASKID_Minor_HrCheckQuorumCapabilities_HrAddResurceToCleanupList,
0xf9d3fcd7, 0x933e, 0x48e7, 0x89, 0x43, 0x35, 0xb0, 0xf8, 0x20, 0x89, 0x34);

// {F9D3FCD7-933E-48e7-8943-35B0F8208934}
DEFINE_GUID( TASKID_Minor_HrAddResurceToCleanupList_Memory,
0xf9d3fcd7, 0x933e, 0x48e7, 0x89, 0x43, 0x35, 0xb0, 0xf8, 0x20, 0x89, 0x34);

// {F9D3FCD7-933E-48e7-8943-35B0F8208934}
DEFINE_GUID( TASKID_Minor_HrCleanupTask_Cleanup,
0xf9d3fcd7, 0x933e, 0x48e7, 0x89, 0x43, 0x35, 0xb0, 0xf8, 0x20, 0x89, 0x34);

// {454F7390-5CF6-41a0-B259-3E4908F043A3}
DEFINE_GUID( TASKID_Minor_CompareDriveLetterMappings_Find_Object,
0x454f7390, 0x5cf6, 0x41a0, 0xb2, 0x59, 0x3e, 0x49, 0x8, 0xf0, 0x43, 0xa3);

// {DBB8C42F-1A87-4c69-89BD-34325DA7E962}
DEFINE_GUID( TASKID_Minor_CompareDriveLetterMappings_Find_Object_QI,
0xdbb8c42f, 0x1a87, 0x4c69, 0x89, 0xbd, 0x34, 0x32, 0x5d, 0xa7, 0xe9, 0x62);

// {67E63207-54BF-4e7e-A9CA-27025CDE5191}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_Enum_Reset,
0x67e63207, 0x54bf, 0x4e7e, 0xa9, 0xca, 0x27, 0x2, 0x5c, 0xde, 0x51, 0x91);

// {1D11320B-30D5-4c12-BA07-3BCD3ED5FA67}
DEFINE_GUID( TASKID_Minor_CompareNetworks_Find_Formed_Node_Next,
0x1d11320b, 0x30d5, 0x4c12, 0xba, 0x7, 0x3b, 0xcd, 0x3e, 0xd5, 0xfa, 0x67);

// {69ADEC5B-F927-4c6e-9549-42A34A808D97}
DEFINE_GUID( TASKID_Minor_CompareNetworks_Find_Formed_Node_Next_1,
0x69adec5b, 0xf927, 0x4c6e, 0x95, 0x49, 0x42, 0xa3, 0x4a, 0x80, 0x8d, 0x97);

// {BE249354-273A-49ed-8F5D-25935D843DC5}
DEFINE_GUID( TASKID_Minor_CompareNetworks_NodeInfo_FindObject_QI,
0xbe249354, 0x273a, 0x49ed, 0x8f, 0x5d, 0x25, 0x93, 0x5d, 0x84, 0x3d, 0xc5);

// {89C93856-F73F-489d-B5FA-D0E97C79D5A1}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Find_Object,
0x89c93856, 0xf73f, 0x489d, 0xb5, 0xfa, 0xd0, 0xe9, 0x7c, 0x79, 0xd5, 0xa1);

// {06D9B0C8-54CA-4c78-AB4E-EF8F6C4D90F3}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Find_Formed_Node_Next1,
0x6d9b0c8, 0x54ca, 0x4c78, 0xab, 0x4e, 0xef, 0x8f, 0x6c, 0x4d, 0x90, 0xf3);

// {7F9DA0FA-A14E-4c0d-9718-7F6162903695}
DEFINE_GUID( TASKID_Minor_CompareResources_NodeInfo_FindObject,
0x7f9da0fa, 0xa14e, 0x4c0d, 0x97, 0x18, 0x7f, 0x61, 0x62, 0x90, 0x36, 0x95);

// {C6F868E4-235C-4015-8D97-ABE3118196B0}
DEFINE_GUID( TASKID_Minor_GetAClusterNodeCookie_Find_Formed_Node_Next_1,
0xc6f868e4, 0x235c, 0x4015, 0x8d, 0x97, 0xab, 0xe3, 0x11, 0x81, 0x96, 0xb0);

// {FE040305-AA31-4410-985C-4B8C71A7FC4D}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject,
0xfe040305, 0xaa31, 0x4410, 0x98, 0x5c, 0x4b, 0x8c, 0x71, 0xa7, 0xfc, 0x4d);

// {92B80603-0550-449b-B01D-C19025DAF7F2}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_QI,
0x92b80603, 0x550, 0x449b, 0xb0, 0x1d, 0xc1, 0x90, 0x25, 0xda, 0xf7, 0xf2);

// {7662F0E6-36F8-4612-AA15-EA848FDA062F}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_Get_Proc_info,
0x7662f0e6, 0x36f8, 0x4612, 0xaa, 0x15, 0xea, 0x84, 0x8f, 0xda, 0x6, 0x2f);

// {DAC11A9A-0044-4dab-8F40-53C4000E0F0A}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_Enum_Nodes_Next,
0xdac11a9a, 0x44, 0x4dab, 0x8f, 0x40, 0x53, 0xc4, 0x0, 0xe, 0xf, 0xa);

// {8EA6D4E9-0D3A-4c1c-A123-6073D4D84237}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_1,
0x8ea6d4e9, 0xd3a, 0x4c1c, 0xa1, 0x23, 0x60, 0x73, 0xd4, 0xd8, 0x42, 0x37);

// {494F9FE8-AE47-4467-9977-48CA6CFEA0B6}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_QI_1,
0x494f9fe8, 0xae47, 0x4467, 0x99, 0x77, 0x48, 0xca, 0x6c, 0xfe, 0xa0, 0xb6);

// {821CC82A-5FA6-49c7-A2AD-D94C9EB78A7E}
DEFINE_GUID( TASKID_Minor_CheckPlatformInteroperability_Get_Proc_info_1,
0x821cc82a, 0x5fa6, 0x49c7, 0xa2, 0xad, 0xd9, 0x4c, 0x9e, 0xb7, 0x8a, 0x7e);

// {804DCF41-4734-4e84-8CF0-B7C3E4B8E2D6}
DEFINE_GUID( TASKID_Minor_Processor_Architecture_Mismatch,
0x804dcf41, 0x4734, 0x4e84, 0x8c, 0xf0, 0xb7, 0xc3, 0xe4, 0xb8, 0xe2, 0xd6);

// {102439CC-67FA-48a6-AB0D-31DF047FC5E6}
DEFINE_GUID( TASKID_Minor_Compare_Resources,
0x102439cc, 0x67fa, 0x48a6, 0xab, 0xd, 0x31, 0xdf, 0x4, 0x7f, 0xc5, 0xe6);

// {2B3F3240-58AE-4f23-A4F8-70E620DABA7C}
DEFINE_GUID( TASKID_Minor_Check_processor_Architecture,
0x2b3f3240, 0x58ae, 0x4f23, 0xa4, 0xf8, 0x70, 0xe6, 0x20, 0xda, 0xba, 0x7c);

// {06AB21DD-D8C7-453d-845E-50423BEACA38}
DEFINE_GUID( TASKID_Minor_Check_Cluster_Membership,
0x6ab21dd, 0xd8c7, 0x453d, 0x84, 0x5e, 0x50, 0x42, 0x3b, 0xea, 0xca, 0x38);

// {CE08A0CD-72BC-4e63-A38D-4942EF962D20}
DEFINE_GUID( TASKID_Minor_Check_DriveLetter_Mappings,
0xce08a0cd, 0x72bc, 0x4e63, 0xa3, 0x8d, 0x49, 0x42, 0xef, 0x96, 0x2d, 0x20);

// {A209EF1D-7C2F-451c-99D9-42A5E00F3028}
DEFINE_GUID( TASKID_Minor_Check_Compare_Networks,
0xa209ef1d, 0x7c2f, 0x451c, 0x99, 0xd9, 0x42, 0xa5, 0xe0, 0xf, 0x30, 0x28);

// {3BB53C9E-E14A-4196-9066-5400FB8860C9}
DEFINE_GUID( TASKID_Minor_Missing_Common_Quorum_Resource,
0x3bb53c9e, 0xe14a, 0x4196, 0x90, 0x66, 0x54, 0x0, 0xfb, 0x88, 0x60, 0xc9);

// {E8043880-46CA-46d6-A01A-BF0D3193D624}
DEFINE_GUID( TASKID_Minor_Forced_Local_Quorum,
0xe8043880, 0x46ca, 0x46d6, 0xa0, 0x1a, 0xbf, 0xd, 0x31, 0x93, 0xd6, 0x24);

// {14B7E6B6-7B7F-4103-9D0D-C8918EC62557}
DEFINE_GUID( TASKID_Minor_Found_Common_Quorum_Resource,
0x14b7e6b6, 0x7b7f, 0x4103, 0x9d, 0xd, 0xc8, 0x91, 0x8e, 0xc6, 0x25, 0x57);

// {AAB22173-47D1-4299-A1B0-F86EA95A38C5}
DEFINE_GUID( TASKID_Minor_Incompatible_Versions,
0xaab22173, 0x47d1, 0x4299, 0xa1, 0xb0, 0xf8, 0x6e, 0xa9, 0x5a, 0x38, 0xc5);

// {7A072F84-0EDD-4ac0-AB54-2DE7028B8C9E}
DEFINE_GUID( TASKID_Minor_No_Joining_Nodes_Found_For_Version_Check,
0x7a072f84, 0xedd, 0x4ac0, 0xab, 0x54, 0x2d, 0xe7, 0x2, 0x8b, 0x8c, 0x9e);

// {07D8047B-01FD-40dc-9132-4B535A77CDE4}
DEFINE_GUID( TASKID_Minor_Comparing_Configuration,
0x7d8047b, 0x1fd, 0x40dc, 0x91, 0x32, 0x4b, 0x53, 0x5a, 0x77, 0xcd, 0xe4);

// {88407BE5-26A3-46f6-9636-A26BDAECC5D6}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Quorum,
0x88407be5, 0x26a3, 0x46f6, 0x96, 0x36, 0xa2, 0x6b, 0xda, 0xec, 0xc5, 0xd6);

// {6AD04D62-3BA5-4365-B7D2-073745EDD920}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetMinimalConfiguration,
0x6ad04d62, 0x3ba5, 0x4365, 0xb7, 0xd2, 0x7, 0x37, 0x45, 0xed, 0xd9, 0x20);

 // {A69474A9-EB94-406E-A1B6-C01D9581DD40} 
DEFINE_GUID( TASKID_Minor_Check_Domain_Membership,
0xa69474a9, 0xeb94, 0x406e, 0xa1, 0xb6, 0xc0, 0x1d, 0x95, 0x81, 0xdd, 0x40);

 // {2B53331D-C2FA-44FE-94CA-22BF7318DB40}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetUserAddedNodeFlag,
0x2B53331D, 0xC2fa, 0x44fe, 0x94, 0xca, 0x22, 0xbf, 0x73, 0x18, 0xdb, 0x40);

// {01297D4D-0C7C-44b1-AECE-604C710A65CC}
DEFINE_GUID( TASKID_Minor_Gathering_Managed_Devices,
0x1297d4d, 0xc7c, 0x44b1, 0xae, 0xce, 0x60, 0x4c, 0x71, 0xa, 0x65, 0xcc );

// {2F2A800D-A704-474b-A870-5CAAAF399093}
DEFINE_GUID( TASKID_Minor_Checking_Node_Cluster_Feasibility,
0x2f2a800d, 0xa704, 0x474b, 0xa8, 0x70, 0x5c, 0xaa, 0xaf, 0x39, 0x90, 0x93 );

// {A7030E11-2C68-469e-8E0C-863128FB021F}
DEFINE_GUID( TASKID_Minor_Forming_Node,
0xa7030e11, 0x2c68, 0x469e, 0x8e, 0xc, 0x86, 0x31, 0x28, 0xfb, 0x2, 0x1f );

// {3222E708-EEF3-4667-8CCE-BB0C9223130E}
DEFINE_GUID( TASKID_Minor_Joining_Node,
0x3222e708, 0xeef3, 0x4667, 0x8c, 0xce, 0xbb, 0xc, 0x92, 0x23, 0x13, 0xe );

// {9983564B-A8B8-444c-B82D-DC7E3BD84D47}
DEFINE_GUID( TASKID_Minor_No_Quorum_Capable_Device_Found,
0x9983564b, 0xa8b8, 0x444c, 0xb8, 0x2d, 0xdc, 0x7e, 0x3b, 0xd8, 0x4d, 0x47 );

// {A976DC09-0108-410a-AF57-68C05F9A42F7}
DEFINE_GUID( TASKID_Minor_Nodes_Cannot_Access_Quorum,
0xa976dc09, 0x108, 0x410a, 0xaf, 0x57, 0x68, 0xc0, 0x5f, 0x9a, 0x42, 0xf7);

// {AEAC8221-A028-4a09-A372-8624F2A6BF75}
DEFINE_GUID( TASKID_Minor_Polling_Connection_Failure,
0xaeac8221, 0xa028, 0x4a09, 0xa3, 0x72, 0x86, 0x24, 0xf2, 0xa6, 0xbf, 0x75 );

// {2985247E-2CEB-4b1e-AAFE-EED45298EDA6}
DEFINE_GUID( TASKID_Minor_Found_Quorum_Capable_Resource,
0x2985247e, 0x2ceb, 0x4b1e, 0xaa, 0xfe, 0xee, 0xd4, 0x52, 0x98, 0xed, 0xa6 );

// {C2B7BE3E-256C-4c03-B886-A1EE8DE38AD0}
DEFINE_GUID( TASKID_Minor_Found_Minimum_Size_Quorum_Capable_Resource,
0xc2b7be3e, 0x256c, 0x4c03, 0xb8, 0x86, 0xa1, 0xee, 0x8d, 0xe3, 0x8a, 0xd0 );

// {0B5C1D35-1CA5-4597-B1A7-DCD4D64F55C6}
DEFINE_GUID( TASKID_Minor_Cluster_Name_Mismatch,
0xb5c1d35, 0x1ca5, 0x4597, 0xb1, 0xa7, 0xdc, 0xd4, 0xd6, 0x4f, 0x55, 0xc6 );

// {C3691397-F13F-419b-8CEA-7F86D3E7DA0E}
DEFINE_GUID( TASKID_Minor_Inconsistant_MiddleTier_Database,
0xc3691397, 0xf13f, 0x419b, 0x8c, 0xea, 0x7f, 0x86, 0xd3, 0xe7, 0xda, 0xe );

// {1799EE20-885C-40ab-99DD-69EB1FE62DB2}
DEFINE_GUID( TASKID_Minor_Cluster_Not_Found,
0x1799ee20, 0x885c, 0x40ab, 0x99, 0xdd, 0x69, 0xeb, 0x1f, 0xe6, 0x2d, 0xb2 );

// {C0171B7C-B419-488f-B05F-8A6E0279B56A}
DEFINE_GUID( TASKID_Minor_Existing_Cluster_Found,
0xc0171b7c, 0xb419, 0x488f, 0xb0, 0x5f, 0x8a, 0x6e, 0x2, 0x79, 0xb5, 0x6a );

// {2E305DD0-9DCA-47fe-8CF6-4306CA72C4A2}
DEFINE_GUID( TASKID_Minor_Error_Contacting_Cluster,
0x2e305dd0, 0x9dca, 0x47fe, 0x8c, 0xf6, 0x43, 0x6, 0xca, 0x72, 0xc4, 0xa2 );

// {46C8CF52-233D-48a7-B7B9-FE3929A40875}
DEFINE_GUID( TASKID_Minor_Cluster_Membership_Verified,
0x46c8cf52, 0x233d, 0x48a7, 0xb7, 0xb9, 0xfe, 0x39, 0x29, 0xa4, 0x8, 0x75 );

// {B8C4066E-0246-4358-9DE5-25603EDD0CA0}
DEFINE_GUID( TASKID_Minor_Finding_Common_Quorum_Device,
0xb8c4066e, 0x246, 0x4358, 0x9d, 0xe5, 0x25, 0x60, 0x3e, 0xdd, 0xc, 0xa0 );

// {F892123F-01A7-4751-84C5-9E2454C2DF67}
DEFINE_GUID( TASKID_Minor_Can_Node_Be_Clustered_Failed,
0xf892123f, 0x1a7, 0x4751, 0x84, 0xc5, 0x9e, 0x24, 0x54, 0xc2, 0xdf, 0x67 );

// {61C76E24-5CC3-4f91-BD91-ADAE1AA1AC8C}
DEFINE_GUID( TASKID_Minor_No_Managed_Resources_Found,
0x61c76e24, 0x5cc3, 0x4f91, 0xbd, 0x91, 0xad, 0xae, 0x1a, 0xa1, 0xac, 0x8c );

// {9E6B30F7-CD47-417d-B59A-6A0C0CC3302B}
DEFINE_GUID( TASKID_Minor_No_Managed_Networks_Found,
0x9e6b30f7, 0xcd47, 0x417d, 0xb5, 0x9a, 0x6a, 0xc, 0xc, 0xc3, 0x30, 0x2b );

// {2B6B66C2-DD8C-46db-8613-DEFAE7CE1A33}
DEFINE_GUID( TASKID_Minor_Only_One_Network,
0x2b6b66c2, 0xdd8c, 0x46db, 0x86, 0x13, 0xde, 0xfa, 0xe7, 0xce, 0x1a, 0x33);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\managednetwork.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedNetwork.cpp
//
//  Description:
//      CManagedNetwork implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IPAddressInfo.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CManagedNetwork")

#define IPADDRESS_INCREMENT 10

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CManagedNetwork::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CManagedNetwork::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CManagedNetwork *   pmn = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pmn = new CManagedNetwork;
    if ( pmn == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pmn->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pmn->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pmn != NULL )
    {
        pmn->Release();
    }

    HRETURN( hr );

} //*** CManagedNetwork::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedNetwork::CManagedNetwork
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedNetwork::CManagedNetwork( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedNetwork::CManagedNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::HrInit
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // Async/IClusCfgNetworkInfo
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_bstrDescription == NULL );
    Assert( m_fHasDescriptionChanged == FALSE );
    Assert( m_fIsPublic == FALSE );
    Assert( m_fIsPrivate == FALSE );
    Assert( m_punkPrimaryAddress == NULL );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CManagedNetwork::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedNetwork::~CManagedNetwork
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedNetwork::~CManagedNetwork( void )
{
    TraceFunc( "" );

    if ( m_ppunkIPs != NULL )
    {
        while ( m_cCurrentIPs != 0 )
        {
            m_cCurrentIPs --;
            Assert( m_ppunkIPs[ m_cCurrentIPs ] != NULL );
            if ( m_ppunkIPs[ m_cCurrentIPs ] != NULL )
            {
                m_ppunkIPs[ m_cCurrentIPs ]->Release();
            }
        }

        TraceFree( m_ppunkIPs );
    }

    if ( m_punkPrimaryAddress != NULL )
    {
        m_punkPrimaryAddress->Release();
    } // if:

    TraceSysFreeString( m_bstrUID );
    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedNetwork::~CManagedNetwork


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedNetwork::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgNetworkInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNetworkInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
    } // else if: IClusCfgNetworkInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
    } // else if: IEnumClusCfgIPAddresses
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CManagedNetwork::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedNetwork::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedNetwork::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CManagedNetwork::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedNetwork::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedNetwork::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CManagedNetwork::Release


// ************************************************************************
//
// IClusCfgNetworkInfo
//
// ************************************************************************


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetUID(
//      BSTR * pbstrUIDOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrUID == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::GetUID

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrName == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::GetName

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::SetName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetDescription(
//      BSTR * pbstrDescriptionOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetDescription(
    BSTR * pbstrDescriptionOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrDescription == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if ( *pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::GetDescription

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetDescription(
//      LPCWSTR pcszDescriptionIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetDescription(
    LPCWSTR pcszDescriptionIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ws'", ( pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewDescription;

    if ( pcszDescriptionIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrNewDescription == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    if ( m_bstrDescription != NULL )
    {
        TraceSysFreeString( m_bstrDescription );
    }

    m_bstrDescription = bstrNewDescription;
    m_fHasDescriptionChanged = TRUE;

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::SetDescription

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgNetworkInfo::GetPrimaryNetworkAddress
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkPrimaryAddress != NULL );

    HRESULT hr;

    if ( ppIPAddressOut == NULL )
    {
        hr = THR( E_POINTER );
    } // if:
    else
    {
        hr = THR( m_punkPrimaryAddress->TypeSafeQI( IClusCfgIPAddressInfo, ppIPAddressOut ) );
    } // else:

    HRETURN( hr );

} //*** CManagedNetwork::GetPrimaryNetworkAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgNetworkInfo::SetPrimaryNetworkAddress
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo * pIPAddressIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CManagedNetwork::SetPrimaryNetworkAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::IsPublic
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( m_fIsPublic )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::IsPublic

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetPublic(
//      BOOL fIsPublicIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPublic(
    BOOL fIsPublicIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] fIsPublic = %s", BOOLTOSTRING( fIsPublicIn ) );

    HRESULT hr = S_OK;

    m_fIsPublic = fIsPublicIn;

    HRETURN( hr );

} //*** CManagedNetwork::SetPublic

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::IsPrivate
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( m_fIsPrivate )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::IsPrivate

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetPrivate(
//      BOOL fIsPrivateIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPrivate(
    BOOL fIsPrivateIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] fIsPrivate = %s", BOOLTOSTRING( fIsPrivateIn ) );

    HRESULT hr = S_OK;

    m_fIsPrivate = fIsPrivateIn;

    HRETURN( hr );

} //*** CManagedNetwork::SetPrivate


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    IUnknown *                  punk = NULL;
    IClusCfgNetworkInfo *       pccni = NULL;
    IEnumClusCfgIPAddresses *   peccia = NULL;
    IObjectManager *            pom = NULL;
    OBJECTCOOKIE                cookie;
    IServiceProvider *          psp = NULL;
    IGatherData *               pgd = NULL;
    IClusCfgIPAddressInfo *     piccipai = NULL;

    //
    //  Make sure we don't "gather" the same object twice.
    //

    if ( m_fGathered )
    {
        hr = THR( E_UNEXPECTED );
        goto Cleanup;   // don't cleanup the object.
    }


    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Gather the information.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Gather UID
    //

    hr = THR( pccni->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Gather Name
    //

    hr = THR( pccni->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrName );

    //
    //  Gather Description
    //

    hr = THR( pccni->GetDescription( &m_bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrDescription );

    //
    //  Gather IsPrivate
    //

    hr = STHR( pccni->IsPrivate() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hr == S_OK )
    {
        m_fIsPrivate = TRUE;
    }
    else
    {
        m_fIsPrivate = FALSE;
    }

    //
    //  Gather IsPublic
    //

    hr = STHR( pccni->IsPublic() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    if ( hr == S_OK )
    {
        m_fIsPublic = TRUE;
    }
    else
    {
        m_fIsPublic = FALSE;
    }

    //
    //
    //  If the parent cookie is ZERO, then we don't grab the secondary IP
    //  address information.
    //

    if ( cookieParentIn != 0 )
    {
        //  Gather the IP Addresses
        //

        hr = THR( punkIn->TypeSafeQI( IEnumClusCfgIPAddresses, &peccia ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Gather the object manager.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                                   IObjectManager,
                                   &pom
                                   ) );
        psp->Release();        // release promptly
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pom->FindObject( CLSID_NetworkType,
                                   cookieParentIn,
                                   m_bstrUID,
                                   IID_NULL,
                                   &cookie,
                                   &punk // dummy
                                   ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( EnumChildrenAndTransferInformation( cookie, peccia ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Gather Primary Network Address
    //

    hr = THR( pccni->GetPrimaryNetworkAddress( &piccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( CIPAddressInfo::S_HrCreateInstance( &m_punkPrimaryAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_punkPrimaryAddress->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pgd->Gather( cookieParentIn, piccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Anything else to gather??
    //

    hr = S_OK;
    m_fGathered = TRUE;

Cleanup:
    if ( pgd != NULL )
    {
        pgd->Release();
    } // if:
    if ( piccipai != NULL )
    {
        piccipai->Release();
    } // if:
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( peccia != NULL )
    {
        peccia->Release();
    } // if:
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
        m_bstrUID = NULL;
    }
    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
        m_bstrName = NULL;
    }
    if ( m_bstrDescription != NULL )
    {
        TraceSysFreeString( m_bstrDescription );
        m_bstrDescription = NULL;
    }
    m_fIsPrivate = FALSE;
    m_fIsPublic = FALSE;
    goto Cleanup;

} //*** CManagedNetwork::Gather


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CManagedNetwork::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = S_OK;

    //
    //  Check parameters.
    //

    //  We need a cookie.
    if ( cookieIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to be representing a NetworkType
    if ( !IsEqualIID( rclsidTypeIn, CLSID_NetworkType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to have a name.
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = THR( QueryInterface( DFGUID_NetworkResource,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::FindObject


// ************************************************************************
//
//  Private methods.
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::EnumChildrenAndTransferInformation(
//      IEnumClusCfgIPAddresses * pecciaIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::EnumChildrenAndTransferInformation(
    OBJECTCOOKIE                cookieIn,
    IEnumClusCfgIPAddresses *   pecciaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   cFetched;
    IGatherData *           pgd = NULL;
    IUnknown *              punk = NULL;
    DWORD                   cIPs = 0;

    Assert( m_ppunkIPs == NULL );
    Assert( m_cCurrentIPs == 0 );
    Assert( m_cAllocedIPs == 0 );

    hr = THR( pecciaIn->Count( &cIPs ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( cIPs > 0 )
    {
        m_ppunkIPs = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, cIPs * sizeof(IUnknown *) );
        if ( m_ppunkIPs == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    m_cAllocedIPs = cIPs;

    for ( m_cCurrentIPs = 0 ; m_cCurrentIPs < m_cAllocedIPs ; m_cCurrentIPs += 1 )
    {
        //
        //  Grab the next address.
        //

        hr = STHR( pecciaIn->Next( 1, &pccipai, &cFetched ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        Assert( cFetched == 1 );

        //
        //  Create a new IP Address object.
        //

        hr = THR( CIPAddressInfo::S_HrCreateInstance( &punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Retrieve the information.
        //

        hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pgd->Gather( cookieIn, pccipai ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Place it in the array.
        //

        m_ppunkIPs[ m_cCurrentIPs ] = punk;
        punk = NULL; // not released because it's now in the m_ppunkIPs array

        //
        //  Release temporary objects.
        //
        pgd->Release();
        pgd = NULL;

        pccipai->Release();
        pccipai = NULL;
    } // for:

    m_cIter = 0;

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:
    if ( pgd != NULL )
    {
        pgd->Release();
    } // if:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    HRETURN( hr );

} //*** CManagedNetwork::EnumChildrenAndTransferInformation


//****************************************************************************
//
//  IEnumClusCfgIPAddresses
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Next(
//      ULONG                       celt,
//      IClusCfgIPAddressInfo **    rgOut,
//      ULONG *                     pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Next(
    ULONG                       celt,
    IClusCfgIPAddressInfo **    rgOut,
    ULONG *                     pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    ULONG   celtFetched;

    HRESULT hr = S_OK;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cCurrentIPs && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_ppunkIPs[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgIPAddressInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
        {
            goto CleanupList;
        }

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release();
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

} //*** CManagedNetwork::Next

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Skip(
//      ULONG cNumberToSkipIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Skip(
    ULONG cNumberToSkipIn
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter += cNumberToSkipIn;

    if ( m_cIter >= m_cCurrentIPs )
    {
        m_cIter = m_cCurrentIPs;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::Skip

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Reset( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CManagedNetwork::Reset

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Clone(
//      IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    //
    //  KB: GPease  31-JUL-2000
    //      Not going to implement this.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CManagedNetwork::Clone


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CManagedNetwork::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cCurrentIPs;

Cleanup:
    HRETURN( hr );

} //*** CManagedNetwork::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\managedresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ManagedResource.h
//
//  Description:
//      CManagedResource implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumManageableResources;

class CManagedResource
    : public IExtendObjectManager
    , public IClusCfgManagedResourceInfo
    , public IGatherData
    , public IClusCfgManagedResourceData
    , public IClusCfgVerifyQuorum
{
friend class CEnumManageableResources;
private:
    // IUnknown
    LONG                    m_cRef;

    // Async/IClusCfgManagedResourceInfo
    BSTR                    m_bstrUID;                                      // Unique Identifier
    BSTR                    m_bstrName;                                     // Display Name
    BSTR                    m_bstrType;                                     // Display Type Name
    BOOL                    m_fHasNameChanged;                              // Indicates the user changed the name
    BOOL                    m_fIsManaged;                                   // Does the user want to manage this resource in the cluster?
    BOOL                    m_fIsManagedByDefault;                          // Should the resource be managed by default in the cluster?
    BOOL                    m_fIsQuorumResource;                            // If the user wants this device to be the quorum...
    BOOL                    m_fIsQuorumCapable;                             // If the device supports quorum...
    BOOL                    m_fIsQuorumResourceMultiNodeCapable;            // Does the quorum capable device allow join.
    BYTE *                  m_pbPrivateData;                                // Buffer for the resource's private data.
    DWORD                   m_cbPrivateData;                                // size of the resource's private data.
    DWORD                   m_cookieResourcePrivateData;                    // Global Interface Table cookie -- server side IClusCfgManagedResourceData
    DWORD                   m_cookieVerifyQuorum;                           // Global Interface Table cookie -- server side IClusCfgVerifyQuorum
    IGlobalInterfaceTable * m_pgit;                                         // Global Interface Table

    SDriveLetterMapping m_dlmDriveLetterMapping;                            // Drive letter representations hosted on this device.

    // IExtendObjectManager

private: // Methods
    CManagedResource( void );
    ~CManagedResource( void );

    // Private copy constructor to prevent copying.
    CManagedResource( const CManagedResource & nodeSrc );

    // Private assignment operator to prevent copying.
    const CManagedResource & operator = ( const CManagedResource & nodeSrc );

    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgManagedResourceInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsManaged )( void );
    STDMETHOD( SetManaged )( BOOL fIsManagedIn );
    STDMETHOD( IsQuorumResource )( void );
    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );
    STDMETHOD( IsQuorumCapable )( void );
    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingsOut );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingsIn );
    STDMETHOD( IsManagedByDefault )( void );
    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendOjectManager
    STDMETHOD( FindObject )( OBJECTCOOKIE cookieIn, REFCLSID rclsidTypeIn, LPCWSTR pcszNameIn, LPUNKNOWN * ppunkOut );

    // IClusCfgManagedResourceData
    STDMETHOD( GetResourcePrivateData )( BYTE * pbBufferOut, DWORD * pcbBufferInout );
    STDMETHOD( SetResourcePrivateData )( const BYTE * pcbBufferIn, DWORD cbBufferIn );

    //  IClusCfgVerifyQuorum
    STDMETHOD( PrepareToHostQuorumResource )( void );
    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );
    STDMETHOD( IsMultiNodeCapable )( void );
    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** class CManagedResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\middletierutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      MiddleTierUtils.cpp
//
//  Description:
//      MiddleTier utility functions.
//
//  Maintained By:
//      Galen Barbee (GalenB) 30-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <pch.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrRetrieveCookiesName
//
//  Description:
//      Get the name associated with the standard info for the passed in
//      cookie.
//
//  Arguments:
//      pomIn
//          Pointer to the object manager.
//
//      cookieIn
//          The cookie's whose name we want.
//
//      pbstrNameOut
//          The name associated with the passed in cookie.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRetrieveCookiesName(
      IObjectManager *  pomIn
    , OBJECTCOOKIE      cookieIn
    , BSTR *            pbstrNameOut
    )
{
    TraceFunc( "" );
    Assert( pomIn != NULL );
    Assert( cookieIn != NULL );
    Assert( pbstrNameOut != NULL );

    HRESULT         hr = S_OK;
    IUnknown *      punk = NULL;
    IStandardInfo * psi  = NULL;

    hr = THR( pomIn->GetObject( DFGUID_StandardInfo, cookieIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psi->GetName( pbstrNameOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( *pbstrNameOut );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( psi != NULL )
    {
        psi->Release();
    } // if:

    HRETURN( hr );

} //*** HrRetrieveCookiesName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\middletierstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      MiddleTierStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 16-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

/////////////////////////////////////////////////////////////////////
// Strings
/////////////////////////////////////////////////////////////////////

#define IDS_TASKID_MINOR_FOUND_RESOURCE                             ( ID_MT_START +   0 )
#define IDS_TASKID_MINOR_FOUND_NETWORK                              ( ID_MT_START +  10 )
#define IDS_TASKID_MINOR_NO_QUORUM_CAPABLE_RESOURCE_FOUND           ( ID_MT_START +  20 )
#define IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_RESOURCE              ( ID_MT_START +  30 )
#define IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM                        ( ID_MT_START +  40 )
#define IDS_TASKID_MINOR_CLUSTER_NOT_FOUND                          ( ID_MT_START +  50 )
#define IDS_TASKID_MINOR_EXISTING_CLUSTER_FOUND                     ( ID_MT_START +  60 )
#define IDS_TASKID_MINOR_FOUND_COMMON_QUORUM_RESOURCE               ( ID_MT_START +  70 )
#define IDS_TASKID_MINOR_FOUND_MINIMUM_SIZE_QUORUM_CAPABLE_RESOURCE ( ID_MT_START +  74 )
#define IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND                 ( ID_MT_START +  80 )
#define IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND                  ( ID_MT_START +  90 )
#define IDS_TASKID_MINOR_NO_JOINING_NODES_FOUND_FOR_VERSION_CHECK   ( ID_MT_START + 100 )
#define IDS_TASKID_MINOR_FOUND_A_QUORUM_CAPABLE_RESOURCE            ( ID_MT_START + 110 )

#define IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND                   ( ID_MT_START + 120 )
#define IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND_REF               ( ID_MT_START + 121 )

#define IDS_TASKID_MINOR_MARKING_QUORUM_CAPABLE_RESOURCE            ( ID_MT_START + 130 )
#define IDS_TASKID_MINOR_NO_NODES_TO_PROCESS                        ( ID_MT_START + 140 )
#define IDS_TASKID_MINOR_ONLY_ONE_NETWORK                           ( ID_MT_START + 150 )
#define IDS_TASKID_MINOR_NODE_ALREADY_IS_MEMBER                     ( ID_MT_START + 160 )
#define IDS_TASKID_MINOR_REQUESTING_REMOTE_CONNECTION               ( ID_MT_START + 170 )
#define IDS_TASKID_MINOR_REMOTE_CONNECTION_REQUESTS                 ( ID_MT_START + 180 )
//#define ( ID_MT_START + 190 )
#define IDS_TASKID_MINOR_NODES_VERSION_MISMATCH                     ( ID_MT_START + 200 )
#define IDS_ERR_ANALYSIS_FAILED_TRY_TO_REANALYZE                    ( ID_MT_START + 210 )
#define IDS_TASKID_MINOR_CHECKINTEROPERABILITY                      ( ID_MT_START + 220 )
#define IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE                         ( ID_MT_START + 230 )
#define IDS_TASKID_MINOR_BAD_CREDENTIALS                            ( ID_MT_START + 240 )
#define IDS_TASKID_MINOR_FAILED_TO_CONNECT_TO_NODE                  ( ID_MT_START + 250 )
#define IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_ERROR       ( ID_MT_START + 260 )
#define IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_ERROR_REF   ( ID_MT_START + 261 )
#define IDS_TASKID_MINOR_CLUSTER_NAME_MISMATCH                      ( ID_MT_START + 270 )
#define IDS_TASKID_MINOR_INCONSISTANT_MIDDLETIER_DATABASE           ( ID_MT_START + 280 )
#define IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER                   ( ID_MT_START + 290 )
#define IDS_TASKID_MINOR_CLUSTER_MEMBERSHIP_VERIFIED                ( ID_MT_START + 300 )
#define IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE               ( ID_MT_START + 310 )
#define IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_ERROR            ( ID_MT_START + 320 )
#define IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_ERROR_REF        ( ID_MT_START + 321 )
#define IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_MIN_CONFIG_REF   ( ID_MT_START + 322 )
#define IDS_TASKID_MINOR_MISSING_JOINABLE_QUORUM_RESOURCE           ( ID_MT_START + 330 )
#define IDS_TASKID_MINOR_VALIDATING_CREDENTIALS                     ( ID_MT_START + 340 )
#define IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE                 ( ID_MT_START + 350 )
#define IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE_REF             ( ID_MT_START + 351 )
#define IDS_TASKID_MINOR_CONNECTING_TO_NODES                        ( ID_MT_START + 360 )
#define IDS_TASKID_MINOR_FORMING_NODE                               ( ID_MT_START + 370 )
#define IDS_TASKID_MINOR_JOINING_NODE                               ( ID_MT_START + 380 )
#define IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES                  ( ID_MT_START + 390 )
#define IDS_TASKID_MINOR_CHECKING_NODE_CLUSTER_FEASIBILITY          ( ID_MT_START + 400 )
#define IDS_TASKID_MINOR_CHECKING_FOR_EXISTING_CLUSTER              ( ID_MT_START + 410 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR         ( ID_MT_START + 420 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR_REF     ( ID_MT_START + 425 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_CD_WARNING    ( ID_MT_START + 430 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_NET_WARNING   ( ID_MT_START + 432 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_RAM_WARNING   ( ID_MT_START + 434 )
#define IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_WARNING_REF   ( ID_MT_START + 435 )
#define IDS_TASKID_MINOR_PROCESSOR_ARCHITECTURE_MISMATCH            ( ID_MT_START + 440 )
#define IDS_TASKID_MINOR_PROCESSOR_ARCHITECTURE_MISMATCH_REF        ( ID_MT_START + 450 )
#define IDS_TASKID_MINOR_COMPARE_RESOURCES                          ( ID_MT_START + 460 )
#define IDS_TASKID_MINOR_CHECK_PROCESSOR_ARCHITECTURE               ( ID_MT_START + 470 )
#define IDS_TASKID_MINOR_CHECK_CLUSTER_MEMBERSHIP                   ( ID_MT_START + 480 )
#define IDS_TASKID_CLUSTER_MEMBERSHIP_VERIFIED                      ( ID_MT_START + 490 )
#define IDS_TASKID_MINOR_CHECK_DRIVELETTER_MAPPINGS                 ( ID_MT_START + 500 )
#define IDS_TASKID_MINOR_COMPARE_NETWORKS                           ( ID_MT_START + 510 )
#define IDS_TASKID_MINOR_NO_PUBLIC_NETWORKS_FOUND                   ( ID_MT_START + 520 )
#define IDS_TASKID_MINOR_NO_PRIVATE_NETWORKS_FOUND                  ( ID_MT_START + 530 )
#define IDS_TASKID_MINOR_COMPARING_CONFIGURATION                    ( ID_MT_START + 540 )
#define IDS_TASKID_MINOR_CHECK_DRIVELETTER_MAPPINGS_MIN_CONFIG      ( ID_MT_START + 550 )
#define IDS_TASKID_MINOR_COMPARE_RESOURCES_ENUM_FIRST_NODE_QUORUM   ( ID_MT_START + 560 )
#define IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_WARN        ( ID_MT_START + 570 )
#define IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_WARN_REF    ( ID_MT_START + 571 )
#define IDS_TASKID_MINOR_NODES_CANNOT_ACCESS_QUORUM                 ( ID_MT_START + 580 )
#define IDS_TASKID_MINOR_CHECK_DOMAIN_MEMBERSHIP                    ( ID_MT_START + 590 )
#define IDS_TASKID_MINOR_CHECK_DOMAIN_MEMBERSHIP_ERROR_REF          ( ID_MT_START + 592 )
#define IDS_TASKID_MINOR_DISCONNECTING_FROM_SERVER                  ( ID_MT_START + 600 )
#define IDS_TASKID_MINOR_DISCONNECTING_FROM_SERVER_REF              ( ID_MT_START + 601 )
#define IDS_TASKID_MINOR_ADD_JOINED_NODES                           ( ID_MT_START + 610 )
#define IDS_ERR_NO_RC2_INTERFACE                                    ( ID_MT_START + 620 )
#define IDS_TASKID_MINOR_CHECK_NODE_DOMAINS                         ( ID_MT_START + 630 )
#define IDS_TASKID_MINOR_CHECK_NODE_DOMAINS_ERROR                   ( ID_MT_START + 640 )
#define IDS_TASKID_MINOR_CHECK_NODE_DOMAINS_ERROR_REF               ( ID_MT_START + 650 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\nodeinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      NodeInformation.cpp
//
//  Description:
//      Node Information object implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NodeInformation.h"
#include "ClusterConfiguration.h"

DEFINE_THISCLASS("CNodeInformation")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CNodeInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNodeInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CNodeInformation *  pni = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pni = new CNodeInformation;
    if ( pni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pni->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pni != NULL )
    {
        pni->Release();
    }

    HRETURN( hr );

} //*** CNodeInformation::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CNodeInformation::CNodeInformation
//
//////////////////////////////////////////////////////////////////////////////
CNodeInformation::CNodeInformation( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CNodeInformation::CNodeInformation

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IClusCfgNodeInfo
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_fIsMember == FALSE );
    Assert( m_pccci == NULL );
    Assert( m_dwHighestVersion == 0 );
    Assert( m_dwLowestVersion == 0 );
    Assert( m_dwMajorVersion == 0 );
    Assert( m_dwMinorVersion == 0 );
    Assert( m_wSuiteMask == 0 );
    Assert( m_bProductType == 0 );
    Assert( m_bstrCSDVersion == NULL );
    Assert( m_dlmDriveLetterMapping.dluDrives[ 0 ] == 0 );
    Assert( m_wProcessorArchitecture == 0 );
    Assert( m_wProcessorLevel == 0 );
    Assert( m_cMaxNodes == 0 );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CNodeInformation::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CNodeInformation::~CNodeInformation
//
//////////////////////////////////////////////////////////////////////////////
CNodeInformation::~CNodeInformation( void )
{
    TraceFunc( "" );

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrCSDVersion );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CNodeInformation::~CNodeInformation


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeInformation::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgNodeInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNodeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
    } // else if: IClusCfgNodeInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
    } // else if: IExtendObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CNodeInformation::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNodeInformation::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNodeInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CNodeInformation::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNodeInformation::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNodeInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CNodeInformation::Release


// ************************************************************************
//
//  IClusCfgNodeInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetName(
//      BSTR * pbstrNameOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrName == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CNodeInformation::GetName


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_fHasNameChanged = TRUE;
    m_bstrName        = bstrNewName;

Cleanup:
    HRETURN( hr );

} //*** CNodeInformation::SetName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::IsMemberOfCluster
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( m_fIsMember == FALSE )
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CNodeInformation::IsMemberOfCluster

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetClusterConfigInfo(
//      IClusCfgClusterInfo * * ppClusCfgClusterInfoOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetClusterConfigInfo(
    IClusCfgClusterInfo * * ppClusCfgClusterInfoOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;

    if ( ppClusCfgClusterInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_pccci == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_pccci->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );

Cleanup:
    HRETURN( hr );

} //*** CNodeInformation::GetClusterConfigInfo


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetOSVersion(
//      DWORD * pdwMajorVersionOut,
//      DWORD * pdwMinorVersionOut,
//      WORD *  pwSuiteMaskOut,
//      BYTE *  pbProductTypeOut
//      BSTR *  pbstrCSDVersionOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetOSVersion(
    DWORD * pdwMajorVersionOut,
    DWORD * pdwMinorVersionOut,
    WORD *  pwSuiteMaskOut,
    BYTE *  pbProductTypeOut,
    BSTR *  pbstrCSDVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdwMajorVersionOut == NULL
      || pdwMinorVersionOut == NULL
      || pwSuiteMaskOut == NULL
      || pbProductTypeOut == NULL
      || pbstrCSDVersionOut == NULL
       )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pdwMajorVersionOut = m_dwMajorVersion;
    *pdwMinorVersionOut  = m_dwMinorVersion;
    *pwSuiteMaskOut = m_wSuiteMask;
    *pbProductTypeOut = m_bProductType;

    *pbstrCSDVersionOut = TraceSysAllocString( m_bstrCSDVersion );
    if ( *pbstrCSDVersionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CNodeInformation::GetOSVersion


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetClusterVersion(
//      DWORD * pdwNodeHighestVersion,
//      DWORD * pdwNodeLowestVersion
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetClusterVersion(
    DWORD * pdwNodeHighestVersion,
    DWORD * pdwNodeLowestVersion
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdwNodeHighestVersion == NULL
      || pdwNodeLowestVersion == NULL
       )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pdwNodeHighestVersion = m_dwHighestVersion;
    *pdwNodeLowestVersion  = m_dwLowestVersion;

Cleanup:
    HRETURN( hr );

} //*** CNodeInformation::GetClusterVersion

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetDriveLetterMappings(
//      SDriveLetterMapping * pdlmDriveLetterUsageOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )

{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    *pdlmDriveLetterUsageOut = m_dlmDriveLetterMapping;

    HRETURN( hr );

} //*** CNodeInformation::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeInformation::GetMaxNodeCount
//
//  Description:
//      Returns the maximun number of nodes for this node's product
//      suite type.
//
//  Notes:
//
//  Parameter:
//      pcMaxNodesOut
//          The maximum number of nodes allowed by this node's product
//          suite type.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pcMaxNodesOut = m_cMaxNodes;

Cleanup:

    HRETURN( hr );

} //*** CNodeInformation::GetMaxNodeCount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeInformation::GetProcessorInfo
//
//  Description:
//      Get the processor information for this node.
//
//  Arguments:
//      pwProcessorArchitectureOut
//          The processor architecture.
//
//      pwProcessorLevelOut
//          The processor type.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//  Remarks:
//      See SYSTEM_INFO in MSDN and/or the Platform SDK for more
//      information.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetProcessorInfo(
      WORD *    pwProcessorArchitectureOut
    , WORD *    pwProcessorLevelOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( ( pwProcessorArchitectureOut == NULL ) && ( pwProcessorLevelOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( pwProcessorArchitectureOut != NULL )
    {
        *pwProcessorArchitectureOut = m_wProcessorArchitecture;
    } // if:

    if ( pwProcessorLevelOut != NULL )
    {
        *pwProcessorLevelOut = m_wProcessorLevel;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CNodeInformation::GetProcessorInfo


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    IServiceProvider *  psp;

    BSTR    bstrClusterName = NULL;

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgNodeInfo *      pccni = NULL;

    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Grab the right interface.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Gather the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    //
    //  Gather Name
    //

    hr = THR( pccni->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }
    TraceMemoryAddBSTR( m_bstrName );

    m_fHasNameChanged = FALSE;

    //
    //  Gather Is Member?
    //

    hr = STHR( pccni->IsMemberOfCluster() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        m_fIsMember = TRUE;
    }
    else
    {
        m_fIsMember = FALSE;
    }

    if ( m_fIsMember )
    {
        IGatherData * pgd;

        //
        //  Gather Cluster Configuration
        //

        hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( CClusterConfiguration::S_HrCreateInstance( &punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pgd->Gather( NULL, pccci ) );
        pgd->Release();    // release promptly
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &m_pccci ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pccci->Release();
        pccci = NULL;

    } // if: node if a member of a cluster

    //
    //  Gather OS Version
    //

    hr = THR( pccni->GetOSVersion(
                        &m_dwMajorVersion,
                        &m_dwMinorVersion,
                        &m_wSuiteMask,
                        &m_bProductType,
                        &m_bstrCSDVersion
                        ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrCSDVersion );

    //
    //  Gather Cluster Version
    //

    hr = THR( pccni->GetClusterVersion( &m_dwHighestVersion, &m_dwLowestVersion ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather Drive Letter Mappings
    //

    hr = STHR( pccni->GetDriveLetterMappings( &m_dlmDriveLetterMapping ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = STHR( pccni->GetMaxNodeCount( &m_cMaxNodes ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    hr = STHR( pccni->GetProcessorInfo( &m_wProcessorArchitecture, &m_wProcessorLevel ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    //
    //  Anything else to gather??
    //

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( bstrClusterName != NULL )
    {
        TraceSysFreeString( bstrClusterName );
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_fHasNameChanged = FALSE;
    m_fIsMember = FALSE;
    if ( m_pccci != NULL )
    {
        m_pccci->Release();
        m_pccci = NULL;
    }
    m_dwHighestVersion = 0;
    m_dwLowestVersion = 0;
    ZeroMemory( &m_dlmDriveLetterMapping, sizeof( m_dlmDriveLetterMapping ) );
    goto Cleanup;

} //*** CNodeInformation::Gather


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CNodeInformation::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = S_OK;

    //
    //  Check parameters...
    //

    //  Gotta have a cookie
    if ( cookieIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need to be representing a NodeType.
    if ( ! IsEqualIID( rclsidTypeIn, CLSID_NodeType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //  We need a name.
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    // Free m_bstrName before we allocate a new value.
    //
    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

     //
    //  Save our name.
    //
    m_bstrName = TraceSysAllocString( pcszNameIn );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Get the pointer.
    //
    if ( ppunkOut != NULL )
    {
        hr = THR( QueryInterface( DFGUID_NodeInformation,
                                  reinterpret_cast< void ** > ( ppunkOut )
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: ppunkOut

    //
    //  Tell caller that the data is pending.
    //
    hr = E_PENDING;

Cleanup:

    HRETURN( hr );

} //*** CNodeInformation::FindObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\notificationmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      NotificationMgr.h
//
//  Description:
//      Notification Manager implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CConnPointEnum;

// CNotificationManager
class CNotificationManager
    : public INotificationManager
    , public IConnectionPointContainer
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference counter

    // IConnectionPointContainer
    CConnPointEnum *    m_penumcp;  //  CP Enumerator and list
    CCriticalSection    m_csInstanceGuard;

private: // Methods
    CNotificationManager( void );
    ~CNotificationManager( void );
    STDMETHOD( HrInit )( void );

    // Private copy constructor to prevent copying.
    CNotificationManager( const CNotificationManager & );

    // Private assignment operator to prevent copying.
    CNotificationManager & operator=( const CNotificationManager & );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // INotificationManager
    //
    STDMETHOD( AddConnectionPoint )( REFIID riidIn, IConnectionPoint * pcpIn );

    //
    // IConnectionPointContainer
    //
    STDMETHOD( EnumConnectionPoints )( IEnumConnectionPoints ** ppEnumOut );
    STDMETHOD( FindConnectionPoint )( REFIID riidIn, IConnectionPoint ** ppCPOut );

}; //*** class CNotificationManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\middletierutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      MiddleTierUtils.h
//
//  Description:
//      Utility functions
//
//  Maintained By:
//      Galen Barbee    (GalenB) 30-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


HRESULT
HrRetrieveCookiesName(
      IObjectManager *  pomIn
    , OBJECTCOOKIE      cookieIn
    , BSTR *            pbstrNameOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\nodeinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      NodeInformation.h
//
//  Description:
//      CNodeInformation implementation.
//
//  Maintained By:
//      Galen barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumNodeInformation;

// CNodeInformation
class CNodeInformation
    : public IExtendObjectManager
    , public IClusCfgNodeInfo
    , public IGatherData  // internal
{
friend class CEnumNodeInformation;
private:
    // IUnknown
    LONG                    m_cRef;

    // Async/IClusNodeInfo
    BSTR                    m_bstrName;                 // Name of the node
    BOOL                    m_fHasNameChanged;          // If the node name was changed...
    BOOL                    m_fIsMember;                // If the node is a member of a cluster...
    IClusCfgClusterInfo *   m_pccci;                    // Interface to the node's cluster info (might not be the same as the cluster we are joining)
    DWORD                   m_dwHighestVersion;         //
    DWORD                   m_dwLowestVersion;          //
    DWORD                   m_dwMajorVersion;           // OS Major version.  See OSVERSIONINFOEX
    DWORD                   m_dwMinorVersion;           // OS Minor version.  See OSVERSIONINFOEX
    WORD                    m_wSuiteMask;               // Product suite mask.  See OSVERSIONINFOEX
    BYTE                    m_bProductType;             // OS product type.  See OSVERSIONINFOEX
    BSTR                    m_bstrCSDVersion;           // Service pack info.  See OSVERSIONINFOEX
    SDriveLetterMapping     m_dlmDriveLetterMapping;    // Drive letter mappings
    WORD                    m_wProcessorArchitecture;   // Processor architecture, x86, IA64, etc.
    WORD                    m_wProcessorLevel;          // Processor type, 386, 486, etc
    DWORD                   m_cMaxNodes;                // Max node count for this node.

    // IExtendObjectManager

private: // Methods
    CNodeInformation( void );
    ~CNodeInformation( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNodeInfo
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR bstrNameIn );
    STDMETHOD( IsMemberOfCluster )( void );
    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo ** ppClusCfgClusterInfoOut );
    STDMETHOD( GetOSVersion )(
                DWORD * pdwMajorVersionOut,
                DWORD * pdwMinorVersionOut,
                WORD *  pwSuiteMaskOut,
                BYTE *  pbProductTypeOut,
                BSTR *  pbstrCSDVersionOut
                );
    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );
    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );
    STDMETHOD( GetProcessorInfo )( WORD * pwProcessorArchitectureOut, WORD * wProcessorLevelOut );


    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; //*** class CNodeInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\objectmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ObjectManager.h
//
//  Description:
//      Data Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CStandardInfo;

//  CObjectManager
class CObjectManager
    : public IObjectManager
{
private:
    // IUnknown
    LONG                    m_cRef;

    // data
    ULONG                   m_cAllocSize;       //  Size of the cookie array.
    ULONG                   m_cCurrentUsed;     //  Current count used in the cookie array.
    CStandardInfo **        m_pCookies;         //  Cookie array (note: zero-th element is not used)
    CCriticalSection        m_csInstanceGuard;  //  Spin lock to restrict access to one thread at a time.

private: // Methods
    CObjectManager( void );
    ~CObjectManager( void );
    STDMETHOD( HrInit )( void );

    // Private copy constructor to prevent copying.
    CObjectManager( const CObjectManager & );

    // Private assignment operator to prevent copying.
    CObjectManager & operator=( const CObjectManager & );

    HRESULT
        HrSearchForExistingCookie( REFCLSID rclsidTypeIn,
                                   OBJECTCOOKIE     cookieParentIn,
                                   LPCWSTR          pcszNameIn,
                                   OBJECTCOOKIE *   pcookieOut
                                   );
    HRESULT HrDeleteCookie( OBJECTCOOKIE  cookieIn );
    HRESULT HrDeleteInstanceAndChildren( OBJECTCOOKIE cookieIn );
    HRESULT
        HrCreateNewCookie( REFCLSID        rclsidTypeIn,
                           OBJECTCOOKIE    cookieParentIn,
                           LPCWSTR         pcszNameIn,
                           OBJECTCOOKIE *  pcookieOut
                           );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown
    //
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    // IObjectManager
    //
    STDMETHOD( FindObject )( REFCLSID             rclsidTypeIn,
                             OBJECTCOOKIE         cookieParent,
                             LPCWSTR              pcszNameIn,
                             REFCLSID             rclsidFormatIn,
                             OBJECTCOOKIE *       pcookieOut,
                             LPUNKNOWN *          ppunkOut
                             );
    STDMETHOD( GetObject )( REFCLSID              rclsidFormatIn,
                            OBJECTCOOKIE          cookieIn,
                            LPUNKNOWN *           ppunkOut
                            );
    STDMETHOD( RemoveObject )( OBJECTCOOKIE       cookieIn );
    STDMETHOD( SetObjectStatus )( OBJECTCOOKIE    cookieIn,
                                  HRESULT         hrIn
                                  );

}; //*** class CObjectManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\objectmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ObjectManager.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ObjectManager.h"
#include "ConnectionInfo.h"
#include "StandardInfo.h"
#include "EnumCookies.h"

DEFINE_THISCLASS("CObjectManager")

#define COOKIE_BUFFER_GROW_SIZE 100

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  LPUNKNOWN
//  CObjectManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    CObjectManager *    pom = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        pom = new CObjectManager();
        if ( pom == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( pom->HrInit() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pom->TypeSafeQI( IUnknown, ppunkOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // if: service manager doesn't exists
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                                   IUnknown,
                                   ppunkOut
                                   ) );
        psp->Release();

    } // else: service manager exists

Cleanup:

    if ( pom != NULL )
    {
        pom->Release();
    }

    HRETURN( hr );

} //*** CObjectManager::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CObjectManager::CObjectManager
//
//////////////////////////////////////////////////////////////////////////////
CObjectManager::CObjectManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CObjectManager::CObjectManager

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( m_cRef == 1 );

    //  IObjectManager
    Assert( m_cAllocSize == 0 );
    Assert( m_cCurrentUsed == 0 );
    Assert( m_pCookies == NULL );

    hr = THR( m_csInstanceGuard.HrInitialized() );    

    HRETURN( hr );

} //*** CObjectManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CObjectManager::~CObjectManager
//
//////////////////////////////////////////////////////////////////////////////
CObjectManager::~CObjectManager( void )
{
    TraceFunc( "" );

    if ( m_pCookies != NULL )
    {
        while ( m_cCurrentUsed != 0 )
        {
            m_cCurrentUsed --;

            if ( m_pCookies[ m_cCurrentUsed ] != NULL )
            {
                m_pCookies[ m_cCurrentUsed ]->Release();
            }
        }

        TraceFree( m_pCookies );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CObjectManager::~CObjectManager


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjectManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< LPUNKNOWN >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IObjectManager, this, 0 );
    } // else if: IObjectManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CObjectManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CObjectManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjectManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CObjectManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CObjectManager::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjectManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CObjectManager::Release


// ************************************************************************
//
//  IObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CObjectManager::FindObject(
//      REFCLSID            rclsidTypeIn,
//      OBJECTCOOKIE        cookieParentIn,
//      LPCWSTR             pcszNameIn,
//      REFCLSID            rclsidFormatIn,
//      OBJECTCOOKIE *      cookieOut,
//      LPUNKNOWN *         punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::FindObject(
    REFCLSID            rclsidTypeIn,
    OBJECTCOOKIE        cookieParentIn,
    LPCWSTR             pcszNameIn,
    REFCLSID            rclsidFormatIn,
    OBJECTCOOKIE *      pcookieOut,
    LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IObjectManager]" );

    ExtObjectEntry *        pentry;
    HRESULT                 hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );
    OBJECTCOOKIE            cookie = 0;
    CStandardInfo *         pcsi = NULL;      // don't free
    BOOL                    fTempCookie = FALSE;
    CEnumCookies *          pcec = NULL;
    IUnknown *              punk = NULL;
    IExtendObjectManager *  peom = NULL;

    //
    //  Check to see if we already have an object.
    //
    m_csInstanceGuard.Enter();
    if ( pcszNameIn != NULL )
    {
        hr = STHR( HrSearchForExistingCookie( rclsidTypeIn, cookieParentIn, pcszNameIn, &cookie ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            hr = THR( HrCreateNewCookie( rclsidTypeIn, cookieParentIn, pcszNameIn, &cookie ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            pcsi = m_pCookies[ cookie ];
            Assert( pcsi != NULL );
        }
        else if ( hr == S_OK )
        {
            //
            //  Found an existing cookie.
            //

            if ( pcookieOut != NULL )
            {
                *pcookieOut = cookie;
            }

            if ( ppunkOut != NULL )
            {
                pcsi = m_pCookies[ cookie ];

                //
                //  Is the object still in an failed state or still pending?
                //

                if ( FAILED( pcsi->m_hrStatus ) )
                {
                    hr = pcsi->m_hrStatus;
                    goto Cleanup;
                }

                //
                //  Retrieve the requested format.
                //

                hr = THR( GetObject( rclsidFormatIn, cookie, ppunkOut ) );
                //  we always jump to cleanup. No need to check hr here.

                goto Cleanup;
            }

        }
        else
        {
            //
            //  Unexpected error_success - now what?
            //
            Assert( hr == S_OK );
            goto Cleanup;
        }

    } // if: named object
    else
    {
        Assert( pcsi == NULL );
    }

    //
    //  Create a new object.
    //

    if ( IsEqualIID( rclsidFormatIn, IID_NULL )
      || ppunkOut == NULL
       )
    {
        //
        //  No-op.
        //
        hr = S_OK;
    } // if: IID_NULL
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_StandardInfo ) )
    {
        hr = THR( pcsi->QueryInterface( DFGUID_StandardInfo,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // else if: standard info
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_ConnectionInfoFormat ) )
    {
        if ( pcsi->m_pci != NULL )
        {
            *ppunkOut = TraceInterface( L"CConnectionInfo!ObjectManager", IConnectionInfo, pcsi->m_pci, 0 );
            (*ppunkOut)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = THR( CConnectionInfo::S_HrCreateInstance( &punk, pcsi->m_cookieParent ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IConnectionInfo,
                                        &pcsi->m_pci
                                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( punk->QueryInterface( IID_IConnectionInfo,
                                            reinterpret_cast< void ** >( ppunkOut )
                                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // else:
    } // else if: connection info
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_EnumCookies ) )
    {
        ULONG   cIter;

        //
        //  Create a new cookie enumerator.
        //

        pcec = new CEnumCookies;
        if ( pcec == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        //
        //  Initialize the enumerator. This also causes an AddRef().
        //

        hr = THR( pcec->HrInit() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  See who matches our citeria.
        //

        pcec->m_cIter = 0;

        for( cIter = 1; cIter < m_cCurrentUsed; cIter ++ )
        {
            pcsi = m_pCookies[ cIter ];

            if ( pcsi != NULL )
            {
                if ( rclsidTypeIn == IID_NULL
                  || pcsi->m_clsidType == rclsidTypeIn
                   )
                {
                    if ( cookieParentIn == NULL
                      || pcsi->m_cookieParent == cookieParentIn
                       )
                    {
                        if ( ( pcszNameIn == NULL )
                          ||    ( ( pcsi->m_bstrName != NULL )
                               && ( StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0 )
                                )
                           )
                        {
                            //
                            //  Match!
                            //
                            pcec->m_cIter ++;

                        } // if: names match

                    } // if: parents match

                } // if: match parent and type

            } // if: valid element

        } // for: cIter

        if ( pcec->m_cIter == 0 )
        {
            // The error text is better than the coding value.
            hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
            goto Cleanup;
        }

        //
        //  Alloc an array to hold the cookies.
        //

        pcec->m_pList = (OBJECTCOOKIE*) TraceAlloc( HEAP_ZERO_MEMORY, pcec->m_cIter * sizeof(OBJECTCOOKIE) );
        if ( pcec->m_pList == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        pcec->m_cAlloced = pcec->m_cIter;
        pcec->m_cIter = 0;

        for( cIter = 1; cIter < m_cCurrentUsed; cIter ++ )
        {
            pcsi = m_pCookies[ cIter ];

            if ( pcsi != NULL )
            {
                if ( rclsidTypeIn == IID_NULL
                  || pcsi->m_clsidType == rclsidTypeIn
                   )
                {
                    if ( cookieParentIn == NULL
                      || pcsi->m_cookieParent == cookieParentIn
                      )
                    {
                        if ( ( pcszNameIn == NULL )
                          ||    ( ( pcsi->m_bstrName != NULL )
                               && ( StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0 )
                                )
                           )
                        {
                            //
                            //  Match!
                            //

                            pcec->m_pList[ pcec->m_cIter ] = cIter;

                            pcec->m_cIter ++;

                        } // if: names match

                    } // if: parents match

                } // if: match parent and type

            } // if: valid element

        } // for: cIter

        Assert( pcec->m_cIter != 0 );
        pcec->m_cCookies = pcec->m_cIter;
        pcec->m_cIter = 0;

        //
        //  Grab the inteface on the way out.
        //

        hr = THR( pcec->QueryInterface( IID_IEnumCookies,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // else if: enum cookies
    else
    {
        //
        //  Check for extension formats.
        //

        //
        //  See if the format already exists for this cookie.
        //

        if ( punk != NULL )
        {
            punk->Release();
            punk = NULL;
        }

        if ( pcsi != NULL )
        {
            for( pentry = pcsi->m_pExtObjList; pentry != NULL; pentry = pentry->pNext )
            {
                if ( pentry->iid == rclsidFormatIn )
                {
                    hr = THR( pentry->punk->QueryInterface( rclsidFormatIn,
                                                            reinterpret_cast< void ** >( &punk )
                                                            ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }

                    break; // exit loop
                }

            } // for: pentry

        } // if: have cookie
        else
        {
            //
            //  Create a temporary cookie.
            //

            Assert( pcszNameIn == NULL );

            hr = THR( HrCreateNewCookie( IID_NULL, cookieParentIn, NULL, &cookie ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            fTempCookie = TRUE;

            Assert( pcsi == NULL );

        } // else: need a temporary cookie

        if ( punk == NULL )
        {
            //
            //  Possibly a new or externally object, try creating it and querying.
            //

            hr = THR( HrCoCreateInternalInstance( rclsidFormatIn,
                                                  NULL,
                                                  CLSCTX_ALL,
                                                  TypeSafeParams( IExtendObjectManager, &peom )
                                                  ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            Assert( punk == NULL );
            // Can't wrap with THR because it can return E_PENDING.
            hr = peom->FindObject( cookie,
                                   rclsidTypeIn,
                                   pcszNameIn,
                                   &punk
                                   );
            if ( hr == E_PENDING )
            {
                // ignore
            }
            else if ( FAILED( hr ) )
            {
                THR( hr );
                goto Cleanup;
            }

            if ( fTempCookie )
            {
                (m_pCookies[ cookie ])->Release();
                m_pCookies[ cookie ] = NULL;
            }
            else
            {
                //
                //  Keep track of the format (if extension wants)
                //

                if (  (  ( SUCCEEDED( hr )
                        && hr != S_FALSE
                         )
                     || hr == E_PENDING
                      )
                  && punk != NULL
                  && pcsi != NULL
                   )
                {
                    pentry = (ExtObjectEntry *) TraceAlloc( 0, sizeof( ExtObjectEntry ) );
                    if ( pentry == NULL )
                    {
                        hr = THR( E_OUTOFMEMORY );
                        goto Cleanup;
                    }

                    pentry->iid   = rclsidFormatIn;
                    pentry->pNext = pcsi->m_pExtObjList;
                    pentry->punk  = punk;
                    pentry->punk->AddRef();

                    pcsi->m_pExtObjList = pentry;   //  update header of list (LIFO)
                    pcsi->m_hrStatus    = hr;       //  update status
                }

            } // else: persistent cookie

            if ( SUCCEEDED( hr ) )
            {
                //  Give up ownership
                *ppunkOut = punk;
                punk = NULL;
            }

        } // if: creating new object

    } // else: possible extension format

    //
    //  Save stuff for the caller.
    //

    if ( pcookieOut != NULL )
    {
        *pcookieOut = cookie;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( peom != NULL )
    {
        peom->Release();
    }
    if ( pcec != NULL )
    {
        pcec->Release();
    }

    m_csInstanceGuard.Leave();
    
    HRETURN( hr );

} //*** CObjectManager::FindObject

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CObjectManager::GetObject(
//      REFCLSID        rclsidFormatIn,
//      OBJECTCOOKIE    cookieIn,
//      LPUNKNOWN *     ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::GetObject(
    REFCLSID        rclsidFormatIn,
    OBJECTCOOKIE    cookieIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IObjectManager]" );

    CStandardInfo * pcsi;
    ExtObjectEntry * pentry;

    HRESULT hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );

    IUnknown *             punk = NULL;
    IExtendObjectManager * peom = NULL;

    //
    //  Check parameters
    //
    m_csInstanceGuard.Enter();
    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Create the request format object.
    //

    if ( IsEqualIID( rclsidFormatIn, IID_NULL )
      || ppunkOut == NULL
       )
    {
        //
        //  No-op.
        //
        hr = S_OK;
    } // if: IID_NULL
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_StandardInfo ) )
    {
        hr = THR( pcsi->QueryInterface( DFGUID_StandardInfo,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // else if: Standard Info
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_ConnectionInfoFormat ) )
    {
        if ( pcsi->m_pci != NULL )
        {
            *ppunkOut = pcsi->m_pci;
            (*ppunkOut)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = THR( CConnectionInfo::S_HrCreateInstance( &punk, pcsi->m_cookieParent ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IConnectionInfo,
                                        &pcsi->m_pci
                                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( punk->QueryInterface( IID_IConnectionInfo,
                                            reinterpret_cast< void ** >( ppunkOut )
                                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
    } // else if: Connection Info
    else
    {
        //
        //  See if the format already exists for this cookie.
        //

        if ( punk != NULL )
        {
            punk->Release();
            punk = NULL;
        }

        for( pentry = pcsi->m_pExtObjList; pentry != NULL; pentry = pentry->pNext )
        {
            if ( pentry->iid == rclsidFormatIn )
            {
                hr = THR( pentry->punk->QueryInterface( rclsidFormatIn,
                                                        reinterpret_cast< void ** >( &punk )
                                                        ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                break; // exit loop
            }

        } // for: pentry

        if ( punk == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
            goto Cleanup;
        }

        //  Give up ownership
        *ppunkOut = punk;
        punk = NULL;

    } // else: external?

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( peom != NULL )
    {
        peom->Release();
    }

    m_csInstanceGuard.Leave();
    
    HRETURN( hr );

} //*** CObjectManager::GetObject

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::RemoveObject(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::RemoveObject(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[IObjectManager]" );

    HRESULT hr = S_FALSE;
    CStandardInfo * pcsi;

    //
    //  Check parameters
    //
    m_csInstanceGuard.Enter();
    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    hr = THR( HrDeleteInstanceAndChildren( cookieIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    m_csInstanceGuard.Leave();
    
    HRETURN( hr );

} //*** CObjectManager::RemoveObject

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::SetObjectStatus(
//      OBJECTCOOKIE          cookieIn,
//      HRESULT               hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::SetObjectStatus(
    OBJECTCOOKIE    cookieIn,
    HRESULT         hrIn
    )
{
    TraceFunc( "[IObjectManager]" );

    HRESULT hr = S_OK;
    CStandardInfo * pcsi;

    //
    //  Check parameters
    //
    m_csInstanceGuard.Enter();
    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    //  Update the status.
    //

    pcsi->m_hrStatus = hrIn;

Cleanup:

    m_csInstanceGuard.Leave();

    HRETURN( hr );

} //*** CObjectManager::SetObjectStatus


//****************************************************************************
//
//  Privates
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrDeleteCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrDeleteCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc1( "cookieIn = %#X", cookieIn );

    HRESULT hr = S_OK;

    CStandardInfo * pcsi;

    Assert( cookieIn != 0 && cookieIn < m_cCurrentUsed );

    pcsi = m_pCookies[ cookieIn ];
    Assert( pcsi != NULL );
    pcsi->Release();
    m_pCookies[ cookieIn ] = NULL;

    HRETURN( hr );

} //*** CObjectManager::HrDeleteCookie

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrSearchForExistingCookie(
//      OBJECTCOOKIE cookieIn,
//      LPUNKNOWN ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrSearchForExistingCookie(
    REFCLSID        rclsidTypeIn,
    OBJECTCOOKIE    cookieParentIn,
    LPCWSTR         pcszNameIn,
    OBJECTCOOKIE *  pcookieOut
    )
{
    TraceFunc( "" );

    Assert( pcszNameIn != NULL );
    Assert( pcookieOut != NULL );

    HRESULT hr = S_FALSE;
    ULONG   idx;

    CStandardInfo * pcsi;

    //
    //  Search the list.
    //
    for( idx = 1; idx < m_cCurrentUsed; idx ++ )
    {
        pcsi = m_pCookies[ idx ];

        if ( pcsi != NULL )
        {
            if ( pcsi->m_cookieParent == cookieParentIn          // matching parents
              && IsEqualIID( pcsi->m_clsidType, rclsidTypeIn )   // matching types
              && StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0    // matching names
               )
            {
                //
                //  Found a match.
                //

                *pcookieOut = idx;
                hr = S_OK;

                break;  // exit loop

            } // if: match

        } // if: cookie exists

    } // while: pcsi

    HRETURN( hr );

} //*** CObjectManager::HrSearchForExistingCookie


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrDeleteInstanceAndChildren(
//      OBJECTCOOKIE   pcsiIn
//      )
//
//  Notes:
//      This should be called while the ListLock is held!
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrDeleteInstanceAndChildren(
    OBJECTCOOKIE   cookieIn
    )
{
    TraceFunc1( "cookieIn = %#X", cookieIn );

    ULONG   idx;
    CStandardInfo * pcsi;

    HRESULT hr = S_OK;

    hr = THR( HrDeleteCookie( cookieIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    for ( idx = 1; idx < m_cCurrentUsed; idx ++ )
    {
        pcsi = m_pCookies[ idx ];

        if ( pcsi != NULL
          && pcsi->m_cookieParent == cookieIn )
        {
            hr = THR( HrDeleteInstanceAndChildren( idx ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

        } // if:

    } // while:

Cleanup:
    HRETURN( hr );

} //*** CObjectManager::HrDeleteInstanceAndChildren

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrCreateNewCookie(
//      REFCLSID        rclsidTypeIn
//      OBJECTCOOKIE    cookieParentIn,
//      BSTR            pcszNameIn,
//      OBJECTCOOKIE *  pcookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrCreateNewCookie(
    REFCLSID        rclsidTypeIn,
    OBJECTCOOKIE    cookieParentIn,
    LPCWSTR         pcszNameIn,
    OBJECTCOOKIE *  pcookieOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    CStandardInfo * pcsi = NULL;

    Assert( pcookieOut != NULL );

    *pcookieOut = 0;

    //
    //  Create some space for it.
    //

    if ( m_cCurrentUsed == m_cAllocSize )
    {
        CStandardInfo ** pnew = (CStandardInfo **) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(CStandardInfo *) * ( m_cAllocSize + COOKIE_BUFFER_GROW_SIZE ) );
        if ( pnew == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        if ( m_pCookies != NULL )
        {
            CopyMemory( pnew, m_pCookies, sizeof(CStandardInfo *) * m_cCurrentUsed );
            TraceFree( m_pCookies );
        }

        m_pCookies = pnew;

        m_cAllocSize += COOKIE_BUFFER_GROW_SIZE;

        if ( m_cCurrentUsed == 0 )
        {
            //
            //  Always skip zero.
            //
            m_cCurrentUsed = 1;
        }
    }

    pcsi = new CStandardInfo();
    if ( pcsi == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pcsi->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_pCookies[ m_cCurrentUsed ] = pcsi;

    //
    //  Initialize the rest of the structure.
    //

    pcsi->m_cookieParent = cookieParentIn;
    pcsi->m_hrStatus     = E_PENDING;

    CopyMemory( &pcsi->m_clsidType, &rclsidTypeIn, sizeof( pcsi->m_clsidType ) );

    if ( pcszNameIn != NULL )
    {
        pcsi->m_bstrName = TraceSysAllocString( pcszNameIn );
        if ( pcsi->m_bstrName == NULL )
        {
            m_cCurrentUsed --;
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: out of memory
    }

    Assert( pcsi->m_pci == NULL );
    Assert( pcsi->m_pExtObjList == NULL );

    //
    //  Keep it around and return SUCCESS!
    //

    pcsi = NULL;
    *pcookieOut = m_cCurrentUsed;
    m_cCurrentUsed ++;
    hr  = S_OK;

Cleanup:
    if ( pcsi != NULL )
    {
        pcsi->Release();
    }

    HRETURN( hr );

} //*** CObjectManager::HrCreateNewCookie
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\notificationmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NotificationMgr.cpp
//
//  Description:
//      Notification Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ConnPointEnum.h"
#include "NotificationManager.h"
#include "CPINotifyUI.h"
#include "CPIClusCfgCallback.h"

DEFINE_THISCLASS("CNotificationManager")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CNotificationManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNotificationManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IServiceProvider *      psp = NULL;
    CNotificationManager *  pnm = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        pnm = new CNotificationManager();
        if ( pnm == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( pnm->HrInit() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pnm->TypeSafeQI( IUnknown, ppunkOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // if: service manager doesn't exist
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IUnknown, ppunkOut ) );
        psp->Release();

    } // else: service manager exists

Cleanup:

    if ( pnm != NULL )
    {
        pnm->Release();
    }

    HRETURN( hr );

} //*** CNotificationManager::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNotificationManager::CNotificationManager
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CNotificationManager::CNotificationManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CNotificationManager::CNotificationManager

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNotificationManager::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    IUnknown * punk = NULL;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IConnectionPointContainer
    Assert( m_penumcp == NULL );

    m_penumcp = new CConnPointEnum();
    if ( m_penumcp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( m_penumcp->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( CCPINotifyUI::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_penumcp->HrAddConnection( IID_INotifyUI, punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    hr = THR( CCPIClusCfgCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_penumcp->HrAddConnection( IID_IClusCfgCallback, punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_csInstanceGuard.HrInitialized() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CNotificationManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CNotificationManager::~CNotificationManager
//
//////////////////////////////////////////////////////////////////////////////
CNotificationManager::~CNotificationManager( void )
{
    TraceFunc( "" );

    if ( m_penumcp != NULL )
    {
        m_penumcp->Release();
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CNotificationManager::~CNotificationManager


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNotificationManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::QueryInterface( 
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotificationManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotificationManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotificationManager, this, 0 );
    } // else if: INotificationManager
    else if ( IsEqualIID( riidIn, IID_IConnectionPointContainer ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConnectionPointContainer, this, 0 );
    } // else if: IConnectionPointContainer
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CNotificationManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNotificationManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNotificationManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CNotificationManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNotificationManager::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNotificationManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CNotificationManager::Release


// ************************************************************************
//
// INotificationManager
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNotificationManager::AddConnectionPoint( 
//      REFIID riidIn, 
//      IConnectionPoint * pcpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::AddConnectionPoint( 
    REFIID riidIn, 
    IConnectionPoint * pcpIn
    )
{
    TraceFunc( "[INotificationManager]" );

    HRESULT hr;

    m_csInstanceGuard.Enter();
    hr = THR( m_penumcp->HrAddConnection( riidIn, pcpIn ) );
    m_csInstanceGuard.Leave();

    HRETURN( hr );

} //*** CNotificationManager::AddConnectionPoint


// ************************************************************************
//
// IConnectionPointContainer
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CNotificationManager::EnumConnectionPoints( 
//      IEnumConnectionPoints **ppEnumOut 
//      )
//
//  Return values:
//      On success the result of m_penumcp->Clone()
//      E_POINTER - null m_penumcp pointer
//      E_INVALIDARG - ppEnumOut is NULL 
//
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CNotificationManager::EnumConnectionPoints( 
    IEnumConnectionPoints **ppEnumOut 
    )
{
    TraceFunc( "[IConnectionPointContainer]" );

    HRESULT hr = S_OK;

    m_csInstanceGuard.Enter();
    
    if ( ( ppEnumOut == NULL ) || ( m_penumcp == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_penumcp->Clone( ppEnumOut ) );

Cleanup:

    m_csInstanceGuard.Leave();

    HRETURN( hr );

} //*** CNotificationManager::EnumConnectionPoints

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CNotificationManager::FindConnectionPoint( 
//      REFIID riidIn, 
//      IConnectionPoint **ppCPOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CNotificationManager::FindConnectionPoint( 
    REFIID              riidIn, 
    IConnectionPoint ** ppCPOut 
    )
{
    TraceFunc( "[IConnectionPointContainer]" );

    IID iid;

    HRESULT hr = S_FALSE;

    IConnectionPoint * pcp = NULL;

    m_csInstanceGuard.Enter();
    if ( ppCPOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( m_penumcp->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    for ( ; ; ) // ever
    {
        if ( pcp != NULL )
        {
            pcp->Release();
            pcp = NULL;
        }

        hr = STHR( m_penumcp->Next( 1, &pcp, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            hr = THR( CONNECT_E_NOCONNECTION );
            break;  // exit condition
        }

        hr = THR( pcp->GetConnectionInterface( &iid ) );
        if ( FAILED( hr ) )
        {
            continue;   // ignore it
        }

        if ( iid != riidIn )
        {
            continue;   // not the right interface
        }

        //
        //  Found it. Give up ownership and exit loop.
        //

        *ppCPOut = pcp;
        pcp = NULL;

        hr = S_OK;

        break;

    } // forever

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    m_csInstanceGuard.Leave();

    HRETURN( hr );

} //*** CNotificationManager::FindConnectionPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define SECURITY_WIN32

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

#include <windows.h>
#include <shlwapi.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <ComCat.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include <windns.h>
#include <clusapi.h>
#include <crt\limits.h>
#include <security.h>
#include <strsafe.h>

#include <clusrtl.h>

#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <Common.h>
#include <CriticalSection.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include "ServiceManager.h"
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>
#include <LoadString.h>
#include <NameUtil.h>

#include "MiddleTierGuids.h"
#include "MiddleTierUtils.h"

#include "MiddleTierStrings.h"
#include "CommonStrings.h"
#include <ClusCfgDef.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\servicemanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ServiceMgr.cpp
//
//  Description:
//      Service Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
// #include "ServiceMgr.h" - already included in DLL.H

DEFINE_THISCLASS("CServiceManager")
#define CServiceManager CServiceManager
#define LPTHISCLASS CServiceManager *

//****************************************************************************
//
// Protected Global
//
//****************************************************************************
IServiceProvider * g_pspServiceManager = NULL;

//****************************************************************************
//
// Class Static Variables
//
//****************************************************************************

CRITICAL_SECTION    CServiceManager::sm_cs;

//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CServiceManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    LPTHISCLASS pthis = NULL;

    EnterCriticalSection( &sm_cs );

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( g_pspServiceManager != NULL )
    {
        hr = THR( g_pspServiceManager->TypeSafeQI( IUnknown, ppunkOut ) );
        goto Cleanup;
    } // if: assign new service manager

    pthis = new CServiceManager();
    if ( pthis == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    //  Can't hold CS in Init.
    //
    LeaveCriticalSection( &sm_cs );

    hr = THR( pthis->HrInit() );
    EnterCriticalSection( &sm_cs );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( g_pspServiceManager == NULL );

    // No REF - or we'll never die!
    g_pspServiceManager = static_cast< IServiceProvider * >( pthis );
    TraceMoveToMemoryList( g_pspServiceManager, g_GlobalMemoryList );

    hr = THR( g_pspServiceManager->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pthis != NULL )
    {
        pthis->Release();
    } // if:

    LeaveCriticalSection( &sm_cs );

    HRETURN( hr );

} //*** CServiceManager::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
// HRESULT
// CServiceManager::S_HrGetManagerPointer( IServiceProvider ** ppspOut )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrGetManagerPointer( IServiceProvider ** ppspOut )
{
    TraceFunc( "ppspOut" );

    HRESULT hr = HRESULT_FROM_WIN32( ERROR_PROCESS_ABORTED );

    EnterCriticalSection( &sm_cs );

    if ( g_pspServiceManager != NULL )
    {
        g_pspServiceManager->AddRef();
        *ppspOut = g_pspServiceManager;
        hr = S_OK;
    } // if: valid service manager
    else
    {
        //
        // KB 18-JUN-2001 DavidP
        //      Don't wrap this with THR because it is expected to return
        //      E_POINTER on the very first call.
        //
        hr = E_POINTER;
    } // else: no pointer

    LeaveCriticalSection( &sm_cs );

    HRETURN ( hr );

} //*** CServiceManager::S_HrGetManagerPointer


//////////////////////////////////////////////////////////////////////////////
//++
//
// CServiceManager::S_HrProcessInitialize
//
//  Description:
//      Do process initialization by intializing the critical section.
//
//  Return Value:
//      S_OK
//
//  Remarks:
//      This function is called from DllMain() when DLL_PROCESS_ATTACH
//      is sent.  This function is needed because we need a known point
//      to create a critical section that synchronizes the creation and
//      deletion  of this object.  Given this object's life cycle and
//      static creator function it is possible to have a race when this
//      object is destrying itself with the static creator function.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrProcessInitialize( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( InitializeCriticalSectionAndSpinCount( &sm_cs, RECOMMENDED_SPIN_COUNT ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
    }

    HRETURN( hr );

} //*** CServiceManager::S_HrProcessInitialize


//////////////////////////////////////////////////////////////////////////////
//++
//
// CServiceManager::S_HrProcessUninitialize
//
//  Description:
//      Do process uninitialization by deleting the critical section.
//
//  Return Value:
//      S_OK
//
//  Remarks:
//      Delete the critical section that sychronizes the creation and
//      deletion code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrProcessUninitialize( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DeleteCriticalSection( &sm_cs );

    HRETURN( hr );

} //*** CServiceManager::S_HrProcessUninitialize


//////////////////////////////////////////////////////////////////////////////
//
//  CServiceManager::CServiceManager
//
//////////////////////////////////////////////////////////////////////////////
CServiceManager::CServiceManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CServiceManager::CServiceManager


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CServiceManager::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr;

    ITaskManager    *       ptm = NULL;
    IDoTask         *       pdt = NULL;
    IObjectManager *        pom = NULL;
    INotificationManager *  pnm = NULL;
    IConnectionManager *    pcm = NULL;
    ILogManager *           plm = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    // IServiceProvider
    Assert( m_dwLogManagerCookie == 0 );
    Assert( m_dwConnectionManagerCookie == 0 );
    Assert( m_dwNotificationManagerCookie == 0 );
    Assert( m_dwObjectManagerCookie == 0 );
    Assert( m_dwTaskManagerCookie == 0 );
    Assert( m_pgit == NULL );

    // IServiceProvider stuff
    hr = THR( HrCoCreateInternalInstance( CLSID_ObjectManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IObjectManager, &pom ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrCoCreateInternalInstance( CLSID_TaskManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( ITaskManager, &ptm ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrCoCreateInternalInstance( CLSID_NotificationManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( INotificationManager, &pnm ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrCoCreateInternalInstance( CLSID_ClusterConnectionManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IConnectionManager, &pcm ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrCoCreateInternalInstance( CLSID_LogManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( ILogManager, &plm ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Store the interfaces in the GIT.
    //
    hr = THR( CoCreateInstance(
                      CLSID_StdGlobalInterfaceTable
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IGlobalInterfaceTable
                    , reinterpret_cast< void ** >( &m_pgit )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pom, IID_IObjectManager, &m_dwObjectManagerCookie ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RegisterInterfaceInGlobal( ptm, IID_ITaskManager, &m_dwTaskManagerCookie ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pnm, IID_INotificationManager, &m_dwNotificationManagerCookie ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pcm, IID_IConnectionManager, &m_dwConnectionManagerCookie ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RegisterInterfaceInGlobal( plm, IID_ILogManager, &m_dwLogManagerCookie ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pom != NULL )
    {
        pom->Release();
    } // if:

    if ( pnm != NULL )
    {
        pnm->Release();
    } // if:

    if ( pcm != NULL )
    {
        pcm->Release();
    } // if:

    if ( plm != NULL )
    {
        plm->Release();
    } // if:

    if ( ptm != NULL )
    {
        ptm->Release();
    } // if:

    if ( pdt != NULL )
    {
        pdt->Release();
    } // if:

    HRETURN( hr );

} //*** CServiceManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CServiceManager::~CServiceManager
//
//////////////////////////////////////////////////////////////////////////////
CServiceManager::~CServiceManager( void )
{
    TraceFunc( "" );

    EnterCriticalSection( &sm_cs );

    if ( g_pspServiceManager == static_cast< IServiceProvider * >( this ) )
    {
        TraceMoveFromMemoryList( g_pspServiceManager, g_GlobalMemoryList );
        g_pspServiceManager = NULL;
    } // if: its our pointer

    if ( m_pgit != NULL )
    {
        if ( m_dwLogManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwLogManagerCookie ) );
        } // if:

        if ( m_dwConnectionManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwConnectionManagerCookie ) );
        } // if:

        if ( m_dwNotificationManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwNotificationManagerCookie ) );
        } // if:

        if ( m_dwObjectManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwObjectManagerCookie ) );
        } // if:

        if ( m_dwTaskManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwTaskManagerCookie ) );
        } // if:

        m_pgit->Release();
    } // if:

    InterlockedDecrement( &g_cObjects );

    LeaveCriticalSection( &sm_cs );

    TraceFuncExit();

} //*** CServiceManager::~CServiceManager


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CServiceManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< LPUNKNOWN >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IServiceProvider ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IServiceProvider, this, 0 );
    } // else if: IQueryService
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CServiceManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CServiceManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CServiceManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CServiceManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CServiceManager::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CServiceManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CServiceManager::Release


//****************************************************************************
//
// IServiceProvider
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CServiceManager::QueryService(
//        REFCLSID rclsidIn
//      , REFIID   riidInIn
//      , void **  ppvOutOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceManager::QueryService(
      REFCLSID rclsidIn
    , REFIID   riidIn
    , void **  ppvOut
    )
{
    TraceFunc( "[IServiceProvider]" );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if ( m_pgit != NULL )
    {
        if ( IsEqualIID( rclsidIn, CLSID_ObjectManager ) )
        {
            IObjectManager * pom;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwObjectManagerCookie, TypeSafeParams( IObjectManager, &pom ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pom->QueryInterface( riidIn, ppvOut ) );
            pom->Release();
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_TaskManager ) )
        {
            ITaskManager * ptm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwTaskManagerCookie, TypeSafeParams( ITaskManager, &ptm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( ptm->QueryInterface( riidIn, ppvOut ) );
            ptm->Release();
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_NotificationManager ) )
        {
            INotificationManager * pnm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwNotificationManagerCookie, TypeSafeParams( INotificationManager, &pnm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pnm->QueryInterface( riidIn, ppvOut ) );
            pnm->Release();
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_ClusterConnectionManager ) )
        {
            IConnectionManager * pcm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwConnectionManagerCookie, TypeSafeParams( IConnectionManager, &pcm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pcm->QueryInterface( riidIn, ppvOut ) );
            pcm->Release();
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_LogManager ) )
        {
            ILogManager * plm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwLogManagerCookie, TypeSafeParams( ILogManager, &plm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( plm->QueryInterface( riidIn, ppvOut ) );
            plm->Release();
            // fall thru
        }
    } // if: GIT pointer not NULL

Cleanup:

    HRETURN( hr );

} //*** CServiceManager::QueryService


//****************************************************************************
//
// Private Methods
//
//****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\standardinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      StandardInfo.cpp
//
//  Description:
//      CStandardInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "StandardInfo.h"

DEFINE_THISCLASS("CStandardInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStandardInfo::S_HrCreateInstance(
//      IUnknown **     ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStandardInfo::S_HrCreateInstance(
    IUnknown **     ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CStandardInfo * psi = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    psi = new CStandardInfo;
    if ( psi == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( psi->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psi->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

} //*** CStandardInfo::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::CStandardInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::CStandardInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CStandardInfo::CStandardInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::CStandardInfo(
//      CLSID *      pclsidTypeIn,
//      OBJECTCOOKIE cookieParentIn,
//      BSTR         bstrNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::CStandardInfo(
    CLSID *      pclsidTypeIn,
    OBJECTCOOKIE cookieParentIn,
    BSTR         bstrNameIn
    )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    //THR( HrInit() );

    m_clsidType     = *pclsidTypeIn;
    m_cookieParent  = cookieParentIn;
    m_bstrName      = bstrNameIn;

    TraceFuncExit();

} //*** CStandardInfo::CStandardInfo( ... )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::HrInit( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IStandardInfo
    Assert( m_clsidType == IID_NULL );
    Assert( m_cookieParent == 0 );
    Assert( m_bstrName == NULL );
    Assert( m_hrStatus == 0 );
    Assert( m_pci == NULL );
    Assert( m_pExtObjList == NULL );

    HRETURN( hr );

} //*** CStandardInfo::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::~CStandardInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::~CStandardInfo( void )
{
    TraceFunc( "" );

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_pci != NULL )
    {
        m_pci->Release();
    }

    while ( m_pExtObjList != NULL )
    {
        ExtObjectEntry * pnext = m_pExtObjList->pNext;

        m_pExtObjList->punk->Release();

        TraceFree( m_pExtObjList );

        m_pExtObjList = pnext;
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CStandardInfo::~CStandardInfo


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IStandardInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IStandardInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IStandardInfo, this, 0 );
    } // else if: IStandardInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CStandardInfo::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStandardInfo::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStandardInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CStandardInfo::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStandardInfo::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStandardInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CStandardInfo::Release



//****************************************************************************
//
//  IStandardInfo
//
//****************************************************************************



//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetType(
//      CLSID * pclsidTypeOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetType(
    CLSID * pclsidTypeOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pclsidTypeOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    CopyMemory( pclsidTypeOut, &m_clsidType, sizeof( *pclsidTypeOut ) );

Cleanup:
    HRETURN( hr );

} //*** CStandardInfo::GetType

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CStandardInfo::GetName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IStandardInfo] pcszNameIn = '%ws'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNew;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    bstrNew = TraceSysAllocString( pcszNameIn );
    if ( bstrNew == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNew;

Cleanup:
    HRETURN( hr );

} //*** CStandardInfo::SetName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetParent(
//      OBJECTCOOKIE * pcookieOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetParent(
    OBJECTCOOKIE * pcookieOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pcookieOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pcookieOut = m_cookieParent;

    if ( m_cookieParent == NULL )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

} //*** CStandardInfo::GetParent

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetStatus(
//      HRESULT * phrOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetStatus(
    HRESULT * phrStatusOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( phrStatusOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *phrStatusOut = m_hrStatus;

Cleanup:
    HRETURN( hr );

} //*** CStandardInfo::GetStatus

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::SetStatus(
//      HRESULT hrIn
//      )
//

//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::SetStatus(
    HRESULT hrIn
    )
{
    TraceFunc1( "[IStandardInfo] hrIn = %#08x", hrIn );

    HRESULT hr = S_OK;

    m_hrStatus = hrIn;

    HRETURN( hr );

} //*** CStandardInfo::SetStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\standardinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      StandardInfo.h
//
//  Description:
//      CStandardInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CObjectManager;

//  Link list of extension object that are persisted.
typedef struct _ExtObjectEntry {
    struct _ExtObjectEntry *    pNext;          //  Next item in list
    CLSID                       iid;            //  Interface ID
    IUnknown *                  punk;           //  Punk to object
} ExtObjectEntry;

//  CStandardInfo
class CStandardInfo
    : public IStandardInfo
{
friend class CObjectManager;
private:
    // IUnknown
    LONG                m_cRef;

    // IStandardInfo
    CLSID               m_clsidType;          //  Type of object
    OBJECTCOOKIE        m_cookieParent;       //  Parent of object (if any - NULL means none)
    BSTR                m_bstrName;           //  Name of object
    HRESULT             m_hrStatus;           //  Object status
    IConnectionInfo *   m_pci;                //  Connection to the object (used by Connection Manager)
    ExtObjectEntry *    m_pExtObjList;        //  List of extended objects

private: // Methods
    CStandardInfo(  void );
    CStandardInfo( CLSID *      pclsidTypeIn,
                   OBJECTCOOKIE cookieParentIn,
                   BSTR         bstrNameIn
                   );
    ~CStandardInfo( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IStandardInfo
    STDMETHOD( GetType )( CLSID * pclsidTypeOut );
    STDMETHOD( GetName )( BSTR * bstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetParent )( OBJECTCOOKIE * pcookieOut );
    STDMETHOD( GetStatus )( HRESULT * phrStatusOut );
    STDMETHOD( SetStatus )( HRESULT hrIn );

}; //*** class CStandardInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\servicemanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ServiceMgr.h
//
//  Description:
//      Service Manager implementation.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 05-JUN-2001
//      Geoffrey Pease  (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CServiceManager
class CServiceManager
    : public IServiceProvider
{
private:
    // IUnknown
    LONG                        m_cRef;                         //  Reference counter

    // IServiceProvider
    DWORD                       m_dwObjectManagerCookie;        //  Cookie for Object Manager
    DWORD                       m_dwTaskManagerCookie;          //  Cookie for Task Manager
    DWORD                       m_dwNotificationManagerCookie;  //  Cookie for Notification Manager
    DWORD                       m_dwConnectionManagerCookie;    //  Cookie for Connection Manager
    DWORD                       m_dwLogManagerCookie;           //  Cookie for Log Manager
    IGlobalInterfaceTable *     m_pgit;                         //  Global Interface Table

    static CRITICAL_SECTION     sm_cs;                          //  Access control critical section

private: // Methods
    CServiceManager( void );
    ~CServiceManager( void );

    HRESULT HrInit( void );

    // Private copy constructor to prevent copying.
    CServiceManager( const CServiceManager & nodeSrc );

    // Private assignment operator to prevent copying.
    const CServiceManager & operator = ( const CServiceManager & nodeSrc );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );
    static HRESULT S_HrGetManagerPointer( IServiceProvider ** pspOut );
    static HRESULT S_HrProcessInitialize( void );
    static HRESULT S_HrProcessUninitialize( void );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IServiceProvider
    STDMETHOD( QueryService )( REFCLSID rclsidIn, REFIID riidIn, void ** ppvOut );

}; // class CServiceManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzeclusterbase.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeClusterBase.h
//
//  Description:
//      CTaskAnalyzeClusterBase declaration.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 01-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "TaskTracking.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

#define SSR_ANALYSIS_FAILED( _major, _minor, _hr ) \
    {   \
        HRESULT hrTemp; \
        hrTemp = THR( HrSendStatusReport( NULL, _major, _minor, 1, 1, 1, _hr, IDS_ERR_ANALYSIS_FAILED_TRY_TO_REANALYZE ) );   \
        if ( FAILED( hrTemp ) && SUCCEEDED( _hr ) ) \
        {   \
            _hr = hrTemp; \
        }   \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskAnalyzeClusterBase
//
//  Description:
//      This is the base class for the two different analysis tasks.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskAnalyzeClusterBase
    : public CTaskTracking
    , public IClusCfgCallback
    , public INotifyUI
{
private:

    // IUnknown
    LONG                    m_cRef;

    // ITaskAnalyzeClusterBase
    OBJECTCOOKIE            m_cookieCompletion;                 // Task completion cookie
    IClusCfgCallback *      m_pcccb;                            // Callback interface
    OBJECTCOOKIE *          m_pcookies;                         // Completion cookies for the subtasks.
    ULONG                   m_cCookies;                         // Count of completion cookies in m_pcookies
    ULONG                   m_cNodes;                           // Count of nodes in configuration
    HANDLE                  m_event;                            // Synchronization event to signal when subtasks have completed.
    BOOL                    m_fJoiningMode;                     // FALSE = forming mode. TRUE = joining mode.
    ULONG                   m_cUserNodes;                       // The count of nodes that the user entered. It is also the "sizeof" the array, m_pcookiesUser.
    OBJECTCOOKIE *          m_pcookiesUser;                     // The cookies of nodes that the user entered.
    BSTR                    m_bstrNodeName;
    IClusCfgVerifyQuorum *  ((*m_prgQuorumsToCleanup)[]);
    ULONG                   m_idxQuorumToCleanupNext;
    INotifyUI *             m_pnui;
    ITaskManager *          m_ptm;
    IConnectionManager *    m_pcm;

    BOOL                    m_fStop;

    // INotifyUI
    ULONG                   m_cSubTasksDone;    // The number of subtasks done.
    HRESULT                 m_hrStatus;         // Status of callbacks

    // Private copy constructor to prevent copying.
    CTaskAnalyzeClusterBase( const CTaskAnalyzeClusterBase & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskAnalyzeClusterBase & operator = ( const CTaskAnalyzeClusterBase & nodeSrc );

private:

    HRESULT HrWaitForClusterConnection( void );
    HRESULT HrCountNumberOfNodes( void );
    HRESULT HrCreateSubTasksToGatherNodeInfo( void );
    HRESULT HrCreateSubTasksToGatherNodeResourcesAndNetworks( void );
    HRESULT HrCheckClusterFeasibility( void );
    HRESULT HrAddJoinedNodes( void );
    HRESULT HrCheckNodeDomains( void );
    HRESULT HrCheckClusterMembership( void );
    HRESULT HrCompareResources( void );
    HRESULT HrCheckForCommonQuorumResource( void );
    HRESULT HrCompareNetworks( void );
    HRESULT HrCreateNewNetworkInClusterConfiguration( IClusCfgNetworkInfo * pccmriIn, IClusCfgNetworkInfo ** ppccmriNewOut );
    HRESULT HrFreeCookies( void );
    HRESULT HrCheckInteroperability( void );
    HRESULT HrEnsureAllJoiningNodesSameVersion( DWORD * pdwNodeHighestVersionOut, DWORD * pdwNodeLowestVersionOut, bool * pfAllNodesMatchOut );
    HRESULT HrGetUsersNodesCookies( void );
    HRESULT HrIsUserAddedNode( BSTR bstrNodeNameIn );
    HRESULT HrResourcePrivateDataExchange( IClusCfgManagedResourceInfo * pccmriClusterIn, IClusCfgManagedResourceInfo * pccmriNodeIn );
    HRESULT HrCheckQuorumCapabilities( IClusCfgManagedResourceInfo * pccmriNodeResourceIn, OBJECTCOOKIE nodeCookieIn );
    HRESULT HrCleanupTask( HRESULT hrCompletionStatusIn );
    HRESULT HrAddResurceToCleanupList( IClusCfgVerifyQuorum * piccvqIn );
    HRESULT HrCheckPlatformInteroperability( void );
    HRESULT HrGetAClusterNodeCookie( IEnumCookies ** ppecNodesOut, DWORD * pdwClusterNodeCookieOut );
    HRESULT HrFormatProcessorArchitectureRef( WORD wClusterProcArchIn, WORD wNodeProcArchIn, LPCWSTR pcszNodeNameIn, BSTR * pbstrReferenceOut );
    HRESULT HrGetProcessorArchitectureString( WORD wProcessorArchitectureIn, BSTR * pbstrProcessorArchitectureOut );

protected:

    OBJECTCOOKIE        m_cookieCluster;    //  Cookie of the cluster to analyze
    IObjectManager *    m_pom;
    BSTR                m_bstrQuorumUID;    //  Quorum device UID
    BSTR                m_bstrClusterName;  //  Name of the cluster to analyze

    CTaskAnalyzeClusterBase( void );
    virtual ~CTaskAnalyzeClusterBase( void );

    HRESULT HrInit( void );
    HRESULT HrSendStatusReport( LPCWSTR pcszNodeNameIn, CLSID clsidMajorIn, CLSID clsidMinorIn, ULONG ulMinIn, ULONG ulMaxIn, ULONG ulCurrentIn, HRESULT hrIn, int nDescriptionIdIn );
    HRESULT HrCreateNewManagedResourceInClusterConfiguration( IClusCfgManagedResourceInfo * pccmriIn, IClusCfgManagedResourceInfo ** ppccmriNewOut );

    //
    // Overrideable functions.
    //

    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo * pccmriIn
                        , BSTR                          bstrNodeResNameIn
                        , BSTR *                        pbstrNodeResUIDInout
                        , BSTR                          bstrNodeNameIn
                        ) = 0;
    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo *     pccmriIn
                        , IClusCfgManagedResourceInfo **    ppccmriOut
                        ) = 0;
    virtual HRESULT HrCompareDriveLetterMappings( void ) = 0;
    virtual HRESULT HrFixupErrorCode( HRESULT hrIn ) = 0;
    virtual BOOL    BMinimalConfiguration( void ) = 0;
    virtual void    GetNodeCannotVerifyQuorumStringRefId( DWORD * pdwRefIdOut ) = 0;
    virtual void    GetNoCommonQuorumToAllNodesStringIds( DWORD * pdwMessageIdOut, DWORD * pdwRefIdOut ) = 0;
    virtual HRESULT HrShowLocalQuorumWarning( void ) = 0;

    //
    //  IUnknown implemetation
    //

    ULONG   UlAddRef( void );
    ULONG   UlRelease( void );

    //
    //  IDoTask / ITaskAnalyzeClusterBase implementation
    //

    HRESULT HrBeginTask( void );
    HRESULT HrStopTask( void );
    HRESULT HrSetJoiningMode( void );
    HRESULT HrSetCookie( OBJECTCOOKIE cookieIn );
    HRESULT HrSetClusterCookie( OBJECTCOOKIE cookieClusterIn );

public:

    //
    //  IClusCfgCallback
    //

    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    //
    //  INotifyUI
    //

    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; //*** class CTaskAnalyzeClusterBase
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzecluster.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.h
//
//  Description:
//      CTaskAnalyzeCluster declaration.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "TaskAnalyzeClusterBase.h"
#include "TaskTracking.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskAnalyzeCluster
//
//  Description:
//      The class CTaskAnalyzeCluster is the implementation of the
//      ITaskAnalyzeCluster interface that does normal analysis and
//      configuration.  This task is launched from the client when the user
//      has not chosen the minimal configuration option.
//
//  Interfaces:
//      ITaskAnalyzeCluster
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskAnalyzeCluster
    : public ITaskAnalyzeCluster
    , public CTaskAnalyzeClusterBase
{
private:

    CTaskAnalyzeCluster( void );
    ~CTaskAnalyzeCluster( void );

    // Private copy constructor to prevent copying.
    CTaskAnalyzeCluster( const CTaskAnalyzeCluster & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskAnalyzeCluster & operator = ( const CTaskAnalyzeCluster & nodeSrc );

protected:

    //
    // Overridden functions.
    //

    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo * pccmriIn
                        , BSTR                          bstrNodeResNameIn
                        , BSTR *                        pbstrNodeResUIDInout
                        , BSTR                          bstrNodeNameIn
                        );
    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo *     pccmriIn
                        , IClusCfgManagedResourceInfo **    ppccmriOut
                        );
    virtual HRESULT HrCompareDriveLetterMappings( void );
    virtual HRESULT HrFixupErrorCode( HRESULT hrIn );
    virtual BOOL    BMinimalConfiguration( void ) { return FALSE; };
    virtual void    GetNodeCannotVerifyQuorumStringRefId( DWORD * pdwRefIdOut );
    virtual void    GetNoCommonQuorumToAllNodesStringIds( DWORD * pdwMessageIdOut, DWORD * pdwRefIdOut );
    virtual HRESULT HrShowLocalQuorumWarning( void );

public:

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    //  IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  IDoTask / ITaskAnalyzeCluster
    //

    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetJoiningMode )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );

}; //*** class CTaskAnalyzeCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzecluster.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.cpp
//
//  Description:
//      CTaskAnalyzeCluster implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "TaskAnalyzeCluster.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
DEFINE_THISCLASS( "CTaskAnalyzeCluster" )


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeCluster class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::S_HrCreateInstance
//
//  Description:
//      Create a CTaskAnalyzeCluster instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT as failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_OK;
    CTaskAnalyzeCluster *   ptac = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ptac = new CTaskAnalyzeCluster;
    if ( ptac == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ptac->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( ptac->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( ptac != NULL )
    {
        ptac->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::CTaskAnalyzeCluster
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeCluster::CTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::CTaskAnalyzeCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::~CTaskAnalyzeCluster
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeCluster::~CTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::~CTaskAnalyzeCluster


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeCluster - IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskAnalyzeCluster * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskAnalyzeCluster ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskAnalyzeCluster, this, 0 );
    } // else if: ITaskAnalyzeCluster
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskAnalyzeCluster::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeCluster::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    ULONG   c = UlAddRef();

    CRETURN( c );

} //*** CTaskAnalyzeCluster::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeCluster::Release( void )
{
    TraceFunc( "[IUnknown]" );

    ULONG   c = UlRelease();

    CRETURN( c );

} //*** CTaskAnalyzeCluster::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeCluster - IDoTask/ITaskAnalyzeCluster interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::BeginTask
//
//  Description:
//      Task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = THR( HrBeginTask() );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::BeginTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::StopTask
//
//  Description:
//      Stop task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = THR( HrStopTask() );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::StopTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::SetJoiningMode
//
//  Description:
//      Tell this task whether we are joining nodes to the cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetJoiningMode( void )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = THR( HrSetJoiningMode() );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetJoiningMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::SetCookie
//
//  Description:
//      Receive the completion cookier from the task creator.
//
//  Arguments:
//      cookieIn
//          The completion cookie to send back to the creator when this
//          task is complete.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = THR( HrSetCookie( cookieIn ) );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::SetClusterCookie
//
//  Description:
//      Receive the object manager cookie of the cluster that we are going
//      to analyze.
//
//  Arguments:
//      cookieClusterIn
//          The cookie for the cluster to work on.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = THR( HrSetClusterCookie( cookieClusterIn ) );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetClusterCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::HrCompareDriveLetterMappings
//
//  Description:
//      Compare the drive letter mappings on each node to make sure there
//      are no conflicts.  Specifically, verify that the system disk on each
//      node does not conflict with storage devices that could be failed over
//      to that node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCompareDriveLetterMappings( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    HRESULT                         hrDriveConflictError   = S_OK;
    HRESULT                         hrDriveConflictWarning = S_OK;
    OBJECTCOOKIE                    cookieDummy;
    OBJECTCOOKIE                    cookieClusterNode;
    DWORD                           idxCurrentNode;
    DWORD                           cNodes;
    ULONG                           celtDummy;
    int                             idxDLM;
    BSTR                            bstrOuterNodeName   = NULL;
    BSTR                            bstrInnerNodeName   = NULL;
    BSTR                            bstrMsg             = NULL;
    BSTR                            bstrMsgREF          = NULL;
    IUnknown *                      punk                = NULL;
    IEnumCookies *                  pecNodes            = NULL;
    IClusCfgNodeInfo *              pccniOuter          = NULL;
    IClusCfgNodeInfo *              pccniInner          = NULL;
    SDriveLetterMapping             dlmOuter;
    SDriveLetterMapping             dlmInner;

    hr = THR( HrSendStatusReport(
                      CTaskAnalyzeClusterBase::m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Check_DriveLetter_Mappings
                    , 0
                    , 1
                    , 0
                    , hr
                    , IDS_TASKID_MINOR_CHECK_DRIVELETTER_MAPPINGS
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the node cookie enumerator.
    //

    hr = THR( CTaskAnalyzeClusterBase::m_pom->FindObject( CLSID_NodeType, CTaskAnalyzeClusterBase::m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CompareDriveLetterMappings_Find_Object, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CompareDriveLetterMappings_Find_Object_QI, hr );
        goto Cleanup;
    }

    //pecNodes = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pecNodes, 1 );

    punk->Release();
    punk = NULL;

    //
    //  If there is only one node, just exit this function.
    //

    hr = THR( pecNodes->Count( &cNodes ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    if ( cNodes == 1 )
    {
        goto Cleanup;
    }

    //
    //  Loop through the enumerator to compare each node with every other node.
    //  This requires an outer loop and an inner loop.
    //

    for ( idxCurrentNode = 0 ;; idxCurrentNode++ )
    {
        //
        //  Cleanup.
        //

        if ( pccniOuter != NULL )
        {
            pccniOuter->Release();
            pccniOuter = NULL;
        }
        TraceSysFreeString( bstrOuterNodeName );
        bstrOuterNodeName = NULL;

        //
        //  Skip to the next node.  This is necessary since there is only one
        //  enumerator for both the outer and inner loop.
        //

        if ( idxCurrentNode > 0 )
        {
            // Reset back to the first item in the enumerator.
            hr = STHR( pecNodes->Reset() );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Reset_Node_Enumerator, hr );
                goto Cleanup;
            }

            // Skip to the current node.
            hr = STHR( pecNodes->Skip( idxCurrentNode ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Skip_To_Node, hr );
                goto Cleanup;
            }
            if ( hr == S_FALSE )
            {
                //
                //  Reached the end of the list.
                //

                hr = S_OK;
                break;
            }
        } // if: not at first node

        //
        //  Find the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieClusterNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Find_Outer_Node_Next, hr );
            goto Cleanup;
        }
        if ( hr == S_FALSE )
        {
            //
            //  Reached the end of the list.
            //

            hr = S_OK;
            break;
        }

        //
        //  Retrieve the node information.
        //

        hr = THR( CTaskAnalyzeClusterBase::m_pom->GetObject( DFGUID_NodeInformation, cookieClusterNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccniOuter ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_FindObject_QI, hr );
            goto Cleanup;
        }

        //pccniOuter = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNodeInfo", IClusCfgNodeInfo, pccni, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Get the drive letter mappings for the outer node.
        //

        hr = THR( pccniOuter->GetDriveLetterMappings( &dlmOuter ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_NodeInfo_GetDLM, hr );
            goto Cleanup;
        }

        //
        //  Get the name of the node.
        //

        hr = THR( pccniOuter->GetName( &bstrOuterNodeName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Outer_GetNodeName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrOuterNodeName );

        //
        //  Loop through all the other nodes in the cluster.
        //

        for ( ;; )
        {
            //
            //  Cleanup.
            //

            if ( pccniInner != NULL )
            {
                pccniInner->Release();
                pccniInner = NULL;
            }
            TraceSysFreeString( bstrInnerNodeName );
            bstrInnerNodeName = NULL;

            //
            //  Find the next node.
            //

            hr = STHR( pecNodes->Next( 1, &cookieClusterNode, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Find_Inner_Node_Next, hr );
                goto Cleanup;
            }
            if ( hr == S_FALSE )
            {
                //
                //  Reached the end of the list.
                //

                hr = S_OK;
                break;
            }

            //
            //  Retrieve the node information.
            //

            hr = THR( CTaskAnalyzeClusterBase::m_pom->GetObject( DFGUID_NodeInformation, cookieClusterNode, &punk ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccniInner ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_FindObject_QI, hr );
                goto Cleanup;
            }

            //pccniInner = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNodeInfo", IClusCfgNodeInfo, pccni, 1 );

            punk->Release();
            punk = NULL;

            //
            //  Get the drive letter mappings for the inner node.
            //

            hr = THR( pccniInner->GetDriveLetterMappings( &dlmInner ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_NodeInfo_GetDLM, hr );
                goto Cleanup;
            }

            //
            //  Get the name of the node.
            //

            hr = THR( pccniInner->GetName( &bstrInnerNodeName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Compare_Drive_Letter_Mappings_Inner_GetNodeName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrInnerNodeName );

            //
            //  Loop through the drive letter mappings to make sure that there
            //  are no conflicts between the two machines.
            //

            for ( idxDLM = 0 ; idxDLM < 26 ; idxDLM++ )
            {
                if ( dlmOuter.dluDrives[ idxDLM ] == dluSYSTEM )
                {
                    CLSID   clsidMinorId;
                    hr = THR( CoCreateGuid( &clsidMinorId ) );
                    if ( FAILED( hr ) )
                    {
                        clsidMinorId = IID_NULL;
                    }

                    switch ( dlmInner.dluDrives[ idxDLM ] )
                    {
                        case dluFIXED_DISK:
                        case dluREMOVABLE_DISK:
                        {
                            LPCWSTR pwszMsg;
                            LPCWSTR pwszMsgREF;

                            hrDriveConflictError = HRESULT_FROM_WIN32( ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT );

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR
                                            , &bstrMsg
                                            , bstrOuterNodeName
                                            , L'A' + idxDLM // construct the drive letter
                                            , bstrInnerNodeName
                                            ) );
                            if ( bstrMsg == NULL )
                            {
                                pwszMsg = L"System drive conflicts.";
                            }
                            else
                            {
                                pwszMsg = bstrMsg;
                            }

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR_REF
                                            , &bstrMsgREF
                                            ) );
                            if ( bstrMsgREF == NULL )
                            {
                                pwszMsgREF = L"System drive conflicts. Make sure there is no drive letter conflict between these nodes and re-run the cluster setup.";
                            }
                            else
                            {
                                pwszMsgREF = bstrMsgREF;
                            }

                            hr = THR( SendStatusReport(
                                              CTaskAnalyzeClusterBase::m_bstrClusterName
                                            , TASKID_Minor_Check_DriveLetter_Mappings
                                            , clsidMinorId
                                            , 0
                                            , 1
                                            , 1
                                            , hrDriveConflictError
                                            , pwszMsg
                                            , NULL
                                            , pwszMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            break;
                        } // case: fixed disk or removable disk

                        case dluCOMPACT_DISC:
                        case dluNETWORK_DRIVE:
                        case dluRAM_DISK:
                        {
                            LPCWSTR pwszMsg;
                            LPCWSTR pwszMsgREF;
                            UINT    ids = 0;

                            hrDriveConflictWarning = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT );

                            if ( dlmInner.dluDrives[ idxDLM ] == dluCOMPACT_DISC )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_CD_WARNING;
                            } // if: ( dlmInner.dluDrives[ idxDLM ] == dluCOMPACT_DISC )
                            else if ( dlmInner.dluDrives[ idxDLM ] == dluNETWORK_DRIVE )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_NET_WARNING;
                            } // if: ( dlmInner.dluDrives[ idxDLM ] == dluNETWORK_DRIVE )
                            else if ( dlmInner.dluDrives[ idxDLM ] == dluRAM_DISK )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_RAM_WARNING;
                            } // if: ( dlmInner.dluDrives[ idxDLM ] == dluRAM_DISK )
                            Assert( ids != 0 );

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , ids
                                            , &bstrMsg
                                            , bstrOuterNodeName
                                            , L'A' + idxDLM // construct the drive letter
                                            , bstrInnerNodeName
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            if ( bstrMsg == NULL )
                            {
                                pwszMsg = L"System drive conflicts.";
                            }
                            else
                            {
                                pwszMsg = bstrMsg;
                            }

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_WARNING_REF
                                            , &bstrMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            if ( bstrMsgREF == NULL )
                            {
                                pwszMsgREF = L"System drive conflicts. It is recommended not to have any drive letter conflicts between nodes.";
                            }
                            else
                            {
                                pwszMsgREF = bstrMsgREF;
                            }

                            hr = THR( SendStatusReport(
                                              CTaskAnalyzeClusterBase::m_bstrClusterName
                                            , TASKID_Minor_Check_DriveLetter_Mappings
                                            , clsidMinorId
                                            , 0
                                            , 1
                                            , 1
                                            , hrDriveConflictWarning
                                            , pwszMsg
                                            , NULL
                                            , pwszMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            break;
                        } // case: compact disc, network drive, or ram disk
                    } // switch: inner drive letter usage
                } // if: outer node drive is a system drive

                if ( dlmInner.dluDrives[ idxDLM ] == dluSYSTEM )
                {
                    CLSID   clsidMinorId;
                    hr = THR( CoCreateGuid( &clsidMinorId ) );
                    if ( FAILED( hr ) )
                    {
                        clsidMinorId = IID_NULL;
                    }

                    switch ( dlmOuter.dluDrives[ idxDLM ] )
                    {
                        case dluFIXED_DISK:
                        case dluREMOVABLE_DISK:
                        {
                            LPCWSTR pwszMsg;
                            LPCWSTR pwszMsgREF;

                            hrDriveConflictError = HRESULT_FROM_WIN32( ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT );

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR
                                            , &bstrMsg
                                            , bstrInnerNodeName
                                            , L'A' + idxDLM // construct the drive letter
                                            , bstrOuterNodeName
                                            ) );
                            if ( bstrMsg == NULL )
                            {
                                pwszMsg = L"System drive conflicts.";
                            }
                            else
                            {
                                pwszMsg = bstrMsg;
                            }

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_ERROR_REF
                                            , &bstrMsgREF
                                            ) );
                            if ( bstrMsgREF == NULL )
                            {
                                pwszMsgREF = L"System drive conflicts. Make sure there is no drive letter conflict between these nodes and re-run the cluster setup.";
                            }
                            else
                            {
                                pwszMsgREF = bstrMsgREF;
                            }

                            hr = THR( SendStatusReport(
                                              CTaskAnalyzeClusterBase::m_bstrClusterName
                                            , TASKID_Minor_Check_DriveLetter_Mappings
                                            , clsidMinorId
                                            , 0
                                            , 1
                                            , 1
                                            , hrDriveConflictError
                                            , pwszMsg
                                            , NULL
                                            , pwszMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            break;
                        } // case: fixed disk or removable disk

                        case dluCOMPACT_DISC:
                        case dluNETWORK_DRIVE:
                        case dluRAM_DISK:
                        {
                            LPCWSTR pwszMsg;
                            LPCWSTR pwszMsgREF;
                            UINT    ids = 0;

                            hrDriveConflictWarning = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT );

                            if ( dlmOuter.dluDrives[ idxDLM ] == dluCOMPACT_DISC )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_CD_WARNING;
                            } // if: ( dlmOuter.dluDrives[ idxDLM ] == dluCOMPACT_DISC )
                            else if ( dlmOuter.dluDrives[ idxDLM ] == dluNETWORK_DRIVE )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_NET_WARNING;
                            } // if: ( dlmOuter.dluDrives[ idxDLM ] == dluNETWORK_DRIVE )
                            else if ( dlmOuter.dluDrives[ idxDLM ] == dluRAM_DISK )
                            {
                                ids = IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_RAM_WARNING;
                            } // if: ( dlmOuter.dluDrives[ idxDLM ] == dluRAM_DISK )
                            Assert( ids != 0 );

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , ids
                                            , &bstrMsg
                                            , bstrInnerNodeName
                                            , L'A' + idxDLM // construct the drive letter
                                            , bstrOuterNodeName
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            if ( bstrMsg == NULL )
                            {
                                pwszMsg = L"System drive conflicts.";
                            }
                            else
                            {
                                pwszMsg = bstrMsg;
                            }

                            hr = THR( HrFormatStringIntoBSTR(
                                              g_hInstance
                                            , IDS_TASKID_MINOR_SYSTEM_DRIVE_LETTER_CONFLICT_WARNING_REF
                                            , &bstrMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            if ( bstrMsgREF == NULL )
                            {
                                pwszMsgREF = L"System drive conflicts. It is recommended not to have any drive letter conflicts between nodes.";
                            }
                            else
                            {
                                pwszMsgREF = bstrMsgREF;
                            }

                            hr = THR( SendStatusReport(
                                              CTaskAnalyzeClusterBase::m_bstrClusterName
                                            , TASKID_Minor_Check_DriveLetter_Mappings
                                            , clsidMinorId
                                            , 0
                                            , 1
                                            , 1
                                            , hrDriveConflictWarning
                                            , pwszMsg
                                            , NULL
                                            , pwszMsgREF
                                            ) );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            }

                            break;
                        } // case: compact disc, network drive, or ram disk
                    } // switch: outer drive letter usage
                } // if: inner node drive is a system drive
            } // for: each drive letter mapping
        } // for ever: inner node loop
    } // for ever: outer node loop

Cleanup:

    THR( HrSendStatusReport(
                  CTaskAnalyzeClusterBase::m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_Check_DriveLetter_Mappings
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_CHECK_DRIVELETTER_MAPPINGS
                ) );

    TraceSysFreeString( bstrOuterNodeName );
    TraceSysFreeString( bstrInnerNodeName );
    TraceSysFreeString( bstrMsg );
    TraceSysFreeString( bstrMsgREF );

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    }

    if ( pccniOuter != NULL )
    {
        pccniOuter->Release();
    }

    if ( pccniInner != NULL )
    {
        pccniInner->Release();
    }

    if ( punk != NULL )
    {
        punk->Release();
    }

    //
    // Set the return value if an error or warning occurred.
    // An error will override a warning.
    //
    if ( hrDriveConflictError != S_OK )
    {
        hr = hrDriveConflictError;
    }
    else if ( hrDriveConflictWarning != S_OK )
    {
        hr = hrDriveConflictWarning;
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCompareDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::HrCreateNewResourceInCluster
//
//  Description:
//      Create a new resource in the cluster configuration since there was
//      not a match to the resource already in the cluster.
//
//  Arguments:
//      pccmriIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateNewResourceInCluster(
      IClusCfgManagedResourceInfo * pccmriIn
    , BSTR                          bstrNodeResNameIn
    , BSTR *                        pbstrNodeResUIDInout
    , BSTR                          bstrNodeNameIn
    )
{
    TraceFunc( "" );
    Assert( pccmriIn != NULL );
    Assert( pbstrNodeResUIDInout != NULL );

    HRESULT                         hr = S_OK;
    IClusCfgManagedResourceInfo *   pccmriNew        = NULL;

    //
    //  Need to create a new object.
    //

    hr = THR( HrCreateNewManagedResourceInClusterConfiguration( pccmriIn, &pccmriNew ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Display the name of the node's resource in the log.
    //

    LogMsg(
          L"[MT] Created object for resource '%ws' ('%ws') from node '%ws' in the cluster configuration."
        , bstrNodeResNameIn
        , *pbstrNodeResUIDInout
        , bstrNodeNameIn
        );

    //
    // If this is the quorum resource, remember it.
    //

    hr = STHR( pccmriNew->IsQuorumResource() );
    if ( hr == S_OK )
    {
        //
        //  Remember the quorum device's UID.
        //

        Assert( m_bstrQuorumUID == NULL );
        m_bstrQuorumUID = *pbstrNodeResUIDInout;
        *pbstrNodeResUIDInout = NULL;
    } // if:

    hr = S_OK;

Cleanup:

    if ( pccmriNew != NULL )
    {
        pccmriNew->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCreateNewResourceInCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::HrCreateNewResourceInCluster
//
//  Description:
//      Create a new resource in the cluster configuration since there was
//      not a match to the resource already in the cluster.
//
//  Arguments:
//      pccmriIn
//          The source object.
//
//      ppccmriOut
//          The new object that was created.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateNewResourceInCluster(
      IClusCfgManagedResourceInfo *     pccmriIn
    , IClusCfgManagedResourceInfo **    ppccmriOut
    )
{
    TraceFunc( "" );
    Assert( pccmriIn != NULL );
    Assert( ppccmriOut != NULL );

    HRESULT hr = S_OK;

    //
    //  Need to create a new object.
    //

    hr = THR( HrCreateNewManagedResourceInClusterConfiguration( pccmriIn, ppccmriOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If the resource is manageable in a cluster then we should set it
    //  to be managed so it will be created by PostConfig.
    //

    hr = STHR( (*ppccmriOut)->IsManagedByDefault() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( (*ppccmriOut)->SetManaged( TRUE ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCreateNewResourceInCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::HrFixupErrorCode
//
//  Description:
//      Do any fix ups needed for the passed in error code and return the
//      fixed up value.  The default implementation is to do no fixups.
//
//  Arguments:
//      hrIn
//          The error code to fix up.
//
//  Return Value:
//      The passed in error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrFixupErrorCode(
    HRESULT hrIn
    )
{
    TraceFunc( "" );

    HRETURN( hrIn );

} //*** CTaskAnalyzeCluster::HrFixupErrorCode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::GetNodeCannotVerifyQuorumStringRefId
//
//  Description:
//      Return the correct string ids for the message that is displayed
//      to the user when there isn't a quorum resource.
//
//  Arguments:
//      pdwRefIdOut
//          The reference text to show the user.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskAnalyzeCluster::GetNodeCannotVerifyQuorumStringRefId(
    DWORD *   pdwRefIdOut
    )
{
    TraceFunc( "" );
    Assert( pdwRefIdOut != NULL );

    *pdwRefIdOut = IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_ERROR_REF;

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::GetNodeCannotVerifyQuorumStringRefId

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::GetNoCommonQuorumToAllNodesStringIds
//
//  Description:
//      Return the correct string ids for the message that is displayed
//      to the user when there isn't a common to all nodes quorum resource.
//
//  Arguments:
//      pdwMessageIdOut
//          The message to show the user.
//
//      pdwRefIdOut
//          The reference text to show the user.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskAnalyzeCluster::GetNoCommonQuorumToAllNodesStringIds(
      DWORD *   pdwMessageIdOut
    , DWORD *   pdwRefIdOut
    )
{
    TraceFunc( "" );
    Assert( pdwMessageIdOut != NULL );
    Assert( pdwRefIdOut != NULL );

    *pdwMessageIdOut = IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_ERROR;
    *pdwRefIdOut = IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_ERROR_REF;

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::GetNoCommonQuorumToAllNodesStringIds


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeCluster::HrShowLocalQuorumWarning
//
//  Description:
//      Send the warning about forcing local quorum to the UI.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The SSR was done properly.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrShowLocalQuorumWarning( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( HrSendStatusReport(
                      CTaskAnalyzeClusterBase::m_bstrClusterName
                    , TASKID_Minor_Finding_Common_Quorum_Device
                    , TASKID_Minor_Forced_Local_Quorum
                    , 1
                    , 1
                    , 1
                    , MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_QUORUM_DISK_NOT_FOUND )
                    , IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM
                    ) );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrShowLocalQuorumWarning
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcancelcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskCancelCleanup.cpp
//
//  Description:
//      CTaskCancelCleanup implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 25-JAN-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <ClusCfgPrivate.h>
#include "TaskCancelCleanup.h"
#include <StatusReports.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CTaskCancelCleanup")

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskCancelCleanup class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::S_HrCreateInstance
//
//  Description:
//      Create a CTaskCancelCleanup instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCancelCleanup::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CTaskCancelCleanup *    ptcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ptcc = new CTaskCancelCleanup;
    if ( ptcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ptcc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( ptcc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );

Cleanup:

    if ( ptcc != NULL )
    {
        ptcc->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskCancelCleanup::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::CTaskCancelCleanup
//
//  Description:
//      Constructor of the CTaskCancelCleanup class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskCancelCleanup::CTaskCancelCleanup( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_fStop == false );
    Assert( m_cookieCluster == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_cookieCompletion == 0 );
    Assert( m_pnui == NULL );
    Assert( m_pom == NULL );
    Assert( m_pnui == NULL );

    TraceFuncExit();

} //*** CTaskCancelCleanup::CTaskCancelCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::~CTaskCancelCleanup
//
//  Description:
//      Desstructor of the CTaskCancelCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskCancelCleanup::~CTaskCancelCleanup( void )
{
    TraceFunc( "" );

    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    if ( m_pom != NULL )
    {
        m_pom->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    if ( m_pnui != NULL )
    {
        m_pnui->Release();
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskCancelCleanup::~CTaskCancelCleanup


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskCancelCleanup -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCancelCleanup::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskCancelCleanup::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCancelCleanup::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if:

    CRETURN( cRef );

} //*** CTaskCancelCleanup::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } //if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskCancelCleanup * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskCancelCleanup ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskCancelCleanup, this, 0 );
    } // else if: ITaskCancelCleanup
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskCancelCleanup::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskCancelCleanup -- IDoTask interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::BeginTask
//
//  Description:
//      Entry point for this task.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT                     hr = S_OK;
    IUnknown *                  punk = NULL;
    OBJECTCOOKIE                cookieDummy;
    ULONG                       celtDummy;
    IEnumCookies *              pec  = NULL;
    OBJECTCOOKIE                cookieNode;

    hr = THR( HrTaskSetup() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the object manager for the node cookie enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not get the node cookie enumerator.", hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query for the cookie enumerator interface.", hr );
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    for ( ; m_fStop == false; )
    {
        //
        //  Grab the next node.
        //

        hr = STHR( pec->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break;          // exit condition
        } // if:

        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"[TaskCancelCleanup] Node cookie enumerator Next() method failed.", hr );
            goto Cleanup;
        } // if:

        //
        //  Process each node in turn...
        //

        hr = STHR( HrProcessNode( cookieNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // for:

Cleanup:

    THR( HrTaskCleanup( hr ) );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( pec != NULL )
    {
        pec->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskCancelCleanup::BeginTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::StopTask
//
//  Description:
//      This task has been asked to stop.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = true;

    LOG_STATUS_REPORT( L"[TaskCancelCleanup] This task has been asked to stop.", hr );

    HRETURN( hr );

} //*** CTaskCancelCleanup::StopTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::SetClusterCookie
//
//  Description:
//      Get the cookie of the cluster that we are supposed to be working on.
//
//  Arguments:
//      cookieClusterIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskCancelCleanup]" );

    HRESULT hr = S_OK;

    m_cookieCluster = cookieClusterIn;

    HRETURN( hr );

} //*** CTaskCancelCleanup::SetClusterCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::SetCompletionCookie
//
//  Description:
//      Get the completion cookie that we will send back when the task is
//      complete.
//
//  Arguments:
//      cookieIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::SetCompletionCookie(
    OBJECTCOOKIE    cookieCompletionIn
    )
{
    TraceFunc( "[ITaskCancelCleanup]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieCompletionIn;

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetCompletionCookie


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskCancelCleanup -- IClusCfgCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::SendStatusReport
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( m_picccCallback != NULL );

    HRESULT hr = S_OK;

    //
    //  Send the message!
    //

    hr = THR( m_picccCallback->SendStatusReport(
                                  pcszNodeNameIn
                                , clsidTaskMajorIn
                                , clsidTaskMinorIn
                                , ulMinIn
                                , ulMaxIn
                                , ulCurrentIn
                                , hrStatusIn
                                , pcszDescriptionIn
                                , pftTimeIn
                                , pcszReferenceIn
                                ) );

    if ( m_fStop == true )
    {
        hr = E_ABORT;
    } // if:

    HRETURN( hr );

} //*** CTaskCancelCleanup::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskCancelCleanup -- Private methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::HrInit
//
//  Description:
//      Failable initialization for this class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCancelCleanup::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CTaskCancelCleanup::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::HrProcessNode
//
//  Description:
//      Look at the resources on the passed in node and tell all that
//      support IClusCfgVerifyQuorum that the config session has been
//      canceled and that they need to cleanup.
//
//  Arguments:
//      cookieNodeIn
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCancelCleanup::HrProcessNode(
    OBJECTCOOKIE    cookieNodeIn
    )
{
    TraceFunc( "" );
    Assert( m_pom != NULL );

    HRESULT                         hr = S_OK;
    BSTR                            bstrNodeName = NULL;
    IClusCfgNodeInfo *              pccni = NULL;
    IUnknown *                      punk = NULL;
    OBJECTCOOKIE                    cookieDummy;
    IEnumClusCfgManagedResources *  peccmr = NULL;
    IClusCfgManagedResourceInfo *   pccmri = NULL;
    ULONG                           celtDummy;
    IClusCfgVerifyQuorum *          piccvq = NULL;

    //
    //  Get the node info object for the passed in node cookie.
    //

    hr = m_pom->GetObject( DFGUID_NodeInformation, cookieNodeIn, reinterpret_cast< IUnknown ** >( &punk ) );
    if ( FAILED( hr ) )
    {
        THR( hr );
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not get the node info object.", hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query for the node info object interface.", hr );
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    //
    //  Get the node's name and track the memory...
    //

    hr = THR( pccni->GetName( &bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not get the name of the node.", hr );
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrNodeName );

    LOG_STATUS_REPORT_STRING( L"[TaskCancelCleanup] Cleaning up node %1!ws!...", bstrNodeName, hr );

    //
    //  Get the managed resources enum for the node...
    //

    hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookieNodeIn, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT_STRING( L"[TaskCancelCleanup] Could not get the managed resource enumerator for node %1!ws!.", bstrNodeName, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query for the managed resource enumerator interface.", hr );
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    for ( ; m_fStop == false; )
    {
        //
        //  Cleanup
        //

        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        } // if:

        if ( piccvq != NULL )
        {
            piccvq->Release();
            piccvq = NULL;
        } // if:

        //
        //  Get next resource.
        //

        hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"[TaskCancelCleanup] Managed resource enumerator Next() method failed.", hr );
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break;  // exit condition
        } // if:

        //
        //  Get the IClusCfgVerifyQuorum interface.  Not all objects will support
        //  this interface.
        //

        hr = pccmri->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
        if ( hr == E_NOINTERFACE )
        {
            continue;       // we can skip those objects that don't support this interface...
        } // if:
        else if ( FAILED( hr ) )
        {
            THR( hr );
            LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could query for the IClusCfgVerifyQuorum interface.", hr );
            continue;
        } // else if:
        else
        {
            hr = STHR( piccvq->Cleanup( crCANCELLED ) );   // don't really care if this call fails...
            if ( FAILED( hr ) )
            {
                LOG_STATUS_REPORT( L"[TaskCancelCleanup] IClusCfgVerifyQuorum::Cleanup() method failed.", hr );
                continue;
            } // if:
        } // else:
    } // for:

Cleanup:

    LOG_STATUS_REPORT_STRING( L"[TaskCancelCleanup] Node %1!ws! cleaned up.", bstrNodeName, hr );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CTaskCancelCleanup::HrProcessNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::HrTaskCleanup
//
//  Description:
//      The task is running down and we need to tell the caller the status
//      and to let them know that we are done.
//
//  Arguments:
//      hrIn
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCancelCleanup::HrTaskCleanup(
    HRESULT hrIn
    )
{
    TraceFunc( "" );
    Assert( m_pom != NULL );
    Assert( m_pnui != NULL );

    HRESULT hr = S_OK;

    if ( m_cookieCompletion != 0 )
    {
        HRESULT     hr2;
        IUnknown *  punk;

        hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punk ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hrIn ) );
                psi->Release();
            } // if:
            else
            {
                LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query the completion cookie objet for IStandardInfo.", hr );
            } // else:
        } // if:
        else
        {
            LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not get the completion cookie object.", hr );
        } // else:

        //
        //  Have the notification manager signal the completion cookie.
        //

        hr2 = THR( m_pnui->ObjectChanged( m_cookieCompletion ) );
        if ( FAILED( hr2 ) )
        {
            LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not notify that this task is done.", hr );
            hr = hr2;
        } // if:

        m_cookieCompletion = 0;
    } // if: completion cookie was obtained

    HRETURN( hr );

} //*** CTaskCancelCleanup::HrTaskCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCancelCleanup::HrTaskSetup
//
//  Description:
//      Do all task setup.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCancelCleanup::HrTaskSetup( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    IServiceProvider *          psp = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;

    //
    //  Get the service manager...
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the notification manager...
    //

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    pcp->Release();
    pcp = NULL;

    //
    //  It is now okay to use SendStatusReport...
    //

    //
    //  Get the UI notification
    //

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not find notify UI connection point.", hr );
        goto Cleanup;
    } // if:

    hr = THR( pcp->TypeSafeQI( INotifyUI, &m_pnui ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query for the notify UI interface.", hr );
        goto Cleanup;
    } // if:

    //
    //  Get the object manager from the service manager...
    //

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[TaskCancelCleanup] Could not query for the object manager service.", hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( pcp != NULL )
    {
        pcp->Release();
    } // if:

    if ( pcpc != NULL )
    {
        pcpc->Release();
    } // if:

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskCancelCleanup::HrTaskSetup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzeclusterbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeClusterBase.cpp
//
//  Description:
//      CTaskAnalyzeClusterBase implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "TaskAnalyzeClusterBase.h"
#include "ManagedResource.h"
#include <NameUtil.h>

// For CsRpcGetJoinVersionData() and constants like JoinVersion_v2_0_c_ifspec
#include <StatusReports.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
DEFINE_THISCLASS( "CTaskAnalyzeClusterBase" )

#define CHECKING_TIMEOUT    90 // seconds


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::CTaskAnalyzeClusterBase
//
//  Description:
//      Construcor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeClusterBase::CTaskAnalyzeClusterBase( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskAnalyzeClusterBase::CTaskAnalyzeClusterBase


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::~CTaskAnalyzeClusterBase
//
//  Description:
//      Destrucor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeClusterBase::~CTaskAnalyzeClusterBase( void )
{
    TraceFunc( "" );

    ULONG   idx;

    for ( idx = 0; idx < m_idxQuorumToCleanupNext; idx++ )
    {
        ((*m_prgQuorumsToCleanup)[ idx ])->Release();
    } // for:

    TraceFree( m_prgQuorumsToCleanup );

    // m_cRef

    // m_cookieCompletion

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pcookies != NULL )
    {
        THR( HrFreeCookies() );
    }

    // m_cCookies
    // m_cNodes

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    // m_cookieCluster

    TraceMoveFromMemoryList( m_bstrClusterName, g_GlobalMemoryList );
    TraceSysFreeString( m_bstrClusterName );

    TraceSysFreeString( m_bstrNodeName );

    // m_fJoiningMode
    // m_cUserNodes

    TraceFree( m_pcookiesUser );

    if ( m_pnui != NULL )
    {
        m_pnui->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }

    if ( m_pcm != NULL )
    {
        m_pcm->Release();
    } // if:

    TraceSysFreeString( m_bstrQuorumUID );

    // m_cSubTasksDone
    // m_hrStatus

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskAnalyzeClusterBase::~CTaskAnalyzeClusterBase


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase - IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::UlAddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CTaskAnalyzeClusterBase::UlAddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskAnalyzeClusterBase::UlAddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::UlRelease
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
CTaskAnalyzeClusterBase::UlRelease( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskAnalyzeClusterBase::UlRelease


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase - IDoTask/ITaskAnalyzeCluster interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrBeginTask
//
//  Description:
//      Task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrBeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT             hr;
    DWORD               dwCookie = 0;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::BeginTask() Thread id %d", GetCurrentThreadId() );

    IServiceProvider *          psp  = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;

    TraceInitializeThread( L"" );

    LogMsg( L"[MT] [CTaskAnalyzeClusterBase] Beginning task..." );

    //
    //  Gather the managers we need to complete the task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_CoCreate_Service_Manager, hr );
        goto Cleanup;
    }

    Assert( m_pnui == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pom == NULL );

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_Notification_Manager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskAnalyzeClusterBase!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &m_pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint_QI_INotifyUI, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &m_ptm ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_TaskManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &m_pcm ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_ConnectionManager, hr );
        goto Cleanup;
    } // if:

    //
    //  Release the Service Manager.
    //

    psp->Release();
    psp = NULL;

    //
    //  Create an event to wait upon.
    //

    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_event == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_Win32Error, hr );
        goto Cleanup;
    }

    //
    //  Register with the Notification Manager to get notified.
    //

    Assert( ( m_cCookies == 0 ) && ( m_pcookies == NULL ) && ( m_cSubTasksDone == 0 ) );
    hr = THR( pcp->Advise( static_cast< INotifyUI * >( this ), &dwCookie ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_BeginTask_Advise, hr );
        goto Cleanup;
    }

    //
    //  Wait for the cluster connection to stablize.
    //

    hr = STHR( HrWaitForClusterConnection() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    Assert( m_bstrClusterName != NULL );

    //
    //  Tell the UI layer we are starting this task.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Update_Progress,
                                TASKID_Major_Establish_Connection,
                                0,
                                CHECKING_TIMEOUT,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Count the number of nodes to be analyzed.
    //

    hr = STHR( HrCountNumberOfNodes() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Create separate tasks to gather node information.
    //

    hr = STHR( HrCreateSubTasksToGatherNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Tell the UI layer we have completed this task.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Update_Progress,
                                TASKID_Major_Establish_Connection,
                                0,
                                CHECKING_TIMEOUT,
                                CHECKING_TIMEOUT,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Create separate tasks to gather node resources and networks.
    //

    hr = STHR( HrCreateSubTasksToGatherNodeResourcesAndNetworks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Count the number of nodes to be analyzed again. TaskGatherInformation
    //  will delete the cookies of unresponsive nodes.
    //

    hr = STHR( HrCountNumberOfNodes() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Create the feasibility task.
    //

    hr = STHR( HrCheckClusterFeasibility() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

Cleanup:

    STHR( HrCleanupTask( hr ) );

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    if ( pcp != NULL )
    {
        HRESULT hr2;

        hr2 = THR( pcp->Unadvise( dwCookie ) );
        if ( FAILED( hr2 ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_Unadvise, hr2 );
        }

        pcp->Release();
    }

    if ( m_cookieCompletion != 0 )
    {
        if ( m_pom != NULL )
        {
            HRESULT hr2;
            IUnknown * punk;
            hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punk ) );
            if ( SUCCEEDED( hr2 ) )
            {
                IStandardInfo * psi;

                hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
                punk->Release();

                if ( SUCCEEDED( hr2 ) )
                {
                    hr2 = THR( psi->SetStatus( hr ) );
                    psi->Release();
                }
                else
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_SetStatus, hr2 );
                }
            }
            else
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject, hr2 );
            }
        }

        if ( m_pnui != NULL )
        {
            //
            //  Have the notification manager signal the completion cookie.
            //
            HRESULT hr2 = THR( m_pnui->ObjectChanged( m_cookieCompletion ) );
            if ( FAILED( hr2 ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_ObjectChanged, hr2 );
                hr = hr2;
            } // if:
        } // if:

        m_cookieCompletion = 0;
    } // if: completion cookie was obtained

    LogMsg( L"[MT] [CTaskAnalyzeClusterBase] Exiting task.  The task was%ws cancelled.", m_fStop == FALSE ? L" not" : L"" );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrBeginTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrStopTask
//
//  Description:
//      Stop task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrStopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskAnalyzeClusterBase] Calling StopTask() on all remaining sub-tasks." );

    THR( HrNotifyAllTasksToStop() );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrStopTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrSetJoiningMode
//
//  Description:
//      Tell this task whether we are joining nodes to the cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrSetJoiningMode( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_fJoiningMode = TRUE;

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrSetJoiningMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrSetCookie
//
//  Description:
//      Receive the completion cookier from the task creator.
//
//  Arguments:
//      cookieIn
//          The completion cookie to send back to the creator when this
//          task is complete.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrSetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrSetCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrSetClusterCookie
//
//  Description:
//      Receive the object manager cookie of the cluster that we are going
//      to analyze.
//
//  Arguments:
//      cookieClusterIn
//          The cookie for the cluster to work on.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrSetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_cookieCluster = cookieClusterIn;

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrSetClusterCookie


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase - IClusCfgCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterBase::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                                  pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName
                                , clsidTaskMajorIn
                                , clsidTaskMinorIn
                                , ulMinIn
                                , ulMaxIn
                                , ulCurrentIn
                                , hrStatusIn
                                , pcszDescriptionIn
                                , pftTimeIn
                                , pcszReferenceIn
                                ) );

    if ( m_fStop == TRUE )
    {
        hr = E_ABORT;
    } // if:

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase - INotifyUI interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::ObjectChanged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterBase::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );
    Assert( cookieIn != 0 );

    HRESULT hr = S_OK;
    BOOL    fSuccess;
    ULONG   idx;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::ObjectChanged() Thread id %d", GetCurrentThreadId() );
    LogMsg( L"[MT:CTaskAnalyzeClusterBase] Looking for the completion cookie %u.", cookieIn );

    for ( idx = 0 ; idx < m_cCookies ; idx ++ )
    {
        Assert( m_pcookies != NULL );

        if ( cookieIn == m_pcookies[ idx ] )
        {
            LogMsg( L"[CTaskAnalyzeClusterBase] Clearing completion cookie %u at array index %u", cookieIn, idx );

            //
            //  Make sure it won't be signalled twice.
            //

            m_pcookies[ idx ] = NULL;

            // don't care if this fails, but it really shouldn't
            THR( HrRemoveTaskFromTrackingList( cookieIn ) );

            // don't care if this fails, but it really shouldn't
            THR( m_pom->RemoveObject( cookieIn ) );

            InterlockedIncrement( reinterpret_cast< long * >( &m_cSubTasksDone ) );

            if ( m_cSubTasksDone == m_cCookies )
            {
                //
                //  Signal the event if all the nodes are done.
                //
                fSuccess = SetEvent( m_event );
                if ( fSuccess == FALSE )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ObjectChanged_Win32Error, hr );
                    goto Cleanup;
                } // if:
            } // if: all done
        } // if: matched cookie
    } // for: each cookies in the array

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::ObjectChanged


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterBase - Protected methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrInit
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskAnalyzeClusterMinConfig
    Assert( m_cookieCompletion == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_pcookies == NULL );
    Assert( m_cNodes == 0 );
    Assert( m_event == NULL );
    Assert( m_cookieCluster == NULL );
    Assert( m_fJoiningMode == FALSE );
    Assert( m_cUserNodes == 0 );
    Assert( m_pcookiesUser == NULL );
    Assert( m_prgQuorumsToCleanup == NULL );
    Assert( m_idxQuorumToCleanupNext == 0 );

    Assert( m_pnui == NULL );
    Assert( m_pom == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pcm == NULL );
    Assert( m_fStop == FALSE );

    // INotifyUI
    Assert( m_cSubTasksDone == 0 );
    Assert( m_hrStatus == 0 );

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrWaitForClusterConnection
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrWaitForClusterConnection( void )
{
    TraceFunc( "" );

    HRESULT                     hrStatus;
    ULONG                       ulCurrent;
    DWORD                       sc;
    HRESULT                     hr = S_OK;
    IUnknown *                  punk = NULL;
    ITaskGatherClusterInfo *    ptgci = NULL;
    IStandardInfo *             psi = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrWaitForClusterConnection() Thread id %d", GetCurrentThreadId() );

    //
    //  Get the cluster name
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetObject_QI, hr );
        goto Cleanup;
    }

    //psi = TraceInterface( L"TaskAnalyzeClusterBase!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Retrieve the cluster's name.
    //

    hr = THR( psi->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrClusterName );

    //
    //  Tell the UI layer that we are starting to search for an existing cluster.
    //

    hr = THR( HrSendStatusReport(
                                  m_bstrClusterName
                                , TASKID_Major_Update_Progress
                                , TASKID_Major_Checking_For_Existing_Cluster
                                , 0
                                , CHECKING_TIMEOUT
                                , 0
                                , S_OK
                                , IDS_TASKID_MINOR_CHECKING_FOR_EXISTING_CLUSTER
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a completion cookie list.
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = THR( m_pom->FindObject( CLSID_ClusterCompletionCookie, m_cookieCluster, m_bstrClusterName, IID_NULL, &m_pcookies[ 0 ], &punk ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateCompletionCookie, hr );
        goto Cleanup;
    }

    m_cCookies = 1;

    //
    //  Create the task object.
    //

    hr = THR( m_ptm->CreateTask( TASK_GatherClusterInfo, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateTask, hr );
        goto Cleanup;
    }

    Assert( punk != NULL );

    hr = THR( punk->TypeSafeQI( ITaskGatherClusterInfo, &ptgci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateTask_QI, hr );
        goto Cleanup;
    }

    //
    //  Set the object cookie in the task.
    //

    hr = THR( ptgci->SetCookie( m_cookieCluster ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SetCookie, hr );
        goto Cleanup;
    }

    LogMsg( L"[CTaskAnalyzeClusterBase] Setting completion cookie %u at array index 0 into the gather cluster information task for node %ws", m_pcookies[ 0 ], m_bstrClusterName );
    hr = THR( ptgci->SetCompletionCookie( m_pcookies[ 0 ] ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SetCompletionCookie, hr );
        goto Cleanup;
    }

    //
    //  Submit the task.
    //

    hr = THR( m_ptm->SubmitTask( ptgci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SubmitTask, hr );
        goto Cleanup;
    }

    hr = THR( HrAddTaskToTrackingList( punk, m_pcookies[ 0 ] ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; ( sc != WAIT_OBJECT_0 ) && ( m_fStop == FALSE )
        ;
        )
    {
        MSG msg;

        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             1000,  // 1 second
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

        //
        //  Tell the UI layer that we are still searching for the cluster. BUT
        //  don't let the progress reach 100% if it is taking longer than
        //  CHECKING_TIMEOUT seconds.
        //
        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( m_bstrClusterName,
                                        TASKID_Major_Update_Progress,
                                        TASKID_Major_Checking_For_Existing_Cluster,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

    } // for: sc != WAIT_OBJECT_0

    //
    //  Cleanup the completion cookies
    //

    THR( HrFreeCookies() );

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the cluster's name again, because it might have been renamed.
    //
    TraceSysFreeString( m_bstrClusterName );
    m_bstrClusterName = NULL;
    hr = THR( psi->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrClusterName );

    //
    //  Check out the status of the cluster.
    //

    hr = THR( psi->GetStatus( &hrStatus ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetStatus, hr );
        goto Cleanup;
    }

    //
    //  If we are adding nodes and can't connect to the cluster, this
    //  should be deemed a bad thing!
    //

    if ( m_fJoiningMode )
    {
        //
        //  ADDING
        //

        switch ( hrStatus )
        {
            case S_OK:
                //
                //  This is what we are expecting.
                //
                break;

            case HR_S_RPC_S_SERVER_UNAVAILABLE:
                {
                    //
                    //  If we failed to connect to the server....
                    //
                    THR( HrSendStatusReport(
                                  m_bstrClusterName
                                , TASKID_Major_Checking_For_Existing_Cluster
                                , TASKID_Minor_Cluster_Not_Found
                                , 1
                                , 1
                                , 1
                                , HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE )
                                , IDS_TASKID_MINOR_CLUSTER_NOT_FOUND
                                ) );

                    hr = THR( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) );
                }
                goto Cleanup;

            default:
                {
                    //
                    //  If something else goes wrong, stop.
                    //
                    THR( HrSendStatusReport(
                              m_bstrClusterName
                            , TASKID_Major_Checking_For_Existing_Cluster
                            , TASKID_Minor_Error_Contacting_Cluster
                            , 1
                            , 1
                            , 1
                            , hrStatus
                            , IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER
                            ) );

                    hr = THR( hrStatus );
                }
                goto Cleanup;

        } // switch: hrStatus

    } // if: adding
    else
    {
        //
        //  CREATING
        //

        switch ( hrStatus )
        {
        case HR_S_RPC_S_SERVER_UNAVAILABLE:
            //
            //  This is what we are expecting.
            //
            break;

        case HRESULT_FROM_WIN32( ERROR_CONNECTION_REFUSED ):
        case REGDB_E_CLASSNOTREG:
        case E_ACCESSDENIED:
        case S_OK:
            {
                BSTR    bstrDescription = NULL;
                //
                //  If we are forming and we find an existing cluster with the same name
                //  that we trying to form, we shouldn't let the user continue.
                //
                //  NOTE that some error conditions indicate that "something" is hosting
                //  the cluster name.
                //
                hr = THR( HrFormatStringIntoBSTR(
                                                  g_hInstance
                                                , IDS_TASKID_MINOR_EXISTING_CLUSTER_FOUND
                                                , &bstrDescription
                                                , m_bstrClusterName
                                                ) );

                THR( SendStatusReport(
                              m_bstrClusterName
                            , TASKID_Major_Checking_For_Existing_Cluster
                            , TASKID_Minor_Existing_Cluster_Found
                            , 1
                            , 1
                            , 1
                            , HRESULT_FROM_WIN32( ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME )
                            , bstrDescription
                            , NULL
                            , NULL
                            ) );
                TraceSysFreeString( bstrDescription );
                hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME ) );
            }
            goto Cleanup;

        default:
            {
                //
                //  If something else goes wrong, stop.
                //
                THR( HrSendStatusReport(
                              m_bstrClusterName
                            , TASKID_Major_Checking_For_Existing_Cluster
                            , TASKID_Minor_Error_Contacting_Cluster
                            , 1
                            , 1
                            , 1
                            , hrStatus
                            , IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER
                            ) );
                hr = THR( hrStatus );
            }
            goto Cleanup;

        } // switch: hrStatus

    } // else: creating


    if ( m_fJoiningMode )
    {
        //
        //  Memorize the cookies of the objects that the user entered.
        //

        hr = THR( HrGetUsersNodesCookies() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Create cookies for the existing nodes.
        //

        hr = THR( HrAddJoinedNodes() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: adding nodes to an existing cluster

    //
    //  Tell the UI layer that we are done searching for the cluster.
    //

    hr = THR( SendStatusReport( m_bstrClusterName,
                                TASKID_Major_Update_Progress,
                                TASKID_Major_Checking_For_Existing_Cluster,
                                0,
                                CHECKING_TIMEOUT,
                                CHECKING_TIMEOUT,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( psi != NULL )
    {
        psi->Release();
    }

    if ( ptgci != NULL )
    {
        ptgci->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrWaitForClusterConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCountNumberOfNodes
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCountNumberOfNodes( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    IUnknown *      punk = NULL;
    IEnumCookies *  pec  = NULL;

    //
    //  Make sure all the node object that (will) make up the cluster
    //  are in a stable state.
    //
    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_FindObject_QI, hr );
        goto Cleanup;
    }

    //pec = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Count how many nodes there are.
    //

    hr = THR( pec->Count( &m_cNodes ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_EnumNodes_Count, hr );
        goto Cleanup;
    } // if: error getting count of nodes

    Assert( hr == S_OK );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCountNumberOfNodes


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeInfo
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeInfo( void )
{
    TraceFunc( "" );
    Assert( m_hrStatus == S_OK );

    HRESULT hr;
    ULONG   cNode;
    ULONG   cNodesToProcess;
    ULONG   ulCurrent;
    DWORD   sc;

    OBJECTCOOKIE            cookieDummy;
    OBJECTCOOKIE            cookieNode;
    BSTR                    bstrName = NULL;
    IUnknown *              punk  = NULL;
    IClusCfgNodeInfo *      pccni = NULL;
    IEnumCookies *          pec   = NULL;
    ITaskGatherNodeInfo *   ptgni = NULL;
    IStandardInfo *         psi   = NULL;
    IStandardInfo **        psiCompletion = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeInfo() Thread id %d", GetCurrentThreadId() );

    hr = THR( SendStatusReport(
                                  m_bstrClusterName
                                , TASKID_Major_Update_Progress
                                , TASKID_Major_Check_Node_Feasibility
                                , 0
                                , CHECKING_TIMEOUT
                                , 0
                                , S_OK
                                , NULL
                                , NULL
                                , NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_FindObject_QI, hr );
        goto Cleanup;
    }

    //pec = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Allocate a buffer to collect cookies
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_OutOfMemory, hr );
        goto Cleanup;
    }

    //
    //  KB: gpease  29-NOV-2000
    //      Create a list of "interesting" completion cookie StandardInfo-s. If any of the
    //      statuses return from this list are FAILED, then abort the analysis.
    //
    psiCompletion = reinterpret_cast< IStandardInfo ** >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( IStandardInfo * ) ) );
    if ( psiCompletion == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_OutOfMemory, hr );
        goto Cleanup;
    }

    //
    //  Loop thru the nodes, creating cookies and allocating a gather task for
    //  that node.
    //
    for ( cNode = 0 ; ( cNode < m_cNodes ) && ( m_fStop == FALSE ) ; cNode ++ )
    {
        ULONG   celtDummy;
        ULONG   idx;
        BOOL    fFound;

        //
        //  Grab the next node.
        //

        hr = STHR( pec->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_Next, hr );
            goto Cleanup;
        }

        //
        //  Get the node's name. We are using this to distinguish one node's
        //  completion cookie from another.  It might also make debugging
        //  easier (??).
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrName );

        //
        //  Create a completion cookie.
        //

        hr = THR( m_pom->FindObject( IID_NULL, m_cookieCluster, bstrName, DFGUID_StandardInfo, &m_pcookies[ cNode ], &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject, hr );
            goto Cleanup;
        }

        //
        //  Increment the cookie counter.
        //

        m_cCookies ++;

        //
        //  See if this node is one of the user entered nodes.
        //

        if ( m_fJoiningMode == FALSE )
        {
            //
            //  All nodes are "interesting" during a form operation.
            //

            Assert( m_cUserNodes == 0 );
            Assert( m_pcookiesUser == NULL );

            fFound = TRUE;
        } // if: creating a new cluster
        else
        {
            //
            //  Only the nodes the user entered are interesting during an add
            //  nodes operation.
            //

            for ( fFound = FALSE, idx = 0 ; idx < m_cUserNodes ; idx ++ )
            {
                if ( m_pcookiesUser[ idx ] == cookieNode )
                {
                    fFound = TRUE;
                    break;
                }
            } // for: each node entered by the user
        } // else: adding nodes to an existing cluster

        if ( fFound == TRUE )
        {
            hr = THR( punk->TypeSafeQI( IStandardInfo, &psiCompletion[ cNode ] ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject_QI, hr );
                goto Cleanup;
            }
        }
        else
        {
            Assert( psiCompletion[ cNode ] == NULL );
        }

        punk->Release();
        punk = NULL;

        //
        //  Create a task to gather this nodes information.
        //

        hr = THR( m_ptm->CreateTask( TASK_GatherNodeInfo, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CreateTask, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( ITaskGatherNodeInfo, &ptgni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_QI_GatherNodeInfo, hr );
            goto Cleanup;
        }

        //
        //  Set the tasks completion cookie.
        //

        LogMsg( L"[CTaskAnalyzeClusterBase] Setting completion cookie %u at array index %u into the gather node information task for node %ws", m_pcookies[ cNode ], cNode, bstrName );
        hr = THR( ptgni->SetCompletionCookie( m_pcookies[ cNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SetCompletionCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it what node it is suppose to gather information from.
        //

        hr = THR( ptgni->SetCookie( cookieNode ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SetCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it whether it is a user-added node or not.
        //

        hr = THR( ptgni->SetUserAddedNodeFlag( fFound ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SetUserAddedNodeFlag, hr );
            goto Cleanup;
        }

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptgni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SubmitTask, hr );
            goto Cleanup;
        }

        hr = THR( HrAddTaskToTrackingList( punk, m_pcookies[ cNode ] ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        ptgni->Release();
        ptgni = NULL;

    } // for: looping thru nodes

    Assert( m_cCookies == m_cNodes );

    //
    //  Reset the signal event.
    //

    {
        BOOL bRet = FALSE;

        bRet = ResetEvent( m_event );
        Assert( bRet == TRUE );
    }

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; ( sc != WAIT_OBJECT_0 ) && ( m_fStop == FALSE )
        ;
        )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx(
                  1
                , &m_event
                , INFINITE
                , QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE
                , 0
                );

        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Update_Progress,
                                        TASKID_Major_Establish_Connection,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

    } // for: sc == WAIT_OBJECT_0

    //
    //  Now check the results using the list of completion cookie StandardInfo-s
    //  built earlier of interesting objects. If any of these "interesting" cookies
    //  return a FAILED status, then abort the analysis.
    //

    for ( cNode = 0 , cNodesToProcess = 0 ; ( cNode < m_cNodes ) && ( m_fStop == FALSE ); cNode++ )
    {
        HRESULT hrStatus;

        if ( psiCompletion[ cNode ] == NULL )
        {
            continue;
        }

        hr = THR( psiCompletion[ cNode ]->GetStatus( &hrStatus ) );
        if ( FAILED( hrStatus ) )
        {
            hr = THR( hrStatus );
            goto Cleanup;
        }

        if ( hrStatus == S_OK )
        {
            cNodesToProcess++;
        } // if:

    } // for: cNode

    if ( cNodesToProcess == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NODE_NOT_AVAILABLE ) );

        THR( HrSendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Establish_Connection
                    , TASKID_Minor_No_Nodes_To_Process
                    , 1
                    , 1
                    , 1
                    , hr
                    , IDS_TASKID_MINOR_NO_NODES_TO_PROCESS
                    ) );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:

    THR( SendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Update_Progress
                , TASKID_Major_Check_Node_Feasibility
                , 0
                , CHECKING_TIMEOUT
                , CHECKING_TIMEOUT
                , S_OK
                , NULL
                , NULL
                , NULL
                ) );

    THR( HrFreeCookies() );

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( pec != NULL )
    {
        pec->Release();
    }

    if ( ptgni != NULL )
    {
        ptgni->Release();
    }

    if ( psi != NULL )
    {
        psi->Release();
    }

    if ( psiCompletion != NULL )
    {
        for ( cNode = 0 ; cNode < m_cNodes ; cNode++ )
        {
            if ( psiCompletion[ cNode ] != NULL )
            {
                psiCompletion[ cNode ]->Release();
            }
        }

        TraceFree( psiCompletion );
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeResourcesAndNetworks
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeResourcesAndNetworks( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxNode;
    ULONG   ulCurrent;
    DWORD   sc;

    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieNode;

    BSTR    bstrName = NULL;
    IUnknown *               punk  = NULL;
    IClusCfgNodeInfo *       pccni = NULL;
    IEnumCookies *           pec   = NULL;
    ITaskGatherInformation * ptgi  = NULL;
    IStandardInfo *          psi   = NULL;
    IStandardInfo **         ppsiStatuses = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeResourcesAndNetworks() Thread id %d", GetCurrentThreadId() );
    Assert( m_hrStatus == S_OK );

    //
    //  Tell the UI layer we are starting to retrieve the resources/networks.
    //

    hr = THR( SendStatusReport( m_bstrClusterName,
                                TASKID_Major_Update_Progress,
                                TASKID_Major_Find_Devices,
                                0,
                                CHECKING_TIMEOUT,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_FindObject_QI, hr );
        goto Cleanup;
    }

    pec = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Allocate a buffer to collect cookies
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_OutOfMemory, hr );
        goto Cleanup;
    }

    ppsiStatuses = reinterpret_cast< IStandardInfo ** >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( IStandardInfo * ) ) );
    if ( ppsiStatuses == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_OutOfMemory, hr );
        goto Cleanup;
    }

    //
    //  Loop thru the nodes, creating cookies and allocating a gather task for
    //  that node.
    //
    for ( idxNode = 0 ; ( idxNode < m_cNodes ) && ( m_fStop == FALSE ); idxNode++ )
    {
        ULONG   celtDummy;

        //
        //  Grab the next node.
        //

        hr = STHR( pec->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_Next, hr );
            goto Cleanup;
        }

        //
        //  Get the node's name. We are using this to distinguish one node's
        //  completion cookie from another. It might also make debugging
        //  easier (??).
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrName );

        //
        //  Create a completion cookie.
        //

        hr = THR( m_pom->FindObject( IID_NULL, m_cookieCluster, bstrName, DFGUID_StandardInfo, &m_pcookies[ idxNode ], &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IStandardInfo, &ppsiStatuses[ idxNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        //
        //  Increment the cookie counter.
        //

        m_cCookies ++;

        //
        //  Create a task to gather this node's information.
        //

        hr = THR( m_ptm->CreateTask( TASK_GatherInformation, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CreateTask, hr );
            goto Cleanup;
        }

        TraceMoveFromMemoryList( punk, g_GlobalMemoryList );

        hr = THR( punk->TypeSafeQI( ITaskGatherInformation, &ptgi ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_QI_GatherNodeInfo, hr );
            goto Cleanup;
        }

        //
        //  Set the tasks completion cookie.
        //

        hr = THR( ptgi->SetCompletionCookie( m_pcookies[ idxNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetCompletionCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it what node it is suppose to gather information from.
        //

        hr = THR( ptgi->SetNodeCookie( cookieNode ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it if we are creating or adding.
        //

        if ( m_fJoiningMode )
        {
            hr = THR( ptgi->SetJoining() );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetJoining, hr );
                goto Cleanup;
            }
        } // if: adding nodes to an existing cluster

        hr = THR( ptgi->SetMinimalConfiguration( BMinimalConfiguration() ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetMinimalConfiguration, hr );
            goto Cleanup;
        } // if:

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptgi ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SubmitTask, hr );
            goto Cleanup;
        }

        hr = THR( HrAddTaskToTrackingList( punk, m_pcookies[ idxNode ] ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        ptgi->Release();
        ptgi = NULL;

    } // for: looping thru nodes

    Assert( m_cCookies == m_cNodes );

    //
    //  Reset the signal event.
    //

    {
        BOOL bRet = FALSE;

        bRet = ResetEvent( m_event );
        Assert( bRet == TRUE );
    }

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; ( sc != WAIT_OBJECT_0 ) && ( m_fStop == FALSE )
        ;
        )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx(
                  1
                , &m_event
                , INFINITE
                , QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE
                , 0
                );

        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( m_bstrClusterName,
                                        TASKID_Major_Update_Progress,
                                        TASKID_Major_Find_Devices,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

    } // while: sc == WAIT_OBJECT_0

    //
    //  See if anything went wrong.
    //

    for ( idxNode = 0 ; ( idxNode < m_cNodes ) && ( m_fStop == FALSE ); idxNode++ )
    {
        HRESULT hrStatus;

        if ( ppsiStatuses[ idxNode ] == NULL )
        {
            continue;
        }

        hr = THR( ppsiStatuses[ idxNode ]->GetStatus( &hrStatus ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_GetStatus, hr );
            goto Cleanup;
        }

        if ( FAILED( hrStatus ) )
        {
            hr = THR( hrStatus );
            goto Cleanup;
        }
    }

    //
    //  Tell the UI we are done.
    //

    THR( SendStatusReport(
              m_bstrClusterName
            , TASKID_Major_Update_Progress
            , TASKID_Major_Find_Devices
            , 0
            , CHECKING_TIMEOUT
            , CHECKING_TIMEOUT
            , S_OK
            , NULL
            , NULL
            , NULL
            ) );

Cleanup:

    THR( HrFreeCookies() );

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( ptgi != NULL )
    {
        ptgi->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( ppsiStatuses != NULL )
    {
        for ( idxNode = 0 ; idxNode < m_cNodes ; idxNode++ )
        {
            if ( ppsiStatuses[ idxNode ] != NULL )
            {
                ppsiStatuses[ idxNode ]->Release();
            }
        }

        TraceFree( ppsiStatuses );
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCreateSubTasksToGatherNodeResourcesAndNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckClusterFeasibility
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckClusterFeasibility( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCheckClusterFeasibility() Thread id %d", GetCurrentThreadId() );

    //
    //  Notify the UI layer that we have started.
    //

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 0
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Check membership.
    //

    hr = THR( HrCheckClusterMembership() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 1
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Look for nodes not in the cluster's domain.
    //

    hr = THR( HrCheckNodeDomains() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 2
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Check platform interoperability.
    //

    hr = THR( HrCheckPlatformInteroperability() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 3
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Check version interoperability.
    //

    hr = STHR( HrCheckInteroperability() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 4
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Compare drive letter mappings to make sure we don't have any conflicts.
    //

    hr = THR( HrCompareDriveLetterMappings() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 5
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Compare resources on each node and in the cluster.
    //

    hr = THR( HrCompareResources() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 6
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Compare the networks.
    //

    hr = THR( HrCompareNetworks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Check_Cluster_Feasibility
                    , 0
                    , 8
                    , 7
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Now check to see if the nodes can all see the selected quorum resource.
    //

    hr = THR( HrCheckForCommonQuorumResource() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

Cleanup:

    //
    //  Notify the UI layer that we are done.
    //

    THR( SendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Update_Progress
                , TASKID_Major_Check_Cluster_Feasibility
                , 0
                , 8
                , 8
                , hr
                , NULL
                , NULL
                , NULL
                ) );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckClusterFeasibility



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrAddJoinedNodes
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrAddJoinedNodes( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    long                idxNode = 0;
    long                cNodes = 0;
    BSTR*               rgbstrNodeNames = NULL;

    OBJECTCOOKIE        cookieDummy;
    BSTR                bstrNodeFQN = NULL;
    size_t              idxClusterDomain = 0;
    IUnknown *          punkDummy = NULL;
    IUnknown *          punk = NULL;

    IClusCfgServer *        piccs = NULL;
    IClusCfgNodeInfo *      piccni = NULL;
    IClusCfgClusterInfo *   piccci = NULL;
    IClusCfgClusterInfoEx * picccie = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrAddJoinedNodes() Thread id %d", GetCurrentThreadId() );

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_AddJoinedNodes
                    , 0
                    , 1
                    , 0
                    , hr
                    , IDS_TASKID_MINOR_ADD_JOINED_NODES
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_pcm->GetConnectionToObject( m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetConnectionObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &piccs ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_ConfigConnection_QI, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccs->GetClusterNodeInfo( &piccni ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetNodeInfo, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccni->GetClusterConfigInfo( &piccci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetConfigInfo, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccci->TypeSafeQI( IClusCfgClusterInfoEx, &picccie ) );
    if ( FAILED( hr ) )
    {
        THR( HrSendStatusReport(
              m_bstrClusterName
            , TASKID_Major_Check_Cluster_Feasibility
            , TASKID_Minor_HrAddJoinedNodes_ClusterInfoEx_QI
            , 0
            , 1
            , 1
            , hr
            , IDS_ERR_NO_RC2_INTERFACE
            ) );
        goto Cleanup;
    } // if:


    hr = THR( HrFindDomainInFQN( m_bstrClusterName, &idxClusterDomain ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_HrFindDomainInFQN, hr );
        goto Cleanup;
    } // if

    hr = THR( picccie->GetNodeNames( &cNodes, &rgbstrNodeNames ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetNodeNames, hr );
        goto Cleanup;
    } // if

    for ( idxNode = 0; idxNode < cNodes; ++idxNode )
    {
        //
        //  Build the FQName of the node.
        //

        hr = THR( HrMakeFQN( rgbstrNodeNames[ idxNode ], m_bstrClusterName + idxClusterDomain, TRUE /*Accept non-RFC characters*/, &bstrNodeFQN ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_HrMakeFQN, hr );
            goto Cleanup;
        } // if

        LogMsg( L"[MT] Connecting to cluster node '%ws'", bstrNodeFQN );

        //
        //  Prime the object manager to retrieve the node information.
        //

        // can't wrap - should return E_PENDING
        hr = m_pom->FindObject( CLSID_NodeType, m_cookieCluster, bstrNodeFQN, DFGUID_NodeInformation, &cookieDummy, &punkDummy );
        if ( SUCCEEDED( hr ) )
        {
            Assert( punkDummy != NULL );
            punkDummy->Release();
            punkDummy = NULL;
        } // if
        else if ( hr == E_PENDING )
        {
            hr = S_OK;
        } // else
        else // !SUCCEEDED( hr ) && ( hr != E_PENDING )
        {
            THR( hr );
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_AddJoinedNodes_FindObject, hr );
            goto Cleanup;
        } // else

        TraceSysFreeString( bstrNodeFQN );
        bstrNodeFQN = NULL;
    } // for: idx

Cleanup:

    THR( HrSendStatusReport(
          m_bstrClusterName
        , TASKID_Major_Check_Cluster_Feasibility
        , TASKID_Minor_AddJoinedNodes
        , 0
        , 1
        , 1
        , hr
        , IDS_TASKID_MINOR_ADD_JOINED_NODES
        ) );

    Assert( punkDummy == NULL );
    TraceSysFreeString( bstrNodeFQN );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccs != NULL )
    {
        piccs->Release();
    } // if

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( piccci != NULL )
    {
        piccci->Release();
    } // if:

    if ( picccie != NULL )
    {
        picccie->Release();
    } // if:

    if ( rgbstrNodeNames != NULL )
    {
        for ( idxNode = 0; idxNode < cNodes; idxNode += 1 )
        {
            SysFreeString( rgbstrNodeNames[ idxNode ] );
        } // for

        CoTaskMemFree( rgbstrNodeNames );
    } // if

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrAddJoinedNodes



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckDomainMembership
//
//  Description:
//      Determine whether all participating nodes are in the cluster's domain.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckNodeDomains( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    OBJECTCOOKIE        ocNodeEnum = 0;
    IUnknown *          punkNodeEnum = NULL;
    IEnumNodes *        pen = NULL;
    IClusCfgNodeInfo ** prgccni = NULL;
    DWORD               cNodeInfoObjects = 0;
    DWORD               idxNodeInfo = 0;
    BSTR                bstrNodeName = NULL;
    size_t              idxClusterDomain = 0;
    ULONG               cNodesFetched = 0;
    BSTR                bstrDescription = NULL;
    BSTR                bstrReference = NULL;

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_CheckNodeDomains
                    , 0
                    , 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_CHECK_NODE_DOMAINS
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get a pointer to the domain portion of the cluster's name.
    //

    hr = THR( HrFindDomainInFQN( m_bstrClusterName, &idxClusterDomain ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_HrFindDomainInClusterFQN, hr );
        goto Cleanup;
    } // if

    //
    //  Ask the object manager for the node enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumNodes,
                                 &ocNodeEnum,
                                 &punkNodeEnum
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_FindObject, hr );
        goto Cleanup;
    } // if

    hr = THR( punkNodeEnum->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_QI, hr );
        goto Cleanup;
    } // if

    //
    //  Get array of node objects.
    //

    hr = THR( pen->Count( &cNodeInfoObjects ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_Count, hr );
        goto Cleanup;
    } // if

    if ( cNodeInfoObjects == 0 )
    {
        //  Nothing to check, so no more work to do.
        hr = S_OK;
        goto Cleanup;
    } // if

    prgccni = new IClusCfgNodeInfo*[ cNodeInfoObjects ];
    if ( prgccni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_New, hr );
        goto Cleanup;
    } // if
    ZeroMemory( prgccni, cNodeInfoObjects * sizeof( *prgccni ) );

    do
    {
        hr = STHR( pen->Next( cNodeInfoObjects, prgccni, &cNodesFetched ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_Next, hr );
            goto Cleanup;
        } // if

        //
        //  Step through node array, checking domain of each against cluster's domain.
        //

        for ( idxNodeInfo = 0; idxNodeInfo < cNodesFetched; idxNodeInfo += 1 )
        {
            size_t  idxNodeDomain = 0;

            hr = THR( prgccni[ idxNodeInfo ]->GetName( &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_GetName, hr );
                goto Cleanup;
            } // if
            TraceMemoryAddBSTR( bstrNodeName );

            //  Done with the node, but might reuse array, so dispose node now.
            prgccni[ idxNodeInfo ]->Release();
            prgccni[ idxNodeInfo ] = NULL;

            hr = THR( HrFindDomainInFQN( bstrNodeName, &idxNodeDomain ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_HrFindDomainInNodeFQN, hr );
                goto Cleanup;
            } // if

            if ( ClRtlStrICmp( bstrNodeName + idxNodeDomain, m_bstrClusterName + idxClusterDomain ) != 0 )
            {
                DWORD scError = TW32( ERROR_INVALID_DATA );

                hr = THR( HrFormatMessageIntoBSTR(
                      g_hInstance
                    , IDS_TASKID_MINOR_CHECK_NODE_DOMAINS_ERROR_REF
                    , &bstrReference
                    , bstrNodeName
                    , bstrNodeName + idxNodeDomain
                    , m_bstrClusterName + idxClusterDomain
                    ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_FormatMessage, hr );
                    goto Cleanup;
                } // if

                hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CHECK_NODE_DOMAINS_ERROR, &bstrDescription ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckNodeDomains_LoadString, hr );
                    goto Cleanup;
                } // if:

                hr = HRESULT_FROM_WIN32( scError );
                THR( SendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_CheckNodeDomains
                    , 0
                    , 1
                    , 1
                    , hr
                    , bstrDescription
                    , NULL
                    , bstrReference
                    ) );
                goto Cleanup;
            } // if node domain does not match cluster's

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;
        } // for each node

    } while ( cNodesFetched > 0 ); // while enumerator has more nodes

    //  Might have finished the loop with S_FALSE, so replace with S_OK to signal normal completion.
    hr = S_OK;

Cleanup:

    THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_CheckNodeDomains
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_CHECK_NODE_DOMAINS
                ) );

    if ( punkNodeEnum != NULL )
    {
        punkNodeEnum->Release();
    } // if:

    if ( pen != NULL )
    {
        pen->Release();
    } // if:

    if ( prgccni != NULL )
    {
        for ( idxNodeInfo = 0; idxNodeInfo < cNodeInfoObjects; idxNodeInfo += 1 )
        {
            if ( prgccni[ idxNodeInfo ] != NULL )
            {
                prgccni[ idxNodeInfo ]->Release();
            } // if
        } // for

        delete [] prgccni;
    } // if

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrReference );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckNodeDomains



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckClusterMembership
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//      ERROR_CLUSTER_NODE_EXISTS
//      ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckClusterMembership( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    OBJECTCOOKIE    cookieDummy;

    IClusCfgClusterInfo *   pccci;

    BSTR    bstrNodeName     = NULL;
    BSTR    bstrClusterName  = NULL;
    BSTR    bstrNotification = NULL;

    IUnknown *         punk  = NULL;
    IEnumNodes *       pen   = NULL;
    IClusCfgNodeInfo * pccni = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCheckClusterMembership() Thread id %d", GetCurrentThreadId() );

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Check_Cluster_Membership
                    , 0
                    , 1
                    , 0
                    , hr
                    , IDS_TASKID_MINOR_CHECK_CLUSTER_MEMBERSHIP
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the object manager for the node enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumNodes,&cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FindObject_QI, hr );
        goto Cleanup;
    }

    //
    //  If we are adding nodes to an existing cluster, make sure that all the
    //  other nodes are members of the same cluster.
    //

    Assert( SUCCEEDED( hr ) );
    while ( SUCCEEDED( hr ) )
    {
        ULONG   celtDummy;

        //
        //  Cleanup
        //

        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        TraceSysFreeString( bstrClusterName );
        bstrClusterName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_Next, hr );
            goto Cleanup;
        }

        //
        //  Check to see if we need to "form a cluster" by seeing if any
        //  of the nodes are already clustered.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_IsMemberOfCluster, hr );
            goto Cleanup;
        }

        if ( hr == S_OK )
        {
            //
            //  Retrieve the name and make sure they match.
            //

            hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetClusterConfigInfo, hr );
                goto Cleanup;
            }

            hr = THR( pccci->GetName( &bstrClusterName ) );
            pccci->Release();      // release promptly
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrClusterName );

            hr = THR( pccni->GetName( &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetNodeName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrNodeName );

            if ( ClRtlStrICmp( m_bstrClusterName, bstrClusterName ) != 0 )
            {
                //
                //  They don't match! Tell the UI layer!
                //

                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CLUSTER_NAME_MISMATCH, &bstrNotification, bstrClusterName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_FormatMessage, hr );
                    goto Cleanup;
                }

                hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );

                THR( SendStatusReport( bstrNodeName,
                                       TASKID_Major_Check_Cluster_Feasibility,
                                       TASKID_Minor_Cluster_Name_Mismatch,
                                       1,
                                       1,
                                       1,
                                       hr,
                                       bstrNotification,
                                       NULL,
                                       NULL
                                       ) );

                //
                //  We don't care what the return value is since we are bailing the analysis.
                //

                goto Cleanup;
            } // if: cluster names don't match
            else
            {
                hr = STHR( HrIsUserAddedNode( bstrNodeName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                if ( hr == S_OK )
                {
                    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NODE_ALREADY_IS_MEMBER, &bstrNotification, bstrNodeName, bstrClusterName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_FormatMessage1, hr );
                        goto Cleanup;
                    }

                    //
                    //  Make this a success code because we don't want to abort.  We simply want to tell the user...
                    //
                    hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_CLUSTER_NODE_ALREADY_MEMBER );

                    THR( SendStatusReport( bstrNodeName,
                                           TASKID_Major_Check_Cluster_Feasibility,
                                           TASKID_Minor_Cluster_Name_Match,
                                           1,
                                           1,
                                           1,
                                           hr,
                                           bstrNotification,
                                           NULL,
                                           NULL
                                           ) );
                } // if:
            } // else: cluster names do match then this node is already a member of this cluster

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;
        } // if: cluster member

    } // while: hr

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CLUSTER_MEMBERSHIP_VERIFIED, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FormatMessage, hr );
        goto Cleanup;
    }

    THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Minor_Check_Cluster_Membership
                , TASKID_Minor_Cluster_Membership_Verified
                , 1
                , 1
                , 1
                , hr
                , IDS_TASKID_CLUSTER_MEMBERSHIP_VERIFIED
                ) );

Cleanup:

    THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_Check_Cluster_Membership
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_CHECK_CLUSTER_MEMBERSHIP
                ) );

    if ( pen != NULL )
    {
        pen->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckClusterMembership


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCompareResources
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCompareResources( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    OBJECTCOOKIE                    cookieNode;
    OBJECTCOOKIE                    cookieDummy;
    OBJECTCOOKIE                    cookieClusterNode;
    ULONG                           celtDummy;
    BSTR                            bstrNotification    = NULL;
    BSTR                            bstrClusterNodeName = NULL;
    BSTR                            bstrClusterResUID   = NULL;
    BSTR                            bstrClusterResName  = NULL;
    BSTR                            bstrNodeName        = NULL;
    BSTR                            bstrNodeResUID      = NULL;
    BSTR                            bstrNodeResName     = NULL;
    BSTR                            bstrQuorumName      = NULL;
    IClusCfgManagedResourceInfo *   pccmriNew        = NULL;
    IUnknown *                      punk             = NULL;
    IEnumCookies *                  pecNodes         = NULL;
    IEnumClusCfgManagedResources *  peccmr           = NULL;
    IEnumClusCfgManagedResources *  peccmrCluster    = NULL;
    IClusCfgManagedResourceInfo *   pccmri           = NULL;
    IClusCfgManagedResourceInfo *   pccmriCluster    = NULL;
    IClusCfgVerifyQuorum *          piccvq = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCompareResources() Thread id %d", GetCurrentThreadId() );

    hr = THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_Compare_Resources
                , 0
                , 1
                , 0
                , hr
                , IDS_TASKID_MINOR_COMPARE_RESOURCES
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetAClusterNodeCookie( &pecNodes, &cookieClusterNode ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the node's name for error messages.
    //

    hr = THR( HrRetrieveCookiesName( m_pom, cookieClusterNode, &bstrClusterNodeName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the managed resources enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookieClusterNode, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
    {
        hr = THR( HrSendStatusReport(
                          m_bstrClusterName
                        , TASKID_Minor_Compare_Resources
                        , TASKID_Minor_No_Managed_Resources_Found
                        , 1
                        , 1
                        , 1
                        , MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND )
                        , IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

        // fall thru - the while ( hr == S_OK ) will be FALSE and keep going
    } // if: no manageable resources are available for the cluster node
    else if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object, hr );
        goto Cleanup;
    } // else if: error finding manageable resources for the cluster node
    else
    {
        hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmrCluster ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;
    } // else: found manageable resources for the cluster node

    //
    //  Loop thru the resources of the node selected as the cluster node
    //  to create an equivalent resource under the cluster configuration
    //  object/cookie.
    //

    while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
    {

        //
        //  Cleanup
        //

        if ( pccmriCluster != NULL )
        {
            pccmriCluster->Release();
            pccmriCluster = NULL;
        }

        //
        //  Get next resource.
        //

        hr = STHR( peccmrCluster->Next( 1, &pccmriCluster, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_First_Node_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        //
        //  Create a new object.  If min config was selected this new object will be marked as not managed.
        //

        hr = THR( HrCreateNewResourceInCluster( pccmriCluster, &pccmriNew ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( pccmriNew->IsQuorumResource() );
        if ( hr == S_OK )
        {
            Assert( m_bstrQuorumUID == NULL );

            hr = THR( pccmriNew->GetUID( &m_bstrQuorumUID ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_First_Node_Get_Quorum_UID, hr );
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( m_bstrQuorumUID );

            LogMsg( L"[MT][1] Found the quorum resource '%ws' on node '%ws' and setting it as the quorum resource.", m_bstrQuorumUID, bstrClusterNodeName );

            Assert( pccmriNew->IsManaged() == S_OK );

            //
            //  Since this is the quorum resource then it needs to be managed.  If min config was selected it will not be managed.
            //

            //hr = THR( pccmriNew->SetManaged( TRUE ) );
            //if ( FAILED( hr ) )
            //{
            //    goto Cleanup;
            //} // if:

            //
            //  Tell the UI which resource is the quorum.
            //

            hr = THR( pccmriNew->GetName( &bstrQuorumName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrQuorumName );

            hr = THR( ::HrFormatDescriptionAndSendStatusReport(
                          m_pcccb
                        , m_bstrClusterName
                        , TASKID_Minor_Compare_Resources
                        , TASKID_Minor_Compare_Resources_Enum_First_Node_Quorum
                        , 1
                        , 1
                        , 1
                        , hr
                        , IDS_TASKID_MINOR_COMPARE_RESOURCES_ENUM_FIRST_NODE_QUORUM
                        , bstrQuorumName
                        ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  Check that the quorum supports adding nodes to the cluster
            //  if we are in add mode.
            //

            if ( m_fJoiningMode )
            {
                hr = pccmriNew->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
                if ( hr == E_NOINTERFACE )
                {
                    LogMsg( L"[MT] The quorum resource \"%ws\" does not support IClusCfgVerifyQuorum and we cannot determine if multi nodes is supported.", m_bstrQuorumUID );
                    hr = S_OK;
                } // if:
                else if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // else if:
                else
                {
                    hr = STHR( piccvq->IsMultiNodeCapable() );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable, hr );
                        goto Cleanup;
                    }
                    else if ( hr == S_FALSE )
                    {
                        THR( HrSendStatusReport(
                                      m_bstrClusterName
                                    , TASKID_Minor_Compare_Resources
                                    , TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable
                                    , 1
                                    , 1
                                    , 1
                                    , HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) )
                                    , IDS_TASKID_MINOR_MISSING_JOINABLE_QUORUM_RESOURCE
                                    ) );

                        hr = HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) );
                        goto Cleanup;
                    } // else if: Quorum resource is not multi node capable.

                    piccvq->Release();
                    piccvq = NULL;
                } // else: This resource support IClusCfgVerifyQuorum
            } // if: Are we adding nodes?

            pccmriNew->Release();
            pccmriNew = NULL;
        } // if: Is this the quorum resource?
        else
        {
            pccmriNew->Release();
            pccmriNew = NULL;
            hr = S_OK;
        } // else: It is not the quorum resource.
    } // while: more resources on the selected cluster node

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    hr = THR( pecNodes->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Reset, hr );
        goto Cleanup;
    }

    //
    //  If this is an add nodes operation, a quorum resource must have been
    //  found in the existing cluster.
    //

    Assert( ( m_fJoiningMode == FALSE ) || ( m_bstrQuorumUID != NULL ) );

    //
    //  Loop thru the rest of the nodes comparing the resources.
    //

    for ( ; m_fStop == FALSE; )
    {
        //
        //  Cleanup
        //

        if ( peccmr != NULL )
        {
            peccmr->Release();
            peccmr = NULL;
        } // if:

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        //
        //  Skip the selected cluster node since we already have its
        //  configuration.
        //
        if ( cookieClusterNode == cookieNode )
        {
            continue;
        }

        //
        //  Retrieve the node's name for error messages.
        //

        hr = THR( HrRetrieveCookiesName( m_pom, cookieNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Retrieve the managed resources enumerator.
        //

        hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookieNode, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            hr = THR( HrSendStatusReport(
                              m_bstrClusterName
                            , TASKID_Minor_Compare_Resources
                            , TASKID_Minor_No_Managed_Resources_Found
                            , 1
                            , 1
                            , 1
                            , MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND )
                            , IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            continue;   // skip this node
        } // if: no manageable resources for the node are available
        else if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object, hr );
            goto Cleanup;
        } // else if: error finding manageable resources for the node

        hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        //
        //  Loop thru the managed resources that the node has.
        //

        for ( ; m_fStop == FALSE; )
        {
            //
            //  Cleanup
            //

            if ( pccmri != NULL )
            {
                pccmri->Release();
                pccmri = NULL;
            }

            if ( peccmrCluster != NULL )
            {
                peccmrCluster->Release();
                peccmrCluster = NULL;
            }

            TraceSysFreeString( bstrNodeResUID );
            TraceSysFreeString( bstrNodeResName );
            bstrNodeResUID = NULL;
            bstrNodeResName = NULL;

            //
            //  Get next resource
            //

            hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Next, hr );
                goto Cleanup;
            }

            if ( hr == S_FALSE )
            {
                break;  // exit condition
            }

            pccmri = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, pccmri, 1 );

            //
            //  Get the resource's UID and name.
            //

            hr = THR( pccmri->GetUID( &bstrNodeResUID ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetUID, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrNodeResUID );

            hr = THR( pccmri->GetName( &bstrNodeResName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrNodeResName );

            //
            //  See if it matches a resource already in the cluster configuration.
            //

            hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, m_cookieCluster, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                hr = S_FALSE;   // create a new object.
                // fall thru
            } // if: no cluster manageable resources found
            else if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object, hr );
                goto Cleanup;
            } // else if: error finding manageable resources for the cluster
            else
            {
                hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmrCluster ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object_QI, hr );
                    goto Cleanup;
                }

                punk->Release();
                punk = NULL;
            } // else: found manageable resources for the cluster

            //
            //  Loop thru the configured cluster resources to see what matches.
            //

            while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
            {
                BOOL    fMatch;

                //
                //  Cleanup
                //

                if ( pccmriCluster != NULL )
                {
                    pccmriCluster->Release();
                    pccmriCluster = NULL;
                }

                TraceSysFreeString( bstrClusterResUID );
                TraceSysFreeString( bstrClusterResName );
                bstrClusterResUID = NULL;
                bstrClusterResName = NULL;

                hr = STHR( peccmrCluster->Next( 1, &pccmriCluster, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                {
                    break;  // exit condition
                }

                //
                //  Get the resource's UID and name.
                //

                hr = THR( pccmriCluster->GetUID( &bstrClusterResUID ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrClusterResUID );

                hr = THR( pccmriCluster->GetName( &bstrClusterResName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetName, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrClusterResName );

                fMatch = ( NBSTRCompareCase( bstrNodeResUID, bstrClusterResUID ) == 0 );

                if ( fMatch == FALSE )
                {
                    continue;   // keep looping
                }

                //
                //  A resource is already in the database.  See if it is the
                //  same from the POV of management.
                //

                //
                //  If we made it here then we think it truly is the same
                //  resource.  The rest is stuff we need to fixup during the
                //  commit phase.
                //

                //
                //  If this node wants its resources managed, mark it as
                //  being managed in the cluster configuration as well.
                //  THIS IS NOT VALID WHEN JUST ADDING NODES.
                //

                //
                //  BUGBUG: 09-APR-2002 GalenB
                //
                //  I cannot see how this code is ever executed!  You must have more than one node in the nodes
                //  list to get down here.  However, you can only have more than one node in the node list when
                //  adding nodes...
                //

                if ( m_fJoiningMode == FALSE )
                {
                    //
                    //  Want to alert someone if we ever get in here...
                    //

                    Assert( FALSE );

                    hr = STHR( pccmri->IsManagedByDefault() );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsManageable, hr );
                        goto Cleanup;
                    }

                    if ( hr == S_OK )
                    {
                        hr = THR( pccmriCluster->SetManaged( TRUE ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetManaged, hr );
                            goto Cleanup;
                        }

                        //
                        // Since this node manages this resource, it should be
                        // able to provide us with a name.  We will use this
                        // name to overwrite whatever we currently have,
                        // except for the quorum resource, which already has
                        // the correct name.
                        //

                        hr = STHR( pccmri->IsQuorumResource() );
                        if ( hr == S_FALSE )
                        {
                            hr = THR( pccmriCluster->SetName( bstrNodeResName ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetResName, hr );
                                goto Cleanup;
                            }
                        } // if: is not quorum device
                    } // if: is managed
                } // if: creating a new cluster
                else
                {
                    //
                    //  Since we have a match and we are adding nodes to the cluster we need to perform a
                    //  private data exchange if the server objects supported it.
                    //

                    hr = THR( HrResourcePrivateDataExchange( pccmriCluster, pccmri ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:
                } // else:

                //
                //  Check to see if the resource is the quorum resource. If so, mark that
                //  we found a common quorum resource.
                //

                if ( m_bstrQuorumUID == NULL )
                {
                    //
                    //  No previous quorum has been set. See if this is the quorum resource.
                    //

                    // There is already a quorum resource when adding nodes to
                    // the cluster, so this string better already be set.
                    Assert( m_fJoiningMode == FALSE );

                    hr = STHR( pccmri->IsQuorumResource() );
                    if ( hr == S_OK )
                    {
                        //
                        //  Yes it is. Then mark it in the configuration as such.
                        //

                        hr = THR( pccmriCluster->SetQuorumResource( TRUE ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Cluster, hr );
                            goto Cleanup;
                        }

                        //
                        //  Remember that this resource is the quorum.
                        //

                        hr = THR( pccmriCluster->GetUID( &m_bstrQuorumUID ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_GetUID, hr );
                            goto Cleanup;
                        }

                        TraceMemoryAddBSTR( m_bstrQuorumUID );
                        LogMsg( L"[MT][2] Found the quorum resource '%ws' on node '%ws' and setting it as the quorum resource.", m_bstrQuorumUID, bstrNodeName );
                    } // if: node resource says its the quorum resource
                } // if: haven't found the quorum resource yet
                else if ( NBSTRCompareCase( m_bstrQuorumUID, bstrNodeResUID ) == 0 )
                {
                    //
                    //  Check to ensure that the resource on the new node can
                    //  really host the quorum resource.
                    //

                    LogMsg( L"[MT] Checking quorum capabilities (PrepareToHostQuorum) for node '%ws.' for quorum resource '%ws'", bstrNodeName, m_bstrQuorumUID );

                    hr = STHR( HrCheckQuorumCapabilities( pccmri, cookieNode ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    //
                    //  This is the same quorum. Mark the Node's configuration.
                    //

                    hr = THR( pccmri->SetQuorumResource( TRUE ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_True, hr );
                        goto Cleanup;
                    }
                } // else if: node's resource matches the quorum resource
                else
                {
                    //
                    //  Otherwise, make sure that the device isn't marked as quorum. (paranoid)
                    //

                    hr = THR( pccmri->SetQuorumResource( FALSE ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Minor_Compare_Resources, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_False, hr );
                        goto Cleanup;
                    }
                } // else: quorum already found and this is not it

                //
                //  Display the names of the cluster resource and the node's
                //  resource in the log.
                //

                LogMsg(
                      L"[MT] Matched resource '%ws' ('%ws') from node '%ws' with '%ws' ('%ws') on cluster node '%ws'."
                    , bstrNodeResName
                    , bstrNodeResUID
                    , bstrNodeName
                    , bstrClusterResName
                    , bstrClusterResUID
                    , bstrClusterNodeName
                    );

                //
                //  Exit the loop with S_OK so we don't create a new resource.
                //

                hr = S_OK;
                break;  // exit loop

            } // while: S_OK

            if ( hr == S_FALSE )
            {
                hr = THR( HrCreateNewResourceInCluster( pccmri, bstrNodeResName, &bstrNodeResUID, bstrNodeName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if: node's resource not matched to a cluster resource
        } // for: each resource on the node
    } // for: each node

    hr = S_OK;

Cleanup:

    THR( HrSendStatusReport(
              m_bstrClusterName
            , TASKID_Major_Check_Cluster_Feasibility
            , TASKID_Minor_Compare_Resources
            , 0
            , 1
            , 1
            , hr
            , IDS_TASKID_MINOR_COMPARE_RESOURCES
            ) );

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrClusterNodeName );
    TraceSysFreeString( bstrClusterResUID );
    TraceSysFreeString( bstrClusterResName );
    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrNodeResUID );
    TraceSysFreeString( bstrNodeResName );
    TraceSysFreeString( bstrQuorumName );

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    if ( pccmriNew != NULL )
    {
        pccmriNew->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    }

    if ( peccmr != NULL )
    {
        peccmr->Release();
    }

    if ( peccmrCluster != NULL )
    {
        peccmrCluster->Release();
    }

    if ( pccmri != NULL )
    {
        pccmri->Release();
    }

    if ( pccmriCluster != NULL )
    {
        pccmriCluster->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCompareResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCreateNewManagedResourceInClusterConfiguration
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCreateNewManagedResourceInClusterConfiguration(
      IClusCfgManagedResourceInfo *     pccmriIn
    , IClusCfgManagedResourceInfo **    ppccmriNewOut
    )
{
    TraceFunc( "" );
    Assert( pccmriIn != NULL );
    Assert( ppccmriNewOut != NULL );

    HRESULT                         hr;
    OBJECTCOOKIE                    cookieDummy;
    BSTR                            bstrUID = NULL;
    IUnknown *                      punk   = NULL;
    IGatherData *                   pgd    = NULL;
    IClusCfgManagedResourceInfo *   pccmri = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCreateNewManagedResourceInClusterConfiguration() Thread id %d", GetCurrentThreadId() );

    //
    //  TODO:   gpease  28-JUN-2000
    //          Make this dynamic - for now we'll just create a "managed device."
    //

    //  grab the name
    hr = THR( pccmriIn->GetUID( &bstrUID ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_GetUID, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrUID );

#ifdef DEBUG
    BSTR    _bstr_ = NULL;

    THR( pccmriIn->GetName( &_bstr_ ) );

    LogMsg( L"[MT] [HrCreateNewManagedResourceInClusterConfiguration] The UID for the new object is \"%ws\" and it has the name \"%ws\".", bstrUID, _bstr_ );

    SysFreeString( _bstr_ );
#endif

    //  create an object in the object manager.
    hr = THR( m_pom->FindObject( CLSID_ManagedResourceType,
                                 m_cookieCluster,
                                 bstrUID,
                                 DFGUID_ManagedResource,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_FindObject, hr );
        goto Cleanup;
    }

    //  find the IGatherData interface
    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_FindObject_QI, hr );
        goto Cleanup;
    }

    //  have the new object gather all information it needs
    hr = THR( pgd->Gather( m_cookieCluster, pccmriIn ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_Gather, hr );
        goto Cleanup;
    }

    //  hand the object out if requested
    if ( ppccmriNewOut != NULL )
    {
        // find the IClusCfgManagedResourceInfo
        hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_QI, hr );
            goto Cleanup;
        }

        *ppccmriNewOut = TraceInterface( L"ManagedResource!ICCMRI", IClusCfgManagedResourceInfo, pccmri, 0 );
        (*ppccmriNewOut)->AddRef();
    }

Cleanup:

    TraceSysFreeString( bstrUID );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    }

    if ( pgd != NULL )
    {
        pgd->Release();
    }

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCreateNewManagedResourceInClusterConfiguration


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckForCommonQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckForCommonQuorumResource( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE                    cookie;
    OBJECTCOOKIE                    cookieDummy;
    ULONG                           cMatchedNodes = 0;
    ULONG                           cAnalyzedNodes = 0;
    BOOL                            fNodeCanAccess = FALSE;
    BSTR                            bstrUID = NULL;
    BSTR                            bstrNotification = NULL;
    BSTR                            bstrNodeName = NULL;
    BSTR                            bstrMessage = NULL;
    IUnknown *                      punk = NULL;
    IEnumCookies *                  pecNodes = NULL;
    IEnumClusCfgManagedResources *  peccmr = NULL;
    IClusCfgManagedResourceInfo  *  pccmri = NULL;
    IClusCfgNodeInfo *              piccni = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCheckForCommonQuorumResource() Thread id %d", GetCurrentThreadId() );

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Finding_Common_Quorum_Device
                    , 0
                    , m_cNodes + 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_bstrQuorumUID != NULL )
    {
        //
        //  Grab the cookie enumer for nodes in our cluster configuration.
        //

        hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_FindObject_QI, hr );
            goto Cleanup;
        }

        //pecNodes = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumCookies", IEnumCookies, pecNodes, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Scan the cluster configurations looking for the quorum resource.
        //
        for ( ;; )
        {
            ULONG   celtDummy;

            if ( peccmr != NULL )
            {
                peccmr->Release();
                peccmr = NULL;
            } // if:

            hr = STHR( pecNodes->Next( 1, &cookie, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Next, hr );
                goto Cleanup;
            } // if:

            if ( hr == S_FALSE )
            {
                break;  // exit condition
            }

            hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookie, &punk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            punk->Release();
            punk = NULL;

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;

            hr = THR( piccni->GetName( &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrNodeName );

            //
            // increment counter for a "nice" progress bar
            //

            cAnalyzedNodes ++;

            hr = THR( HrSendStatusReport(
                              m_bstrClusterName
                            , TASKID_Major_Check_Cluster_Feasibility
                            , TASKID_Minor_Finding_Common_Quorum_Device
                            , 0
                            , m_cNodes + 1
                            , cAnalyzedNodes
                            , S_OK
                            , IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  Grab the managed resource enumer for resources that our node has.
            //

            hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookie, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                continue; // ignore and continue
            }
            else if ( FAILED( hr ) )
            {
                THR( hr );
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_FindObject_QI, hr );
                goto Cleanup;
            }

            //peccmr = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmr, 1 );

            punk->Release();
            punk = NULL;

            fNodeCanAccess = FALSE;

            //
            //  Loop thru the resources trying to match the UID of the quorum resource.
            //
            for ( ; m_fStop == FALSE; )
            {
                TraceSysFreeString( bstrUID );
                bstrUID = NULL;

                if ( pccmri != NULL )
                {
                    pccmri->Release();
                    pccmri = NULL;
                }

                hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                {
                    break;  // exit condition
                }

                pccmri = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, pccmri, 1 );

                hr = THR( pccmri->GetUID( &bstrUID ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrUID );

                if ( NBSTRCompareCase( bstrUID, m_bstrQuorumUID ) != 0 )
                {
                    continue;   // doesn't match - keep going
                }

                cMatchedNodes ++;
                fNodeCanAccess = TRUE;

                break;  // exit condition

            } // for: ( ; m_fStop == FALSE; )

            //
            // Give the UI feedback if this node has no access to the quorum
            //

            if ( fNodeCanAccess == FALSE )
            {
                HRESULT hrTemp;
                DWORD   dwRefId;
                CLSID   clsidMinorId;

                hr = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hr ) )
                {
                    clsidMinorId = IID_NULL;
                } // if:

                //
                //  Ensure that the parent item is in the tree control.
                //

                hr = THR( ::HrSendStatusReport(
                                  m_pcccb
                                , m_bstrClusterName
                                , TASKID_Minor_Finding_Common_Quorum_Device
                                , TASKID_Minor_Nodes_Cannot_Access_Quorum
                                , 1
                                , 1
                                , 1
                                , S_OK
                                , IDS_TASKID_MINOR_NODES_CANNOT_ACCESS_QUORUM
                                ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = HrFixupErrorCode( HRESULT_FROM_WIN32( ERROR_QUORUM_DISK_NOT_FOUND ) ); // don't THR this!

                GetNodeCannotVerifyQuorumStringRefId( &dwRefId );

                //
                //  Cleanup.
                //

                TraceSysFreeString( bstrMessage );
                bstrMessage = NULL;

                Assert( bstrNodeName != NULL );

                hrTemp = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_ERROR, &bstrMessage, bstrNodeName ) );
                if ( FAILED( hrTemp ) )
                {
                    hr = hrTemp;
                    goto Cleanup;
                } // if:

                hrTemp = THR( ::HrSendStatusReport(
                                  m_pcccb
                                , m_bstrClusterName
                                , TASKID_Minor_Nodes_Cannot_Access_Quorum
                                , clsidMinorId
                                , 1
                                , 1
                                , 1
                                , hr
                                , bstrMessage
                                , dwRefId
                                ) );
                if ( FAILED( hrTemp ) )
                {
                    hr = hrTemp;
                    goto Cleanup;
                } // if:
            } // if ( fNodeCanAccess == FALSE )
        } // for: ever
    } // if: m_bstrQuorumUID != NULL

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Figure out if we ended up with a common quorum device.
    //

    if ( cMatchedNodes == m_cNodes )
    {
        //
        //  We found a device that can be used as a common quorum device.
        //
        hr = THR( HrSendStatusReport(
                              m_bstrClusterName
                            , TASKID_Minor_Finding_Common_Quorum_Device
                            , TASKID_Minor_Found_Common_Quorum_Resource
                            , 1
                            , 1
                            , 1
                            , S_OK
                            , IDS_TASKID_MINOR_FOUND_COMMON_QUORUM_RESOURCE
                            ) );
        // error checked outside if/else statement
    }
    else
    {
        if ( ( m_cNodes == 1 ) && ( m_fJoiningMode == FALSE ) )
        {
            //
            //  We didn't find a common quorum device, but we're only forming. We can
            //  create the cluster with a local quorum. Just put up a warning.
            //

            hr = THR( HrShowLocalQuorumWarning() );

            // error checked outside if/else statement
        }
        else
        {
            HRESULT hrTemp;
            DWORD   dwMessageId;
            DWORD   dwRefId;

            //
            //  We didn't find a common quorum device.
            //

            hr = HrFixupErrorCode( HRESULT_FROM_WIN32( ERROR_QUORUM_DISK_NOT_FOUND ) );   // don't THR this!

            GetNoCommonQuorumToAllNodesStringIds( &dwMessageId, &dwRefId );

            hrTemp = THR( ::HrSendStatusReport(
                                  m_pcccb
                                , m_bstrClusterName
                                , TASKID_Minor_Finding_Common_Quorum_Device
                                , TASKID_Minor_Missing_Common_Quorum_Resource
                                , 0
                                , 1
                                , 1
                                , hr
                                , dwMessageId
                                , dwRefId
                                ) );

            //
            //  Should we bail out and return an error to the client?
            //

            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If the SSR failed.  This is a secondary failure to the one above.
            //

            if ( FAILED( hrTemp ) )
            {
                hr = hrTemp;
                goto Cleanup;
            } // if:

        }
    }

    //
    //  Check to see if any of the SendStatusReports() returned anything
    //  of interest.
    //

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_Finding_Common_Quorum_Device
                , 0
                , m_cNodes + 1
                , m_cNodes + 1
                , hr
                , IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE
                ) );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrMessage );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckForCommonQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCompareNetworks
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCompareNetworks( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    HRESULT                 hrError = S_OK;
    BSTR                    bstrUID = NULL;
    BSTR                    bstrName = NULL;
    BSTR                    bstrUIDExisting;
    BSTR                    bstrNotification = NULL;
    ULONG                   celtDummy;
    BOOL                    fIsPrivateNetworkAvailable = FALSE;
    BOOL                    fIsPublicNetworkAvailable = FALSE;
    OBJECTCOOKIE            cookieNode;
    OBJECTCOOKIE            cookieDummy;
    OBJECTCOOKIE            cookieFirst;
    IUnknown *              punk         = NULL;
    IEnumCookies *          pecNodes     = NULL;
    IEnumClusCfgNetworks *  peccn        = NULL;
    IEnumClusCfgNetworks *  peccnCluster = NULL;
    IClusCfgNetworkInfo *   pccni        = NULL;
    IClusCfgNetworkInfo *   pccniCluster = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCompareNetworks() Thread id %d", GetCurrentThreadId() );

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Check_Compare_Networks
                    , 0
                    , 1
                    , 0
                    , hr
                    , IDS_TASKID_MINOR_COMPARE_NETWORKS
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetAClusterNodeCookie( &pecNodes, &cookieFirst ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the node name in case of errors.
    //

    hr = THR( HrRetrieveCookiesName( m_pom, cookieFirst, &bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Retrieve the networks enumer.
    //

    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                 cookieFirst,
                                 NULL,
                                 DFGUID_EnumManageableNetworks,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
    {
        hr = THR( HrSendStatusReport(
                          bstrName
                        , TASKID_Minor_Check_Compare_Networks
                        , TASKID_Minor_No_Managed_Networks_Found
                        , 1
                        , 1
                        , 1
                        , MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND )
                        , IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

        // fall thru - the while ( hr == S_OK ) will be FALSE and keep going
    }
    else if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumResources_FindObject, hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumResources_FindObject_QI, hr );
            goto Cleanup;
        }

        //peccn = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccn, 1 );

        punk->Release();
        punk = NULL;
    }

    //
    //  Loop thru the first nodes networks create an equalivant network
    //  under the cluster configuration object/cookie.
    //

    while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
    {

        //  Cleanup
        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        //  Get next network
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetwork_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        pccni = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccni, 1 );

        //  create a new object
        hr = THR( HrCreateNewNetworkInClusterConfiguration( pccni, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // while: S_OK

    //
    //  Reset the enumeration.
    //

    hr = THR( pecNodes->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Reset, hr );
        goto Cleanup;
    }

    //
    //  Loop thru the rest of the nodes comparing the networks.
    //

    do
    {
        //
        //  Cleanup
        //

        if ( peccn != NULL )
        {
            peccn->Release();
            peccn = NULL;
        }
        TraceSysFreeString( bstrName );
        bstrName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_NextNode, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        if ( cookieNode == cookieFirst )
        {
            continue;   // skip it
        }

        //
        //  Retrieve the node's name
        //

        hr = THR( HrRetrieveCookiesName( m_pom, cookieNode, &bstrName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Retrieve the networks enumer.
        //

        hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                     cookieNode,
                                     NULL,
                                     DFGUID_EnumManageableNetworks,
                                     &cookieDummy,
                                     &punk
                                     ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            hr = THR( HrSendStatusReport(
                              bstrName
                            , TASKID_Minor_Check_Compare_Networks
                            , TASKID_Minor_No_Managed_Networks_Found
                            , 1
                            , 1
                            , 1
                            , MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND )
                            , IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            continue;   // skip this node
        } // if: not found
        else if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Next_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //peccn = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccn, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Loop thru the networks already that the node has.
        //

        //  These are used to detect whether or not private and public communications are enabled.
        fIsPrivateNetworkAvailable = FALSE;
        fIsPublicNetworkAvailable = FALSE;

        do
        {
            //
            //  Cleanup
            //

            if ( pccni != NULL )
            {
                pccni->Release();
                pccni = NULL;
            }
            TraceSysFreeString( bstrUID );
            bstrUID = NULL;

            if ( peccnCluster != NULL )
            {
                peccnCluster->Release();
                peccnCluster = NULL;
            }

            //
            //  Get next network
            //

            hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Next, hr );
                goto Cleanup;
            }

            if ( hr == S_FALSE )
            {
                break;  // exit condition
            }

            pccni = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccni, 1 );

            //
            //  Grab the network's UUID.
            //

            hr = THR( pccni->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_GetUID, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrUID );

            //
            //  See if it matches a network already in the cluster configuration.
            //

            hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                         m_cookieCluster,
                                         NULL,
                                         DFGUID_EnumManageableNetworks,
                                         &cookieDummy,
                                         &punk
                                         ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                hr = S_FALSE;   // create a new object.
                // fall thru
            }
            else if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccnCluster ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject_QI, hr );
                goto Cleanup;
            }

            //peccnCluster = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccnCluster, 1 );

            punk->Release();
            punk = NULL;

            //
            //  Loop thru the configured cluster network to see what matches.
            //

            while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
            {
                BOOL    fMatch;

                //
                //  Cleanup
                //

                if ( pccniCluster != NULL )
                {
                    pccniCluster->Release();
                    pccniCluster = NULL;
                }

                hr = STHR( peccnCluster->Next( 1, &pccniCluster, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                {
                    break;  // exit condition
                }

                pccniCluster = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccniCluster, 1 );

                hr = THR( pccniCluster->GetUID( &bstrUIDExisting ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrUIDExisting );

                fMatch = ( NBSTRCompareCase( bstrUID, bstrUIDExisting ) == 0 );
                TraceSysFreeString( bstrUIDExisting );

                if ( fMatch == FALSE )
                {
                    continue;   // keep looping
                }

                //
                //
                //  If we made it here then we think it TRUEly is the same network. The
                //  rest is stuff we need to fixup during the commit phase.
                //
                //

                //
                //  Exit the loop with S_OK so we don't create a new network.
                //

                //
                //  We have a match.  Now see if it's private and/or public.
                //

                hr = pccniCluster->IsPublic();
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Check_Compare_Networks, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_IsPublic, hr );
                    goto Cleanup;
                }
                else if ( hr == S_OK )
                {
                    fIsPublicNetworkAvailable = TRUE;
                }

                hr = pccniCluster->IsPrivate();
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Minor_Check_Compare_Networks, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_IsPrivate, hr );
                    goto Cleanup;
                }
                else if ( hr == S_OK )
                {
                    fIsPrivateNetworkAvailable = TRUE;
                }

                hr = S_OK;
                break;  // exit loop

            } // while: S_OK

            if ( hr == S_FALSE )
            {
                //
                //  Need to create a new object.
                //

                Assert( pccni != NULL );

                hr = THR( HrCreateNewNetworkInClusterConfiguration( pccni, NULL ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

            } // if: object not found

        } while ( ( hr == S_OK ) && ( m_fStop == FALSE ) ); // networks

        //
        //  If no public network is available return a warning.  If no private network is available
        //  return an error, which supercedes the warning.
        //
        if ( fIsPublicNetworkAvailable == FALSE )
        {
            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NO_PUBLIC_NETWORKS_FOUND, &bstrNotification, bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Check_Compare_Networks, TASKID_Minor_CompareNetworks_IsPublic_FormatMessage, hr );
            }

            hr = THR( SendStatusReport(
                              m_bstrClusterName
                            , TASKID_Minor_Check_Compare_Networks
                            , TASKID_Minor_CompareNetworks_EnumNodes_IsPublicNetworkAvailable
                            , 1
                            , 1
                            , 1
                            , MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_CLUSTER_NETWORK_NOT_FOUND )
                            , bstrNotification
                            , NULL
                            , NULL
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //
            //  At a minimum we need to return a warning.  If we have anything less than that
            //  then upgrade it to our warning.  We don't break or goto Cleanup here so that
            //  we can continue evaluating any other nodes that we're trying to add.
            //

            if ( hrError == S_OK )
            {
                hrError = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_CLUSTER_NETWORK_NOT_FOUND );
            }
        } // if: publicnetworkavailable == FALSE

        if ( fIsPrivateNetworkAvailable == FALSE )
        {
            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NO_PRIVATE_NETWORKS_FOUND, &bstrNotification, bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Minor_Check_Compare_Networks, TASKID_Minor_CompareNetworks_IsPrivate_FormatMessage, hr );
            }

            hr = THR( SendStatusReport(
                              m_bstrClusterName
                            , TASKID_Minor_Check_Compare_Networks
                            , TASKID_Minor_CompareNetworks_EnumNodes_IsPrivateNetworkAvailable
                            , 1
                            , 1
                            , 1
                            , HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_NOT_FOUND )
                            , bstrNotification
                            , NULL
                            , NULL
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //
            //  We need to return an error.  If we have anything less than that
            //  then upgrade it to our error.  We don't break or goto Cleanup here so that
            //  we can continue evaluating any other nodes that we're trying to add.
            //

            if ( HRESULT_SEVERITY( hrError ) < SEVERITY_ERROR )
            {
                hrError = HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_NOT_FOUND );
            }
        } // if: privatenetworkavailable == FALSE

    } while ( ( hr == S_OK ) && ( m_fStop == FALSE ) ); // nodes

    //
    //  If we had an error with one of the new nodes not having both public and private
    //  communications enabled, then return the correct error.  We do this here so that
    //  we can analyze all of the nodes in the enumeration to detect multiple errors at
    //  once.  If we get here then hr is going to be S_FALSE since that is the normal
    //  exit condition for the loops above.  Any other exit would have gone to cleanup.
    //

    hr = hrError;

Cleanup:

    THR( HrSendStatusReport(
                  m_bstrClusterName
                , TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_Check_Compare_Networks
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_COMPARE_NETWORKS
                ) );

    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    }

    if ( peccn != NULL )
    {
        peccn->Release();
    }

    if ( peccnCluster != NULL )
    {
        peccnCluster->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( pccniCluster != NULL )
    {
        pccniCluster->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCompareNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCreateNewNetworkInClusterConfiguration
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCreateNewNetworkInClusterConfiguration(
    IClusCfgNetworkInfo * pccniIn,
    IClusCfgNetworkInfo ** ppccniNewOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    BSTR    bstrUID = NULL;

    IUnknown *            punk  = NULL;
    IGatherData *         pgd   = NULL;
    IClusCfgNetworkInfo * pccni = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCreateNewNetworkInClusterConfiguration() Thread id %d", GetCurrentThreadId() );

    //  grab the name
    hr = THR( pccniIn->GetUID( &bstrUID ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_GetUID, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrUID );

    //  create an object in the object manager.
    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                 m_cookieCluster,
                                 bstrUID,
                                 DFGUID_NetworkResource,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_FindObject, hr );
        goto Cleanup;
    }

    //  find the IGatherData interface
    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_FindObject_QI, hr );
        goto Cleanup;
    }

    //  have the new object gather all information it needs
    hr = THR( pgd->Gather( m_cookieCluster, pccniIn ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_Gather, hr );
        goto Cleanup;
    }

    //  hand the object out if requested
    if ( ppccniNewOut != NULL )
    {
        // find the IClusCfgManagedResourceInfo
        hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_QI, hr );
            goto Cleanup;
        }

        *ppccniNewOut = TraceInterface( L"ManagedResource!ICCNI", IClusCfgNetworkInfo, pccni, 0 );
        (*ppccniNewOut)->AddRef();
    }

Cleanup:
    TraceSysFreeString( bstrUID );

    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCreateNewNetworkInClusterConfiguration


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrFreeCookies
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrFreeCookies( void )
{
    TraceFunc( "" );

    HRESULT hr;

    HRESULT hrReturn = S_OK;

    Assert( m_pom != NULL );

    while( m_cCookies != 0 )
    {
        m_cCookies --;

        if ( m_pcookies[ m_cCookies ] != NULL )
        {
            hr = THR( m_pom->RemoveObject( m_pcookies[ m_cCookies ] ) );
            if ( FAILED( hr ) )
            {
                hrReturn = hr;
            }
        } // if: found cookie
    } // while: more cookies

    Assert( m_cCookies == 0 );
    m_cSubTasksDone = 0;
    TraceFree( m_pcookies );
    m_pcookies = NULL;

    HRETURN( hrReturn );

} //*** CTaskAnalyzeClusterBase::HrFreeCookies

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckInteroperability
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckInteroperability( void )
{
    TraceFunc( "" );
    Assert( m_pcm != NULL );

    HRESULT             hr = S_OK;
    IUnknown *          punk = NULL;
    bool                fAllNodesMatch;
    DWORD               dwNodeHighestVersion;
    DWORD               dwNodeLowestVersion;

    IClusCfgServer *        piccs = NULL;
    IClusCfgNodeInfo *      piccni = NULL;
    IClusCfgClusterInfo *   piccci = NULL;
    IClusCfgClusterInfoEx * picccie = NULL;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrCheckInteroperability() Thread id %d", GetCurrentThreadId() );

    //
    //  If were are creating a new cluster, there is no need to do this check.
    //
    if ( m_fJoiningMode == FALSE )
    {
        goto Cleanup;
    } // if:

    //
    //  Tell the UI were are starting this.
    //

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_CheckInteroperability
                    , 0
                    , 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_CHECKINTEROPERABILITY
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  All nodes must be at the same level diring a bulk add.
    //
    hr = STHR( HrEnsureAllJoiningNodesSameVersion( &dwNodeHighestVersion, &dwNodeLowestVersion, &fAllNodesMatch ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    //
    //  If no nodes found that are being added, then there isn't a need to do
    //  do this check.  Just bail.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if

    if ( fAllNodesMatch == FALSE )
    {
        hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ) );
        goto Cleanup;
    } // if:

    //
    // Get and verify the sponsor version
    //

    hr = THR( m_pcm->GetConnectionToObject( m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_GetConnectionObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &piccs ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_ConfigConnection_QI, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccs->GetClusterNodeInfo( &piccni ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_GetNodeInfo, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccni->GetClusterConfigInfo( &piccci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_GetClusterConfigInfo, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccci->TypeSafeQI( IClusCfgClusterInfoEx, &picccie ) );
    if ( FAILED( hr ) )
    {
        THR( HrSendStatusReport(
              m_bstrClusterName
            , TASKID_Major_Check_Cluster_Feasibility
            , TASKID_Minor_HrCheckInteroperability_ClusterInfoEx_QI
            , 0
            , 1
            , 1
            , hr
            , IDS_ERR_NO_RC2_INTERFACE
            ) );
        goto Cleanup;
    } // if:

    hr = THR( picccie->CheckJoiningNodeVersion( dwNodeHighestVersion, dwNodeLowestVersion ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_CheckJoiningNodeVersion, hr );
        goto Cleanup;
    } // if: CheckJoiningNodeVersion() failed

    goto UpdateStatus;

Error:
UpdateStatus:
    {
        HRESULT hr2;

        hr2 = THR( SendStatusReport( m_bstrClusterName,
                                     TASKID_Major_Check_Cluster_Feasibility,
                                     TASKID_Minor_CheckInteroperability,
                                     0,
                                     1,
                                     1,
                                     hr,
                                     NULL,
                                     NULL,
                                     NULL
                                     ) );
        if ( FAILED( hr2 ) )
        {
            hr = hr2;
        } // if
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccs != NULL )
    {
        piccs->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( piccci != NULL )
    {
        piccci->Release();
    } // if:

    if ( picccie != NULL )
    {
        picccie->Release();
    } // if:

    HRETURN( hr );
} //*** CTaskAnalyzeClusterBase::HrCheckInteroperability

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrEnsureAllJoiningNodesSameVersion
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrEnsureAllJoiningNodesSameVersion(
    DWORD * pdwNodeHighestVersionOut,
    DWORD * pdwNodeLowestVersionOut,
    bool *  pfAllNodesMatchOut
    )
{
    TraceFunc( "" );
    Assert( m_fJoiningMode );
    Assert( pdwNodeHighestVersionOut != NULL );
    Assert( pdwNodeLowestVersionOut != NULL );
    Assert( pfAllNodesMatchOut != NULL );

    HRESULT             hr = S_OK;
    OBJECTCOOKIE        cookieDummy;
    IUnknown *          punk  = NULL;
    IEnumNodes *        pen   = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    DWORD               rgdwNodeHighestVersion[ 2 ];
    DWORD               rgdwNodeLowestVersion[ 2 ];
    int                 idx = 0;
    BSTR                bstrDescription = NULL;
    BSTR                bstrNodeName = NULL;
    BSTR                bstrFirstNodeName = NULL;
    BOOL                fFoundAtLeastOneJoiningNode = FALSE;

    TraceFlow1( "[MT] CTaskAnalyzeClusterBase::HrEnsureAllJoiningNodesSameVersion() Thread id %d", GetCurrentThreadId() );

    *pfAllNodesMatchOut = TRUE;

    ZeroMemory( rgdwNodeHighestVersion, sizeof( rgdwNodeHighestVersion ) );
    ZeroMemory( rgdwNodeLowestVersion, sizeof( rgdwNodeLowestVersion ) );

    //
    //  Ask the object manager for the node enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumNodes,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject_QI, hr );
        goto Cleanup;
    }

    //
    //  Look at each node and ensure that they all have the same version.
    //

    Assert( SUCCEEDED( hr ) );
    while ( SUCCEEDED( hr ) )
    {
        ULONG   celtDummy;

        //
        //  Cleanup
        //

        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        } // if:

        //
        //  Get the next node.
        //

        hr = STHR( pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;  // exit condition
        } // if:

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_EnumNode_Next, hr );
            goto Cleanup;
        } // if:

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_IsMemberOfCluster, hr );
            goto Cleanup;
        } // if:

        //
        //  Only want to check those nodes that are not already members of a cluster.  The nodes being added.
        //
        if ( hr == S_FALSE )
        {
            fFoundAtLeastOneJoiningNode = TRUE;

            hr = THR( pccni->GetClusterVersion( &rgdwNodeHighestVersion[ idx ], &rgdwNodeLowestVersion[ idx ] ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_GetClusterVersion, hr );
                goto Cleanup;
            } // if:

            idx++;

            //
            //  Need to get the another node's version.
            //
            if ( idx == 1 )
            {
                WCHAR * psz = NULL;

                hr = THR( pccni->GetName( &bstrFirstNodeName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName, hr );
                    goto Cleanup;
                } // if:

                TraceMemoryAddBSTR( bstrFirstNodeName );

                psz = wcschr( bstrFirstNodeName, L'.' );
                if ( psz != NULL )
                {
                    *psz = L'\0';       // change from an FQDN to a simple node name.
                } // if:

                continue;
            } // if:

            //
            //  Let's compare two nodes at a time...
            //
            if ( idx == 2 )
            {
                if ( ( rgdwNodeHighestVersion[ 0 ] == rgdwNodeHighestVersion[ 1 ] )
                  && ( rgdwNodeLowestVersion[ 1 ] == rgdwNodeLowestVersion[ 1 ] ) )
                {
                    idx = 1;    // reset to put the next node's version values at the second position...
                    continue;
                } // if:
                else
                {
                    *pfAllNodesMatchOut = FALSE;

                    hr = THR( pccni->GetName( &bstrNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName, hr );
                        goto Cleanup;
                    } // if:

                    TraceMemoryAddBSTR( bstrNodeName );

                    hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NODES_VERSION_MISMATCH, &bstrDescription, bstrFirstNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FormatString, hr );
                        goto Cleanup;
                    } // if:

                    THR( SendStatusReport(
                              m_bstrClusterName
                            , TASKID_Minor_CheckInteroperability
                            , TASKID_Minor_Incompatible_Versions
                            , 1
                            , 1
                            , 1
                            , HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS )
                            , bstrDescription
                            , NULL
                            , NULL
                            ) );
                    goto Cleanup;
                } // else:
            } // if:
        } // if:
    } // while: hr

    if ( fFoundAtLeastOneJoiningNode == FALSE )
    {
        THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Minor_CheckInteroperability
                    , TASKID_Minor_No_Joining_Nodes_Found_For_Version_Check
                    , 1
                    , 1
                    , 1
                    , S_FALSE
                    , IDS_TASKID_MINOR_NO_JOINING_NODES_FOUND_FOR_VERSION_CHECK
                    ) );

        hr = S_FALSE;
        goto Cleanup;
    }

    //
    //  Fill in the out args...
    //
    *pdwNodeHighestVersionOut = rgdwNodeHighestVersion[ 0 ];
    *pdwNodeLowestVersionOut = rgdwNodeLowestVersion[ 0 ];

    hr = S_OK;

Cleanup:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    if ( pen != NULL )
    {
        pen->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrFirstNodeName );
    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrEnsureAllJoiningNodesSameVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrGetUsersNodesCookies
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrGetUsersNodesCookies( void )
{
    TraceFunc( "" );

    HRESULT         hr;
    ULONG           cElememtsReturned;
    OBJECTCOOKIE    cookieDummy;
    ULONG           cNode;
    IUnknown *      punk = NULL;
    IEnumCookies *  pec  = NULL;
    BSTR            bstrName = NULL;

    //
    //  Get the cookie enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_FindObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_FindObject_QI, hr );
        goto Cleanup;
    } // if:

    punk->Release();
    punk = NULL;

    //
    //  Get the number of nodes entered by the user.
    //

    hr = THR( pec->Count( &m_cUserNodes ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Count, hr );
        goto Cleanup;
    } // if: error getting count of nodes entered by user

    Assert( hr == S_OK );

    //
    //  Allocate a buffer for the cookies.
    //

    m_pcookiesUser = (OBJECTCOOKIE *) TraceAlloc( 0, sizeof( OBJECTCOOKIE ) * m_cUserNodes );
    if ( m_pcookiesUser == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_OutOfMemory, hr );
        goto Cleanup;
    } // if:

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Reset, hr );
        goto Cleanup;
    } // if:

    //
    //  Enumerate them again this time putting the cookies into the buffer.
    //

    for ( cNode = 0 ; cNode < m_cUserNodes ; cNode ++ )
    {
        //
        //  Cleanup
        //

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        //
        //  Get each user-added node cookie in turn and add it to the array...
        //

        hr = THR( pec->Next( 1, &m_pcookiesUser[ cNode ], &cElememtsReturned ) );
        AssertMsg( hr != S_FALSE, "We should never hit this because the count of nodes should not change!" );
        if ( hr != S_OK )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next, hr );
            goto Cleanup;
        } // if:

        //
        //  Log the node name as a user-added node.
        //

        hr = THR( HrRetrieveCookiesName( m_pom, m_pcookiesUser[ cNode ], &bstrName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        LogMsg( L"[MT] Adding node '%ws' to the list of user-added nodes.", bstrName );
    } // for: each user-entered node

    Assert( cNode == m_cUserNodes );

#ifdef DEBUG
{
    OBJECTCOOKIE    cookie;

    hr = STHR( pec->Next( 1, &cookie, &cElememtsReturned ) );
    Assert( hr == S_FALSE );
}
#endif

    hr = S_OK;

Cleanup:

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( pec != NULL )
    {
        pec->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrGetUsersNodesCookies


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrIsUserAddedNode
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrIsUserAddedNode(
    BSTR bstrNodeNameIn
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_FALSE;
    ULONG               cNode;
    IUnknown *          punk = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    BSTR                bstrNodeName = NULL;

    for ( cNode = 0 ; cNode < m_cUserNodes ; cNode ++ )
    {
        hr = m_pom->GetObject( DFGUID_NodeInformation, m_pcookiesUser[ cNode ], &punk );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            ULONG idx;

            //
            //  The cookie at cNode was removed from the object manager since it was gathered before the nodes
            //  were connected to.  This typically means that the user added node was removed form the list
            //  of nodes to work on.  We need to remove this cookie from the list.
            //

            //
            //  Shift the cookies to the left by one index.
            //

            for ( idx = cNode; idx < m_cUserNodes - 1; idx++ )
            {
                m_pcookiesUser[ idx ] = m_pcookiesUser[ idx + 1 ];
            } // for:

            m_cUserNodes -= 1;
            hr = S_FALSE;
            continue;
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetObject, hr );
            goto Cleanup;
        } // else if:

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetObject_QI, hr );
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetName, hr );
            goto Cleanup;
        } // if:

        TraceMemoryAddBSTR( bstrNodeName );

        pccni->Release();
        pccni = NULL;

        if ( NBSTRCompareCase( bstrNodeNameIn, bstrNodeName ) == 0 )
        {
            hr = S_OK;
            break;
        } // if:

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        hr = S_FALSE;
    } // for:

Cleanup:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrIsUserAddedNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrSendStatusReport
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.

//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrSendStatusReport(
      LPCWSTR   pcszNodeNameIn
    , CLSID     clsidMajorIn
    , CLSID     clsidMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrIn
    , int       nDescriptionIdIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, nDescriptionIdIn, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SendStatusReport(
                  pcszNodeNameIn == NULL ? m_bstrClusterName : pcszNodeNameIn
                , clsidMajorIn
                , clsidMinorIn
                , ulMinIn
                , ulMaxIn
                , ulCurrentIn
                , hrIn
                , bstr
                , NULL
                , NULL
                ) );

Cleanup:

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrResourcePrivateDataExchange
//
//  Description:
//      The two passed in managed resources are a match between the one in
//      the cluster and one on a node.  If they both support the
//      IClusCfgManagedResourceData interface then the private data from
//      the resource in the cluster will be handed to the resource on the
//      node.
//
//  Arguments:
//      pccmriClusterIn
//          The mananged resource in the cluster.
//
//      pccmriNodeIn
//          The managed resource from the node.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//  Remarks:
//      This function will return S_OK unless there is a good reason to stop
//      the caller from continuing.  Just because one, or both, of these
//      objects does not support the IClusCfgManagedResourceData interface
//      is not a good reason to stop.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrResourcePrivateDataExchange(
      IClusCfgManagedResourceInfo * pccmriClusterIn
    , IClusCfgManagedResourceInfo * pccmriNodeIn
    )
{
    TraceFunc( "" );
    Assert( pccmriClusterIn != NULL );
    Assert( pccmriNodeIn != NULL );

    HRESULT                         hr = S_OK;
    HRESULT                         hrClusterQI = S_OK;
    HRESULT                         hrNodeQI = S_OK;
    IClusCfgManagedResourceData *   pccmrdCluster = NULL;
    IClusCfgManagedResourceData *   pccmrdNode = NULL;
    BYTE *                          pbPrivateData = NULL;
    DWORD                           cbPrivateData = 0;

    hrClusterQI = pccmriClusterIn->TypeSafeQI( IClusCfgManagedResourceData, &pccmrdCluster );
    if ( hrClusterQI == E_NOINTERFACE )
    {
        LogMsg( L"[MT] The cluster managed resource has no support for IClusCfgManagedResourceData." );
        goto Cleanup;
    } // if:
    else if ( FAILED( hrClusterQI ) )
    {
        hr = THR( hrClusterQI );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_ClusterResource_QI, hr );
        goto Cleanup;
    } // if:

    hrNodeQI = pccmriNodeIn->TypeSafeQI( IClusCfgManagedResourceData, &pccmrdNode );
    if ( hrNodeQI == E_NOINTERFACE )
    {
        LogMsg( L"[MT] The new node resource has no support for IClusCfgManagedResourceData." );
        goto Cleanup;
    } // if:
    else if ( FAILED( hrNodeQI ) )
    {
        hr = THR( hrNodeQI );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_NodeResource_QI, hr );
        goto Cleanup;
    } // if:

    Assert( ( hrClusterQI == S_OK ) && ( pccmrdCluster != NULL ) );
    Assert( ( hrNodeQI == S_OK ) && ( pccmrdNode != NULL ) );

    cbPrivateData = 512;    // start with a reasonable amout

    pbPrivateData = (BYTE *) TraceAlloc( 0, cbPrivateData );
    if ( pbPrivateData == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_Out_Of_Memory1, hr );
        goto Cleanup;
    } // if:

    hr = pccmrdCluster->GetResourcePrivateData( pbPrivateData, &cbPrivateData );
    if ( hr == HR_RPC_INSUFFICIENT_BUFFER )
    {
        TraceFree( pbPrivateData );
        pbPrivateData = NULL;

        pbPrivateData = (BYTE *) TraceAlloc( 0, cbPrivateData );
        if ( pbPrivateData == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_Out_Of_Memory2, hr );
            goto Cleanup;
        } // if:

        hr = pccmrdCluster->GetResourcePrivateData( pbPrivateData, &cbPrivateData );
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( pccmrdNode->SetResourcePrivateData( pbPrivateData, cbPrivateData ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_SetResourcePrivateData, hr );
            goto Cleanup;
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // else if:
    else
    {
        THR( hr );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrResourcePrivateDataExchange_GetResourcePrivateData, hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( pccmrdCluster != NULL )
    {
        pccmrdCluster->Release();
    } // if:

    if ( pccmrdNode != NULL )
    {
        pccmrdNode->Release();
    } // if:

    TraceFree( pbPrivateData );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrResourcePrivateDataExchange


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckQuorumCapabilities
//
//  Description:
//      Call through the CManagedResource proxy object to the server side
//      object and ensure that it can indeed host the quorum resource.
//
//  Arguments:
//      pccmriNodeResourceIn
//          The managed resource from the node.
//
//      cookieNodeIn
//          The cookie for the node that the passed in resource belongs to.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//  Remarks:
//      This function will return S_OK unless there is a good reason to stop
//      the caller from continuing.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckQuorumCapabilities(
      IClusCfgManagedResourceInfo * pccmriNodeResourceIn
    , OBJECTCOOKIE                  cookieNodeIn
    )
{
    TraceFunc( "" );
    Assert( pccmriNodeResourceIn != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  piccvq = NULL;
    IClusCfgNodeInfo *      pcni = NULL;

    //
    //  Get a node info object for the passed in node cookie.
    //

    hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNodeIn, reinterpret_cast< IUnknown ** >( &pcni ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( pcni != NULL );

    //
    //  If this node is already a member of the cluster, or an error occurs,
    //   then we should not call PrepareToHostQuorum() on that node.
    //

    hr = STHR( pcni->IsMemberOfCluster() );
    if ( hr != S_FALSE )
    {
        BSTR    bstr = NULL;

        THR( pcni->GetName( &bstr ) );

        if ( hr == S_OK )
        {
            LogMsg( L"[MT] Skipping quorum capabilities check for node \"%ws\" because the node is already clustered.", bstr != NULL ? bstr : L"<unknown>" );
        } // if:
        else
        {
            LogMsg( L"[MT] Skipping quorum capabilities check for node \"%ws\". (hr = %#08x)", bstr != NULL ? bstr : L"<unknown>", hr );
        } // else:

        SysFreeString( bstr );  // do not make TraceSysFreeString because it hasn't been tracked!!
        goto Cleanup;
    } // if:

    hr = pccmriNodeResourceIn->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq );
    if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
        goto Cleanup;
    } // if:
    else if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckQuorumCapabilities_QI, hr );
        goto Cleanup;
    } // else if:

    Assert( (hr == S_OK ) && ( piccvq != NULL ) );

    hr = THR( HrAddResurceToCleanupList( piccvq ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckQuorumCapabilities_HrAddResurceToCleanupList, hr );
        goto Cleanup;
    } // if:

    hr = STHR( piccvq->PrepareToHostQuorumResource() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckQuorumCapabilities_PrepareToHostQuorumResource, hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( pcni != NULL )
    {
        pcni->Release();
    } // if:

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckQuorumCapabilities


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCleanupTask
//
//  Description:
//      Call through the CManagedResource proxy objects to the server side
//      objects and give them a chance to cleanup anything they might need
//      to.
//
//  Arguments:
//      hrCompletionStatusIn
//          The completion status of this task.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCleanupTask(
    HRESULT hrCompletionStatusIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    ULONG                   idx;
    EClusCfgCleanupReason   ecccr = crSUCCESS;

    //
    //  Figure out what the cleanup reason should be.
    //

    if ( hrCompletionStatusIn == E_ABORT )
    {
        ecccr = crCANCELLED;
    } // if:
    else if ( FAILED( hrCompletionStatusIn ) )
    {
        ecccr = crERROR;
    } // else if:

    for ( idx = 0; idx < m_idxQuorumToCleanupNext; idx++ )
    {
        hr = STHR( ((*m_prgQuorumsToCleanup)[ idx ])->Cleanup( ecccr ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCleanupTask_Cleanup, hr );
        } // if:
    } // for:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCleanupTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrAddResurceToCleanupList
//
//  Description:
//      Add the passed in object to the side list of objects that need
//      to be called for cleanup when the task exits.
//
//  Arguments:
//      piccvqIn
//          The object to add to the list.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrAddResurceToCleanupList(
    IClusCfgVerifyQuorum * piccvqIn
    )
{
    TraceFunc( "" );
    Assert( piccvqIn != NULL );

    HRESULT                 hr = S_OK;
    IClusCfgVerifyQuorum *  ((*prgTemp)[]) = NULL;

    prgTemp = (IClusCfgVerifyQuorum *((*)[])) TraceReAlloc(
                                              m_prgQuorumsToCleanup
                                            , sizeof( IClusCfgVerifyQuorum * ) * ( m_idxQuorumToCleanupNext + 1 )
                                            , HEAP_ZERO_MEMORY
                                            );
    if ( prgTemp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResurceToCleanupList_Memory, hr );
        goto Cleanup;
    } // if:

    m_prgQuorumsToCleanup = prgTemp;

    (*m_prgQuorumsToCleanup)[ m_idxQuorumToCleanupNext++ ] = piccvqIn;
    piccvqIn->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrAddResurceToCleanupList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrCheckPlatformInteroperability
//
//  Description:
//      Check each node's platform specs, processor architecture against
//      the cluster's plaform specs.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrCheckPlatformInteroperability( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    DWORD               cookieClusterNode;
    DWORD               cookieNode;
    IEnumCookies *      pecNodes = NULL;
    IUnknown *          punk = NULL;
    IClusCfgNodeInfo *  piccni = NULL;
    WORD                wClusterProcArch;
    WORD                wNodeProcArch;
    WORD                wClusterProcLevel;
    WORD                wNodeProcLevel;
    BSTR                bstrNodeName = NULL;
    ULONG               celtDummy;
    BSTR                bstrDescription = NULL;
    BSTR                bstrReference = NULL;

    hr = THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Check_processor_Architecture
                    , 0
                    , 1
                    , 0
                    , hr
                    , IDS_TASKID_MINOR_CHECK_PROCESSOR_ARCHITECTURE
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get a node that is already in the cluster.
    //

    hr = THR( HrGetAClusterNodeCookie( &pecNodes, &cookieClusterNode ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the node information.
    //

    hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieClusterNode, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_QI, hr );
        goto Cleanup;
    } // if:

    piccni = TraceInterface( L"CTaskAnalyzeClusterBase!HrCheckPlatformInteroperability", IClusCfgNodeInfo, piccni, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Now get that node's processor architecture values.
    //

    hr = THR( piccni->GetProcessorInfo( &wClusterProcArch, &wClusterProcLevel ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_Get_Proc_info, hr );
        goto Cleanup;
    } // if:

    //
    //  Cleanup since we now have the processor info for the cluster.
    //

    piccni->Release();
    piccni = NULL;

    hr = THR( pecNodes->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_Enum_Reset, hr );
        goto Cleanup;
    } // if:

    //
    //  Loop thru the rest of the nodes comparing the resources.
    //

    for ( ; m_fStop == FALSE; )
    {
        //
        //  Cleanup
        //

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        if ( piccni != NULL )
        {
            piccni->Release();
            piccni = NULL;
        } // if:

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_Enum_Nodes_Next, hr );
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break;  // exit condition
        } // if:

        //
        //  Skip the selected cluster node since we already have its
        //  configuration.
        //
        if ( cookieClusterNode == cookieNode )
        {
            continue;
        } // if:

        //
        //  Retrieve the node's name for error messages.
        //

        hr = THR( HrRetrieveCookiesName( m_pom, cookieNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Retrieve the node information.
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_1, hr );
            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_NodeInfo_FindObject_QI_1, hr );
            goto Cleanup;
        } // if:

        piccni = TraceInterface( L"CTaskAnalyzeClusterBase!HrCheckPlatformInteroperability", IClusCfgNodeInfo, piccni, 1 );

        punk->Release();
        punk = NULL;

        hr = THR( piccni->GetProcessorInfo( &wNodeProcArch, &wNodeProcLevel ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckPlatformInteroperability_Get_Proc_info_1, hr );
            goto Cleanup;
        } // if:

        //
        //  If either the processor architecture is not the same between the node and the cluster
        //  then inform the user and fail.
        //

        if ( wClusterProcArch != wNodeProcArch )
        {
            THR( HrFormatStringIntoBSTR(
                      g_hInstance
                    , IDS_TASKID_MINOR_PROCESSOR_ARCHITECTURE_MISMATCH
                    , &bstrDescription
                    , bstrNodeName
                    ) );

            THR( HrFormatProcessorArchitectureRef( wClusterProcArch, wNodeProcArch, bstrNodeName, &bstrReference ) );

            hr = HRESULT_FROM_WIN32( TW32( ERROR_NODE_CANNOT_BE_CLUSTERED ) );

            THR( SendStatusReport(
                          m_bstrClusterName
                        , TASKID_Minor_Check_processor_Architecture
                        , TASKID_Minor_Processor_Architecture_Mismatch
                        , 1
                        , 1
                        , 1
                        , hr
                        , bstrDescription != NULL ? bstrDescription : L"A node was found that was not the same processor architecture as the cluster."
                        , NULL
                        , bstrReference
                        ) );

            goto Cleanup;
        } // if:
    } // for:

Cleanup:

    THR( HrSendStatusReport(
              m_bstrClusterName
            , TASKID_Major_Check_Cluster_Feasibility
            , TASKID_Minor_Check_processor_Architecture
            , 0
            , 1
            , 1
            , hr
            , IDS_TASKID_MINOR_CHECK_PROCESSOR_ARCHITECTURE
            ) );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    } // if :

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrCheckPlatformInteroperability


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrGetAClusterNodeCookie
//
//  Description:
//      Check each node's platform specs, processor architecture against
//      the cluster's plaform specs.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrGetAClusterNodeCookie(
      IEnumCookies ** ppecNodesOut
    , DWORD *         pdwClusterNodeCookieOut
    )
{
    TraceFunc( "" );
    Assert( ppecNodesOut != NULL );
    Assert( pdwClusterNodeCookieOut != NULL );

    HRESULT             hr = S_OK;
    DWORD               cookieDummy;
    DWORD               cookieClusterNode;
    ULONG               celtDummy;
    IUnknown *          punk = NULL;
    IClusCfgNodeInfo *  pccni = NULL;

    //
    //  Get the node cookie enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GetAClusterNodeCookie_Find_Object, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, ppecNodesOut ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GetAClusterNodeCookie_Find_Object_QI, hr );
        goto Cleanup;
    }

    *ppecNodesOut = TraceInterface( L"CTaskAnalyzeClusterBase!IEnumCookies", IEnumCookies, *ppecNodesOut, 1 );

    punk->Release();
    punk = NULL;

    //
    //  If creating a cluster, it doesn't matter who we pick to prime the cluster configuration
    //

    if ( m_fJoiningMode == FALSE )
    {
        //
        //  The first guy thru, we just copy his resources under the cluster
        //  configuration.
        //

        hr = THR( (*ppecNodesOut)->Next( 1, &cookieClusterNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GetAClusterNodeCookie_Next, hr );
            goto Cleanup;
        }
    } // if: not adding
    else
    {
        //
        //  We are adding nodes to the cluster.  Find a node that is ta member
        //  of the cluster and use it to prime the new configuration.
        //

        for ( ;; )
        {
            //
            //  Cleanup
            //
            if ( pccni != NULL )
            {
                pccni->Release();
                pccni = NULL;
            }

            hr = STHR( (*ppecNodesOut)->Next( 1, &cookieClusterNode, &celtDummy ) );
            if ( hr == S_FALSE )
            {
                //
                //  We shouldn't make it here.  There should be at least one node
                //  in the cluster that we are adding.
                //

                hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GetAClusterNodeCookie_Find_Formed_Node_Next, hr );
                goto Cleanup;
            }

            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GetAClusterNodeCookie_Find_Formed_Node_Next1, hr );
                goto Cleanup;
            }

            //
            //  Retrieve the node information.
            //

            hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieClusterNode, &punk ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject_QI, hr );
                goto Cleanup;
            }

            pccni = TraceInterface( L"CTaskAnalyzeClusterBase!IClusCfgNodeInfo", IClusCfgNodeInfo, pccni, 1 );

            punk->Release();
            punk = NULL;

            hr = STHR( pccni->IsMemberOfCluster() );
            if ( hr == S_OK )
            {
                break;  // exit condition
            }
        } // for: ever
    } // else:  adding

    *pdwClusterNodeCookieOut = cookieClusterNode;
    hr = S_OK;

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrGetAClusterNodeCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrFormatProcessorArchitectureRef(
//
//  Description:
//      Format a reference string with the processor architecture types in
//      it.
//
//  Arguments:
//      wClusterProcArchIn
//      wNodeProcArchIn
//      pcszNodeNameIn
//      pbstrReferenceOut
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrFormatProcessorArchitectureRef(
      WORD      wClusterProcArchIn
    , WORD      wNodeProcArchIn
    , LPCWSTR   pcszNodeNameIn
    , BSTR *    pbstrReferenceOut
    )
{
    TraceFunc( "" );
    Assert( pcszNodeNameIn != NULL );
    Assert( pbstrReferenceOut != NULL );

    HRESULT hr = S_OK;
    BSTR    bstrClusterArch = NULL;
    BSTR    bstrNodeArch = NULL;

    hr = THR( HrGetProcessorArchitectureString( wClusterProcArchIn, &bstrClusterArch ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetProcessorArchitectureString( wNodeProcArchIn, &bstrNodeArch ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrFormatStringIntoBSTR(
                  g_hInstance
                , IDS_TASKID_MINOR_PROCESSOR_ARCHITECTURE_MISMATCH_REF
                , pbstrReferenceOut
                , bstrClusterArch
                , bstrNodeArch
                , pcszNodeNameIn
                ) );

Cleanup:

    TraceSysFreeString( bstrClusterArch );
    TraceSysFreeString( bstrNodeArch );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrFormatProcessorArchitectureRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterBase::HrGetProcessorArchitectureString
//
//  Description:
//      Get the description string for the passed in architecture.
//      it.
//
//  Arguments:
//      wProcessorArchitectureIn
//
//      pbstrProcessorArchitectureOut
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterBase::HrGetProcessorArchitectureString(
      WORD      wProcessorArchitectureIn
    , BSTR *    pbstrProcessorArchitectureOut
    )
{
    TraceFunc( "" );
    Assert( pbstrProcessorArchitectureOut != NULL );

    HRESULT hr = S_OK;
    int     id;

    switch ( wProcessorArchitectureIn )
    {
        case PROCESSOR_ARCHITECTURE_INTEL :
            id = IDS_PROCESSOR_ARCHITECTURE_INTEL;
            break;

        case PROCESSOR_ARCHITECTURE_IA64 :
            id = IDS_PROCESSOR_ARCHITECTURE_IA64;
            break;

        case PROCESSOR_ARCHITECTURE_AMD64 :
            id = IDS_PROCESSOR_ARCHITECTURE_AMD64;
            break;

        case PROCESSOR_ARCHITECTURE_UNKNOWN :
        default:
            id = IDS_PROCESSOR_ARCHITECTURE_UNKNOWN;
            break;

    } // switch:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, id, pbstrProcessorArchitectureOut ) );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterBase::HrGetProcessorArchitectureString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzeclusterminconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeClusterMinConfig.cpp
//
//  Description:
//      CTaskAnalyzeClusterMinConfig implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "TaskAnalyzeClusterMinConfig.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
DEFINE_THISCLASS( "CTaskAnalyzeClusterMinConfig" )


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterMinConfig class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::S_HrCreateInstance
//
//  Description:
//      Create a CTaskAnalyzeClusterMinConfig instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULT as failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_OK;
    CTaskAnalyzeClusterMinConfig *   ptac = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ptac = new CTaskAnalyzeClusterMinConfig;
    if ( ptac == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ptac->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( ptac->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( ptac != NULL )
    {
        ptac->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::CTaskAnalyzeClusterMinConfig
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeClusterMinConfig::CTaskAnalyzeClusterMinConfig( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CTaskAnalyzeClusterMinConfig::CTaskAnalyzeClusterMinConfig


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::CTaskAnalyzeClusterMinConfig
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeClusterMinConfig::~CTaskAnalyzeClusterMinConfig( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CTaskAnalyzeClusterMinConfig::~CTaskAnalyzeClusterMinConfig


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterMinConfig - IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskAnalyzeCluster * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskAnalyzeCluster ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskAnalyzeCluster, this, 0 );
    } // else if: ITaskAnalyzeClusterMinConfig
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskAnalyzeClusterMinConfig::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeClusterMinConfig::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    ULONG   c = UlAddRef();

    CRETURN( c );

} //*** CTaskAnalyzeClusterMinConfig::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeClusterMinConfig::Release( void )
{
    TraceFunc( "[IUnknown]" );

    ULONG   c = UlRelease();

    CRETURN( c );

} //*** CTaskAnalyzeClusterMinConfig::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterMinConfig - IDoTask/ITaskAnalyzeCluster interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::BeginTask
//
//  Description:
//      Task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = THR( HrBeginTask() );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::BeginTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::StopTask
//
//  Description:
//      Stop task entry point.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = THR( HrStopTask() );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::StopTask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::SetJoiningMode
//
//  Description:
//      Tell this task whether we are joining nodes to the cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::SetJoiningMode( void )
{
    TraceFunc( "[ITaskAnalyzeClusterMinConfig]" );

    HRESULT hr = THR( HrSetJoiningMode() );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::SetJoiningMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::SetCookie
//
//  Description:
//      Receive the completion cookier from the task creator.
//
//  Arguments:
//      cookieIn
//          The completion cookie to send back to the creator when this
//          task is complete.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskAnalyzeClusterMinConfig]" );

    HRESULT hr = THR( HrSetCookie( cookieIn ) );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::SetCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::SetClusterCookie
//
//  Description:
//      Receive the object manager cookie of the cluster that we are going
//      to analyze.
//
//  Arguments:
//      cookieClusterIn
//          The cookie for the cluster to work on.
//
//  Return Value:
//      S_OK
//          Success
//
//      HRESULT failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeClusterMinConfig::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskAnalyzeClusterMinConfig]" );

    HRESULT hr = THR( HrSetClusterCookie( cookieClusterIn ) );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::SetClusterCookie


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CTaskAnalyzeClusterMinConfig - Protected methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster
//
//  Description:
//      Create a new resource in the cluster configuration since there was
//      not a match to the resource already in the cluster.
//
//  Arguments:
//      pccmriIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster(
      IClusCfgManagedResourceInfo * pccmriIn
    , BSTR                          bstrNodeResNameIn
    , BSTR *                        pbstrNodeResUIDInout
    , BSTR                          bstrNodeNameIn
    )
{
    TraceFunc( "" );
    Assert( pccmriIn != NULL );
    Assert( pbstrNodeResUIDInout != NULL );

    HRESULT hr = S_OK;

    LogMsg(
          L"[MT] Not creating an object for resource '%ws' ('%ws') from node '%ws' in the cluster configuration because minimal analysis and configuration was selected."
        , bstrNodeResNameIn
        , *pbstrNodeResUIDInout
        , bstrNodeNameIn
        );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster
//
//  Description:
//      Create a new resource in the cluster configuration since there was
//      not a match to the resource already in the cluster.  This method
//      is called when creating a new cluster and we need to get the
//      resources in the cluster.  They are just not managed when doing
//      a min config.
//
//  Arguments:
//          The source object.
//
//      ppccmriOut
//          The new object that was created.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster(
      IClusCfgManagedResourceInfo *     pccmriIn
    , IClusCfgManagedResourceInfo **    ppccmriOut
    )
{
    TraceFunc( "" );
    Assert( pccmriIn != NULL );
    Assert( ppccmriOut != NULL );

    HRESULT hr = S_OK;

    //
    //  Need to create a new object.
    //

    hr = THR( HrCreateNewManagedResourceInClusterConfiguration( pccmriIn, ppccmriOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::HrCompareDriveLetterMappings
//
//  Description:
//      Convert the passed in error HRESULT into a success code HRESULT that
//      has the same error code in the LOWORD.  This task does not want to
//      stop on all errors.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::HrCompareDriveLetterMappings( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( HrSendStatusReport(
                      CTaskAnalyzeClusterBase::m_bstrClusterName
                    , TASKID_Major_Check_Cluster_Feasibility
                    , TASKID_Minor_Check_DriveLetter_Mappings
                    , 0
                    , 1
                    , 1
                    , S_FALSE
                    , IDS_TASKID_MINOR_CHECK_DRIVELETTER_MAPPINGS_MIN_CONFIG
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::SetClusterCookie


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::HrFixupErrorCode
//
//  Description:
//      Convert the passed in error HRESULT into a success code HRESULT that
//      has the same error code in the LOWORD.  This task does not want to
//      stop on all errors.
//
//  Arguments:
//      hrIn
//          The error code to fix up.
//
//  Return Value:
//      The passed in error code.
//
//  Notes:
//      hr =  MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_QUORUM_DISK_NOT_FOUND );
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::HrFixupErrorCode(
    HRESULT hrIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = MAKE_HRESULT( SEVERITY_SUCCESS, SCODE_FACILITY( hrIn ), SCODE_CODE( hrIn ) );

    HRETURN( hr );

} //*** CTaskAnalyzeClusterMinConfig::HrCreateNewResourceInCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::GetNodeCannotVerifyQuorumStringRefId
//
//  Description:
//      Return the correct string ids for the message that is displayed
//      to the user when there isn't a quorum resource.
//
//  Arguments:
//      pdwRefIdOut
//          The reference text to show the user.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskAnalyzeClusterMinConfig::GetNodeCannotVerifyQuorumStringRefId(
    DWORD *   pdwRefIdOut
    )
{
    TraceFunc( "" );
    Assert( pdwRefIdOut != NULL );

    *pdwRefIdOut = IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM_MIN_CONFIG_REF;

    TraceFuncExit();

} //*** CTaskAnalyzeClusterMinConfig::GetNodeCannotVerifyQuorumStringRefId


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::GetNoCommonQuorumToAllNodesStringIds
//
//  Description:
//      Return the correct string ids for the message that is displayed
//      to the user when there isn't a common to all nodes quorum resource.
//
//  Arguments:
//      pdwMessageIdOut
//          The message to show the user.
//
//      pdwRefIdOut
//          The reference text to show the user.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskAnalyzeClusterMinConfig::GetNoCommonQuorumToAllNodesStringIds(
      DWORD *   pdwMessageIdOut
    , DWORD *   pdwRefIdOut
    )
{
    TraceFunc( "" );
    Assert( pdwMessageIdOut != NULL );
    Assert( pdwRefIdOut != NULL );

    *pdwMessageIdOut = IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_WARN;
    *pdwRefIdOut = IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE_WARN_REF;

    TraceFuncExit();

} //*** CTaskAnalyzeClusterMinConfig::GetNoCommonQuorumToAllNodesStringIds


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskAnalyzeClusterMinConfig::HrShowLocalQuorumWarning
//
//  Description:
//      Send the warning about forcing local quorum to the UI.  For min config
//      we don't want to send any message...
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The SSR was done properly.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeClusterMinConfig::HrShowLocalQuorumWarning( void )
{
    TraceFunc( "" );

    HRETURN( S_OK );

} //*** CTaskAnalyzeClusterMinConfig::HrShowLocalQuorumWarning
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcommitclusterchanges.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      TaskCommitClusterChanges.h
//
//  Description:
//      CTaskCommitClusterChanges implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "TaskTracking.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskCommitClusterChanges
//
//  Description:
//      This is the base class for the task that commits the user's
//      configuration changes to the cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskCommitClusterChanges
    : public ITaskCommitClusterChanges
    , public INotifyUI
    , public IClusCfgCallback
    , public CTaskTracking
{
private:
    // IUnknown
    LONG                    m_cRef;

    // ITaskCommitClusterChanges
    BOOL                    m_fJoining;                 // If we are attempting to join...
    OBJECTCOOKIE            m_cookie;                   // Task completion cookie
    IClusCfgCallback *      m_pcccb;                    // Marshalled callback interface
    OBJECTCOOKIE *          m_pcookies;                 // Completion cookies for the subtasks.
    ULONG                   m_cNodes;                   // Count of nodes/subtasks that need to signal completion.
    HANDLE                  m_event;                    // Synchronization event to signal when subtasks have completed.
    OBJECTCOOKIE            m_cookieCluster;            // Cookie of the cluster to commit changes

    OBJECTCOOKIE            m_cookieFormingNode;        // Cookie of the forming node.
    IUnknown *              m_punkFormingNode;          // The node to form the cluster.
    BSTR                    m_bstrClusterName;          // The cluster to form
    BSTR                    m_bstrClusterBindingString; // The cluster to form
    IClusCfgCredentials *   m_pccc;                     // The cluster service account credentials.
    ULONG                   m_ulIPAddress;              // IP address of the new cluster.
    ULONG                   m_ulSubnetMask;             // IP subnet mask of the new cluster.
    BSTR                    m_bstrNetworkUID;           // UID of the network the IP should be advertized.
    BSTR                    m_bstrNodeName;             // Node name used be SendStatusReport.
    BOOL                    m_fStop;                    // Should this task stop?

    IEnumCookies *          m_pen;                      // Nodes to form/join

    INotifyUI *             m_pnui;
    IObjectManager *        m_pom;
    ITaskManager *          m_ptm;
    IConnectionManager *    m_pcm;

    // INotifyUI
    ULONG                   m_cSubTasksDone;        // The number of subtasks done.
    HRESULT                 m_hrStatus;             // Status of callbacks

    CTaskCommitClusterChanges( void );
    ~CTaskCommitClusterChanges( void );

    // Private copy constructor to prevent copying.
    CTaskCommitClusterChanges( const CTaskCommitClusterChanges & );

    // Private assignment operator to prevent copying.
    CTaskCommitClusterChanges & operator = ( const CTaskCommitClusterChanges & );

    STDMETHOD( HrInit )( void );

    HRESULT HrCompareAndPushInformationToNodes( void );
    HRESULT HrGatherClusterInformation( void );
    HRESULT HrFormFirstNode( void );
    HRESULT HrAddJoiningNodes( void );
    HRESULT HrAddAJoiningNode( BSTR bstrNameIn, OBJECTCOOKIE cookieIn );
    HRESULT HrSendStatusReport( LPCWSTR pcszNodeNameIn, CLSID clsidMajorIn, CLSID clsidMinorIn, ULONG ulMinIn, ULONG ulMaxIn, ULONG ulCurrentIn, HRESULT hrIn, int nDescriptionIdIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskCommitClusterChanges
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );
    STDMETHOD( SetJoining )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; //*** class CTaskCommitClusterChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzeclusterminconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeClusterMinConfig.h
//
//  Description:
//      CTaskAnalyzeClusterMinConfig declaration.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 01-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "TaskAnalyzeClusterBase.h"
#include "TaskTracking.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskAnalyzeClusterMinConfig
//
//  Description:
//      The class CTaskAnalyzeClusterMinConfig is the implementation of the
//      ITaskAnalyzeCluster interface that does minimal analysis and
//      configuration.  This task is launched from the client when the user
//      has chosen the minimal configuration option.
//
//  Interfaces:
//      ITaskAnalyzeCluster
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskAnalyzeClusterMinConfig
    : public ITaskAnalyzeCluster
    , public CTaskAnalyzeClusterBase
{
private:

    CTaskAnalyzeClusterMinConfig( void );
    ~CTaskAnalyzeClusterMinConfig( void );

    // Private copy constructor to prevent copying.
    CTaskAnalyzeClusterMinConfig( const CTaskAnalyzeClusterMinConfig & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskAnalyzeClusterMinConfig & operator = ( const CTaskAnalyzeClusterMinConfig & nodeSrc );

protected:

    //
    // Overridden functions.
    //

    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo * pccmriIn
                        , BSTR                          bstrNodeResNameIn
                        , BSTR *                        pbstrNodeResUIDInout
                        , BSTR                          bstrNodeNameIn
                        );
    virtual HRESULT HrCreateNewResourceInCluster(
                          IClusCfgManagedResourceInfo *     pccmriIn
                        , IClusCfgManagedResourceInfo **    ppccmriOut
                        );
    virtual HRESULT HrCompareDriveLetterMappings( void );
    virtual HRESULT HrFixupErrorCode( HRESULT hrIn );
    virtual BOOL    BMinimalConfiguration( void ) { return TRUE; };
    virtual void    GetNodeCannotVerifyQuorumStringRefId( DWORD * pdwRefIdOut );
    virtual void    GetNoCommonQuorumToAllNodesStringIds( DWORD * pdwMessageIdOut, DWORD *   pdwRefIdOut );
    virtual HRESULT HrShowLocalQuorumWarning( void );

public:

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    //  IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //
    //  IDoTask / ITaskAnalyzeClusterMinConfig
    //

    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetJoiningMode )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );

}; //*** class CTaskAnalyzeClusterMinConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcommitclusterchanges.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskCommitClusterChanges.cpp
//
//  Description:
//      CTaskCommitClusterChanges implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskCommitClusterChanges.h"

DEFINE_THISCLASS("CTaskCommitClusterChanges")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CTaskCommitClusterChanges * ptccc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptccc = new CTaskCommitClusterChanges;
    if ( ptccc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptccc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptccc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ptccc != NULL )
    {
        ptccc->Release();
    }

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCommitClusterChanges::CTaskCommitClusterChanges
//
//////////////////////////////////////////////////////////////////////////////
CTaskCommitClusterChanges::CTaskCommitClusterChanges( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskCommitClusterChanges::CTaskCommitClusterChanges

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCommitClusterChanges::HrInit
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskCommitClusterChanges
    Assert( m_cookie == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_pcookies == NULL );
    Assert( m_cNodes == 0 );
    Assert( m_event == NULL );
    Assert( m_cookieCluster == NULL );

    Assert( m_cookieFormingNode == NULL );
    Assert( m_punkFormingNode == NULL );
    Assert( m_bstrClusterName == NULL );
    Assert( m_bstrClusterBindingString == NULL );
    Assert( m_pccc == NULL );
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_bstrNetworkUID == 0 );
    Assert( m_fStop == FALSE );

    Assert( m_pen == NULL );

    Assert( m_pnui == NULL );
    Assert( m_pom == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pcm == NULL );

    // INotifyUI
    Assert( m_cNodes == 0 );
    Assert( m_hrStatus == S_OK );

    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ClusCfgCredentials
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IClusCfgCredentials
                    , reinterpret_cast< void ** >( &m_pccc )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestFitIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCommitClusterChanges::~CTaskCommitClusterChanges
//
//////////////////////////////////////////////////////////////////////////////
CTaskCommitClusterChanges::~CTaskCommitClusterChanges( void )
{
    TraceFunc( "" );

    // m_cRef

    // m_cookie

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pcookies != NULL )
    {
        TraceFree( m_pcookies );
    }

    // m_cNodes

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    // m_cookieCluster

    // m_cookieFormingNode

    if ( m_punkFormingNode != NULL )
    {
        m_punkFormingNode->Release();
    }

    TraceSysFreeString( m_bstrClusterName );
    TraceSysFreeString( m_bstrClusterBindingString );

    // m_ulIPAddress

    // m_ulSubnetMask

    TraceSysFreeString( m_bstrNetworkUID );
    TraceSysFreeString( m_bstrNodeName );

    if ( m_pen != NULL )
    {
        m_pen->Release();
    }

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    }

    if ( m_pnui != NULL )
    {
        m_pnui->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }

    if ( m_pcm != NULL )
    {
        m_pcm->Release();
    }

    // m_cSubTasksDone

    // m_hrStatus

    // m_lLockCallback

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskCommitClusterChanges::~CTaskCommitClusterChanges


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCommitClusterChanges::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskCommitClusterChanges * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskCommitClusterChanges ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskCommitClusterChanges, this, 0 );
    } // else if: ITaskCommitClusterChanges
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskCommitClusterChanges::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCommitClusterChanges::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCommitClusterChanges::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskCommitClusterChanges::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCommitClusterChanges::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCommitClusterChanges::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskCommitClusterChanges::Release


// ************************************************************************
//
// IDoTask / ITaskCommitClusterChanges
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::BeginTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    IServiceProvider *          psp  = NULL;
    IUnknown *                  punk = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;

    TraceInitializeThread( L"TaskCommitClusterChanges" );

    LogMsg( L"[MT] [CTaskCommitClusterChanges] Beginning task..." );

    //
    //  Gather the managers we need to complete the task.
    //
    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pcpc = TraceInterface( L"CTaskCommitClusterChanges!IConnectionPointContainer", IConnectionPointContainer, pcpc, 1 );

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskCommitClusterChanges!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &m_pnui ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

//    TraceMoveFromMemoryList( m_pnui, g_GlobalMemoryList );

    m_pnui = TraceInterface( L"CTaskCommitClusterChanges!INotifyUI", INotifyUI, m_pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &m_ptm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &m_pcm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Release the service manager.
    //
    psp->Release();
    psp = NULL;

    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumCookies,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( m_pen == NULL );
    hr = THR( punk->TypeSafeQI( IEnumCookies, &m_pen ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Compare and push information to the nodes.
    //

    hr = THR( HrCompareAndPushInformationToNodes() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Gather information about the cluster we are to form/join.
    //

    hr = THR( HrGatherClusterInformation() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Check to see if we need to "form" a cluster first.
    //

    if ( m_punkFormingNode != NULL )
    {
        hr = THR( HrFormFirstNode() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // if: m_punkFormingNode

    //
    //  Join the additional nodes.
    //

    hr = THR( HrAddJoiningNodes() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( m_cookie != 0 )
    {
        if ( m_pom != NULL )
        {
            HRESULT hr2;
            IUnknown * punkTemp = NULL;

            hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                         m_cookie,
                                         &punkTemp
                                         ) );
            if ( SUCCEEDED( hr2 ) )
            {
                IStandardInfo * psi;

                hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psi ) );
                punkTemp->Release();
                punkTemp = NULL;

                if ( SUCCEEDED( hr2 ) )
                {
                    hr2 = THR( psi->SetStatus( hr ) );
                    psi->Release();
                }
            } // if: ( SUCCEEDED( hr2 ) )
        } // if: ( m_pom != NULL )
        if ( m_pnui != NULL )
        {
            //  Signal that the task completed.
            THR( m_pnui->ObjectChanged( m_cookie ) );
        }
    } // if: ( m_cookie != 0 )
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    LogMsg( L"[MT] [CTaskCommitClusterChanges] Exiting task.  The task was%ws cancelled. (hr = %#08x)", m_fStop == FALSE ? L" not" : L"", hr );

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::StopTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskCommitClusterChanges] Calling StopTask() on all remaining sub-tasks." );

    THR( HrNotifyAllTasksToStop() );

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::SetCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetClusterCookie(
//      OBJECTCOOKIE    cookieClusterIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_cookieCluster = cookieClusterIn;

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::SetClusterCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetJoining
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetJoining( void )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_fJoining = TRUE;

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::SetJoining


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                                  pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName
                                , clsidTaskMajorIn
                                , clsidTaskMinorIn
                                , ulMinIn
                                , ulMaxIn
                                , ulCurrentIn
                                , hrStatusIn
                                , pcszDescriptionIn
                                , pftTimeIn
                                , pcszReferenceIn
                                ) );

    if ( m_fStop == TRUE )
    {
        hr = E_ABORT;
    } // if:

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::SendStatusReport


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    BOOL    fSuccess;
    ULONG   idx;

    HRESULT hr = S_OK;

    LogMsg( L"[TaskCommitClusterChanges] Looking for the completion cookie %u.", cookieIn );

    for ( idx = 0; idx < m_cNodes; idx ++ )
    {
        if ( cookieIn == m_pcookies[ idx ] )
        {
            LogMsg( L"[TaskCommitClusterChanges] Clearing completion cookie %u at array index %u", cookieIn, idx );

            // don't care if this fails, but it really shouldn't
            THR( HrRemoveTaskFromTrackingList( cookieIn ) );

            //
            //  Make sure it won't be signalled twice.
            //
            m_pcookies[ idx ] = NULL;

            InterlockedIncrement( reinterpret_cast< long * >( &m_cSubTasksDone ) );

            if ( m_cSubTasksDone == m_cNodes )
            {
                //
                //  Signal the event if all the nodes are done.
                //
                fSuccess = SetEvent( m_event );
                if ( ! fSuccess )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    goto Cleanup;
                } // if:
            } // if: all done

            break;
        } // if: matched cookie
    } // for: each cookie in the list

    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::ObjectChanged


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrCompareAndPushInformationToNodes
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrCompareAndPushInformationToNodes( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    DWORD               dwCookie = 0;
    DWORD               sc;
    ULONG               cNodes;
    ULONG               celtDummy;
    OBJECTCOOKIE        cookieNode;
    OBJECTCOOKIE *      pcookies = NULL;
    BOOL                fDeterminedForming = FALSE;
    BSTR                bstrNodeName           = NULL;
    BSTR                bstrNotification   = NULL;
    IUnknown *          punk = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    IConnectionPoint *  pcp = NULL;
    IStandardInfo *     psi = NULL;

    ITaskCompareAndPushInformation *    ptcapi = NULL;

    //
    //  Tell the UI layer that we are starting to connect to the nodes.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Update_Progress,   // just twiddle the icon
                                TASKID_Major_Reanalyze,
                                1,
                                1,
                                1,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Count the number of nodes.
    //

    hr = THR( m_pen->Count( &m_cNodes ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Create an event to signal when all the "push" tasks have been
    //  completed.
    //
    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_event == NULL )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
        goto Error;
    }

    //
    //  Register with the Notification Manager to get notified.
    //

    hr = THR( m_pnui->TypeSafeQI( IConnectionPoint, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pcp->Advise( static_cast< INotifyUI * >( this ), &dwCookie ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Allocate a buffer to collect cookies
    //

    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  This copy is to find out the status of the subtasks.
    //

    pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( OBJECTCOOKIE ) ) );

    if ( pcookies == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Loop thru the nodes, creating cookies and compare data for that node.
    //
    Assert( hr == S_OK );
    for ( cNodes = 0; ( ( hr == S_OK ) && ( m_fStop == FALSE ) ); cNodes ++ )
    {
        //
        //  Grab the next node.
        //

        hr = STHR( m_pen->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;
        } // if:

        if ( FAILED( hr ) )
        {
            goto Error;
        } // if:

        //
        //  Get the object for this node cookie.
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        //
        //  Get the nodes name. We are using this to distinguish one nodes
        //  completion cookie from another. It might also make debugging
        //  easier (??).
        //

        hr = THR( HrRetrieveCookiesName( m_pom, cookieNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Update the notification in case something goes wrong.
        //

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CONNECTING_TO_NODES, &bstrNotification, bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Create a completion cookie.
        //
        //  KB: These will probably be the same cookie from TaskAnalyzeCluster.
        //

        //  Wrap this because we're just generating a cookie
        hr = THR( m_pom->FindObject( IID_NULL, m_cookieCluster, bstrNodeName, IID_NULL, &m_pcookies[ cNodes ], &punk ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  This copy is for determining the status of the sub-tasks.
        //
        pcookies[ cNodes ] = m_pcookies[ cNodes ];

        //
        //  Figure out if this node is already part of a cluster.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  Figure out the forming node.
        //

        if (    ( m_punkFormingNode == NULL )   // no forming node selected
            &&  ( fDeterminedForming == FALSE ) // no forming node determined
            &&  ( hr == S_FALSE )               // node isn't a member of a cluster
           )
        {
            //
            //  If it isn't a member of a cluster, select it as the forming node.
            //

            Assert( m_punkFormingNode == NULL );
            hr = THR( pccni->TypeSafeQI( IUnknown, &m_punkFormingNode ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  Retrieve the cookie for the forming node.
            //

            //  Wrap this because all Nodes should be in the database by now.
            hr = THR( m_pom->FindObject( CLSID_NodeType,
                                         m_cookieCluster,
                                         bstrNodeName,
                                         IID_NULL,
                                         &m_cookieFormingNode,
                                         &punk  // dummy
                                         ) );
            Assert( punk == NULL );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  Set this flag to once a node has been determined to be the
            //  forming node to keep other nodes from being selected.
            //

            fDeterminedForming = TRUE;

        } // if: forming node not found yet
        else if ( hr == S_OK ) // node is a member of a cluster
        {
            //
            //  Figured out that this node has already formed therefore there
            //  shouldn't be a "forming node." "Unselect" the forming node by
            //  releasing the punk and setting it to NULL.
            //

            if ( m_punkFormingNode != NULL  )
            {
                m_punkFormingNode->Release();
                m_punkFormingNode = NULL;
            }

            //
            //  Set this flag to once a node has been determined to be the
            //  forming node to keep other nodes from being selected.
            //

            fDeterminedForming = TRUE;

        } // else:

        //
        //  Create a task to gather this nodes information.
        //

        hr = THR( m_ptm->CreateTask( TASK_CompareAndPushInformation, &punk ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        hr = THR( punk->TypeSafeQI( ITaskCompareAndPushInformation, &ptcapi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Set the tasks completion cookie.
        //

        LogMsg( L"[TaskCommitClusterChanges] Setting completion cookie %u at array index %u into the compare and push information task for node %ws", m_pcookies[ cNodes ], cNodes, bstrNodeName );
        hr = THR( ptcapi->SetCompletionCookie( m_pcookies[ cNodes ] ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  Tell it what node it is suppose to gather information from.
        //

        hr = THR( ptcapi->SetNodeCookie( cookieNode ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptcapi ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        hr = THR( HrAddTaskToTrackingList( punk, m_pcookies[ cNodes ] ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        ptcapi->Release();
        ptcapi = NULL;
    } // for: looping thru nodes

    Assert( cNodes == m_cNodes );

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Now wait for the work to be done.
    //

    sc = (DWORD) -1;
    Assert( sc != WAIT_OBJECT_0 );
    while ( ( sc != WAIT_OBJECT_0 ) && ( m_fStop == FALSE ) )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             INFINITE,
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

    } // while: sc == WAIT_OBJECT_0

    //
    //  Check the status to make sure everyone was happy, if not abort the task.
    //

    for( cNodes = 0; cNodes < m_cNodes; cNodes ++ )
    {
        HRESULT hrStatus;

        hr = THR( m_pom->GetObject( DFGUID_StandardInfo, pcookies[ cNodes ], &punk ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        punk->Release();
        punk = NULL;
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        hr = THR( psi->GetStatus( &hrStatus ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        if ( hrStatus != S_OK )
        {
            hr = hrStatus;
            goto Cleanup;
        }
    } // for: each node

    hr = S_OK;

Cleanup:

    Assert( punk == NULL );

    if ( pcookies != NULL )
    {
        for ( cNodes = 0; cNodes < m_cNodes; cNodes++ )
        {
            if ( pcookies[ cNodes ] != NULL )
            {
                THR( m_pom->RemoveObject( pcookies[ cNodes ] ) );
            }
        } // for: each node

        TraceFree( pcookies );
    } // if: cookiees were allocated

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrNotification );

    if ( ptcapi != NULL )
    {
        ptcapi->Release();
    }

    if ( pcp != NULL )
    {
        if ( dwCookie != 0 )
        {
            THR( pcp->Unadvise( dwCookie ) );
        }

        pcp->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( HrSendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Reanalyze
                    , TASKID_Minor_Inconsistant_MiddleTier_Database
                    , 0
                    , 1
                    , 1
                    , hr
                    , IDS_TASKID_MINOR_INCONSISTANT_MIDDLETIER_DATABASE
                    ) );
    goto Cleanup;

} //*** CTaskCommitClusterChanges::HrCompareAndPushInformationToNodes


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrGatherClusterInformation
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrGatherClusterInformation( void )
{
    TraceFunc( "" );

    HRESULT hr;

    IUnknown *              punk  = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;

    //
    //  Ask the object manager for the cluster configuration object.
    //

    hr = THR( m_pom->GetObject( DFGUID_ClusterConfigurationInfo, m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Gather common properties.
    //

    hr = THR( pccci->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrClusterName );

    hr = STHR( pccci->GetBindingString( &m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    TraceMemoryAddBSTR( m_bstrClusterBindingString );

    LogMsg( L"[MT] Cluster binding string is {%ws}.", m_bstrClusterBindingString );

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_pccc->AssignFrom( piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->GetSubnetMask( &m_ulSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccni->GetUID( &m_bstrNetworkUID ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    TraceMemoryAddBSTR( m_bstrNetworkUID );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( HrSendStatusReport(
                      m_bstrClusterName
                    , TASKID_Major_Reanalyze
                    , TASKID_Minor_Inconsistant_MiddleTier_Database
                    , 0
                    , 1
                    , 1
                    , hr
                    , IDS_TASKID_MINOR_INCONSISTANT_MIDDLETIER_DATABASE
                    ) );
    goto Cleanup;

} //*** CTaskCommitClusterChanges::HrGatherClusterInformation

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrFormFirstNode
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrFormFirstNode( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    ULONG                       celtDummy;
    BSTR                        bstrNodeName = NULL;
    BSTR                        bstrUID = NULL;
    IUnknown *                  punk  = NULL;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgClusterInfo *       pccci = NULL;
    IClusCfgServer *            pccs  = NULL;
    IEnumClusCfgNetworks *      peccn = NULL;
    IClusCfgNetworkInfo *       pccneti = NULL;

    //
    //  TODO:   gpease  25-MAR-2000
    //          Figure out what additional work to do here.
    //

    //
    //  Get the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_NodeInformation, m_cookieFormingNode, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    hr = THR( pccni->GetName( &bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    TraceMemoryAddBSTR( bstrNodeName );

    pccni->Release();
    pccni = NULL;

    //
    //  Create notification string.
    //

    //
    //  Update the UI layer telling it that we are about to start.
    //

    hr = THR( HrSendStatusReport(
                      bstrNodeName
                    , TASKID_Major_Configure_Cluster_Services
                    , TASKID_Minor_Forming_Node
                    , 0
                    , 2
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_FORMING_NODE
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the Connection Manager for a connection to the node.
    //

    hr = THR( m_pcm->GetConnectionToObject( m_cookieFormingNode, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    punk->Release();
    punk = NULL;

    //
    //  Get the node info interface.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Retrieve the server's Cluster Configuration Object..
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Put the properties into the remoted object.
    //

    hr = THR( pccci->SetName( m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = STHR( pccci->SetBindingString( m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_pccc->AssignTo( piccc ) );
    if( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->SetIPAddress( m_ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pccci->SetSubnetMask( m_ulSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Find the network that matches the UID of network to host the
    //  IP address.
    //

    hr = THR( pccs->GetNetworksEnum( &peccn ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccn->Next( 1, &pccneti, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            //
            //  Somehow, there isn't a network that matches the UID of the
            //  network. How did we get this far?
            //
            hr = THR( E_UNEXPECTED );
            goto Error;
        }
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        hr = THR( pccneti->GetUID( &bstrUID ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        TraceMemoryAddBSTR( bstrUID );

        if ( NBSTRCompareCase( bstrUID, m_bstrNetworkUID ) == 0 )
        {
            //
            //  Found the network!
            //
            break;
        }

        TraceSysFreeString( bstrUID );
        bstrUID = NULL;

        pccneti->Release();
        pccneti = NULL;

    } // while: hr == S_OK

    hr = THR( pccci->SetNetworkInfo( pccneti ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Configure that node to create a cluster
    //

    hr = THR( pccci->SetCommitMode( cmCREATE_CLUSTER ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Update the UI layer telling it that we are making progress.
    //

    hr = THR( SendStatusReport( bstrNodeName,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Forming_Node,
                                0,
                                2,
                                1,
                                hr,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Commit this node!
    //

    hr = THR( pccs->CommitChanges() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

Cleanup:

    //
    //  Update the UI layer telling it that we are finished.
    //

    THR( SendStatusReport( bstrNodeName,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Forming_Node,
                           0,
                           2,
                           2,
                           hr,
                           NULL,    // don't need to update string
                           NULL,
                           NULL
                           ) );

    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrUID );

    if ( pccneti != NULL )
    {
        pccneti->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( SendStatusReport( bstrNodeName,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Forming_Node,
                           0,
                           2,
                           2,
                           hr,
                           NULL,    // don't need to update string
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} //*** CTaskCommitClusterChanges::HrFormFirstNode

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrAddJoiningNodes
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrAddJoiningNodes( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    ULONG               cNodes;
    ULONG               celtDummy;
    OBJECTCOOKIE        cookieNode;
    BSTR                bstrNodeName = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    IUnknown *          punkNode = NULL;

    //
    //  Reset the enum to use again.
    //

    hr = THR( m_pen->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Loop thru the nodes, adding all joining nodes, skipping the forming node (if any).
    //

    Assert( hr == S_OK );
    for( cNodes = 0; ( ( hr == S_OK ) && ( m_fStop == FALSE ) ); cNodes ++ )
    {
        //
        //  Cleanup
        //

        if ( punkNode != NULL )
        {
            punkNode->Release();
            punkNode = NULL;
        } // if:

        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        } // if:

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        //
        //  Grab the next node.
        //

        hr = STHR( m_pen->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;
        }

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Get the name of the node ffrom the cookies standard info,  Once we have a node
        //  name it's okay to goto error instead of cleanup.
        //

        hr = THR( HrRetrieveCookiesName( m_pom, cookieNode, &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Get the node object for the cookie.
        //

        // While the argument list says it returns an IUnknown pointer, it
        // actually calls into QueryInterface requesting an IClusCfgNodeInfo
        // interface.
        hr = THR( m_pom->GetObject(
                              DFGUID_NodeInformation
                            , cookieNode
                            , reinterpret_cast< IUnknown ** >( &pccni )
                            ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Get an IUnknown pointer for use in the comparison to determine
        // whether this is the forming node or not.  This is necessary because
        // in the comparison below, we need to compare the exact same
        // interface that was set into m_punkFormingNode, which was an
        // IUnknown interface.
        hr = THR( pccni->TypeSafeQI( IUnknown, &punkNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Check cluster membership.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  If the node is already clustered then skip it.
        //

        if ( hr == S_OK )
        {
            continue;
        }

        //
        //  KB: We only need the punk's address to see if the objects are the
        //      same COM object by comparing the IUnknown interfaces.
        //
        //  If the addresses are the same then skip it since we already "formed" in
        //  HrCompareAndPushInformationToNodes() above.
        //

        if ( m_punkFormingNode == punkNode )
        {
            continue;
        }

        hr = THR( HrAddAJoiningNode( bstrNodeName, cookieNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // for: looping thru nodes a second time.

    Assert( cNodes == m_cNodes );

    hr = S_OK;

Cleanup:

    TraceSysFreeString( bstrNodeName );

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( punkNode != NULL )
    {
        punkNode->Release();
    }

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::HrAddJoiningNodes

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrAddAJoiningNode(
//      BSTR            bstrNameIn,
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrAddAJoiningNode(
    BSTR            bstrNameIn,
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    IUnknown *                  punk  = NULL;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgClusterInfo *       pccci = NULL;
    IClusCfgServer *            pccs  = NULL;

    //
    //  Create the notification string
    //

    //
    //  Tell UI layer we are about to start this.
    //

    hr = THR( HrSendStatusReport(
                      bstrNameIn
                    , TASKID_Major_Configure_Cluster_Services
                    , TASKID_Minor_Joining_Node
                    , 0
                    , 2
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_JOINING_NODE
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Connect to the node.
    //

    hr = THR( m_pcm->GetConnectionToObject( cookieIn,
                                            &punk
                                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Get the node info interface.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Retrieve the server's Cluster Configuration Object..
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Put the properties into the remoted object.
    //

    hr = THR( pccci->SetName( m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccci->SetBindingString( m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccc->AssignTo( piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccci->SetIPAddress( m_ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccci->SetSubnetMask( m_ulSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Set this node to add itself to a cluster
    //

    hr = THR( pccci->SetCommitMode( cmADD_NODE_TO_CLUSTER ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Tell the UI layer we are making progess.... the server will then send messages
    //  indicating what it is doing.
    //

    hr = THR( SendStatusReport( bstrNameIn,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Joining_Node,
                                0,
                                2,
                                1,
                                S_OK,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Commit this node!
    //

    hr = THR( pccs->CommitChanges() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    THR( SendStatusReport( bstrNameIn,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Joining_Node,
                           0,
                           2,
                           2,
                           hr,
                           NULL,    // don't need to update string
                           NULL,
                           NULL
                           ) );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::HrAddAJoiningNode


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrSendStatusReport(
//       LPCWSTR   pcsNodeNameIn
//     , CLSID     clsidMajorIn
//     , CLSID     clsidMinorIn
//     , ULONG     ulMinIn
//     , ULONG     ulMaxIn
//     , ULONG     ulCurrentIn
//     , HRESULT   hrIn
//     , int       nDescriptionIdIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrSendStatusReport(
      LPCWSTR   pcszNodeNameIn
    , CLSID     clsidMajorIn
    , CLSID     clsidMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrIn
    , int       nDescriptionIdIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, nDescriptionIdIn, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SendStatusReport( pcszNodeNameIn, clsidMajorIn, clsidMinorIn, ulMinIn, ulMaxIn, ulCurrentIn, hrIn, bstr, NULL, NULL ) );

Cleanup:

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::HrSendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcancelcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      TaskCancelCleanup.h
//
//  Description:
//      CTaskCancelCleanup implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 25-JAN-2002
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskCancelCleanup
//
//  Description:
//      The class CTaskCancelCleanup is the cleanup task that is invoked
//      whenever the wizard is canceled.
//
//  Interfaces:
//      ITaskCancelCleanup
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskCancelCleanup
    : public ITaskCancelCleanup
    , public IClusCfgCallback
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    bool                m_fStop;
    OBJECTCOOKIE        m_cookieCluster;
    IClusCfgCallback *  m_picccCallback;
    OBJECTCOOKIE        m_cookieCompletion;
    IObjectManager *    m_pom;
    INotifyUI *         m_pnui;

    CTaskCancelCleanup( void );
    ~CTaskCancelCleanup( void );
    STDMETHOD( HrInit )( void );
    HRESULT HrProcessNode( OBJECTCOOKIE cookieNodeIn );
    HRESULT HrTaskCleanup( HRESULT hrIn );
    HRESULT HrTaskSetup( void );

    // Private copy constructor to prevent copying.
    CTaskCancelCleanup( const CTaskCancelCleanup & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskCancelCleanup & operator = ( const CTaskCancelCleanup & nodeSrc );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    //  IUnknown
    //

    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );

    //
    //  ITaskCancelCleanup
    //

    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieCompletionIn );

    //
    //  IClusCfgCallback
    //

    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** class CTaskCancelCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherClusterInfo.h
//
//  Description:
//      CTaskGatherClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 07-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherClusterInfo
class CTaskGatherClusterInfo
    : public ITaskGatherClusterInfo
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask / ITaskGatherNodeInfo
    OBJECTCOOKIE        m_cookie;           //  Cookie to the Node
    OBJECTCOOKIE        m_cookieCompletion; //  Cookie to signal when task is completed
    BOOL                m_fStop;

    CTaskGatherClusterInfo( void );
    ~CTaskGatherClusterInfo( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGatherNodeInfo
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );

}; //*** class CTaskGatherClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskGatherClusterInfo.cpp
//
//  Description:
//      TaskGatherClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 07-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskGatherClusterInfo.h"

DEFINE_THISCLASS("CTaskGatherClusterInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherClusterInfo::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherClusterInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CTaskGatherClusterInfo *    ptgci = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptgci = new CTaskGatherClusterInfo;
    if ( ptgci == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptgci->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptgci->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ptgci != NULL )
    {
        ptgci->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherClusterInfo::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherClusterInfo::CTaskGatherClusterInfo
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherClusterInfo::CTaskGatherClusterInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherClusterInfo::CTaskGatherClusterInfo

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskGatherClusterInfo
    Assert( m_cookie == NULL );

    Assert( m_fStop == FALSE );

    HRETURN( hr );

} //*** CTaskGatherClusterInfo::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherClusterInfo::~CTaskGatherClusterInfo
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherClusterInfo::~CTaskGatherClusterInfo( void )
{
    TraceFunc( "" );

    //
    //  This keeps the per thread memory tracking from screaming.
    //
    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherClusterInfo::~CTaskGatherClusterInfo

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGatherClusterInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGatherClusterInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_ITaskGatherClusterInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGatherClusterInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGatherClusterInfo::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherClusterInfo::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskGatherClusterInfo::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherClusterInfo::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskGatherClusterInfo::Release


// ************************************************************************
//
// IDoTask / ITaskGatherClusterInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    IConnectionManager *        pcm   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgServer *            pccs  = NULL;
    IGatherData *               pgd   = NULL;
    IClusCfgClusterInfo *       pccci = NULL;

    TraceInitializeThread( L"TaskGatherClusterInfo" );

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &pcm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcp = TraceInterface( L"CTaskGatherClusterInfo!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //pnui = TraceInterface( L"CTaskGatherClusterInfo!INotifyUI", INotifyUI, pnui, 1 );

    psp->Release();
    psp = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the Connection Manager for a connection to the object.
    //

    // don't wrap - this can fail.
    hr = pcm->GetConnectionToObject( m_cookie, &punk );

    //
    //  This means the cluster has not been created yet.
    //
    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        goto ReportStatus;
    }
//  HR_S_RPC_S_CLUSTER_NODE_DOWN
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto ReportStatus;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release();
    punk = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the Node information.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  See if the node is a member of a cluster.
    //

    hr = STHR( pccni->IsMemberOfCluster() );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  If it is not a cluster, then there is nothing to do the "default"
    //  configuration will do.
    //

    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto ReportStatus;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the Node for the Cluster Information.
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  Ask the Object Manager to retrieve the data format to store the information.
    //

    Assert( punk == NULL );
    hr = THR( pom->GetObject( DFGUID_ClusterConfigurationInfo, m_cookie, &punk ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  Start sucking.
    //

    hr = THR( pgd->Gather( NULL, pccci ) );

    //
    //  Update the status. Ignore the error (if any).
    //
ReportStatus:
    if ( pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punkTemp = NULL;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookie,
                                   &punkTemp
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psi ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }
    } // if: ( pom != NULL )
    if ( pnui != NULL )
    {
        THR( pnui->ObjectChanged( m_cookie ) );
    }

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punkTemp = NULL;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookieCompletion,
                                   &punkTemp
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psi ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        pom->Release();
    } // if: ( pom != NULL )
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    if ( pnui !=NULL )
    {
        if ( m_cookieCompletion != 0 )
        {
            hr = THR( pnui->ObjectChanged( m_cookieCompletion ) );
        } // if:

        pnui->Release();
    } // if:

    LogMsg( L"[MT] [CTaskGatherClusterInfo] exiting task.  The task was%ws cancelled.", m_fStop == FALSE ? L" not" : L"" );

    HRETURN( hr );

} //*** CTaskGatherClusterInfo::BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskGatherClusterInfo] is being stopped." );

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskGatherClusterInfo]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** SetCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::SetCompletionCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::SetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherClusterInfo::SetGatherPunk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcompareandpushinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskCompareAndPushInformation.h
//
//  Description:
//      CTaskCompareAndPushInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskCompareAndPushInformation
class CTaskCompareAndPushInformation
    : public ITaskCompareAndPushInformation
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask / ITaskCompareAndPushInformation
    OBJECTCOOKIE        m_cookieCompletion;
    OBJECTCOOKIE        m_cookieNode;
    IClusCfgCallback *  m_pcccb;                // Marshalled interface

    // INotifyUI
    HRESULT             m_hrStatus;             // Status of callbacks

    IObjectManager *    m_pom;
    BSTR                m_bstrNodeName;
    BOOL                m_fStop;

    CTaskCompareAndPushInformation( void );
    ~CTaskCompareAndPushInformation( void );

    // Private copy constructor to prevent copying.
    CTaskCompareAndPushInformation( const CTaskCompareAndPushInformation & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskCompareAndPushInformation & operator = ( const CTaskCompareAndPushInformation & nodeSrc );

    STDMETHOD( HrInit )( void );

    HRESULT HrVerifyCredentials( IClusCfgServer * pccsIn, OBJECTCOOKIE cookieClusterIn );
    HRESULT HrExchangePrivateData( IClusCfgManagedResourceInfo * piccmriSrcIn, IClusCfgManagedResourceInfo * piccmriDstIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskCompareAndPushInformation
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetNodeCookie )( OBJECTCOOKIE cookieIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    STDMETHOD( HrSendStatusReport )(
                      CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , UINT       nDescriptionIn
                    );
}; //*** class CTaskCompareAndPushInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskcompareandpushinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskCompareAndPushInformation.cpp
//
//  Description:
//      CTaskCompareAndPushInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskCompareAndPushInformation.h"
#include "ManagedResource.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CTaskCompareAndPushInformation")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCompareAndPushInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCompareAndPushInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    CTaskCompareAndPushInformation *    ptcapi = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptcapi = new CTaskCompareAndPushInformation;
    if ( ptcapi == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptcapi->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptcapi->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ptcapi != NULL )
    {
        ptcapi->Release();
    }

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCompareAndPushInformation::CTaskCompareAndPushInformation
//
//////////////////////////////////////////////////////////////////////////////
CTaskCompareAndPushInformation::CTaskCompareAndPushInformation( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskCompareAndPushInformation::CTaskCompareAndPushInformation

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskCompareAndPushInformation
    Assert( m_cookieCompletion == NULL );
    Assert( m_cookieNode == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_pom == NULL );
    Assert( m_hrStatus == S_OK );
    Assert( m_bstrNodeName == NULL );
    Assert( m_fStop == FALSE );

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCompareAndPushInformation::~CTaskCompareAndPushInformation
//
//////////////////////////////////////////////////////////////////////////////
CTaskCompareAndPushInformation::~CTaskCompareAndPushInformation()
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    TraceSysFreeString( m_bstrNodeName );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskCompareAndPushInformation::~CTaskCompareAndPushInformation


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCompareAndPushInformation::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskCompareAndPushInformation * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_ITaskCompareAndPushInformation ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskCompareAndPushInformation, this, 0 );
    } // else if: ITaskCompareAndPushInformation
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskCompareAndPushInformation::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCompareAndPushInformation::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCompareAndPushInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskCompareAndPushInformation::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCompareAndPushInformation::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskCompareAndPushInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskCompareAndPushInformation::Release



//****************************************************************************
//
//  ITaskCompareAndPushInformation
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::BeginTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;
    ULONG   celt;
    ULONG   celtDummy;

    OBJECTCOOKIE    cookieCluster;
    OBJECTCOOKIE    cookieDummy;

    BSTR    bstrNotification = NULL;
    BSTR    bstrRemote       = NULL;    // reused many times
    BSTR    bstrLocal        = NULL;    // reused many times

    ULONG   celtFetched = 0;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    IConnectionManager *        pcm   = NULL;
    IClusCfgServer *            pccs  = NULL;
    IStandardInfo *             psi   = NULL;
    INotifyUI *                 pnui  = NULL;

    IEnumClusCfgNetworks *      peccnLocal    = NULL;
    IEnumClusCfgNetworks *      peccnRemote   = NULL;

    IEnumClusCfgManagedResources * peccmrLocal = NULL;
    IEnumClusCfgManagedResources * peccmrRemote = NULL;

    IClusCfgManagedResourceInfo *  pccmri[ 10 ] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    IClusCfgManagedResourceInfo *  pccmriLocal = NULL;

    IClusCfgNetworkInfo *          pccni[ 10 ]  = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    IClusCfgNetworkInfo *          pccniLocal = NULL;

    TraceInitializeThread( L"TaskCompareAndPushInformation" );

    //
    //  Gather the manager we need to complete our tasks.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    pcpc = TraceInterface( L"CTaskCompareAndPushInformation!IConnectionPointContainer", IConnectionPointContainer, pcpc, 1 );

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    pcp = TraceInterface( L"CTaskCompareAndPushInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    pnui = TraceInterface( L"CTaskCompareAndPushInformation!INotifyUI", INotifyUI, pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &pcm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    psp->Release();            // release promptly
    psp = NULL;

    //
    //  Ask the object manager for the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieNode, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    psi = TraceInterface( L"TaskCompareAndPushInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetName( &m_bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( m_bstrNodeName );

    // done with it.
    psi->Release();
    psi = NULL;

    LogMsg( L"[MT] [CTaskCompareAndPushInformation] Beginning task for node %ws...", m_bstrNodeName );

    hr = THR( HrSendStatusReport(
                      TASKID_Major_Reanalyze
                    , TASKID_Minor_Comparing_Configuration
                    , 0
                    , 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_COMPARING_CONFIGURATION
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the connection manager for a connection to the node.
    //

    hr = THR( pcm->GetConnectionToObject( m_cookieNode, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    punk->Release();
    punk = NULL;

    //
    //  Figure out the parent cluster of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieNode, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    psi = TraceInterface( L"TaskCompareAndPushInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetParent( &cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    hr = THR( HrVerifyCredentials( pccs, cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    //
    //  Tell the UI layer we're starting to gather the resources.  There are two steps, managed resources and networks.
    //

    hr = THR( HrSendStatusReport(
                      TASKID_Minor_Comparing_Configuration
                    , TASKID_Minor_Gathering_Managed_Devices
                    , 0
                    , 2
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the connection for the enumer for managed resources.
    //

    hr = THR( pccs->GetManagedResourcesEnum( &peccmrRemote ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    peccmrRemote = TraceInterface( L"CTaskCompareAndPushInformation!GetManagedResourceEnum", IEnumClusCfgManagedResources, peccmrRemote, 1 );

    //
    //  Ask the Object Manager for the enumer for managed resources.
    //
    // Don't wrap - this can fail.
    hr = m_pom->FindObject( CLSID_ManagedResourceType,
                          cookieCluster,
                          NULL,
                          DFGUID_EnumManageableResources,
                          &cookieDummy,
                          &punk
                          );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
    {
        goto PushNetworks;
    }

    if ( FAILED( hr ) )
    {
        Assert( punk == NULL );
        THR( hr );
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmrLocal ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    peccmrLocal = TraceInterface( L"CTaskCompareAndPushInformation!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmrLocal, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Enumerate the next 10 resources.
    //
    for( ; m_fStop == FALSE; )
    {
        //
        //  Get next remote managed resource(s).
        //

        hr = STHR( peccmrRemote->Next( 10, pccmri, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
        {
            break;  // exit loop
        }

        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  Loop thru the resource gather information out of each of them
        //  and then release them.
        //
        for( celt = 0; ( ( celt < celtFetched ) && ( m_fStop == FALSE ) ); celt ++ )
        {
            DWORD   dwLenRemote;

            //
            //  Error
            //

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            Assert( pccmri[ celt ] != NULL );

            //
            //  Get the UID of the remote resource.
            //

            hr = THR( pccmri[ celt ]->GetUID( &bstrRemote ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrRemote );

            dwLenRemote = SysStringByteLen( bstrRemote );

            //
            //  Try to match this resource with one in the object manager.
            //

            hr = THR( peccmrLocal->Reset() );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            for( ; m_fStop == FALSE; )
            {
                DWORD   dwLenLocal;

                //
                //  Cleanup
                //

                if ( pccmriLocal != NULL )
                {
                    pccmriLocal->Release();
                    pccmriLocal = NULL;
                } // if:

                TraceSysFreeString( bstrLocal );
                bstrLocal = NULL;

                //
                //  Get next local managed resource.
                //

                hr = STHR( peccmrLocal->Next( 1, &pccmriLocal, &celtDummy ) );
                if ( hr == S_FALSE )
                {
                    //
                    //  If we exhausted all the devices but did not match the device
                    //  in our cluster configuration, this means something changed
                    //  on the remote node. Send up an error!
                    //

                    //
                    //  TODO:   gpease  24-MAR-2000
                    //          Find a better error code and SendStatusReport!
                    //
                    hr = THR( ERROR_RESOURCE_NOT_FOUND );
                    goto Error;
                }

                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                hr = THR( pccmriLocal->GetUID( &bstrLocal ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                TraceMemoryAddBSTR( bstrLocal );

                dwLenLocal  = SysStringByteLen( bstrLocal );

                if ( dwLenRemote == dwLenLocal
                  && memcmp( bstrRemote, bstrLocal, dwLenLocal ) == 0
                   )
                {
                    Assert( hr == S_OK );
                    break;  // match!
                }
            } // for: local managed resources...

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  If we made it here, we have a resource in pccmriLocal that matches
            //  the resource in pccmri[ celt ].
            //
            Assert( pccmriLocal != NULL );

            //
            //
            //  Push the data down to the node.
            //
            //

            //
            //  Update the name (if needed).
            //

            hr = THR( pccmriLocal->GetName( &bstrLocal ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccmri[ celt ]->GetName( &bstrRemote ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrRemote );

            if ( NBSTRCompareCase( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccmri[ celt ]->SetName( bstrLocal ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }
            }

            //
            //  Update IsManaged?
            //

            hr = STHR( pccmriLocal->IsManaged() );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            hr = STHR( pccmri[ celt ]->SetManaged( hr == S_OK ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  I'm not sure that we want to send this back down to the server side object.
            //  It is its responsibility to know whether or not it is manageable.
            //
            /*
            //
            //  Update IsManageable?
            //

            hr = STHR( pccmriLocal->IsManageable() );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( pccmri[ celt ]->SetManageable( hr == S_OK ) );
            if ( FAILED( hr ) )
                goto Error;
            */
            //
            //  Update IsQuorum?
            //

            hr = STHR( pccmriLocal->IsQuorumResource() );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            hr = THR( pccmri[ celt ]->SetQuorumResource( hr == S_OK ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  Update private resource data
            //

            hr = THR( HrExchangePrivateData( pccmriLocal, pccmri[ celt ] ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            //
            //  Update DriveLetterMappings
            //

            //
            //  KB: gpease  31-JUL-2000
            //      We currently don't support setting the drive letter mappings
            //

            //  release the interface
            pccmri[ celt ]->Release();
            pccmri[ celt ] = NULL;
        } // for: celt

        //
        //  Need to cleanup from the last iteration...
        //

        TraceSysFreeString( bstrRemote );
        bstrRemote = NULL;

        TraceSysFreeString( bstrLocal );
        bstrLocal = NULL;
    } // for: hr

PushNetworks:

    if ( m_fStop == TRUE )
    {
        goto Error;
    } // if:

#if defined(DEBUG)

    //
    //  Make sure the strings are really freed after exitting the loop.
    //

    Assert( bstrLocal == NULL );
    Assert( bstrRemote == NULL );

#endif // DEBUG

    //
    //  Tell the UI layer we're done will gathering the managed resources.
    //

    hr = THR( HrSendStatusReport(
                  TASKID_Minor_Comparing_Configuration
                , TASKID_Minor_Gathering_Managed_Devices
                , 0
                , 2
                , 1
                , S_OK
                , IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Now gather the networks from the node.
    //

    //
    //  Ask the connection for the enumer for the networks.
    //

    hr = THR( pccs->GetNetworksEnum( &peccnRemote ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Ask the Object Manager for the enumer for managed resources.
    //

    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                               NULL,
                               NULL,
                               DFGUID_EnumManageableNetworks,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccnLocal ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    punk->Release();
    punk = NULL;

    //
    //  Enumerate the next 10 networks.
    //
    for( ; m_fStop == FALSE; )
    {
        //
        //  Get the next 10 networks.
        //

        hr = STHR( peccnRemote->Next( 10, pccni, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
        {
            break;  // exit loop
        }

        if ( FAILED( hr ) )
        {
            goto Error;
        }

        //
        //  Loop thru the networks gather information out of each of them
        //  and then release them.
        //

        for( celt = 0; ( ( celt < celtFetched ) && ( m_fStop == FALSE ) ); celt ++ )
        {
            DWORD   dwLenRemote;

            //
            //  Error
            //

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  Get the UID of the remote network.
            //

            hr = THR( pccni[ celt ]->GetUID( &bstrRemote ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrRemote );

            dwLenRemote = SysStringByteLen( bstrRemote );

            //
            //  Try to match this resource with one in the object manager.
            //

            hr = THR( peccnLocal->Reset() );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            for ( ; m_fStop == FALSE; )
            {
                DWORD   dwLenLocal;

                //
                //  Cleanup before next pass...
                //

                if ( pccniLocal != NULL )
                {
                    pccniLocal->Release();
                    pccniLocal = NULL;
                } // if:

                TraceSysFreeString( bstrLocal );
                bstrLocal = NULL;

                //
                //  Get next network from the cluster configuration.
                //

                hr = STHR( peccnLocal->Next( 1, &pccniLocal, &celtDummy ) );
                if ( hr == S_FALSE )
                {
                    break;
                }

                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                hr = THR( pccniLocal->GetUID( &bstrLocal ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }

                TraceMemoryAddBSTR( bstrLocal );

                dwLenLocal  = SysStringByteLen( bstrLocal );

                if ( dwLenRemote == dwLenLocal
                  && memcmp( bstrRemote, bstrLocal, dwLenLocal ) == 0
                   )
                {
                    Assert( hr == S_OK );
                    break;  // match!
                }

            } // for: hr

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  If we come out of the loop with S_FALSE, that means the
            //  node has a resource that we did not see during the analysis.
            //  Send up an error.
            //
            if ( hr == S_FALSE )
            {
                LogMsg( L"[MT] Found a resource that was not found during analysis." );
                hr = S_OK;
                continue;
            }

            //
            //  If we made it here, we have a resource in pccniLocal that matches
            //  the resource in pccmri[ celt ].
            //
            Assert( pccniLocal != NULL );

            //
            //
            //  Push the data down to the node.
            //
            //

            //
            //  Set Name
            //

            hr = THR( pccniLocal->GetName( &bstrLocal ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccni[ celt ]->GetName( &bstrRemote ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrRemote );

            if ( NBSTRCompareCase( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccni[ celt ]->SetName( bstrLocal ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }
            }

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  Set Description
            //

            hr = THR( pccniLocal->GetDescription( &bstrLocal ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccni[ celt ]->GetDescription( &bstrRemote ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            TraceMemoryAddBSTR( bstrRemote );

            if ( NBSTRCompareCase( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccni[ celt ]->SetDescription( bstrLocal ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }
            }

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  KB: gpease  31-JUL-2000
            //      We don't support reconfiguring the IP Address remotely because
            //      our connection to the server will be cut when the IP stack on
            //      the remote machine reconfigs.
            //

            //
            //  Set IsPublic?
            //

            hr = STHR( pccniLocal->IsPublic() );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            hr = STHR( pccni[ celt ]->SetPublic( hr == S_OK ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  Set IsPrivate?
            //

            hr = STHR( pccniLocal->IsPrivate() );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            hr = STHR( pccni[ celt ]->SetPrivate( hr == S_OK ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //  release the interface
            pccni[ celt ]->Release();
            pccni[ celt ] = NULL;
        } // for: celt
    } // for: hr

    //
    //  Tell the UI that we are done gathering managed resources and networks.
    //

    hr = THR( HrSendStatusReport(
                  TASKID_Minor_Comparing_Configuration
                , TASKID_Minor_Gathering_Managed_Devices
                , 0
                , 2
                , 2
                , S_OK
                , IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

#if defined(DEBUG)
    //
    //  Make sure the strings are really freed after exitting the loop.
    //
    Assert( bstrLocal == NULL );
    Assert( bstrRemote == NULL );
#endif // DEBUG

    hr = S_OK;

Error:

    //
    //  Tell the UI layer we're done comparing configurations and what the resulting
    //  status was.
    //

    THR( HrSendStatusReport(
                  TASKID_Major_Reanalyze
                , TASKID_Minor_Comparing_Configuration
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_COMPARING_CONFIGURATION
                ) );

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrRemote );
    TraceSysFreeString( bstrLocal );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( m_pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punkTemp = NULL;

        hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punkTemp ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psiTemp = NULL;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psiTemp ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psiTemp->SetStatus( hr ) );
                psiTemp->Release();
                psiTemp = NULL;
            }
        } // if: ( SUCCEEDED( hr2 ) )
    } // if: ( m_pom != NULL )
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pnui != NULL )
    {
        HRESULT hrTemp;

        LogMsg( L"[TaskCompareAndPushInformation] Sending the completion cookie %ld for node %ws to the notification manager because this task is complete.", m_cookieCompletion, m_bstrNodeName );
        hrTemp = THR( pnui->ObjectChanged( m_cookieCompletion ) );
        if ( FAILED( hrTemp ) )
        {
            LogMsg( L"[TaskCompareAndPushInformation] Error sending the completion cookie %ld for node %ws to the notification manager because this task is complete. (hr=%#08x)", m_cookieCompletion, m_bstrNodeName, hrTemp );
        } // if:

        pnui->Release();
    }
    if ( peccnLocal != NULL )
    {
        peccnLocal->Release();
    }
    if ( peccnRemote != NULL )
    {
        peccnRemote->Release();
    }
    if ( peccmrLocal != NULL )
    {
        peccmrLocal->Release();
    }
    if ( peccmrRemote != NULL )
    {
        peccmrRemote->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccmri[ celt ] != NULL )
        {
            pccmri[ celt ]->Release();
        }
        if ( pccni[ celt ] != NULL )
        {
            pccni[ celt ]->Release();
        }

    } // for: celt
    if ( pccmriLocal != NULL )
    {
        pccmriLocal->Release();
    }

    if ( pccniLocal != NULL )
    {
        pccniLocal->Release();
    }

    LogMsg( L"[MT] [CTaskCompareAndPushInformation] Exiting task.  The task was%ws cancelled. (hr = %#08x)", m_fStop == FALSE ? L" not" : L"", hr );

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::BeginTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::StopTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskCompareAndPushInformation] is being stopped." );

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::StopTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SetCompletionCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SetCompletionCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskCompareAndPushInformation]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::SetCompletionCookie


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SetNodeCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SetNodeCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskCompareAndPushInformation]" );

    HRESULT hr = S_OK;

    m_cookieNode = cookieIn;

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::SetNodeCookie


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                              pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , pftTimeIn
                            , pcszReferenceIn
                            ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::HrSendStatusReport(
//       CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , UINT       nDescriptionIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::HrSendStatusReport(
      CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , UINT       nDescriptionIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;

    THR( HrLoadStringIntoBSTR( g_hInstance, nDescriptionIn, &bstrDescription ) );

    hr = THR( SendStatusReport(
                          m_bstrNodeName
                        , clsidTaskMajorIn
                        , clsidTaskMinorIn
                        , ulMinIn
                        , ulMaxIn
                        , ulCurrentIn
                        , hrStatusIn
                        , bstrDescription != NULL ? bstrDescription : L"<unknown>"
                        , NULL
                        , NULL
                        ) );

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::HrSendStatusReport


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCompareAndPushInformation::HrVerifyCredentials(
//      IClusCfgServer * pccsIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCompareAndPushInformation::HrVerifyCredentials(
    IClusCfgServer *    pccsIn,
    OBJECTCOOKIE        cookieClusterIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    BSTR    bstrAccountName = NULL;
    BSTR    bstrAccountPassword = NULL;
    BSTR    bstrAccountDomain = NULL;

    IUnknown *              punk  = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;
    IClusCfgVerify *        pccv = NULL;

    hr = THR( HrSendStatusReport(
                      TASKID_Major_Reanalyze
                    , TASKID_Minor_Validating_Credentials
                    , 0
                    , 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_VALIDATING_CREDENTIALS
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the object manager for the cluster configuration object.
    //

    hr = THR( m_pom->GetObject( DFGUID_ClusterConfigurationInfo, cookieClusterIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccsIn->TypeSafeQI( IClusCfgVerify, &pccv ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( piccc->GetCredentials( &bstrAccountName, &bstrAccountDomain, &bstrAccountPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    TraceMemoryAddBSTR( bstrAccountName );
    TraceMemoryAddBSTR( bstrAccountDomain );
    TraceMemoryAddBSTR( bstrAccountPassword );

    //
    //  The server component reports the exact failure, if any, to the UI.
    //

    hr = THR( pccv->VerifyCredentials( bstrAccountName, bstrAccountDomain, bstrAccountPassword ) );
    SecureZeroMemory( bstrAccountPassword, SysStringLen( bstrAccountPassword ) * sizeof( *bstrAccountPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    //
    //  The server side function does its own error reporting and it's okay to double report here because
    //  there could have been a network problem that prevents the server side from either being contacted
    //  or being able to report the status.
    //

    THR( HrSendStatusReport(
                  TASKID_Major_Reanalyze
                , TASKID_Minor_Validating_Credentials
                , 0
                , 1
                , 1
                , hr
                , IDS_TASKID_MINOR_VALIDATING_CREDENTIALS
                ) );
    TraceSysFreeString( bstrAccountName );
    TraceSysFreeString( bstrAccountDomain );
    TraceSysFreeString( bstrAccountPassword );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( piccc != NULL )
    {
        piccc->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::HrVerifyCredentials


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCompareAndPushInformation::HrExchangePrivateData(
//        IClusCfgManagedResourceInfo *   piccmriSrcIn
//      , IClusCfgManagedResourceInfo *   piccmriDstIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCompareAndPushInformation::HrExchangePrivateData(
      IClusCfgManagedResourceInfo *   piccmriSrcIn
    , IClusCfgManagedResourceInfo *   piccmriDstIn
)
{
    TraceFunc( "" );
    Assert( piccmriSrcIn != NULL );
    Assert( piccmriDstIn != NULL );

    HRESULT                         hr = S_OK;
    HRESULT                         hrSrcQI = S_OK;
    HRESULT                         hrDstQI = S_OK;
    IClusCfgManagedResourceData *   piccmrdSrc = NULL;
    IClusCfgManagedResourceData *   piccmrdDst = NULL;
    BYTE *                          pbPrivateData = NULL;
    DWORD                           cbPrivateData = 0;

    hrSrcQI = piccmriSrcIn->TypeSafeQI( IClusCfgManagedResourceData, &piccmrdSrc );
    if ( hrSrcQI == E_NOINTERFACE )
    {
        LogMsg( L"[MT] The cluster managed resource has no support for IClusCfgManagedResourceData." );
        goto Cleanup;
    } // if:
    else if ( FAILED( hrSrcQI ) )
    {
        hr = THR( hrSrcQI );
        goto Cleanup;
    } // if:

    hrDstQI = piccmriDstIn->TypeSafeQI( IClusCfgManagedResourceData, &piccmrdDst );
    if ( hrDstQI == E_NOINTERFACE )
    {
        LogMsg( L"[MT] The new node resource has no support for IClusCfgManagedResourceData." );
        goto Cleanup;
    } // if:
    else if ( FAILED( hrDstQI ) )
    {
        hr = THR( hrDstQI );
        goto Cleanup;
    } // if:

    Assert( ( hrSrcQI == S_OK ) && ( piccmrdSrc != NULL ) );
    Assert( ( hrDstQI == S_OK ) && ( piccmrdDst != NULL ) );

    cbPrivateData = 512;    // start with a reasonable amout

    pbPrivateData = (BYTE *) TraceAlloc( 0, cbPrivateData );
    if ( pbPrivateData == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = piccmrdSrc->GetResourcePrivateData( pbPrivateData, &cbPrivateData );
    if ( hr == HR_RPC_INSUFFICIENT_BUFFER )
    {
        TraceFree( pbPrivateData );
        pbPrivateData = NULL;

        pbPrivateData = (BYTE *) TraceAlloc( 0, cbPrivateData );
        if ( pbPrivateData == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        hr = piccmrdSrc->GetResourcePrivateData( pbPrivateData, &cbPrivateData );
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( piccmrdDst->SetResourcePrivateData( pbPrivateData, cbPrivateData ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // else if:
    else
    {
        THR( hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( piccmrdSrc != NULL )
    {
        piccmrdSrc->Release();
    } // if:

    if ( piccmrdDst != NULL )
    {
        piccmrdDst->Release();
    } // if:

    TraceFree( pbPrivateData );

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::HrExchangePrivateData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskGatherInformation.cpp
//
//  Description:
//      CTaskGatherInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <StatusReports.h>
#include "TaskGatherInformation.h"
#include "ManagedResource.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CTaskGatherInformation")

//
//  Failure code.
//

#define SSR_TGI_FAILED( _major, _minor, _hr ) \
    {   \
        HRESULT __hrTemp; \
        __hrTemp = THR( HrSendStatusReport( m_bstrNodeName, _major, _minor, 1, 1, 1, _hr, IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE, 0 ) ); \
        if ( FAILED( __hrTemp ) && SUCCEEDED( _hr ) )\
        {   \
            _hr = __hrTemp;   \
        }   \
    }


//////////////////////////////////////////////////////////////////////////////
//
//  Static function prototypes
//
//////////////////////////////////////////////////////////////////////////////

static
HRESULT
HrTotalManagedResourceCount(
      IEnumClusCfgManagedResources *    pResourceEnumIn
    , IEnumClusCfgNetworks *            pNetworkEnumIn
    , DWORD *                           pnCountOut
    );


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::S_HrCreateInstance(
//      IUnknown ** punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CTaskGatherInformation *    ptgi = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptgi = new CTaskGatherInformation;
    if ( ptgi == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptgi->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptgi->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );

Cleanup:

    if ( ptgi != NULL )
    {
        ptgi->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherInformation::CTaskGatherInformation
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherInformation::CTaskGatherInformation( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::CTaskGatherInformation

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskGatherInformation
    Assert( m_cookieCompletion == NULL );
    Assert( m_cookieNode == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_fAdding == FALSE );
    Assert( m_cResources == 0 );

    Assert( m_pom == NULL );
    Assert( m_pccs == NULL );
    Assert( m_bstrNodeName == NULL );

    Assert( m_ulQuorumDiskSize == 0 );
    Assert( m_pccmriQuorum == NULL );

    Assert( m_fStop == FALSE );
    Assert( m_fMinConfig == FALSE );

    HRETURN( hr );

} //*** CTaskGatherInformation::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherInformation::~CTaskGatherInformation
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherInformation::~CTaskGatherInformation( void )
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_pccs != NULL )
    {
        m_pccs->Release();
    }

    TraceSysFreeString( m_bstrNodeName );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::~CTaskGatherInformation


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGatherInformation::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGatherInformation * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGatherInformation ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGatherInformation, this, 0 );
    } // else if: ITaskGatherInformation

    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGatherInformation::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskGatherInformation::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskGatherInformation::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskGatherInformation::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskGatherInformation::Release


//****************************************************************************
//
//  ITaskGatherInformation
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::BeginTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IConnectionManager *        pcm   = NULL;
    IStandardInfo *             psi   = NULL;
    IClusCfgCapabilities *      pccc  = NULL;

    IEnumClusCfgManagedResources *  peccmr  = NULL;
    IEnumClusCfgNetworks *          pen     = NULL;

    DWORD   cTotalResources = 0;

    TraceInitializeThread( L"TaskGatherInformation" );

    //
    //  Make sure we weren't "reused"
    //

    Assert( m_cResources == 0 );

    //
    //  Gather the manager we need to complete our tasks.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_CoCreate_ServiceManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_NotificationManager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskGatherInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QI_pnui, hr );
        goto Cleanup;
    }

    pnui = TraceInterface( L"CTaskGatherInformation!INotifyUI", INotifyUI, pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &pcm ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_ClusterConnectionManager, hr );
        goto Cleanup;
    }

    // release promptly
    psp->Release();
    psp = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the object manager for the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieNode, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_StandardInfo, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_StandardInfo_QI, hr );
        goto Cleanup;
    }

    psi = TraceInterface( L"TaskGatherInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetName( &m_bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrNodeName );

    //
    //  Create progress message and tell the UI layer our progress
    //  for checking the node's cluster feasibility.
    //
    hr = THR( HrSendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Check_Node_Feasibility
                    , TASKID_Minor_Checking_Node_Cluster_Feasibility
                    , 0
                    , 2
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_CHECKING_NODE_CLUSTER_FEASIBILITY
                    , 0
                    ) );
    if ( FAILED( hr ) )
    {
        goto ClusterFeasibilityError;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the connection manager for a connection to the node.
    //

    hr = THRE( pcm->GetConnectionToObject( m_cookieNode, &punk ), HR_S_RPC_S_CLUSTER_NODE_DOWN );
    if ( hr != S_OK )
    {
        THR( HrSendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Check_Node_Feasibility
                    , TASKID_Minor_Checking_Node_Cluster_Feasibility
                    , 0
                    , 2
                    , 2
                    , hr
                    , IDS_TASKID_MINOR_FAILED_TO_CONNECT_TO_NODE
                    , 0
                    ) );
        //  don't care about error from here - we are returning an error.

        //
        //  If we failed to get a connection to the node, we delete the
        //  node from the configuration.
        //
        THR( m_pom->RemoveObject( m_cookieNode ) );
        // don't care if there is an error because we can't fix it!

        goto ClusterFeasibilityError;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &m_pccs ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetConnectionToObject_QI_m_pccs, hr );
        goto ClusterFeasibilityError;
    }

    punk->Release();
    punk = NULL;

    //
    //  Tell the UI layer we're done connecting to the node.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Check_Node_Feasibility,
                                TASKID_Minor_Checking_Node_Cluster_Feasibility,
                                0, // min
                                2, // max
                                1, // current
                                S_OK,
                                NULL,   // don't update string
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the node if it can be clustered.
    //

    hr = THR( m_pccs->TypeSafeQI( IClusCfgCapabilities, &pccc ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QI_pccc, hr );
        goto ClusterFeasibilityError;
    }

    hr = STHR( pccc->CanNodeBeClustered() );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_CanNodeBeClustered, hr );
        goto ClusterFeasibilityError;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Tell the UI layer that this node doesn't want to be clustered. Note that
        //  we don't put anything in the UI, only to the log. It is the responsibility
        //  of the "blocking" component to tell the UI layer the reasons.
        //

        hr = THR( HRESULT_FROM_WIN32( ERROR_NODE_CANNOT_BE_CLUSTERED ) );
        THR( SendStatusReport( m_bstrNodeName,
                                    TASKID_Major_Client_And_Server_Log,
                                    TASKID_Minor_Can_Node_Be_Clustered_Failed,
                                    0, // min
                                    1, // max
                                    1, // current
                                    hr,
                                    NULL,
                                    NULL
                                    ) );
        goto ClusterFeasibilityError;
    }

    //
    //  Tell the UI layer we're done checking the node's cluster feasibility.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Check_Node_Feasibility,
                                TASKID_Minor_Checking_Node_Cluster_Feasibility,
                                0, // min
                                2, // max
                                2, // current
                                S_OK,
                                NULL,   // don't update string
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Create progress message and tell the UI layer our progress
    //  for gathering managed resource info.
    //
    hr = THR( HrSendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Find_Devices
                    , TASKID_Minor_Gathering_Managed_Devices
                    , 0
                    , 2
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES
                    , 0
                    ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    hr = THR( m_pccs->GetManagedResourcesEnum( &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    hr = THR( m_pccs->GetNetworksEnum( &pen ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    hr = THR( HrTotalManagedResourceCount( peccmr, pen, &cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Start gathering the managed resources.
    //

    hr = THR( HrGatherResources( peccmr, cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    //
    //  Tell the UI layer we're done with gathering the resources.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0, // min
                                2, // max
                                1, // current
                                S_OK,
                                NULL,   // don't update string
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now gather the networks from the node.
    //

    hr = THR( HrGatherNetworks( pen, cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto FindResourcesError;
    }

    //
    //  Tell the UI layer we're done with gathering the networks.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0, // min
                                2, // max
                                2, // current
                                S_OK,
                                NULL,   // don't update string
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( m_pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punkTemp = NULL;

        hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                     m_cookieCompletion,
                                     &punkTemp
                                     ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psiTemp = NULL;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psiTemp ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psiTemp->SetStatus( hr ) );
                psiTemp->Release();
                psiTemp = NULL;
            }
            else
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_QI_Failed, hr );
            }
        }
        else
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_Failed, hr );
        }
    } // if: ( m_pom != NULL )
    if ( pnui != NULL )
    {
        THR( pnui->ObjectChanged( m_cookieCompletion ) );
        pnui->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }

    if ( peccmr != NULL )
    {
        peccmr->Release();
    }

    if ( pen != NULL )
    {
        pen->Release();
    }

    LogMsg( L"[MT] [CTaskGatherInformation] exiting task.  The task was%ws cancelled.", m_fStop == FALSE ? L" not" : L"" );

    HRETURN( hr );

ClusterFeasibilityError:

    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Check_Node_Feasibility,
                           TASKID_Minor_Checking_Node_Cluster_Feasibility,
                           0,
                           2,
                           2,
                           hr,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

FindResourcesError:
    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Find_Devices,
                           TASKID_Minor_Gathering_Managed_Devices,
                           0,
                           2,
                           2,
                           hr,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} //*** CTaskGatherInformation::BeginTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskGatherInformation] is being stopped." );

    HRETURN( hr );

} //*** CTaskGatherInformation::StopTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetCompletionCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetCompletionCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetCompletionCookie


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetNodeCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetNodeCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_cookieNode = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetNodeCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetJoining( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetJoining( void )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_fAdding = TRUE;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetJoining

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetMinimalConfiguration(
//      BOOL    fMinimalConfigurationIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetMinimalConfiguration(
    BOOL    fMinimalConfigurationIn
    )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_fMinConfig = fMinimalConfigurationIn;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetMinimalConfiguration


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SendStatusReport(
//      LPCWSTR pcszNodeNameIn,
//      CLSID clsidTaskMajorIn,
//      CLSID clsidTaskMinorIn,
//      ULONG ulMinIn,
//      ULONG ulMaxIn,
//      ULONG ulCurrentIn,
//      HRESULT hrStatusIn,
//      LPCWSTR pcszDescriptionIn,
//      LPCWSTR pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SendStatusReport(
      LPCWSTR pcszNodeNameIn
    , CLSID   clsidTaskMajorIn
    , CLSID   clsidTaskMinorIn
    , ULONG   ulMinIn
    , ULONG   ulMaxIn
    , ULONG   ulCurrentIn
    , HRESULT hrStatusIn
    , LPCWSTR pcszDescriptionIn
    , LPCWSTR pcszReferenceIn
    )
{
    TraceFunc( "" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CTaskGatherInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_pcccb = TraceInterface( L"CTaskGatherInformation!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    } // if: no IClusCfgCallback interface QI'd for yet

    GetSystemTimeAsFileTime( &ft );

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         pcszDescriptionIn,
                                         &ft,
                                         pcszReferenceIn
                                         ) );

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::SendStatusReport


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGatherInformation::HrGatherResources
//
//  Description:
//
//  Arguments:
//      pResourceEnumIn     -
//      cTotalResourcesIn   -
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrGatherResources(
      IEnumClusCfgManagedResources *    pResourceEnumIn
    , DWORD                             cTotalResourcesIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    ULONG                           celt;
    OBJECTCOOKIE                    cookieDummy;
    ULONG                           celtFetched        = 0;
    BSTR                            bstrName           = NULL;
    BSTR                            bstrNotification   = NULL;
    BOOL                            fFoundQuorumResource = FALSE;
    BOOL                            fFoundOptimalSizeQuorum = FALSE;
    BOOL                            fFoundQuorumCapablePartition = FALSE;
    BOOL                            fIsQuorumCapable = FALSE;
    BSTR                            bstrQuorumResourceName = NULL;
    IEnumClusCfgPartitions *        peccp  = NULL;
    IClusCfgManagedResourceInfo *   pccmriClientSide = NULL;
    IClusCfgManagedResourceInfo *   pccmriServerSide[ 10 ] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    HRESULT                         hrTemp;
    CLSID                           clsidMinorId;

    if ( pResourceEnumIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Error;
    }

    //
    //  Initialize some stuff.
    //

    m_ulQuorumDiskSize = ULONG_MAX;
    Assert( m_pccmriQuorum == NULL );

    THR( SendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Gather_Resources
                    , 0
                    , cTotalResourcesIn + 2
                    , 0
                    , S_OK
                    , NULL
                    , NULL
                    ) );
    //
    //  Enumerate the next 10 resources.
    //
    while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
    {
        //
        //  KB: GPease  27-JUL-2000
        //      We decided to enumerate one at a time because WMI is
        //      taking so long on the server side that the UI needs
        //      some kind of feedback. Having the server send a
        //      message back seemed to be expensive especially
        //      since grabbing 10 at a time was supposed to save
        //      us bandwidth on the wire.
        //
        //  KB: DavidP  24-JUL-2001
        //      According to GalenB, this is not longer an issue, since once
        //      the server has collected information for one resource, it has
        //      collected information for all of them.
        //

        hr = STHR( pResourceEnumIn->Next( 10, pccmriServerSide, &celtFetched ) );
        //hr = STHR( pResourceEnumIn->Next( 1, pccmriServerSide, &celtFetched ) );
        if ( ( hr == S_FALSE ) && ( celtFetched == 0 ) )
        {
            break;  // exit loop
        }

        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_Next, hr );
            goto Error;
        }

        //
        //  Loop thru the resource gather information out of each of them
        //  and then release them.
        //
        for ( celt = 0 ; ( ( celt < celtFetched ) && ( m_fStop == FALSE ) ); celt ++ )
        {
            UINT            uIdMessage = IDS_TASKID_MINOR_FOUND_RESOURCE;
            IGatherData *   pgd;
            IUnknown *      punk;

            Assert( pccmriServerSide[ celt ] != NULL );

            //  get the name of the resource
            hr = THR( pccmriServerSide[ celt ]->GetUID( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_GetUID, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            //  make sure the object manager generates a cookie for it.
            hr = STHR( m_pom->FindObject( CLSID_ManagedResourceType,
                                          m_cookieNode,
                                          bstrName,
                                          DFGUID_ManagedResource,
                                          &cookieDummy,
                                          &punk
                                          ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject, hr );
                goto Error;
            }

            TraceSysFreeString( bstrName );
            bstrName = NULL;

            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmriClientSide ) );
            punk->Release();       // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pccmriClientSide, hr );
                goto Error;
            }

            //
            //  The Object Manager created a new object. Initialize it.
            //

            //  Find the IGatherData interface.
            hr = THR( pccmriClientSide->TypeSafeQI( IGatherData, &pgd ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pgd, hr );
                goto Error;
            }

            //  Have the new object gather all information it needs.
            hr = THR( pgd->Gather( m_cookieNode, pccmriServerSide[ celt ] ) );
            pgd->Release();        // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_Gather, hr );
                goto Error;
            }

            //  Figure out if the resource is capable of being a quorum resource.
            hr = STHR( pccmriClientSide->IsQuorumCapable() );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_IsQuorumCapable, hr );
                goto Error;
            }

            if ( hr == S_OK )
            {
                uIdMessage = IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_RESOURCE;

                //
                //  If we aren't adding nodes, then figure out if this resource
                //  is a better quorum resource than one previously encountered.
                //

                //
                //  If minimal analysis and configuration was selected then we don't want to
                //  choose a quorum resource.
                //

                if ( ( m_fAdding == FALSE ) && ( m_fMinConfig == FALSE ) )
                {
                    ULONG   ulMegaBytes;

                    //  Don't wrap - this can fail with NO_INTERFACE.
                    hr = pccmriServerSide[ celt ]->TypeSafeQI( IEnumClusCfgPartitions, &peccp );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // We don't know if this resource is quorum capable, so this flag is set to FALSE right before the while loop
                        //
                        fIsQuorumCapable = FALSE;
                        while ( SUCCEEDED( hr ) )
                        {
                            ULONG                   celtDummy;
                            IClusCfgPartitionInfo * pccpi;

                            hr = STHR( peccp->Next( 1, &pccpi, &celtDummy ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_Next, hr );
                                goto Error;
                            }

                            if ( hr == S_FALSE )
                            {
                                break;  // exit condition
                            }

                            hr = THR( pccpi->GetSize( &ulMegaBytes ) );
                            pccpi->Release();      // release promptly
                            if ( FAILED( hr ) )
                            {
                                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetSize, hr );
                                goto Error;
                            }

                            //
                            //  This section below represents our quorum resource selection logic:
                            //  Does this partition meet the minimum requirements for a quorum resource?
                            //  And is it smaller than the last selected quorum resource?
                            //
                            if ( ( ulMegaBytes >= OPTIMUM_STORAGE_SIZE ) && ( ( ulMegaBytes < m_ulQuorumDiskSize ) || ( m_ulQuorumDiskSize < OPTIMUM_STORAGE_SIZE ) ) )
                            {
                                fFoundQuorumCapablePartition = TRUE;
                                fFoundOptimalSizeQuorum = TRUE;
                            } // if: partition meets optimum requirements
                            else if ( ( fFoundOptimalSizeQuorum == FALSE ) && ( ulMegaBytes >= MINIMUM_STORAGE_SIZE ) )
                            {
                                if ( ( fFoundQuorumResource == FALSE ) || ( ulMegaBytes >  m_ulQuorumDiskSize ) )
                                {
                                    fFoundQuorumCapablePartition = TRUE;
                                } // if: ( ( fFoundQuorumResource == FALSE ) || ( ulMegaBytes >  m_ulQuorumDiskSize ) )
                            } // else if: there is a partition that satisfies minimum requirements

                            //
                            // Per our quourum selection logic, if fFoundQuorumCapablePartition == TRUE, we select this resource to be the quorum.
                            //
                            if ( fFoundQuorumCapablePartition == TRUE )
                            {
                                fFoundQuorumCapablePartition = FALSE;
                                fFoundQuorumResource = TRUE;
                                if ( m_pccmriQuorum != pccmriClientSide )
                                {
                                    //  Set the new resource as quorum.
                                    hr = THR( pccmriClientSide->SetQuorumResource( TRUE ) );
                                    if ( FAILED( hr ) )
                                    {
                                        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetNEWQuorumedDevice, hr );
                                        goto Error;
                                    }

                                    if ( m_pccmriQuorum != NULL )
                                    {
                                        // Delete the old quorum resource name.
                                        TraceSysFreeString( bstrQuorumResourceName );
                                        bstrQuorumResourceName = NULL;

                                        //  Unset the old resource.
                                        hr = THR( m_pccmriQuorum->SetQuorumResource( FALSE ) );
                                        if ( FAILED( hr ) )
                                        {
                                            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetOLDQuorumedDevice, hr );
                                            goto Error;
                                        }

                                        //  Release the interface.
                                        m_pccmriQuorum->Release();
                                    }

                                    hr = THR( pccmriClientSide->GetUID( &bstrQuorumResourceName ) );
                                    if ( FAILED( hr ) )
                                    {
                                        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetUID, hr );
                                        goto Error;
                                    }

                                    TraceMemoryAddBSTR( bstrQuorumResourceName );

                                    m_pccmriQuorum = pccmriClientSide;
                                    m_pccmriQuorum->AddRef();
                                }

                                m_ulQuorumDiskSize = ulMegaBytes;
                            } // if: ( fFoundQuorumCapablePartition == TRUE )

                            //
                            // If any partition on this resource is larger than the minimum storage size, set fIsQuorumCapable to TRUE
                            //
                            if ( ulMegaBytes >= MINIMUM_STORAGE_SIZE )
                            {
                                fIsQuorumCapable = TRUE;
                            }

                        } // while: success

                        peccp->Release();
                        peccp = NULL;

                        //
                        // If there was no partition that met the minimum storage size, set this resource as NOT quorum capable.
                        //
                        if ( fIsQuorumCapable == FALSE )
                        {
                            hr = THR( pccmriClientSide->SetQuorumCapable( fIsQuorumCapable ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_SetQuorumCapable, hr );
                                goto Error;
                            }
                        }

                    } // if: partition capable
                    else
                    {
                        if ( hr != E_NOINTERFACE )
                        {
                            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_QI_peccp, hr );
                            THR( hr );
                            goto Error;
                        }
                    } // else: failed
                } // if: not joining
                else
                {
                    //
                    //  If we are adding, then a quorum resource had to be
                    //  found already.
                    //

                    //
                    //  BUGBUG: 08-MAY-2001 GalenB
                    //
                    //  We are not setting bstrQuorumResourceName to something
                    //  if we are adding.  This causes the message "Setting
                    //  quorum resource to '(NULL)' to appear in the logs and
                    //  the UI.  Where is the quorum when we are adding a node
                    //  to the cluster?
                    //
                    //  A more complete fix is to find the current quorum
                    //  resource and get its name.
                    //
                    fFoundQuorumResource = TRUE;

                } // else: joining
            } // if: quorum capable

            //  send the UI layer a report
            m_cResources ++;

            //  grab the name to display in the UI
            hr = THR( pccmriClientSide->GetName( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_GetName, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, uIdMessage, &bstrNotification, bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FormatMessage, hr );
                goto Error;
            }

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LogMsg( L"[MT] Could not create a guid for a managed resource minor task ID" );
                clsidMinorId = IID_NULL;
            } // if:

            //
            //  Show this resource under "Collecting Managed Resources..."
            //

            hr = THR( ::HrSendStatusReport(
                              m_pcccb
                            , m_bstrNodeName
                            , TASKID_Minor_Gathering_Managed_Devices
                            , clsidMinorId
                            , 1
                            , 1
                            , 1
                            , S_OK
                            , bstrNotification
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  Simply update the progress bar "tick".
            //

            hr = THR( SendStatusReport(
                              m_bstrNodeName
                            , TASKID_Major_Update_Progress
                            , TASKID_Major_Gather_Resources
                            , 0
                            , cTotalResourcesIn + 2
                            , m_cResources + 1
                            , S_OK
                            , NULL
                            , NULL
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //  Cleanup for the next resource.
            TraceSysFreeString( bstrName );
            bstrName = NULL;

            pccmriClientSide->Release();
            pccmriClientSide = NULL;

            //  release the interface
            pccmriServerSide[ celt ]->Release();
            pccmriServerSide[ celt ] = NULL;
        } // for: celt
    } // while: hr

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Update UI layer about the quorum resource.
    //

    //
    //  BUGUG:  08-MAY-2001 GalenB
    //
    //  Testing that bstrQuorumResourceName has something in it before showing
    //  this in the UI.  When adding nodes this variable is not being set and
    //  was causing a status report with a NULL name to be shown in the UI.
    //
    if ( fFoundQuorumResource == TRUE )
    {
        if ( bstrQuorumResourceName != NULL )
        {
            Assert( m_fAdding == FALSE );

            if ( fFoundOptimalSizeQuorum == TRUE )
            {
                //
                // Display a message in UI telling we found a quorum capable resource
                //
                THR( HrSendStatusReport(
                              m_bstrNodeName
                            , TASKID_Major_Find_Devices
                            , TASKID_Minor_Found_Quorum_Capable_Resource
                            , 1
                            , 1
                            , 1
                            , S_OK
                            , IDS_TASKID_MINOR_FOUND_A_QUORUM_CAPABLE_RESOURCE
                            , 0
                            ) );

            } // if: optimal size quorum resource found
            else
            {
                TraceSysFreeString( bstrNotification );
                bstrNotification = NULL;
                THR( HrFormatStringIntoBSTR(
                              g_hInstance
                            , IDS_TASKID_MINOR_FOUND_MINIMUM_SIZE_QUORUM_CAPABLE_RESOURCE
                            , &bstrNotification
                            , bstrQuorumResourceName
                            ) );

                //
                // Display a warning in UI since we found a minimum size quorum resource
                //
                hr = THR( SendStatusReport(
                              m_bstrNodeName
                            , TASKID_Major_Find_Devices
                            , TASKID_Minor_Found_Minimum_Size_Quorum_Capable_Resource
                            , 1
                            , 1
                            , 1
                            , S_FALSE
                            , bstrNotification
                            , 0
                            ) );

            } // minimum size quorum resource found

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;

            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_MARKING_QUORUM_CAPABLE_RESOURCE, &bstrNotification, bstrQuorumResourceName ) );
            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Marking_Quorum_Capable_Resource,
                                        1,
                                        1,
                                        1,
                                        S_OK,
                                        bstrNotification,
                                        NULL
                                        ) );

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;

        } // if: we have a quorum resource to show
    } // if: found a quorum resource
    else
    {
        if ( m_fAdding == TRUE )
        {
            //
            //  If adding, stop the user.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_NO_QUORUM_CAPABLE_RESOURCE_FOUND,
                                               &bstrNotification,
                                               m_bstrNodeName
                                               ) );

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Quorum_Capable_Device_Found,
                                        1,
                                        1,
                                        1,
                                        HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) ),
                                        bstrNotification,
                                        NULL
                                        ) );

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;
            // error checked below
        } // if: adding nodes
        else
        {
            //
            //  If creating, just warn the user.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM,
                                               &bstrNotification
                                               ) );

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Quorum_Capable_Device_Found,
                                        1,
                                        1,
                                        1,
                                        MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_QUORUM_DISK_NOT_FOUND ),
                                        bstrNotification,
                                        NULL
                                        ) );

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;

            // error checked below
        } // else: creating a cluster
    } // else: no quorum detected.

    //
    //  Check error and do the appropriate thing.
    //

    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    THR( SendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Gather_Resources
                    , 0
                    , cTotalResourcesIn + 2
                    , cTotalResourcesIn + 2
                    , S_OK
                    , NULL
                    , NULL
                    ) );

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrQuorumResourceName );

    if ( peccp != NULL )
    {
        peccp->Release();
    }
    if ( pccmriClientSide != NULL )
    {
        pccmriClientSide->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccmriServerSide[ celt ] != NULL )
        {
            pccmriServerSide[ celt ]->Release();
        }
    } // for: celt

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer we're done will gathering and what the resulting
    //  status was.
    //
    THR( HrSendStatusReport(
                  m_bstrNodeName
                , TASKID_Major_Find_Devices
                , TASKID_Minor_Gathering_Managed_Devices
                , 0
                , 2
                , 2
                , hr
                , IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE
                , 0
                ) );
    goto Cleanup;

} //*** CTaskGatherInformation::HrGatherResources

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGatherInformation::HrGatherNetworks
//
//  Description:
//
//  Arguments:
//      pNetworkEnumIn      -
//      cTotalNetworksIn    -
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrGatherNetworks(
      IEnumClusCfgNetworks *    pNetworkEnumIn
    , DWORD                     cTotalNetworksIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    ULONG                   celt;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   celtFetched      = 0;
    ULONG                   celtFound        = 0;
    BSTR                    bstrUID          = NULL;
    BSTR                    bstrName         = NULL;
    BSTR                    bstrNotification = NULL;
    IClusCfgNetworkInfo *   pccniLocal   = NULL;
    IClusCfgNetworkInfo *   pccni[ 10 ]  = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    HRESULT                 hrTemp;
    CLSID                   clsidMinorId;

    hr = THR( SendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Gather_Networks
                    , 0
                    , cTotalNetworksIn + 2
                    , 0
                    , S_OK
                    , NULL
                    , NULL
                    ) );
    //
    //  Enumerate the next 10 networks.
    //
    while ( ( hr == S_OK ) && ( m_fStop == FALSE ) )
    {
        //
        //  KB: GPease  27-JUL-2000
        //      We decided to enumerate one at a time because WMI is
        //      taking so long on the server side that the UI needs
        //      some kind of feedback. Having the server send a
        //      message back seemed to be expensive especially
        //      since grabbing 10 at a time was supposed to save
        //      us bandwidth on the wire.
        //
        //  KB: DavidP  24-JUL-2001
        //      According to GalenB, this is no longer an issue, since once
        //      the server has collected information for one network, it has
        //      collected information for all of them.
        //
        hr = STHR( pNetworkEnumIn->Next( 10, pccni, &celtFetched ) );
        //hr = STHR( pNetworkEnumIn->Next( 1, pccni, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
        {
            break;  // exit loop
        }

        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_Next, hr );
            goto Error;
        }

        //
        //  Loop thru the networks gather information out of each of them
        //  and then release them.
        //
        for ( celt = 0 ; ( ( celt < celtFetched ) && ( m_fStop == FALSE ) ); celt ++ )
        {
            IGatherData *   pgd;
            IUnknown *      punk;

            Assert( pccni[ celt ] != NULL );

            //  Get the UID of the network.
            hr = THR( pccni[ celt ]->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_GetUID, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrUID );

            //  Get the Name of the network.
            hr = THR( pccni[ celt ]->GetName( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_GetName, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            //  Make sure the object manager generates a cookie for it.
            hr = STHR( m_pom->FindObject( CLSID_NetworkType,
                                          m_cookieNode,
                                          bstrUID,
                                          DFGUID_NetworkResource,
                                          &cookieDummy,
                                          &punk
                                          ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject, hr );
                goto Error;
            }

            //
            //  The Object Manager created a new object. Initialize it.
            //

            //  Find the IGatherData interface
            hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &pccniLocal ) );
            punk->Release();       // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pccniLocal, hr );
                goto Error;
            }

            //  Find the IGatherData interface
            hr = THR( pccniLocal->TypeSafeQI( IGatherData, &pgd ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pgd, hr );
                goto Error;
            }

            //  Have the new object gather all information it needs
            hr = THR( pgd->Gather( m_cookieNode, pccni[ celt ] ) );
            pgd->Release();        // release promptly
            if ( hr == E_UNEXPECTED )
            {
                //
                // Add the parent item.
                //

                hr = THR( HrSendStatusReport(
                                      m_bstrNodeName
                                    , TASKID_Major_Find_Devices
                                    , TASKID_Minor_Not_Managed_Networks
                                    , 1
                                    , 1
                                    , 1
                                    , S_OK
                                    , IDS_INFO_NOT_MANAGED_NETWORKS
                                    , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                                    ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                //
                // Construct the description string and get a GUID for the
                // minor ID.
                //

                hrTemp = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND, &bstrNotification, bstrName ) );
                if ( FAILED( hrTemp ) )
                {
                    SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage, hrTemp );
                    if ( bstrNotification != NULL )
                    {
                        TraceSysFreeString( bstrNotification );
                        bstrNotification = NULL;
                    }
                } // if: failed to format message

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LogMsg( L"[MT] Could not create a guid for a managed network minor task ID." );
                    clsidMinorId = IID_NULL;
                } // if:

                //
                // Send the specific report.
                //

                hr = THR( HrSendStatusReport(
                                      m_bstrNodeName
                                    , TASKID_Minor_Not_Managed_Networks
                                    , clsidMinorId
                                    , 1
                                    , 1
                                    , 1
                                    , S_OK
                                    , bstrNotification != NULL ? bstrNotification : L"An adapter with a duplicate IP address and subnet was found."
                                    , IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND_REF
                                    ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                TraceSysFreeString( bstrNotification );
                bstrNotification = NULL;

                //
                //  Simply update the progress bar "tick".
                //

                hr = THR( SendStatusReport(
                                  m_bstrNodeName
                                , TASKID_Major_Update_Progress
                                , TASKID_Major_Gather_Networks
                                , 0
                                , cTotalNetworksIn + 2
                                , m_cResources + 2 // the resource number it would have been
                                , S_OK
                                , L"An adapter with a duplicate IP address and subnet was found."
                                , NULL
                                ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                // Ignore the error since the cluster will just ignore
                // duplicate networks.
                hr = S_OK;
                goto CleanupLoop;
            } // if: GatherData returned E_UNEXPECTED
            else if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_Gather, hr );
                goto Error;
            }

            m_cResources ++;

            //
            //  Send the UI layer a report
            //

            hrTemp = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FOUND_NETWORK, &bstrNotification, bstrName ) );
            if ( FAILED( hrTemp ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage, hrTemp );
                if ( bstrNotification != NULL )
                {
                    TraceSysFreeString( bstrNotification );
                    bstrNotification = NULL;
                }
            } // if: failed to format message

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LogMsg( L"[MT] Could not create a guid for a managed network minor task ID." );
                clsidMinorId = IID_NULL;
            } // if: failed to create a new guid

            //
            //  Show this network under "Collecting Managed Resources..."
            //

            hr = THR( ::HrSendStatusReport(
                              m_pcccb
                            , m_bstrNodeName
                            , TASKID_Minor_Gathering_Managed_Devices
                            , clsidMinorId
                            , 1
                            , 1
                            , 1
                            , S_OK
                            , bstrNotification != NULL ? bstrNotification : L"The description for this entry could not be located."
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;

            //
            //  Simply update the progress bar "tick".
            //

            hr = THR( SendStatusReport(
                              m_bstrNodeName
                            , TASKID_Major_Update_Progress
                            , TASKID_Major_Gather_Networks
                            , 0
                            , cTotalNetworksIn + 2
                            , m_cResources + 1
                            , S_OK
                            , NULL
                            , NULL
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //  Found a Network Interface, increment the counter
            celtFound++;

CleanupLoop:

            //  Clean up before next pass
            TraceSysFreeString( bstrUID );
            TraceSysFreeString( bstrName );
            bstrUID = NULL;
            bstrName = NULL;

            //  Release the interface
            pccni[ celt ]->Release();
            pccni[ celt ] = NULL;

            pccniLocal->Release();
            pccniLocal = NULL;

        } // for: each network
    } // while: hr

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    // Check how many interfaces have been found. Should be at
    // least 2 to avoid single point of failure. If not, warn.
    if ( celtFound < 2 )
    {
        hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_ONLY_ONE_NETWORK, &bstrNotification ) );
        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage, hr );
            goto Error;
        }

        hr = THR( SendStatusReport( m_bstrNodeName,
                                    TASKID_Major_Find_Devices,
                                    TASKID_Minor_Only_One_Network,
                                    1,
                                    1,
                                    1,
                                    S_FALSE,
                                    bstrNotification,
                                    NULL
                                    ) );
        TraceSysFreeString( bstrNotification );
        bstrNotification = NULL;

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: fewer than two networks found

    hr = S_OK;

Cleanup:

    hr = THR( SendStatusReport(
                      m_bstrNodeName
                    , TASKID_Major_Update_Progress
                    , TASKID_Major_Gather_Networks
                    , 0
                    , cTotalNetworksIn + 2
                    , cTotalNetworksIn + 2 
                    , S_OK
                    , NULL
                    , NULL
                    ) );

    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( pccniLocal != NULL )
    {
        pccniLocal->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccni[ celt ] != NULL )
        {
            pccni[ celt ]->Release();
        }
    } // for: celt

    HRETURN( hr );

Error:

    //
    //  Tell the UI layer we're done will gathering and what the resulting
    //  status was.
    //
    THR( HrSendStatusReport(
                  m_bstrNodeName
                , TASKID_Major_Find_Devices
                , TASKID_Minor_Gathering_Managed_Devices
                , 0
                , 2
                , 2
                , hr
                , IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE
                , 0
                ) );
    goto Cleanup;

} //*** CTaskGatherInformation::HrGatherNetworks

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::HrSendStatusReport(
//        LPCWSTR   pcszNodeNameIn
//      , CLSID     clsidMajorIn
//      , CLSID     clsidMinorIn
//      , ULONG     ulMinIn
//      , ULONG     ulMaxIn
//      , ULONG     ulCurrentIn
//      , HRESULT   hrIn
//      , int       idsDescriptionIdIn
//      , int       idsReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrSendStatusReport(
      LPCWSTR   pcszNodeNameIn
    , CLSID     clsidMajorIn
    , CLSID     clsidMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrIn
    , int       idsDescriptionIdIn
    , int       idsReferenceIdIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;
    BSTR    bstrReference = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsDescriptionIdIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( idsReferenceIdIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsReferenceIdIn, &bstrReference ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if: reference ID was specified

    hr = THR( SendStatusReport( pcszNodeNameIn, clsidMajorIn, clsidMinorIn, ulMinIn, ulMaxIn, ulCurrentIn, hrIn, bstrDescription, bstrReference ) );

Cleanup:

    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );

    HRETURN( hr );

} //*** CTaskGatherInformation::HrSendStatusReport( idsDescriptionIn )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::HrSendStatusReport(
//        LPCWSTR   pcszNodeNameIn
//      , CLSID     clsidMajorIn
//      , CLSID     clsidMinorIn
//      , ULONG     ulMinIn
//      , ULONG     ulMaxIn
//      , ULONG     ulCurrentIn
//      , HRESULT   hrIn
//      , LPCWSTR   pcszDescriptionIdIn
//      , int       idsReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrSendStatusReport(
      LPCWSTR   pcszNodeNameIn
    , CLSID     clsidMajorIn
    , CLSID     clsidMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrIn
    , LPCWSTR   pcszDescriptionIdIn
    , int       idsReferenceIdIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrReference = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsReferenceIdIn, &bstrReference ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SendStatusReport( pcszNodeNameIn, clsidMajorIn, clsidMinorIn, ulMinIn, ulMaxIn, ulCurrentIn, hrIn, pcszDescriptionIdIn, bstrReference ) );

Cleanup:

    TraceSysFreeString( bstrReference );

    HRETURN( hr );

} //*** CTaskGatherInformation::HrSendStatusReport( pcszDescription )


//****************************************************************************
//
//  Static function implementations
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrTotalManagedResourceCount
//
//  Description:
//
//  Arguments:
//      pResourceEnumIn -
//      pNetworkEnumIn  -
//      pnCountOut      -
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrTotalManagedResourceCount(
      IEnumClusCfgManagedResources *    pResourceEnumIn
    , IEnumClusCfgNetworks *            pNetworkEnumIn
    , DWORD *                           pnCountOut
    )
{
    TraceFunc( "" );

    DWORD   cResources = 0;
    DWORD   cNetworks = 0;
    HRESULT hr = S_OK;

    if ( ( pResourceEnumIn == NULL ) || ( pNetworkEnumIn == NULL ) || ( pnCountOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Ask the resource enumerator how many resources its collection has.
    //

    hr = THR(pResourceEnumIn->Count( &cResources ));
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the network enumerator how many networks its collection has.
    //

    hr = pNetworkEnumIn->Count( &cNetworks );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pnCountOut = cResources + cNetworks;

Cleanup:

    HRETURN( hr );

} //*** HrTotalManagedResourceCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgathernodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherNodeInfo.h
//
//  Description:
//      CTaskGatherNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherNodeInfo
class CTaskGatherNodeInfo
    : public ITaskGatherNodeInfo
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    //  IDoTask / ITaskGatherNodeInfo
    OBJECTCOOKIE        m_cookie;           //  Cookie to the Node
    OBJECTCOOKIE        m_cookieCompletion; //  Cookie to signal when task is completed
    BSTR                m_bstrName;         //  Name of the node
    BOOL                m_fStop;
    BOOL                m_fUserAddedNode; // new node being added or existing cluster node

    //  IClusCfgCallback
    IClusCfgCallback *  m_pcccb;            //  Marshalled callback interface

    CTaskGatherNodeInfo( void );
    ~CTaskGatherNodeInfo( void );

    // Private copy constructor to prevent copying.
    CTaskGatherNodeInfo( const CTaskGatherNodeInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskGatherNodeInfo & operator = ( const CTaskGatherNodeInfo & nodeSrc );

    STDMETHOD( HrInit )( void );
    HRESULT HrSendStatusReport( LPCWSTR pcszNodeNameIn, CLSID clsidMajorIn, CLSID clsidMinorIn, ULONG ulMinIn, ULONG ulMaxIn, ULONG ulCurrentIn, HRESULT hrIn, int nDescriptionIdIn, int nReferenceIdIn = 0 );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IDoTask / ITaskGatherNodeInfo
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetUserAddedNodeFlag )( BOOL fUserAddedNodeIn );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** class CTaskGatherNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      TaskGatherInformation.h
//
//  Description:
//      CTaskGatherInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherInformation
class CTaskGatherInformation
    : public ITaskGatherInformation
{
private:
    // IUnknown
    LONG                            m_cRef;

    // IDoTask / ITaskGatherInformation
    OBJECTCOOKIE                    m_cookieCompletion;     //  Cookie to signal when task is completed.
    OBJECTCOOKIE                    m_cookieNode;           //  Cookie of the node to gather from.
    IClusCfgCallback *              m_pcccb;                //  Marshalled UI Layer callback
    BOOL                            m_fAdding;              //  If the node is to be added to a cluster...
    ULONG                           m_cResources;           //  Resource counter

    IObjectManager *                m_pom;                  //  Object manager
    IClusCfgServer *                m_pccs;                 //  ClusCfgServer
    BSTR                            m_bstrNodeName;         //  Hostname of the node

    ULONG                           m_ulQuorumDiskSize;     //  Size of the selected quorum resource
    IClusCfgManagedResourceInfo *   m_pccmriQuorum;         //  Punk to the MT quorum resource object
    BOOL                            m_fStop;
    BOOL                            m_fMinConfig;           // Was minimal configuration selected?

    CTaskGatherInformation( void );
    ~CTaskGatherInformation( void );

    // Private copy constructor to prevent copying.
    CTaskGatherInformation( const CTaskGatherInformation & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskGatherInformation & operator = ( const CTaskGatherInformation & nodeSrc );

    STDMETHOD( HrInit )( void );

    HRESULT HrGatherResources( IEnumClusCfgManagedResources * pResourceEnumIn, DWORD cTotalResourcesIn );
    HRESULT HrGatherNetworks( IEnumClusCfgNetworks * pNetworkEnumIn, DWORD cTotalResourcesIn );
    HRESULT HrSendStatusReport(
                  LPCWSTR pcszNodeNameIn
                , CLSID clsidMajorIn
                , CLSID clsidMinorIn
                , ULONG ulMinIn
                , ULONG ulMaxIn
                , ULONG ulCurrentIn
                , HRESULT hrIn
                , int idsDescriptionIn
                , int idsReferenceIdIn
                );

    HRESULT HrSendStatusReport(
                  LPCWSTR pcszNodeNameIn
                , CLSID clsidMajorIn
                , CLSID clsidMinorIn
                , ULONG ulMinIn
                , ULONG ulMaxIn
                , ULONG ulCurrentIn
                , HRESULT hrIn
                , LPCWSTR pcszDescriptionIn
                , int idsReferenceIdIn
                );

    STDMETHOD( SendStatusReport )(
                      LPCWSTR  pcszNodeNameIn
                    , CLSID    clsidTaskMajorIn
                    , CLSID    clsidTaskMinorIn
                    , ULONG    ulMinIn
                    , ULONG    ulMaxIn
                    , ULONG    ulCurrentIn
                    , HRESULT  hrStatusIn
                    , LPCWSTR  pcszDescriptionIn
                    , LPCWSTR  pcszReferenceIn
                    );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGatherInformation
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetNodeCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetJoining )( void );
    STDMETHOD( SetMinimalConfiguration )( BOOL fMinimalConfigIn );

}; //*** class CTaskGatherInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgetdomains.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGetDomains.cpp
//
//  Description:
//      Get DNS/NetBIOS Domain Names for the list of domains.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusCfgClient.h"
#include "TaskGetDomains.h"

// ADSI support, to get domain names
#include <Lm.h>
#include <Dsgetdc.h>

DEFINE_THISCLASS("CTaskGetDomains")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CTaskGetDomains *   ptgd = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptgd = new CTaskGetDomains;
    if ( ptgd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptgd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptgd->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );

Cleanup:

    if ( ptgd != NULL )
    {
        ptgd->Release();
    }

    HRETURN( hr );

} //*** CTaskGetDomains::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGetDomains::CTaskGetDomains
//
//////////////////////////////////////////////////////////////////////////////

CTaskGetDomains::CTaskGetDomains( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGetDomains::CTaskGetDomains

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // ITaskGetDomains
    Assert( m_pStream == NULL );
    Assert( m_ptgdcb == NULL );

    if ( InitializeCriticalSectionAndSpinCount( &m_csCallback, RECOMMENDED_SPIN_COUNT ) == 0 )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
    }

    HRETURN( hr );

} //*** CTaskGetDomains::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGetDomains::~CTaskGetDomains
//
//////////////////////////////////////////////////////////////////////////////

CTaskGetDomains::~CTaskGetDomains( void )
{
    TraceFunc( "" );

    if ( m_pStream != NULL)
    {
        m_pStream->Release();
    }

    if ( m_ptgdcb != NULL )
    {
        m_ptgdcb->Release();
    }

    DeleteCriticalSection( &m_csCallback );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGetDomains::~CTaskGetDomains

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGetDomains::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGetDomains * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomains ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGetDomains, this, 0 );
    } // else if: ITaskGetDomains
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ( (IUnknown *) *ppvOut )->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGetDomains::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGetDomains::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGetDomains::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskGetDomains::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGetDomains::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGetDomains::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskGetDomains::Release

// ************************************************************************
//
// IDoTask / ITaskGetDomains
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::BeginTask(void);
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;
    ULONG   ulLen;
    DWORD   dwRes;
    ULONG   idx;

    PDS_DOMAIN_TRUSTS paDomains = NULL;

    hr = THR( HrUnMarshallCallback() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Enumerate the list of Domains
    //
    dwRes = TW32( DsEnumerateDomainTrusts( NULL,
                                           DS_DOMAIN_VALID_FLAGS,
                                           &paDomains,
                                           &ulLen
                                           ) );

    //
    // Might return ERROR_NOT_SUPPORTED if the DC is pre-W2k
    // In that case, retry in compatible mode
    //
    if ( dwRes == ERROR_NOT_SUPPORTED )
    {
        dwRes = TW32( DsEnumerateDomainTrusts( NULL,
                                               DS_DOMAIN_VALID_FLAGS & ( ~DS_DOMAIN_DIRECT_INBOUND),
                                               &paDomains,
                                               &ulLen
                                               ) );
    } // if:
    if ( dwRes != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwRes );
        goto Cleanup;
    }

    //
    //  Pass the information to the UI layer.
    //
    for ( idx = 0; idx < ulLen; idx++ )
    {
        if ( paDomains[ idx ].DnsDomainName != NULL )
        {
            if ( m_ptgdcb != NULL )
            {
                BSTR bstrDomainName = TraceSysAllocString( paDomains[ idx ].DnsDomainName );
                if ( bstrDomainName == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }

                hr = THR( ReceiveDomainName( bstrDomainName ) );

                // check error after freeing string
                TraceSysFreeString( bstrDomainName );

                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }
            else
            {
                break;
            }
        }
        else if ( paDomains[ idx ].NetbiosDomainName != NULL )
        {
            if ( m_ptgdcb != NULL )
            {
                BSTR bstrDomainName = TraceSysAllocString( paDomains[ idx ].NetbiosDomainName );
                if ( bstrDomainName == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }

                // send data
                hr = THR( ReceiveDomainName( bstrDomainName ) );

                TraceSysFreeString( bstrDomainName );

                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }
        }
    }

    hr = S_OK;

Cleanup:
    if ( paDomains != NULL )
    {
        NetApiBufferFree( paDomains );
    }

    HRETURN( hr );

} //*** CTaskGetDomains::BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::SetCallback(
//      ITaskGetDomainsCallback * punkIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::SetCallback(
    ITaskGetDomainsCallback * punkIn
    )
{
    TraceFunc( "[ITaskGetDomains]" );

    HRESULT hr = S_FALSE;

    if ( punkIn != NULL )
    {
        EnterCriticalSection( &m_csCallback );

        hr = THR( CoMarshalInterThreadInterfaceInStream( IID_ITaskGetDomainsCallback,
                                                         punkIn,
                                                         &m_pStream
                                                         ) );

        LeaveCriticalSection( &m_csCallback );

    }
    else
    {
        hr = THR( HrReleaseCurrentCallback() );
    }

    HRETURN( hr );

} //*** CTaskGetDomains::SetCallback


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::HrReleaseCurrentCallback( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::HrReleaseCurrentCallback( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    EnterCriticalSection( &m_csCallback );

    if ( m_pStream != NULL )
    {
        hr = THR( CoUnmarshalInterface( m_pStream,
                                        TypeSafeParams( ITaskGetDomainsCallback, &m_ptgdcb )
                                        ) );

        m_pStream->Release();
        m_pStream = NULL;
    }

    if ( m_ptgdcb != NULL )
    {
        m_ptgdcb->Release();
        m_ptgdcb = NULL;
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} //*** CTaskGetDomains::HrReleaseCurrentCallback

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::HrUnMarshallCallback( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::HrUnMarshallCallback( void )
{
    TraceFunc( "" );

    HRESULT hr;

    EnterCriticalSection( &m_csCallback );

    hr = THR( CoUnmarshalInterface( m_pStream,
                                    TypeSafeParams( ITaskGetDomainsCallback, &m_ptgdcb )
                                    ) );

    m_pStream->Release();
    m_pStream = NULL;

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} //*** CTaskGetDomains::HrUnMarshallCallback


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClusDomainPage::ReceiveDomainResult(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    EnterCriticalSection( &m_csCallback );

    if ( m_ptgdcb != NULL )
    {
        hr = THR( m_ptgdcb->ReceiveDomainResult( hrIn ) );
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} //*** CTaskGetDomains::ReceiveResult

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::ReceiveDomainName(
//      BSTR bstrDomainNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::ReceiveDomainName(
    BSTR bstrDomainNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    EnterCriticalSection( &m_csCallback );

    if ( m_ptgdcb != NULL )
    {
        hr = THR( m_ptgdcb->ReceiveDomainName( bstrDomainNameIn ) );
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} //*** CTaskGetDomains::ReceiveDomainName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgathernodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherNodeInfo.cpp
//
//  Description:
//      CTaskGatherNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskGatherNodeInfo.h"
#include <Lm.h>
#include <LmJoin.h>

DEFINE_THISCLASS("CTaskGatherNodeInfo")

//
//  Failure code.
//

#define SSR_FAILURE( _minor, _hr ) THR( SendStatusReport( m_bstrName, TASKID_Major_Client_And_Server_Log, _minor, 0, 1, 1, _hr, NULL, NULL, NULL ) );

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherNodeInfo::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherNodeInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CTaskGatherNodeInfo *   ptgni = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptgni = new CTaskGatherNodeInfo;
    if ( ptgni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptgni->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptgni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // This gets passed to other threads.
    TraceMoveToMemoryList( ptgni, g_GlobalMemoryList );

Cleanup:

    if ( ptgni != NULL )
    {
        ptgni->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherNodeInfo::CTaskGatherNodeInfo
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherNodeInfo::CTaskGatherNodeInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherNodeInfo::CTaskGatherNodeInfo

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( m_cRef == 1 );

    //  IDoTask / ITaskGatherNodeInfo
    Assert( m_cookie == NULL );
    Assert( m_cookieCompletion == NULL );
    Assert( m_bstrName == NULL );

    //  IClusCfgCallback
    Assert( m_pcccb == NULL );

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherNodeInfo::~CTaskGatherNodeInfo
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherNodeInfo::~CTaskGatherNodeInfo( void )
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    TraceSysFreeString( m_bstrName );

    //
    //  This keeps the per thread memory tracking from screaming.
    //
    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherNodeInfo::~CTaskGatherNodeInfo


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskGatherNodeInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGatherNodeInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_ITaskGatherNodeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGatherNodeInfo, this, 0 );
    } // else if: ITaskGatherNodeInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGatherNodeInfo::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherNodeInfo::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskGatherNodeInfo::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherNodeInfo::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskGatherNodeInfo::Release


// ************************************************************************
//
// IDoTask / ITaskGatherNodeInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    OBJECTCOOKIE                cookieParent;
    BSTR                        bstrNotification = NULL;
    BSTR                        bstrDisplayName = NULL;
    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    IConnectionManager *        pcm   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgServer *            pccs  = NULL;
    IGatherData *               pgd   = NULL;
    IStandardInfo *             psi   = NULL;

    TraceInitializeThread( L"TaskGatherNodeInfo" );

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_CoCreate_ServiceManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_QS_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &pcm ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_QS_ConnectionManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_QS_NotificationManager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskGatherNodeInfo!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_FindConnectionPoint_QI, hr );
        goto Cleanup;
    }

    pnui = TraceInterface( L"CTaskGatherNodeInfo!INotifyUI", INotifyUI, pnui, 1 );

    // release promptly
    psp->Release();
    psp = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the node's standard info.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo, m_cookie, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo_QI_psi, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    psi = TraceInterface( L"TaskGatherNodeInfo!IStandardInfo", IStandardInfo, psi, 1 );

    //
    //  Get the node's name to display a status message.
    //

    hr = THR( psi->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrName );

    hr = STHR( HrGetFQNDisplayName( m_bstrName, &bstrDisplayName ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetName, hr );
        goto Cleanup;
    } // if:

    //
    //  Create a progress message.
    //
    //  Tell the UI layer what's going on.
    //

    hr = THR( HrSendStatusReport(
                      m_bstrName
                    , TASKID_Major_Establish_Connection
                    , TASKID_Minor_Connecting
                    , 0
                    , 1
                    , 0
                    , S_OK
                    , IDS_TASKID_MINOR_CONNECTING_TO_NODES
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Ask the Connection Manager for a connection to the object.
    //

    hr = pcm->GetConnectionToObject( m_cookie, &punk );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        goto Cleanup;
    }

    if ( ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE ) || FAILED( hr ) )
    {
        LPWSTR                  pszNameBuffer = NULL;
        NETSETUP_JOIN_STATUS    JoinType;
        NET_API_STATUS          naps = NERR_Success;

        //
        //  test domain membership
        //

        naps = NetGetJoinInformation( bstrDisplayName, &pszNameBuffer, &JoinType );

        //
        //  We are using bstrDisplayName instead of a full DNS name in the code above,
        //  since machine that is a workgroup member might have only NETBIOS name only
        //

        LogMsg( L"%ws: Test domain membership, %d.", bstrDisplayName, naps );

        if ( naps == NERR_Success )
        {
            if ( JoinType == NetSetupDomainName )
            {
                LogMsg( L"%ws is a member of a domain.", m_bstrName );
            }
            else
            {
                // not a member of the domain
                naps = ERROR_ACCESS_DENIED;
            }

            NetApiBufferFree( pszNameBuffer );
        } // if: NetGetJoinInformation failed

        if ( naps == ERROR_ACCESS_DENIED )
        {
            LogMsg( L"%ws is not a member of a domain.", m_bstrName );

            //
            //  verify that the node is a member of the domain
            //

            HRESULT reportHr = THR( HRESULT_FROM_WIN32( ERROR_NO_SUCH_DOMAIN ) );
            THR( HrSendStatusReport( m_bstrName,
                                   TASKID_Major_Establish_Connection,
                                   TASKID_Minor_Check_Domain_Membership,
                                   0,
                                   1,
                                   1,
                                   reportHr,
                                   IDS_TASKID_MINOR_CHECK_DOMAIN_MEMBERSHIP,
                                   IDS_TASKID_MINOR_CHECK_DOMAIN_MEMBERSHIP_ERROR_REF
                                   ) );
        } // if: failed with ACCESS_DENIED
    }// if: GetConnectionToObject failed

    if ( FAILED( hr ) )
    {
        THR( hr );
        SSR_FAILURE( TASKID_Minor_BeginTask_GetConnectionToObject, hr );
        goto Cleanup;
    }

    //
    //  If this comes up from a Node, this is bad so change the error code
    //  back and bail.
    //

    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        //
        //  Commented out as a fix for bug #543135 [GorN 4/11/2002]
        //

        if ( m_fUserAddedNode )
        {
            //
            //  If it is user entered node the error is fatal.
            //

            hr = THR( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) );
        }

        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetConnectionToObject_QI_pccs, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetClusterNodeInfo, hr );
        goto Cleanup;
    }

    //
    //  Ask the Object Manager to retrieve the data format to store the information.
    //

    hr = THR( pom->GetObject( DFGUID_NodeInformation, m_cookie, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetObject_NodeInformation, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetObject_NodeInformation_QI_pgd, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Find out our parent.
    //

    hr = THR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetParent, hr );
        goto Cleanup;
    }

    if ( m_fStop == TRUE )
    {
        goto Cleanup;
    } // if:

    //
    //  Start sucking.
    //

    hr = THR( pgd->Gather( cookieParent, pccni ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_Gather, hr );
        //
        //  Don't goto cleanup - we need to single that the information possibly changed.
        //
    }

    //
    //  At this point, we don't care if the "Gather" succeeded or failed. We
    //  need to single that the object potentially changed.
    //
    THR( pnui->ObjectChanged( m_cookie ) );

Cleanup:
    //  Tell the UI layer we are done and the results of what was done.
    THR( SendStatusReport( m_bstrName,
                           TASKID_Major_Establish_Connection,
                           TASKID_Minor_Connecting,
                           0,
                           1,
                           1,
                           hr,
                           NULL,
                           NULL,
                           NULL
                           ) );
    //  don't care about errors from SSR at this point

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcm != NULL )
    {
        pcm->Release();
    }

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pom != NULL )
    {
        //
        //  Update the cookie's status indicating the result of our task.
        //

        IUnknown * punkTemp = NULL;
        HRESULT hr2;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo, m_cookie, &punkTemp ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psiTemp = NULL;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psiTemp ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
//                if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
//                {
//                    hr = HRESULT_FROM_WIN32( ERROR_CLUSTER_NODE_DOWN );
//                }

                hr2 = THR( psiTemp->SetStatus( hr ) );
                psiTemp->Release();
                psiTemp = NULL;
            }
        }

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punkTemp ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psiTemp = NULL;

            hr2 = THR( punkTemp->TypeSafeQI( IStandardInfo, &psiTemp ) );
            punkTemp->Release();
            punkTemp = NULL;

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psiTemp->SetStatus( hr ) );
                psiTemp->Release();
                psiTemp = NULL;
            }
        }

        pom->Release();
    } // if: ( pom != NULL )
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pnui != NULL )
    {
        if ( m_cookieCompletion != 0 )
        {
            //
            //  Signal the cookie to indicate that we are done.
            //
            hr = THR( pnui->ObjectChanged( m_cookieCompletion ) );
        }

        pnui->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    TraceSysFreeString( bstrDisplayName  );
    TraceSysFreeString( bstrNotification );

    LogMsg( L"[MT] [CTaskGatherNodeInfo] exiting task.  The task was%ws cancelled.", m_fStop == FALSE ? L" not" : L"" );

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = TRUE;

    LogMsg( L"[MT] [CTaskGatherNodeInfo] is being stopped." );

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskGatherNodeInfo]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** SetCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SetCompletionCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "..." );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::SetGatherPunk

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SetUserAddedNodeFlag(
//      BOOL fUserAddedNodeIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SetUserAddedNodeFlag(
     BOOL fUserAddedNodeIn
     )
{
    TraceFunc( "[ITaskGatherNodeInfo]" );

    HRESULT hr = S_OK;

    m_fUserAddedNode = fUserAddedNodeIn;

    HRETURN( hr );

} //*** SetUserAddedNodeFlag


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );
    Assert( pcszNodeNameIn != NULL );

    HRESULT                     hr = S_OK;
    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                              pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrName
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcszDescriptionIn
                            , pftTimeIn
                            , pcszReferenceIn
                            ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherNodeInfo::HrSendStatusReport(
//       LPCWSTR   pcsNodeNameIn
//     , CLSID     clsidMajorIn
//     , CLSID     clsidMinorIn
//     , ULONG     ulMinIn
//     , ULONG     ulMaxIn
//     , ULONG     ulCurrentIn
//     , HRESULT   hrIn
//     , int       nDescriptionIdIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherNodeInfo::HrSendStatusReport(
      LPCWSTR   pcszNodeNameIn
    , CLSID     clsidMajorIn
    , CLSID     clsidMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrIn
    , int       nDescriptionIdIn
    , int       nReferenceIdIn // = 0
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;
    BSTR    bReference = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, nDescriptionIdIn, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( nReferenceIdIn != 0 )
    {
        //
        // Even though we failed to load the reference, we still would like the user to learn
        // about whatever report we were going to send...
        //

        THR( HrLoadStringIntoBSTR( g_hInstance, nReferenceIdIn, &bReference ) );
    } // if:

    hr = THR( SendStatusReport( pcszNodeNameIn, clsidMajorIn, clsidMinorIn, ulMinIn, ulMaxIn, ulCurrentIn, hrIn, bstr, NULL, bReference ) );

Cleanup:

    TraceSysFreeString( bReference );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CTaskGatherNodeInfo::HrSendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ActionMgr.h
//
//  Description:
//      Action Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskManager
class CTaskManager
    : public ITaskManager
{
private:
    // IUnknown
    LONG            m_cRef;

    CTaskManager( void );
    ~CTaskManager( void );
    STDMETHOD( HrInit )( void );

    static DWORD WINAPI S_BeginTask( LPVOID pParam );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // ITaskManager
    STDMETHOD(CreateTask)( REFIID clsidTaskIn, IUnknown** ppUnkOut );

    // ITaskManager
    STDMETHOD(SubmitTask)( IDoTask * pTask);

}; //*** class CTaskManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskgetdomains.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGetDomains.h
//
//  Description:
//      CTaskGetDomains implementation.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
// Class Declarations
//////////////////////////////////////////////////////////////////////////////

// CTaskGetDomains
class CTaskGetDomains
    : public ITaskGetDomains
{
private:
    // IUnknown
    LONG                        m_cRef;

    // ITaskGetDomains
    IStream *                   m_pStream;      // Interface marshalling stream
    ITaskGetDomainsCallback *   m_ptgdcb;       // Marshalled interface
    CRITICAL_SECTION            m_csCallback;   // Protects access to m_ptgdcb

    CTaskGetDomains( void );
    ~CTaskGetDomains( void );

    STDMETHOD( HrInit )( void );

    HRESULT HrReleaseCurrentCallback( void );
    HRESULT  HrUnMarshallCallback( void );

    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( BSTR bstrDomainNameIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGetDomains
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCallback )( ITaskGetDomainsCallback * punkIn );

}; //*** class CTaskGetDomains
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskpollingcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskPollingCallback.cpp
//
//  Description:
//      CTaskPollingCallback implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <ClusCfgPrivate.h>
#include "TaskPollingCallback.h"

DEFINE_THISCLASS("CTaskPollingCallback")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskPollingCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskPollingCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CTaskPollingCallback *  ptpc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ptpc = new CTaskPollingCallback;
    if ( ptpc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ptpc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( ptpc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );

Cleanup:

    if ( ptpc != NULL )
    {
        ptpc->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskPollingCallback::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskPollingCallback::CTaskPollingCallback
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskPollingCallback::CTaskPollingCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_fStop == false );
    Assert( m_dwRemoteServerObjectGITCookie == 0 );
    Assert( m_cookieLocalServerObject == 0 );

    TraceFuncExit();

} //*** CTaskPollingCallback::CTaskPollingCallback

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::HrInit
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CTaskPollingCallback::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskPollingCallback::~CTaskPollingCallback
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskPollingCallback::~CTaskPollingCallback( void )
{
    TraceFunc( "" );

    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskPollingCallback::~CTaskPollingCallback


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskPollingCallback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskPollingCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskPollingCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskPollingCallback, this, 0 );
    } // else if: ITaskPollingCallback
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskPollingCallback::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskPollingCallback::AddRef
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskPollingCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskPollingCallback::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskPollingCallback::Release
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskPollingCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if:

    CRETURN( cRef );

} //*** CTaskPollingCallback::Release


//****************************************************************************
//
//  ITaskPollingCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::BeginTask( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT                         hr = S_OK;
    BSTR                            bstrNodeName = NULL;
    BSTR                            bstrLastNodeName = NULL;
    BSTR                            bstrReference = NULL;
    BSTR                            bstrDescription = NULL;
    BSTR                            bstrNodeConnectedTo = NULL;
    CLSID                           clsidTaskMajor;
    CLSID                           clsidTaskMinor;
    ULONG                           ulMin;
    ULONG                           ulMax;
    ULONG                           ulCurrent;
    HRESULT                         hrStatus;
    FILETIME                        ft;
    IGlobalInterfaceTable *         pgit = NULL;
    IClusCfgServer *                pccs = NULL;
    IClusCfgPollingCallback *       piccpc = NULL;
    IClusCfgPollingCallbackInfo *   piccpci = NULL;
    IServiceProvider *              psp = NULL;
    IConnectionPointContainer *     pcpc  = NULL;
    IConnectionPoint *              pcp   = NULL;
    IClusCfgCallback *              pcccb = NULL;
    DWORD                           cRetries = 0;
    IObjectManager *                pom = NULL;

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    psp->Release();
    psp = NULL;

    //
    //  Create the GIT.
    //

    hr = THR( CoCreateInstance(
                  CLSID_StdGlobalInterfaceTable
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IGlobalInterfaceTable
                , reinterpret_cast< void ** >( &pgit )
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Get the ClusCfgServer interface from the GIT.
    //

    Assert( m_dwRemoteServerObjectGITCookie != 0 );

    hr = THR( pgit->GetInterfaceFromGlobal( m_dwRemoteServerObjectGITCookie, IID_IClusCfgServer, reinterpret_cast< void ** >( &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Get the PollingCallback object from the server.
    //

    hr = THR( pccs->TypeSafeQI( IClusCfgPollingCallbackInfo, &piccpci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( piccpci->GetCallback( &piccpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( HrRetrieveCookiesName( pom, m_cookieLocalServerObject, &bstrNodeConnectedTo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    pom->Release();
    pom = NULL;

    //
    //  Begin polling for SendStatusReports.
    //

    while ( m_fStop == FALSE )
    {
        //
        //  When the we cannot get a service manager pointer then it's time to
        //  leave...
        //
        //  Don't wrap with THR because we are expecting an error.
        //

        hr = CServiceManager::S_HrGetManagerPointer( &psp );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        psp->Release();
        psp = NULL;

        if ( bstrNodeName != NULL )
        {
            TraceSysFreeString( bstrLastNodeName );
            bstrLastNodeName = NULL;

            //
            //  Give up ownership
            //

            bstrLastNodeName = bstrNodeName;
            bstrNodeName = NULL;
        } // if:

        TraceSysFreeString( bstrDescription );
        bstrDescription = NULL;

        TraceSysFreeString( bstrReference );
        bstrReference = NULL;

        hr = STHR( piccpc->GetStatusReport(
                                      &bstrNodeName
                                    , &clsidTaskMajor
                                    , &clsidTaskMinor
                                    , &ulMin
                                    , &ulMax
                                    , &ulCurrent
                                    , &hrStatus
                                    , &bstrDescription
                                    , &ft
                                    , &bstrReference
                                    ) );
        if ( FAILED( hr ) )
        {
            HRESULT hr2;
            BSTR    bstrNotification = NULL;
            BSTR    bstrRef = NULL;

            LogMsg( L"[TaskPollingCallback] GetStatusReport() failed for node %ws. (hr = %#08x)", bstrNodeConnectedTo, hr );

            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE, &bstrNotification, bstrNodeConnectedTo ) );
            THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE_REF, &bstrRef ) );

            //
            //  Don't show this in the UI as a failure since it may succeed later and we don't want a
            //  red X and a green status bar at the end.
            //

            hr2 = THR( pcccb->SendStatusReport(
                                      bstrLastNodeName
                                    , TASKID_Major_Establish_Connection
                                    , TASKID_Minor_Polling_Connection_Failure
                                    , 0
                                    , 1
                                    , 1
                                    , MAKE_HRESULT( SEVERITY_SUCCESS, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) )
                                    , bstrNotification
                                    , NULL
                                    , bstrRef
                                    ) );

            TraceSysFreeString( bstrNotification );
            TraceSysFreeString( bstrRef );

            if ( hr2 == E_ABORT )
            {
                LogMsg( L"[TaskPollingCallback] UI layer returned E_ABORT..." );
            } // if:

            //
            //  If we had an error then sleep for a little more time before
            //  trying again.
            //

            Sleep( TPC_WAIT_AFTER_FAILURE );

            //
            //  Increment the retry count.
            //

            cRetries++;

            //
            //  If we are exceeding our max retry count then it's time to leave
            //  and notify the UI that we are have lost connection to the
            //  server...
            //

            if ( cRetries >= TPC_MAX_RETRIES_ON_FAILURE )
            {
                BSTR    bstrDesc = NULL;
                BSTR    bstrTempRef = NULL;

                THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_DISCONNECTING_FROM_SERVER, &bstrDesc, bstrNodeConnectedTo ) );
                THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_DISCONNECTING_FROM_SERVER_REF, &bstrTempRef ) );

                LogMsg( L"[TaskPollingCallback] GetStatusReport() failed for node %ws too many times and has timed out.  Aborting polling. (hr = %#08x)", bstrNodeConnectedTo, hr );
                THR( pcccb->SendStatusReport(
                                  bstrNodeConnectedTo
                                , TASKID_Major_Find_Devices
                                , TASKID_Minor_Disconnecting_From_Server
                                , 1
                                , 1
                                , 1
                                , hr
                                , bstrDesc
                                , NULL
                                , bstrTempRef
                                ) );

                TraceSysFreeString( bstrDesc );
                TraceSysFreeString( bstrTempRef );

                goto Cleanup;
            } // if:
        } // if: GetStatusReport() failed
        else if ( hr == S_OK )
        {
            HRESULT hrTmp;

            TraceMemoryAddBSTR( bstrNodeName );
            TraceMemoryAddBSTR( bstrDescription );
            TraceMemoryAddBSTR( bstrReference );

            hr = THR( pcccb->SendStatusReport(
                                  bstrNodeName
                                , clsidTaskMajor
                                , clsidTaskMinor
                                , ulMin
                                , ulMax
                                , ulCurrent
                                , hrStatus
                                , bstrDescription
                                , &ft
                                , bstrReference
                                ) );

            if ( hr == E_ABORT )
            {
                LogMsg( L"[TaskPollingCallback] UI layer returned E_ABORT and it is being sent to the server." );
            } // if:

            hrTmp = hr;
            hr = THR( piccpc->SetHResult( hrTmp ) );
            if ( FAILED( hr ) )
            {
                LogMsg( L"[TaskPollingCallback] SetHResult() failed.  hr = 0x%08x", hr );
            } // if:

            //
            //  Need to reset the retry count when we successfully round trip a status report.
            //

            cRetries = 0;
        } // else if: GetStatusReport() retrieved an item
        else
        {
            //
            //  Need to reset the retry count when we successfully round trip a status report.
            //

            cRetries = 0;

            Sleep( TPC_POLL_INTERVAL );
        } // else: GetStatusReport() didn't find and item waiting
    } // while:

Cleanup:

    if ( pom != NULL )
    {
        pom->Release();
    } // if:

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    if ( pgit != NULL )
    {
        pgit->Release();
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    if ( piccpc != NULL )
    {
        piccpc->Release();
    } // if:

    if ( piccpci != NULL )
    {
        piccpci->Release();
    } // if:

    if ( pcpc != NULL )
    {
        pcpc->Release();
    } // if:

    if ( pcp != NULL )
    {
        pcp->Release();
    } // if:

    if ( pcccb != NULL )
    {
        pcccb->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );
    TraceSysFreeString( bstrLastNodeName );
    TraceSysFreeString( bstrNodeConnectedTo );

    LogMsg( L"[MT] Polling callback task exiting. It %ws cancelled.", m_fStop == FALSE ? L"was not" : L"was" );

    HRETURN( hr );

} //*** CTaskPollingCallback::BeginTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::StopTask( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = true;

    HRETURN( hr );

} //*** CTaskPollingCallback::StopTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::SetServerInfo(
//        DWORD         dwRemoteServerObjectGITCookieIn
//      , OBJECTCOOKIE  cookieLocalServerObjectIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::SetServerInfo(
      DWORD         dwRemoteServerObjectGITCookieIn
    , OBJECTCOOKIE  cookieLocalServerObjectIn
    )
{
    TraceFunc( "[ITaskPollingCallback]" );

    HRESULT hr = S_OK;

    m_dwRemoteServerObjectGITCookie = dwRemoteServerObjectGITCookieIn;
    m_cookieLocalServerObject = cookieLocalServerObjectIn;

    HRETURN( hr );

} //*** CTaskPollingCallback::SetServerInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      TaskManager.cpp
//
//  Description:
//      Task Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskManager.h"

DEFINE_THISCLASS( "CTaskManager" )
#define THISCLASS CTaskManager
#define LPTHISCLASS CTaskManager *

//
//  Define this to cause the Task Manager to do all tasks synchonously.
//
//#define SYNCHRONOUS_TASKING


//****************************************************************************
//
//  Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    CTaskManager *      ptm = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    if ( hr == E_POINTER )
    {
        ptm = new CTaskManager();
        if ( ptm == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        hr = THR( ptm->HrInit() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( ptm->TypeSafeQI( IUnknown, ppunkOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        TraceMoveToMemoryList( *ppunkOut, IUnknown );

    } // if: service manager doesn't exist
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( psp->TypeSafeQS( CLSID_TaskManager, IUnknown, ppunkOut ) );
        psp->Release();

    } // else: service manager exists

Cleanup:

    if ( ptm != NULL )
    {
        ptm->Release();
    }

    HRETURN( hr );

} //*** CTaskManager::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::CTaskManager
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskManager::CTaskManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskManager::CTaskManager

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::HrInit
//
//  Description:
//      Initialize the instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Successful.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::HrInit( void )
{
    TraceFunc( "" );

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( S_OK );

} //*** CTaskManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::~CTaskManager
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskManager::~CTaskManager( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskManager::~CTaskManager


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskManager, this , 0 );
    } // else if: ITaskManager
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::AddRef
//
//  Description:
//      Add a reference to the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::Release
//
//  Description:
//      Decrement the reference count on the object.
//
//  Arguments:
//      None.
//
//   Returns:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskManager::Release


//****************************************************************************
//
//  ITaskManager
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::SubmitTask
//
//  Description:
//      Execute a task.
//
//  Arguments:
//      pTask       - The task to execute.
//
//  Return Values:
//      S_OK        - Successful.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::SubmitTask(
    IDoTask *   pTask
    )
{
    TraceFunc1( "[ITaskManager] pTask = %#x", pTask );

    BOOL                fResult;
    HRESULT             hr;

    TraceFlow1( "[MT] CTaskManager::SubmitTask() Thread id %d", GetCurrentThreadId() );

#if defined( SYNCHRONOUS_TASKING )
    //
    // Don't wrap. The "return value" is meaningless since it normally
    // would not make it back here. The "return value" of doing the task
    // should have been submitted thru the Notification Manager.
    //
    pTask->BeginTask();

    //
    // Fake it as if the task was submitted successfully.
    //
    hr = S_OK;

    goto Cleanup;
#else
    IStream * pstm; // don't free! (unless QueueUserWorkItem fails)

    TraceMemoryDelete( pTask, FALSE );  // About to be handed to another thread.

    hr = THR( CoMarshalInterThreadInterfaceInStream( IID_IDoTask, pTask, &pstm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    fResult = QueueUserWorkItem( S_BeginTask, pstm, WT_EXECUTELONGFUNCTION );
    if ( fResult != FALSE )
    {
        hr = S_OK;
    } // if: success
    else
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
        pstm->Release();
    } // else:

    //
    //  Don't free the stream. It will be freed by S_BeginTask.
    //
#endif

Cleanup:

    HRETURN( hr );

} //*** CTaskManager::SubmitTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::CreateTask
//
//  Description:
//      The purpose of this is to create the task in our process and/or our
//      apartment.
//
//  Arguments:
//      clsidTaskIn     - CLSID of the task to create.
//      ppUnkOut        - IUnknown interface.
//
//  Return Values:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::CreateTask(
    REFIID      clsidTaskIn,    // CLSID of the task to create
    IUnknown ** ppUnkOut        // IUnknown interface
    )
{
    TraceFunc( "[ITaskManager] clsidTaskIn, ppvOut" );

    HRESULT hr;

    //
    // TODO:    gpease 27-NOV-1999
    //          Maybe implement a list of "spent" tasks in order to
    //          reuse tasks that have been completed and reduce heap
    //          thrashing.(????)
    //

    hr = THR( HrCoCreateInternalInstance(
                          clsidTaskIn
                        , NULL
                        ,  CLSCTX_INPROC_SERVER, IID_IUnknown
                        , reinterpret_cast< void ** >( ppUnkOut )
                        ) );

    HRETURN( hr );

} //*** CTaskManager::CreateTask


//****************************************************************************
//
//  Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CTaskManager::S_BeginTask
//
//  Description:
//      Thread task to begin the task.
//
//  Arguments:
//      pParam      - Parameter for the task.
//
//  Return Values:
//      Ignored.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
CTaskManager::S_BeginTask(
    LPVOID pParam
    )
{
    TraceFunc1( "pParam = %#x", pParam );
    Assert( pParam != NULL );

    HRESULT hr;

    IDoTask * pTask = NULL;
    IStream * pstm  = reinterpret_cast< IStream * >( pParam );

    TraceMemoryAddPunk( pTask );

    hr = STHR( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE ) );
    if ( FAILED( hr ) )
        goto Bail;

    hr = THR( CoUnmarshalInterface( pstm, TypeSafeParams( IDoTask, &pTask ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pTask->BeginTask();

Cleanup:

    if ( pTask != NULL )
    {
        pTask->Release();  // AddRef'ed in SubmitTask
    }

    if ( pstm != NULL )
    {
        pstm->Release();
    }

    CoUninitialize();

Bail:

    FRETURN( hr );

    return hr;

} //*** CTaskManager::S_BeginTask
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\tasktracking.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.cpp
//
//  Description:
//      CTaskTracking implementation
//
//  Maintained By:
//      Galen Barbee    (GalenB) 16-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTracking.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTracking::CTaskTracking
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTracking::CTaskTracking( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_prgTasks == NULL );
    Assert( m_idxTaskNext == 0 );

    TraceFuncExit();

} //*** CTaskTracking::CTaskTracking


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTracking::~CTaskTracking
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTracking::~CTaskTracking( void )
{
    TraceFunc( "" );

    ULONG   idx;

    Assert( m_idxTaskNext == 0 );

    for ( idx = 0; idx < m_idxTaskNext; idx++ )
    {
        THR( (m_prgTasks[ idx ].pidt)->Release() );
    } // for:

    TraceFree( m_prgTasks );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskTracking::~CTaskTracking


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTracking::HrAddTaskToTrackingList
//
//  Description:
//      Add the passed in task to the side list of tasks that may need
//      to be cancelled.
//
//  Arguments:
//      punkIn
//          The task object to add to the list.
//
//      cookieIn
//          Completion cookie for the task.  Will be used to remove the
//          task from the list when a task completes.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTracking::HrAddTaskToTrackingList(
      IUnknown *    punkIn
    , OBJECTCOOKIE  cookieIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT             hr = S_OK;
    TaskTrackingEntry * prgTemp = NULL;
    IDoTask *           pidt = NULL;

    prgTemp = (TaskTrackingEntry *) TraceReAlloc(
                                              m_prgTasks
                                            , sizeof( TaskTrackingEntry ) * ( m_idxTaskNext + 1 )
                                            , HEAP_ZERO_MEMORY
                                            );
    if ( prgTemp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    m_prgTasks = prgTemp;

    hr = THR( punkIn->TypeSafeQI( IDoTask, &pidt ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_prgTasks[ m_idxTaskNext ].pidt = pidt;
    m_prgTasks[ m_idxTaskNext++ ].ocCompletion = cookieIn;

Cleanup:

    HRETURN( hr );

} //*** CTaskTracking::HrAddTaskToTrackingList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTracking::HrRemoveTaskFromTrackingList
//
//  Description:
//      Remove the task which has the passed in cookie associated with it.
//
//  Arguments:
//      cookieIn
//          Completion cookie for the task.  Will be used to remove the
//          task from the list when a task completes.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTracking::HrRemoveTaskFromTrackingList(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "" );
    Assert( m_idxTaskNext != NULL );

    HRESULT hr = S_OK;
    ULONG   idxOuter;
    ULONG   idxInner;

    //
    //  Find the entry that contains the passed in cookie.
    //

    for ( idxOuter = 0; idxOuter < m_idxTaskNext; idxOuter++ )
    {
        if ( m_prgTasks[ idxOuter ].ocCompletion == cookieIn )
        {
            //
            //  Release out ref on the task object.
            //

            (m_prgTasks[ idxOuter ].pidt)->Release();

            //
            //  Shift the remaining entries to the left.  Need to stop one before the end
            //  because there is no need to move the end plus one...
            //

            for ( idxInner = idxOuter; idxInner < m_idxTaskNext - 1; idxInner++ )
            {
                m_prgTasks[ idxInner ] = m_prgTasks[ idxInner + 1 ];
            } // for:

            //
            //  Decrement the count/next index
            //

            m_idxTaskNext -= 1;
            break;
        } // if:
    } // for:

    HRETURN( hr );

} //*** CTaskTracking::HrRemoveTaskFromTrackingList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTracking::HrNotifyAllTasksToStop
//
//  Description:
//      Notify all tasks in the tracking list that the need to stop.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTracking::HrNotifyAllTasksToStop(
    void
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    ULONG   idx;

    //
    //  Enum each task and tell it to stop.
    //

    for ( idx = 0; idx < m_idxTaskNext; idx++ )
    {
        THR( (m_prgTasks[ idx ].pidt)->StopTask() );
    } // for:

    HRETURN( hr );

} //*** CTaskTracking::HrNotifyAllTasksToStop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskpollingcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      TaskPollingCallback.h
//
//  Description:
//      CTaskPollingCallback implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
//  Timeout controlling how long TaskPollingCallback should retry until it gives up.
//

const DWORD TPC_FAILURE_TIMEOUT = CC_DEFAULT_TIMEOUT;

//
//  TaskPollingCallback's poll interval.  The interval is the time to wait before calling into
//  the server to check for a queued status report.
//

const DWORD TPC_POLL_INTERVAL = 1000;                                                       // 1 second

//
//  How long TaskPollingCallback should wait before retrying GetStatusReport() after a failure.
//

const DWORD TPC_WAIT_AFTER_FAILURE = 10000;                                                 // 10 seconds

//
//  How many times should TaskPollingCallback retry after a failure.  The count is the timeout value
//  divided by the failure wait time.  This allows us to determine how much approximate time should
//  elapse before giving up.
//

#if defined( DEBUG ) && defined( CCS_SIMULATE_RPC_FAILURE )
    const DWORD TPC_MAX_RETRIES_ON_FAILURE = TPC_FAILURE_TIMEOUT / TPC_WAIT_AFTER_FAILURE / 4;  // Want simulated failures 4 times sooner...
#else
    const DWORD TPC_MAX_RETRIES_ON_FAILURE = TPC_FAILURE_TIMEOUT / TPC_WAIT_AFTER_FAILURE;      // Number of times to retry the operation (5 minute timeout)
#endif


// CTaskPollingCallback
class CTaskPollingCallback
    : public ITaskPollingCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask/ITaskPollingCallback
    bool                m_fStop;
    DWORD               m_dwRemoteServerObjectGITCookie;    // The GIT cookie for the server side object.
    OBJECTCOOKIE        m_cookieLocalServerObject;          // Object Manager cookie for the client side server proxy object.

private: // Methods
    CTaskPollingCallback( void );
    ~CTaskPollingCallback( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask/ITaskPollingCallback
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetServerInfo )( DWORD dwRemoteServerObjectGITCookieIn, OBJECTCOOKIE cookieLocalServerObjectIn );

}; //*** class CTaskPollingCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\callback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Callback.h
//
//  Description:
//      CCallback implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CCallback
class CCallback
    : public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

private: // Methods
    CCallback( void );
    ~CCallback( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID clsidTaskMajorIn,
                                   CLSID clsidTaskMinorIn,
                                   ULONG ulMinIn,
                                   ULONG ulMaxIn,
                                   ULONG ulCurrentIn,
                                   HRESULT hrStatusIn,
                                   BSTR bstrDescriptionIn
                                   );

}; //*** class CCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskverifyipaddress.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskVerifyIPAddress.h
//
//  Description:
//      CTaskVerifyIPAddress implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUL-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskVerifyIPAddress
class CTaskVerifyIPAddress
    : public ITaskVerifyIPAddress
{
private:
    // IUnknown
    LONG                m_cRef;

    //  ITaskVerifyIPAddress
    OBJECTCOOKIE        m_cookie;       //  Cookie to signal when done.
    DWORD               m_dwIPAddress;  //  IP address to verify

    CTaskVerifyIPAddress( void );
    ~CTaskVerifyIPAddress( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IDoTask / ITaskVerifyIPAddress
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetIPAddress )( DWORD dwIPAddressIn );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );

}; //*** class CTaskVerifyIPAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\tasktracking.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.h
//
//  Description:
//      CTaskTracking declaration
//
//  Maintained By:
//      Galen Barbee    (GalenB) 16-AUG-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CTaskTracking
{
private:

    typedef struct _TaskTrackingEntry
    {
        IDoTask *       pidt;
        OBJECTCOOKIE    ocCompletion;
    } TaskTrackingEntry;

    ULONG               m_idxTaskNext;  // Count and next available index of the tasks to cancel.
    TaskTrackingEntry * m_prgTasks;

    // Private copy constructor to prevent copying.
    CTaskTracking( const CTaskTracking & nodeSrc );

    // Private assignment operator to prevent copying.
    const CTaskTracking & operator = ( const CTaskTracking & nodeSrc );

protected:

    CTaskTracking( void );
    virtual ~CTaskTracking( void );

    HRESULT HrAddTaskToTrackingList( IUnknown * punkIn, OBJECTCOOKIE cookieIn );
    HRESULT HrRemoveTaskFromTrackingList( OBJECTCOOKIE cookieIn );
    HRESULT HrNotifyAllTasksToStop( void );

    ULONG   CTasks( void ) { return m_idxTaskNext; }

}; //*** class CTaskTracking
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\callback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Callback.cpp
//
//  Description:
//      CCallback implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Callback.h"

DEFINE_THISCLASS("CCallback")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    CCallback * pc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pc = new CCallback;
    if ( pc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pc->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pc->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pc != NULL )
    {
        pc->Release();
    }

    HRETURN( hr );

} //*** CCallback::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CCallback::CCallback
//
//////////////////////////////////////////////////////////////////////////////
CCallback::CCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CCallback::CCallback

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCallback::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CCallback::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CCallback::~CCallback
//
//////////////////////////////////////////////////////////////////////////////
CCallback::~CCallback( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CCallback::~CCallback


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCallback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCallback::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCallback::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCallback::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCallback::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CCallback::Release



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCallback::SendStatusReport(
//      BSTR bstrNodeNameIn,
//      CLSID clsidTaskMajorIn,
//      CLSID clsidTaskMinorIn,
//      ULONG ulMinIn,
//      ULONG ulMaxIn,
//      ULONG ulCurrentIn,
//      HRESULT hrStatusIn,
//      BSTR bstrDescriptionIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::SendStatusReport(
    BSTR bstrNodeNameIn,
    CLSID clsidTaskMajorIn,
    CLSID clsidTaskMinorIn,
    ULONG ulMinIn,
    ULONG ulMaxIn,
    ULONG ulCurrentIn,
    HRESULT hrStatusIn,
    BSTR bstrDescriptionIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    DebugMsg( "clsidTaskMajorIn: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
              clsidTaskMajorIn.Data1, clsidTaskMajorIn.Data2, clsidTaskMajorIn.Data3,
              clsidTaskMajorIn.Data4[ 0 ], clsidTaskMajorIn.Data4[ 1 ], clsidTaskMajorIn.Data4[ 2 ], clsidTaskMajorIn.Data4[ 3 ],
              clsidTaskMajorIn.Data4[ 4 ], clsidTaskMajorIn.Data4[ 5 ], clsidTaskMajorIn.Data4[ 6 ], clsidTaskMajorIn.Data4[ 7 ]
              );

    DebugMsg( "clsidTaskMinorIn: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
              clsidTaskMinorIn.Data1, clsidTaskMinorIn.Data2, clsidTaskMinorIn.Data3,
              clsidTaskMinorIn.Data4[ 0 ], clsidTaskMinorIn.Data4[ 1 ], clsidTaskMinorIn.Data4[ 2 ], clsidTaskMinorIn.Data4[ 3 ],
              clsidTaskMinorIn.Data4[ 4 ], clsidTaskMinorIn.Data4[ 5 ], clsidTaskMinorIn.Data4[ 6 ], clsidTaskMinorIn.Data4[ 7 ]
              );

    DebugMsg( "Progress:\tmin: %u\tcurrent: %u\tmax: %u",
              ulMinIn,
              ulCurrentIn,
              ulMaxIn
              );

    DebugMsg( "Status: hrStatusIn = %#08x\t%ws", hrStatusIn, ( bstrDescriptionIn == NULL ? L"" : bstrDescriptionIn ) );

    Assert( ulCurrentIn >= ulMinIn && ulMaxIn >= ulCurrentIn );

    HRETURN( hr );

} //*** CCallback::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\taskverifyipaddress.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskVerifyIPAddress.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUL-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskVerifyIPAddress.h"

DEFINE_THISCLASS("CTaskVerifyIPAddress")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskVerifyIPAddress::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskVerifyIPAddress::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CTaskVerifyIPAddress *  ptvipa = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ptvipa = new CTaskVerifyIPAddress;
    if ( ptvipa == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ptvipa->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptvipa->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ptvipa != NULL )
    {
        ptvipa->Release();
    }

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskVerifyIPAddress::CTaskVerifyIPAddress
//
//////////////////////////////////////////////////////////////////////////////
CTaskVerifyIPAddress::CTaskVerifyIPAddress( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskVerifyIPAddress::CTaskVerifyIPAddress

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskVerifyIPAddress::~CTaskVerifyIPAddress
//
//////////////////////////////////////////////////////////////////////////////
CTaskVerifyIPAddress::~CTaskVerifyIPAddress( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskVerifyIPAddress::~CTaskVerifyIPAddress


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskVerifyIPAddress::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskVerifyIPAddress * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskVerifyIPAddress ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskVerifyIPAddress, this, 0 );
    } // else if: ITaskVerifyIPAddress
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
    } // else if: IDoTask
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskVerifyIPAddress::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskVerifyIPAddress::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskVerifyIPAddress::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CTaskVerifyIPAddress::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskVerifyIPAddress::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskVerifyIPAddress::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CTaskVerifyIPAddress::Release



//****************************************************************************
//
//  IDoTask / ITaskVerifyIPAddress
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::BeginTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    BOOL    fRet;

    HRESULT hr = S_OK;

    IServiceProvider *          psp  = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;
    INotifyUI *                 pnui = NULL;
    IObjectManager *            pom  = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI,
                                         &pcp
                                         ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //   release promptly
    psp->Release();
    psp = NULL;

    fRet = ClRtlIsDuplicateTcpipAddress( m_dwIPAddress );
    if ( fRet )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pom != NULL )
    {
        //
        //  Update the cookie's status indicating the result of our task.
        //

        IUnknown * punk;
        HRESULT hr2;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookie,
                                   &punk
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        pom->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pnui != NULL )
    {
        //
        //  Signal the cookie to indicate that we are done.
        //

        THR( pnui->ObjectChanged( m_cookie ) );
        pnui->Release();
    }

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::StopTask
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::SetIPAddress(
//      DWORD dwIPAddressIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::SetIPAddress(
    DWORD dwIPAddressIn
    )
{
    TraceFunc( "[ITaskVerifyIPAddress]" );

    HRESULT hr = S_OK;

    m_dwIPAddress = dwIPAddressIn;

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::SetIPAddress

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::SetCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::SetCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskVerifyIPAddress]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** CTaskVerifyIPAddress::SetCookie
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#endif // DBG==1

#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include "UINotification.h"
#include "Callback.h"
#include <winsock2.h>

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);


//
//  KB: Turn this on to run all tests. Some of these might return errors, but none
//      of them should cause the program to crash.
//
//#define TURN_ON_ALL_TESTS

//
//  KB: Turn this on to run a regression pass.
//
#define REGRESSION_PASS


DEFINE_MODULE( "MIDDLETIERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IServiceProvider *  g_psp       = NULL;

BOOL                g_fWait     = FALSE;    // global synchronization

OBJECTCOOKIE        g_cookieCluster = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}

//
//  This tests the Object Manager code path to retrieve information
//  from a soon-to-be or existing cluster node.
//
HRESULT
HrTestAddingNode(
    BSTR    bstrNodeNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   dwHigh;
    DWORD   dwLow;

    OBJECTCOOKIE cookie;

    SDriveLetterMapping dlmDriveLetterUsage;

    BSTR    bstrName = NULL;

    IUnknown *              punk    = NULL;
    IUnknown *              punk2   = NULL;
    IObjectManager *        pom     = NULL;
    IClusCfgNodeInfo *      pccni   = NULL;
    IClusCfgNodeInfo *      pccni2  = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;

    // Get OS Version stuff
    DWORD   dwMajorVersionOut;
    DWORD   dwMinorVersionOut;
    WORD    wSuiteMaskOut;
    BYTE    bProductTypeOut;
    BSTR    bstrCSDVersionOut;

    //
    //  Contact the Object Manager
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Try to find my test machine.
    //

    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        DebugMsg( "Trying to FindObject( ... %s ... )", bstrNodeNameIn );

        hr = pom->FindObject( CLSID_NodeType,
                              g_cookieCluster,
                              bstrNodeNameIn,
                              DFGUID_NodeInformation,
                              &cookie,
                              &punk
                              );
        if ( hr == E_PENDING )
        {
            Assert( punk == NULL );
            Sleep( 1000 );  // 1 Second
            continue;
        }

        THR( hr );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Interrogate the information retrieved.
    //

    hr = THR( pccni->GetName( &bstrName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "bstrName = %s", bstrName );

#if defined(TURN_ON_ALL_TESTS)
    hr = THR( pccni->SetName( L"gpease-wolf1.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully called SetName( )." );
#endif

    hr = STHR( pccni->IsMemberOfCluster( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "IsMemberOfCluster == %s", BOOLTOSTRING( hr == S_OK ) );

    if ( hr == S_OK )
    {
        hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        DebugMsg( "Succesfully called GetClusterConfigInfo( )" );
    }

    hr = THR( pccni->GetOSVersion( &dwMajorVersionOut,
                                   &dwMinorVersionOut,
                                   &wSuiteMaskOut,
                                   &bProductTypeOut,
                                   &bstrCSDVersionOut
                                   ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully called GetOSVersion( )" );

    hr = THR( pccni->GetClusterVersion( &dwHigh, &dwLow ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Version: dwHigh = %#x, dwLow = %#x", dwHigh, dwLow );

    hr = THR( pccni->GetDriveLetterMappings( &dlmDriveLetterUsage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  TODO:   gpease  08-MAR-2000
    //          Make this dump the table.
    //
    DebugMsg( "Succesfully called GetDriveLetterMappings( )" );

    //
    //  Try getting the same object.
    //

    hr = THR( pom->GetObject( DFGUID_NodeInformation,
                              cookie,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni2 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    DebugMsg( "GetObject succeeded." );

    //
    //  They should be the same object.
    //

    hr = THR( pccni->TypeSafeQI( IUnknown, &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccni2->TypeSafeQI( IUnknown, &punk2 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    AssertMsg( punk == punk2, "These should be the same!" );

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( punk2 != NULL )
    {
        punk2->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
    }
    if ( pccci != NULL )
    {
        pccci->Release( );
    }
    if ( pccni2 != NULL )
    {
        pccni2->Release( );
    }

    HRETURN( hr );
}


//
//  This tests the Analyze Cluster Tasks.
//
HRESULT
HrTestTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    DWORD           dwCookie;

    CUINotification *       puin;

    IUnknown *              punk = NULL;
    IObjectManager *        pom  = NULL;
    ITaskManager *          ptm  = NULL;
    ITaskAnalyzeCluster *   ptac = NULL;
    IConnectionPoint *      pcp  = NULL;
    INotifyUI *             pnui = NULL;
    IClusCfgCallback *      pcccb = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_TaskType,
                               g_cookieCluster,
                               L"AnalyzeTask",
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a notification object that will be called when
    //  the task is completed.
    //

    hr = THR( CUINotification::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    puin = reinterpret_cast< CUINotification * >( punk );
    THR( puin->HrSetCompletionCookie( cookie ) );

    hr = THR( punk->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Register the notification object with the Notification Manager.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_NotificationManager,
                                 IConnectionPoint,
                                 &pcp
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->Advise( pnui, &dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Task Manager to create the Analyze Cluster Task.
    //

    hr = THR( ptm->CreateTask( TASK_AnalyzeCluster,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( ITaskAnanlyzeCluster, &ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  The the task what cookie to use for the notification.
    //

    hr = THR( ptac->SetCookie( cookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Tell the task which cluster to analyze.
    //

    hr = THR( ptac->SetClusterCookie( g_cookieCluster ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a callback object.
    //

    Assert( punk == NULL );
    hr = THR( CCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk = TraceInterface( L"CCallback", IUnknown, punk, 1 );

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  The the action where to call us back.
    //

    hr = THR( ptac->SetCallback( pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Reset g_fWait and submit the task.
    //

    g_fWait = TRUE;
    hr = THR( ptm->SubmitTask( ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Wait for the task to complete.
    //
    while( g_fWait )
    {
        Sleep( 1 ); // sleep a millisecond
    }

    //
    //  Unregister the notification object.
    //

    hr = THR( pcp->Unadvise( dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( ptm != NULL )
    {
        ptm->Release( );
    }
    if ( ptac != NULL )
    {
        ptac->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pnui != NULL )
    {
        pnui->Release( );
    }
    if ( pcccb != NULL )
    {
        pcccb->Release( );
    }

    HRETURN( hr );

}

//
//  This tests the Commit Cluster Changes Tasks.
//
HRESULT
HrTestTaskCommitClusterChanges( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    DWORD           dwCookie;

    CUINotification *           puin;

    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    ITaskManager *              ptm   = NULL;
    ITaskCommitClusterChanges * ptccc = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IClusCfgCallback *          pcccb = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_TaskType,
                               g_cookieCluster,
                               L"CommitClusterChanges",
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a notification object that will be called when
    //  the task is completed.
    //

    hr = THR( CUINotification::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    puin = reinterpret_cast< CUINotification * >( punk );
    THR( puin->HrSetCompletionCookie( cookie ) );

    hr = THR( punk->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Register the notification object with the Notification Manager.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_NotificationManager,
                                 IConnectionPoint,
                                 &pcp
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->Advise( pnui, &dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Task Manager to create the Analyze Cluster Task.
    //

    hr = THR( ptm->CreateTask( TASK_CommitClusterChanges,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( ITaskCommitClusterChanges, &ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  The the task what cookie to use for the notification.
    //

    hr = THR( ptccc->SetCookie( cookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Tell the task which cluster to commit.
    //

    hr = THR( ptccc->SetClusterCookie( g_cookieCluster ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a callback object.
    //

    Assert( punk == NULL );
    hr = THR( CCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk = TraceInterface( L"CCallback", IUnknown, punk, 1 );

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  The the action where to call us back.
    //

    hr = THR( ptccc->SetCallback( pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Reset g_fWait and submit the task.
    //

    g_fWait = TRUE;
    hr = THR( ptm->SubmitTask( ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Wait for the task to complete.
    //
    while( g_fWait )
    {
        Sleep( 1 ); // sleep a millisecond
    }

    //
    //  Unregister the notification object.
    //

    hr = THR( pcp->Unadvise( dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( ptm != NULL )
    {
        ptm->Release( );
    }
    if ( ptccc != NULL )
    {
        ptccc->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pnui != NULL )
    {
        pnui->Release( );
    }
    if ( pcccb != NULL )
    {
        pcccb->Release( );
    }

    HRETURN( hr );

}


//
//  This tests the object manager's node enumerator.
//
HRESULT
HrTestEnumNodes( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    ULONG           celtFetched;

    BSTR            bstrName = NULL;

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IEnumNodes *            pen   = NULL;
    IClusCfgNodeInfo *      pccni = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_NodeType,
                               g_cookieCluster,
                               NULL,
                               DFGUID_EnumNodes,
                               &cookieDummy,    // not needed, but the proxy code wants something
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Enumerate the nodes.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( pen->Next( 1, &pccni, &celtFetched ) );
        if ( hr == S_FALSE )
            break;  // exit loop

        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        DebugMsg( "Node Name: %s", bstrName );

        TraceSysFreeString( bstrName );

        pccni->Release( );
        pccni = NULL;
    }

    hr = S_OK;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pen != NULL )
    {
        pen->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
    }

    HRETURN( hr );
}

//
//  This tests all the object manager's enumerators. It should be executed
//  while the object cache is empty.
//
HRESULT
HrTestEmptyEnumerations( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;

    IUnknown *          punk  = NULL;
    IObjectManager *    pom   = NULL;
    IEnumNodes *        pen   = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;
    IEnumClusCfgNetworks *  peccn = NULL;
    IClusCfgManagedResourceInfo * pccmri = NULL;
    IClusCfgNetworkInfo * pccneti = NULL;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumNodes,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto EnumResources;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( pen->Next( 1, &pccni, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccni->Release( );
        pccni = NULL;
    }

EnumResources:
    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumManageableResources,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto EnumNetworks;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccmr->Next( 1, &pccmri, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccmri->Release( );
        pccmri = NULL;
    }

EnumNetworks:
    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumManageableNetworks,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccn->Next( 1, &pccneti, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccneti->Release( );
        pccneti = NULL;
    }

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( peccmr != NULL )
    {
        peccmr->Release( );
    }
    if ( peccn != NULL )
    {
        peccn->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( pccmri != NULL )
    {
        pccmri->Release( );
    }
    if ( pccneti != NULL )
    {
        pccneti->Release( );
    }
    if ( pen != NULL )
    {
        pen->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }

    HRETURN( hr );
}

//
//  This tests the Cluster Configuration object in the object manager.
//
HRESULT
HrTestClusterConfiguration(
    BSTR            bstrClusterNameIn,
    BSTR            bstrAccountNameIn,
    BSTR            bstrPasswordIn,
    BSTR            bstrDomainIn,
    ULONG           ulClusterIPIn,
    ULONG           ulClusterSubnetIn,
    OBJECTCOOKIE *  pcookieClusterOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    ULONG   ulClusterIP;
    ULONG   ulClusterSubnet;

    BSTR    bstrClusterName = NULL;
    BSTR    bstrAccountName = NULL;
    BSTR    bstrPassword    = NULL;
    BSTR    bstrDomain      = NULL;

    IUnknown *              punk   = NULL;
    IObjectManager *        pom    = NULL;
    IClusCfgClusterInfo *   pccci  = NULL;
    IClusCfgCredentials *   piccc  = NULL;

    //
    //  Retrieve the Object Manager
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for the cluster configuration object.
    //

    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        //  Don't wrap. this can fail with E_PENDING.
        hr = pom->FindObject( CLSID_ClusterConfigurationType,
                              NULL,
                              bstrClusterNameIn,
                              DFGUID_ClusterConfigurationInfo,
                              pcookieClusterOut,
                              &punk
                              );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 Second
            continue;
        }

        THR( hr );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // while: pending

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Exercise the forming and joining flags.
    //

    hr = THR( pccci->SetForming( TRUE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if defined(TURN_ON_ALL_TESTS)
    //  This will fail.
    hr = pccci->SetJoining( TRUE );
    Assert( FAILED( hr ) );
#endif

    hr = THR( pccci->SetForming( FALSE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->SetJoining( TRUE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if defined(TURN_ON_ALL_TESTS)
    //  This will fail.
    hr = pccci->SetForming( TRUE );
    Assert( FAILED( hr ) );
#endif

    hr = THR( pccci->SetJoining( FALSE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Test account info.
    //
    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( piccc->SetCredentials( bstrAccountNameIn, bstrDomainIn, bstrPasswordIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( piccc->GetCredentials( &bstrAccountName, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( StrCmp( bstrAccountNameIn, bstrAccountName ) == 0 );
    Assert( StrCmp( bstrPasswordIn, bstrPassword ) == 0 );
    Assert( StrCmp( bstrDomainIn, bstrDomain ) == 0 );

    piccc->Release();
    piccc = NULL;

    //
    //. Test cluster name.
    //

    hr = THR( pccci->SetName( bstrClusterNameIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( StrCmp( bstrClusterNameIn, bstrClusterName ) == 0 );

    //
    //  Test IP/subnet.
    //

    hr = THR( pccci->SetIPAddress( ulClusterIPIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->SetSubnetMask( ulClusterSubnetIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetIPAddress( &ulClusterIP ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetSubnetMask( &ulClusterSubnet ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( ulClusterIP == ulClusterIPIn );
    Assert( ulClusterSubnet == ulClusterSubnetIn );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( bstrClusterName != NULL )
    {
        TraceSysFreeString( bstrClusterName );
    }
    if ( bstrAccountName != NULL )
    {
        TraceSysFreeString( bstrAccountName );
    }
    if ( bstrPassword != NULL )
    {
        TraceSysFreeString( bstrPassword );
    }
    if ( bstrDomain != NULL )
    {
        TraceSysFreeString( bstrDomain );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( piccc != NULL )
    {
        piccc->Release( );
    }
    if ( pccci != NULL )
    {
        pccci->Release( );
    }

    HRETURN( hr );
}


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
main( void )
{
    TraceInitializeProcess( NULL, 0 );

    HRESULT hr;
    ULONG   ulClusterIP;
    ULONG   ulClusterSubnet;

    ulClusterIP = inet_addr( "10.1.1.10" );
    ulClusterSubnet = inet_addr( "255.255.0.0" );

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0
    hr = THR( HrRegisterTheDll( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    //
    //  Start up the middle tier.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &g_psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0 || defined(TURN_ON_ALL_TESTS)
    hr = THR( HrTestEmptyEnumerations( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestClusterConfiguration( L"GPEASEDEV-CLUS.NTDEV.MICROSOFT.COM",
                                          L"ntdev",
                                          L"ntdevntdev",
                                          L"ntdev",
                                          ulClusterIP,
                                          ulClusterSubnet,
                                          &g_cookieCluster
                                          ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#if 1 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestAddingNode( L"GPEASE-WOLF1.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0 || defined(TURN_ON_ALL_TESTS)
    //
    //  KB: Since HrTestAddingNode( ) changes the name of the node when
    //      TURN_ON_ALL_TESTS is on, it doesn't make sense to try to
    //      connect to another node.
    //
    hr = THR( HrTestAddingNode( L"GALENB-CLUS.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#endif // HrTestAddingNode

#if 1 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    //
    //  KB: HrTestAddingNode() must be run before this or the test
    //      will failed.
    //
    hr = THR( HrTestEnumNodes( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestEnumNodes

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestTaskAnalyzeCluster( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestTaskAnalyzeCluster

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestTaskCommitClusterChanges( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestTaskCommitClusterChanges

Cleanup:
    if ( g_psp != NULL )
    {
        g_psp->Release( );
    }

    CoUninitialize( );

    TraceTerminateProcess( NULL, 0 );

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\createservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CreateServices.h
//
//  Description:
//      CreateServices implementation.
//
//  Maintained By:
//      Galen Barbee   (GalenB) 14-JUN-2001
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCreateServices
    : public IClusCfgResourceCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CCreateServices( void );
    ~CCreateServices( void );

    HRESULT HrInit( void );

public:     // methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgResourceCreate
    STDMETHOD( SetPropertyBinary )( LPCWSTR pcszNameIn, const DWORD cbSizeIn, const BYTE * pbyteIn );
    STDMETHOD( SetPropertyDWORD )( LPCWSTR pcszNameIn, const DWORD dwDWORDIn );
    STDMETHOD( SetPropertyString )( LPCWSTR pcszNameIn, LPCWSTR pcszStringIn );
    STDMETHOD( SetPropertyExpandString )( LPCWSTR pcszNameIn, LPCWSTR pcszStringIn );
    STDMETHOD( SetPropertyMultiString )( LPCWSTR pcszNameIn, const DWORD cbSizeIn, LPCWSTR pcszStringIn );
    STDMETHOD( SetPropertyUnsignedLargeInt )( LPCWSTR pcszNameIn, const ULARGE_INTEGER ulIntIn );
    STDMETHOD( SetPropertyLong )( LPCWSTR pcszNameIn, const LONG lLongIn );
    STDMETHOD( SetPropertySecurityDescriptor )( LPCWSTR pcszNameIn, const SECURITY_DESCRIPTOR * pcsdIn );
    STDMETHOD( SetPropertyLargeInt )( LPCWSTR pcszNameIn, const LARGE_INTEGER lIntIn );

    STDMETHOD( SendResourceControl )( DWORD dwControlCode, LPVOID lpInBuffer, DWORD cbInBufferSize );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; //*** class CCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\uinotification.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      UINotification.h
//
//  Description:
//      UINotification implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    26-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CUINotification
class CUINotification
    : public INotifyUI
{
private: // Data
    // IUnknown
    LONG                m_cRef;

    // INotifyUI
    DWORD               m_dwCookie;

    // Other
    OBJECTCOOKIE        m_cookie;

private: // Methods
    CUINotification( void );
    ~CUINotification( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    HRESULT
        HrSetCompletionCookie( OBJECTCOOKIE cookieIn );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // INotifyUI
    STDMETHOD( ObjectChanged )( LPVOID cookieIn );

}; //*** class CUINotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\dummy.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Dummy.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Dummy.h"

DEFINE_THISCLASS("CDummy")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CDummy::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDummy::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    CDummy *    pdummy = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pdummy = new CDummy;
    if ( pdummy == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pdummy->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pdummy != NULL )
    {
        pdummy->Release();
    }

    HRETURN( hr );

} //*** CDummy::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CDummy::CDummy
//
//////////////////////////////////////////////////////////////////////////////
CDummy::CDummy( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CDummy::CDummy

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CDummy::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CDummy::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CDummy::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CDummy::~CDummy
//
//////////////////////////////////////////////////////////////////////////////
CDummy::~CDummy( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CDummy::~CDummy


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDummy::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CDummy::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IDummy * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IDummy ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDummy, this, 0 );
    } // else if: IDummy
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN( hr, riidIn );

} //*** CDummy::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CDummy::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CDummy::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CDummy::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CDummy::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CDummy::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CDummy::Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\middletier\test\uinotification.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      UINotification.cpp
//
//  Description:
//      UINotification implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//  Notes:
//      The object implements a lightweight marshalling of data from the
//      free-threaded lower layers to the single-threaded, apartment model
//      UI layer.
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "UINotification.h"

DEFINE_THISCLASS("CUINotification")

extern BOOL g_fWait;
extern IServiceProvider * g_psp;

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// HRESULT
// CUINotification::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUINotification::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CUINotification *   puin = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    puin = new CUINotification();
    if ( puin == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( puin->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( puin->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( puin != NULL )
    {
        puin->Release();
    }

    HRETURN( hr );

} //*** CUINotification::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
//////////////////////////////////////////////////////////////////////////////
CUINotification::CUINotification( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CUINotification::CUINotification

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CUINotification::HrInit
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CUINotification::HrInit

//////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////
CUINotification::~CUINotification( void )
{
    TraceFunc( "" );

    HRESULT hr;

    IConnectionPoint * pcp = NULL;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CUINotification::~CUINotification


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUINotification::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
    } // else if: INotifyUI
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CUINotification::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CUINotification::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUINotification::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CUINotification::AddRef

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CUINotification::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUINotification::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CUINotification::Release


// ************************************************************************
//
// INotifyUI
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CUINotification::ObjectChanged(
//      DWORD cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::ObjectChanged(
    LPVOID cookieIn
    )
{
    TraceFunc1( "[INotifyUI] cookieIn = 0x%08x", cookieIn );

    HRESULT hr = S_OK;

    DebugMsg( "UINOTIFICATION: cookie %#x has changed.", cookieIn );

    if ( m_cookie == cookieIn )
    {
        //
        //  Done waiting...
        //
        g_fWait = FALSE;
    }

    HRETURN( hr );

} //*** CUINotification::ObjectChanged



//****************************************************************************
//
//  Semi-Public
//
//****************************************************************************

HRESULT
CUINotification::HrSetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc1( "cookieIn = %p", cookieIn );

    m_cookie = cookieIn;

    HRETURN( S_OK );

} //*** CUINotification::HrSetCompletionCookie
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\dummy.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Dummy.h
//
//  Description:
//      CDummy implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CDummy
class CDummy
    : public IDummy
{
private:
    // IUnknown
    LONG                m_cRef;

private: // Methods
    CDummy( void );
    ~CDummy( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

}; //*** class CDummy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\createservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CreateServices.h
//
//  Description:
//      CreateServices implementation.
//
//  Maintained By:
//      Galen Barbee    (GalenB)    14-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "CreateServices.h"

DEFINE_THISCLASS("CCreateServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CCreateServices *   pcs = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcs = new CCreateServices;
    if ( pcs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcs != NULL )
    {
        pcs->Release();
    } // if:

    HRETURN( hr );

} //*** CCreateServices::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CCreateServices::CCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CCreateServices::CCreateServices( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CCreateServices::CCreateServices

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCreateServices::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} //*** CCreateServices::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CCreateServices::~CCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CCreateServices::~CCreateServices( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CCreateServices::~CCreateServices


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateServices::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourceCreate * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourceCre