               DBGF_WARNINGS,
                           "UMPNPMGR: RegisterDeviceNotification using this class GUID is not supported!\n"));

                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
            if (entry == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Copy the client name for the window or service, supplied by
            // ServiceName.  The maximum service name buffer length required for
            // services is MAX_SERVICE_NAME_LEN (256 characters), which should
            // be a reasonable limit for both.
            //
            if (ARGUMENT_PRESENT(ServiceName)) {

                HRESULT hr;
                size_t  ServiceNameLen = 0;

                hr = StringCchLength(ServiceName,
                                     MAX_SERVICE_NAME_LEN,
                                     &ServiceNameLen);
                if (FAILED(hr)) {
                    ServiceNameLen = MAX_SERVICE_NAME_LEN - 1;
                }

                entry->ClientName =
                    (LPWSTR)HeapAlloc(
                        ghPnPHeap, 0,
                        (ServiceNameLen+1)*sizeof(WCHAR));

                if (entry->ClientName == NULL) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "UMPNPMGR: PNP_RegisterNotification "
                               "failed to allocate memory for ClientName!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    HeapFree (ghPnPHeap,0,entry);
                    goto Clean0;
                }

                //
                // Copy to the allocated buffer, truncating if necessary.
                //
                hr = StringCchCopy(entry->ClientName,
                                   ServiceNameLen + 1,
                                   ServiceName);
                ASSERT(SUCCEEDED(hr));

            } else {
                entry->ClientName = NULL;
            }

            //
            // Resolve the service status handle from the supplied service name.
            //
            if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

                hRecipient = (ULONG_PTR)NULL;

                if (pSCMAuthenticate && ServiceName) {

                    SERVICE_STATUS_HANDLE serviceHandle;

                    if (pSCMAuthenticate(ServiceName, &serviceHandle) == NO_ERROR) {
                        hRecipient = (ULONG_PTR)serviceHandle;
                    }
                }

                if (!hRecipient) {
                    Status = CR_INVALID_DATA;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    *Context = NULL;
                    goto Clean0;
                }
            }

            //
            // Add this entry to the class list
            //
            entry->Signature = CLASS_ENTRY_SIGNATURE;
            entry->Handle = (HANDLE)hRecipient;
            entry->Flags = Flags;
            entry->Unregistered = FALSE;
            entry->Freed = 0;
            entry->SessionId = ulSessionId;

            //
            // If the caller is registering for all interface class events,
            // ignore the caller supplied class GUID and use a private GUID.
            // Otherwise, copy the caller supplied GUID to the notification list
            // entry.
            //
            if ((Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                DEVICE_NOTIFY_ALL_INTERFACE_CLASSES) {
                memcpy(&entry->u.Class.ClassGuid,
                       &GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
                       sizeof(GUID));
            } else {
                memcpy(&entry->u.Class.ClassGuid,
                       &filter->dbcc_classguid,
                       sizeof(GUID));
            }

            EnterCriticalSection(&RegistrationCS);
            bCritSecHeld = TRUE;

            if (gNotificationInProg != 0) {
                //
                // If a notification is happening, add this entry to the list of
                // deferred registrations.
                //
                PPNP_DEFERRED_LIST regNode;
                regNode = (PPNP_DEFERRED_LIST)
                    HeapAlloc(ghPnPHeap,
                              0,
                              sizeof (PNP_DEFERRED_LIST));
                if (!regNode) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_WARNINGS,
                               "UMPNPMGR: Error allocating deferred list entry during registration!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    LeaveCriticalSection(&RegistrationCS);
                    bCritSecHeld = FALSE;
                    goto Clean0;
                }
                //
                // Do not notify this entry until after the current
                // notification is finished.
                //
                entry->Unregistered = TRUE;
                regNode->hBinding = 0;
                regNode->Entry = entry;
                regNode->Next = RegisterList;
                RegisterList = regNode;
            }

            hashValue = HashClassGuid(&entry->u.Class.ClassGuid);
            notifyList = &ClassList[hashValue];
            MarkEntryWithList(entry,hashValue);
            LockNotifyList(&notifyList->Lock);
            bLocked = TRUE;
            AddNotifyEntry(&ClassList[hashValue],entry);
            entry->ClientCtxPtr = (ULONG64)*ClientContext;
            *Context = entry;
            UnlockNotifyList(&notifyList->Lock);
            bLocked = FALSE;

            LeaveCriticalSection(&RegistrationCS);
            bCritSecHeld = FALSE;
            break;
        }

        default:
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in PNP_RegisterNotification\n"));
        ASSERT(0);

        Status = CR_FAILURE;

        if (bLocked) {
            UnlockNotifyList(&notifyList->Lock);
        }
        if (bCritSecHeld) {
            LeaveCriticalSection(&RegistrationCS);
        }
    }

    return Status;

} // PNP_RegisterNotification



CONFIGRET
PNP_UnregisterNotification(
    IN handle_t hBinding,
    IN PPNP_NOTIFICATION_CONTEXT Context
    )
/*++

Routine Description:

    This routine is the rpc server-side of the CMP_UnregisterNotification routine.
    It performs the remaining parameter validation and unregisters the
    corresponding notification entry.

Arguments:

    hBinding     - RPC binding handle (not used).

    Context      - Contains the address of a HDEVNOTIFY notification handle that
                   was supplied when this notification request was registered.

                   Note that when the server context is freed, this context
                   handle must be set to NULL.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    Note that the Context comes in as a PNP_NOTIFICATION_CONTEXT pointer
    It is NOT one of those. The case is correct. This is to work around
    RPC and user.

    This RPC server interface is used by local RPC clients only; it is never
    called remotely.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       hashValue = 0;
    PPNP_DEFERRED_LIST unregNode;
    PPNP_NOTIFY_LIST notifyList = NULL;
    BOOLEAN     bLocked = FALSE;


    //
    // This routine only services requests from local RPC clients.
    //
    if (!IsClientLocal(hBinding)) {
        return CR_ACCESS_DENIED;
    }

    try {
        //
        // validate notification handle
        //
        PPNP_NOTIFY_ENTRY entry = (PPNP_NOTIFY_ENTRY)*Context;

        EnterCriticalSection (&RegistrationCS);
        if (entry == NULL) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (gNotificationInProg  != 0) {

            if (RegisterList) {
                //
                // Check to see if this entry is in the deferred RegisterList.
                //
                PPNP_DEFERRED_LIST currReg,prevReg;

                currReg = RegisterList;
                prevReg = NULL;

                while (currReg) {
                    //
                    // Entries in the deferred RegisterList are to be skipped
                    // during notification.
                    //
                    ASSERT(currReg->Entry->Unregistered);
                    if (currReg->Entry == entry) {
                        //
                        // Remove this entry from the deferred RegisterList.
                        //
                        if (prevReg) {
                            prevReg->Next = currReg->Next;
                        } else {
                            RegisterList = currReg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currReg);
                        if (prevReg) {
                            currReg = prevReg->Next;
                        } else {
                            currReg = RegisterList;
                        }
                    } else {
                        prevReg = currReg;
                        currReg = currReg->Next;
                    }
                }
            }


            switch (entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

                case CLASS_ENTRY_SIGNATURE:
                case TARGET_ENTRY_SIGNATURE: {

                    unregNode = (PPNP_DEFERRED_LIST)
                        HeapAlloc(ghPnPHeap,
                                  0,
                                  sizeof (PNP_DEFERRED_LIST));

                    if (!unregNode) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Error allocating deferred list entry during unregistration!\n"));
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    //
                    // This param is not used, if this changes, change this line too.
                    //
                    unregNode->hBinding= 0;

                    notifyList = GetNotifyListForEntry(entry);
                    if (notifyList) {
                        //
                        // The entry is part of a notification list, so make
                        // sure not to notify on it.
                        //
                        LockNotifyList(&notifyList->Lock);
                        bLocked = TRUE;
                        entry->Unregistered = TRUE;
                        UnlockNotifyList(&notifyList->Lock);
                        bLocked = FALSE;
                    }
                    unregNode->Entry = entry;
                    unregNode->Next = UnregisterList;
                    UnregisterList = unregNode;
                    *Context = NULL;
                    break;
                }

                default:
                    Status = CR_INVALID_DATA;
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS | DBGF_ERRORS,
                               "UMPNPMGR: PNP_UnregisterNotification: invalid signature on entry at %x\n",
                               entry));
                    break;
            }
            goto Clean0;
        }

        //
        // Free the notification entry from the appropriate list.
        //
        switch (entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

            case CLASS_ENTRY_SIGNATURE:
                hashValue = HashClassGuid(&entry->u.Class.ClassGuid);
                notifyList = &ClassList[hashValue];
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_CLASS);
                DeleteNotifyEntry(entry,TRUE);
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
                *Context = NULL;
                break;

            case TARGET_ENTRY_SIGNATURE:
                hashValue = HashString(entry->u.Target.DeviceId, TARGET_HASH_BUCKETS);
                notifyList = &TargetList[hashValue];
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_TARGET);
                DeleteNotifyEntry(entry,TRUE);
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
                *Context = NULL;
                break;

            default:
                Status = CR_INVALID_DATA;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_ERRORS,
                           "UMPNPMGR: PNP_UnregisterNotification: invalid signature on entry at %x\n",
                           entry));
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: PNP_UnregisterNotification caused an exception!\n"));
        ASSERT(0);
        SetLastError(ERROR_EXCEPTION_IN_SERVICE);
        Status = CR_FAILURE;

        if (bLocked) {
            UnlockNotifyList(&notifyList->Lock);
        }
        LeaveCriticalSection(&RegistrationCS);
    }

    return Status;

} // PNP_UnregisterNotification




//-----------------------------------------------------------------------------
// Dynamic Event Notification Support
//-----------------------------------------------------------------------------



DWORD
ThreadProc_DeviceEvent(
   LPDWORD lpParam
   )

/*++

Routine Description:

    This routine is a thread procedure. This thread handles all device event
    notification from kernel-mode.

Arguments:

   lpParam - Not used.

Return Value:

   Currently returns TRUE/FALSE.

--*/

{
    DWORD                               status = TRUE, result = 0;
    NTSTATUS                            ntStatus = STATUS_SUCCESS;
    PPLUGPLAY_EVENT_BLOCK               eventBlock = NULL;
    ULONG                               totalSize, variableSize;
    BOOL                                notDone = TRUE;
    PVOID                               p = NULL;
    PNP_VETO_TYPE                       vetoType;
    WCHAR                               vetoName[MAX_VETO_NAME_LENGTH];
    ULONG                               vetoNameLength;
    PLUGPLAY_CONTROL_USER_RESPONSE_DATA userResponse;
    PPNP_NOTIFY_LIST notifyList = NULL;
    PPNP_DEFERRED_LIST reg,regFree,unreg,unregFree,rundown,rundownFree;

    UNREFERENCED_PARAMETER(lpParam);


    try {

        //
        // Initialize event buffer used to pass info back from kernel-mode in.
        //

        variableSize = 4096 - sizeof(PLUGPLAY_EVENT_BLOCK);
        totalSize = sizeof(PLUGPLAY_EVENT_BLOCK) + variableSize;

        eventBlock = (PPLUGPLAY_EVENT_BLOCK)HeapAlloc(ghPnPHeap, 0, totalSize);
        if (eventBlock == NULL) {
            LogErrorEvent(ERR_ALLOCATING_EVENT_BLOCK, ERROR_NOT_ENOUGH_MEMORY, 0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            status = FALSE;
            ASSERT(0);
            goto Clean0;
        }

        //
        // Retrieve device events synchronously (this is more efficient
        // than using apcs).
        //
        while (notDone) {

            ntStatus = NtGetPlugPlayEvent(NULL,
                                          NULL,     // Context
                                          eventBlock,
                                          totalSize);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                //
                // Kernel-mode side couldn't transfer the event because
                // my buffer is too small, realloc and attempt to retrieve
                // the event again.
                //
                variableSize += 1024;
                totalSize = variableSize + sizeof(PLUGPLAY_EVENT_BLOCK);

                p = HeapReAlloc(ghPnPHeap, 0, eventBlock, totalSize);
                if (p == NULL) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Couldn't reallocate event block to size %d\n",
                               totalSize));

                    LogErrorEvent(ERR_ALLOCATING_EVENT_BLOCK, ERROR_NOT_ENOUGH_MEMORY, 0);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    status = FALSE;
                    ASSERT(0);
                    goto Clean0;
                }
                eventBlock = (PPLUGPLAY_EVENT_BLOCK)p;
            }

            if (ntStatus == STATUS_SUCCESS) {
                //
                // An event was retrieved, process it.
                //
                gNotificationInProg = 1;

                vetoType = PNP_VetoTypeUnknown;
                vetoName[0] = L'\0';
                vetoNameLength = MAX_VETO_NAME_LENGTH;

                try {
                    //
                    // Process the device event.
                    //
                    result = ProcessDeviceEvent(eventBlock,
                                                totalSize,
                                                &vetoType,
                                                vetoName,
                                                &vetoNameLength);

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_EVENT,
                               "UMPNPMGR: Exception in ProcessDeviceEvent!\n"));
                    ASSERT(0);

                    //
                    // An exception while processing the event should not be
                    // considered a failure of the event itself.
                    //
                    result = TRUE;
                    vetoType = PNP_VetoTypeUnknown;
                    vetoName[0] = L'\0';
                    vetoNameLength = 0;
                }

                ASSERT(vetoNameLength < MAX_VETO_NAME_LENGTH &&
                       vetoName[vetoNameLength] == L'\0');

                //
                // Notify kernel-mode of the user-mode result.
                //
                userResponse.Response = result;
                userResponse.VetoType = vetoType;
                userResponse.VetoName = vetoName;
                userResponse.VetoNameLength = vetoNameLength;

                NtPlugPlayControl(PlugPlayControlUserResponse,
                                  &userResponse,
                                  sizeof(userResponse));

                EnterCriticalSection (&RegistrationCS);

                if (RegisterList != NULL) {
                    //
                    // Complete Registrations requested during notification.
                    //
                    reg = RegisterList;
                    RegisterList=NULL;
                } else {
                    reg = NULL;
                }
                if (UnregisterList != NULL) {
                    //
                    // Complete Unregistrations requested during notification.
                    //
                    unreg = UnregisterList;
                    UnregisterList = NULL;
                } else {
                    unreg = NULL;
                }
                if (RundownList != NULL) {
                    //
                    // Complete Unregistrations requested during notification.
                    //
                    rundown = RundownList;
                    RundownList = NULL;
                } else {
                    rundown = NULL;
                }
                gNotificationInProg = 0;

                while (reg) {
                    //
                    // This entry has already been added to the appropriate
                    // notification list.  Allow this entry to receive
                    // notifications.
                    //
                    notifyList = GetNotifyListForEntry(reg->Entry);
                    ASSERT(notifyList);
                    if (notifyList) {
                        LockNotifyList(&notifyList->Lock);
                    }
                    reg->Entry->Unregistered = FALSE;
                    if (notifyList) {
                        UnlockNotifyList(&notifyList->Lock);
                    }
                    //
                    // Remove the entry from the deferred registration list.
                    //
                    regFree = reg;
                    reg = reg->Next;
                    HeapFree(ghPnPHeap, 0, regFree);
                }

                while (unreg) {
                    PNP_UnregisterNotification(unreg->hBinding,&unreg->Entry);
                    //
                    // Remove the entry from the deferred unregistration list.
                    //
                    unregFree = unreg;
                    unreg = unreg->Next;
                    HeapFree(ghPnPHeap, 0, unregFree);
                }

                while (rundown) {
                    PNP_NOTIFICATION_CONTEXT_rundown(rundown->Entry);
                    //
                    // Remove the entry from the deferred rundown list.
                    //
                    rundownFree = rundown;
                    rundown = rundown->Next;
                    HeapFree(ghPnPHeap, 0, rundownFree);
                }

                LeaveCriticalSection(&RegistrationCS);
            }

            if (ntStatus == STATUS_NOT_IMPLEMENTED) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: NtGetPlugPlayEvent returned STATUS_NOT_IMPLEMENTED\n"));

                ASSERT(FALSE);
            }

            if (ntStatus == STATUS_USER_APC) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: ThreadProc_DeviceEvent exiting on STATUS_USER_APC\n"));

                ASSERT(FALSE);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in ThreadProc_DeviceEvent!\n"));
        ASSERT(0);
        status = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        eventBlock = eventBlock;
    }

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_ERRORS | DBGF_EVENT,
               "UMPNPMGR: Exiting ThreadProc_DeviceEvent!!!!\n"));

    TermNotification();

    if (eventBlock != NULL) {
        HeapFree(ghPnPHeap, 0, eventBlock);
    }

    return status;

} // ThreadProc_DeviceEvent



BOOL
InitNotification(
    VOID
    )

/*++

Routine Description:

    This routine allocates and initializes notification lists, etc.

Arguments:

   Not used.

Return Value:

   Currently returns TRUE/FALSE.

--*/

{
    ULONG i;

    //
    // Initialize the interface device (class) list
    //
    memset(ClassList, 0, sizeof(PNP_NOTIFY_LIST) * CLASS_GUID_HASH_BUCKETS);
    for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {
        ClassList[i].Next = NULL;
        ClassList[i].Previous = NULL;
        InitPrivateResource(&ClassList[i].Lock);
    }

    //
    // Initialize the target device list
    //
    memset(TargetList, 0, sizeof(PNP_NOTIFY_LIST) * TARGET_HASH_BUCKETS);
    for (i = 0; i < TARGET_HASH_BUCKETS; i++) {
        TargetList[i].Next = NULL;
        TargetList[i].Previous = NULL;
        InitPrivateResource(&TargetList[i].Lock);
    }

    //
    // Initialize the install list
    //
    InstallList.Next = NULL;
    InitPrivateResource(&InstallList.Lock);

    //
    // Initialize the install client list
    //
    InstallClientList.Next = NULL;
    InitPrivateResource(&InstallClientList.Lock);

    //
    // Initialize the lock for user token access
    //
    InitPrivateResource(&gTokenLock);

    //
    // Initialize the service handle list
    //
    memset(ServiceList, 0, sizeof(PNP_NOTIFY_LIST) * SERVICE_NUM_CONTROLS);
    for (i = 0; i < SERVICE_NUM_CONTROLS; i++) {
        ServiceList[i].Next = NULL;
        ServiceList[i].Previous = NULL;
        InitPrivateResource(&ServiceList[i].Lock);
    }

    //
    // Initialize Registration/Unregistration CS.
    //
    try {
        InitializeCriticalSection(&RegistrationCS);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    //
    // Initialize deferred Registration/Unregistration lists.
    //
    RegisterList = NULL;
    UnregisterList = NULL;
    RundownList = NULL;

    //
    // Initialize gNotificationInProg flag.
    //
    gNotificationInProg = 0;

    return TRUE;

} // InitNotification



VOID
TermNotification(
    VOID
    )
/*++

Routine Description:

    This routine frees notification resources.

Arguments:

   Not used.

Return Value:

   No return.

--*/
{
    ULONG i;

    //
    // Free the interface device (class) list locks
    //
    for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {
        if (LockNotifyList(&ClassList[i].Lock)) {
            DestroyPrivateResource(&ClassList[i].Lock);
        }
    }

    //
    // Free the target device list locks
    //
    for (i = 0; i < TARGET_HASH_BUCKETS; i++) {
        if (LockNotifyList(&TargetList[i].Lock)) {
            DestroyPrivateResource(&TargetList[i].Lock);
        }
    }

    //
    // Free the service notification list locks
    //
    for (i = 0; i < SERVICE_NUM_CONTROLS; i++) {
        if (LockNotifyList(&ServiceList[i].Lock)) {
            DestroyPrivateResource(&ServiceList[i].Lock);
        }
    }

    //
    // Free the install list lock
    //
    if (LockNotifyList(&InstallList.Lock)) {
        DestroyPrivateResource(&InstallList.Lock);
    }

    //
    // Free the lock for user token access
    //
    if (LockNotifyList(&gTokenLock)) {
        DestroyPrivateResource(&gTokenLock);
    }

    //
    // Free the install client list lock
    //
    if (LockNotifyList(&InstallClientList.Lock)) {
        DestroyPrivateResource(&InstallClientList.Lock);
    }

    //
    // Close the handle to winsta.dll
    //
    if (ghWinStaLib) {
        fpWinStationSendWindowMessage = NULL;
        fpWinStationBroadcastSystemMessage = NULL;
        FreeLibrary(ghWinStaLib);
        ghWinStaLib = NULL;
    }

    //
    // Close the handle to wtsapi32.dll
    //
    if (ghWtsApi32Lib) {
        fpWTSQuerySessionInformation = NULL;
        fpWTSFreeMemory = NULL;
        FreeLibrary(ghWtsApi32Lib);
        ghWtsApi32Lib = NULL;
    }

    return;

} // TermNotification



ULONG
ProcessDeviceEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN DWORD                 EventBufferSize,
    OUT PPNP_VETO_TYPE       VetoType,
    OUT LPWSTR               VetoName,
    IN OUT PULONG            VetoNameLength
    )
/*++

Routine Description:

    This routine processes device events recieved from the kernel-mode pnp
    manager.

Arguments:

   EventBlock - contains the event data.

   EventBlockSize - specifies the size (in bytes) of EventBlock.

Return Value:

   Returns FALSE if unsuccessful, or in the case of a vetoed query event.
   Returns TRUE otherwise.

Notes:

   This routine takes part in translating kernel mode PnP events into user mode
   notifications. Currently, the notification code is dispersed and duplicated
   throughout several routines. All notifications can be said to have the
   following form though:

   result = DeliverMessage(
       MessageFlags,    // [MSG_POST, MSG_SEND, MSG_QUERY] |
                        // [MSG_WALK_LIST_FORWARD, MSG_WALK_LIST_BACKWARDS]
       Target,          // A local window handle, hydra window handle (with
                        // session ID), service handle, or "broadcast".
                        // Better yet, it could take lists...
       wParam,          // DBT_* (or corresponding SERVICE_CONTROL_* message)
       lParam,          // Appropriate data (note: user has hardcoded knowledge
                        //                   about these via DBT_ type).
       queueTimeout,    // Exceeded if there exists messages in the queue but
                        // no message has been drained in the given time. Note
                        // that this means a message can fail immediately.
       responseTimeout, // Exceeded if *this* message has not been processed in
                        // the elasped time.
       VetoName,        // For queries, the name of the vetoer.
       VetoType         // Type of vetoer component (window, service, ...)
       );

   DeviceEventWorker implements targeted sends and posts (normal exported Win32
     API cannot be used as they won't reach other desktops). Currently User32
     does not allow posts of DBT_* messages with lParam data, mainly because
     a caller might send the message to itself, in which case no copy is made.
     This in theory presents the caller with no opportunity to free that data
     (note that this scenario would never occur with UmPnpMgr however, as we
     have no WndProc). User implements this function with a fixed
     responseTimeout of thirty seconds. This API can but should not be used for
     broadcasts.

   WinStationSendWindowMessage sends messages to windows within Hydra clients
     on a machine. There is no corresponding WinStationPostWindowMessage. All
     the code in this component passes a ResponseTimeout of five seconds. There
     is no queueTimeout.

   BroadcastSystemMessage implements broadcasts to all applications and desktops
     in the non-console (ie non-Hydra) session. As with DeviceEventWorker,
     User32 does not allow posts of DBT_* messages with lParam data (regardless
     of whether you pass in BSF_IGNORECURRENTTASK). All code in this component
     passes a ResponseTimeout of thirty seconds. QueueTimeout is optional,
     fixed five seconds. ResponseTimeout cannot be specified, but the maximum
     value would be five seconds per top level window. There is no information
     returned on which window vetoed a query.

   WinStationBroadcastSystemMessage broadcasts to all applications and desktops
     on a given machine's Hydra sessions. No posts of any kind may be done
     through this API. All code in this component passes a ResponseTimeout of
     five seconds. QueueTimeout is an optional, fixed five seconds. There is no
     information on which window vetoed a query.

   ServiceControlCallback sends messages to registered services. There is no
     posting or timeout facilities of any kind.

   Actually, each queued registration entry should be queued with a callback.
   We implement the callback, and there it hides the underlying complexities.

--*/

{
    DWORD eventId, serviceControl, flags, status = TRUE;
    LPWSTR p = NULL;
    ULONG vetoNameSize;
    ULONG ulLength, ulCustomDataLength, ulClientSessionId, ulHotplugFlags;
    HRESULT hr;

    UNREFERENCED_PARAMETER(EventBufferSize);

    //
    // Validate parameters
    //

    ASSERT(EventBlock->TotalSize >= sizeof(PLUGPLAY_EVENT_BLOCK));

    if (EventBlock->TotalSize < sizeof(PLUGPLAY_EVENT_BLOCK)) {
        return FALSE;
    }

    //
    // Convert the event guid into a dbt style event id.
    //

    if (!EventIdFromEventGuid(&EventBlock->EventGuid,
                              &eventId,
                              &flags,
                              &serviceControl)) {

        if (VetoNameLength != NULL) {
            *VetoNameLength = 0;
        }
        return FALSE;
    }
    if (VetoNameLength != NULL &&
        !((EventBlock->EventCategory == TargetDeviceChangeEvent) ||
          (EventBlock->EventCategory == CustomDeviceEvent) ||
          (EventBlock->EventCategory == HardwareProfileChangeEvent) ||
          (EventBlock->EventCategory == PowerEvent) ) ){
        *VetoNameLength = 0;
    }

    vetoNameSize = *VetoNameLength;

    switch (EventBlock->EventCategory) {
    
        case TargetDeviceChangeEvent:
        case VetoEvent:
        case BlockedDriverEvent:
        case InvalidIDEvent:
            if (IsFastUserSwitchingEnabled()) {
        
                ulHotplugFlags = HOTPLUG_DISPLAY_ON_CONSOLE;
                ulClientSessionId = INVALID_SESSION;
            } else {
        
                ulHotplugFlags = 0;
                ulClientSessionId = MAIN_SESSION;
            }
            break;
    
        default:
            ulHotplugFlags = 0;
            ulClientSessionId = INVALID_SESSION;
            break;
    }
    //
    // Notify registered callers first (class changes will also send generic
    // broadcast if the type is volume or port).
    //

    switch (EventBlock->EventCategory) {

    case CustomDeviceEvent: {
        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_HANDLE pNotify;
        PLUGPLAY_CUSTOM_NOTIFICATION *pTarget;

        if (*EventBlock->u.CustomNotification.DeviceIds == L'\0') {
            //
            // There are no device IDs, can't do notification in this case
            // just return
            //

            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Ignoring CustomDeviceEvent with no Device IDs\n"));

            return FALSE;
        }

        //
        // Custom events should always be this GUID, and that guid should always
        // be converted into the below eventId.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_PNP_CUSTOM_NOTIFICATION));
        ASSERT(eventId == DBT_CUSTOMEVENT);

        //
        // Handle and Marshall the custom notification.
        //

        //
        // The amount of space allocated for the EventBlock + IDs is always a
        // multiple of sizeof(PVOID) in order to keep the notification structure
        // aligned.
        //
        ulLength = sizeof(PLUGPLAY_EVENT_BLOCK) + (lstrlen(EventBlock->u.CustomNotification.DeviceIds) + 1) * sizeof(WCHAR);

        ulLength += sizeof(PVOID) - 1;
        ulLength &= ~(sizeof(PVOID) - 1);

        //
        // The notification structure follows the Event Block and IDs
        //

        pTarget = (PPLUGPLAY_CUSTOM_NOTIFICATION)((PUCHAR)EventBlock + ulLength);

        ulCustomDataLength = pTarget->HeaderInfo.Size - FIELD_OFFSET(PLUGPLAY_CUSTOM_NOTIFICATION,CustomDataBuffer);

        pNotify = HeapAlloc(ghPnPHeap, 0, sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength);

        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_NOTIFICATION_STRUCTURE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            break;
        }

        memset(pNotify, 0, sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength);

        pNotify->dbch_size = sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength;


        pNotify->dbch_devicetype = DBT_DEVTYP_HANDLE;

        pNotify->dbch_nameoffset = pTarget->NameBufferOffset;
        pNotify->dbch_eventguid = pTarget->HeaderInfo.Event;

        memcpy( pNotify->dbch_data, pTarget->CustomDataBuffer, ulCustomDataLength);

        *VetoNameLength = vetoNameSize;

        status = NotifyTargetDeviceChange( serviceControl,
                                           eventId,
                                           flags,
                                           pNotify,
                                           EventBlock->u.CustomNotification.DeviceIds,
                                           VetoType,
                                           VetoName,
                                           VetoNameLength);

        if (GuidEqual(&pNotify->dbch_eventguid, (LPGUID)&GUID_IO_VOLUME_NAME_CHANGE)) {
            //
            // Broadcast compatible volume removal and arrival notifications
            // (if any) after the custom name change event has been sent to
            // all recipients.
            //
            BroadcastVolumeNameChange();
        }

        HeapFree(ghPnPHeap, 0, pNotify);
        break;
    }

    case TargetDeviceChangeEvent: {

        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_HANDLE pNotify;

        if (*EventBlock->u.TargetDevice.DeviceIds == L'\0') {
            //
            // There are no device IDs, can't do notification in this case
            // just return
            //

            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Ignoring TargetDeviceChangeEvent with no Device IDs\n"));

            return FALSE;
        }

        //
        // If this is a surprise removal event then call HOTPLUG.DLL to display
        // a warning to the user before sending this event to other apps.
        //
        if (GuidEqual(&EventBlock->EventGuid,&GUID_DEVICE_SAFE_REMOVAL)) {

            SendHotplugNotification(
                &EventBlock->EventGuid,
                NULL,
                EventBlock->u.TargetDevice.DeviceIds,
                &ulClientSessionId,
                ulHotplugFlags
                );

        } else if (GuidEqual(&EventBlock->EventGuid, &GUID_DEVICE_KERNEL_INITIATED_EJECT)) {

            *VetoNameLength = vetoNameSize;
            status = CheckEjectPermissions(
                EventBlock->u.TargetDevice.DeviceIds,
                VetoType,
                VetoName,
                VetoNameLength
                );

        } else if (GuidEqual(&EventBlock->EventGuid,&GUID_DEVICE_SURPRISE_REMOVAL)) {

            LogSurpriseRemovalEvent(EventBlock->u.TargetDevice.DeviceIds);

#if 0 // We don't display surpise-removal bubbles anymore...
            SendHotplugNotification(
                &EventBlock->EventGuid,
                NULL,
                EventBlock->u.TargetDevice.DeviceIds,
                &ulClientSessionId,
                ulHotplugFlags
                );
#endif
        }

        if (eventId == 0) {

            //
            // Internal event, no broadcasting should be done.
            //
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            break;
        }

        pNotify = HeapAlloc(ghPnPHeap, 0, sizeof(DEV_BROADCAST_HANDLE));
        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_BROADCAST_HANDLE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }
            break;
        }

        memset(pNotify, 0, sizeof(DEV_BROADCAST_HANDLE));

        pNotify->dbch_nameoffset = -1;  // empty except for custom events
        pNotify->dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        pNotify->dbch_devicetype = DBT_DEVTYP_HANDLE;

        for (p = EventBlock->u.TargetDevice.DeviceIds;
             *p;
             p += lstrlen(p) + 1) {

            *VetoNameLength = vetoNameSize;

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: Processing TargetDeviceChangeEvent (0x%lx) for %ws\n",
                       eventId, p));

            status = NotifyTargetDeviceChange(serviceControl,
                                              eventId,
                                              flags,
                                              pNotify,
                                              p,
                                              VetoType,
                                              VetoName,
                                              VetoNameLength);

            if (!status && (flags & BSF_QUERY)) {
                LPWSTR pFail = p;
                DWORD dwCancelEventId;

                //
                // Use the appropriate cancel device event id that corresponds to the
                // original query device event id.
                //

                dwCancelEventId = MapQueryEventToCancelEvent(eventId);

                for (p = EventBlock->u.TargetDevice.DeviceIds;
                    *p && p != pFail;
                    p += lstrlen(p) + 1) {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT,
                               "UMPNPMGR: Processing TargetDeviceChangeEvent (0x%lx) for %ws\n",
                               dwCancelEventId, p));

                    NotifyTargetDeviceChange( serviceControl,
                                              dwCancelEventId,
                                              BSF_NOHANG,
                                              pNotify,
                                              p,
                                              NULL,
                                              NULL,
                                              NULL);

                }
                break;
            }
        }

        HeapFree(ghPnPHeap, 0, pNotify);
        break;
    }

    case DeviceClassChangeEvent: {

        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_DEVICEINTERFACE pNotify;
        ULONG ulSize;

        ulSize = sizeof(DEV_BROADCAST_DEVICEINTERFACE) +
            (lstrlen(EventBlock->u.DeviceClass.SymbolicLinkName) * sizeof(WCHAR));

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing DeviceClassChangeEvent (0x%lx) for %ws\n",
                   eventId, EventBlock->u.DeviceClass.SymbolicLinkName));

        pNotify = HeapAlloc(ghPnPHeap, 0, ulSize);
        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_BROADCAST_INTERFACE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            break;
        }

        pNotify->dbcc_size = ulSize;
        pNotify->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        pNotify->dbcc_reserved = 0;
        memcpy(&pNotify->dbcc_classguid, &EventBlock->u.DeviceClass.ClassGuid, sizeof(GUID));

        hr = StringCbCopy(pNotify->dbcc_name,
                          ulSize
                          - sizeof(DEV_BROADCAST_DEVICEINTERFACE)
                          + sizeof(WCHAR),
                          EventBlock->u.DeviceClass.SymbolicLinkName);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
            status = FALSE;
            break;
        }

        //
        // Note: the symbolic link name is passed in kernel-mode format (\??\),
        // convert to user-mode format (\\?\) before sending notification.
        // Note that the only difference is the second character.
        //
        pNotify->dbcc_name[1] = L'\\';

        status = NotifyInterfaceClassChange(serviceControl,
                                            eventId,
                                            flags,
                                            pNotify);
        break;
    }

    case HardwareProfileChangeEvent:

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing HardwareProfileChangeEvent (0x%lx)\n",
                   eventId));

        *VetoNameLength = vetoNameSize;
        status = NotifyHardwareProfileChange(serviceControl,
                                             eventId,
                                             flags,
                                             VetoType,
                                             VetoName,
                                             VetoNameLength);
        break;

    case PowerEvent:
        *VetoNameLength = vetoNameSize;

        //
        // Since all power events arrive under a single event GUID,
        // EventIdFromEventGuid cannot correctly determine the event id or query
        // flags from it.  Instead, we get the event id directly from the device
        // event block, and add the BSF_QUERY flag here, if appropriate.
        //
        eventId = EventBlock->u.PowerNotification.NotificationCode;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing PowerEvent (0x%lx)\n",
                   eventId));

        if ((eventId == PBT_APMQUERYSUSPEND) ||
            (eventId == PBT_APMQUERYSTANDBY)) {
            flags |= BSF_QUERY;
        } else {
            flags &= ~BSF_QUERY;
        }

        status = NotifyPower(serviceControl,
                             eventId,
                             EventBlock->u.PowerNotification.NotificationData,
                             flags,
                             VetoType,
                             VetoName,
                             VetoNameLength);
        break;

    case VetoEvent:

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing VetoEvent\n"));

        status = SendHotplugNotification(
            &EventBlock->EventGuid,
            &EventBlock->u.VetoNotification.VetoType,
            EventBlock->u.VetoNotification.DeviceIdVetoNameBuffer,
            &ulClientSessionId,
            ulHotplugFlags
            );

        break;

    case DeviceInstallEvent: {

        //
        // Initiate installation; we can't wait around here for a user, but
        // after installation is complete, kernel-mode will be notified
        // that they can attempt to start the device now.
        //
        PPNP_INSTALL_ENTRY entry = NULL, current = NULL;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing DeviceInstallEvent for %ws\n",
                   EventBlock->u.InstallDevice.DeviceId));

        //
        // Device install events should always be this GUID, and that guid
        // should always be converted into the below eventId, serviceControl and
        // flags.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_DEVICE_ENUMERATED));
        ASSERT((eventId == DBT_DEVICEARRIVAL) && (serviceControl == 0) && (flags == 0));

        //
        // Allocate and initialize a new device install entry block.
        //
        entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_INSTALL_ENTRY));
        if (!entry) {
            break;
        }

        entry->Next = NULL;
        entry->Flags = 0;

        hr = StringCchCopy(entry->szDeviceId,
                           MAX_DEVICE_ID_LEN,
                           EventBlock->u.InstallDevice.DeviceId);
        ASSERT(SUCCEEDED(hr));

        //
        // Insert this entry in the device install list.
        //
        LockNotifyList(&InstallList.Lock);

        current = (PPNP_INSTALL_ENTRY)InstallList.Next;
        if (current == NULL) {
            InstallList.Next = entry;
        } else {
            while ((PPNP_INSTALL_ENTRY)current->Next != NULL) {
                current = (PPNP_INSTALL_ENTRY)current->Next;
            }
            current->Next = entry;
        }

        UnlockNotifyList(&InstallList.Lock);

        SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

        //
        // Generate a devnode changed message
        //
        NotifyTargetDeviceChange(serviceControl,
                                 eventId,
                                 flags,
                                 NULL,
                                 EventBlock->u.InstallDevice.DeviceId,
                                 NULL,
                                 NULL,
                                 NULL);

        break;
    }

    case BlockedDriverEvent: {

        LPGUID BlockedDriverGuid;
        PWSTR  MultiSzGuidList = NULL;

        //
        // Display notification to the Console session that the system just
        // blocked a driver from loading on the system.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_DRIVER_BLOCKED));

        //
        // We currently only ever have one blocked driver GUID per event,
        // but SendHotplugNotification and hotplug.dll are setup to deal
        // with multi-sz lists, so we'll just construct one for them.  This
        // keeps hotplug.dll extensible, should we decide in the future to
        // have the kernel-mode pnpmgr "batch" blocked drivers per devnode.
        //
        BlockedDriverGuid = (LPGUID)&EventBlock->u.BlockedDriverNotification.BlockedDriverGuid;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing BlockedDriverEvent for GUID = "
                   "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                   BlockedDriverGuid->Data1,
                   BlockedDriverGuid->Data2,
                   BlockedDriverGuid->Data3,
                   BlockedDriverGuid->Data4[0],
                   BlockedDriverGuid->Data4[1],
                   BlockedDriverGuid->Data4[2],
                   BlockedDriverGuid->Data4[3],
                   BlockedDriverGuid->Data4[4],
                   BlockedDriverGuid->Data4[5],
                   BlockedDriverGuid->Data4[6],
                   BlockedDriverGuid->Data4[7]));

        MultiSzGuidList = BuildBlockedDriverList(BlockedDriverGuid, 1);

        if (MultiSzGuidList != NULL) {
            SendHotplugNotification((LPGUID)&GUID_DRIVER_BLOCKED,
                                    NULL,
                                    MultiSzGuidList,
                                    &ulClientSessionId,
                                    ulHotplugFlags);
            HeapFree(ghPnPHeap, 0, MultiSzGuidList);
            MultiSzGuidList = NULL;
        }

        break;
    }

    case InvalidIDEvent: {

        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_DEVICE_INVALID_ID));
        //
        // Display notification to the Console session that the system just
        // encountered an invalid ID from a device.
        //
        SendHotplugNotification((LPGUID)&GUID_DEVICE_INVALID_ID,
                                NULL,
                                &EventBlock->u.InvalidIDNotification.ParentId[0],
                                &ulClientSessionId,
                                ulHotplugFlags);
        break;
    }

    default:
        break;

    }

    return status;

} // ProcessDeviceEvent



ULONG
NotifyInterfaceClassChange(
    IN DWORD ServiceControl,
    IN DWORD EventId,
    IN DWORD Flags,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    )
/*++

Routine Description:

    This routine notifies registered services and windows of device interface
    change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Unused (Specifies BroadcastSystemMessage BSF_ flags.)

    ClassData      - Pointer to a PDEV_BROADCAST_DEVICEINTERFACE structure that
                     is already filled out with the pertinent data for this
                     event.

Return Value:

    Returns TRUE.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD result;
    ULONG hashValue, pass, i;
    PPNP_NOTIFY_ENTRY classEntry = NULL, nextEntry = NULL;
    PPNP_NOTIFY_LIST  notifyList;
    LPGUID entryGuid[3];

    UNREFERENCED_PARAMETER(Flags);

    //
    // Search the notification lists twice - once to notify entries registered
    // on the device interface class for this device interface, and again to
    // notify entries registered for all device interfaces.
    //
    entryGuid[0] = (LPGUID)&ClassData->dbcc_classguid;
    entryGuid[1] = (LPGUID)&GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES;
    entryGuid[2] = (LPGUID)NULL;

    for (i = 0; entryGuid[i] != NULL; i++) {

        //
        // The list of registered callers is hashed for quicker access and
        // comparison. Walk the list of registered callers and notify anyone
        // that registered an interest in this device interface class guid.
        //
        hashValue = HashClassGuid(entryGuid[i]);
        notifyList = &ClassList[hashValue];
        LockNotifyList(&notifyList->Lock);

        classEntry = GetFirstNotifyEntry(&ClassList[hashValue], 0);
        pass = GetFirstPass(FALSE);
        while (pass != PASS_COMPLETE) {
            while (classEntry) {

                nextEntry = GetNextNotifyEntry(classEntry, 0);

                if (classEntry->Unregistered) {
                    classEntry = nextEntry;
                    continue;
                }

                if (GuidEqual(entryGuid[i], &classEntry->u.Class.ClassGuid)) {

                    if (GuidEqual(&classEntry->u.Class.ClassGuid,
                                  &GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES)) {
                        //
                        // If the entry is marked with our special GUID, make
                        // sure it is because it was registered with the
                        // appropriate flag.
                        //
                        ASSERT((classEntry->Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                               DEVICE_NOTIFY_ALL_INTERFACE_CLASSES);
                    }

                    if ((pass == DEVICE_NOTIFY_WINDOW_HANDLE) &&
                        (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_WINDOW_HANDLE)) {

                        //
                        // Note, class changes currently only support non-query type
                        // messages so special processing is not required (PostMessage
                        // only). Unfortunately, the PostMessage call currently fails
                        // if the high bit of the wParam value is set (which it is in
                        // this case), so we are forced to Send the message (rather than
                        // Post it). USER group implemented it this way because the original
                        // Win95 spec doesn't call for the recipient to free the message
                        // so we have to free it and we have no idea when it's safe
                        // with a PostMessage call.
                        //

                        UnlockNotifyList(&notifyList->Lock);
                        if (classEntry->SessionId == MAIN_SESSION) {

                            ntStatus = DeviceEventWorker(classEntry->Handle,
                                                         EventId,
                                                         (LPARAM)ClassData,
                                                         TRUE,
                                                         &result);

                        } else {
                            if (fpWinStationSendWindowMessage) {
                                try {
                                    if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                      classEntry->SessionId,
                                                                      DEFAULT_SEND_TIME_OUT,
                                                                      HandleToUlong(classEntry->Handle),
                                                                      WM_DEVICECHANGE,
                                                                      (WPARAM)EventId,
                                                                      (LPARAM)ClassData,
                                                                      (LONG*)&result)) {
                                        ntStatus = STATUS_SUCCESS;
                                    } else {
                                        ntStatus = STATUS_UNSUCCESSFUL;
                                    }
                                } except (EXCEPTION_EXECUTE_HANDLER) {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_ERRORS,
                                               "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                    ASSERT(0);
                                    ntStatus = STATUS_SUCCESS;
                                }
                            }

                        }
                        LockNotifyList(&notifyList->Lock);

                        if (!NT_SUCCESS(ntStatus)) {
                            if (ntStatus == STATUS_INVALID_HANDLE) {
                                //
                                // window handle no longer exists, cleanup this entry
                                //
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_WARNINGS | DBGF_ERRORS,
                                           "UMPNPMGR: Invalid window handle for '%ws' during DeviceClassChangeEvent, removing entry.\n",
                                           classEntry->ClientName));
                                classEntry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN);
                                DeleteNotifyEntry(classEntry,FALSE);

                            } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_WARNINGS | DBGF_ERRORS,
                                           "UMPNPMGR: Window '%ws' timed out on DeviceClassChangeEvent\n",
                                           classEntry->ClientName));
                                LogWarningEvent(WRN_INTERFACE_CHANGE_TIMED_OUT, 1, classEntry->ClientName);
                            }
                        }
                    } else if ((pass == DEVICE_NOTIFY_SERVICE_HANDLE) &&
                               (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_SERVICE_HANDLE)) {

                        //
                        // Call the services handler routine...
                        //
                        if (pServiceControlCallback) {
                            UnlockNotifyList(&notifyList->Lock);
                            result = NO_ERROR;
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)classEntry->Handle,
                                                          ServiceControl,
                                                          EventId,
                                                          (LPARAM)ClassData,
                                                          &result);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                result = NO_ERROR;
                                ASSERT(0);
                            }
                            LockNotifyList(&notifyList->Lock);
                        }

                    } else if ((pass == DEVICE_NOTIFY_COMPLETION_HANDLE) &&
                               (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_COMPLETION_HANDLE)) {
                        //
                        // Complete the notification handle.
                        // NOTE: Notification completion handles not implemented.
                        //
                        NOTHING;
                    }
                }

                classEntry = nextEntry;
            }

            pass=GetNextPass(pass,FALSE);
            classEntry = GetFirstNotifyEntry (&ClassList[hashValue],0);
        }

        UnlockNotifyList(&notifyList->Lock);
    }

    //
    // Perform Win9x compatible device interface arrival and removal notification.
    //
    BroadcastCompatibleDeviceMsg(EventId, ClassData, NULL);

    HeapFree(ghPnPHeap, 0, ClassData);

    //
    // For device interface notification, there are no query type events, by
    // definition, so we always return TRUE from this routine (no veto).
    //
    return TRUE;

} // NotifyInterfaceClassChange



ULONG
NotifyTargetDeviceChange(
    IN  DWORD                   ServiceControl,
    IN  DWORD                   EventId,
    IN  DWORD                   Flags,
    IN  PDEV_BROADCAST_HANDLE   HandleData,
    IN  LPWSTR                  DeviceId,
    OUT PPNP_VETO_TYPE          VetoType       OPTIONAL,
    OUT LPWSTR                  VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies registered services and windows of target device
    change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.
                     Note that BroadcastSystemMessage is not actually used for
                     target device events, but the specified BSF_ flags are used
                     to determine query and cancel event notification ordering.

    HandleData     - Pointer to a PDEV_BROADCAST_HANDLE structure that is
                     already filled out with most of the pertinent data for this
                     event.

    DeviceId       - Supplies the device instance id of the target device for
                     this event.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

Note:

    For DBT_DEVICEARRIVAL, DBT_DEVICEREMOVEPENDING, and DBT_DEVICEREMOVECOMPLETE
    events this routine also broadcasts a WM_DEVICECHANGE / DBT_DEVNODES_CHANGED
    message to all windows.  There is no additional device-specific data for
    this message; it is only used by components like device manager to refresh
    the list of devices in the system.

    Also note that the DBT_DEVNODES_CHANGED message is the only notification
    sent for DBT_DEVICEARRIVAL (kernel GUID_DEVICE_ARRIVAL) events.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD result = 0;
    ULONG hashValue, pass;
    PPNP_NOTIFY_ENTRY targetEntry, nextEntry;
    PPNP_NOTIFY_LIST  notifyList = NULL;
    BOOL              bLocked = FALSE;
    DWORD err;
    BOOL serviceVetoedQuery;
    DWORD recipients = BSM_ALLDESKTOPS | BSM_APPLICATIONS;
    LONG response;
#ifdef _WIN64
    DEV_BROADCAST_HANDLE32 UNALIGNED *HandleData32 = NULL;
    ULONG  ulHandleDataSize;
#endif // _WIN64
    PVOID pHandleData;

    serviceVetoedQuery = FALSE;

    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    //
    // Broadcast the DBT_DEVNODES_CHANGED message before any other notification
    // events, so components listening for those can update themselves in a
    // timely manner, and not be delayed by apps/services hung on their
    // notification event.  This broadcasts is a post, so it will return
    // immediately, and complete asynchronously.
    //
    if ((EventId == DBT_DEVICEARRIVAL) ||
        (EventId == DBT_DEVICEREMOVEPENDING) ||
        (EventId == DBT_DEVICEREMOVECOMPLETE)) {

        BroadcastSystemMessage(BSF_POSTMESSAGE,
                               &recipients,
                               WM_DEVICECHANGE,
                               DBT_DEVNODES_CHANGED,
                               (LPARAM)NULL);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   BSF_NOHANG | BSF_POSTMESSAGE,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)DBT_DEVNODES_CHANGED,
                                                   (LPARAM)NULL,
                                                   &response);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }
    }

    //
    // For target device arrival events, no additional notification is
    // performed.
    //
    if (EventId == DBT_DEVICEARRIVAL) {
        goto Clean0;
    }

#ifdef _WIN64
    //
    // Prepare a 32-bit notification structure, which we'll need to send to any
    // WOW64 clients that are registered.
    //
    ASSERT(sizeof(DEV_BROADCAST_HANDLE) == sizeof(DEV_BROADCAST_HANDLE64));
    ASSERT(HandleData->dbch_size >= sizeof(DEV_BROADCAST_HANDLE64));

    ulHandleDataSize = HandleData->dbch_size -
        sizeof(DEV_BROADCAST_HANDLE64) +
        sizeof(DEV_BROADCAST_HANDLE32);

    ASSERT(ulHandleDataSize >= sizeof(DEV_BROADCAST_HANDLE32));

    HandleData32 = HeapAlloc(ghPnPHeap, 0, ulHandleDataSize);
    if (HandleData32 == NULL) {
        goto Clean0;
    }

    memset(HandleData32, 0, ulHandleDataSize);
    HandleData32->dbch_size = ulHandleDataSize;
    HandleData32->dbch_devicetype = DBT_DEVTYP_HANDLE;
    HandleData32->dbch_nameoffset = HandleData->dbch_nameoffset;

    memcpy(&HandleData32->dbch_eventguid,
           &HandleData->dbch_eventguid,
           sizeof(GUID));

    memcpy(&HandleData32->dbch_data,
           &HandleData->dbch_data,
           (HandleData->dbch_size - FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)));
#endif // _WIN64

    //
    // Sanitize the device id
    //
    FixUpDeviceId(DeviceId);

    //
    // The list of registered callers is hashed for quicker access and
    // comparison. Walk the list of registered callers and notify anyone
    // that registered an interest in this device instance.
    //

    hashValue = HashString(DeviceId, TARGET_HASH_BUCKETS);
    notifyList = &TargetList[hashValue];
    LockNotifyList(&notifyList->Lock);
    bLocked = TRUE;

    pass = GetFirstPass(Flags & BSF_QUERY);

    do {

        targetEntry = GetFirstNotifyEntry (notifyList,Flags);


        while (targetEntry) {

            nextEntry = GetNextNotifyEntry(targetEntry,Flags);

            if (targetEntry->Unregistered) {
                targetEntry = nextEntry;
                continue;
            }

            if (CompareString(
                    LOCALE_INVARIANT, NORM_IGNORECASE,
                    DeviceId, -1,
                    targetEntry->u.Target.DeviceId, -1) == CSTR_EQUAL) {

                if ((pass == DEVICE_NOTIFY_WINDOW_HANDLE) &&
                    (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_WINDOW_HANDLE)) {


                    //
                    // Note: we could get away with only doing a send message
                    // if the Flags has BSF_QUERY set and do a post message in
                    // all other cases. Unfortunately, the PostMessage call currently
                    // fails if the high bit of the wParam value is set (which it is in
                    // this case), so we are forced to Send the message (rather than
                    // Post it). USER group implemented it this way because the original
                    // Win95 spec doesn't call for the recipient to free the message
                    // so we have to free it and we have no idea when it's safe
                    // with a PostMessage call.
                    //
                    HandleData->dbch_handle     =
                        targetEntry->u.Target.FileHandle;
                    HandleData->dbch_hdevnotify =
                        (HDEVNOTIFY)((ULONG_PTR)targetEntry->ClientCtxPtr);

                    UnlockNotifyList(&notifyList->Lock);
                    bLocked = FALSE;

                    //
                    // Always send the native DEV_BROADCAST_HANDLE structure to
                    // windows.  If any 64-bit/32-bit conversion needs to be
                    // done for this client, ntuser will do it for us.
                    //
                    pHandleData = HandleData;

                    if (targetEntry->SessionId == MAIN_SESSION ) {

                        ntStatus = DeviceEventWorker(targetEntry->Handle,
                                                     EventId,
                                                     (LPARAM)pHandleData,
                                                     TRUE,
                                                     &result);
                    } else {
                        if (fpWinStationSendWindowMessage) {
                            try {
                                if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                  targetEntry->SessionId,
                                                                  DEFAULT_SEND_TIME_OUT,
                                                                  HandleToUlong(targetEntry->Handle),
                                                                  WM_DEVICECHANGE,
                                                                  (WPARAM)EventId,
                                                                  (LPARAM)pHandleData,
                                                                  (LONG*)&result)) {
                                    ntStatus = STATUS_SUCCESS;
                                } else {
                                    ntStatus = STATUS_UNSUCCESSFUL;
                                }
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                ASSERT(0);
                                ntStatus = STATUS_SUCCESS;
                            }
                        }
                    }
                    LockNotifyList(&notifyList->Lock);
                    bLocked = TRUE;

                    if (NT_SUCCESS(ntStatus)) {

                        //
                        // This call succeeded, if it's a query type call, check
                        // the result returned.
                        //

                        if ((Flags & BSF_QUERY) && (result == BROADCAST_QUERY_DENY)) {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_EVENT,
                                       "UMPNPMGR: Window '%ws' vetoed TargetDeviceChangeEvent\n",
                                       targetEntry->ClientName));

                            WindowVeto(targetEntry, VetoType, VetoName, VetoNameLength);

                            //
                            // Haven't told the services yet.  Note that we
                            // always call this routine with the native
                            // DEV_BROADCAST_HANDLE structure, since it walks
                            // the entire list itself.  It will do the
                            // conversion again, if necessary.
                            //
                            SendCancelNotification(targetEntry,
                                                   ServiceControl,
                                                   EventId,
                                                   BSF_QUERY,
                                                   (PDEV_BROADCAST_HDR)HandleData,
                                                   DeviceId);
                            goto Clean0;
                        }

                    } else if (ntStatus == STATUS_INVALID_HANDLE) {

                        //
                        // window handle no longer exists, cleanup this entry
                        //
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Invalid window handle for '%ws' during TargetDeviceChangeEvent, removing entry.\n",
                                   targetEntry->ClientName));
                        targetEntry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN);
                        DeleteNotifyEntry(targetEntry,FALSE);

                    } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Window '%ws' timed out on TargetDeviceChangeEvent\n",
                                   targetEntry->ClientName));
                        LogWarningEvent(WRN_TARGET_DEVICE_CHANGE_TIMED_OUT, 1, targetEntry->ClientName);
                    }

                } else if ((pass == DEVICE_NOTIFY_SERVICE_HANDLE) &&
                           (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_SERVICE_HANDLE)) {

                    if (pServiceControlCallback) {
                        //
                        // Call the services handler routine...
                        //
                        HandleData->dbch_handle     =
                            targetEntry->u.Target.FileHandle;
                        HandleData->dbch_hdevnotify =
                            (HDEVNOTIFY)((ULONG_PTR)targetEntry->ClientCtxPtr);

                        //
                        // Assume we're sending the native DEV_BROADCAST_HANDLE
                        // structure.
                        //
                        pHandleData = HandleData;
#ifdef _WIN64
                        //
                        // If the client is running on WOW64, send it the 32-bit
                        // DEV_BROADCAST_HANDLE structure we created instead.
                        //
                        if (targetEntry->Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                            HandleData32->dbch_handle =
                                (ULONG32)PtrToUlong(targetEntry->u.Target.FileHandle);
                            HandleData32->dbch_hdevnotify =
                                (ULONG32)PtrToUlong((HDEVNOTIFY)targetEntry->ClientCtxPtr);
                            pHandleData = HandleData32;
                        }
#endif // _WIN64

                        try {
                            UnlockNotifyList(&notifyList->Lock);
                            bLocked = FALSE;
                            err = NO_ERROR;
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)targetEntry->Handle,
                                                          ServiceControl,
                                                          EventId,
                                                          (LPARAM)pHandleData,
                                                          &err);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                ASSERT(0);
                                err = NO_ERROR;
                            }
                            LockNotifyList(&notifyList->Lock);
                            bLocked = TRUE;
                            //
                            // convert Win32 error into window message-style
                            // return value
                            //
                            if (err == NO_ERROR) {
                                result = TRUE;
                            } else {

                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_EVENT,
                                           "UMPNPMGR: Service %ws responded to TargetDeviceChangeEvent with status=0x%08lx\n",
                                           targetEntry->ClientName,
                                           err));

                                //
                                // This service specifically requested to receive this
                                // notification - it should know how to handle it.
                                //
                                ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                                //
                                // Log the error the service used to veto.
                                //
                                LogWarningEvent(WRN_TARGET_DEVICE_CHANGE_SERVICE_VETO,
                                                1,
                                                targetEntry->ClientName);

                                result = BROADCAST_QUERY_DENY;
                            }

                            if ((Flags & BSF_QUERY) && (result == BROADCAST_QUERY_DENY)) {

                                serviceVetoedQuery = TRUE;

                                ServiceVeto(targetEntry, VetoType, VetoName, VetoNameLength );

                                //
                                // This service vetoed the query, tell everyone
                                // else it was cancelled.  Note that we always
                                // call this routine with the native
                                // DEV_BROADCAST_HANDLE structure, since it
                                // walks the entire list itself.  It will do the
                                // conversion again, if necessary.
                                //
                                SendCancelNotification(targetEntry,
                                                       ServiceControl,
                                                       EventId,
                                                       BSF_QUERY,
                                                       (PDEV_BROADCAST_HDR)HandleData,
                                                       DeviceId);
                            }
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling Service Control Manager!\n"));
                            ASSERT(0);

                            //
                            // Reference the "serviceVetoedQuery" variable to
                            // ensure the compiler will respect statement
                            // ordering w.r.t. this variable.  We want to make
                            // sure we know with certainty whether any service
                            // vetoed the query, even if subsequently sending
                            // the cancel caused an access violation.
                            //
                            serviceVetoedQuery = serviceVetoedQuery;
                        }

                        if (serviceVetoedQuery) {
                            goto Clean0;
                        }
                    }

                } else if ((pass == DEVICE_NOTIFY_COMPLETION_HANDLE) &&
                           (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_COMPLETION_HANDLE)) {
                    //
                    // Complete the notification handle.
                    // NOTE: Notification completion handles not implemented.
                    //
                    NOTHING;
                }
            }

            targetEntry = nextEntry;
        } // while

    } while ((pass = GetNextPass(pass, (Flags & BSF_QUERY))) != PASS_COMPLETE);

    if (VetoNameLength != NULL) {
        *VetoNameLength = 0;
    }

Clean0:

    if (bLocked) {
        UnlockNotifyList(&notifyList->Lock);
    }

#ifdef _WIN64
    //
    // Free the 32-bit DEV_BROADCAST_HANDLE structure, if we allocated one.
    //
    if (HandleData32 != NULL) {
        HeapFree(ghPnPHeap, 0, HandleData32);
    }
#endif // _WIN64

    return (result != BROADCAST_QUERY_DENY);

} // NotifyTargetDeviceChange



ULONG
NotifyHardwareProfileChange(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies registered services and all windows of hardware
    profile change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined hardware profile change events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

--*/
{
    DWORD   pass;
    DWORD   recipients = BSM_ALLDESKTOPS | BSM_APPLICATIONS;
    PPNP_NOTIFY_ENTRY entry = NULL, nextEntry = NULL;
    PPNP_NOTIFY_LIST  notifyList = NULL;
    BOOL    bLocked = FALSE;
    LONG    response;
    ULONG   successful;
    LONG    result;
    DWORD   err;

    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    notifyList = &ServiceList[CINDEX_HWPROFILE];

    LockNotifyList(&notifyList->Lock);
    bLocked = TRUE;

    successful = TRUE;

    pass = GetFirstPass(Flags & BSF_QUERY);
    try {

        while (pass != PASS_COMPLETE) {

            if (pass == DEVICE_NOTIFY_WINDOW_HANDLE) {
                //
                // Notify the Windows
                //
                UnlockNotifyList (&notifyList->Lock);
                bLocked = FALSE;

                //
                // ISSUE-2002/02/20-jamesca: BroadcastSystemMessage veto info?
                //
                //   While we could *technically* use BroadcastSystemMessageEx
                //   to receive the hWnd of the vetoing window, and a handle to
                //   the Desktop that it is on, we don't actually know what
                //   WindowStation that Desktop is in!!!  The BSM_ALLDESKTOPS
                //   flags actually causes the message to be sent to all
                //   Desktops on *all WindowStations* in this session -- which
                //   for a non-interactive service in session 0 (such as this),
                //   would include all Desktops in all WindowStations being used
                //   by all non-interactive services.  In reality, a vetoing
                //   application would *most likely* be an interactive process
                //   on WinSta0, but there really is no guarantee that's the
                //   case.  Even if we did know the complete WindowStation and
                //   Desktop location of the window, we would need to have a
                //   thread running on the same desktop just to access it -
                //   which would require either changing the windowstation for
                //   our entire process (a very very bad idea, since we share
                //   this process with the SCM and other services!!), or start a
                //   whole new process over there, and communicate with it.  As
                //   you can see, this info was probably only intended to be
                //   useful for a caller already in the interactive
                //   WindowStation, to find out about vetoing windows also in
                //   the interactive WindowStation, and is therefore not really
                //   of much use to us -- so we may as well just go back to
                //   using BroadcastSystemMessage.  *sigh*
                //
                result = BroadcastSystemMessage(Flags,
                                                &recipients,
                                                WM_DEVICECHANGE,
                                                (WPARAM)EventId,
                                                (LPARAM)NULL);
                if ((result <= 0) && (Flags & BSF_QUERY)) {

                    WinBroadcastVeto(NULL, VetoType, VetoName, VetoNameLength);
                    successful = FALSE;
                    break;
                }

                if ((result > 0) || (!(Flags & BSF_QUERY))) {
                    if (fpWinStationBroadcastSystemMessage) {
                        try {
                            fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                               TRUE,
                                                               0,
                                                               DEFAULT_BROADCAST_TIME_OUT,
                                                               Flags,
                                                               &recipients,
                                                               WM_DEVICECHANGE,
                                                               (WPARAM)EventId,
                                                               (LPARAM)NULL,
                                                               &result);
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                            ASSERT(0);
                            result = 1;
                        }
                    }

                }
                LockNotifyList (&notifyList->Lock);
                bLocked = TRUE;

                if ((result < 0) && (Flags & BSF_QUERY)) {

                    UnknownVeto(VetoType, VetoName, VetoNameLength);
                    successful = FALSE;
                    break;

                } else if ((result == 0) && (Flags & BSF_QUERY)) {

                    WinBroadcastVeto(NULL, VetoType, VetoName, VetoNameLength);
                    successful = FALSE;
                    break;
                }

            } else if (pass == DEVICE_NOTIFY_SERVICE_HANDLE) {
                //
                // Notify the services
                //
                entry = GetFirstNotifyEntry (notifyList,Flags & BSF_QUERY);

                while (entry) {

                    nextEntry = GetNextNotifyEntry(entry,Flags & BSF_QUERY);

                    if (entry->Unregistered) {
                        entry = nextEntry;
                        continue;
                    }

                    ASSERT(GetPassFromEntry(entry) == DEVICE_NOTIFY_SERVICE_HANDLE);

                    //
                    // This is a direct call, not a message via. USER
                    //
                    if (pServiceControlCallback) {
                        UnlockNotifyList (&notifyList->Lock);
                        bLocked = FALSE;
                        err = NO_ERROR;
                        try {
                            (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                                      ServiceControl,
                                                      EventId,
                                                      (LPARAM)NULL,
                                                      &err);
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling Service Control Manager!\n"));
                            ASSERT(0);
                            err = NO_ERROR;
                        }
                        LockNotifyList (&notifyList->Lock);
                        bLocked = TRUE;
                        //
                        // convert Win32 error into window message-style return
                        // value.
                        //
                        if (err == NO_ERROR) {
                            result = TRUE;
                        } else {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_EVENT,
                                       "UMPNPMGR: Service %ws responded to HardwareProfileChangeEvent with status=0x%08lx\n",
                                       entry->ClientName,
                                       err));

                            //
                            // This service specifically requested to receive this
                            // notification - it should know how to handle it.
                            //
                            ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                            //
                            // Log the error the service used to veto.
                            //
                            LogWarningEvent(WRN_HWPROFILE_CHANGE_SERVICE_VETO,
                                            1,
                                            entry->ClientName);

                            result = BROADCAST_QUERY_DENY;
                        }

                        if ((Flags & BSF_QUERY) &&
                            (result == BROADCAST_QUERY_DENY)) {

                            ServiceVeto(entry,
                                        VetoType,
                                        VetoName,
                                        VetoNameLength);

                            successful = FALSE;
                            break;
                        }
                    }

                    entry = nextEntry;

                }
            }

            if (!successful) {
                break;
            }

            pass = GetNextPass (pass,Flags & BSF_QUERY);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in service callback in NotifyHardwareProfileChange\n"));
        ASSERT(0);

        if (Flags & BSF_QUERY) {
            UnknownVeto(VetoType, VetoName, VetoNameLength);
            successful = FALSE;
        }
    }

    try {

        if (!successful) {

            ASSERT(Flags & BSF_QUERY);

            //
            // If a service vetoed the query, inform the services and windows,
            // otherwise only the windows know what was coming.
            //
            if (pass == DEVICE_NOTIFY_SERVICE_HANDLE) {

                SendCancelNotification(
                    entry,
                    ServiceControl,
                    EventId,
                    BSF_QUERY,
                    NULL,
                    NULL);
            }

            UnlockNotifyList (&notifyList->Lock);
            bLocked = FALSE;
            BroadcastSystemMessage(Flags & ~BSF_QUERY,
                                   &recipients,
                                   WM_DEVICECHANGE,
                                   (WPARAM)MapQueryEventToCancelEvent(EventId),
                                   (LPARAM)NULL);

            if (fpWinStationBroadcastSystemMessage) {
                try {
                    fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                       TRUE,
                                                       0,
                                                       DEFAULT_BROADCAST_TIME_OUT,
                                                       Flags & ~BSF_QUERY,
                                                       &recipients,
                                                       WM_DEVICECHANGE,
                                                       (WPARAM)MapQueryEventToCancelEvent(EventId),
                                                       (LPARAM)NULL,
                                                       &response);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage\n"));
                    ASSERT(0);
                }
            }
            LockNotifyList (&notifyList->Lock);
            bLocked = TRUE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in service callback in NotifyHardwareProfileChange\n"));
        ASSERT(0);

    }

    if (bLocked) {
        UnlockNotifyList (&notifyList->Lock);
    }

    //
    // if successful, we are not returning veto info.
    //
    if (successful && (VetoNameLength != NULL)) {
        *VetoNameLength = 0;
    }

    return successful;

} // NotifyHardwareProfileChange



BOOL
SendCancelNotification(
    IN     PPNP_NOTIFY_ENTRY    LastEntry,
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     ULONG                Flags,
    IN     PDEV_BROADCAST_HDR   NotifyData  OPTIONAL,
    IN     LPWSTR               DeviceId    OPTIONAL
    )
/*++

Routine Description:

    This routine sends a cancel notification to the entries in the range
    specified. This routine assumes the appropriate list is already locked.

Arguments:

    LastEntry      - Specifies the last list entry that received the original
                     query notification, and was responsible for failing the
                     request.  We will stop sending cancel notification events
                     when we get to this one.

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.
                     Note that BroadcastSystemMessage is not actually used for
                     target device events, but the specified BSF_ flags are used
                     to determine query and cancel event notification ordering.

    NotifyData     - Optionally, supplies a pointer to a PDEV_BROADCAST_Xxx
                     structure that is already filled out with most of the
                     pertinent data for this event.

                     This parameter may be NULL for "global" events that are not
                     associated with any device, such as power and hardware
                     profile change events.

    DeviceId       - Optionally, supplies the device instance id of the target
                     device for this event.

                     This parameter may be NULL for "global" events that are not
                     associated with any device, such as power and hardware
                     profile change events.

Return Value:

    Returns TRUE / FALSE.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD cancelEventId;
    DWORD result, pass, lastPass;
    PPNP_NOTIFY_ENTRY entry, headEntry;
    PPNP_NOTIFY_LIST notifyList;
#ifdef _WIN64
    DEV_BROADCAST_HANDLE32 UNALIGNED *HandleData32 = NULL;
    ULONG  ulHandleDataSize;
#endif // _WIN64
    PVOID  pNotifyData;

#ifdef _WIN64
    if ((ARGUMENT_PRESENT(NotifyData)) &&
        (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
        //
        // If cancelling a DEV_BROADCAST_HANDLE type event, prepare a 32-bit
        // notification structure, which we'll need to send to any WOW64 clients
        // that are registered.
        //
        ulHandleDataSize = ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_size -
            sizeof(DEV_BROADCAST_HANDLE64) +
            sizeof(DEV_BROADCAST_HANDLE32);

        ASSERT(ulHandleDataSize >= sizeof(DEV_BROADCAST_HANDLE32));

        HandleData32 = HeapAlloc(ghPnPHeap, 0, ulHandleDataSize);
        if (HandleData32 == NULL) {
            return FALSE;
        }

        memset(HandleData32, 0, ulHandleDataSize);
        HandleData32->dbch_size = ulHandleDataSize;
        HandleData32->dbch_devicetype = DBT_DEVTYP_HANDLE;
        HandleData32->dbch_nameoffset = ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_nameoffset;

        memcpy(&HandleData32->dbch_eventguid,
               &((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_eventguid,
               sizeof(GUID));

        memcpy(&HandleData32->dbch_data,
               &((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_data,
               (NotifyData->dbch_size - FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)));
    }
#endif // _WIN64

    //
    // Use the appropriate cancel device event id that corresponds to the
    // original query device event id.
    //
    cancelEventId = MapQueryEventToCancelEvent(EventId);

    //
    // Get the corresponding notification list
    //
    notifyList = GetNotifyListForEntry(LastEntry);
    ASSERT(notifyList);
    if (notifyList == NULL) {
        return FALSE;
    }

    //
    // Get the pass we vetoed things on
    //
    lastPass = GetPassFromEntry(LastEntry);

    //
    // Get the opposite end of the list
    //
    headEntry = GetFirstNotifyEntry(notifyList, (Flags ^ BSF_QUERY));

    //
    // Walk the list of registered callers backwards(!) and notify anyone that registered
    // an interest in this device instance. Start with the FirstEntry and stop
    // just before the LastEntry (the LastEntry is the one that vetoed the
    // request in the first place).
    //

    for(pass = lastPass;
        pass != PASS_COMPLETE;
        pass = GetNextPass(pass, (Flags ^ BSF_QUERY))) {

        //
        // If this is the pass the request was vetoed on, then start on the
        // vetoer entry itself. Otherwise begin again at the appropriate end
        // of the list.
        //
        for(entry = (pass == lastPass) ? LastEntry : headEntry;
            entry;
            entry = GetNextNotifyEntry(entry, (Flags ^ BSF_QUERY))) {

            if (!NotifyEntryThisPass(entry, pass)) {
                continue;
            }

            switch(pass) {

                case DEVICE_NOTIFY_SERVICE_HANDLE:

                    if ((!ARGUMENT_PRESENT(DeviceId)) ||
                        (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE,
                                       DeviceId, -1,
                                       entry->u.Target.DeviceId, -1) == CSTR_EQUAL)) {

                        if (pServiceControlCallback) {
                            //
                            // Assume we're sending the native structure.
                            //
                            pNotifyData = NotifyData;

                            if ((ARGUMENT_PRESENT(NotifyData)) &&
                                (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
                                //
                                // If it's a DBT_DEVTYP_HANDLE notification, set
                                // the hdevnotify and file handle fields for the
                                // client we're notifying.
                                //
                                ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_handle =
                                    entry->u.Target.FileHandle;
                                ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_hdevnotify =
                                    (HDEVNOTIFY)((ULONG_PTR)entry->ClientCtxPtr);
#ifdef _WIN64
                                //
                                // If the client is running on WOW64, send it the 32-bit
                                // DEV_BROADCAST_HANDLE structure we created instead.
                                //
                                if (entry->Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                                    HandleData32->dbch_handle =
                                        (ULONG32)PtrToUlong(entry->u.Target.FileHandle);
                                    HandleData32->dbch_hdevnotify =
                                        (ULONG32)PtrToUlong((HDEVNOTIFY)entry->ClientCtxPtr);
                                    pNotifyData = HandleData32;
                                }
#endif // _WIN64
                            }

                            //
                            // Call the services handler routine...
                            //
                            UnlockNotifyList(&notifyList->Lock);
                            result = NO_ERROR;
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                                          ServiceControl,
                                                          cancelEventId,
                                                          (LPARAM)pNotifyData,
                                                          &result);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                result = NO_ERROR;
                                ASSERT(0);
                            }
                            LockNotifyList(&notifyList->Lock);
                        }
                    }
                    break;

                case DEVICE_NOTIFY_WINDOW_HANDLE:

                    //
                    // Notify the windows. Note that events with NULL DeviceId's
                    // (for example hardware profile change events) are not
                    // registerable by windows. Luckily for them, we broadcast
                    // such info anyway.
                    //
                    if ((ARGUMENT_PRESENT(DeviceId)) &&
                        (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE,
                                       DeviceId, -1,
                                       entry->u.Target.DeviceId, -1) == CSTR_EQUAL)) {

                        ASSERT(NotifyData);

                        //
                        // Always send the native DEV_BROADCAST_HANDLE structure to
                        // windows.  If any 64-bit/32-bit conversion needs to be
                        // done for this client, ntuser will do it for us.
                        //
                        pNotifyData = NotifyData;

                        if ((ARGUMENT_PRESENT(NotifyData)) &&
                            (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
                            //
                            // If it's a DBT_DEVTYP_HANDLE notification, set
                            // the hdevnotify and file handle fields for the
                            // client we're notifying.
                            //
                            ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_handle =
                                entry->u.Target.FileHandle;
                            ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_hdevnotify =
                                (HDEVNOTIFY)((ULONG_PTR)entry->ClientCtxPtr);
                        }

                        UnlockNotifyList(&notifyList->Lock);
                        if (entry->SessionId == MAIN_SESSION) {
                            ntStatus = DeviceEventWorker(entry->Handle,
                                                         cancelEventId,
                                                         (LPARAM)pNotifyData,
                                                         TRUE,
                                                         &result    // ignore result
                                                        );

                        } else if (fpWinStationSendWindowMessage) {
                            try {
                                if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                  entry->SessionId,
                                                                  DEFAULT_SEND_TIME_OUT,
                                                                  HandleToUlong(entry->Handle),
                                                                  WM_DEVICECHANGE,
                                                                  (WPARAM)cancelEventId,
                                                                  (LPARAM)pNotifyData,
                                                                  (LONG*)&result)) {
                                    ntStatus = STATUS_SUCCESS;
                                } else {
                                    ntStatus = STATUS_UNSUCCESSFUL;
                                }
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                ASSERT(0);
                                ntStatus = STATUS_SUCCESS;
                            }
                        }
                        LockNotifyList(&notifyList->Lock);

                        if (!NT_SUCCESS(ntStatus)) {
                            if (ntStatus == STATUS_INVALID_HANDLE) {
                                //
                                // window handle no longer exists, cleanup this entry
                                //
                                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN|PNP_UNREG_CANCEL);
                                DeleteNotifyEntry(entry,FALSE);
                            } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_EVENT,
                                           "UMPNPMGR: Window '%ws' timed out on cancel notification event\n",
                                           entry->ClientName));
                                LogWarningEvent(WRN_CANCEL_NOTIFICATION_TIMED_OUT,
                                                1,
                                                entry->ClientName);
                           }
                        }
                    }
                    break;

                case DEVICE_NOTIFY_COMPLETION_HANDLE:
                    //
                    // NOTE: Completion handles not currently implemented.
                    //
                    NOTHING;
                    break;
            }
        }
    }

#ifdef _WIN64
    //
    // Free the 32-bit DEV_BROADCAST_HANDLE structure, if we allocated one.
    //
    if (HandleData32 != NULL) {
        HeapFree(ghPnPHeap, 0, HandleData32);
    }
#endif // _WIN64

    return TRUE;

} // SendCancelNotification



VOID
BroadcastCompatibleDeviceMsg(
    IN DWORD EventId,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData,
    IN PDWORD CurrentMask
    )
/*++

Routine Description:

    Deliver Win9x compatible event notification for the arrival and removal of
    device interfaces to volume and port class devices.

Arguments:

    EventId   - Specifies the DBT style event id.
                Currently, only DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE
                events are supported.


    ClassData - Pointer to a PDEV_BROADCAST_DEVICEINTERFACE structure that is
                already filled out with the pertinent data.
                Currently, only volume and port class device interfaces are
                supported.

                (For volume class devices, the symbolic link
                ClassData->dbcc_name is OPTIONAL - see Notes below.)

Return Value:

    None.

Notes:

    For volume class device broadcasts only, this routine may also be called
    generically, with no symbolic link information provided.  When no symbolic
    link information to a volume device is supplied, the broadcast mask is
    determined only from the current drive letter mappings and the global drive
    letter mask (gAllDrivesMask) prior to this event.  In this case, the global
    drive letter mask is NOT updated here, and the caller should do so after
    both the removal and arrival broadcasts in response to the name change are
    performed.  Currently, this type of call is only made from
    BroadcastVolumeNameChange.

    For volume class interface DBT_DEVICEREMOVECOMPLETE broadcasts, the drive
    letter mask to be broadcast is always determined only by comparing drive
    letters present prior to the remove of the interface with those present at
    this time.  This is done because the former mount points for this device are
    no longer known when the interface removal event is received.  Even so, it
    is still necessary for the symbolic link corresponding to this interface to
    be supplied to distinguish between the actual removal of the interface
    (where the global drive letter mask is updated), the above case, where it is
    not.

--*/
{
    LONG    status = ERROR_SUCCESS;
    LONG    result = 0;
    DWORD   recipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
    DWORD   flags = BSF_IGNORECURRENTTASK | BSF_NOHANG;
    HRESULT hr;


    //
    // Validate the input event data.
    //
    if ((ClassData->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) ||
        (ClassData->dbcc_size < sizeof(DEV_BROADCAST_DEVICEINTERFACE))) {
        return;
    }

    if ((EventId != DBT_DEVICEARRIVAL) &&
        (EventId != DBT_DEVICEREMOVECOMPLETE)) {
        //
        // If the requested Event is not DBT_DEVICEARRIVAL or
        // DBT_DEVICEREMOVECOMPLETE, don't broadcast any messages.
        //
        return;
    }

    if (GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_VOLUME)) {
        //
        // Volume class device interface events.
        //
        PDEV_BROADCAST_VOLUME   pVolume;
        DWORD   broadcastmask = 0;

        if (EventId == DBT_DEVICEARRIVAL) {

            if (ClassData->dbcc_name[0] == L'\0') {
                //
                // If no symbolic link name was supplied, we were asked to
                // broadcast volume device arrivals in response to a volume name
                // change event.  Broadcast any new drive letters found.
                //
                DWORD currentmask;

                //
                // If a current drive letter mask was provided, use it.
                //
                if (ARGUMENT_PRESENT(CurrentMask)) {
                    currentmask = *CurrentMask;
                } else {
                    currentmask = GetAllVolumeMountPoints();
                }

                broadcastmask = (~gAllDrivesMask & currentmask);

            } else {

                //
                // For volume class device interface arrival events, the volume
                // device name is retrieved from the interface, and is compared to
                // the volume names of all drive letter mountpoints in the system to
                // determine the drive letter(s) corresponding to the arriving
                // volume device interface.
                //
                LPWSTR      devicePath, p;
                WCHAR       thisVolumeName[MAX_PATH];
                WCHAR       enumVolumeName[MAX_PATH];
                WCHAR       driveName[4];
                ULONG       length;
                BOOL        bResult;

                //
                // Allocate a temporary buffer for munging the symbolic link, with
                // enough room for a trailing '\' char (should we need to add one),
                // and the terminating NULL char.
                //
                length = lstrlen(ClassData->dbcc_name);
                devicePath = HeapAlloc(ghPnPHeap, 0,
                                       (length+1)*sizeof(WCHAR)+sizeof(UNICODE_NULL));
                if (devicePath == NULL) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto Clean0;
                }

                hr = StringCchCopy(devicePath,
                                   length + 1,
                                   ClassData->dbcc_name);
                ASSERT(SUCCEEDED(hr));

                //
                // Search for the occurence of a refstring (if any) by looking for the
                // next occurance of a '\' char, after the initial "\\?\".
                //
                p = wcschr(&(devicePath[4]), TEXT('\\'));

                if (!p) {
                    //
                    // No refstring is present in the symbolic link; add a trailing
                    // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                    //
                    p = devicePath + length;
                    *p = TEXT('\\');
                }

                //
                // If there is no refstring present, we have added a trailing '\',
                // and placed p at that position.  If a refstring is present, p is
                // at the position of the '\' char that separates the munged device
                // interface name, and the refstring; since we don't need the
                // refstring to reach the parent interface key, we can use the next
                // char for NULL terminating the string in both cases.
                //
                p++;
                *p = UNICODE_NULL;

                //
                // Get the Volume Name for this Mount Point
                //
                thisVolumeName[0] = TEXT('\0');
                bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                           thisVolumeName,
                                                           MAX_PATH);
                HeapFree(ghPnPHeap, 0, devicePath);
                if (!bResult || !thisVolumeName[0]) {
                    status = ERROR_BAD_PATHNAME;
                    goto Clean0;
                }

                //
                // Initialize the drive name string
                //
                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = UNICODE_NULL;

                //
                // Find the drive letter mount point(s) for this volume device by
                // enumerating all possible volume mount points and comparing each
                // mounted volume name with the name of the volume corresponding to
                // this device interface.
                //
                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = UNICODE_NULL;

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, MAX_PATH);

                    if (CompareString(
                            LOCALE_INVARIANT, NORM_IGNORECASE,
                            thisVolumeName, -1,
                            enumVolumeName, -1) == CSTR_EQUAL) {
                        //
                        // Add the corresponding bit for this drive letter to the mask
                        //
                        broadcastmask |= (1 << (driveName[0] - TEXT('A')));
                    }
                }

                //
                // Update the global drive letter mask to include new drive
                // letters only.  Note that we don't set it to the current mask,
                // because that may omit volumes that have been removed, but
                // that we have not yet received removal notification for -
                // which we would not notice as removed when the removal
                // notification finally came.
                //
                gAllDrivesMask |= broadcastmask;
            }

        } else if (EventId == DBT_DEVICEREMOVECOMPLETE) {

            //
            // For volume class device interface removal events, the volume name
            // (and hence, drive mountpoints) corresponding to this device
            // interface has already been removed, and is no longer available.
            // Instead, the bitmask of all drive letter mountpoints for current
            // physical volumes is compared with that prior to the removal of
            // this device.  All missing drive mountpoints are assumed to have
            // been associated with this volume device interface, and are
            // subsequently broadcasted with this interface removal
            // notification.
            //
            DWORD currentmask;

            //
            // Determine all current volume mount points, and broadcast any
            // missing drive letters.
            //

            //
            // If a current drive letter mask was provided, use it.
            //
            if (ARGUMENT_PRESENT(CurrentMask)) {
                currentmask = *CurrentMask;
            } else {
                currentmask = GetAllVolumeMountPoints();
            }

            broadcastmask = (gAllDrivesMask & ~currentmask);

            //
            // Only update the global drive letter in response to the
            // removal of a interface.  For volume name changes, we update
            // outside of this routine.
            //
            if (ClassData->dbcc_name[0] != L'\0') {
                //
                // Update the global drive letter mask to exclude removed drive
                // letters only.  Note that we don't set it to the current mask,
                // because that may include volumes that have been added, but
                // that we have not yet received arrival notification for -
                // which we would not notice as added when the arrival
                // notification finally came.
                //
                gAllDrivesMask &= ~broadcastmask;
            }
        }

        //
        // If there is nothing to broadcast, then we're done.
        //
        if (broadcastmask == 0) {
            status = ERROR_SUCCESS;
            goto Clean0;
        }

        //
        // Fill out the volume broadcast structure.
        //
        pVolume =
            (PDEV_BROADCAST_VOLUME)HeapAlloc(
                ghPnPHeap, 0,
                sizeof(DEV_BROADCAST_VOLUME));

        if (pVolume == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pVolume->dbcv_size = sizeof(DEV_BROADCAST_VOLUME);
        pVolume->dbcv_devicetype =  DBT_DEVTYP_VOLUME;
        pVolume->dbcv_flags = 0;
        pVolume->dbcv_reserved = 0;
        pVolume->dbcv_unitmask = broadcastmask;

        //
        // Broadcast the message to all components
        //
        result = BroadcastSystemMessage(flags,
                                        &recipients,
                                        WM_DEVICECHANGE,
                                        EventId,
                                        (LPARAM)pVolume);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   flags,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)EventId,
                                                   (LPARAM)pVolume,
                                                   &result);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }

        //
        // Free the broadcast structure.
        //
        HeapFree(ghPnPHeap, 0, pVolume);

    } else if ((GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_PARALLEL)) ||
               (GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_COMPORT))) {

        //
        // COM and LPT port class device interface events.
        //
        PDEV_BROADCAST_PORT pPort;
        LPWSTR    p;
        LPWSTR    deviceInterfacePath = NULL;
        LPWSTR    deviceInterfaceName = NULL;
        LPWSTR    deviceInstance = NULL;
        HKEY      hKey;
        WCHAR     szTempString[MAX_PATH];
        ULONG     ulSize;
        size_t    DevicePathLen = 0, DeviceClassesLen = 0;


        //
        // Convert the interface class GUID to a string.
        //
        if (StringFromGuid((LPGUID)&ClassData->dbcc_classguid,
                           szTempString,
                           SIZECHARS(szTempString)) != NO_ERROR) {
            status = ERROR_INVALID_PARAMETER;
            goto Clean0;
        }

        //
        // Build the complete path to the device interface key for this device.
        //
        hr = StringCchLength(ClassData->dbcc_name,
                             STRSAFE_MAX_CCH,
                             &DevicePathLen);
        ASSERT(SUCCEEDED(hr));
        ASSERT(DevicePathLen > 4);

        if (DevicePathLen < 4) {
            status = ERROR_INVALID_PARAMETER;
            goto Clean0;
        }

        hr = StringCchLength(pszRegPathDeviceClasses,
                             MAX_CM_PATH,
                             &DeviceClassesLen);
        ASSERT(SUCCEEDED(hr));
        ASSERT(DeviceClassesLen > 0);

        if ((FAILED(hr)) || (DeviceClassesLen == 0)) {
            status = ERROR_INVALID_PARAMETER;
            goto Clean0;
        }

        ulSize = (ULONG)DeviceClassesLen + 1 +
            MAX_GUID_STRING_LEN + (ULONG)DevicePathLen + 1;

        deviceInterfacePath =
            (LPWSTR)HeapAlloc(
                ghPnPHeap, 0,
                (ulSize * sizeof(WCHAR)));

        if (deviceInterfacePath == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        //
        // Copy the path to the "DeviceClasses" registry key
        //
        hr = StringCchCopy(deviceInterfacePath,
                           ulSize,
                           pszRegPathDeviceClasses);

        if (SUCCEEDED(hr)) {
            hr = StringCchCat(deviceInterfacePath,
                              ulSize,
                              L"\\");
        }

        //
        // Append the interface class GUID to the registry path
        //
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(deviceInterfacePath,
                              ulSize,
                              szTempString);
        }

        if (SUCCEEDED(hr)) {
            hr = StringCchCatEx(deviceInterfacePath,
                                ulSize,
                                L"\\",
                                &deviceInterfaceName,
                                NULL,
                                STRSAFE_NULL_ON_FAILURE);
        }

        //
        // Append the symbolic link name to the registry path.
        //
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(deviceInterfacePath,
                              ulSize,
                              ClassData->dbcc_name);
        }

        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            status = ERROR_BAD_PATHNAME;
            HeapFree(ghPnPHeap, 0, deviceInterfacePath);
            goto Clean0;
        }

        ASSERT(deviceInterfaceName != NULL);

        //
        // Munge the symbolic link name to form the interface key name.
        // (Note: The munging process is optimized here; we only have to munge
        // the leading "\\?\" segment since the rest of the given symbolic link
        // is already munged, with the exception of the refstring seperator char,
        // if any, which we will handle below.)
        //
        deviceInterfaceName[0] = TEXT('#');
        deviceInterfaceName[1] = TEXT('#');
        ASSERT(deviceInterfaceName[2] == TEXT('?'));
        deviceInterfaceName[3] = TEXT('#');

        //
        // Search for the begininng of the refstring (if any), by looking for
        // the next occurance of a '\' char.
        //
        p = wcschr(&(deviceInterfaceName[4]), TEXT('\\'));

        //
        // If there is a RefString component to the device interface path,
        // remove it from the path by replacing the path separator character
        // with a NULL-terminating character.
        //
        if (p != NULL) {
            *p = L'\0';
        }

        //
        // Open the device interface key
        //
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              deviceInterfacePath,
                              0,
                              KEY_READ,
                              &hKey);

        HeapFree(ghPnPHeap, 0, deviceInterfacePath);

        if (status != ERROR_SUCCESS) {
            hKey = NULL;
            goto Clean0;
        }

        //
        // Allocate a string large enough to store the path from the Enum key,
        // to the "\Device Parameters" subkey of this Device Instance's registry
        // key.
        //
        ulSize = MAX_CM_PATH * sizeof(WCHAR);

        deviceInstance =
            (LPWSTR)HeapAlloc(
                ghPnPHeap, 0, ulSize);

        if (deviceInstance == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            RegCloseKey(hKey);
            hKey = NULL;
            goto Clean0;
        }

        //
        // Retrieve the device instance that owns this interface.
        //
        status = RegQueryValueEx(hKey,
                                 pszRegValueDeviceInstance,
                                 0,
                                 NULL,
                                 (LPBYTE)deviceInstance,
                                 &ulSize);
        RegCloseKey(hKey);
        hKey = NULL;

        if (status != ERROR_SUCCESS) {
            HeapFree(ghPnPHeap, 0, deviceInstance);
            goto Clean0;
        }

        //
        // Open the "Device Parameters" key under the HKLM\SYSTEM\CCS\Enum
        // subkey for this DeviceInstance.
        //
        hr = StringCchCat(deviceInstance,
                          MAX_CM_PATH,
                          L"\\");

        if (SUCCEEDED(hr)) {
            hr = StringCchCat(deviceInstance,
                              MAX_CM_PATH,
                              pszRegKeyDeviceParam);
        }

        if (SUCCEEDED(hr)) {
            status = RegOpenKeyEx(ghEnumKey,
                                  deviceInstance,
                                  0,
                                  KEY_READ,
                                  &hKey);
        } else {
            status = ERROR_BAD_PATHNAME;
        }

        HeapFree(ghPnPHeap, 0, deviceInstance);

        if (status != ERROR_SUCCESS) {
            goto Clean0;
        }

        //
        // Query the "PortName" value for the compatible name of this device.
        //
        ulSize = MAX_PATH*sizeof(WCHAR);
        status = RegQueryValueEx(hKey,
                                 pszRegValuePortName,
                                 0,
                                 NULL,
                                 (LPBYTE)szTempString,
                                 &ulSize);
        RegCloseKey(hKey);

        if (status != ERROR_SUCCESS) {
            goto Clean0;
        }

        //
        // Fill out the port broadcast structure.
        //
        pPort =
            (PDEV_BROADCAST_PORT)HeapAlloc(
                ghPnPHeap, 0,
                sizeof(DEV_BROADCAST_PORT) + ulSize);

        if (pPort == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pPort->dbcp_size = sizeof(DEV_BROADCAST_PORT) + ulSize;
        pPort->dbcp_devicetype =  DBT_DEVTYP_PORT;
        pPort->dbcp_reserved = 0;

        hr = StringCbCopy(pPort->dbcp_name,
                          ulSize + sizeof(WCHAR),
                          szTempString);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
            HeapFree(ghPnPHeap, 0, pPort);
            status = ERROR_BAD_PATHNAME;
            goto Clean0;
        }

        //
        // Broadcast the message to all components
        //
        result = BroadcastSystemMessage(flags,
                                        &recipients,
                                        WM_DEVICECHANGE,
                                        EventId,
                                        (LPARAM)pPort);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   flags,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)EventId,
                                                   (LPARAM)pPort,
                                                   &result);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }

        //
        // Free the broadcast structure.
        //
        HeapFree(ghPnPHeap, 0, pPort);

    }

 Clean0:

    return;

} // BroadcastCompatibleDeviceMsg



VOID
BroadcastVolumeNameChange(
    VOID
    )
/*++

Routine Description:

    Perform Win9x compatible volume removal and arrival messages, to be called
    in reponse to a volume name change event.

Arguments:

    None.

Return Value:

    None.

Notes:

    The drive mask to be broadcast will be determined by comparing the current
    drive letter mask with that prior to the event.  The global drive letter
    mask is also updated here, after all removal and arrival notifications have
    been sent.

--*/
{
    DEV_BROADCAST_DEVICEINTERFACE volumeNotify;
    DWORD  currentmask = 0;

    //
    // Fill out a DEV_BROADCAST_DEVICEINTERFACE structure.
    //
    ZeroMemory(&volumeNotify, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
    volumeNotify.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    volumeNotify.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    volumeNotify.dbcc_reserved   = 0;
    memcpy(&volumeNotify.dbcc_classguid, &GUID_DEVINTERFACE_VOLUME, sizeof(GUID));

    //
    // A null symbolic link name for dbcc_name designates that
    // BroadcastCompatibleDeviceMsg is to determine the drive mask to
    // broadcast by checking differences between the last broadcast drive
    // mask (gAllDrivesMask), and the current drive mask.
    //
    // When broadcasting in response to a volume name change, we must wait until
    // both removal and arrival messages have been sent before we can update the
    // global drive letter mask.  A null symbolic link name specifies that
    // BroadcastCompatibleDeviceMsg should not update the global mask; this will
    // be done here, after all broadcasts are complete.
    //
    volumeNotify.dbcc_name[0]    = L'\0';

    //
    // Retrieve the current drive letter mask.
    //
    currentmask = GetAllVolumeMountPoints();

    //
    // Broadcast volume removal notification for any drive letter moint points
    // no longer in use, followed by volume arrival notification for new
    //
    BroadcastCompatibleDeviceMsg(DBT_DEVICEREMOVECOMPLETE, &volumeNotify, &currentmask);
    BroadcastCompatibleDeviceMsg(DBT_DEVICEARRIVAL, &volumeNotify, &currentmask);

    //
    // Now that both removal and arrival messages have been sent, update the
    // global drive letter mask to reflect what we just broadcast.
    //
    gAllDrivesMask = currentmask;

    return;

} // BroadcastVolumeNameChange



DWORD
GetAllVolumeMountPoints(
    VOID
    )
/*++

Routine Description:

    Queries all drive letter mountpoints ('A'-'Z') and returns a bitmask
    representing all such mount points currently in use by physical volume
    devices.

Arguments:

    None.

Return Value:

    Returns a bit mask representing drive letter mount points ('A'-'Z') in use
    by physical volume devices.

Note:

    The returned bit mask includes only mount points for physical volume class
    devices.  Network mounted drives are not included.


--*/
{
    WCHAR    driveName[4];
    WCHAR    volumeName[MAX_PATH];
    DWORD    driveLetterMask=0;

    //
    // Initialize drive name and mask
    //
    driveName[1] = TEXT(':');
    driveName[2] = TEXT('\\');
    driveName[3] = UNICODE_NULL;

    //
    // Compare the name of this volume with those of all mounted volumes in the system
    //
    for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {
        volumeName[0] = UNICODE_NULL;

        if (!GetVolumeNameForVolumeMountPoint(driveName,
                                              volumeName,
                                              MAX_PATH)) {
            continue;
        }

        if (volumeName[0] != UNICODE_NULL) {
            //
            // Add the corresponding bit for this drive letter to the mask
            //
            driveLetterMask |= (1 << (driveName[0] - TEXT('A')));
        }
    }

    return driveLetterMask;

} // GetAllVolumeMountPoints



ULONG
NotifyPower(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                EventData,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies services of system-wide power events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the PBT style event id for the power event.
                     (see sdk\inc\pbt.h for defined power events)

    EventData      - Specifies additional data for the event.

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

Notes:

    This routine currently only notifies services of power events.  Notification
    to windows is handled directly by USER.

    Power events are placed in the plug and play event queue via a private call
    from USER, for the explicit purpose of notifying services of system-wide
    power events, done here.

--*/
{
    NTSTATUS status=STATUS_SUCCESS;
    PPNP_NOTIFY_ENTRY entry, nextEntry;
    PPNP_NOTIFY_LIST  notifyList = NULL;
    BOOL  bLocked = FALSE;
    DWORD err;
    LONG result;

    //
    // NOTE: Services are not currently sent EventData for power events.  The
    // SCM currently ASSERTs that this will always be zero.
    //
    // The SDK states that WM_POWERBROADCAST "RESUME" type messages may contain
    // the PBTF_APMRESUMEFROMFAILURE flag in the LPARAM field, and that "QUERY"
    // type messages may contain a single bit in the LPARAM field specifying
    // whether user interaction is allowed.
    //
    // Although these don't currently seem to be used much (even for window
    // messages, as stated), shouldn't EventData also be valid for service power
    // event notification?
    //
    UNREFERENCED_PARAMETER(EventData);


    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    notifyList = &ServiceList[CINDEX_POWEREVENT];
    LockNotifyList (&notifyList->Lock);
    bLocked = TRUE;

    //
    //Services only. User sends out messages to apps
    //
    try {
        //
        //Notify the services
        //
        entry = GetFirstNotifyEntry(notifyList,0);

        if (!entry) {
            //
            // can't veto if no one registered.
            //
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }
        }

        while (entry) {

            nextEntry = GetNextNotifyEntry(entry,0);

            if (entry->Unregistered) {
                entry = nextEntry;
                continue;
            }

            //
            // This is a direct call, not a message via. USER
            //
            if (pServiceControlCallback) {
                UnlockNotifyList (&notifyList->Lock);
                bLocked = FALSE;
                err = NO_ERROR;
                try {
                    (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                              ServiceControl,
                                              EventId,
                                              (LPARAM)NULL, // Currently, no EventData allowed for services
                                              &err);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Exception calling Service Control Manager!\n"));
                    err = NO_ERROR;
                    ASSERT(0);
                }
                LockNotifyList (&notifyList->Lock);
                bLocked = TRUE;

                //
                // convert Win32 error into window message-style return
                // value.
                //
                if (err == NO_ERROR) {
                    result = TRUE;
                } else {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT,
                               "UMPNPMGR: Service %ws responded to PowerEvent, with status=0x%08lx\n",
                               entry->ClientName,
                               err));

                    //
                    // This service specifically requested to receive this
                    // notification - it should know how to handle it.
                    //
                    ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                    //
                    // Log the error the service used to veto.
                    //
                    LogWarningEvent(WRN_POWER_EVENT_SERVICE_VETO,
                                    1,
                                    entry->ClientName);

                    result = BROADCAST_QUERY_DENY;
                }

                //
                // Check if one of the QUERY messages was denied
                //
                if ((Flags & BSF_QUERY) &&
                    (result == BROADCAST_QUERY_DENY)) {

                    ServiceVeto(entry, VetoType, VetoName, VetoNameLength );

                    //
                    // This service vetoed the query, tell everyone else
                    // it was cancelled.
                    //
                    SendCancelNotification(entry,
                                           ServiceControl,
                                           EventId,
                                           0,
                                           NULL,
                                           NULL);
                    status = STATUS_UNSUCCESSFUL;
                    break;

                }
            }

            entry = nextEntry;
        }
    } except (EXCEPTION_EXECUTE_HANDLER){
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception delivering Power Notification to Service Control Manager\n"));
        ASSERT(0);
    }

    if (bLocked) {
        UnlockNotifyList (&notifyList->Lock);
    }

    //
    // if successful, we are not returning veto info.
    //
    if (NT_SUCCESS(status) && (VetoNameLength != NULL)) {
        *VetoNameLength = 0;
    }

    return (NT_SUCCESS(status));

} // NotifyPower



CONFIGRET
RegisterServiceNotification(
    IN  SERVICE_STATUS_HANDLE hService,
    IN  LPWSTR pszService,
    IN  DWORD scmControls,
    IN  BOOL bServiceStopped
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.
    It allows the SCM to register or unregister services for events sent by this
    service.

Arguments:

    hService        - Specifies the service handle.

    pszService      - Specifies the name of the service.

    scmControls     - Specifies the messages that SCM wants to listen to.

    bServiceStopped - Specifies whether the service is stopped.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    This routine is called anytime a service changes the state of the
    SERVICE_ACCEPT_POWEREVENT or SERVICE_ACCEPT_HARDWAREPROFILECHANGE flags in
    its list of accepted controls.

    This routine is also called by the SCM whenever any service has stopped, to
    make sure that the specified service status handle is no longer registered
    to receive SERVICE_CONTROL_DEVICEEVENT events.

    Although it is the responsibility of the service to unregister for any
    device event notifications that it has registered to receive before it is
    stopped, its service status handle may be reused by the service controller,
    so we must clean up any remaining device event registrations so that other
    services will not receive them instead.

    This is necessary for shared process services, since RPC rundown on the
    notification handle will not occur until the service's process exits, which
    may be long after the service has stopped.

--*/
{
    ULONG cBits, i=0;
    CONFIGRET Status = CR_SUCCESS;
    PPNP_NOTIFY_ENTRY entry = NULL, curentry, nextentry;
    PLOCKINFO LockHeld = NULL;

    //
    // Filter out the accepted controls we care about.
    //
    cBits = MapSCMControlsToControlBit(scmControls);

    //
    // If we were called because the service was stopped, make sure that we
    // always unregister for all notifications.
    //
    if (bServiceStopped) {
        ASSERT(cBits == 0);
        cBits = 0;
    }

    try {
        EnterCriticalSection(&RegistrationCS);

        //
        // Add or remove an entry in the array for each control bits.
        //
        for (i = 0;i< SERVICE_NUM_CONTROLS;i++) {

            if (LockNotifyList(&ServiceList[i].Lock)) {
                LockHeld = &ServiceList[i].Lock;
            } else {
                //
                // Couldn't acquire the lock.  Just move on to the next control
                // bit.
                //
                continue;
            }

            //
            // Check to see if an entry for this service handle already exists
            // in our list.
            //
            for (curentry = GetFirstNotifyEntry(&ServiceList[i],0);
                 curentry;
                 curentry = GetNextNotifyEntry(curentry,0)) {
                if (curentry->Handle == (HANDLE)hService) {
                    break;
                }
            }

            //
            // At this point, if curentry is non-NULL, then the service
            // handle is already in our list, otherwise, it is not.
            //
            if (cBits & (1 << i)) {
                //
                // If entry isn't already in the list, then add it.
                //
                if (!curentry) {

                    entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
                    if (NULL == entry) {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        Status = CR_OUT_OF_MEMORY;
                        UnlockNotifyList(LockHeld);
                        LockHeld = NULL;
                        goto Clean0;

                    }

                    RtlZeroMemory (entry,sizeof (PNP_NOTIFY_ENTRY));

                    entry->Handle = (HANDLE)hService;
                    entry->Signature = SERVICE_ENTRY_SIGNATURE;
                    entry->Freed = 0;
                    entry->Flags = DEVICE_NOTIFY_SERVICE_HANDLE;
                    entry->ClientName = NULL;

                    if (ARGUMENT_PRESENT(pszService)) {

                        HRESULT hr;
                        size_t  ServiceNameLen = 0;

                        hr = StringCchLength(pszService,
                                             MAX_SERVICE_NAME_LEN,
                                             &ServiceNameLen);
                        if (FAILED(hr)) {
                            ServiceNameLen = MAX_SERVICE_NAME_LEN - 1;
                        }

                        entry->ClientName =
                            (LPWSTR)HeapAlloc(
                                ghPnPHeap, 0,
                                (ServiceNameLen+1)*sizeof(WCHAR));

                        if (entry->ClientName == NULL) {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            Status = CR_OUT_OF_MEMORY;
                            HeapFree(ghPnPHeap,0,entry);
                            UnlockNotifyList(LockHeld);
                            LockHeld = NULL;
                            goto Clean0;
                        }

                        //
                        // Copy to the allocated buffer, truncating if necessary.
                        //
                        hr = StringCchCopy(entry->ClientName,
                                           ServiceNameLen + 1,
                                           pszService);
                        ASSERT(SUCCEEDED(hr));
                    }

                    entry->u.Service.scmControls = scmControls;
                    MarkEntryWithList(entry,i);
                    AddNotifyEntry(&ServiceList[i], entry);

                    //
                    // Now reset entry pointer to NULL so we won't try to free
                    // it if we encounter an exception
                    //
                    entry = NULL;
                }
            } else {
                //
                // If entry is in the list, then remove it.
                //
                if (curentry) {
                    curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_SERVICE);
                    DeleteNotifyEntry(curentry,TRUE);
                }
            }

            UnlockNotifyList(LockHeld);
            LockHeld = NULL;
        }

        //
        // If the service is being stopped, unregister all outstanding device
        // event registrations.
        //
        if (bServiceStopped) {

            //
            // If a notification is currently in progress, check to see if there
            // are any entries for this service in the deferred RegisterList or
            // UnregisterList.
            //
            if (gNotificationInProg  != 0) {

                if (RegisterList) {
                    PPNP_DEFERRED_LIST currReg, prevReg;

                    currReg = RegisterList;
                    prevReg = NULL;

                    while (currReg) {

                        ASSERT(currReg->Entry->Unregistered);

                        if (currReg->Entry->Handle == (HANDLE)hService) {
                            if (prevReg) {
                                prevReg->Next = currReg->Next;
                            } else {
                                RegisterList = currReg->Next;
                            }
                            HeapFree(ghPnPHeap, 0, currReg);
                            if (prevReg) {
                                currReg = prevReg->Next;
                            } else {
                                currReg = RegisterList;
                            }
                        } else {
                            prevReg = currReg;
                            currReg = currReg->Next;
                        }
                    }
                }

                if (UnregisterList) {
                    PPNP_DEFERRED_LIST currUnreg, prevUnreg;

                    currUnreg = UnregisterList;
                    prevUnreg = NULL;

                    while (currUnreg) {

                        ASSERT(currUnreg->Entry->Unregistered);

                        if (currUnreg->Entry->Handle == (HANDLE)hService) {
                            if (prevUnreg) {
                                prevUnreg->Next = currUnreg->Next;
                            } else {
                                UnregisterList = currUnreg->Next;
                            }
                            HeapFree(ghPnPHeap, 0, currUnreg);
                            if (prevUnreg) {
                                currUnreg = prevUnreg->Next;
                            } else {
                                currUnreg = UnregisterList;
                            }
                        } else {
                            prevUnreg = currUnreg;
                            currUnreg = currUnreg->Next;
                        }
                    }
                }
            }

            //
            // Check for any target device notification entries for this
            // service.
            //
            for (i = 0; i < TARGET_HASH_BUCKETS; i++) {

                if (LockNotifyList(&TargetList[i].Lock)) {
                    LockHeld = &TargetList[i].Lock;
                } else {
                    //
                    // Couldn't acquire the lock.  Just move on to the next list.
                    //
                    continue;
                }

                //
                // Check to see if an entry for this service handle exists in
                // this list.
                //
                curentry = GetFirstNotifyEntry(&TargetList[i],0);
                while(curentry) {

                    nextentry = GetNextNotifyEntry(curentry,0);

                    if (curentry->Unregistered) {
                        curentry = nextentry;
                        continue;
                    }

                    if (curentry->Handle == (HANDLE)hService) {
                        //
                        // Remove the entry from the notification list.
                        //
                        curentry->Unregistered = TRUE;
                        curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_TARGET);
                        DeleteNotifyEntry(curentry,FALSE);

                        //
                        // Only log a warning if the PlugPlay service has not
                        // already stopped.  Otherwise, the client may actually
                        // have tried to unregister after we were shut down.
                        //
                        if (CurrentServiceState != SERVICE_STOPPED &&
                            CurrentServiceState != SERVICE_STOP_PENDING) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_WARNINGS | DBGF_EVENT,
                                       "UMPNPMGR: Service '%ws' "
                                       "may have stopped without unregistering "
                                       "for TargetDeviceChange notification.\n",
                                       curentry->ClientName));
                            LogWarningEvent(WRN_STOPPED_SERVICE_REGISTERED,
                                            1,
                                            curentry->ClientName);
                        }
                    }

                    curentry = nextentry;
                }
                UnlockNotifyList(LockHeld);
                LockHeld = NULL;
            }

            //
            // Check for any device interface notification entries for this
            // service.
            //
            for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {

                if (LockNotifyList(&ClassList[i].Lock)) {
                    LockHeld = &ClassList[i].Lock;
                } else {
                    //
                    // Couldn't acquire the lock.  Just move on to the next list.
                    //
                    continue;
                }

                //
                // Check to see if an entry for this service handle exists in
                // this list.
                //
                curentry = GetFirstNotifyEntry(&ClassList[i],0);
                while(curentry) {

                    nextentry = GetNextNotifyEntry(curentry,0);

                    if (curentry->Unregistered) {
                        curentry = nextentry;
                        continue;
                    }

                    if (curentry->Handle == (HANDLE)hService) {
                        //
                        // Remove the entry from the notification list.
                        //
                        curentry->Unregistered = TRUE;
                        curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_CLASS);
                        DeleteNotifyEntry(curentry,FALSE);

                        //
                        // Only log a warning if the PlugPlay service has not
                        // already stopped.  Otherwise, the client may actually
                        // have tried to unregister after we were shut down.
                        //
                        if (CurrentServiceState != SERVICE_STOPPED &&
                            CurrentServiceState != SERVICE_STOP_PENDING) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_WARNINGS | DBGF_EVENT,
                                       "UMPNPMGR: Service '%ws' "
                                       "may have stopped without unregistering "
                                       "for DeviceInterfaceChange notification.\n",
                                       curentry->ClientName));
                            LogWarningEvent(WRN_STOPPED_SERVICE_REGISTERED,
                                            1,
                                            curentry->ClientName);
                        }
                    }

                    curentry = nextentry;
                }
                UnlockNotifyList(LockHeld);
                LockHeld = NULL;
            }
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except (EXCEPTION_EXECUTE_HANDLER){
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in RegisterServiceNotification!!\n"));
        ASSERT(0);
        SetLastError(ERROR_EXCEPTION_IN_SERVICE);
        Status = CR_FAILURE;

        if (LockHeld) {
            UnlockNotifyList(LockHeld);
        }
        LeaveCriticalSection(&RegistrationCS);

        if (entry) {
            if (entry->ClientName) {
                HeapFree(ghPnPHeap, 0, entry->ClientName);
            }
            HeapFree(ghPnPHeap, 0, entry);
        }
    }

    return Status;

} // RegisterServiceNotification



CONFIGRET
RegisterScmCallback(
    IN  PSCMCALLBACK_ROUTINE pScCallback,
    IN  PSCMAUTHENTICATION_CALLBACK pScAuthCallback
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.  It
    allows the SCM to dynamically provide this service with callback routines.

Arguments:

    pScCallback     - Specifies the entrypoint for the routine that should be used
                      to have the service controller send special controls to a
                      service (which ControlService would block), on behalf of
                      the user-mode plug and play manager.

    pScAuthCallback - Specifies the entrypoint for the routine that should be
                      used to retrieve the service status for a service.

Return Value:

    Returns CR_SUCCESS.

--*/
{
    ASSERT(pScCallback);
    ASSERT(pScAuthCallback);

    pServiceControlCallback = pScCallback;
    pSCMAuthenticate = pScAuthCallback;

    return CR_SUCCESS;

} // RegisterScmCallback



CONFIGRET
UnRegisterScmCallback(
    VOID
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.  It
    allows the SCM to unregister the callback routines previously registered by
    RegisterScmCallback.

Arguments:

    None.

Return Value:

    Returns CR_SUCCESS.

--*/
{
    pServiceControlCallback = NULL;
    pSCMAuthenticate = NULL;

    return CR_SUCCESS;

} // UnRegisterScmCallback



ULONG
MapSCMControlsToControlBit(
    IN ULONG scmControls
    )
/*++

Routine Description:

    Returns a bitmask of control bits specifying ServiceList lists to which a
    service should be added or removed from, based on the controls currently
    accepted by the service.

Arguments:

    scmControls - Specifies the service controls currently accepted by a
                  service.

Return Value:

    Returns a bitmask of control bits corresponding to entries in the
    ServiceList array of lists to which a service should be added or removed
    from, based on the controls currently accepted by the service.

Notes:

    Services are added or removed from a ServiceList notification list by adding
    or removing the corresponding SERVICE_ACCEPT_* control from its list of
    accepted controls when calling SetServiceStatus().  The service control
    manager calls RegisterServiceNotification() as appropriate to register or
    unregister the service to receive that control.  Currently, only
    SERVICE_ACCEPT_HARDWAREPROFILECHANGE and SERVICE_ACCEPT_POWEREVENT are
    supported.

    A service registers to receive the SERVICE_CONTROL_DEVICEEVENT control by
    calling RegisterDeviceNotification, and is stored in the appropriate
    TargetList or ClassList entry.

--*/
{
    ULONG retBits=0;

    if (scmControls & SERVICE_ACCEPT_HARDWAREPROFILECHANGE) {
        retBits |= CBIT_HWPROFILE;
    }

    if (scmControls & SERVICE_ACCEPT_POWEREVENT) {
        retBits |= CBIT_POWEREVENT;
    }

    return retBits;

} // MapSCMControlsToControlBit



DWORD
GetFirstPass(
    IN BOOL bQuery
    )
/*++

Routine Description:

  This routine retrieves the first class of handles to notify. The subsequent
  class of handles to notify should be retrieved by calling GetNextPass(...);

Arguments:

   bQuery - If TRUE, starts with window handles, otherwise service handles.

Return Value:

   Returns the first class of handles to notify.

Notes:

   See GetNextPass() for the notification pass progression.

--*/
{
    //
    // Since services are generally less likely to veto device event queries, we
    // first make sure that all windows succeed the query before notifying any
    // services.  For non-query events, services should be the first to know.
    //
    return (bQuery) ? DEVICE_NOTIFY_WINDOW_HANDLE : DEVICE_NOTIFY_SERVICE_HANDLE;
}



DWORD
GetNextPass(
    IN  DWORD   curPass,
    IN  BOOL    bQuery
    )
/*++

Routine Description:

  This routine retrieves the next class of handles to notify. If there is no
  subsequent class of handles to notify, PASS_COMPLETE is returned.

Arguments:

   curPass      Current pass.

   bQuery       If TRUE, proceed from window handles to completion handles to
                service handles. Otherwise process in reverse.

Return Value:

   Returns the subsequent pass.

Notes:

   For query events, the notification pass progression is:

      DEVICE_NOTIFY_WINDOW_HANDLE,
      DEVICE_NOTIFY_COMPLETION_HANDLE,
      DEVICE_NOTIFY_SERVICE_HANDLE,
      PASS_COMPLETE

   For non-query events, the notification pass progression is:

      DEVICE_NOTIFY_SERVICE_HANDLE,
      DEVICE_NOTIFY_COMPLETION_HANDLE,
      DEVICE_NOTIFY_WINDOW_HANDLE,
      PASS_COMPLETE

--*/
{
    if (bQuery) {
        if (curPass == DEVICE_NOTIFY_WINDOW_HANDLE ) {
            curPass = DEVICE_NOTIFY_COMPLETION_HANDLE;
        } else if (curPass == DEVICE_NOTIFY_COMPLETION_HANDLE) {
            curPass = DEVICE_NOTIFY_SERVICE_HANDLE;
        } else {
            curPass = PASS_COMPLETE;
        }
    } else {
        if (curPass == DEVICE_NOTIFY_SERVICE_HANDLE ) {
            curPass = DEVICE_NOTIFY_COMPLETION_HANDLE;
        } else if (curPass == DEVICE_NOTIFY_COMPLETION_HANDLE) {
            curPass = DEVICE_NOTIFY_WINDOW_HANDLE;
        } else {
            curPass = PASS_COMPLETE;
        }
    }

    return curPass;
}



BOOL
NotifyEntryThisPass(
    IN     PPNP_NOTIFY_ENTRY    Entry,
    IN     DWORD                Pass
    )
{
    ASSERT(Pass != PASS_COMPLETE);
    return ((!(Entry->Unregistered)) && (GetPassFromEntry(Entry) == Pass));
}

DWORD
GetPassFromEntry(
    IN     PPNP_NOTIFY_ENTRY    Entry
    )
{
    return (Entry->Flags & DEVICE_NOTIFY_HANDLE_MASK);
}



BOOL
EventIdFromEventGuid(
    IN CONST GUID *EventGuid,
    OUT LPDWORD   EventId,
    OUT LPDWORD   Flags,
    OUT LPDWORD   ServiceControl
    )

/*++

Routine Description:

  This thread routine converts an event guid into the corresponding event id
  that user-mode code expects (used in BroadcastSystemMessage).

Arguments:

   EventGuid    Specifies an event guid.

   EventId      Returns the id form (from dbt.h) of the guid in EventGuid.

   Flags        Returns the flags that should be used when broadcasting this
                event.
                NOTE: device ARRIVAL and event CANCEL are considered "Queries"
                since the bottom level drivers need to be told first.

Return Value:

   Currently returns TRUE/FALSE.


Notes:

   Most users of this function call it mainly to retrieve the EventId. Those
   functions typically examine the returned flags only to check the BSF_QUERY
   flag (ie, they don't call BroadcastSystemMessage). Depending on whether
   BSF_QUERY is set, the notification lists will be walked forwards or
   backwards.

   We should really return something generic such as:
   [MSG_POST, MSG_QUERY, MSG_SEND] | [MSG_FORWARDS, MSG_BACKWARDS]
   Then we should implement a BsmFlagsFromMsgFlags function.

--*/

{
    //
    // BSF_IGNORECURRENTTASK  - Sent messages do not appear in the sending
    //                          processes message queue.
    //
    // BSF_QUERY              - If any recipient vetoes the message by returning
    //                          the appropriate value, the broadcast is failed
    //                          (ie, BroadcastSystemMessage returns 0).
    //
    // BSF_NOHANG             - Non-posted messages are automatically failed if
    //                          the window has not processed any available
    //                          messages within a system defined time (as of
    //                          04/20/1999 this is 5 seconds).
    //                          (SendMessageTimeout: SMTO_ABORTIFHUNG)
    //
    // BSF_FORCEIFHUNG        - Failures due to timeouts or hangs are instead
    //                          treated as successes.
    //
    // BSF_NOTIMEOUTIFNOTHUNG - If a window has not responded to the passed in
    //                          notification, but is actively processing
    //                          subsequent messages, then it is assumed to be
    //                          interacting with the user, in which case the
    //                          timeout is on hold.
    //                          (SendMessageTimeout: SMTO_NOTIMEOUTIFNOTHUNG)
    //
    // BSF_POSTMESSAGE        - Message is posted, results ignored. Note that
    //                          a notification with private data in the lParam
    //                          *cannot* be posted - the OS does not make a
    //                          private copy, but rather treats the broadcast
    //                          as if it were a SendMessage if you try.
    //
    // BSF_ALLOWSFW           - Windows that receive the broadcast are allowed
    //                          to become foreground windows.
    //
    // Also, DBT messages >= 0x8000 have lParams pointing to blocks of data that
    // need to be marshalled around. As user doesn't support "snapshotting" the
    // data for posts, we can't pass in BSF_POSTMESSAGE.
    //

    *Flags = BSF_IGNORECURRENTTASK;

    //
    // Standard (well-known) event guids.
    //
    if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE)) {

        *Flags |= BSF_QUERY | BSF_ALLOWSFW |
                  BSF_FORCEIFHUNG | BSF_NOHANG;
        *EventId = DBT_QUERYCHANGECONFIG;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED)) {

        *Flags |= BSF_POSTMESSAGE;
        *EventId = DBT_CONFIGCHANGECANCELED;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_COMPLETE)) {

        *Flags |= BSF_POSTMESSAGE;
        *EventId = DBT_CONFIGCHANGED;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INTERFACE_ARRIVAL)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INTERFACE_REMOVAL)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVECOMPLETE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        *Flags |= BSF_QUERY | BSF_ALLOWSFW |
                  BSF_FORCEIFHUNG | BSF_NOHANG;
        *EventId = DBT_DEVICEQUERYREMOVE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEQUERYREMOVEFAILED;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVE_PENDING)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVEPENDING;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVECOMPLETE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_ARRIVAL)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_ENUMERATED)) {

        *Flags = 0;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = 0;

    //
    // Private event guids (kernel-mode pnp to user-mode pnp communication).
    // Setting EventId to zero causes ProcessDeviceEvent to swallow these
    // TargetDeviceChangeEvent events.
    //

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SAFE_REMOVAL) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_EJECT_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVAL_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_WARM_EJECT_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_STANDBY_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_HIBERNATE_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_KERNEL_INITIATED_EJECT) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SURPRISE_REMOVAL) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DRIVER_BLOCKED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INVALID_ID)) {

        *Flags = 0;
        *EventId = 0;
        *ServiceControl = 0;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_PNP_CUSTOM_NOTIFICATION)) {

        //
        // Custom events cannot be failed (ie they aren't queries)
        //
        *EventId = DBT_CUSTOMEVENT;
        *Flags |= BSF_NOHANG;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_PNP_POWER_NOTIFICATION)) {

        //
        // These are treated as custom too.
        //
        *EventId = DBT_CUSTOMEVENT;
        *Flags |= BSF_NOHANG;
        *ServiceControl = SERVICE_CONTROL_POWEREVENT;

    } else {

        //
        // Anything that makes it here is a bug.
        //
        ASSERT(GuidEqual(EventGuid, (LPGUID)&GUID_PNP_CUSTOM_NOTIFICATION));
        *EventId = 0;
        *Flags = 0;
        *ServiceControl = 0;
    }

    return TRUE;

} // EventIdFromEventGuid



ULONG
SendHotplugNotification(
    IN CONST GUID           *EventGuid,
    IN       PPNP_VETO_TYPE  VetoType      OPTIONAL,
    IN       LPWSTR          MultiSzList,
    IN OUT   PULONG          SessionId,
    IN       ULONG           Flags
    )
/*++

Routine Description:

    This routine kicks off a hotplug.dll process (if someone is logged in).
    We use a named pipe to comunicate with the user mode process and have it
    display the requested UI.

Arguments:

    EventGuid   - Specifies an event GUID.

    VetoType    - For events requiring a vetoer, supplies the address of a
                  variable containing the type of the component responsible for
                  vetoing the request.

    MultiSzList - Supplies the MultiSz list to be sent to hotplu.dll.  This is
                  usually a device ID, possibly followed by a list of vetoers
                  (which may or may not be device ID's).

    SessionId -   Supplies the address of a variable containing the SessionId on
                  which the hotplug dialog is to be displayed.  If successful,
                  the SessionId will contain the id of the session in which the
                  device install client process was launched.  Otherwise, will
                  contain an invalid session id, INVALID_SESSION (0xFFFFFFFF).

    Flags       - Specifies flags describing the behavior of the hotplug dialog.
                  The following flags are currently defined:

        HOTPLUG_DISPLAY_ON_CONSOLE - if specified, the value in the SessionId
           variable will be ignored, and the hotplug dialog will always be
           displayed on the current active console session.

Return Value:

    Currently returns TRUE/FALSE.

Return Value:

    If the process was successfully created, the return value is TRUE.  This
    routine doesn't wait until the process terminates.

    If we couldn't create the process (e.g., because no user was logged in),
    the return value is FALSE.

--*/
{
    BOOL bStatus;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR szCmdLine[MAX_PATH];
    WCHAR szHotPlugDllEntryPoint[80];
    HANDLE hHotPlugPipe = NULL;
    HANDLE hHotPlugEvent = NULL;
    HANDLE hFinishEvents[2] = { NULL, NULL };
    HANDLE hTemp, hUserToken = NULL;
    RPC_STATUS rpcStatus = RPC_S_OK;
    GUID  newGuid;
    WCHAR szGuidString[MAX_GUID_STRING_LEN];
    WCHAR szHotPlugPipeName[MAX_PATH];
    WCHAR szHotPlugEventName[MAX_PATH];
    ULONG ulHotPlugEventNameSize;
    ULONG ulMultiSzListSize;
    ULONG ulSize, ulSessionId = INVALID_SESSION;
    WIN32_FIND_DATA findData;
    LPWSTR pszName = NULL;
    PVOID lpEnvironment = NULL;
    OVERLAPPED overlapped;
    DWORD dwError, dwWait, dwBytes;
    HRESULT hr;
    size_t Len = 0;


    //
    // Check if we should skip client side UI.
    //
    if (gbSuppressUI) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "UMPNPMGR: SendHotplugNotification: "
                   "UI has been suppressed, exiting.\n"));
        LogWarningEvent(WRN_HOTPLUG_UI_SUPPRESSED, 1, MultiSzList);
        return FALSE;
    }

    //
    // Initialize process, startup and overlapped structures, since we
    // depend on them being NULL during cleanup here on out.
    //
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    ZeroMemory(&overlapped,  sizeof(overlapped));

    //
    // Assume failure
    //
    bStatus = FALSE;

    try {
        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & HOTPLUG_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        //
        // Before doing anything, check that hotplug.dll is actually present on
        // the system.
        //
        szCmdLine[0] = L'\0';
        ulSize = GetSystemDirectory(szCmdLine, MAX_PATH);
        if ((ulSize == 0) || ((ulSize + 2 + ARRAY_SIZE(HOTPLUG_DLL)) > MAX_PATH)) {
            return FALSE;
        }

        hr = StringCchCat(szCmdLine,
                          SIZECHARS(szCmdLine),
                          L"\\");

        if (SUCCEEDED(hr)) {
            hr = StringCchCat(szCmdLine,
                              SIZECHARS(szCmdLine),
                              HOTPLUG_DLL);
        }

        if (FAILED(hr)) {
            return FALSE;
        }

        hTemp = FindFirstFile(szCmdLine, &findData);
        if(hTemp != INVALID_HANDLE_VALUE) {
            FindClose(hTemp);
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_WARNINGS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: %ws not found, error = %d, exiting\n",
                       szCmdLine,
                       GetLastError()));
            LogWarningEvent(WRN_HOTPLUG_NOT_PRESENT, 1, szCmdLine);
            return FALSE;
        }

        //
        // Get the user access token for the active console session user.
        //
        if (!GetSessionUserToken(ulSessionId, &hUserToken)) {
            return FALSE;
        }

        //
        // Create a named pipe and event for communication and synchronization
        // with HotPlug.  The event and named pipe must be global so that
        // UMPNPMGR can interact with a HotPlug client in a different session,
        // but it must still be unique for that session.  Add a generated GUID
        // so the names are not entirely well-known.
        //
        rpcStatus = UuidCreate(&newGuid);

        if ((rpcStatus != RPC_S_OK) &&
            (rpcStatus != RPC_S_UUID_LOCAL_ONLY)) {
            goto clean0;
        }

        if (StringFromGuid((LPGUID)&newGuid,
                           szGuidString,
                           MAX_GUID_STRING_LEN) != NO_ERROR) {
            goto clean0;
        }

        if (FAILED(StringCchPrintf(
                       szHotPlugPipeName,
                       SIZECHARS(szHotPlugPipeName),
                       L"%ws_%d.%ws",
                       PNP_HOTPLUG_PIPE,
                       ulSessionId,
                       szGuidString))) {
            goto clean0;
        }

        if (FAILED(StringCchPrintf(
                       szHotPlugEventName,
                       SIZECHARS(szHotPlugEventName),
                       L"Global\\%ws_%d.%ws",
                       PNP_HOTPLUG_EVENT,
                       ulSessionId,
                       szGuidString))) {
            goto clean0;
        }

        if (FAILED(StringCchLength(
                       szHotPlugEventName,
                       SIZECHARS(szHotPlugEventName),
                       &Len))) {
            goto clean0;
        }

        ulHotPlugEventNameSize = (ULONG)((Len + 1) * sizeof(WCHAR));

        //
        // Get the length of the multi-sz list. This is usually a device ID
        // possibly followed by a list of vetoers which may or may not be device
        // Id's
        //
        ulMultiSzListSize = 0;
        for (pszName = MultiSzList;
             *pszName;
             pszName += lstrlen(pszName) + 1) {

            ulMultiSzListSize += (lstrlen(pszName) + 1) * sizeof(WCHAR);
        }
        ulMultiSzListSize += sizeof(WCHAR);

        //
        // The approximate size of the named pipe output buffer should be large
        // enough to hold the greater of either:
        // - The name and size of the named event string, OR
        // - The type, size and contents of the multi-sz list.
        //
        ulSize = max(sizeof(ulHotPlugEventNameSize) +
                     ulHotPlugEventNameSize,
                     sizeof(PNP_VETO_TYPE) +
                     sizeof(ulMultiSzListSize) +
                     ulMultiSzListSize);

        //
        // Open up a named pipe to communicate with hotplug.dll.
        //
        if (CreateUserReadNamedPipe(
                hUserToken,
                szHotPlugPipeName,
                ulSize,
                &hHotPlugPipe) != NO_ERROR) {
            ASSERT(hHotPlugPipe == NULL);
            goto clean0;
        }

        //
        // Create an event that a user-client can synchronize with and set, and
        // that we will block on after we send all the device IDs to
        // hotplug.dll.
        //
        if (CreateUserSynchEvent(
                hUserToken,
                szHotPlugEventName,
                &hHotPlugEvent) != NO_ERROR) {
            ASSERT(hHotPlugEvent == NULL);
            goto clean0;
        }

        if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_EJECT_VETOED)) {
            //
            // GUID_DEVICE_EJECT_VETOED : HotPlugEjectVetoed
            // Expects veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugEjectVetoed"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVAL_VETOED)) {
            //
            // GUID_DEVICE_REMOVAL_VETOED : HotPlugRemovalVetoed
            // Expects veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugRemovalVetoed"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_STANDBY_VETOED)) {
            //
            // GUID_DEVICE_STANDBY_VETOED : HotPlugStandbyVetoed
            // Expects veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugStandbyVetoed"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_HIBERNATE_VETOED)) {
            //
            // GUID_DEVICE_HIBERNATE_VETOED : HotPlugHibernateVetoed
            // Expects veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugHibernateVetoed"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_WARM_EJECT_VETOED)) {
            //
            // GUID_DEVICE_WARM_EJECT_VETOED : HotPlugWarmEjectVetoed
            // Expects veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugWarmEjectVetoed"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SAFE_REMOVAL)) {
            //
            // GUID_DEVICE_SAFE_REMOVAL : HotPlugSafeRemovalNotification
            // No veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugSafeRemovalNotification"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType == NULL);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SURPRISE_REMOVAL)) {
            //
            // GUID_DEVICE_SURPRISE_REMOVAL : HotPlugSurpriseWarn
            // No veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugSurpriseWarn"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType == NULL);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DRIVER_BLOCKED)) {
            //
            // GUID_DRIVER_BLOCKED : HotPlugDriverBlocked
            // No veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugDriverBlocked"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType == NULL);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INVALID_ID)) {
            //
            // GUID_DEVICE_INVALID_ID : HotPlugChildWithInvalidId
            // No veto information.
            //
            hr = StringCchCopyEx(szHotPlugDllEntryPoint,
                                 SIZECHARS(szHotPlugDllEntryPoint),
                                 TEXT("HotPlugChildWithInvalidId"),
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            ASSERT(VetoType == NULL);

        } else {
            //
            // Unknown device event.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: "
                       "Unknown device event!\n"));
            ASSERT(0);
            goto clean0;
        }

        //
        // Attempt to create the user's environment block.  If for some reason we
        // can't, we'll just have to create the process without it.
        //
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hUserToken,
                                    FALSE)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: "
                       "Failed to allocate environment block, error = %d!\n",
                       GetLastError()));
            lpEnvironment = NULL;
        }

        //
        // Launch hotplug.dll using rundll32.exe, passing it the pipe name.
        // "rundll32.exe hotplug.dll,<hotplug-entry-point> <hotplug-pipe-name>"
        //
        if (FAILED(StringCchPrintf(
                       szCmdLine,
                       SIZECHARS(szCmdLine),
                       TEXT("%ws %ws,%ws %ws"),
                       RUNDLL32_EXE, HOTPLUG_DLL,
                       szHotPlugDllEntryPoint,
                       szHotPlugPipeName))) {
            goto clean0;
        }

        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.lpDesktop = DEFAULT_INTERACTIVE_DESKTOP; // WinSta0\Default

        //
        // CreateProcessAsUser will create the process in the session
        // specified by the by user-token.
        //
        if (!CreateProcessAsUser(hUserToken,        // hToken
                                 NULL,              // lpApplicationName
                                 szCmdLine,         // lpCommandLine
                                 NULL,              // lpProcessAttributes
                                 NULL,              // lpThreadAttributes
                                 FALSE,             // bInheritHandles
                                 CREATE_UNICODE_ENVIRONMENT |
                                 DETACHED_PROCESS,  // dwCreationFlags
                                 lpEnvironment,     // lpEnvironment
                                 NULL,              // lpDirectory
                                 &StartupInfo,      // lpStartupInfo
                                 &ProcessInfo       // lpProcessInfo
                                 )) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_ERRORS,
                       "UMPNPMGR: SendHotplugNotification: "
                       "Create rundll32 process failed, error = %d\n",
                       GetLastError()));
            goto clean0;
        }

        ASSERT(ProcessInfo.hProcess);
        ASSERT(ProcessInfo.hThread);

        //
        // Create an event for use with overlapped I/O - no security, manual
        // reset, not signalled, no name.
        //
        overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (overlapped.hEvent == NULL) {
            goto clean0;
        }

        //
        // Connect to the newly created named pipe.  If hotplug is not already
        // connected to the named pipe, then ConnectNamedPipe() will fail with
        // ERROR_IO_PENDING, and we will wait on the overlapped event.  If
        // newdev is already connected, it will fail with ERROR_PIPE_CONNECTED.
        // Note however that neither of these is an error condition.
        //
        if (!ConnectNamedPipe(hHotPlugPipe, &overlapped)) {
            //
            // Overlapped ConnectNamedPipe should always return FALSE on
            // success.  Check the last error to see what really happened.
            //
            dwError = GetLastError();

            if (dwError == ERROR_IO_PENDING) {
                //
                // I/O is pending, wait up to one minute for the client to
                // connect, also wait on the process in case it terminates
                // unexpectedly.
                //
                hFinishEvents[0] = overlapped.hEvent;
                hFinishEvents[1] = ProcessInfo.hProcess;

                dwWait = WaitForMultipleObjects(2, hFinishEvents,
                                                FALSE,
                                                PNP_PIPE_TIMEOUT); // 60 seconds

                if (dwWait == WAIT_OBJECT_0) {
                    //
                    // The overlapped I/O operation completed.  Check the status
                    // of the operation.
                    //
                    if (!GetOverlappedResult(hHotPlugPipe,
                                             &overlapped,
                                             &dwBytes,
                                             FALSE)) {
                        goto clean0;
                    }

                } else {
                    //
                    // Either the connection timed out, or the client process
                    // exited.  Cancel pending I/O against the pipe, and quit.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: SendHotPlugNotification: "
                               "Connect timed out, or client process exited!\n"));
                    CancelIo(hHotPlugPipe);
                    goto clean0;
                }

            } else if (dwError != ERROR_PIPE_CONNECTED) {
                //
                // If the last error indicates anything other than pending I/O,
                // or that The client is already connected to named pipe, fail.
                //
                goto clean0;
            }

        } else {
            //
            // ConnectNamedPipe should not return anything but FALSE in
            // overlapped mode.
            //
            goto clean0;
        }

        //
        // The client is now connected to the named pipe.
        // Close the overlapped event.
        //
        CloseHandle(overlapped.hEvent);
        overlapped.hEvent = NULL;

        //
        // The first data in the pipe will be the length of the name of the
        // event that will be used to sync up umpnpmgr.dll and hotplug.dll.
        //
        if (!WriteFile(hHotPlugPipe,
                       &ulHotPlugEventNameSize,
                       sizeof(ulHotPlugEventNameSize),
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // The next data in the pipe will be the name of the event that will
        // be used to sync up umpnpmgr.dll and hotplug.dll.
        //
        if (!WriteFile(hHotPlugPipe,
                       (LPCVOID)szHotPlugEventName,
                       ulHotPlugEventNameSize,
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }


        if (ARGUMENT_PRESENT(VetoType)) {
            //
            // For the notification types expecting veto information,
            // send the Veto type to the client.
            //
            if (!WriteFile(hHotPlugPipe,
                           (LPCVOID)VetoType,
                           sizeof(PNP_VETO_TYPE),
                           &ulSize,
                           NULL)) {
                LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
                goto clean0;
            }
        }

        //
        // Send the string length to the client
        //
        if (!WriteFile(hHotPlugPipe,
                       (LPCVOID)&ulMultiSzListSize,
                       sizeof(ulMultiSzListSize),
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // Now send over the entire string
        //
        if (!WriteFile(hHotPlugPipe,
                       MultiSzList,
                       ulMultiSzListSize,
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // When we are done writing, we need to close the pipe handles so that
        // the client will get a ReadFile error and know that we are finished.
        //
        if (hHotPlugPipe) {
            CloseHandle(hHotPlugPipe);
            hHotPlugPipe = NULL;
        }

        //
        // Wait for hotplug.dll to respond by setting the event before before
        // returning.  Also wait on the process as well, to catch the case where
        // the process crashes (or goes away) without signaling the device
        // install event.
        //
        hFinishEvents[0] = hHotPlugEvent;
        hFinishEvents[1] = ProcessInfo.hProcess;
        WaitForMultipleObjects(2, hFinishEvents, FALSE, INFINITE);

        bStatus = TRUE;

    clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in SendHotPlugNotification!!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        lpEnvironment = lpEnvironment;
        ProcessInfo.hThread = ProcessInfo.hThread;
        ProcessInfo.hProcess = ProcessInfo.hProcess;
        hUserToken = hUserToken;
        hHotPlugPipe = hHotPlugPipe;
        hHotPlugEvent = hHotPlugEvent;
    }

    if (lpEnvironment) {
        DestroyEnvironmentBlock(lpEnvironment);
    }

    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }

    if (ProcessInfo.hProcess) {
        CloseHandle(ProcessInfo.hProcess);
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    if (hHotPlugPipe) {
        CloseHandle(hHotPlugPipe);
    }

    if (hHotPlugEvent) {
        CloseHandle(hHotPlugEvent);
    }

    if (!bStatus) {
        *SessionId = INVALID_SESSION;
    } else {
        *SessionId = ulSessionId;
    }

    return bStatus;

} // SendHotplugNotification



ULONG
CheckEjectPermissions(
    IN      LPWSTR          DeviceId,
    OUT     PPNP_VETO_TYPE  VetoType            OPTIONAL,
    OUT     LPWSTR          VetoName            OPTIONAL,
    IN OUT  PULONG          VetoNameLength      OPTIONAL
    )
/*++

Routine Description:

   Checks that the user has eject permissions for the specified device.

Arguments:

    DeviceId       - Specifies the device instance id of the device for which
                     eject permissions are to be checked.

    VetoType       - Supplies the address of a variable to receive, upon
                     failure, the type of the component responsible for vetoing
                     the request.

    VetoName       - Supplies the address of a variable to receive, upon
                     failure, the name of the component responsible for vetoing
                     the request.

    VetoNameLength - Supplies the address of a variable specifying the size of
                     the of buffer specified by the VetoName parameter.  Upon
                     failure, this address will specify the length of the string
                     stored in that buffer by this routine.


Return Value:

   FALSE if the eject should be blocked, TRUE otherwise.

Note:

    This routine is called while processing a kernel-initiated ejection event.
    On this side of the event, we are NOT in the context of the user who
    initiated the ejection, but since only the active console user was allowed
    to initiate the request that triggered this event, we use the access token
    of the active console user for the check on this side also.  (should the
    active console user change between the request and this event, this would
    check that the user that the current active console user has eject
    permissions; this is still a valid thing to do since it is the console user
    who will receive the ejected hardware)

--*/
{
    BOOL    bResult, bDockDevice;
    ULONG   ulPropertyData, ulDataSize, ulDataType;
    ULONG   ulTransferLen, ulConsoleSessionId;
    HANDLE  hUserToken = NULL;

    //
    // Is this a dock?
    //
    bDockDevice = FALSE;
    ulDataSize = ulTransferLen = sizeof(ULONG);
    if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                           DeviceId,
                                           CM_DRP_CAPABILITIES,
                                           &ulDataType,
                                           (LPBYTE)&ulPropertyData,
                                           &ulTransferLen,
                                           &ulDataSize,
                                           0)) {

        if (ulPropertyData & CM_DEVCAP_DOCKDEVICE) {

            //
            // Undocking (ie ejecting a dock) uses a special privilege.
            //
            bDockDevice = TRUE;
        }
    } else {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: PNP_GetDeviceRegProp failed, error = %d\n",
                   GetLastError()));

        return FALSE;
    }

    ulConsoleSessionId = GetActiveConsoleSessionId();

    if ((IsSessionLocked(ulConsoleSessionId)) ||
        (!GetSessionUserToken(ulConsoleSessionId, &hUserToken))) {
        //
        // If the console session is locked or no user is logged in, supply no
        // user token, and verify strictly against the policy permissions
        // required to eject the dock or device, absent a user.
        //
        hUserToken = NULL;
    }

    bResult = VerifyKernelInitiatedEjectPermissions(hUserToken, bDockDevice);

    if (bResult == FALSE) {

        if (ARGUMENT_PRESENT(VetoType)) {
            *VetoType = PNP_VetoInsufficientRights;
        }

        if (ARGUMENT_PRESENT(VetoNameLength)) {

            //
            // VetoNameLength is in characters.
            //
            if (ARGUMENT_PRESENT(VetoName) && *VetoNameLength) {
                *VetoName = UNICODE_NULL;
            }
            *VetoNameLength = 0;
        }
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    return bResult;

} // CheckEjectPermissions



//---------------------------------------------------------------------------
// Private Utility Routines
//---------------------------------------------------------------------------

VOID
LogErrorEvent(
    DWORD dwEventID,
    DWORD dwError,
    WORD  nStrings,
    ...
    )
{
    HANDLE  hEventLog;
    LPWSTR  *paStrings;
    va_list pArg;
    DWORD   index;

    hEventLog = RegisterEventSource(NULL, TEXT("PlugPlayManager"));

    if (hEventLog == NULL) {
        return;
    }

    if (nStrings) {

        paStrings = HeapAlloc(ghPnPHeap, 0, nStrings * sizeof(LPWSTR));

        if (paStrings != NULL) {
            va_start(pArg, nStrings);

            for (index = 0; index < nStrings; index++) {
                paStrings[index] = va_arg(pArg, LPWSTR);
            }

            va_end(pArg);

            ReportEvent( hEventLog,
                         EVENTLOG_ERROR_TYPE,
                         0,                     // wCategory
                         dwEventID,             // dwEventID
                         NULL,                  // lpUserSID
                         nStrings,              // wNumStrings
                         sizeof(dwError),       // dwDataSize
                         paStrings,             // lpStrings
                         &dwError);             // lpRawData

            HeapFree(ghPnPHeap, 0, paStrings);
        }

    } else {

        ReportEvent( hEventLog,
                     EVENTLOG_ERROR_TYPE,
                     0,                     // wCategory
                     dwEventID,             // dwEventID
                     NULL,                  // lpUserSID
                     0,                     // wNumStrings
                     sizeof(dwError),       // dwDataSize
                     NULL,                  // lpStrings
                     &dwError);             // lpRawData
    }

    DeregisterEventSource(hEventLog);
}

VOID
LogWarningEvent(
    DWORD dwEventID,
    WORD  nStrings,
    ...
    )
{
    HANDLE  hEventLog;
    LPWSTR  *paStrings;
    va_list pArg;
    DWORD   index;

    hEventLog = RegisterEventSource(NULL, TEXT("PlugPlayManager"));

    if (hEventLog == NULL) {
        return;
    }

    paStrings = HeapAlloc(ghPnPHeap, 0, nStrings * sizeof(LPWSTR));

    if (paStrings != NULL) {
        va_start(pArg, nStrings);

        for (index = 0; index < nStrings; index++) {
            paStrings[index] = va_arg(pArg, LPWSTR);
        }

        va_end(pArg);

        ReportEvent( hEventLog,
                     EVENTLOG_WARNING_TYPE,
                     0,                     // wCategory
                     dwEventID,             // dwEventID
                     NULL,                  // lpUserSID
                     nStrings,              // wNumStrings
                     0,                     // dwDataSize
                     paStrings,             // lpStrings
                     NULL);                 // lpRawData

        HeapFree(ghPnPHeap, 0, paStrings);
    }

    DeregisterEventSource(hEventLog);
}

BOOL
LockNotifyList(
    IN LOCKINFO *Lock
    )
{
    return LockPrivateResource(Lock);
}


VOID
UnlockNotifyList(
    IN LOCKINFO *Lock
    )
{
    UnlockPrivateResource(Lock);
}



PPNP_NOTIFY_LIST
GetNotifyListForEntry(
    IN PPNP_NOTIFY_ENTRY Entry
    )
/*++

Routine Description:

    This routine retrives the notification list that the given entry is in,
    based on the list entry signature.  If this entry has been removed from a
    notification list (via DeleteNotifyEntry), NULL is returned.

Arguments:

    Entry - Specifies a notification entry for the coresponding notification
            list is to be found.

Return Value:

    Returns the notification list this entry is a member of, or NULL if the
    entry is not in any notification list.

--*/
{
    PPNP_NOTIFY_LIST notifyList;

    if (!Entry) {
        return NULL;
    }

    //
    // Retrieve the list pointer from the entry signature.
    // The signature contains two pieces of data.
    //
    // It is a ULONG, with byte 0 being a list index and
    // bytes 1,2,3 being the signature
    // We mask and compare the top 3 bytes to find which list
    // then return the address of the list to lock based on the
    // index in the bottom byte.
    //

    switch (Entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

        case TARGET_ENTRY_SIGNATURE:
            notifyList = &TargetList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case CLASS_ENTRY_SIGNATURE:
            notifyList = &ClassList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case SERVICE_ENTRY_SIGNATURE:
            notifyList = &ServiceList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case 0:
            //
            // If the entry Signature is 0, this entry has been removed from it's
            // notification list.
            //
            notifyList = NULL;
            break;

        default:
            //
            // Should never get here!
            //
            ASSERT (FALSE);
            notifyList = NULL;
            break;
    }
    return notifyList;

} // GetNotifyListForEntry



BOOL
DeleteNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN BOOLEAN RpcNotified
    )
/*++

Routine Description:

    This routine removes an entry from a notification list and frees the
    memory for that entry.

Arguments:

   Entry - Specifies an entry in one of the notification lists that is
           to be deleted.

Return Value:

   Returns TRUE or FALSE.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = Entry->Previous;

    if (!(Entry->Freed & DEFER_NOTIFY_FREE)) {
        if (previousEntry == NULL) {
            return FALSE;
        }

        //
        // hook up the forward and backwards pointers
        //
        previousEntry->Next = Entry->Next;

        if (Entry->Next) {
            ((PPNP_NOTIFY_ENTRY)(Entry->Next))->Previous = previousEntry;
        }

        //
        // Clear the entry signature now that it is no longer part of any list.
        //
        Entry->Signature = 0;
    }

    if (RpcNotified || (Entry->Freed & DEFER_NOTIFY_FREE)) {
        if (Entry->ClientName) {
            HeapFree (ghPnPHeap,0,Entry->ClientName);
            Entry->ClientName = NULL;
        }
        HeapFree(ghPnPHeap, 0, Entry);
    }else {
        //
        //Let the entry dangle until the RPC rundown
        //
        Entry->Freed |= DEFER_NOTIFY_FREE;
    }

    return TRUE;

} // DeleteNotifyEntry;



VOID
AddNotifyEntry(
    IN PPNP_NOTIFY_LIST  NotifyList,
    IN PPNP_NOTIFY_ENTRY NewEntry
    )
/*++

Routine Description:

    This routine inserts an entry at the tail of a notification list.

Arguments:

   Entry - Specifies an entry to be added to a notification list

Return Value:

   None.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = NULL, currentEntry = NULL;
    //
    // Skip to the last entry in this list.
    //
    previousEntry = (PPNP_NOTIFY_ENTRY)NotifyList;
    currentEntry = previousEntry->Next;

    while (currentEntry) {
        previousEntry = currentEntry;
        currentEntry = currentEntry->Next;
    }

    //
    // Attach this entry to the end of the list.
    //
    previousEntry->Next = NewEntry;
    NewEntry->Previous = previousEntry;
    NewEntry->Next = NULL;

    return;

} // AddNotifyEntry;



PPNP_NOTIFY_ENTRY
GetNextNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN DWORD Flags
    )
/*++

Routine Description:

    Returns the next entry in the notification list for the entry specified, in
    the direction specified by the Flags.

Arguments:

    Entry - Specified a notification list entry.

    Flags - Specifies BSF_* flags indicating the direction the list is to be
            traversed.  If BSF_QUERY is specified, the previous list entry is
            returned, otherwise returns the next entry forward in the list.

Return Value:

    Returns the next entry in the notification list, or NULL if no such entry
    exists.

--*/
{
    PPNP_NOTIFY_ENTRY nextEntry = NULL;

    if (Entry == NULL) {
        return Entry;
    }

    //
    // Determine if this is a QUERY (or a resume). In which case
    // we go back -> front.
    //
    if (Flags & BSF_QUERY) {
        nextEntry = Entry->Previous;
        //
        // If the previous entry is the list head, there is no next entry.
        //
        if ((nextEntry == NULL) ||
            (nextEntry->Previous == NULL)) {
            return NULL;
        }

    } else {
        nextEntry = Entry->Next;
    }
    return nextEntry;
}



PPNP_NOTIFY_ENTRY
GetFirstNotifyEntry(
    IN PPNP_NOTIFY_LIST List,
    IN DWORD Flags
    )
/*++

Routine Description:

    Returns the first entry in the specified notification list, starting from
    the direction specified by the Flags.

Arguments:

    List  - Specified a notification list.

    Flags - Specifies BSF_* flags indicating the end of the list from which the
            first entry is to be retrieved.  If BSF_QUERY is specified, the last
            list entry is returned, otherwise returns the first entry in the
            list.

Return Value:

    Returns the first entry in the notification list, or NULL if no such entry
    exists.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = NULL, currentEntry = NULL, firstEntry = NULL;

    //
    // Determine if this is a QUERY (or a resume). In which case
    // we go back -> front.
    //
    if (Flags & BSF_QUERY) {

        //
        // Skip to the last entry in this list.
        //
        previousEntry = (PPNP_NOTIFY_ENTRY)List;
        currentEntry = previousEntry->Next;

        while (currentEntry) {
            previousEntry = currentEntry;
            currentEntry = currentEntry->Next;
        }
        if (!previousEntry->Previous) {
            //
            // If the list is empty, there is no first entry.
            //
            firstEntry = NULL;
        } else {
            firstEntry = previousEntry;
        }

    } else {
        firstEntry = (PPNP_NOTIFY_ENTRY)List->Next;
    }
    return firstEntry;
}



ULONG
HashString(
    IN LPWSTR String,
    IN ULONG  Buckets
    )
/*++

Routine Description:

    This routine performs a quick and dirty hash of a unicode string.

Arguments:

   String - Null-terminated unicode string to perform hash on.

   Buckets - Number of hashing buckets.

Return Value:

   Returns a hash value between 0 and Buckets.

--*/
{
    LPWSTR p = String;
    ULONG hash = 0;

    while (*p) {
        hash ^= *p;
        p++;
    }

    hash = hash % Buckets;

    return hash;

} // HashString



DWORD
MapQueryEventToCancelEvent(
    IN DWORD QueryEventId
    )
/*++

Routine Description:

    This routine maps a query device event id (such as query remove) to the
    corresponding cancel device event id (such as cancel remove). The event
    ids are based on DBT_Xxx values from DBT.H.

Arguments:

   QueryEventId - A DBT_Xxx query type device event id.


Return Value:

   Returns the corresponding cancel device event id or -1 if it fails.

--*/
{
    DWORD cancelEventId;

    switch (QueryEventId) {

        case DBT_QUERYCHANGECONFIG:
            cancelEventId = DBT_CONFIGCHANGECANCELED;
            break;

        case DBT_DEVICEQUERYREMOVE:
            cancelEventId = DBT_DEVICEQUERYREMOVEFAILED;
            break;

        case PBT_APMQUERYSUSPEND:
            cancelEventId = PBT_APMQUERYSUSPENDFAILED;
            break;

        case PBT_APMQUERYSTANDBY:
            cancelEventId = PBT_APMQUERYSTANDBYFAILED;

        default:
            cancelEventId = (DWORD)-1;
            break;
    }

    return cancelEventId;

} // MapQueryEventToCancelEvent



VOID
FixUpDeviceId(
    IN OUT LPWSTR  DeviceId
    )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

Return Value:

    None.

--*/
{
    PWCHAR p;

    CharUpper(DeviceId);
    p = DeviceId;
    while (*p) {
        if ((*p <= TEXT(' '))  || (*p > (WCHAR)0x7F) || (*p == TEXT(','))) {
            *p = TEXT('_');
        }
        p++;
    }

} // FixUpDeviceId



BOOL
GetWindowsExeFileName(
    IN  HWND      hWnd,
    OUT LPWSTR    lpszFileName,
    IN OUT PULONG pulFileNameLength
    )
/*++

Routine Description:

    This routine retrieves the module file name for the process that the
    specified window belongs to.

Arguments:

    hWnd              - Supplies the handle to the window whose process module
                        file name is to be retrieved.

    lpszFileName      - Supplies the address of a variable to receive, upon
                        success, the module file name of the window's process.

    pulFileNameLength - Supplies the address of a variable specifying the size of
                        the of buffer specified by the lpszFileName parameter.
                        Upon success, this address will specify the length of
                        the string stored in that buffer by this routine.

Return Value:

    Returns TRUE.

Notes:

    Not implemented.  Currently returns a NULL string for the file name.

--*/
{
    UNREFERENCED_PARAMETER(hWnd);

    if ((!ARGUMENT_PRESENT(lpszFileName)) ||
        (!ARGUMENT_PRESENT(pulFileNameLength))) {
        return FALSE;
    }

    if (*pulFileNameLength > 0) {
        *pulFileNameLength = 0;
        lpszFileName[0] = UNICODE_NULL;
    }

    return TRUE;

} // GetWindowsExeFileName



BOOL
InitializeHydraInterface(
    VOID
    )
/*++

Routine Description:

    This routine loads the terminal services support libraries and locates
    required function entrypoints.

Arguments:

    None.

Return Value:

    Returns TRUE if the terminal services support libraries were successfully
    loaded, and entrypoints located.

--*/
{
    BOOL Status = FALSE;

    //
    // Load the base library that contains the user message dispatch routines
    // for Terminal Services.
    //
    ghWinStaLib = LoadLibrary(WINSTA_DLL);
    if (!ghWinStaLib) {
        return FALSE;
    }

    fpWinStationSendWindowMessage =
        (FP_WINSTASENDWINDOWMESSAGE)GetProcAddress(
            ghWinStaLib,
            "WinStationSendWindowMessage");

    fpWinStationBroadcastSystemMessage =
        (FP_WINSTABROADCASTSYSTEMMESSAGE)GetProcAddress(
            ghWinStaLib,
            "WinStationBroadcastSystemMessage");

    fpWinStationQueryInformationW =
        (FP_WINSTAQUERYINFORMATIONW)GetProcAddress(
            ghWinStaLib,
            "WinStationQueryInformationW");

    if (!fpWinStationSendWindowMessage ||
        !fpWinStationBroadcastSystemMessage ||
        !fpWinStationQueryInformationW) {
        goto Clean0;
    }


    //
    // Load the library that contains Terminal Services support routines.
    //
    ghWtsApi32Lib = LoadLibrary(WTSAPI32_DLL);
    if (!ghWtsApi32Lib) {
        goto Clean0;
    }

    fpWTSQuerySessionInformation =
        (FP_WTSQUERYSESSIONINFORMATION)GetProcAddress(
            ghWtsApi32Lib,
            "WTSQuerySessionInformationW");

    fpWTSFreeMemory =
        (FP_WTSFREEMEMORY)GetProcAddress(
            ghWtsApi32Lib,
            "WTSFreeMemory");

    if (!fpWTSQuerySessionInformation ||
        !fpWTSFreeMemory) {
        goto Clean0;
    }

    Status = TRUE;

Clean0:

    ASSERT(Status == TRUE);

    if (!Status) {
        //
        // Something failed.  Unload all libraries.
        //
        fpWinStationSendWindowMessage = NULL;
        fpWinStationBroadcastSystemMessage = NULL;
        fpWinStationQueryInformationW = NULL;

        if (ghWinStaLib) {
            FreeLibrary(ghWinStaLib);
            ghWinStaLib = NULL;
        }

        fpWTSQuerySessionInformation = NULL;
        fpWTSFreeMemory = NULL;

        if (ghWtsApi32Lib) {
            FreeLibrary(ghWtsApi32Lib);
            ghWtsApi32Lib = NULL;
        }
    }

    return Status;

} // InitializeHydraInterface



BOOL
GetClientName(
    IN  PPNP_NOTIFY_ENTRY entry,
    OUT LPWSTR  lpszClientName,
    IN OUT PULONG  pulClientNameLength
    )
/*++

Routine Description:

    This routine retrieves the client name for the specified notification list
    entry.

Arguments:

    entry                - Specifies a notification list entry.

    lpszClientName       - Supplies the address of a variable to receive, the
                           client name of the window's process.

    pulClientNameLength  - Supplies the address of a variable specifying the size of
                           the of buffer specified by the lpszFileName parameter.
                           Upon return, this address will specify the length of
                           the string stored in that buffer by this routine.

Return Value:

    Returns TRUE.

--*/
{
    size_t  BufferLen = 0, ClientNameLen = 0;

    //
    // Validate parameters.
    //
    if ((!ARGUMENT_PRESENT(lpszClientName)) ||
        (!ARGUMENT_PRESENT(pulClientNameLength)) ||
        (*pulClientNameLength == 0)) {
        return FALSE;
    }

    //
    // Copy as much of the client name that will fit into the specified buffer,
    // (including the NULL terminating char).
    //
    BufferLen = *pulClientNameLength;

    *pulClientNameLength = 0;
    *lpszClientName = L'\0';

    if ((!ARGUMENT_PRESENT(entry)) ||
        (entry->ClientName == NULL)) {
        return FALSE;
    }

    ASSERT(BufferLen > 0);

    //
    // Copy client name to specified buffer, allow truncation.
    //
    if (FAILED(StringCchCopyEx(
                   lpszClientName,
                   BufferLen,
                   entry->ClientName,
                   NULL, NULL,
                   STRSAFE_IGNORE_NULLS))) {
        //
        // Failure from truncation can be handled safely.
        //
        NOTHING;
    }

    //
    // Count the number of characters copied to the buffer.
    //
    if (FAILED(StringCchLength(
                   lpszClientName,
                   BufferLen,
                   &ClientNameLen))) {
        *lpszClientName = L'\0';
        return FALSE;
    }

    //
    // The size returned does not include the terminating NULL.
    //
    ASSERT(ClientNameLen < MAX_SERVICE_NAME_LEN);

    *pulClientNameLength = (ULONG)ClientNameLen;

    return TRUE;

} // GetClientName



void __RPC_USER
PNP_NOTIFICATION_CONTEXT_rundown(
    PPNP_NOTIFICATION_CONTEXT hEntry
    )
/*++

Routine Description:

    Rundown routine for RPC.  This will get called if a client/server pipe
    breaks without unregistering a notification.  If a notification is in
    progress when rundown is called, the entry is kept in a deferred list, and
    this routines is explicitly called again for the deferred entry, after
    notification is complete.

    This routine frees the memory associated with the notification entry that is
    no longer needed.

Arguments:

    hEntry - Specifies a notification entry for which RPC has requested rundown.

Return Value:

    None.

--*/
{
    PPNP_NOTIFY_LIST notifyList = NULL;
    PPNP_NOTIFY_ENTRY node;
    PPNP_DEFERRED_LIST rundownNode;
    BOOLEAN bLocked = FALSE;

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_WARNINGS | DBGF_EVENT,
               "UMPNPMGR: Cleaning up broken pipe\n"));

    try {
        EnterCriticalSection(&RegistrationCS);
        node = (PPNP_NOTIFY_ENTRY) hEntry;

        if (gNotificationInProg != 0) {
            //
            // Before freeing the entry, we need to make sure that it's not sitting
            // around in the deferred RegisterList or UnregisterList.
            //

            if (RegisterList != NULL) {
                //
                // Check to see if this entry is in the deferred RegisterList.
                //
                PPNP_DEFERRED_LIST currReg,prevReg;

                currReg = RegisterList;
                prevReg = NULL;

                while (currReg) {
                    ASSERT(currReg->Entry->Unregistered);
                    if (currReg->Entry == node) {
                        //
                        // Remove this entry from the deferred RegisterList.
                        //
                        if (prevReg) {
                            prevReg->Next = currReg->Next;
                        } else {
                            RegisterList = currReg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currReg);
                        if (prevReg) {
                            currReg = prevReg->Next;
                        } else {
                            currReg = RegisterList;
                        }
                    } else {
                        prevReg = currReg;
                        currReg = currReg->Next;
                    }
                }
            }
            if (UnregisterList != NULL) {
                //
                // Check to see if this entry is in the deferred UnregisterList.
                //
                PPNP_DEFERRED_LIST currUnreg,prevUnreg;
                currUnreg = UnregisterList;
                prevUnreg = NULL;

                while (currUnreg) {
                    ASSERT(currUnreg->Entry->Unregistered);
                    if (currUnreg->Entry == node) {
                        //
                        // Remove this entry from the deferred UnregisterList.
                        //
                        if (prevUnreg) {
                            prevUnreg->Next = currUnreg->Next;
                        } else {
                            UnregisterList = currUnreg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currUnreg);
                        if (prevUnreg) {
                            currUnreg = prevUnreg->Next;
                        } else {
                            currUnreg = UnregisterList;
                        }
                    } else {
                        prevUnreg = currUnreg;
                        currUnreg = currUnreg->Next;
                    }
                }
            }

            //
            // If the entry to be rundown is part of a notification list, make
            // sure it does not get notified.
            //
            notifyList = GetNotifyListForEntry(node);
            if (notifyList) {
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                node->Unregistered = TRUE;
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
            }

            //
            // Delay rundown of this entry until after the notification in
            // progress is complete.
            //
            rundownNode = (PPNP_DEFERRED_LIST)
                HeapAlloc(ghPnPHeap,
                          0,
                          sizeof (PNP_DEFERRED_LIST));

            if (!rundownNode) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS | DBGF_WARNINGS,
                           "UMPNPMGR: Error allocating deferred list entry during RPC rundown!\n"));
                goto Clean0;
            }
            rundownNode->hBinding = 0;
            rundownNode->Entry = node;
            rundownNode->Next = RundownList;
            RundownList = rundownNode;

        } else {

            if (!(node->Freed & DEFER_NOTIFY_FREE)) {
                //
                // This entry is still in a notification list.
                //
                notifyList = GetNotifyListForEntry(node);
                ASSERT(notifyList);
                if (notifyList) {
                    //
                    // Lock the notification list and delete this entry.
                    //
                    LockNotifyList (&notifyList->Lock);
                    bLocked = TRUE;
                }
                node->Freed |= (PNP_UNREG_FREE|PNP_UNREG_RUNDOWN);
                DeleteNotifyEntry (node,TRUE);
                if (notifyList) {
                    UnlockNotifyList (&notifyList->Lock);
                    bLocked = FALSE;
                }

            } else {
                //
                // This node has been removed from the list, and should just be deleted
                //
                DeleteNotifyEntry (node,TRUE);
            }
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during PNP_NOTIFICATION_CONTEXT_rundown!\n"));
        ASSERT(0);

        if (bLocked) {
            UnlockNotifyList (&notifyList->Lock);
        }
        LeaveCriticalSection(&RegistrationCS);
    }

    return;

} // PNP_NOTIFICATION_CONTEXT_rundown



DWORD
LoadDeviceInstaller(
    VOID
    )
/*++

Routine Description:

    This routine loads setupapi.dll and retrieves the necessary device install
    entrypoints.  It also creates two named events used to communicate with the
    client-side UI in the case where there's a user logged in.

    If setupapi.dll is already loaded, it simply returns success.

Arguments:

    None

Return Value:

    If successful, NO_ERROR is returned.  Otherwise, a Win32 error code is
    returned indicating the cause of failure.

--*/
{
    DWORD Err = NO_ERROR;
    DWORD SetupGlobalFlags;

    if (ghDeviceInstallerLib) {
        return NO_ERROR;
    }

    ghDeviceInstallerLib =
        LoadLibrary(SETUPAPI_DLL);

    if (!ghDeviceInstallerLib) {
        return GetLastError();
    }

    try {
       //
       // Locate the SETUPAPI entrypoints required to perform device
       // installation.
       //
       fpCreateDeviceInfoList =
           (FP_CREATEDEVICEINFOLIST)GetProcAddress(
               ghDeviceInstallerLib,
               "SetupDiCreateDeviceInfoList");
       if (!fpCreateDeviceInfoList) {
           goto HitFailure;
       }

       fpOpenDeviceInfo =
           (FP_OPENDEVICEINFO)GetProcAddress(
               ghDeviceInstallerLib,
               "SetupDiOpenDeviceInfoW");
       if (!fpOpenDeviceInfo) {
           goto HitFailure;
       }

       fpBuildDriverInfoList =
           (FP_BUILDDRIVERINFOLIST)GetProcAddress(
               ghDeviceInstallerLib,
               "SetupDiBuildDriverInfoList");
       if (!fpBuildDriverInfoList) {
           goto HitFailure;
       }

        fpDestroyDeviceInfoList =
            (FP_DESTROYDEVICEINFOLIST)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiDestroyDeviceInfoList");
        if (!fpDestroyDeviceInfoList) {
            goto HitFailure;
        }

        fpCallClassInstaller =
            (FP_CALLCLASSINSTALLER)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiCallClassInstaller");
        if (!fpCallClassInstaller) {
            goto HitFailure;
        }

        fpInstallClass =
            (FP_INSTALLCLASS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiInstallClassW");
        if (!fpInstallClass) {
            goto HitFailure;
        }

        fpGetSelectedDriver =
            (FP_GETSELECTEDDRIVER)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiGetSelectedDriverW");
        if (!fpGetSelectedDriver) {
            goto HitFailure;
        }

        fpGetDriverInfoDetail =
            (FP_GETDRIVERINFODETAIL)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiGetDriverInfoDetailW");

        if (!fpGetDriverInfoDetail) {
            goto HitFailure;
        }

        fpGetDeviceInstallParams =
            (FP_GETDEVICEINSTALLPARAMS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiGetDeviceInstallParamsW");

        if (!fpGetDeviceInstallParams) {
            goto HitFailure;
        }

        fpSetDeviceInstallParams =
            (FP_SETDEVICEINSTALLPARAMS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiSetDeviceInstallParamsW");
        if (!fpSetDeviceInstallParams) {
            goto HitFailure;
        }

        fpGetDriverInstallParams =
            (FP_GETDRIVERINSTALLPARAMS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiGetDriverInstallParamsW");
        if (!fpGetDriverInstallParams) {
            goto HitFailure;
        }

        fpSetClassInstallParams =
            (FP_SETCLASSINSTALLPARAMS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiSetClassInstallParamsW");
        if (!fpSetClassInstallParams) {
            goto HitFailure;
        }


        fpGetClassInstallParams =
            (FP_GETCLASSINSTALLPARAMS)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupDiGetClassInstallParamsW");
        if (!fpGetClassInstallParams) {
            goto HitFailure;
        }

        fpOpenInfFile =
            (FP_OPENINFFILE)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupOpenInfFileW");
        if (!fpOpenInfFile) {
            goto HitFailure;
        }

        fpCloseInfFile =
            (FP_CLOSEINFFILE)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupCloseInfFile");
        if (!fpCloseInfFile) {
            goto HitFailure;
        }

        fpFindFirstLine =
            (FP_FINDFIRSTLINE)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupFindFirstLineW");
        if (!fpFindFirstLine) {
            goto HitFailure;
        }

        fpFindNextMatchLine =
            (FP_FINDNEXTMATCHLINE)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupFindNextMatchLineW");
        if (!fpFindNextMatchLine) {
            goto HitFailure;
        }

        fpGetStringField =
            (FP_GETSTRINGFIELD)GetProcAddress(
                ghDeviceInstallerLib,
                "SetupGetStringFieldW");
        if (!fpGetStringField) {
            goto HitFailure;
        }

        fpSetGlobalFlags =
            (FP_SETGLOBALFLAGS)GetProcAddress(
                ghDeviceInstallerLib,
                "pSetupSetGlobalFlags");
        if (!fpSetGlobalFlags) {
            goto HitFailure;
        }

        fpGetGlobalFlags =
            (FP_GETGLOBALFLAGS)GetProcAddress(
                ghDeviceInstallerLib,
                "pSetupGetGlobalFlags");
        if (!fpGetGlobalFlags) {
            goto HitFailure;
        }

        fpAccessRunOnceNodeList =
            (FP_ACCESSRUNONCENODELIST)GetProcAddress(
                ghDeviceInstallerLib,
                "pSetupAccessRunOnceNodeList");
        if (!fpAccessRunOnceNodeList) {
            goto HitFailure;
        }

        fpDestroyRunOnceNodeList =
            (FP_DESTROYRUNONCENODELIST)GetProcAddress(
                ghDeviceInstallerLib,
                "pSetupDestroyRunOnceNodeList");
        if (!fpDestroyRunOnceNodeList) {
            goto HitFailure;
        }

        //
        // Now configure setupapi for server-side installation
        //
        SetupGlobalFlags = fpGetGlobalFlags();

        //
        // We want to run non-interactive and do RunOnce entries server-side
        //
        SetupGlobalFlags |= (PSPGF_NONINTERACTIVE | PSPGF_SERVER_SIDE_RUNONCE);

        //
        // Make sure we _aren't_ skipping backup--it is essential that we be
        // able to completely back-out of an installation half-way through if
        // we encounter a failure (e.g., an unsigned file).
        //
        SetupGlobalFlags &= ~PSPGF_NO_BACKUP;

        fpSetGlobalFlags(SetupGlobalFlags);

        //
        // If we get to here, we succeeded.
        //
        goto clean0;

    HitFailure:
        //
        // Failed to retrieve some entrypoint.
        //
        Err = GetLastError();

    clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during LoadDeviceInstaller!\n"));
        ASSERT(0);
        Err = ERROR_INVALID_DATA;
    }

    if(Err != NO_ERROR) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: failed to load device installer, error = %d\n",
                   Err));
        FreeLibrary(ghDeviceInstallerLib);
        ghDeviceInstallerLib = NULL;
    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Loaded device installer\n",
                   Err));
    }

    return Err;

} // LoadDeviceInstaller



VOID
UnloadDeviceInstaller(
    VOID
    )
/*++

Routine Description:

    This unloads setupapi.dll if it's presently loaded.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient, pNextDeviceInstallClient;

    //
    // Unload setupapi.dll.
    //
    if(ghDeviceInstallerLib) {

        FreeLibrary(ghDeviceInstallerLib);
        ghDeviceInstallerLib = NULL;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Unloaded device installer\n"));
    }

    //
    // Close any device install clients that exist.
    //
    LockNotifyList(&InstallClientList.Lock);
    pDeviceInstallClient = InstallClientList.Next;
    while (pDeviceInstallClient) {
        ASSERT(pDeviceInstallClient->RefCount == 1);
        pNextDeviceInstallClient = pDeviceInstallClient->Next;
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        pDeviceInstallClient = pNextDeviceInstallClient;
    }
    UnlockNotifyList(&InstallClientList.Lock);

    return;

} // UnloadDeviceInstaller



DWORD
InstallDeviceServerSide(
    IN     LPWSTR pszDeviceId,
    IN OUT PBOOL  RebootRequired,
    IN OUT PBOOL  DeviceHasProblem,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine attempts to install the specified device in the context of
    umpnpmgr (i.e., on the server-side of the ConfigMgr interface).

Arguments:

    pszDeviceId - device instance ID of the devnode to be installed.

    RebootRequired - Supplies the address of a boolean variable that will be
        set to TRUE if the (successful) installation of this device requires a
        reboot.  Note, the existing value of this variable is preserved if
        either (a) the installation fails or (b) no reboot was required.
        
    DeviceHasProblem - Supplies the address of a boolean variable that will be
        set to TRUE if the device has a CM_PROB_Xxx code after the drivers
        were installed. Note, this value is only set if the installation 
        succeedes.          

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the id of the session in which the device install
        client UI process was launched.  Otherwise, will contain an invalid
        session id INVALID_SESSION, (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.

Return Value:

    If the device installation was successful, the return value is NO_ERROR.
    Otherwise, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    DWORD Err;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    LPWSTR pszClassGuid;
    WCHAR szBuffer[MAX_PATH];
    HKEY hKey;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    BOOL b, bDoClientUI = FALSE;
    LPWSTR p;
    SP_DRVINFO_DATA DriverInfoData;
    ULONG ulType;
    ULONG ulSize;
    DWORD Capabilities;
    SP_NEWDEVICEWIZARD_DATA NewDevWizData;
    BOOL RemoveNewDevDescValue = FALSE;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData = NULL;
    DWORD DriverInfoDetailDataSize;
    HINF hInf;
    INFCONTEXT InfContext;
    DWORD i, dwWait;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;
    ULONG ulSessionId = INVALID_SESSION;
    ULONG ulTransferLen;
    ULONG ulStatus, ulProblem;
    HRESULT hr;


    //
    // Now create a container set for our device information element.
    //
    DeviceInfoSet = fpCreateDeviceInfoList(NULL, NULL);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    if(!fpOpenDeviceInfo(DeviceInfoSet, pszDeviceId, NULL, 0, &DeviceInfoData)) {
        goto clean1;
    }

    //
    // OK, it looks like we're going to be able to attempt a server-side
    // install.  Next up is the (potentially time-consuming) driver search.
    // Before we start that, we want to fire up some UI on the client side (if
    // somebody is logged in) letting them know we've found their hardware and
    // are working on installing it.
    //
    // NOTE: We don't fire up client-side UI if the device has the SilentInstall
    // capability.
    //
    ulSize = ulTransferLen = sizeof(Capabilities);
    if ((CR_SUCCESS != PNP_GetDeviceRegProp(NULL,
                                            pszDeviceId,
                                            CM_DRP_CAPABILITIES,
                                            &ulType,
                                            (LPBYTE)&Capabilities,
                                            &ulTransferLen,
                                            &ulSize,
                                            0))
        || !(Capabilities & CM_DEVCAP_SILENTINSTALL)) {
        //
        // Either we couldn't retrieve the capabilities property (shouldn't
        // happen, or we did retrieve it but the silent-install bit wasn't set.
        //
        bDoClientUI = TRUE;

        //
        // If we're not going to determine the session to use for UI, use the
        // SessionId supplied by the caller.
        //
        if ((Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0) {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        //
        // Go ahead and fire up the client-side UI.
        //
        DoDeviceInstallClient(pszDeviceId,
                              &ulSessionId,
                              Flags | DEVICE_INSTALL_UI_ONLY | DEVICE_INSTALL_PLAY_SOUND,
                              &pDeviceInstallClient);
    }

    //
    // Do a default driver search for this device.
    //
    if(!fpBuildDriverInfoList(DeviceInfoSet, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
        goto clean1;
    }

    //
    // Select the best driver from the list we just built.
    //
    if(!fpCallClassInstaller(DIF_SELECTBESTCOMPATDRV, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    b = fpGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    //
    // NOTE: the multi-port serial class has some buggy co-installers that
    // always popup UI, without using the finish-install wizard page mechanism,
    // and without regard to the DI_QUIETINSTALL flag.  Until they clean up
    // their act, we must disallow server-side installation of those devices
    // as well.
    //
    if(GuidEqual(&GUID_DEVCLASS_MULTIPORTSERIAL, &(DeviceInfoData.ClassGuid))) {
        Err = ERROR_DI_DONT_INSTALL;
        goto clean0;
    }

    //
    // Kludge to allow INFs to force client-side (i.e., interactive)
    // installation for certain devices.  They do this by referencing a
    // hardware or compatible ID in an "InteractiveInstall" entry in the INF's
    // [ControlFlags] section.  The format of one of these lines is:
    //
    //     InteractiveInstall = <ID1> [, <ID2>... ]
    //
    // and there may be any number of these lines.
    //

    //
    // First, retrieve the driver info detail data (this contains the hardware
    // ID and any compatible IDs specified by this INF driver entry).
    //
    b = fpGetDriverInfoDetail(DeviceInfoSet,
                              &DeviceInfoData,
                              &DriverInfoData,
                              NULL,
                              0,
                              &DriverInfoDetailDataSize
                             );
    Err = GetLastError();

    //
    // The above call to get driver info detail data should never succeed
    // because the buffer will alwyas be too small (we're just interested in
    // sizing the buffer at this point).
    //
    ASSERT(!b && (Err == ERROR_INSUFFICIENT_BUFFER));

    if(b || (Err != ERROR_INSUFFICIENT_BUFFER)) {
        Err = ERROR_INVALID_DATA;
        goto clean0;
    }

    //
    // Now that we know how big of a buffer we need to hold the driver info
    // details, allocate the buffer and retrieve the information.
    //
    pDriverInfoDetailData = HeapAlloc(ghPnPHeap, 0, DriverInfoDetailDataSize);

    if(!pDriverInfoDetailData) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!fpGetDriverInfoDetail(DeviceInfoSet,
                              &DeviceInfoData,
                              &DriverInfoData,
                              pDriverInfoDetailData,
                              DriverInfoDetailDataSize,
                              NULL)) {
        Err = GetLastError();
        ASSERT(FALSE);          // we should never fail this call.
        goto clean0;
    }

    //
    // OK, we have all the hardware and compatible IDs for this driver node.
    // Now we need to open up the INF and see if any of them are referenced in
    // an "InteractiveInstall" control flag entry.
    //
    hInf = fpOpenInfFile(pDriverInfoDetailData->InfFileName,
                         NULL,
                         INF_STYLE_WIN4,
                         NULL
                        );
    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason, we couldn't open the INF!
        //
        goto clean1;
    }

    b = FALSE;

    //
    // Look at each InteractiveInstall line in the INF's [ControlFlags]
    // section...
    //
    if(fpFindFirstLine(hInf, pszControlFlags, pszInteractiveInstall, &InfContext)) {

        do {
            //
            // and within each line, examine each value...
            //
            for(i = 1;
                fpGetStringField(&InfContext, i, szBuffer, sizeof(szBuffer) / sizeof(WCHAR), NULL);
                i++) {

                //
                // Check to see if this ID matches up with one of the driver
                // node's hardware or compatible IDs.
                //
                for(p = pDriverInfoDetailData->HardwareID; *p; p += (lstrlen(p) + 1)) {

                    if (CompareString(
                            LOCALE_INVARIANT, NORM_IGNORECASE,
                            p, -1,
                            szBuffer, -1) == CSTR_EQUAL) {
                        //
                        // We found a match!  We must defer the installation to
                        // the client-side.
                        //
                        b = TRUE;
                        goto InteractiveInstallSearchDone;
                    }
                }
            }

        } while(fpFindNextMatchLine(&InfContext, pszInteractiveInstall, &InfContext));
    }

InteractiveInstallSearchDone:

    //
    // We're done with the INF--close it.
    //
    fpCloseInfFile(hInf);

    if(b) {
        Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
        goto clean0;
    }

    //
    // Check to see if it's OK to install this driver.
    //
    if(!fpCallClassInstaller(DIF_ALLOW_INSTALL, DeviceInfoSet, &DeviceInfoData) &&
       ((Err = GetLastError()) != ERROR_DI_DO_DEFAULT)) {

        goto clean0;
    }

    //
    // Tell our client-side UI (if any) it's time to update the device's
    // description and class icon.
    //
    if (pDeviceInstallClient) {
        //
        // Retrieve the device description from the driver node we're about to
        // install.  We don't want to write this out as the devnode's DeviceDesc
        // property, because some class installers have dependencies upon being
        // able to retrieve the unaltered description as reported by the
        // enumerator.  So instead, we write this out as the REG_SZ
        // NewDeviceDesc value entry to the devnode's hardware key.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        b = fpGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData);
        ASSERT(b);  // the above call shouldn't fail

        if(b) {
            //
            // Make sure that the hardware key is created (with the right
            // security).
            //
            PNP_CreateKey(NULL,
                          pszDeviceId,
                          KEY_READ,
                          0
                         );

            //
            // Now, open the Device Parameters subkey so we can write out the
            // device's new description.
            //
            if (SUCCEEDED(StringCchPrintf(
                              szBuffer,
                              SIZECHARS(szBuffer),
                              L"%s\\%s",
                              pszDeviceId,
                              pszRegKeyDeviceParam))) {

                if(ERROR_SUCCESS == RegOpenKeyEx(ghEnumKey,
                                                 szBuffer,
                                                 0,
                                                 KEY_READ | KEY_WRITE,
                                                 &hKey)) {

                    if(ERROR_SUCCESS == RegSetValueEx(
                           hKey,
                           pszRegValueNewDeviceDesc,
                           0,
                           REG_SZ,
                           (LPBYTE)(DriverInfoData.Description),
                           (lstrlen(DriverInfoData.Description) + 1) * sizeof(WCHAR))) {

                        RemoveNewDevDescValue = TRUE;
                    }

                    RegCloseKey(hKey);
                    hKey = NULL;
                }
            }
        }

        //
        // Wait for the device install to be signaled from newdev.dll to let us
        // know that it has completed displaying the UI request.
        //
        // Wait on the client's process as well, to catch the case
        // where the process crashes (or goes away) without signaling the
        // device install event.
        //
        // Also wait on the disconnect event in case we have explicitly
        // disconnected from the client while switching sessions.
        //
        // We don't want to wait forever in case NEWDEV.DLL hangs for some
        // reason.  So we will give it 5 seconds to complete the UI only
        // install and then continue on without it.
        //
        // Note that the client is still referenced for our use, and should be
        // dereferenced when we're done with it.
        //
        hFinishEvents[0] = pDeviceInstallClient->hProcess;
        hFinishEvents[1] = pDeviceInstallClient->hEvent;
        hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

        dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, 5000);

        if (dwWait == WAIT_OBJECT_0) {
            //
            // If the return is WAIT_OBJECT_0 then the newdev.dll process has
            // gone away.  Close the device install client and clean up all of
            // the associated handles.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: process signalled, closing device install client!\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
            //
            // If the return is WAIT_OBJECT_0 + 1 then the device installer
            // successfully received the request.  This is the only case where
            // we don't want to close the client, since we may want to reuse it
            // later.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client succeeded\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
            //
            // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
            // disconnected from the device install client.  For server-side
            // installation, we don't need to keep the client UI around on the
            // disconnected session, so we should close it here also.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client disconnected\n"));

        } else if (dwWait == WAIT_TIMEOUT) {
            //
            // Timed out while waiting for the device install client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: InstallDeviceServerSide: timed out waiting for device install client!\n"));

        } else {
            //
            // The wait was satisfied for some reason other than the
            // specified objects.  This should never happen, but just in
            // case, we'll close the client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: InstallDeviceServerSide: wait completed unexpectedly!\n"));
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (dwWait != (WAIT_OBJECT_0 + 1)) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
            ulSessionId = INVALID_SESSION;
        }
        pDeviceInstallClient = NULL;

        UnlockNotifyList(&InstallClientList.Lock);
    }

    //
    // If we're doing client side UI for this device, attempt to refresh the UI again.
    //
    if (bDoClientUI) {
        //
        // When we attempt to refresh the client-side UI, if we display the
        // refreshed UI on a different session than the one we had previously,
        // close the previous device install client.
        //
        ULONG ulPrevSessionId = ulSessionId;

        //
        // If we're not going to determine the session to use for UI, use the
        // SessionId supplied by the caller.
        //
        if ((Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0) {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        DoDeviceInstallClient(pszDeviceId,
                              &ulSessionId,
                              Flags | DEVICE_INSTALL_UI_ONLY,
                              &pDeviceInstallClient);

        if ((ulPrevSessionId != INVALID_SESSION) &&
            (ulPrevSessionId != ulSessionId)) {
            PINSTALL_CLIENT_ENTRY pPrevDeviceInstallClient;
            LockNotifyList(&InstallClientList.Lock);
            pPrevDeviceInstallClient = LocateDeviceInstallClient(ulPrevSessionId);
            if (pPrevDeviceInstallClient) {
                ASSERT(pPrevDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pPrevDeviceInstallClient);
            }
            UnlockNotifyList(&InstallClientList.Lock);
        }
    }

    //
    // OK, everything looks good for installing this driver.  Check to see if
    // this INF's class is already installed--if not, then we need to install
    // it before proceeding.
    //
    if(RPC_S_OK != UuidToString(&(DeviceInfoData.ClassGuid), &pszClassGuid)) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    hr = StringCchPrintf(szBuffer,
                         SIZECHARS(szBuffer),
                         L"{%s}",
                         pszClassGuid);

    RpcStringFree(&pszClassGuid);

    if (FAILED(hr)) {
        Err =  HRESULT_CODE(hr);
        goto clean0;
    }

    if(RegOpenKeyEx(ghClassKey,
                    szBuffer,
                    0,
                    KEY_READ,
                    &hKey) != ERROR_SUCCESS) {

        if(!fpInstallClass(NULL,
                           pDriverInfoDetailData->InfFileName,
                           0,
                           NULL)) {

            goto clean1;
        }

    } else {
        //
        // The class key already exists--assume that the class has previously
        // been installed.
        //
        RegCloseKey(hKey);
    }

    //
    // Now we're ready to install the device.  First, install the files.
    //
    if(!fpCallClassInstaller(DIF_INSTALLDEVICEFILES, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    //
    // Set a flag in the device install parameters so that we don't try to
    // re-copy the files during subsequent DIF operations.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    b = fpGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    DeviceInstallParams.Flags |= DI_NOFILECOPY;

    b = fpSetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    //
    // Now finish up the installation.
    //
    if(!fpCallClassInstaller(DIF_REGISTER_COINSTALLERS, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    if(!fpCallClassInstaller(DIF_INSTALLINTERFACES, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    if(!fpCallClassInstaller(DIF_INSTALLDEVICE, DeviceInfoSet, &DeviceInfoData)) {

        ULONG ulConfig;

        //
        // Before we do anything to blow away last error, retrieve it.
        //
        Err = GetLastError();

        //
        // It's possible that the installation got far enough to have cleared
        // any problems on the device (i.e., SetupDiInstallDevice succeeded,
        // but the class installer or co-installer subsequently failed during
        // some post-processing).
        //
        // We want to make sure that the devnode is marked as needing re-install
        // because we might lose the client-side install request (e.g., the
        // user reboots without logging in).
        //
        ulConfig = GetDeviceConfigFlags(pszDeviceId, NULL);

        ulConfig |= CONFIGFLAG_REINSTALL;

        PNP_SetDeviceRegProp(NULL,
                             pszDeviceId,
                             CM_DRP_CONFIGFLAGS,
                             REG_DWORD,
                             (LPBYTE)&ulConfig,
                             sizeof(ulConfig),
                             0
                            );

        goto clean0;
    }

    //
    // We're not quite out of the woods yet.  We need to check if the class-/
    // co-installers want to display finish-install wizard pages.  If so, then
    // we need to set the CONFIGFLAG_REINSTALL flag for this devnode and report
    // failure so that we'll re-attempt the install as a client-side
    // installation (where a wizard can actually be displayed).
    //
    ZeroMemory(&NewDevWizData, sizeof(NewDevWizData));

    NewDevWizData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    NewDevWizData.ClassInstallHeader.InstallFunction = DIF_NEWDEVICEWIZARD_FINISHINSTALL;

    b = fpSetClassInstallParams(DeviceInfoSet,
                                &DeviceInfoData,
                                (PSP_CLASSINSTALL_HEADER)&NewDevWizData,
                                sizeof(NewDevWizData)
                               );
    ASSERT(b);  // the above call shouldn't fail

    if(b) {
        b = fpCallClassInstaller(DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                 DeviceInfoSet,
                                 &DeviceInfoData
                                );

        if(b || (ERROR_DI_DO_DEFAULT == GetLastError())) {
            //
            // Retrieve the install params
            //
            b = (fpGetClassInstallParams(DeviceInfoSet,
                                         &DeviceInfoData,
                                         (PSP_CLASSINSTALL_HEADER)&NewDevWizData,
                                         sizeof(NewDevWizData),
                                         NULL)
                 && (NewDevWizData.ClassInstallHeader.InstallFunction == DIF_NEWDEVICEWIZARD_FINISHINSTALL)
                );

            if(b) {
                //
                // Are there any pages?
                //
                if(!NewDevWizData.NumDynamicPages) {
                    b = FALSE;
                } else {
                    //
                    // b is already TRUE if we made it here so no need to set
                    //
                    HMODULE hComCtl32;
                    FP_DESTROYPROPERTYSHEETPAGE fpDestroyPropertySheetPage;

                    //
                    // We don't want to link to comctl32, nor do we want to
                    // always explicitly load it every time we load the device
                    // installer.  (The number of devices that request finish-
                    // install pages should be small.)  Thus, we load it on-
                    // demand right here, retrieve the entrypoint to the
                    // DestroyPropertySheetPage routine, and then unload the
                    // DLL once we've destroyed all the property pages.
                    //
                    // NOTE: (lonnym): If we can't load comctl32 or get the
                    // entrypont for DestroyPropertySheetPage, then we'll leak
                    // these wizard pages!
                    //
                    hComCtl32 = LoadLibrary(TEXT("comctl32.dll"));

                    if(hComCtl32) {

                        fpDestroyPropertySheetPage = (FP_DESTROYPROPERTYSHEETPAGE)GetProcAddress(
                                                         hComCtl32,
                                                         "DestroyPropertySheetPage"
                                                        );

                        if(fpDestroyPropertySheetPage) {

                            for(i = 0; i < NewDevWizData.NumDynamicPages; i++) {
                                fpDestroyPropertySheetPage(NewDevWizData.DynamicPages[i]);
                            }
                        }

                        FreeLibrary(hComCtl32);
                    }
                }
            }
        }
    }

    if(b) {

        ULONG ulConfig;
        CONFIGRET cr;

        //
        // One or more finish-install wizard pages were provided--we must defer
        // this installation to the client-side.
        //
        ulConfig = GetDeviceConfigFlags(pszDeviceId, NULL);

        ulConfig |= CONFIGFLAG_REINSTALL;

        cr = PNP_SetDeviceRegProp(NULL,
                                  pszDeviceId,
                                  CM_DRP_CONFIGFLAGS,
                                  REG_DWORD,
                                  (LPBYTE)&ulConfig,
                                  sizeof(ulConfig),
                                  0
                                 );
        ASSERT(cr == CR_SUCCESS);

        Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
        goto clean0;
    }

    //
    // The installation was a success!  Check to see if a reboot is needed.
    //
    b = fpGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(b) {
        if(DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            *RebootRequired = TRUE;
        }
    }

    //
    // Process any RunOnce (RunDll32) entries that may have been queued up
    // during this installation.
    //
    DoRunOnce();

    //
    // Check to see if the device has a problem.
    //
    if ((GetDeviceStatus(pszDeviceId, &ulStatus, &ulProblem) != CR_SUCCESS) ||
        (ulStatus & DN_HAS_PROBLEM)) {
        *DeviceHasProblem = TRUE;
    } else {
        *DeviceHasProblem = FALSE;
    }

    Err = NO_ERROR;
    goto clean0;

clean1:
    //
    // Failures where error is in GetLastError() can come here.
    //
    Err = GetLastError();

clean0:
    fpDestroyDeviceInfoList(DeviceInfoSet);

    if(pDriverInfoDetailData) {
        HeapFree(ghPnPHeap, 0, pDriverInfoDetailData);
    }

    //
    // Clear out our list of RunOnce work items (note that the list will
    // already be empty if the device install succeeded and we called
    // DoRunOnce() above).
    //
    fpDestroyRunOnceNodeList();

    //
    // If we stored out a NewDeviceDesc value to the devnode's hardware key
    // above, go and remove that turd now.
    //
    if(RemoveNewDevDescValue) {
        //
        // Open the Device Parameters subkey so we can delete the value.
        //
        if (SUCCEEDED(StringCchPrintf(
                          szBuffer,
                          SIZECHARS(szBuffer),
                          L"%s\\%s",
                          pszDeviceId,
                          pszRegKeyDeviceParam))) {

            if (RegOpenKeyEx(ghEnumKey,
                             szBuffer,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hKey) == ERROR_SUCCESS) {

                RegDeleteValue(hKey, pszRegValueNewDeviceDesc);
                RegCloseKey(hKey);
            }
        }
    }

    if (pDeviceInstallClient) {
        //
        // Wait for the device install to be signaled from newdev.dll to let us
        // know that it has completed displaying the UI request.
        //
        // Wait on the client's process as well, to catch the case
        // where the process crashes (or goes away) without signaling the
        // device install event.
        //
        // Also wait on the disconnect event in case we have explicitly
        // disconnected from the client while switching sessions.
        //
        // We don't want to wait forever in case NEWDEV.DLL hangs for some
        // reason.  So we will give it 5 seconds to complete the UI only
        // install and then continue on without it.
        //
        // Note that the client is still referenced for our use, and should be
        // dereferenced when we're done with it.
        //
        hFinishEvents[0] = pDeviceInstallClient->hProcess;
        hFinishEvents[1] = pDeviceInstallClient->hEvent;
        hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

        dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, 5000);

        if (dwWait == WAIT_OBJECT_0) {
            //
            // If the return is WAIT_OBJECT_0 then the newdev.dll process has
            // gone away.  Close the device install client and clean up all of
            // the associated handles.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: "
                       "process signalled, closing device install client!\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
            //
            // If the return is WAIT_OBJECT_0 + 1 then the device installer
            // successfully received the request.  This is the only case where
            // we don't want to close the client, since we may want to reuse it
            // later.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: "
                       "device install client succeeded\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
            //
            // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
            // disconnected from the device install client.  For server-side
            // installation, we don't need to keep the client UI around on the
            // disconnected session, so we should close it here also.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: "
                       "device install client disconnected\n"));

        } else if (dwWait == WAIT_TIMEOUT) {
            //
            // Timed out while waiting for the device install client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: InstallDeviceServerSide: "
                       "timed out waiting for device install client!\n"));

        } else {
            //
            // The wait was satisfied for some reason other than the
            // specified objects.  This should never happen, but just in
            // case, we'll close the client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: InstallDeviceServerSide: "
                       "wait completed unexpectedly!\n"));
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (dwWait != (WAIT_OBJECT_0 + 1)) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
            ulSessionId = INVALID_SESSION;
        }
        pDeviceInstallClient = NULL;

        UnlockNotifyList(&InstallClientList.Lock);
    }

    if (bDoClientUI) {
        //
        // Note that if client-side UI was created during the server-side device
        // install, it will still exist when we are done.  The caller should
        // dereference it when it is done installing all devices to make it go
        // away.
        //
        *SessionId = ulSessionId;
    } else {
        //
        // There was never any client-side UI for this device install.
        //
        *SessionId = INVALID_SESSION;
    }

    return Err;

} // InstallDeviceServerSide



BOOL
PromptUser(
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine will notify the logged-on user (if any) with a specified
    message.

Arguments:

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the id of the session in which the reboot dialog
        process was launched.  Otherwise, will contain an invalid session id,
        INVALID_SESSION, (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the reboot dialog
        displayed by the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_FINISHED_REBOOT - if specified, the user should be
           prompted to reboot.

        DEVICE_INSTALL_BATCH_COMPLETE - if specified, the user should be
           prompted that the plug and play manager is finished installing a
           batch of devices.

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.

Return Value:

    If the user is successfully notified, the return value is TRUE.

    If we couldn't ask the user (i.e., no user was logged in), the return
    value is FALSE.

Notes:

    If the user was prompted for a reboot, this doesn't necessarily mean that a
    reboot is in progress.

--*/
{
    BOOL bStatus = FALSE;
    ULONG ulValue, ulSize, ulSessionId = INVALID_SESSION;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    DWORD dwWait;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;

    try {
        //
        // Check if we should skip client side UI.
        //
        if (gbSuppressUI) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: PromptUser: Client-side UI has been suppressed, exiting.\n"));
            LogWarningEvent(WRN_REBOOT_UI_SUPPRESSED, 0, NULL);
            *SessionId = INVALID_SESSION;
            return FALSE;
        }

        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        ASSERT(ulSessionId != INVALID_SESSION);

        //
        // If the specified session is not currently connected anywhere, don't
        // bother creating any UI.
        //
        if (!IsSessionConnected(ulSessionId)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: PromptUser: SessionId %d not connected, exiting\n",
                       ulSessionId));
            return FALSE;
        }

        //
        // If a device install client is already running on this session,
        // connect to it.  Otherwise, create a new one.
        //
        LockNotifyList(&InstallClientList.Lock);

        //
        // First, try to connect to an existing client already running on this
        // session.
        //
        bStatus = ConnectDeviceInstallClient(ulSessionId,
                                             &pDeviceInstallClient);

        if (bStatus) {
            if ((Flags & DEVICE_INSTALL_BATCH_COMPLETE) &&
                (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_BATCH_COMPLETE)) {
                //
                // If there is an existing client, and we're sending it the
                // "we're done" message, and the last thing this client did was
                // display that message, don't bother sending it again.
                //
                pDeviceInstallClient = NULL;
                bStatus = FALSE;
            }
        } else if (!(Flags & DEVICE_INSTALL_BATCH_COMPLETE)) {
            //
            // If there isn't an existing client for this session, and we're not
            // launching one just to say "we're done", then go ahead and create
            // a new device install client for this session.
            //
            bStatus = CreateDeviceInstallClient(ulSessionId,
                                                &pDeviceInstallClient);
        }

        if (bStatus) {
            //
            // Whether we are using an existing client, or created a
            // new one, the client should only have the initial
            // reference from when it was added to the list, since any
            // use of the client is done on this single install
            // thread.
            //
            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->RefCount == 1);

            //
            // Reference the device install client while it is in use.
            // We'll remove this reference when we're done with it.
            //
            ReferenceDeviceInstallClient(pDeviceInstallClient);
        }

        UnlockNotifyList(&InstallClientList.Lock);

        if (!bStatus) {
            *SessionId = INVALID_SESSION;
            return FALSE;
        }

        ASSERT(pDeviceInstallClient);

        //
        // Don't send newdev the display on console flag, if it was specified.
        //
        ulValue = Flags & ~DEVICE_INSTALL_DISPLAY_ON_CONSOLE;

        //
        // Send newdev.dll the specified signal.
        //
        if (WriteFile(pDeviceInstallClient->hPipe,
                      &ulValue,
                      sizeof(ulValue),
                      &ulSize,
                      NULL
                      )) {

            //
            // newdev.dll expects two DWORDs to be sent over the pipe each time.  The second
            // DWORD should just be set to 0 in this case.
            //
            ulValue = 0;
            if (WriteFile(pDeviceInstallClient->hPipe,
                          &ulValue,
                          sizeof(ulValue),
                          &ulSize,
                          NULL
                          )) {
                bStatus = TRUE;
            } else {
                bStatus = FALSE;
                LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            }

        } else {
            bStatus = FALSE;
            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
        }

        if (bStatus) {

            bStatus = FALSE;

            //
            // Wait for the event to be signaled from newdev.dll
            // to let us know that it has received the information.
            //
            // Wait on the process as well, to catch the case where the process
            // crashes (or goes away) without signaling the event.
            //
            // Also wait on the disconnect event in case we have just
            // disconnected from the device install client, in which case the
            // event and process handles are no longer valid.
            //
            hFinishEvents[0] = pDeviceInstallClient->hProcess;
            hFinishEvents[1] = pDeviceInstallClient->hEvent;
            hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

            dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, INFINITE);

            if (dwWait == WAIT_OBJECT_0) {
                //
                // If the return is WAIT_OBJECT_0 then the newdev.dll
                // process has gone away.  Consider the request unsuccessful
                // so that we will retry again at a later time.  Orphan the
                // device install client and clean up all of the associated
                // handles.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: process signalled, orphaning device install client!\n"));

            } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
                //
                // If the return is WAIT_OBJECT_0 + 1 then the request was
                // received successfully.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: device install client succeeded\n"));

                //
                // Remember the last request serviced by this client.
                //
                pDeviceInstallClient->ulInstallFlags = Flags;

                bStatus = TRUE;

            } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
                //
                // If the return is WAIT_OBJECT_0 + 2 then the device
                // install client was explicitly disconnected before
                // the request was received.  Consider the request
                // unsuccessful so that we will retry again at a later
                // time.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: device install client orphaned!\n"));
            }
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (!bStatus) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
        }
        UnlockNotifyList(&InstallClientList.Lock);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during PromptUser!\n"));
        ASSERT(0);
        bStatus = FALSE;
    }

    if (!bStatus) {
        *SessionId = INVALID_SESSION;
    } else {
        *SessionId = ulSessionId;
    }

    return bStatus;

} // PromptUser



BOOL
CreateDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    This routine kicks off a newdev.dll process (if someone is logged in).
    We use a named pipe to comunicate with the user mode process
    and have it either display UI for a server side install, or do the install
    itself on the client side.

Arguments:

    SessionId           - Session for which a device install client should be
                          created or connected to.

    DeviceInstallClient - Receives a pointer to receive a pointer to the
                          device install client for this session.

Return Value:

    Returns TRUE if a device install client was created, or if an existing
    device install client was found for the specified session.  This routine
    doesn't wait until the process terminates.  Returns FALSE if a device
    install client could not be created.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR szCmdLine[MAX_PATH];
    WCHAR szDeviceInstallPipeName[MAX_PATH];
    WCHAR szDeviceInstallEventName[MAX_PATH];
    ULONG ulDeviceInstallEventNameSize;
    HANDLE hFinishEvents[2] = { NULL, NULL };
    HANDLE hTemp, hUserToken = NULL;
    PINSTALL_CLIENT_ENTRY entry;
    RPC_STATUS rpcStatus = RPC_S_OK;
    GUID  newGuid;
    WCHAR szGuidString[MAX_GUID_STRING_LEN];
    HANDLE hDeviceInstallPipe = NULL, hDeviceInstallEvent = NULL;
    HANDLE hDeviceInstallDisconnectEvent = NULL;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;
    ULONG ulSize;
    WIN32_FIND_DATA findData;
    BOOL bStatus;
    PVOID lpEnvironment = NULL;
    OVERLAPPED overlapped = {0,0,0,0,0};
    DWORD dwError, dwWait, dwBytes;
    HRESULT hr;
    size_t Len = 0;


    //
    // Validate output parameter.
    //
    ASSERT(DeviceInstallClient);
    if (!DeviceInstallClient) {
        return FALSE;
    }

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: CreateDeviceInstallClient: Invalid Console SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Initialize process, startup and overlapped structures, since we
    // depend on them being NULL during cleanup here on out.
    //
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    ZeroMemory(&overlapped,  sizeof(overlapped));

    //
    // Assume failure
    //
    bStatus = FALSE;

    try {
        //
        // Before doing anything, check that newdev.dll is actually present on
        // the system.
        //
        szCmdLine[0] = L'\0';
        ulSize = GetSystemDirectory(szCmdLine, MAX_PATH);
        if ((ulSize == 0) || ((ulSize + 2 + ARRAY_SIZE(NEWDEV_DLL)) > MAX_PATH)) {
            return FALSE;
        }

        hr = StringCchCat(szCmdLine,
                          SIZECHARS(szCmdLine),
                          L"\\");

        if (SUCCEEDED(hr)) {
            hr = StringCchCat(szCmdLine,
                              SIZECHARS(szCmdLine),
                              NEWDEV_DLL);
        }

        if (FAILED(hr)) {
            return FALSE;
        }

        hTemp = FindFirstFile(szCmdLine, &findData);
        if(hTemp != INVALID_HANDLE_VALUE) {
            FindClose(hTemp);
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: %ws not found, error = %d, exiting\n",
                       szCmdLine,
                       GetLastError()));
            LogWarningEvent(WRN_NEWDEV_NOT_PRESENT, 1, szCmdLine);
            return FALSE;
        }

        //
        // Get the user access token for the active console session user.
        //
        if (!GetSessionUserToken(SessionId, &hUserToken) || (hUserToken == NULL)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: CreateDeviceInstallClient: Unable to get user token for Session %d,\n"
                       "          postponing client-side installation, error = %d\n",
                       SessionId,
                       GetLastError()));
            return FALSE;
        }

        //
        // If the user Winstation for this session is locked, and Fast User
        // Switching is enabled, then we're at the welcome screen.  Don't create
        // a device install client, because we don't want to hang the install
        // thread if nobody's actually around to do anything about it.  If the
        // session is locked, but FUS is not disabled, maintain previous
        // behavior, and launch the device install client.  The user will have
        // to unlock or logoff before another user can logon anyways.
        //
        if (IsSessionLocked(SessionId) && IsFastUserSwitchingEnabled()) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: CreateDeviceInstallClient: Session %d locked with FUS enabled,\n"
                       "          postponing client-side installation.\n",
                       SessionId));
            CloseHandle(hUserToken);
            return FALSE;
        }

        //
        // Create a named pipe and event for communication and synchronization
        // with the client-side device installer.  The event and named pipe must
        // be global so that UMPNPMGR can interact with a device install client
        // in a different session, but it must still be unique for that session.
        // Add a generated GUID so the names are not entirely well-known.
        //
        rpcStatus = UuidCreate(&newGuid);

        if ((rpcStatus != RPC_S_OK) &&
            (rpcStatus != RPC_S_UUID_LOCAL_ONLY)) {
            goto Clean0;
        }

        if (StringFromGuid((LPGUID)&newGuid,
                           szGuidString,
                           MAX_GUID_STRING_LEN) != NO_ERROR) {
            goto Clean0;
        }

        if (FAILED(StringCchPrintf(
                       szDeviceInstallPipeName,
                       SIZECHARS(szDeviceInstallPipeName),
                       L"%ws_%d.%ws",
                       PNP_DEVICE_INSTALL_PIPE,
                       SessionId,
                       szGuidString))) {
            goto Clean0;
        }

        if (FAILED(StringCchPrintf(
                       szDeviceInstallEventName,
                       SIZECHARS(szDeviceInstallEventName),
                       L"Global\\%ws_%d.%ws",
                       PNP_DEVICE_INSTALL_EVENT,
                       SessionId,
                       szGuidString))) {
            goto Clean0;
        }

        if (FAILED(StringCchLength(
                       szDeviceInstallEventName,
                       SIZECHARS(szDeviceInstallEventName),
                       &Len))) {
            goto Clean0;
        }

        ulDeviceInstallEventNameSize = (ULONG)((Len + 1) * sizeof(WCHAR));

        //
        // The approximate size of the named pipe output buffer should be large
        // enough to hold the greater of either:
        // - The name and size of the named event string, OR
        // - The install flags, name and device instance id size for at least
        //   one device install.
        //
        ulSize = max(sizeof(ulDeviceInstallEventNameSize) +
                     ulDeviceInstallEventNameSize,
                     2 * sizeof(ULONG) +
                     (MAX_DEVICE_ID_LEN * sizeof(WCHAR)));

        //
        // Open up a named pipe to communicate with the newdev user-client.
        //
        if (CreateUserReadNamedPipe(
                hUserToken,
                szDeviceInstallPipeName,
                ulSize,
                &hDeviceInstallPipe) != NO_ERROR) {
            ASSERT(hDeviceInstallPipe == NULL);
            goto Clean0;
        }

        //
        // Create an event that a user-client can synchronize with and set, and
        // that we will block on after we send a device install to newdev.dll.
        //
        if (CreateUserSynchEvent(
                hUserToken,
                szDeviceInstallEventName,
                &hDeviceInstallEvent) != NO_ERROR) {
            ASSERT(hDeviceInstallEvent == NULL);
            goto Clean0;
        }

        //
        // Create an event that we can use internally such that waiters can know
        // when to disconnect from the device install client.
        //
        hDeviceInstallDisconnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!hDeviceInstallDisconnectEvent) {
            goto Clean0;
        }

        //
        // Launch newdev.dll using rundll32.exe, passing it the pipe name.
        // "rundll32.exe newdev.dll,ClientSideInstall <device-install-pipe-name>"
        //
        if (FAILED(StringCchPrintf(
                       szCmdLine,
                       SIZECHARS(szCmdLine),
                       L"%ws %ws,%ws %ws",
                       RUNDLL32_EXE,
                       NEWDEV_DLL,
                       L"ClientSideInstall",
                       szDeviceInstallPipeName))) {
            goto Clean0;
        }

#if DBG
        //
        // Retrieve debugger settings from the service key.
        //
        {
            HKEY hKey;

            if (RegOpenKeyEx(ghServicesKey,
                             pszRegKeyPlugPlayServiceParams,
                             0,
                             KEY_READ,
                             &hKey) == ERROR_SUCCESS) {

                ULONG ulValue = 0;
                WCHAR szDebugCmdLine[MAX_PATH];

                ulSize = sizeof(ulValue);

                if ((RegQueryValueEx(hKey,
                                     pszRegValueDebugInstall,
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize) == ERROR_SUCCESS) &&(ulValue == 1)) {

                    ulSize = sizeof(szDebugCmdLine);

                    if (RegQueryValueEx(hKey,
                                        pszRegValueDebugInstallCommand,
                                        NULL,
                                        NULL,
                                        (LPBYTE)szDebugCmdLine,
                                        &ulSize) != ERROR_SUCCESS) {
                        //
                        // If no debugger was retrieved, use the default
                        // debugger (ntsd.exe).
                        //
                        if (FAILED(StringCchCopyEx(
                                       szDebugCmdLine,
                                       SIZECHARS(szDebugCmdLine),
                                       NTSD_EXE,
                                       NULL, NULL,
                                       STRSAFE_NULL_ON_FAILURE))) {
                            //
                            // No debugger will be used.
                            //
                            NOTHING;
                        }
                    }

                    if ((SUCCEEDED(StringCchCatEx(
                                       szDebugCmdLine,
                                       SIZECHARS(szDebugCmdLine),
                                       L" ",
                                       NULL, NULL,
                                       STRSAFE_NULL_ON_FAILURE |
                                       STRSAFE_IGNORE_NULLS))) &&
                        (SUCCEEDED(StringCchCatEx(
                                       szDebugCmdLine,
                                       SIZECHARS(szDebugCmdLine),
                                       szCmdLine,
                                       NULL, NULL,
                                       STRSAFE_NULL_ON_FAILURE |
                                       STRSAFE_IGNORE_NULLS)))) {

                        //
                        // Only overwrite the original command line buffer with
                        // a debug command line info if we were successful in
                        // builing a debug command line.
                        //
                        if (FAILED(StringCchCopyEx(
                                       szCmdLine,
                                       SIZECHARS(szCmdLine),
                                       szDebugCmdLine,
                                       NULL, NULL,
                                       STRSAFE_IGNORE_NULLS))) {
                            //
                            // Nothing more we can do here.
                            //
                            NOTHING;
                        }
                    }
                }
                RegCloseKey(hKey);
            }
        }
#endif // DBG

        //
        // Attempt to create the user's environment block.  If for some reason we
        // can't, we'll just have to create the process without it.
        //
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hUserToken,
                                    FALSE)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: "
                       "Failed to allocate environment block, error = %d!\n",
                       GetLastError()));
            lpEnvironment = NULL;
        }

        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.lpDesktop = DEFAULT_INTERACTIVE_DESKTOP; // WinSta0\Default

        //
        // CreateProcessAsUser will create the process in the session
        // specified by the by user-token.
        //
        if (!CreateProcessAsUser(hUserToken,        // hToken
                                 NULL,              // lpApplicationName
                                 szCmdLine,         // lpCommandLine
                                 NULL,              // lpProcessAttributes
                                 NULL,              // lpThreadAttributes
                                 FALSE,             // bInheritHandles
                                 CREATE_UNICODE_ENVIRONMENT |
                                 DETACHED_PROCESS,  // dwCreationFlags
                                 lpEnvironment,     // lpEnvironment
                                 NULL,              // lpDirectory
                                 &StartupInfo,      // lpStartupInfo
                                 &ProcessInfo       // lpProcessInfo
                                 )) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: "
                       "Create rundll32 process failed, error = %d\n",
                       GetLastError()));
            goto Clean0;
        }

        ASSERT(ProcessInfo.hProcess);
        ASSERT(ProcessInfo.hThread);

        //
        // Create an event for use with overlapped I/O - no security, manual
        // reset, not signalled, no name.
        //
        overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (overlapped.hEvent == NULL) {
            goto Clean0;
        }

        //
        // Connect to the newly created named pipe.  If newdev is not already
        // connected to the named pipe, then ConnectNamedPipe() will fail with
        // ERROR_IO_PENDING, and we will wait on the overlapped event.  If
        // newdev is already connected, it will fail with ERROR_PIPE_CONNECTED.
        // Note however that neither of these is an error condition.
        //
        if (!ConnectNamedPipe(hDeviceInstallPipe, &overlapped)) {
            //
            // Overlapped ConnectNamedPipe should always return FALSE on
            // success.  Check the last error to see what really happened.
            //
            dwError = GetLastError();

            if (dwError == ERROR_IO_PENDING) {
                //
                // I/O is pending, wait up to one minute for the client to
                // connect, also wait on the process in case it terminates
                // unexpectedly.
                //
                hFinishEvents[0] = overlapped.hEvent;
                hFinishEvents[1] = ProcessInfo.hProcess;

                dwWait = WaitForMultipleObjects(2, hFinishEvents,
                                                FALSE,
                                                PNP_PIPE_TIMEOUT); // 60 seconds

                if (dwWait == WAIT_OBJECT_0) {
                    //
                    // The overlapped I/O operation completed.  Check the status
                    // of the operation.
                    //
                    if (!GetOverlappedResult(hDeviceInstallPipe,
                                             &overlapped,
                                             &dwBytes,
                                             FALSE)) {
                        goto Clean0;
                    }

                } else {
                    //
                    // Either the connection timed out, or the client process
                    // exited.  Cancel pending I/O against the pipe, and quit.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: CreateDeviceInstallClient: "
                               "Connect timed out, or client process exited!\n"));
                    CancelIo(hDeviceInstallPipe);
                    goto Clean0;
                }

            } else if (dwError != ERROR_PIPE_CONNECTED) {
                //
                // If the last error indicates anything other than pending I/O,
                // or that The client is already connected to named pipe, fail.
                //
                goto Clean0;
            }

        } else {
            //
            // ConnectNamedPipe should not return anything but FALSE in
            // overlapped mode.
            //
            goto Clean0;
        }

        //
        // The client is now connected to the named pipe.
        // Close the overlapped event.
        //
        CloseHandle(overlapped.hEvent);
        overlapped.hEvent = NULL;

        //
        // The first data in the device install pipe will be the length of
        // the name of the event that will be used to sync up umpnpmgr.dll
        // and newdev.dll.
        //
        if (!WriteFile(hDeviceInstallPipe,
                       &ulDeviceInstallEventNameSize,
                       sizeof(ulDeviceInstallEventNameSize),
                       &ulSize,
                       NULL)) {

            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            goto Clean0;
        }

        //
        // The next data in the device install pipe will be the name of the
        // event that will be used to sync up umpnpmgr.dll and newdev.dll.
        //
        if (!WriteFile(hDeviceInstallPipe,
                       (LPCVOID)szDeviceInstallEventName,
                       ulDeviceInstallEventNameSize,
                       &ulSize,
                       NULL)) {

            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            goto Clean0;
        }

        //
        // Allocate a new device install client entry for the list, and save all
        // the handles with it.
        //
        pDeviceInstallClient = HeapAlloc(ghPnPHeap, 0, sizeof(INSTALL_CLIENT_ENTRY));
        if(!pDeviceInstallClient) {
            goto Clean0;
        }

        pDeviceInstallClient->Next = NULL;
        pDeviceInstallClient->RefCount = 1;
        pDeviceInstallClient->ulSessionId = SessionId;
        pDeviceInstallClient->hEvent = hDeviceInstallEvent;
        pDeviceInstallClient->hPipe = hDeviceInstallPipe;
        pDeviceInstallClient->hProcess = ProcessInfo.hProcess;
        pDeviceInstallClient->hDisconnectEvent = hDeviceInstallDisconnectEvent;
        pDeviceInstallClient->ulInstallFlags = 0;
        pDeviceInstallClient->LastDeviceId[0] = L'\0';

        //
        // Insert the newly created device install client info to our list.
        // The caller must have previously acquired the InstallClientList lock.
        //
        entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
        if (!entry) {
            InstallClientList.Next = pDeviceInstallClient;
        } else {
            while ((PINSTALL_CLIENT_ENTRY)entry->Next) {
                entry = (PINSTALL_CLIENT_ENTRY)entry->Next;
            }
            entry->Next = pDeviceInstallClient;
        }

        bStatus = TRUE;

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception during CreateDeviceInstallClient!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        lpEnvironment = lpEnvironment;
        ProcessInfo.hThread = ProcessInfo.hThread;
        ProcessInfo.hProcess = ProcessInfo.hProcess;
        hUserToken = hUserToken;
        hDeviceInstallDisconnectEvent = hDeviceInstallDisconnectEvent;
        hDeviceInstallEvent = hDeviceInstallEvent;
        hDeviceInstallPipe = hDeviceInstallPipe;
    }

    if (lpEnvironment) {
        DestroyEnvironmentBlock(lpEnvironment);
    }

    //
    // Close the handle to the thread since we don't need it.
    //
    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    if (!bStatus) {

        ASSERT(!pDeviceInstallClient);

        if (hDeviceInstallDisconnectEvent) {
            CloseHandle(hDeviceInstallDisconnectEvent);
        }

        if (hDeviceInstallEvent) {
            CloseHandle(hDeviceInstallEvent);
        }

        if (hDeviceInstallPipe) {
            CloseHandle(hDeviceInstallPipe);
        }

        if (ProcessInfo.hProcess) {
            CloseHandle(ProcessInfo.hProcess);
        }

        *DeviceInstallClient = NULL;

    } else {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: CreateDeviceInstallClient: created new client for Session %d.\n",
                   SessionId));

        ASSERT(pDeviceInstallClient);
        ASSERT(pDeviceInstallClient->hEvent);
        ASSERT(pDeviceInstallClient->hPipe);
        ASSERT(pDeviceInstallClient->hProcess);
        ASSERT(pDeviceInstallClient->hDisconnectEvent);

        *DeviceInstallClient = pDeviceInstallClient;
    }

    return bStatus;

} // CreateDeviceInstallClient



BOOL
ConnectDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    Retrieves the device install client handles for the specified session,
    if one exists.

Arguments:

    SessionId           - Session for which a device install client should be
                          created or connected to.

    DeviceInstallClient - Receives a pointer to receive the a pointer to the
                          device install client for this session.

Return Value:

    Returns TRUE if an existing device install client was found for the
    specified session, FALSE otherwise.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    PINSTALL_CLIENT_ENTRY entry;
    BOOL bClientFound = FALSE;

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: ConnectDeviceInstallClient: Invalid SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Validate output parameters.
    //
    ASSERT(DeviceInstallClient);
    if (!DeviceInstallClient) {
        return FALSE;
    }

    entry = LocateDeviceInstallClient(SessionId);

    if (entry) {
        //
        // An existing client was found for this session, so we should already
        // have event, pipe, and process handles for it.
        //
        ASSERT(entry->hEvent);
        ASSERT(entry->hPipe);
        ASSERT(entry->hProcess);

        //
        // Make sure the client's process object is in the nonsignalled state,
        // else newdev has already gone away, and we can't use it.
        //
        if (WaitForSingleObject(entry->hProcess, 0) != WAIT_TIMEOUT) {
            //
            // Remove the initial reference to close the handles and remove it
            // from our list.
            //
            ASSERT(entry->RefCount == 1);
            DereferenceDeviceInstallClient(entry);
        } else {
            //
            // If we are reconnecting to a client that was last used during a
            // previous connection to this session, we will not have a disconnect
            // event for it yet, so create one here.  If we just created this client
            // during the current connection to this session, we will already have a
            // disconnect event for it.
            //
            if (!entry->hDisconnectEvent) {
                entry->hDisconnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            }

            //
            // Either way, make sure we have a disconnect event by now.
            //
            ASSERT(entry->hDisconnectEvent);

            if (entry->hDisconnectEvent) {

                bClientFound = TRUE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: ConnectDeviceInstallClient: found existing client on Session %d.\n",
                           SessionId));
                *DeviceInstallClient = entry;
            }
        }
    }

    if (!bClientFound) {
        *DeviceInstallClient = NULL;
    }

    return bClientFound;

} // ConnectDeviceInstallClient



BOOL
DisconnectDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine disconnects from the current client-side install process (if
    one exists) by signalling the appropriate hDisconnectEvent and closing the
    handle.

Arguments:

    DeviceInstallClient - Receives a pointer to the device install client that
                          should be disconnected.

Return Value:

    Returns TRUE if successful, FALSE otherwise.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    BOOL bStatus = FALSE;

    ASSERT(DeviceInstallClient);

    if (DeviceInstallClient) {
        ASSERT(DeviceInstallClient->hEvent);
        ASSERT(DeviceInstallClient->hPipe);
        ASSERT(DeviceInstallClient->hProcess);

        //
        // We may or may not have a handle to a diconnect event because we may
        // have an existing client for this session, but not reconnected to it.
        //
        // If we do have an hDisconnectEvent, set the event now since we
        // will otherwise block waiting for newdev.dll to set the
        // hDeviceInstallEvent.  Setting the hDisconnectEvent alerts the
        // waiter that the device install was NOT successful, and that it
        // should preserve the device in the install list.
        //
        if (DeviceInstallClient->hDisconnectEvent) {
            SetEvent(DeviceInstallClient->hDisconnectEvent);
            CloseHandle(DeviceInstallClient->hDisconnectEvent);
            DeviceInstallClient->hDisconnectEvent = NULL;
        }

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Disconnected from device install client on Console SessionId %d\n",
                   DeviceInstallClient->ulSessionId));

        bStatus = TRUE;
    }

    return bStatus;

} // DisconnectDeviceInstallClient



PINSTALL_CLIENT_ENTRY
LocateDeviceInstallClient(
    IN  ULONG     SessionId
    )
/*++

Routine Description:

    This routine locates the client-side install process for a given session (if
    one exists).

Arguments:

    SessionId - Session whose device install client should be located.

Return Value:

    Returns a device install client entry if successful, NULL otherwise.

Note:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    PINSTALL_CLIENT_ENTRY entry, foundEntry = NULL;
    BOOL bClientFound = FALSE;

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: LocateDeviceInstallClient: Invalid Console SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Search for a client on the specified session.
    //
    for (entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
         entry != NULL;
         entry = entry->Next) {

        if (entry->ulSessionId == SessionId) {
            //
            // Make sure we only have one entry per session.
            //
            ASSERT(!bClientFound);
            bClientFound = TRUE;
            foundEntry = entry;
        }
    }

    return foundEntry;

} // LocateDeviceInstallClient



VOID
ReferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine increments the reference count for a device install client
    entry.

Parameters:

    DeviceInstallClient - Supplies a pointer to the device install client to be
                          referenced.

Return Value:

    None.

Note:

    The appropriate synchronization lock must be held on the device install
    client list before this routine can be called

--*/
{
    ASSERT(DeviceInstallClient);
    ASSERT(((LONG)DeviceInstallClient->RefCount) > 0);

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_EVENT | DBGF_INSTALL,
               "UMPNPMGR: ---------------- ReferenceDeviceInstallClient  : Session %d [%d --> %d]\n",
               DeviceInstallClient->ulSessionId,
               DeviceInstallClient->RefCount,
               DeviceInstallClient->RefCount + 1));

    DeviceInstallClient->RefCount++;

    return;

} // ReferenceDeviceInstallClient



VOID
DereferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine decrements the reference count for a device install client
    entry, removing the entry from the list and freeing the associated memory if
    there are no outstanding reference counts.

Parameters:

    DeviceInstallClient - Supplies a pointer to the device install client to be
                          dereferenced.

Return Value:

    None.

Note:

    The appropriate synchronization lock must be held on the device install
    client list before this routine can be called

--*/
{
    ASSERT(DeviceInstallClient);
    ASSERT(((LONG)DeviceInstallClient->RefCount) > 0);

    //
    // Avoid over-dereferencing the client.
    //
    if (((LONG)DeviceInstallClient->RefCount) > 0) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT | DBGF_INSTALL,
                   "UMPNPMGR: ---------------- DereferenceDeviceInstallClient: Session %d [%d --> %d]\n",
                   DeviceInstallClient->ulSessionId,
                   DeviceInstallClient->RefCount,
                   DeviceInstallClient->RefCount - 1));

        DeviceInstallClient->RefCount--;

    } else {

        return;
    }

    //
    // If the refcount is zero then the entry no longer needs to be in the list
    // so remove and free it.
    //
    if (DeviceInstallClient->RefCount == 0) {
        BOOL bClientFound = FALSE;
        PINSTALL_CLIENT_ENTRY entry, prev;

        entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
        prev = NULL;

        while (entry) {
            if (entry == DeviceInstallClient) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT | DBGF_INSTALL,
                           "UMPNPMGR: ---------------- DereferenceDeviceInstallClient: Removing client for Session %d\n",
                           entry->ulSessionId));

                //
                // We should have handles to the pipe, event and process objects for
                // the client, because we will close them here.
                //
                ASSERT(entry->hPipe);
                ASSERT(entry->hEvent);
                ASSERT(entry->hProcess);

                //
                // We may or may not have a handle to a diconnect event because we
                // may have an existing client for this session, but not yet
                // connected to it.
                //
                // If we do have an hDisconnectEvent, set the event now since we
                // will otherwise block waiting for newdev.dll to set the
                // hDeviceInstallEvent.  Setting the hDisconnectEvent alerts the
                // waiter that the device install was NOT successful, and that it
                // should preserve the device in the install list.
                //
                if (entry->hDisconnectEvent) {
                    SetEvent(entry->hDisconnectEvent);
                    CloseHandle(entry->hDisconnectEvent);
                }

                //
                // Close the pipe and event handles so that the client will get a
                // ReadFile error and know that we are finished.  Close the process
                // handle as well.
                //
                if (entry->hPipe) {
                    CloseHandle(entry->hPipe);
                }

                if (entry->hEvent) {
                    CloseHandle(entry->hEvent);
                }

                if (entry->hProcess) {
                    CloseHandle(entry->hProcess);
                }

                //
                // Remove the device install client entry from the list, and free it
                // now.
                //
                if (prev) {
                    prev->Next = entry->Next;
                } else {
                    InstallClientList.Next = entry->Next;
                }

                HeapFree(ghPnPHeap, 0, entry);

                if(prev) {
                    entry = (PINSTALL_CLIENT_ENTRY)prev->Next;
                } else {
                    entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
                }

                bClientFound = TRUE;

                break;
            }

            prev = entry;
            entry = (PINSTALL_CLIENT_ENTRY)entry->Next;
        }
        ASSERT(bClientFound);
    }

    return;

} // DereferenceDeviceInstallClient



BOOL
DoDeviceInstallClient(
    IN  LPWSTR    DeviceId,
    IN  PULONG    SessionId,
    IN  ULONG     Flags,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    This routine kicks off a newdev.dll process (if someone is logged in) that
    displays UI informing the user of the status of the server-side device
    installation.

Arguments:

    DeviceId  - Supplies the devnode ID of the device being installed.

    SessionId - Specifies the session that the newdev client is to be launched
                on.  If the DEVICE_INSTALL_DISPLAY_ON_CONSOLE flag is
                specified, the specified SessionId is ignored.

                Upon successful return, the SessionId for the the session where
                the device install client was created is returned.
                If unsuccessful, the returned SessionId is INVALID_SESSION,
                (0xFFFFFFFF).

    Flags     - Specifies flags describing the behavior of the device install client.
                The following flags are currently defined:

                DEVICE_INSTALL_UI_ONLY - tells newdev.dll whether to do a full
                    install or just show UI while umpnpmgr.dll is doing a server
                    side install.

                DEVICE_INSTALL_PLAY_SOUND - tells newdev.dll whether to play a
                    sound.

                DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value
                    specified in SessionId will be ignored, and the client will
                    always be displayed on the current active console session.

    DeviceInstallClient - Supplies the address of a variable to receive, upon
                success, a pointer to a pointer to a device install client.

Return Value:

    If the process was successfully created, the return value is TRUE.  This
    routine doesn't wait until the process terminates.

    If we couldn't create the process (e.g., because no user was logged in),
    the return value is FALSE.

Notes:

    None.

--*/
{
    BOOL  bStatus, bSameDevice = FALSE;
    ULONG DeviceIdSize, ulSize, ulSessionId;
    ULONG InstallFlags;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;

    //
    // Assume failure.
    //
    bStatus = FALSE;

    //
    // Validate output parameters.
    //
    if (!DeviceInstallClient || !SessionId) {
        return FALSE;
    }

    try {
        //
        // Check if we should skip all client side UI.
        //
        if (gbSuppressUI) {
            //
            // If we were launching newdev for client-side installation, log an
            // event to let someone know that we didn't.
            //
            if (!(Flags & DEVICE_INSTALL_UI_ONLY)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_WARNINGS,
                           "UMPNPMGR: DoDeviceInstallClient: Client-side newdev UI has been suppressed, exiting.\n"));
                LogWarningEvent(WRN_NEWDEV_UI_SUPPRESSED, 1, DeviceId);
            }
            goto Clean0;
        }

        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        ASSERT(ulSessionId != INVALID_SESSION);

        //
        // If the specified session is not currently connected anywhere, don't
        // bother creating any UI.
        //
        if (!IsSessionConnected(ulSessionId)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: DoDeviceInstallClient: SessionId %d not connected, exiting\n",
                       ulSessionId));
            goto Clean0;
        }

        //
        // Lock the client list while we retrieve / create a client to use.
        //
        LockNotifyList(&InstallClientList.Lock);

        //
        // First, try to connect to an existing client already running on this
        // session.
        //
        bStatus = ConnectDeviceInstallClient(ulSessionId,
                                             &pDeviceInstallClient);
        if (bStatus) {
            //
            // If the client we just reconnected to was client-side installing
            // this same device when it was last disconnected, don't send it
            // again.
            //
            if ((IS_FLAG_CLEAR(Flags, DEVICE_INSTALL_UI_ONLY)) &&
                (CompareString(
                    LOCALE_INVARIANT, NORM_IGNORECASE,
                    pDeviceInstallClient->LastDeviceId, -1,
                    DeviceId, -1) == CSTR_EQUAL)) {
                bSameDevice = TRUE;
            }

        } else {
            //
            // Create a new device install client for this session.
            //
            bStatus = CreateDeviceInstallClient(ulSessionId,
                                                &pDeviceInstallClient);
        }

        if (bStatus) {
            //
            // The client should only have the initial reference from when it
            // was added to the list, since any use of the client is done on
            // this single install thread.
            //
            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->RefCount == 1);

            //
            // Keep track of both client and server flags.
            //
            pDeviceInstallClient->ulInstallFlags = Flags;

            //
            // Reference the device install client while it is in use.  The
            // caller must remove this reference when it is done with it.
            //
            ReferenceDeviceInstallClient(pDeviceInstallClient);
        }

        UnlockNotifyList(&InstallClientList.Lock);

        if (!bStatus || bSameDevice) {
            //
            // If we don't have a client, or we don't need to resend the device
            // instance to install, we're done.
            //
            goto Clean0;
        }

        //
        // Filter out the install flags that the client doesn't know about.
        //
        InstallFlags = (Flags & DEVICE_INSTALL_CLIENT_MASK);

        DeviceIdSize = (lstrlen(DeviceId) + 1) * sizeof(WCHAR);

        //
        // Make sure we reset the device install event since we will block waiting for
        // newdev.dll to set this event to let us know that it is finished with the current
        // installation.
        //
        if (pDeviceInstallClient->hEvent) {
            ResetEvent(pDeviceInstallClient->hEvent);
        }

        //
        // When sending stuff to newdev.dll over the device install pipe it expects
        // two ULONGs followed by the DeviceID.  The first ULONG is the Flags which
        // tells newdev whether we are doing a UI only install or a full install.
        // The next ULONG is the size of the Device ID and then we send the DeviceID.
        //
        if (WriteFile(pDeviceInstallClient->hPipe,
                      &InstallFlags,
                      sizeof(InstallFlags),
                      &ulSize,
                      NULL
                      )) {
            if (WriteFile(pDeviceInstallClient->hPipe,
                          &DeviceIdSize,
                          sizeof(DeviceIdSize),
                          &ulSize,
                          NULL
                          )) {
                if (WriteFile(pDeviceInstallClient->hPipe,
                              DeviceId,
                              DeviceIdSize,
                              &ulSize,
                              NULL
                              )) {
                    bStatus = TRUE;
                } else {
                    LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
                }
            } else {
                LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            }
        } else {
            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
        }

        //
        // Note that we don't remove the reference placed on the install client
        // entry while it was in use, because it will be handed back to the
        // caller, who will wait on the client's event and process handles.  The
        // caller should remove the reference when it is no longer using these.
        // Removing the final reference will cause the client to be closed.
        //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during DoDeviceInstallClient!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        pDeviceInstallClient = pDeviceInstallClient;
    }

 Clean0:

    if (!bStatus) {
        //
        // If we had a device install client at some point, but failed to send
        // it the request, remove the reference we placed on it.
        //
        if (pDeviceInstallClient) {
            LockNotifyList(&InstallClientList.Lock);
            DereferenceDeviceInstallClient(pDeviceInstallClient);
            UnlockNotifyList(&InstallClientList.Lock);
        }

        //
        // Let the caller know there isn't a device install client handling
        // this request.
        //
        *SessionId = INVALID_SESSION;
        *DeviceInstallClient = NULL;

    } else {
        //
        // Make sure we're returning valid client information.
        //
        ASSERT(pDeviceInstallClient);
        ASSERT(pDeviceInstallClient->hEvent);
        ASSERT(pDeviceInstallClient->hPipe);
        ASSERT(pDeviceInstallClient->hProcess);
        ASSERT(pDeviceInstallClient->hDisconnectEvent);
        ASSERT(pDeviceInstallClient->ulSessionId != INVALID_SESSION);

        *SessionId = pDeviceInstallClient->ulSessionId;
        *DeviceInstallClient = pDeviceInstallClient;
    }

    return bStatus;

} // DoDeviceInstallClient



unsigned _stdcall
ThreadProc_RunOnce(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    This routine performs server-side processing of the RunOnce entries that
    have been accumulated by setupapi.  The RunOnce node list will be empty
    upon return.

Arguments:

    lpThreadParameter - Specifies the head of the RunOnce node list to be
                        processed.

Return Value:

    If successful, the return value is NO_ERROR.  If failure, the return value
    is a Win32 error code indicating the cause of failure.

--*/
{
    DWORD Err = NO_ERROR;
    PPSP_RUNONCE_NODE RunOnceNode;
    HINSTANCE hLib;
    CHAR AnsiBuffer[MAX_PATH * 2];
    PSTR EndPtr;
    RUNDLLPROCA fpRunDllProcA = NULL;
    RUNDLLPROCW fpRunDllProcW = NULL;
    HRESULT hr;

    //
    // This thread is executed synchronously during the server-side device
    // installer process, therefore setupapi must already be loaded.  The
    // RunOnce node list is stored as global state in SETUPAPI.DLL, while it is
    // loaded for this instance of server-side device install processing.
    //
    ASSERT(ghDeviceInstallerLib != NULL);

    //
    // ISSUE-2002/02/20-jamesca: Consider a separate thread for each entry?
    //   Note that this routine processes all RunOnce entries in the context of
    //   a single thread.  Any catastrophic errors encountered while processing
    //   one entry will affect or prevent subsequent entries.  For greater
    //   isolation, we could consider creating a separate thread for each, but
    //   that would adversely affect performance to protect against things that
    //   are supposed to be signed in the first place, and any RunOnce entry we
    //   call could do worse things to this process anyways.
    //
    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_INSTALL,
               "UMPNPMGR: Processing RunOnce entries "
               "during server-side device install.\n"));

    //
    // Process each node in the list supplied.  This thread is only created
    // because there are nodes to be processed, so the list must be non-NULL.
    //
    RunOnceNode = (PPSP_RUNONCE_NODE)lpThreadParameter;

    ASSERT(RunOnceNode != NULL);

    while (RunOnceNode != NULL) {

        hLib = NULL;

        try {
            //
            // First, load the DLL (setupapi already did the signature
            // verification for us, so this should be safe).
            //
            hLib = LoadLibrary(RunOnceNode->DllFullPath);

            if (hLib) {
                //
                // First, try to retrieve the 'W' (Unicode) version of the entrypoint.
                //
                if (SUCCEEDED(StringCchCopyExA(
                                  AnsiBuffer,
                                  (sizeof(AnsiBuffer) / sizeof(CHAR)) - 1,
                                  RunOnceNode->DllEntryPointName,
                                  &EndPtr, NULL,
                                  STRSAFE_IGNORE_NULLS |
                                  STRSAFE_NULL_ON_FAILURE))) {

                    *EndPtr = 'W';
                    *(EndPtr + 1) = '\0';

                    fpRunDllProcW = (RUNDLLPROCW)GetProcAddress(hLib, AnsiBuffer);

                }

                if (!fpRunDllProcW) {
                    //
                    // Couldn't find unicode entrypt, try 'A' decorated one
                    //
                    *EndPtr = 'A';
                    fpRunDllProcA = (RUNDLLPROCA)GetProcAddress(hLib, AnsiBuffer);

                    if (!fpRunDllProcA) {
                        //
                        // Couldn't find 'A' decorated entrypt, try undecorated name
                        // undecorated entrypts are assumed to be ANSI
                        //
                        *EndPtr = '\0';
                        fpRunDllProcA = (RUNDLLPROCA)GetProcAddress(hLib, AnsiBuffer);
                    }
                }

                //
                // We shoulda found one of these...
                //
                ASSERT(fpRunDllProcW || fpRunDllProcA);

                if (fpRunDllProcW) {
                    //
                    // Re-use our ANSI buffer to hold a writeable copy of our
                    // DLL argument string.
                    //
                    hr = StringCchCopyW((LPWSTR)AnsiBuffer,
                                        sizeof(AnsiBuffer) / sizeof(WCHAR), // size of buffer in WCHARs
                                        RunOnceNode->DllParams);
                    ASSERT(SUCCEEDED(hr));

                    fpRunDllProcW(NULL, ghInst, (LPWSTR)AnsiBuffer, SW_HIDE);

                } else if (fpRunDllProcA) {
                    //
                    // Need to convert the arg string to ANSI first...
                    //
                    WideCharToMultiByte(CP_ACP,
                                        0,      // default composite char behavior
                                        RunOnceNode->DllParams,
                                        -1,
                                        AnsiBuffer,
                                        sizeof(AnsiBuffer),
                                        NULL,
                                        NULL
                                        );

                    fpRunDllProcA(NULL, ghInst, AnsiBuffer, SW_HIDE);
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_INSTALL,
                       "UMPNPMGR: Exception %d during ThreadProc_RunOnce!\n",
                       GetExceptionCode()));
            Err = GetExceptionCode();
            ASSERT(0);
            //
            // Reference the following variable so the compiler will respect
            // statement ordering w.r.t. its assignment.
            //
            hLib = hLib;
        }

        //
        // Free the library, if loaded.
        //
        if (hLib != NULL) {
            FreeLibrary(hLib);
            hLib = NULL;
        }

        //
        // If we encountered an exception processing this entry, exit
        // immediately.  Don't process any additional entries because the
        // exception may have occured because the thread state was corrupted by
        // one of our callees, which could cause problems for the others.  Note,
        // the main device install thread is waiting on this thread, and will
        // log an error in the eventlog if we exit with an error.
        //
        if (Err != NO_ERROR) {
            goto Clean0;
        }

        //
        // We're still doing ok, move on to the next one.
        //
        RunOnceNode = RunOnceNode->Next;
    }

    //
    // If we make it here, we managed to process all queued RunOnce entries
    // without any catastrophic failures.
    //
    ASSERT(Err == NO_ERROR);

  Clean0:

    _endthreadex(Err);

    //
    // Unreachable code, but it makes the compiler happy.
    //
    return Err;

} // ThreadProc_RunOnce



VOID
DoRunOnce(
    VOID
    )
/*++

Routine Description:

    This routine performs server-side processing of the RunOnce entries that
    have been accumulated by setupapi.  The RunOnce node list will be empty
    upon return.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PPSP_RUNONCE_NODE RunOnceNode;
    HANDLE hRunOnceThread;
    DWORD ThreadID = 0, ThreadExitCode = NO_ERROR, WaitStatus;


    //
    // First, check to see if there are any RunOnce entries that need to be
    // processed.
    //
    RunOnceNode = fpAccessRunOnceNodeList();

    if (RunOnceNode != NULL) {

        //
        // Create the thread that will process the RunOnce RUNDLL entries that have
        // been queued up.
        //
        hRunOnceThread =
            (HANDLE)_beginthreadex(
                (void*)NULL,
                (unsigned)0,
                (unsigned int (__stdcall *)(void *))ThreadProc_RunOnce,
                (void*)RunOnceNode,
                (unsigned)0,
                (unsigned int*)&ThreadID);

        if (hRunOnceThread != NULL) {
            //
            // Wait synchronously for the RunOnce thread to complete processing the
            // nodes, and exit.
            //
            WaitStatus =
                WaitForSingleObject(
                    hRunOnceThread, INFINITE);

            ASSERT(WaitStatus == WAIT_OBJECT_0);

            if (GetExitCodeThread(
                    hRunOnceThread, &ThreadExitCode)) {
                //
                // If the thread exit code was not NO_ERROR, some exception
                // occured while processing the RunOnce entries.
                //
                if (ThreadExitCode != NO_ERROR) {
                    LogErrorEvent(ERR_PROCESSING_RUNONCE, ThreadExitCode, 0);
                }

            } else {
                //
                // The above wait on the thread handle succeeded, so the thread
                // should NOT still be active.
                //
                ASSERT(GetLastError() != STILL_ACTIVE);
            }

            //
            // Close the handle to the thread object.
            //
            CloseHandle(hRunOnceThread);
        }
    }

    //
    // Free all the members in the list.
    //
    fpDestroyRunOnceNodeList();

    return;

} // DoRunOnce



DWORD
SessionNotificationHandler(
    IN  DWORD EventType,
    IN  PWTSSESSION_NOTIFICATION SessionNotification
    )
/*++

Routine Description:

    This routine handles console switch events.

Arguments:

    EventType           - The type of event that has occurred.

    SessionNotification - Additional event information.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    failure.

Notes:

    Session change notification events are used to determine when there is a
    session with a logged on user currently connected to the Console.  When a
    user session is connected to the Console, we signal the "logged on" event,
    which will wake the device installation thread to perform any pending
    client-side device install events.  When there is no user session connected
    to the Console, the "logged on" event is reset.  The "logged on" event may
    also be set/reset for logon/logoff events to session 0 by PNP_ReportLogOn /
    PnpConsoleCtrlHandler, in the event that Terminal Services are not
    available.

--*/
{
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient;

    //
    // Validate the session change notification structure.
    //
    ASSERT(SessionNotification);
    ASSERT(SessionNotification->cbSize >= sizeof(WTSSESSION_NOTIFICATION));

    if ((!ARGUMENT_PRESENT(SessionNotification)) ||
        (SessionNotification->cbSize < sizeof(WTSSESSION_NOTIFICATION))) {
        return ERROR_INVALID_PARAMETER;
    }

    switch (EventType) {

        case WTS_CONSOLE_CONNECT:
            //
            // The notification was sent because the specified session was
            // connected to the Console.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_CONSOLE_CONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            //
            // Keep track globally of the current active console session, and
            // signal that it's safe to access it.
            //
            // NOTE - we must set the ghActiveConsoleSessionEvent here, prior to
            // calling IsConsoleSession below, which waits on it, else we will
            // deadlock out service's control handler.
            //
            gActiveConsoleSessionId = (ULONG)SessionNotification->dwSessionId;
            if (ghActiveConsoleSessionEvent) {
                SetEvent(ghActiveConsoleSessionEvent);
            }

            //
            // If the session just connected to the Console already has a logged
            // on user, signal the "logged on" event.
            //
            if (IsConsoleSession((ULONG)SessionNotification->dwSessionId) &&
                IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) {
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_CONSOLE_CONNECT: "
                               "SetEvent LOGGED_ON_EVENT\n"));
                }
            }
            break;

        case WTS_CONSOLE_DISCONNECT:
            //
            // The notification was sent because the specified session
            // was disconnected from the Console.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_CONSOLE_DISCONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            //
            // Check if the session just disconnected from the "Console" has a
            // logged on user.
            //
            if (IsConsoleSession((ULONG)SessionNotification->dwSessionId) &&
                IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) {
                //
                // Reset the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_CONSOLE_DISCONNECT: "
                               "ResetEvent LOGGED_ON_EVENT\n"));
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                }

                //
                // Since this is a console switch event, only do something with
                // a device install client on the console session if it's
                // behavior was specifically designated for the console (i.e. -
                // it was put on this session because it was the active console
                // session at the time).
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if ((pDeviceInstallClient) &&
                    (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE)) {
                    if (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_UI_ONLY) {
                        //
                        // If it was just for UI only, dereference it to make it
                        // go away when it's no longer in use.
                        //
                        DereferenceDeviceInstallClient(pDeviceInstallClient);
                    } else {
                        //
                        // Otherwise, it is a legitimate client-side
                        // installation in progress, so just disconnect from it.
                        // This does not remove a reference because we want it
                        // to stay around in case the session is reconnected to
                        // and the device still needs to be installed, - or
                        // until we find out that there are no more devices to
                        // install, in which case we'll close it.
                        //
                        DisconnectDeviceInstallClient(pDeviceInstallClient);
                    }
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }

            //
            // The current active console session is invalid until we receive a
            // subsequent console connect event.  Reset the event.
            //
            // NOTE - we must reset the ghActiveConsoleSessionEvent here, after
            // calling IsConsoleSession above, which waits on it, else we will
            // deadlock out service's control handler.
            //
            if (ghActiveConsoleSessionEvent) {
                ResetEvent(ghActiveConsoleSessionEvent);
            }
            gActiveConsoleSessionId = INVALID_SESSION;

            break;

        case WTS_REMOTE_CONNECT:
            //
            // The specified session was connected remotely.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_REMOTE_CONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId == MAIN_SESSION) &&
                (IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) &&
                (!IsFastUserSwitchingEnabled())) {
                //
                // If the remote session that was just connected from the "Console"
                // has a logged on user, signal the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_REMOTE_CONNECT: "
                               "SetEvent LOGGED_ON_EVENT\n"));
                }
            }
            break;

        case WTS_REMOTE_DISCONNECT:
            //
            // The specified session was disconnected remotely.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_REMOTE_DISCONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId == MAIN_SESSION) &&
                (IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) &&
                (!IsFastUserSwitchingEnabled())) {
                //
                // If the remote session that was disconnected from the "Console"
                // has a logged on user, reset the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_REMOTE_DISCONNECT: "
                               "ResetEvent LOGGED_ON_EVENT\n"));
                }

                //
                // Since this remote session is being treated as the console,
                // only do something with a device install client if it's
                // behavior was NOT specifically designated for the console
                // (i.e. - it was put on this session because it was the active
                // console session at the time).
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if ((pDeviceInstallClient) &&
                    ((pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0)) {
                    if (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_UI_ONLY) {
                        //
                        // If it was just for UI only, dereference it to make it
                        // go away when it's no longer in use.
                        //
                        DereferenceDeviceInstallClient(pDeviceInstallClient);
                    } else {
                        //
                        // Otherwise, it is a legitimate client-side
                        // installation in progress, so just disconnect from it.
                        // This does not remove a reference because we want it
                        // to stay around in case the session is reconnected to
                        // and the device still needs to be installed, - or
                        // until we find out that there are no more devices to
                        // install, in which case we'll close it.
                        //
                        DisconnectDeviceInstallClient(pDeviceInstallClient);
                    }
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }
            break;

        case WTS_SESSION_UNLOCK:
            //
            // The interactive windowstation on the specified session was unlocked.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_UNLOCK: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (SessionNotification->dwSessionId == MAIN_SESSION) {
                //
                // For the main session, Terminal Services may or may not be
                // available, so we keep track of this state ourselves.
                //
                gbMainSessionLocked = FALSE;
            }

            if (IsFastUserSwitchingEnabled()) {
                //
                // When Fast User Switching is enabled, unlocking the windowstation
                // is a return from the "Welcome" desktop, so we treat it as a
                // logon ...
                //

                //
                // If this is a logon to the "Console" session, signal the event that
                // indicates a Console user is currently logged on.
                //
                // NOTE: we check gActiveConsoleSessionId directly here, without
                // waiting on the corresponding event because this unlock may
                // happen during a Console session change for another session,
                // in which case we will hang here in the service control
                // handler, waiting for the event to be set - and not be able to
                // receive the service control that actually lets us set the
                // event!!!  Synchronization is not so important here because we
                // are not using the session for anything, just comparing
                // against it.  If a session change really is in progress, this
                // session can't be the Console session anyways.
                //
                // Also, since Fast User Switching is enabled, we can just
                // compare against the active Console session id, and not bother
                // with the session 0 thing.
                //
                if (SessionNotification->dwSessionId == gActiveConsoleSessionId) {
                    if (InstallEvents[LOGGED_ON_EVENT]) {
                        SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_EVENT | DBGF_INSTALL,
                                   "UMPNPMGR: WTS_SESSION_UNLOCK with FUS: "
                                   "SetEvent LOGGED_ON_EVENT\n"));
                    }
                }

            } else {
                //
                // When Fast User Switching is not enabled, we don't do anything
                // special when the winstation is unlocked.
                //

                // No-FUS, no-muss.
                NOTHING;
            }
            break;

        case WTS_SESSION_LOGON:
            //
            // NTRAID #181685-2000/09/11-jamesca:
            //
            //   Currently, terminal services sends notification of logons to
            //   "remote" sessions before the server's process creation thread
            //   is running.  If we set the logged on event, and there are
            //   devices waiting to be installed, we will immediately call
            //   CreateProcessAsUser on that session, which will fail.  As a
            //   (temporary?) workaround, we'll continue to use PNP_ReportLogOn
            //   to receive logon notification from userinit.exe, now for all
            //   sessions.
            //
            break;

        case WTS_SESSION_LOCK:
            //
            // The interactive windowstation on the specified session was locked.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_LOCK: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (SessionNotification->dwSessionId == MAIN_SESSION) {
                //
                // For the main session, Terminal Services may or may not be
                // available, so we keep track of this state ourselves.
                //
                gbMainSessionLocked = TRUE;
            }

            if (IsFastUserSwitchingEnabled()) {
                //
                // When Fast User Switching is enabled, locking the windowstation
                // displays the "Welcome" desktop, potentially allowing a different
                // user to logon, so we treat it as a logoff ...
                //

                //
                // If this is a "logoff" from the "Console" session, reset the event
                // that indicates a Console user is currently logged on.
                //
                //
                // NOTE: we check gActiveConsoleSessionId directly here, without
                // waiting on the corresponding event because this lock may
                // happen during a Console session change for another session,
                // in which case we will hang here in the service control
                // handler, waiting for the event to be set - and not be able to
                // receive the service control that actually lets us set the
                // event!!!  Synchronization is not so important here because we
                // are not using the session for anything, just comparing
                // against it.  If a session change really is in progress, this
                // session can't be the Console session anyways.
                //
                // Also, since Fast User Switching is enabled, we can just
                // compare against the active Console session id, and not bother
                // with the session 0 thing.
                //
                if (SessionNotification->dwSessionId == gActiveConsoleSessionId) {
                    if (InstallEvents[LOGGED_ON_EVENT]) {
                        ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_EVENT | DBGF_INSTALL,
                                   "UMPNPMGR: WTS_SESSION_LOCK with FUS: "
                                   "ResetEvent LOGGED_ON_EVENT\n"));
                    }
                }

            } else {
                //
                // When Fast User Switching is not enabled, we don't do anything
                // special when the winstation is locked.
                //

                // No-FUS, no-muss.
                NOTHING;
            }
            break;

        case WTS_SESSION_LOGOFF:
            //
            // A user logged off from the specified session.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_LOGOFF: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId != MAIN_SESSION) &&
                ((ULONG)SessionNotification->dwSessionId == gActiveConsoleSessionId)) {
                //
                // If the logoff occurred on the Console session (but not
                // session 0), reset the "logged on" event.
                // Session 0 logoffs are still handled by PnpConsoleCtrlHandler.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_SESSION_LOGOFF: "
                               "ResetEvent LOGGED_ON_EVENT\n",
                               SessionNotification->dwSessionId));
                }

                //
                // If we currently have a device install UI client on this session,
                // we should attempt to close it now, before logging off.
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if (pDeviceInstallClient) {
                    DereferenceDeviceInstallClient(pDeviceInstallClient);
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }
            break;

        default:
            //
            // Unrecognized session change notification event.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: Unknown SERVICE_CONTROL_SESSIONCHANGE event type (%d) "
                       "received for SessionId %d!!\n",
                       EventType,
                       SessionNotification->dwSessionId));
            break;

    }

    return NO_ERROR;

} // SessionNotificationHandler



BOOL
IsUserLoggedOnSession(
    IN  ULONG    ulSessionId
    )
/*++

Routine Description:

    Checks to see if a user is logged on to the specified session.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if a user is currently logged on to the specified session,
    FALSE otherwise.

--*/
{
    BOOL   bResult = FALSE;
    LPWSTR pszUserName;
    DWORD  dwSize;

    if (ulSessionId == MAIN_SESSION) {
        //
        // For the main session, Terminal Services may or may not be available,
        // so we just check if we currently have a handle to the user token.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken != NULL) {
            bResult = TRUE;
        }
        UnlockPrivateResource(&gTokenLock);

    } else {

        //
        // If the specified session is not the main session,
        // query the session information to see if there is already a
        // user logged on.
        //
        if (fpWTSQuerySessionInformation && fpWTSFreeMemory) {

            pszUserName = NULL;
            dwSize = 0;

            if (fpWTSQuerySessionInformation((HANDLE)WTS_CURRENT_SERVER_HANDLE,
                                             (DWORD)ulSessionId,
                                             (WTS_INFO_CLASS)WTSUserName,
                                             (LPWSTR*)&pszUserName,
                                             &dwSize)) {
                if ((pszUserName != NULL) && (lstrlen(pszUserName) != 0)) {
                    bResult = TRUE;
                }

                //
                // Free the supplied buffer
                //
                if (pszUserName) {
                    fpWTSFreeMemory((PVOID)pszUserName);
                }

            } else {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: WTSQuerySessionInformation failed for SessionId %d, "
                           "error = %d\n",
                           ulSessionId, GetLastError()));
            }
        }
    }

    return bResult;

} // IsUserLoggedOnSession



BOOL
IsSessionConnected(
    IN  ULONG     ulSessionId
    )
/*++

Routine Description:

    Checks if the specified session is connected.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the specified session is currently connected, FALSE
    otherwise.

Notes:

    This routine assumes that the specified session is connected, unless we can
    poitively determine that it is not.  i.e., if Terminal Services are not
    available, it is assumed that the specified session is connected.

--*/
{
    BOOL   bResult = TRUE;
    LPWSTR pBuffer;
    DWORD  dwSize;

    //
    // Query the specified session.
    //
    if (fpWTSQuerySessionInformation && fpWTSFreeMemory) {

        pBuffer = NULL;
        dwSize = 0;

        if (fpWTSQuerySessionInformation((HANDLE)WTS_CURRENT_SERVER_HANDLE,
                                         (DWORD)ulSessionId,
                                         (WTS_INFO_CLASS)WTSConnectState,
                                         (LPWSTR*)&pBuffer,
                                         &dwSize)) {
            //
            // The session state must be either Active or Connected.
            //
            if ((pBuffer == NULL) ||
                ((((INT)*pBuffer) != WTSActive) &&
                 (((INT)*pBuffer) != WTSConnected))) {
                //
                // The specified session is not currently connected.
                //
                bResult = FALSE;
            }

            //
            // Free the supplied buffer
            //
            if (pBuffer) {
                fpWTSFreeMemory((PVOID)pBuffer);
            }

        }

    } else {
        //
        // If the above TS entrypoints are not set, terminal services is not
        // enabled.  This must be session 0, and it must be connected.
        //
        ASSERT(ulSessionId == MAIN_SESSION);
    }

    return bResult;

} // IsSessionConnected



BOOL
IsSessionLocked(
    IN  ULONG    ulSessionId
    )
/*++

Routine Description:

    Checks to see if the interactive windowstation for the specified session is
    locked.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the interactive windowstation for the specified session is
    locked, FALSE otherwise.

--*/
{
    BOOL   bLocked = FALSE;
    DWORD  dwReturnLength;

    if (ulSessionId == MAIN_SESSION) {
        //
        // For the main session, Terminal Services may or may not be available,
        // so we just check our internal state variable.
        //
        bLocked = gbMainSessionLocked;

    } else {
        //
        // If the specified session is not the main session, query Terminal
        // Services for that session's WinStation information.
        //

        try {

            if (!fpWinStationQueryInformationW(SERVERNAME_CURRENT,
                                               ulSessionId,
                                               WinStationLockedState,
                                               (PVOID)&bLocked,
                                               sizeof(bLocked),
                                               &dwReturnLength)) {
                bLocked = FALSE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: WinStationQueryInformation failed for SessionId %d, "
                           "error = %d\n",
                           ulSessionId, GetLastError()));
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            bLocked = FALSE;
        }
    }

    return bLocked;

} // IsSessionLocked



BOOL
IsConsoleSession(
    IN  ULONG     ulSessionId
    )
/*++

Routine Description:

    Checks to see if the specified session is the "Console" session.

    When Terminal Services Fast User Switching is enabled, this means that the
    session is the session connected to the physical display.  When Fast User
    Switching is disabled, this means that the session is Session 0.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the specified session should currently be considered the
    "Console" session.

Notes:

   Note that this routine may potentially wait in GetActiveConsoleSessionId(),
   on the event we use to guard access to the active console session.  Because
   of that, this routine should not be called in cases where it prevents a
   console connect or console disconnect from taking place, unless the event is
   known to be set appropriately.

--*/
{
    BOOL bFusEnabled;

    bFusEnabled = IsFastUserSwitchingEnabled();

    if ((!bFusEnabled && (ulSessionId == MAIN_SESSION)) ||
        ( bFusEnabled && (ulSessionId == GetActiveConsoleSessionId()))) {
        return TRUE;
    } else {
        return FALSE;
    }

} // IsConsoleSession



ULONG
GetActiveConsoleSessionId(
    VOID
    )
/*++

Routine Description:

    This routine returns the session id for the current active Console session.
    If a Console session switch event is in progress, it will wait until it is
    complete before returning.

Arguments:

    None.

Return Value:

    Session Id of the current active Console session.

--*/
{
    ULONG ulConsoleSessionId;
    DWORD dwWait;

    ASSERT(ghActiveConsoleSessionEvent != NULL);

    //
    // If we have nothing to wait on, just return the current state.
    //
    if (ghActiveConsoleSessionEvent == NULL) {
        return gActiveConsoleSessionId;
    }

    ulConsoleSessionId = INVALID_SESSION;

    while (ulConsoleSessionId == INVALID_SESSION) {
        //
        // Wait on the console session event until we retrieve a valid Console
        // session id.
        //
        // We do this because a subtle race can occur when our service's control
        // handler processes a Console connect, which signals the console
        // session event and satisfies this wait, but then immediately processes
        // a subsequent Console disconnect, resetting the event, and
        // invalidating the active console session id -- BEFORE this
        // wait-satisfied thread is rescheduled to run.  Once rescheduled, this
        // thread could end up reading an invalid value as the current active
        // Console session id.
        //
        // In that case however, the console session event would have been reset
        // already, so we can simply wait until it is signalled again, and
        // return the session id of the active Console session when the
        // succession of connect/disconnect requests that have been processed by
        // our service's control handler handler have been synchronized with
        // this waiting thread.
        //
        dwWait = WaitForSingleObject(ghActiveConsoleSessionEvent, INFINITE);
        ASSERT(dwWait == WAIT_OBJECT_0);

        ulConsoleSessionId = gActiveConsoleSessionId;
    }

    ASSERT(ulConsoleSessionId != INVALID_SESSION);

    return ulConsoleSessionId;

} // GetActiveConsoleSessionId



BOOL
GetSessionUserToken(
    IN  ULONG     ulSessionId,
    OUT LPHANDLE  lphUserToken
    )
/*++

Routine Description:

    This routine returns a handle to the user access token for the user at the
    Console session.

Arguments:

   ulSession    - Specifies the session for which the interactive user's token is
                  to be retrieved.

   lphUserToken - Specifies the address to receive the handle to the user access
                  token.  Note that if this routine was successful, the caller is
                  responsible for closing this handle.

Return Value:

   Returns TRUE if successful, FALSE otherwise.

--*/
{
    BOOL   bResult = FALSE;
    HANDLE hImpersonationToken = INVALID_HANDLE_VALUE;
    RPC_STATUS rpcStatus;

    //
    // Verify that we were supplied a location to store the user token handle.
    //
    if (lphUserToken == NULL) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: NULL lphUserToken supplied to GetSessionUserToken!\n"));
        return FALSE;
    }

    if (ulSessionId == MAIN_SESSION) {
        //
        // A logon to session 0 can't be dependent on termsrv.exe, so we always
        // cache a handle to the user access token for that session during the
        // call to PNP_ReportLogon for session 0.  If we currently have a handle
        // to the token, return it.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken) {
            //
            // Duplicate the handle so that the caller can always safely close
            // it, no matter where it came from.
            //
            bResult = DuplicateHandle(GetCurrentProcess(),
                                      ghUserToken,
                                      GetCurrentProcess(),
                                      lphUserToken,
                                      0,
                                      TRUE,
                                      DUPLICATE_SAME_ACCESS);
            if (!bResult) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: DuplicateHandle failed for ghUserToken for SessionId %d, error = %d\n",
                           ulSessionId, GetLastError()));
            }

        } else {
            //
            // If we don't have a handle to a user access token for session 0,
            // there is probably not any user logged on to that session.
            //
            bResult = FALSE;
        }
        UnlockPrivateResource(&gTokenLock);

    } else {
        //
        // If the specified session is some session other than session 0,
        // Terminal Services must necessarily be available.  Call
        // GetWinStationUserToken to retrieve a handle to the user access token
        // for this session.
        //
        bResult = GetWinStationUserToken(ulSessionId, &hImpersonationToken);

        if (bResult) {
            //
            // The token retrieved by GetWinStationUserToken is an impersonation
            // token.  CreateProcessAsUser requires a primary token, so we must
            // duplicate the impersonation token to get one.  Create a primary
            // token with the same access rights as the original token.
            //
            bResult = DuplicateTokenEx(hImpersonationToken,
                                       0,
                                       NULL,
                                       SecurityImpersonation,
                                       TokenPrimary,
                                       lphUserToken);

            //
            // Close the handle to the impersonation token.
            //
            CloseHandle(hImpersonationToken);

            if (!bResult) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: DuplicateTokenEx failed, error = %d\n",
                           GetLastError()));
            }

        } else {

            //
            // Find out what the problem was.
            //
            rpcStatus = GetLastError();

            if (rpcStatus == RPC_S_INVALID_BINDING) {
                //
                // This is some error related to the service not being
                // available.  Since we only call this for sessions other than
                // the main session, termsrv should definitely be available.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: GetWinStationUserToken returned error = %d for SessionId %d!!\n",
                           rpcStatus, ulSessionId));

                ASSERT(FALSE);

            } else {
                //
                // Some other error, the service may never be avaiable so bail
                // out now.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: GetWinStationUserToken failed for SessionId %d, error = %d\n",
                           ulSessionId, rpcStatus));
            }
        }
    }

    //
    // If successful, we should always be returning a valid handle.
    //
    ASSERT(!bResult || ((*lphUserToken != INVALID_HANDLE_VALUE) && (*lphUserToken != NULL)));

    return bResult;

} // GetSessionUserToken



DWORD
CreateUserSynchEvent(
    IN  HANDLE    hUserToken,
    IN  LPCWSTR   lpName,
    OUT HANDLE   *phEvent
    )

/*++

Routine Description:

    This routine creates an event that the specified user can synchronize with.
    This is used so that we can communicate with NewDev and HotPlug processes
    running in the user's context.

Arguments:

    hUserToken - Specifies a handle to the user access token for whom the event
                 will be created.

    lpName -     Name of event to create.

    phEvent -    Supplies the address of a variable that will receive a handle
                 to the event.

Return Value:

    If successful, the return value is NO_ERROR.  If failure, the return value
    is a Win32 error code indicating the cause of failure.

--*/

{
    DWORD                       Err = ERROR_SUCCESS;
    PSID                        pUserSid = NULL;
    PACL                        pDacl = NULL;
    ULONG                       ulAclSize;
    SECURITY_DESCRIPTOR         sd;
    SECURITY_ATTRIBUTES         sa;


    //
    // Retrieve the User SID
    //

    pUserSid =
        GetUserSid(hUserToken);

    if (pUserSid == NULL) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(pUserSid));

    //
    // Use the LocalSystem SID provided in the SCM global data.
    //

    ASSERT(PnPGlobalData != NULL);
    ASSERT(IsValidSid(PnPGlobalData->LocalSystemSid));

    //
    // Determine the size required for the DACL
    //

    ulAclSize  = sizeof(ACL);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pUserSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(PnPGlobalData->LocalSystemSid) - sizeof(DWORD);

    //
    // Allocate and initialize the DACL
    //

    pDacl =
        (PACL)HeapAlloc(
            ghPnPHeap, 0, ulAclSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulAclSize, ACL_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for LocalSystem EVENT_ALL_ACCESS
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_ALL_ACCESS,
            PnPGlobalData->LocalSystemSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for User EVENT_QUERY_STATE, EVENT_MODIFY_STATE, and SYNCHRONIZE
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
            pUserSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidAcl(pDacl));

    //
    // Allocate and initialize the security descriptor
    //

    if (!InitializeSecurityDescriptor(
            &sd, SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Set the new DACL in the security descriptor
    //

    if (!SetSecurityDescriptorDacl(
            &sd, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSecurityDescriptor(&sd));

    //
    // Add the security descriptor to the security attributes
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    //
    // Create the manual-reset event with a nonsignaled initial state.
    //

    *phEvent = CreateEvent(&sa, TRUE, FALSE, lpName);

    if (*phEvent == NULL) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Check that the named event did not already exist.
    //

    ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Err = ERROR_ALREADY_EXISTS;
        CloseHandle(*phEvent);
        *phEvent = NULL;
        goto Clean0;
    }

 Clean0:

    //
    // Cleanup.
    //

    if (pUserSid != NULL) {
        HeapFree(ghPnPHeap, 0, pUserSid);
    }

    if (pDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pDacl);
    }

    return Err;

} // CreateUserSynchEvent



BOOL
CreateNoPendingInstallEvent(
    VOID
    )
/*++

Routine Description:

    This routine creates the "PnP_No_Pending_Install_Events" global named event,
    which is set and reset by the UMPNPMGR ThreadProc_DeviceInstall server-side
    device install thread, and waited on by the CMP_WaitNoPendingInstalls
    CFGMGR32 API, which allows clients to synchronize with the event directly,
    to determine when PNP is done actively installing any devices.

Arguments:

    None.

Return Value:

    Returns TRUE if successful, FALSE otherwise.

--*/
{
    DWORD                       Err = NO_ERROR;
    PACL                        pDacl = NULL;
    ULONG                       ulAclSize;
    SECURITY_DESCRIPTOR         sd;
    SECURITY_ATTRIBUTES         sa;


    //
    // Use the SIDs provided in the SCM global data.  This routine is called
    // from our initialization thread, which is created during our service start
    // routine, so the SCM provided global data is available to us by now.
    //

    ASSERT(PnPGlobalData != NULL);
    ASSERT(IsValidSid(PnPGlobalData->LocalSystemSid));
    ASSERT(IsValidSid(PnPGlobalData->AliasAdminsSid));
    ASSERT(IsValidSid(PnPGlobalData->AliasUsersSid));

    //
    // Determine the size required for the DACL
    //

    ulAclSize  = sizeof(ACL);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(PnPGlobalData->LocalSystemSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(PnPGlobalData->AliasAdminsSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(PnPGlobalData->AliasUsersSid) - sizeof(DWORD);

    //
    // Allocate and initialize the DACL
    //

    pDacl =
        (PACL)HeapAlloc(
            ghPnPHeap, 0, ulAclSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulAclSize, ACL_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for LocalSystem EVENT_ALL_ACCESS
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_ALL_ACCESS,
            PnPGlobalData->LocalSystemSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for Administrators EVENT_QUERY_STATE and SYNCHRONIZE
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_QUERY_STATE | SYNCHRONIZE,
            PnPGlobalData->AliasAdminsSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for Users EVENT_QUERY_STATE and SYNCHRONIZE
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_QUERY_STATE | SYNCHRONIZE,
            PnPGlobalData->AliasUsersSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidAcl(pDacl));

    //
    // Allocate and initialize the security descriptor
    //

    if (!InitializeSecurityDescriptor(
            &sd, SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Set the new DACL in the security descriptor
    //

    if (!SetSecurityDescriptorDacl(
            &sd, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSecurityDescriptor(&sd));

    //
    // Add the security descriptor to the security attributes
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    //
    // Create the manual-reset event with a nonsignaled initial state.
    //

    ghNoPendingInstalls =
        CreateEvent(&sa, TRUE, FALSE, PNP_NO_INSTALL_EVENTS);

    if (ghNoPendingInstalls == NULL) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Check that the named event did not already exist.
    //

    ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Err = ERROR_ALREADY_EXISTS;
        CloseHandle(ghNoPendingInstalls);
        ghNoPendingInstalls = NULL;
        goto Clean0;
    }

 Clean0:

    //
    // Cleanup.
    //

    if (pDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pDacl);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

} // CreateNoPendingInstallEvent



DWORD
CreateUserReadNamedPipe(
    IN  HANDLE    hUserToken,
    IN  LPCWSTR   lpName,
    IN  ULONG     ulSize,
    OUT HANDLE   *phPipe
    )

/*++

Routine Description:

    This routine creates a named pipe that the specified user can read from.
    This is used so that we can communicate with NewDev and HotPlug processes
    running in the user's context.

Arguments:

    hUserToken - Specifies a handle to the user access token for whom the named
                 pipe will be created.

    lpName -     Name of pipe to create.

    ulSize -     Specifies the size of the output buffer for the named pipe.

    phPipe -     Supplies the address of a variable that will receive a handle
                 to the pipe.

Return Value:

    If successful, the return value is NO_ERROR.  If failure, the return value
    is a Win32 error code indicating the cause of failure.

--*/

{
    DWORD                       Err = ERROR_SUCCESS;
    PSID                        pUserSid = NULL;
    PACL                        pDacl = NULL;
    ULONG                       ulAclSize;
    SECURITY_DESCRIPTOR         sd;
    SECURITY_ATTRIBUTES         sa;


    //
    // Retrieve the User SID
    //

    pUserSid =
        GetUserSid(hUserToken);

    if (pUserSid == NULL) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(pUserSid));

    //
    // Use the LocalSystem SID provided in the SCM global data.
    //

    ASSERT(PnPGlobalData != NULL);
    ASSERT(IsValidSid(PnPGlobalData->LocalSystemSid));

    //
    // Determine the size required for the DACL
    //

    ulAclSize  = sizeof(ACL);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pUserSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(PnPGlobalData->LocalSystemSid) - sizeof(DWORD);

    //
    // Allocate and initialize the DACL
    //

    pDacl =
        (PACL)HeapAlloc(
            ghPnPHeap, 0, ulAclSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulAclSize, ACL_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for LocalSystem FILE_ALL_ACCESS
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            FILE_ALL_ACCESS,
            PnPGlobalData->LocalSystemSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for User FILE_GENERIC_READ
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            FILE_GENERIC_READ,
            pUserSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidAcl(pDacl));

    //
    // Allocate and initialize the security descriptor
    //

    if (!InitializeSecurityDescriptor(
            &sd, SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Set the new DACL in the security descriptor
    //

    if (!SetSecurityDescriptorDacl(
            &sd, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSecurityDescriptor(&sd));

    //
    // Add the security descriptor to the security attributes
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    //
    // Create the named pipe.
    //

    *phPipe =
        CreateNamedPipe(
            lpName,
            PIPE_ACCESS_OUTBOUND | // outbound data only
            FILE_FLAG_OVERLAPPED | // use overlapped structure
            FILE_FLAG_FIRST_PIPE_INSTANCE, // make sure we are the creator of the pipe
            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
            1,                 // only one instance is allowed, and we are its creator
            ulSize,            // out buffer size
            0,                 // in buffer size
            PNP_PIPE_TIMEOUT,  // default timeout
            &sa);              // security attributes

    if (*phPipe == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        *phPipe = NULL;
        goto Clean0;
    }

    //
    // Check that the named pipe did not already exist.
    //

    ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Err = ERROR_ALREADY_EXISTS;
        CloseHandle(*phPipe);
        *phPipe = NULL;
        goto Clean0;
    }

 Clean0:

    //
    // Cleanup.
    //

    if (pUserSid != NULL) {
        HeapFree(ghPnPHeap, 0, pUserSid);
    }

    if (pDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pDacl);
    }

    return Err;

} // CreateUserReadNamedPipe



VOID
LogSurpriseRemovalEvent(
    IN  LPWSTR  MultiSzList
    )
/*++

Routine Description:

    One or more non-SurpriseRemovalOK devices were removed without prior
    warning. Record the removals in the event log.

Arguments:

    MultiSz list of device instance paths.

Return Value:

    None.

--*/
{
    LPWSTR instancePath, friendlyName;
    CONFIGRET configRet;
    ULONG ulRegDataType, ulRemovalPolicy, ulVerifierFlags, ulTransferLen, ulLength;
    HKEY hMmKey = NULL;
    LONG lResult;

    for(instancePath = MultiSzList;
        ((*instancePath) != UNICODE_NULL);
        instancePath += lstrlen(instancePath) + 1) {

        ulTransferLen = ulLength = sizeof(ULONG);

        configRet = PNP_GetDeviceRegProp(
            NULL,
            instancePath,
            CM_DRP_REMOVAL_POLICY,
            &ulRegDataType,
            (LPBYTE) &ulRemovalPolicy,
            &ulTransferLen,
            &ulLength,
            0
            );

        if (configRet != CR_SUCCESS) {

            continue;
        }

        if (ulRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL) {

            //
            // For devices which we expect surprise removal, we look to see if
            // the verifier is enabled.
            //
            lResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegMemoryManagementKeyName,
                0,
                KEY_QUERY_VALUE,
                &hMmKey
                );

            if ( lResult == ERROR_SUCCESS ) {

                ulLength = sizeof(ULONG);

                lResult = RegQueryValueEx(
                    hMmKey,
                    RegVerifyDriverLevelValueName,
                    0,
                    &ulRegDataType,
                    (LPBYTE) &ulVerifierFlags,
                    &ulLength
                    );

                RegCloseKey(hMmKey);

                //
                // ADRIAO ISSUE 2001/02/14 -
                //    We don't yet have a BIOS verification flag yet, so even
                // though the verifier may be targetted at a specific driver
                // for a WHQL test, we will log an event log here.
                //
                if ((lResult != ERROR_SUCCESS) ||
                    (!(ulVerifierFlags & DRIVER_VERIFIER_ENHANCED_IO_CHECKING))) {

                    continue;
                }
            }
        }

        friendlyName = BuildFriendlyName(instancePath);

        if (friendlyName) {

            LogErrorEvent(
                ERR_SURPRISE_REMOVAL_2,
                0,
                2,
                friendlyName,
                instancePath
                );

            HeapFree(ghPnPHeap, 0, friendlyName);

        } else {

            LogErrorEvent(
                ERR_SURPRISE_REMOVAL_1,
                0,
                1,
                instancePath
                );
        }
    }
}


PWCHAR
BuildFriendlyName(
    IN  LPWSTR   InstancePath
    )
{
    PWCHAR friendlyName;
    CONFIGRET configRet;
    ULONG ulLength, ulTransferLen;
    WCHAR szBuffer[MAX_PATH];
    ULONG ulRegDataType;
    GUID classGuid;
    handle_t hBinding;

    hBinding = NULL;

    //
    // Try the registry for FRIENDLYNAME
    //
    ulLength = ulTransferLen = sizeof(szBuffer);

    configRet = PNP_GetDeviceRegProp(
        hBinding,
        InstancePath,
        CM_DRP_FRIENDLYNAME,
        &ulRegDataType,
        (LPBYTE) szBuffer,
        &ulTransferLen,
        &ulLength,
        0
        );

    if (configRet != CR_SUCCESS || !*szBuffer) {

        //
        // Try the registry for DEVICEDESC
        //
        ulLength = ulTransferLen = sizeof(szBuffer);

        configRet = PNP_GetDeviceRegProp(
            hBinding,
            InstancePath,
            CM_DRP_DEVICEDESC,
            &ulRegDataType,
            (LPBYTE) szBuffer,
            &ulTransferLen,
            &ulLength,
            0
            );

        if (configRet != CR_SUCCESS || !*szBuffer) {

            //
            // Initialize ClassGuid to GUID_NULL
            //
            CopyMemory(&classGuid, &GUID_NULL, sizeof(GUID));

            //
            // Try the registry for CLASSNAME
            //
            ulLength = ulTransferLen = sizeof(szBuffer);

            configRet = PNP_GetDeviceRegProp(
                hBinding,
                InstancePath,
                CM_DRP_CLASSGUID,
                &ulRegDataType,
                (LPBYTE) szBuffer,
                &ulTransferLen,
                &ulLength,
                0
                );

            if (configRet == CR_SUCCESS) {

                GuidFromString(szBuffer, &classGuid);
            }

            if (!GuidEqual(&classGuid, &GUID_NULL) &&
                !GuidEqual(&classGuid, &GUID_DEVCLASS_UNKNOWN)) {

                ulLength = ulTransferLen = sizeof(szBuffer);

                configRet = PNP_GetDeviceRegProp(
                    hBinding,
                    InstancePath,
                    CM_DRP_CLASS,
                    &ulRegDataType,
                    (LPBYTE) szBuffer,
                    &ulTransferLen,
                    &ulLength,
                    0
                    );

            } else {

                configRet = CR_NO_SUCH_VALUE;
            }
        }
    }

    if (configRet == CR_SUCCESS && *szBuffer) {

        friendlyName = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulLength);
        if (friendlyName) {

            memcpy(friendlyName, szBuffer, ulLength);
        }

    } else {

        friendlyName = NULL;
    }

    return friendlyName;
}



ENUM_ACTION
QueueInstallationCallback(
    IN      LPCWSTR         DevInst,
    IN OUT  PVOID           Context
    )
/*++

Routine Description:

    This routine is called back for each devnode in a given subtree. It places
    each device node in that subtree into the installation queue so that it'll
    be reinstalled *if* appropriate (the installation side code checked the
    state of the devnode.)
    
Arguments:

    DevInst     InstancePath of current devnode.

    Context     A pointer to QI_CONTEXT data (needed to handle the single-level
                enum case.)

Return Value:

    ENUM_ACTION (Either EA_CONTINUE, EA_SKIP_SUBTREE, or EA_STOP_ENUMERATION)

--*/
{
    PQI_CONTEXT pqiContext;
    PPNP_INSTALL_ENTRY entry, current;
    CONFIGRET status;
    BOOL needsReinstall;
    HRESULT hr;

    pqiContext = (PQI_CONTEXT)Context;

    status = DevInstNeedsInstall(DevInst, FALSE, &needsReinstall);

    if (status != CR_SUCCESS) {
        //
        // The devnode disappeared out from under us. Skip it's subtree.
        //
        return EA_SKIP_SUBTREE;
    }

    if (needsReinstall) {
        //
        // This devnode needs installation. Allocate and initialize a new
        // device install entry block.
        //
        entry = (PPNP_INSTALL_ENTRY)
            HeapAlloc(
                ghPnPHeap, 0,
                sizeof(PNP_INSTALL_ENTRY));

        if (entry == NULL) {
            pqiContext->Status = CR_OUT_OF_MEMORY;
            return EA_STOP_ENUMERATION;
        }

        hr = StringCchCopy(entry->szDeviceId,
                           MAX_DEVICE_ID_LEN,
                           DevInst);
        ASSERT(SUCCEEDED(hr));

        entry->Next = NULL;
        entry->Flags = 0;

        //
        // Insert this entry in the device install list.
        //
        LockNotifyList(&InstallList.Lock);

        current = (PPNP_INSTALL_ENTRY)InstallList.Next;
        
        if (current == NULL) {
            InstallList.Next = entry;
        } else {
            while ((PPNP_INSTALL_ENTRY)current->Next != NULL) {
                current = (PPNP_INSTALL_ENTRY)current->Next;
            }
            current->Next = entry;
        }

        UnlockNotifyList(&InstallList.Lock);

        SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

        //
        // You might think we could skip the children if a parent is going to
        // be reinstalled. However, setupapi might decide not to tear down the
        // stack.
        //
    }

    //
    // If this is a single-level enumeration, we only want to touch the parent
    // and his immediate children.
    //
    if (pqiContext->HeadNodeSeen && pqiContext->SingleLevelEnumOnly) {

        return EA_SKIP_SUBTREE;
    }

    pqiContext->HeadNodeSeen = TRUE;

    return EA_CONTINUE;

} // QueueInstallationCallback



CONFIGRET
DevInstNeedsInstall(
    IN  LPCWSTR     DevInst,
    IN  BOOL        CheckReinstallConfigFlag,
    OUT BOOL       *NeedsInstall
    )
/*++

Routine Description:

    This routine determines whether a particular DevInst needs to be passed off
    to Setupapi for installation.

Arguments:

    DevInst -

        InstancePath of devnode to check.

    CheckReinstallConfigFlag -

        Specifies if the CONFIGFLAG_REINSTALL ConfigFlag should explicitly also
        be checked.

    NeedsInstall -

        Recieves TRUE if the devnode is present and needs to be installed, FALSE
        otherwise.

Return Value:

    CONFIGRET (if the devnode isn't present, this will be CR_NO_SUCH_DEVINST.)

--*/
{
    CONFIGRET status;
    ULONG ulStatus, ulProblem, ulConfig;

    //
    // Preinit
    //
    *NeedsInstall = FALSE;

    //
    // Is the device present?
    //
    status = GetDeviceStatus(DevInst, &ulStatus, &ulProblem);

    if (status == CR_SUCCESS) {

        //
        // Implementation note: In kernel-mode when we first process this
        // device instance, if there is no ConfigFlag value present, then we
        // set a problem of CM_PROB_NOT_CONFIGURED (this would always happen
        // for brand new device instances). If there is already a ConfigFlag
        // value of CONFIGFLAG_REINSTALL, then we set a problem of
        // CM_PROB_REINSTALL. Either problem will trigger an installation of
        // this device, the only difference is in how SetupDi routines handle
        // a failed installation: If ConfigFlag is CONFIGFLAG_NOT_CONFIGURED,
        // then a failed install will leave the ConfigFlag alone and set a
        // problem of CM_PROB_FAILED_INSTALL. If there is no ConfigFlag, then
        // ConfigFlag will be set to CONFIGFLAG_DISABLED.
        //

        if ((ulStatus & DN_HAS_PROBLEM) &&
            ((ulProblem == CM_PROB_REINSTALL) ||
             (ulProblem == CM_PROB_NOT_CONFIGURED))) {
            *NeedsInstall = TRUE;
        }

        ulConfig = GetDeviceConfigFlags(DevInst, NULL);

        //
        // In some cases, we explicitly need to also check for the
        // CONFIGFLAG_REINSTALL ConfigFlag, because the devnode may not yet have
        // the CM_PROB_REINSTALL problem code.
        //

        if ((CheckReinstallConfigFlag) &&
            (ulConfig & CONFIGFLAG_REINSTALL)) {
            *NeedsInstall = TRUE;
        }

        //
        // Addendum to Implementation note: If there is no ConfigFlag present,
        // but the device has the RawDeviceOK capability - OR - a matching
        // Service is found for the device in the CriticalDeviceDatabase, then
        // the device is started, but marked by kernel-mode with the
        // CONFIGFLAG_FINISH_INSTALL, indicating that user-mode should complete
        // the installation.
        //

        if (ulConfig & CONFIGFLAG_FINISH_INSTALL) {

            *NeedsInstall = TRUE;

            if (gbPreservePreInstall) {
                //
                // If we are expected to preserve critical device database /
                // device pre-installation settings, check if this finish
                // install device indicates installation is complete.
                //
                HKEY hKeyDevInst;
                ULONG ulValue, ulSize;

                if (RegOpenKeyEx(
                        ghEnumKey,
                        DevInst,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKeyDevInst) == ERROR_SUCCESS) {

                    ulValue = 0;
                    ulSize = sizeof(ulValue);

                    if (RegQueryValueEx(
                            hKeyDevInst,
                            pszRegValuePreservePreInstall,
                            NULL,
                            NULL,
                            (LPBYTE)&ulValue,
                            &ulSize) == ERROR_SUCCESS) {

                        if (ulValue == 1) {
                            //
                            // Unset the finish-install config flag.
                            //
                            ulConfig &= ~CONFIGFLAG_FINISH_INSTALL;

                            PNP_SetDeviceRegProp(
                                NULL,
                                DevInst,
                                CM_DRP_CONFIGFLAGS,
                                REG_DWORD,
                                (LPBYTE)&ulConfig,
                                sizeof(ulConfig),
                                0);

                            //
                            // Device does not need to be installed.
                            //
                            *NeedsInstall = FALSE;
                        }

                        //
                        // Delete the PreservePreInstall value.
                        //
                        RegDeleteValue(
                            hKeyDevInst,
                            pszRegValuePreservePreInstall);
                    }

                    RegCloseKey(hKeyDevInst);
                }
            }
        }

    } else if (IsRootDeviceID(DevInst)) {
        status = CR_SUCCESS;
    }

    return status;
}



PWSTR
BuildBlockedDriverList(
    IN OUT LPGUID  GuidList,
    IN     ULONG   GuidCount
    )
/*++

Routine Description:

    This routine builds a multi-sz list of GUIDs, based on the array of GUIDs
    supplied.  If no GUIDs were supplied, this routine returns a list of all
    drivers currently blocked by the system.

Arguments:

    GuidList - Address of the array of blocked driver GUIDs to create the
               multi-sz list from.  This argument may be NULL to retrieve a
               list of all drivers currently blocked by the system.

    GuidCount - Specifies the number of GUIDs in the array.  If GuidList is
                NULL, this argument must be 0.

Return Value:

    Returns a MultiSz list of blocked driver GUIDs, based on the supplied
    parameters.  Returns NULL if no GUIDs were supplied, and no GUIDs are
    currently being blocked by the system.

    If a multi-sz list was returned, the caller is responsible for freeing the
    associated buffer.

--*/

{
    CONFIGRET Status = STATUS_SUCCESS;
    ULONG ulLength, ulTemp;
    PBYTE Buffer = NULL;
    PWSTR MultiSzList = NULL, p;

    try {
        //
        // Validate parameters.
        //
        if (((!ARGUMENT_PRESENT(GuidList)) && (GuidCount != 0)) ||
            ((ARGUMENT_PRESENT(GuidList))  && (GuidCount == 0))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (GuidCount == 0) {
            //
            // We were called without a list of GUIDs, so we need to get the
            // list ourselves.
            //
            ASSERT(!ARGUMENT_PRESENT(GuidList));

            ulLength = 0;
            ulTemp = 0;

            Status = PNP_GetBlockedDriverInfo(
                NULL,
                NULL,
                &ulTemp,
                &ulLength,
                0);

            //
            // If no drivers are currently being blocked, or we encountered some
            // other failure, we have nothing to display, so just return.
            //
            if ((Status != CR_BUFFER_SMALL) || (ulLength == 0)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Allocate a buffer to retrieve the list of GUIDs.
            //
            Buffer = HeapAlloc(ghPnPHeap, 0, ulLength);
            if (Buffer == NULL) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Get the list of GUIDs for currently blocked drivers.
            //
            ulTemp = 0;

            Status = PNP_GetBlockedDriverInfo(
                NULL,
                Buffer,
                &ulTemp,
                &ulLength,
                0);

            //
            // We thought there was a list when we checked before, so we better
            // have one now.
            //
            ASSERT(Status != CR_BUFFER_SMALL);
            ASSERT(ulLength != 0);
            ASSERT(ulTemp != 0);

            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            //
            // Use the list we just retrieved.  Note that Buffer is non-NULL
            // when we allocate our own buffer for the array, so make sure we
            // free it below.
            //
            GuidCount = ulLength / sizeof(GUID);
            GuidList = (LPGUID)Buffer;
        }

        //
        // We must have a list of GUIDs to convert by this point.
        //
        ASSERT(GuidCount > 0);
        ASSERT(GuidList != NULL);

        //
        // Allocate a buffer to hold the multi-sz list of stringified GUIDs.
        //
        ulLength = (GuidCount*MAX_GUID_STRING_LEN + 1) * sizeof(WCHAR);

        MultiSzList = HeapAlloc(ghPnPHeap, 0, ulLength);
        if (MultiSzList == NULL) {
            Status = CR_FAILURE;
            goto Clean0;
        }
        ZeroMemory(MultiSzList, ulLength);

        //
        // Traverse the list of GUIDs, converting to strings as we go.
        //
        for (p = MultiSzList, ulTemp = 0;
             ulTemp < GuidCount;
             ulTemp++, p+= lstrlen(p) + 1) {

            if (StringFromGuid(
                (LPGUID)&(GuidList[ulTemp]), p,
                ((ulLength/sizeof(WCHAR)) - (ULONG)(p - MultiSzList))) != NO_ERROR) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }
        *p = L'\0';

        //
        // Success!!
        //
        Status = CR_SUCCESS;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in BuildBlockedDriverList!\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
        MultiSzList = MultiSzList;
    }

    //
    // Free the GUID list buffer, if we allocated one.
    //
    if (Buffer != NULL) {
        HeapFree(ghPnPHeap, 0, Buffer);
    }

    //
    // Don't return a list if we were unsuccessful.
    //
    if ((Status != CR_SUCCESS) && (MultiSzList != NULL)) {
        HeapFree(ghPnPHeap, 0, MultiSzList);
        MultiSzList = NULL;
    }

    return MultiSzList;

} // BuildBlockedDriverList

CONFIGRET
PNP_GetServerSideDeviceInstallFlags(
    IN handle_t     hBinding,
    PULONG          pulSSDIFlags,
    ULONG           ulFlags
    )

/*++

Routine Description:

   This is the RPC server entry point for the CMP_GetServerSideDeviceInstallFlags
   routine.

Arguments:

   hBinding        - RPC binding handle, not used.

   pulSSDIFlags    - A ULONG pointer, supplied by the caller.  This is used
                     to pass back the following server side device install
                     flags:
   
                     SSDI_REBOOT_PENDING - A reboot is pending from a server
                                           side device install.
   
   ulFlags           Not used, must be zero.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one of the
    CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (!ARGUMENT_PRESENT(pulSSDIFlags)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        *pulSSDIFlags = 0;

        //
        // SSDI_REBOOT_PENDING
        // Determine if a server side device install reboot is pending.
        //
        if (gServerSideDeviceInstallRebootNeeded) {
            *pulSSDIFlags |= SSDI_REBOOT_PENDING;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetServerSideDeviceInstallFlags



VOID
SendInvalidIDNotifications(
    IN ULONG ulSessionId
    )

/*++

Routine Description:

   This routine scans the entire device tree looking for devices with 
   DN_CHILD_WITH_INVALID_ID set. For all those, it sends notification 
   to hotplug. There is a race here between this function and the 
   notifications from kernel mode but that's probably ok 
   (double notifications).

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR szCurrentDevice[MAX_DEVICE_ID_LEN + 1], szNextDevice[MAX_DEVICE_ID_LEN + 1];
    ULONG ulStatus, ulProblem;
    CONFIGRET cr;
    PLUGPLAY_CONTROL_RELATED_DEVICE_DATA controlData;
    NTSTATUS ntStatus;
    HRESULT hr;


    //
    // Start from the device tree root.
    //
    if (FAILED(StringCchCopyEx(
                   szCurrentDevice,
                   SIZECHARS(szCurrentDevice),
                   pszRegRootEnumerator,
                   NULL, NULL,
                   STRSAFE_NULL_ON_FAILURE))) {
        return;
    }

    //
    // Walk the entire tree and send notification to show the balloon for every device with
    // DN_CHILD_WITH_INVALID_ID flag.
    //
    do {
        //
        // Check if this device has the DN_ bit set.
        //
        ulStatus = 0;

        cr = GetDeviceStatus(szCurrentDevice, &ulStatus, &ulProblem);

        if ((cr == CR_SUCCESS) &&
            (ulStatus & DN_CHILD_WITH_INVALID_ID)) {
            //
            // terminate MULTI_SZ.
            //
            szCurrentDevice[wcslen(szCurrentDevice) + 1] = UNICODE_NULL;

            //
            // Notify the user via hotplug.
            //
            SendHotplugNotification((LPGUID)&GUID_DEVICE_INVALID_ID,
                                    NULL,
                                    szCurrentDevice,
                                    &ulSessionId,
                                    0);
        }

        //
        // Get the child.
        //
        controlData.Relation = PNP_RELATION_CHILD;
        RtlInitUnicodeString(&controlData.TargetDeviceInstance, szCurrentDevice);
        controlData.RelatedDeviceInstance = szNextDevice;
        controlData.RelatedDeviceInstanceLength = SIZECHARS(szNextDevice) - 1;   // MAX_DEVICE_ID_LEN

        ntStatus = NtPlugPlayControl(PlugPlayControlGetRelatedDevice,
                                     &controlData,
                                     sizeof(controlData));

        if (NT_SUCCESS(ntStatus)) {

            if (FAILED(StringCchCopyEx(
                           szCurrentDevice,
                           SIZECHARS(szCurrentDevice),
                           szNextDevice,
                           NULL, NULL,
                           STRSAFE_NULL_ON_FAILURE))) {
                //
                // Unable to copy the device id, stop the walk.
                //
                break;
            }

            //
            // Continue the walk.
            //
            continue;
        }

        if (ntStatus != STATUS_NO_SUCH_DEVICE) {
            //
            // We failed for some other reason, stop the walk.
            //
            break;
        }

        //
        // If no child, get the sibling.
        //
        while (!IsRootDeviceID(szCurrentDevice)) {

            controlData.Relation = PNP_GET_SIBLING_DEVICE_INSTANCE;
            RtlInitUnicodeString(&controlData.TargetDeviceInstance, szCurrentDevice);
            controlData.RelatedDeviceInstance = szNextDevice;
            controlData.RelatedDeviceInstanceLength = SIZECHARS(szNextDevice) - 1;  // MAX_DEVICE_ID_LEN

            ntStatus = NtPlugPlayControl(PlugPlayControlGetRelatedDevice,
                                         &controlData,
                                         sizeof(controlData));
            if (NT_SUCCESS(ntStatus)) {
                hr = StringCchCopyEx(szCurrentDevice,
                                     SIZECHARS(szCurrentDevice),
                                     szNextDevice,
                                     NULL, NULL,
                                     STRSAFE_NULL_ON_FAILURE);
                ASSERT(SUCCEEDED(hr));
                break;
            }

            //
            // If no more siblings, go up the tree one level.
            //
            controlData.Relation = PNP_GET_PARENT_DEVICE_INSTANCE;
            RtlInitUnicodeString(&controlData.TargetDeviceInstance, szCurrentDevice);
            controlData.RelatedDeviceInstance = szNextDevice;
            controlData.RelatedDeviceInstanceLength = SIZECHARS(szNextDevice) - 1;  // MAX_DEVICE_ID_LEN

            ntStatus = NtPlugPlayControl(PlugPlayControlGetRelatedDevice,
                                         &controlData,
                                         sizeof(controlData));
            if (!NT_SUCCESS(ntStatus)) {
                //
                // No parent? Something went wrong or we completed our tree walk.
                //
                break;
            }

            hr = StringCchCopyEx(szCurrentDevice,
                                 SIZECHARS(szCurrentDevice),
                                 szNextDevice,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
        }

    } while (NT_SUCCESS(ntStatus) && (!IsRootDeviceID(szCurrentDevice)));

    return;

} // SendInvalidIDNotifications



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rlogconf.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rlogconf.c

Abstract:

    This module contains the server-side logical configuration APIs.

                  PNP_AddEmptyLogConf
                  PNP_FreeLogConf
                  PNP_GetFirstLogConf
                  PNP_GetNextLogConf
                  PNP_GetLogConfPriority

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"


//
// Prototypes used in this routine and in rresdes.c
//
CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    );

PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    );

PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    );

//
// Prototypes from rresdes.c
//

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    );

PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    );

//
// private prototypes
//

BOOL
MigrateObsoleteDetectionInfo(
    IN LPWSTR   pszDeviceID,
    IN HKEY     hLogConfKey
    );


//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY



CONFIGRET
PNP_AddEmptyLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulPriority,
    OUT PULONG     pulTag,
    IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine adds
  an empty logical configuration.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    ulPriority    Priority for new log conf.

    pulTag        Returns tag that identifies which log config this is.

    ulFlags       Describes type of log conf to add.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    LPBYTE      pList = NULL;
    ULONG       Index = 0, ulListSize = 0, ulAddListSize = 0;
    ULONG       RegDataType = 0;

    //------------------------------------------------------------------
    // The BOOT, ALLOC, and FORCED config types are stored in a registry
    // value name of the format XxxConfig and the BASIC, FILTERED, and
    // OVERRIDE configs are stored in a registr value name of the format
    // XxxConfigVector. XxxConfig values contain the actual resource
    // description (REG_RESOURCE_LIST, CM_RESOURCE_LIST) while
    // XxxConfigVector values contain a list of resource requirements
    // (REG_RESOURCE_REQUIREMENTS_LIST, IO_RESOURCE_REQUIREMENTS_LIST).
    //
    // The policy for using the log conf and res des APIs is:
    // - BOOT, ALLOC, and FORCED are defined to only have one log conf.
    // - Although callers always specify a complete XXX_RESOURCE type
    //   structure for the data when adding resource descriptors to
    //   a log conf, I will ignore the resource specific portion of
    //   the XXX_DES structure for FILTERED, BASIC, and OVERRIDE.
    //   Likewise I will ignore any XXX_RANGE structures for ALLOC,
    //   BOOT or FORCED log config types.
    //------------------------------------------------------------------

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS | PRIORITY_BIT)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, ulFlags & LOG_CONF_BITS, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        MigrateObsoleteDetectionInfo(pDeviceID, hKey);

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulFlags & LOG_CONF_BITS,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        //-----------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-----------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            if (Status != CR_SUCCESS || ulListSize == 0) {
                //
                // This is the first log conf of this type: create a new
                // log conf with an empty res des.
                //
                PCM_RESOURCE_LIST pResList = NULL;

                Status = CR_SUCCESS;
                ulListSize = sizeof(CM_RESOURCE_LIST) -
                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                pList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulListSize);
                if (pList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // initialize the config list header info
                //
                pResList = (PCM_RESOURCE_LIST)pList;
                pResList->Count = 1;
                pResList->List[0].InterfaceType                = InterfaceTypeUndefined;
                pResList->List[0].BusNumber                    = 0;
                pResList->List[0].PartialResourceList.Version  = NT_RESLIST_VERSION;
                pResList->List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
                pResList->List[0].PartialResourceList.Count    = 0;

            } else {
                //
                // There is already at least one log conf of this type, so add
                // a new empty log conf to the log conf list (priority ignored)
                //
                PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
                PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

                //
                // realloc the existing log conf list structs to hold another
                // log conf
                //
                ulAddListSize = sizeof(CM_FULL_RESOURCE_DESCRIPTOR) -
                                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                pResList = (PCM_RESOURCE_LIST)HeapReAlloc(ghPnPHeap, 0, pList,
                                                      ulListSize + ulAddListSize);
                if (pResList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pResList;

                //
                // Priorities are ignored for resource lists, so just add any
                // subsequent log confs to the end (they will be ignored by the
                // system anyway).
                //
                pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
                for (Index = 0; Index < pResList->Count; Index++) {
                    pRes = AdvanceResourcePtr(pRes);        // next lc
                }

                //
                // initialize the new empty log config
                //
                pResList->Count++;
                pRes->InterfaceType                = InterfaceTypeUndefined;
                pRes->BusNumber                    = 0;
                pRes->PartialResourceList.Version  = NT_RESLIST_VERSION;
                pRes->PartialResourceList.Revision = NT_RESLIST_REVISION;
                pRes->PartialResourceList.Count    = 0;

                *pulTag = Index;
            }
        }

        //-----------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-----------------------------------------------------------
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            if (Status != CR_SUCCESS || ulListSize == 0) {
                //
                // This is the first log conf of this type: create a new
                // log conf (IO_RESOURCE_LIST) with a single res des
                // (IO_RESOURCE_DESCRIPTOR) for the config data.
                //
                PIO_RESOURCE_REQUIREMENTS_LIST pReqList = NULL;
                PIO_RESOURCE_LIST              pReq = NULL;

                Status = CR_SUCCESS;
                ulListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

                pReqList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulListSize);
                if (pReqList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pReqList;

                //
                // initialize the config list header info
                //
                // There's room for one IO_RESOURCE_DESCRIPTOR embedded in
                // the IO_RESOURCE_LIST structure and by definition the first
                // one is a ConfigData type descriptor (user-mode always
                // specifies a priority value so we always have a ConfigData
                // struct).
                //
                pReqList->ListSize         = ulListSize;
                pReqList->InterfaceType    = InterfaceTypeUndefined;
                pReqList->BusNumber        = 0;
                pReqList->SlotNumber       = 0;
                pReqList->AlternativeLists = 1;

                pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]); // first lc
                pReq->Version  = NT_REQLIST_VERSION;
                pReq->Revision = NT_REQLIST_REVISION;
                pReq->Count    = 1;

                pReq->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
                pReq->Descriptors[0].Type = CmResourceTypeConfigData;
                pReq->Descriptors[0].u.ConfigData.Priority = ulPriority;

            } else {
                //
                // There is already at least one log conf of this type, so add
                // a new empty log conf to the log conf list (always at the end)
                //
                PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
                PIO_RESOURCE_LIST              pReq = NULL;

                //
                // realloc the existing log conf list structs to hold another
                // log conf
                //
                ulAddListSize = sizeof(IO_RESOURCE_LIST);

                pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)HeapReAlloc(ghPnPHeap, 0, pList,
                                                                   ulListSize + ulAddListSize);
                if (pReqList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pReqList;

                //
                // Skip past all the existing log confs to the new space at the
                // end of the reallocated buffer.
                //
                pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]); // first lc
                for (Index = 0; Index < pReqList->AlternativeLists; Index++) {
                    pReq = AdvanceRequirementsPtr(pReq);        // next lc
                }

                //
                // initialize the new empty log config (including the embedded
                // ConfigData structure).
                //
                pReqList->AlternativeLists++;
                pReqList->ListSize = ulListSize + ulAddListSize;

                pReq->Version  = NT_REQLIST_VERSION;
                pReq->Revision = NT_REQLIST_REVISION;
                pReq->Count    = 1;

                memset(&pReq->Descriptors[0], 0, sizeof(IO_RESOURCE_DESCRIPTOR));
                pReq->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
                pReq->Descriptors[0].Type = CmResourceTypeConfigData;
                pReq->Descriptors[0].u.ConfigData.Priority = ulPriority;

                *pulTag = Index;
            }

        } else {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Write out the new/updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize + ulAddListSize)
                         != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_AddEmptyLogConf



CONFIGRET
PNP_FreeLogConf(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      ulType,
    IN ULONG      ulTag,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine frees a
  logical configuration.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    ulType        Identifies which type of log conf is requested.

    ulTag         Identifies which log conf from the specified type
                  of log conf we want.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    LPBYTE      pList = NULL, pTemp = NULL, pNext = NULL;
    ULONG       RegDataType = 0, Index = 0, ulListSize = 0, ulSize = 0;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode (this
        // can't happen but Win95 does the check anyway)
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            //
            // if the device id or LogConf subkey is not in registry,
            // that's okay, by definition the log conf is freed since it
            // doesn't exist
            //
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // If the log conf to free is the one and only log conf of this
        // type then delete the corresponding registry values
        //
        if ((RegDataType == REG_RESOURCE_LIST &&
            ((PCM_RESOURCE_LIST)pList)->Count <= 1) ||
            (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST &&
            ((PIO_RESOURCE_REQUIREMENTS_LIST)pList)->AlternativeLists <= 1)) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_REGISTRY,
                       "PNP_FreeLogConf: Deleting Value %ws from Device %ws\r\n",
                       szValueName,
                       pDeviceID));

            RegDeleteValue(hKey, szValueName);
            goto Clean0;
        }

        //
        // There are other log confs besides the one to delete, so I'll
        // have to remove the log conf from the data structs and resave
        // to the registry
        //

        //-----------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-----------------------------------------------------------
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

            if (ulTag >= pResList->Count) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // skip to the log conf to be deleted
            //
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
            for (Index = 0; Index < ulTag; Index++) {
                pRes = AdvanceResourcePtr(pRes);      // next lc
            }

            if (ulTag == pResList->Count-1) {
                //
                // If deleting the last log conf in the list, just truncate it
                //
                ulListSize = (ULONG)((ULONG_PTR)pRes - (ULONG_PTR)pResList);

            } else {
                //
                // Shift remaining log confs (after the log conf to be deleted)
                // up in the list, writing over the log conf to be deleted
                //
                pNext = (LPBYTE)AdvanceResourcePtr(pRes);
                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);     // save in temp buffer
                memcpy(pRes, pTemp, ulSize);      // copy to deleted lc
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pRes);
            }

            //
            // update the log conf list header
            //
            pResList->Count--;
        }

        //-----------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-----------------------------------------------------------
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = NULL;

            if (ulTag >= pReqList->AlternativeLists) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // skip to the log conf to be deleted
            //
            pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]);    // first lc
            for (Index = 0; Index < ulTag; Index++) {
                pReq = AdvanceRequirementsPtr(pReq);           // next lc
            }

            //
            // If there's any log confs after the log conf that will be deleted,
            // then write them over the top of the log conf we're deleting and
            // truncate any left over data.
            //
            pNext = (LPBYTE)AdvanceRequirementsPtr(pReq);
            if (ulListSize > ((DWORD_PTR)pNext - (DWORD_PTR)pReqList)) {

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);     // save in temp buffer
                memcpy(pReq, pTemp, ulSize);      // copy to deleted lc
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReq);

            } else {
                //
                // No log confs trailing the log conf to be deleted so just
                // truncate it.
                //
                ulListSize = (ULONG)((ULONG_PTR)pReq - (ULONG_PTR)pReqList);
            }

            //
            // update the log conf list header
            //
            pReqList->AlternativeLists--;
            pReqList->ListSize = ulListSize;
        }

        //
        // Write out the updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType, pList,
                          ulListSize) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }

    return Status;

} // PNP_FreeLogConf



CONFIGRET
PNP_GetFirstLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulType,
    OUT PULONG     pulTag,
    IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine finds the
  first log conf of this type for this devnode.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Describes the type of log conf to find.

    pulTag        Returns tag that identifies which log config this is.

    ulFlags       Not used (but may specify LOG_CONF_BITS).

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    LPBYTE      pList = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters. The index of the "first" lc will always
        // be zero as long as at least one lc exists.
        //
        if (!ARGUMENT_PRESENT(pulTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_NO_MORE_LOG_CONF;
            goto Clean0;
        }

        //
        // Migrate any log conf data that might have been written to
        // registry by NT 4.0 Beta I code.
        //
        MigrateObsoleteDetectionInfo(pDeviceID, hKey);

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_NO_MORE_LOG_CONF;
            goto Clean0;
        }

        //
        // Specified log conf type contains Resource Data only
        //
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST pResList = (PCM_RESOURCE_LIST)pList;

            if (pResList->Count == 0) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // Specified log conf type contains requirements data only
        //
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;

            if (pReqList->AlternativeLists == 0) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetFirstLogConf



CONFIGRET
PNP_GetNextLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulType,
    IN  ULONG      ulCurrentTag,
    OUT PULONG     pulNextTag,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine finds the
  next log conf of this type for this devnode.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Specifies what type of log conf to retrieve.

    ulCurrent     Specifies current log conf in the enumeration.

    pulNext       Returns next log conf of this type for this device id.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0;
    LPBYTE      pList = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulNextTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulNextTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
           Status = CR_NO_MORE_LOG_CONF;
           goto Clean0;
        }

        //
        // Specified log conf type contains Resource Data only
        //
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST pResList = (PCM_RESOURCE_LIST)pList;

            if (ulCurrentTag >= pResList->Count) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // Is the "current" log conf the last log conf?
            //
            if (ulCurrentTag == pResList->Count - 1) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // Specified log conf type contains requirements data only
        //
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;

            if (ulCurrentTag >= pReqList->AlternativeLists) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // Is the "current" log conf the last log conf?
            //
            if (ulCurrentTag == pReqList->AlternativeLists - 1) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // There's at least one more log conf, return the next index value
        //
        *pulNextTag = ulCurrentTag + 1;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetNextLogConf



CONFIGRET
PNP_GetLogConfPriority(
    IN  handle_t hBinding,
    IN  LPWSTR   pDeviceID,
    IN  ULONG    ulType,
    IN  ULONG    ulTag,
    OUT PULONG   pPriority,
    IN  ULONG    ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  priority value assigned to the specified log config.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Specifies what type of log conf to retrieve priority for.

    ulCurrent     Specifies current log conf in the enumeration.

    pulNext       Returns priority value of specified log conf.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, index, count;
    LPBYTE      pList = NULL, pLogConf = NULL;
    PIO_RESOURCE_LIST              pReq = NULL;
    PIO_RESOURCE_DESCRIPTOR        pReqDes = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pPriority)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pPriority = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
           Status = CR_INVALID_LOG_CONF;
           goto Clean0;
        }

        //
        // Priority values are only stored in requirements lists
        //
        if (RegDataType != REG_RESOURCE_REQUIREMENTS_LIST) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, ulTag)) {
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

        //
        // Seek to the ConfigData res des, if any.
        //
        pReq = (PIO_RESOURCE_LIST)pLogConf;
        pReqDes = &pReq->Descriptors[0];        // first rd

        index = 0;
        count = 0;
        while (index < pReq->Count && pReqDes != NULL &&
               pReqDes->Type != CmResourceTypeConfigData) {

            pReqDes = AdvanceRequirementsDescriptorPtr(pReqDes, 1, pReq->Count - index, &count);
            index += count;  // index of actual rd's in the struct
        }

        if (pReqDes == NULL || pReqDes->Type != CmResourceTypeConfigData) {
            //
            // No config data so we can't determine the priority.
            //
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;

        }

        *pPriority = pReqDes->u.ConfigData.Priority;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetLogConfPriority




//------------------------------------------------------------------------
// Private Utility Routines
//------------------------------------------------------------------------


CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    )
{
    HRESULT hr;

    switch (ulLogConfType) {
        //
        // BOOT, ALLOC, FORCED only have a Config value
        //
        case BOOT_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueBootConfig,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        case ALLOC_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueAllocConfig,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        case FORCED_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueForcedConfig,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        //
        // FILTERED, BASIC, OVERRIDE only have a Vector value
        //
        case FILTERED_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueFilteredVector,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        case BASIC_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueBasicVector,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        case OVERRIDE_LOG_CONF:
            hr = StringCchCopyEx(pszValueName,
                                 64, // as defined by callers of GetLogConfData
                                 pszRegValueOverrideVector,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            ASSERT(SUCCEEDED(hr));
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        default:
            return CR_FAILURE;
    }

    //
    // retrieve the Log Conf registry data
    //
    if (RegQueryValueEx(hKey, pszValueName, NULL, NULL, NULL,
                        pulBufferSize) != ERROR_SUCCESS) {
        return CR_INVALID_LOG_CONF;
    }

    *ppBuffer = HeapAlloc(ghPnPHeap, 0, *pulBufferSize);
    if (*ppBuffer == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    if (RegQueryValueEx(hKey, pszValueName, NULL, NULL,
                        (LPBYTE)*ppBuffer, pulBufferSize) != ERROR_SUCCESS) {
        HeapFree(ghPnPHeap, 0, *ppBuffer);
        *ppBuffer = NULL;
        return CR_INVALID_LOG_CONF;
    }

    return CR_SUCCESS;

} // GetLogConfData



PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    )
{
    // Given a resource pointer, this routine advances to the beginning
    // of the next resource and returns a pointer to it. I assume that
    // at least one more resource exists in the resource list.

    LPBYTE  p = NULL;
    ULONG   LastResIndex = 0;


    if (pRes == NULL) {
        return NULL;
    }

    //
    // account for the size of the CM_FULL_RESOURCE_DESCRIPTOR
    // (includes the header plus a single imbedded
    // CM_PARTIAL_RESOURCE_DESCRIPTOR struct)
    //
    p = (LPBYTE)pRes + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

    //
    // account for any resource descriptors in addition to the single
    // imbedded one I've already accounted for (if there aren't any,
    // then I'll end up subtracting off the extra imbedded descriptor
    // from the previous step)
    //
    p += (pRes->PartialResourceList.Count - 1) *
         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    //
    // finally, account for any extra device specific data at the end of
    // the last partial resource descriptor (if any)
    //
    if (pRes->PartialResourceList.Count > 0) {

        LastResIndex = pRes->PartialResourceList.Count - 1;

        if (pRes->PartialResourceList.PartialDescriptors[LastResIndex].Type ==
                  CmResourceTypeDeviceSpecific) {

            p += pRes->PartialResourceList.PartialDescriptors[LastResIndex].
                       u.DeviceSpecificData.DataSize;
        }
    }

    return (PCM_FULL_RESOURCE_DESCRIPTOR)p;

} // AdvanceResourcePtr



PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    )
{
    LPBYTE   p = NULL;

    if (pReq == NULL) {
        return NULL;
    }

    //
    // account for the size of the IO_RESOURCE_LIST (includes header plus
    // a single imbedded IO_RESOURCE_DESCRIPTOR struct)
    //
    p = (LPBYTE)pReq + sizeof(IO_RESOURCE_LIST);

    //
    // account for any requirements descriptors in addition to the single
    // imbedded one I've already accounted for (if there aren't any,
    // then I'll end up subtracting off the extra imbedded descriptor
    // from the previous step)
    //
    p += (pReq->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);

    return (PIO_RESOURCE_LIST)p;

} // AdvanceRequirementsPtr



BOOL
MigrateObsoleteDetectionInfo(
    IN LPWSTR   pszDeviceID,
    IN HKEY     hLogConfKey
    )
{
    LONG    RegStatus = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    ULONG   ulSize = 0;
    LPBYTE  ptr = NULL;
    PCM_RESOURCE_LIST               pResList = NULL;
    PPrivate_Log_Conf               pDetectData = NULL;

    //
    // First, delete any of the log conf pairs that aren't valid any more
    //
    RegDeleteValue(hLogConfKey, TEXT("BootConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("AllocConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("ForcedConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("BasicConfig"));
    RegDeleteValue(hLogConfKey, TEXT("FilteredConfig"));
    RegDeleteValue(hLogConfKey, TEXT("OverrideConfig"));

    //
    // open the device instance key in the registry
    //
    if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                     KEY_READ | KEY_WRITE, &hKey) != ERROR_SUCCESS) {
        goto Clean0;    // nothing to migrate
    }

    //
    // If there is already a boot log config value then we can't
    // migrate any old detect info
    //
    RegStatus = RegQueryValueEx(hLogConfKey, pszRegValueBootConfig,
                                NULL, NULL, NULL, &ulSize);

    if (RegStatus == ERROR_SUCCESS  &&  ulSize > 0) {
        goto Clean0;    // can't migrate
    }

    //
    // retrieve any old detect signature info
    //
    RegStatus = RegQueryValueEx(hKey, pszRegValueDetectSignature,
                                NULL, NULL, NULL, &ulSize);

    if ((RegStatus != ERROR_SUCCESS) || (ulSize == 0)) {
        goto Clean0;    // nothing to migrate
    }

    pDetectData = (PPrivate_Log_Conf)HeapAlloc(ghPnPHeap, 0, ulSize);

    if (pDetectData == NULL) {
        goto Clean0;    // insufficient memory
    }

    RegStatus = RegQueryValueEx(hKey, pszRegValueDetectSignature,
                                NULL, NULL, (LPBYTE)pDetectData, &ulSize);

    if ((RegStatus != ERROR_SUCCESS) || (ulSize == 0)) {
        goto Clean0;    // nothing to migrate
    }

    //
    // Create an empty boot log conf and add this class specific data
    // to it
    //
    ulSize = pDetectData->LC_CS.CS_Header.CSD_SignatureLength +
             pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize +
             sizeof(GUID);

    pResList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, sizeof(CM_RESOURCE_LIST) + ulSize);

    if (pResList == NULL) {
        goto Clean0;    // insufficient memory
    }

    //
    // initialize resource list
    //
    pResList->Count = 1;
    pResList->List[0].InterfaceType                = InterfaceTypeUndefined;
    pResList->List[0].BusNumber                    = 0;
    pResList->List[0].PartialResourceList.Version  = NT_RESLIST_VERSION;
    pResList->List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
    pResList->List[0].PartialResourceList.Count    = 1;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
                          CmResourceTypeDeviceSpecific;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                          CmResourceShareUndetermined;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                          (USHORT)pDetectData->LC_CS.CS_Header.CSD_Flags;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.DataSize = ulSize;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.Reserved1 =
                          pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.Reserved2 =
                          pDetectData->LC_CS.CS_Header.CSD_SignatureLength;

    //
    // copy the legacy and class-specific signature data
    //
    ptr = (LPBYTE)(&pResList->List[0].PartialResourceList.PartialDescriptors[1]);

    memcpy(ptr,
           pDetectData->LC_CS.CS_Header.CSD_Signature +
           pDetectData->LC_CS.CS_Header.CSD_LegacyDataOffset,
           pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize);  // legacy data

    ptr += pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize;

    memcpy(ptr,
           pDetectData->LC_CS.CS_Header.CSD_Signature,
           pDetectData->LC_CS.CS_Header.CSD_SignatureLength); // signature

    ptr += pDetectData->LC_CS.CS_Header.CSD_SignatureLength;

    memcpy(ptr,
           &pDetectData->LC_CS.CS_Header.CSD_ClassGuid,
           sizeof(GUID));                                     // GUID

    //
    // Write out the new/updated log conf list to the registry
    //
    RegSetValueEx(hLogConfKey, pszRegValueBootConfig, 0,
                  REG_RESOURCE_LIST, (LPBYTE)pResList,
                  ulSize + sizeof(CM_RESOURCE_LIST));

    //
    // Delete the old detect signature info
    //
    RegDeleteValue(hKey, pszRegValueDetectSignature);

 Clean0:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pDetectData != NULL) {
        HeapFree(ghPnPHeap, 0, pDetectData);
    }
    if (pResList != NULL) {
        HeapFree(ghPnPHeap, 0, pResList);
    }

    return TRUE;

} // MigrateObsoleteDetectionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rregprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rregprop.c

Abstract:

    This module contains the server-side registry property routines.

         PNP_GetDeviceRegProp
         PNP_SetDeviceRegProp
         PNP_GetClassRegProp
         PNP_SetClassRegProp
         PNP_GetClassInstance
         PNP_CreateKey
         PNP_DeleteRegistryKey
         PNP_GetClassCount
         PNP_GetClassName
         PNP_DeleteClassKey
         PNP_GetInterfaceDeviceAlias
         PNP_GetInterfaceDeviceList
         PNP_GetInterfaceDeviceListSize
         PNP_RegisterDeviceClassAssociation
         PNP_UnregisterDeviceClassAssociation
         PNP_GetCustomDevProp

    This module contains the privately exported registry property routines.

         DeleteServicePlugPlayRegKeys

Author:

    Paula Tomlinson (paulat) 6-23-1995

Environment:

    User-mode only.

Revision History:

    23-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"

#include <accctrl.h>
#include <aclapi.h>


//
// private prototypes
//

LPWSTR
MapPropertyToString(
      ULONG ulProperty
      );

ULONG
MapPropertyToNtProperty(
      ULONG ulProperty
      );

HKEY
FindMostAppropriatePerHwIdSubkey(
    IN  HKEY    hDevKey,
    IN  REGSAM  samDesired,
    OUT LPWSTR  PerHwIdSubkeyName,
    OUT LPDWORD PerHwIdSubkeyLen
    );

//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghClassKey;     // Key to HKLM\CCC\System\Class - DO NOT MODIFY
extern HKEY ghPerHwIdKey;   // Key to HKLM\Software\Microsoft\Windows NT\CurrentVersion\PerHwIdStorage - DO NOT MODIFY


BYTE bDeviceReadPropertyFlags[] = {
    0,    // zero-index not used
    1,    // CM_DRP_DEVICEDESC
    1,    // CM_DRP_HARDWAREID
    1,    // CM_DRP_COMPATIBLEIDS
    0,    // CM_DRP_UNUSED0
    1,    // CM_DRP_SERVICE
    0,    // CM_DRP_UNUSED1
    0,    // CM_DRP_UNUSED2
    1,    // CM_DRP_CLASS
    1,    // CM_DRP_CLASSGUID
    1,    // CM_DRP_DRIVER
    1,    // CM_DRP_CONFIGFLAGS
    1,    // CM_DRP_MFG
    1,    // CM_DRP_FRIENDLYNAME
    1,    // CM_DRP_LOCATION_INFORMATION
    1,    // CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    1,    // CM_DRP_CAPABILITIES
    1,    // CM_DRP_UI_NUMBER
    1,    // CM_DRP_UPPERFILTERS
    1,    // CM_DRP_LOWERFILTERS
    1,    // CM_DRP_BUSTYPEGUID
    1,    // CM_DRP_LEGACYBUSTYPE
    1,    // CM_DRP_BUSNUMBER
    1,    // CM_DRP_ENUMERATOR_NAME
    1,    // CM_DRP_SECURITY
    0,    // CM_DRP_SECURITY_SDS - client property only (converted from CM_DRP_SECURITY)
    1,    // CM_DRP_DEVTYPE
    1,    // CM_DRP_EXCLUSIVE
    1,    // CM_DRP_CHARACTERISTICS
    1,    // CM_DRP_ADDRESS
    1,    // CM_DRP_UI_NUMBER_DESC_FORMAT
    1,    // CM_DRP_DEVICE_POWER_DATA
    1,    // CM_DRP_REMOVAL_POLICY
    1,    // CM_DRP_REMOVAL_POLICY_HW_DEFAULT
    1,    // CM_DRP_REMOVAL_POLICY_OVERRIDE
    1,    // CM_DRP_INSTALL_STATE
    1,    // CM_DRP_LOCATION_PATHS
};

BYTE bDeviceWritePropertyFlags[] = {
    0,    // zero-index not used
    1,    // CM_DRP_DEVICEDESC
    1,    // CM_DRP_HARDWAREID
    1,    // CM_DRP_COMPATIBLEIDS
    0,    // CM_DRP_UNUSED0
    1,    // CM_DRP_SERVICE
    0,    // CM_DRP_UNUSED1
    0,    // CM_DRP_UNUSED2
    1,    // CM_DRP_CLASS
    1,    // CM_DRP_CLASSGUID
    1,    // CM_DRP_DRIVER
    1,    // CM_DRP_CONFIGFLAGS
    1,    // CM_DRP_MFG
    1,    // CM_DRP_FRIENDLYNAME
    1,    // CM_DRP_LOCATION_INFORMATION
    0,    // CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    0,    // CM_DRP_CAPABILITIES
    0,    // CM_DRP_UI_NUMBER
    1,    // CM_DRP_UPPERFILTERS
    1,    // CM_DRP_LOWERFILTERS
    0,    // CM_DRP_BUSTYPEGUID
    0,    // CM_DRP_LEGACYBUSTYPE
    0,    // CM_DRP_BUSNUMBER
    0,    // CM_DRP_ENUMERATOR_NAME
    1,    // CM_DRP_SECURITY
    0,    // CM_DRP_SECURITY_SDS - client property only (converted to CM_DRP_SECURITY)
    1,    // CM_DRP_DEVTYPE
    1,    // CM_DRP_EXCLUSIVE
    1,    // CM_DRP_CHARACTERISTICS
    0,    // CM_DRP_ADDRESS
    1,    // CM_DRP_UI_NUMBER_DESC_FORMAT
    0,    // CM_DRP_DEVICE_POWER_DATA
    0,    // CM_DRP_REMOVAL_POLICY
    0,    // CM_DRP_REMOVAL_POLICY_HW_DEFAULT
    1,    // CM_DRP_REMOVAL_POLICY_OVERRIDE
    0,    // CM_DRP_INSTALL_STATE
    0,    // CM_DRP_LOCATION_PATHS
};

BYTE bClassReadPropertyFlags[] = {
    0,    // zero-index not used
    0,    // (CM_DRP_DEVICEDESC)
    0,    // (CM_DRP_HARDWAREID)
    0,    // (CM_DRP_COMPATIBLEIDS)
    0,    // (CM_DRP_UNUSED0)
    0,    // (CM_DRP_SERVICE)
    0,    // (CM_DRP_UNUSED1)
    0,    // (CM_DRP_UNUSED2)
    0,    // (CM_DRP_CLASS)
    0,    // (CM_DRP_CLASSGUID)
    0,    // (CM_DRP_DRIVER)
    0,    // (CM_DRP_CONFIGFLAGS)
    0,    // (CM_DRP_MFG)
    0,    // (CM_DRP_FRIENDLYNAME)
    0,    // (CM_DRP_LOCATION_INFORMATION)
    0,    // (CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME)
    0,    // (CM_DRP_CAPABILITIES)
    0,    // (CM_DRP_UI_NUMBER)
    0,    // (CM_DRP_UPPERFILTERS)
    0,    // (CM_DRP_LOWERFILTERS)
    0,    // (CM_DRP_BUSTYPEGUID)
    0,    // (CM_DRP_LEGACYBUSTYPE)
    0,    // (CM_DRP_BUSNUMBER)
    0,    // (CM_DRP_ENUMERATOR_NAME)
    1,    // CM_CRP_SECURITY
    0,    // CM_CRP_SECURITY_SDS - client property only (converted from CM_CRP_SECURITY)
    1,    // CM_CRP_DEVTYPE
    1,    // CM_CRP_EXCLUSIVE
    1,    // CM_CRP_CHARACTERISTICS
    0,    // (CM_DRP_ADDRESS)
    0,    // (CM_DRP_UI_NUMBER_DESC_FORMAT)
    0,    // (CM_DRP_DEVICE_POWER_DATA)
    0,    // (CM_DRP_REMOVAL_POLICY)
    0,    // (CM_DRP_REMOVAL_POLICY_HW_DEFAULT)
    0,    // (CM_DRP_REMOVAL_POLICY_OVERRIDE)
    0,    // (CM_DRP_INSTALL_STATE)
    0,    // (CM_DRP_LOCATION_PATHS)
};

BYTE bClassWritePropertyFlags[] = {
    0,    // zero-index not used
    0,    // (CM_DRP_DEVICEDESC)
    0,    // (CM_DRP_HARDWAREID)
    0,    // (CM_DRP_COMPATIBLEIDS)
    0,    // (CM_DRP_UNUSED0)
    0,    // (CM_DRP_SERVICE)
    0,    // (CM_DRP_UNUSED1)
    0,    // (CM_DRP_UNUSED2)
    0,    // (CM_DRP_CLASS)
    0,    // (CM_DRP_CLASSGUID)
    0,    // (CM_DRP_DRIVER)
    0,    // (CM_DRP_CONFIGFLAGS)
    0,    // (CM_DRP_MFG)
    0,    // (CM_DRP_FRIENDLYNAME)
    0,    // (CM_DRP_LOCATION_INFORMATION)
    0,    // (CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME)
    0,    // (CM_DRP_CAPABILITIES)
    0,    // (CM_DRP_UI_NUMBER)
    0,    // (CM_DRP_UPPERFILTERS)
    0,    // (CM_DRP_LOWERFILTERS)
    0,    // (CM_DRP_BUSTYPEGUID)
    0,    // (CM_DRP_LEGACYBUSTYPE)
    0,    // (CM_DRP_BUSNUMBER)
    0,    // (CM_DRP_ENUMERATOR_NAME)
    1,    // CM_CRP_SECURITY
    0,    // CM_CRP_SECURITY_SDS - client property only (converted to CM_CRP_SECURITY)
    1,    // CM_CRP_DEVTYPE
    1,    // CM_CRP_EXCLUSIVE
    1,    // CM_CRP_CHARACTERISTICS
    0,    // (CM_DRP_ADDRESS)
    0,    // (CM_DRP_UI_NUMBER_DESC_FORMAT)
    0,    // (CM_DRP_DEVICE_POWER_DATA)
    0,    // (CM_DRP_REMOVAL_POLICY)
    0,    // (CM_DRP_REMOVAL_POLICY_HW_DEFAULT)
    0,    // (CM_DRP_REMOVAL_POLICY_OVERRIDE)
    0,    // (CM_DRP_INSTALL_STATE)
    0,    // (CM_DRP_LOCATION_PATHS)
};


//
// compile-time property-array consistancy checks
//

C_ASSERT(CM_DRP_MIN == CM_CRP_MIN);
C_ASSERT(CM_DRP_MAX == CM_CRP_MAX);

C_ASSERT(ARRAY_SIZE(bDeviceReadPropertyFlags)  == (CM_DRP_MAX + 1));
C_ASSERT(ARRAY_SIZE(bDeviceWritePropertyFlags) == (CM_DRP_MAX + 1));
C_ASSERT(ARRAY_SIZE(bClassReadPropertyFlags)   == (CM_CRP_MAX + 1));
C_ASSERT(ARRAY_SIZE(bClassWritePropertyFlags)  == (CM_CRP_MAX + 1));





CONFIGRET
PNP_GetDeviceRegProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  pDeviceID,
    IN     ULONG    ulProperty,
    OUT    PULONG   pulRegDataType,
    OUT    LPBYTE   Buffer,
    IN OUT PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle, not used.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be read from.

   ulProperty        ID specifying which property (the registry value)
                     to get.

   pulRegDataType    Supplies the address of a variable that will receive
                     the registry data type for this property (i.e., the REG_*
                     constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulSize = 0;
    HKEY        hKey = NULL;
    LPWSTR      pPropertyName;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_PROPERTY_DATA ControlData;
    LPCWSTR     pSeparatorChar;
    ULONG       bufferLength;
    HRESULT     hr;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if ((!ARGUMENT_PRESENT(pulTransferLen)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);
        *pulTransferLen = 0;

        //
        // validate property is valid, and readable
        //
        if ((ulProperty < CM_DRP_MIN) ||
            (ulProperty > CM_DRP_MAX) ||
            (!bDeviceReadPropertyFlags[ulProperty])) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        switch (ulProperty) {
        //
        // for some fields, we need to ask from kernel-mode
        //
        case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:

            //
            // This property has special checking in kernel-mode to make
            // sure the supplied buffer length is even so round it down.
            //

            *pulLength &= ~1;
            // fall through

        case CM_DRP_BUSTYPEGUID:
        case CM_DRP_LEGACYBUSTYPE:
        case CM_DRP_BUSNUMBER:
        case CM_DRP_ADDRESS:
        case CM_DRP_DEVICE_POWER_DATA:
        case CM_DRP_REMOVAL_POLICY:
        case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        case CM_DRP_INSTALL_STATE:
        case CM_DRP_LOCATION_PATHS:

            if ((ulProperty == CM_DRP_DEVICE_POWER_DATA) ||
                (ulProperty == CM_DRP_BUSTYPEGUID)) {

                *pulRegDataType = REG_BINARY;

            } else if (ulProperty == CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME) {

                *pulRegDataType = REG_SZ;

            } else if (ulProperty == CM_DRP_LOCATION_PATHS) {

                *pulRegDataType = REG_MULTI_SZ;

            } else {
                //
                // CM_DRP_LEGACYBUSTYPE, CM_DRP_BUSNUMBER, CM_DRP_ADDRESS,
                // removal policy properties, and install state are all DWORDs
                //
                *pulRegDataType = REG_DWORD;
            }

            //
            // For these properties, we zero out unfilled space. This ensures
            // deterministic downlevel behavior if we expand any returned
            // structures in a later release.
            //
            bufferLength = *pulLength;

            //
            // Fill in a control structure for the device list info.
            //

            memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA));
            RtlInitUnicodeString(&ControlData.DeviceInstance, pDeviceID);
            ControlData.PropertyType = MapPropertyToNtProperty(ulProperty);
            ControlData.Buffer = Buffer;
            ControlData.BufferSize = bufferLength;

            //
            // Call kernel-mode to get the device property.
            //

            ntStatus = NtPlugPlayControl(PlugPlayControlProperty,
                                         &ControlData,
                                         sizeof(ControlData));
            if (NT_SUCCESS(ntStatus)) {

                ASSERT(bufferLength >= ControlData.BufferSize);
                if (bufferLength > ControlData.BufferSize) {

                    RtlZeroMemory(
                        Buffer + ControlData.BufferSize,
                        bufferLength - ControlData.BufferSize
                        );
                }

                *pulLength = ControlData.BufferSize;      // size in bytes
                *pulTransferLen = bufferLength; // size in bytes

            } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

                *pulLength = ControlData.BufferSize;
                *pulTransferLen = 0;
                Status = CR_BUFFER_SMALL;
            } else {
                *pulLength = 0;
                *pulTransferLen = 0;
                Status = MapNtStatusToCmError(ntStatus);
            }
            break;

        case CM_DRP_ENUMERATOR_NAME:

            *pulRegDataType = REG_SZ;

            pSeparatorChar = wcschr(pDeviceID, L'\\');

            ASSERT(pSeparatorChar != NULL);

            if (pSeparatorChar == NULL) {
                //
                // Couldn't find a path separator char in the device id.
                //
                Status=CR_INVALID_DATA;

            } else {
                //
                // Determine the number of bytes in the enumerator part.
                //
                ulSize = (ULONG)((PBYTE)pSeparatorChar - (PBYTE)pDeviceID) + sizeof(WCHAR);

                //
                // Fill in the caller's buffer, if it's large enough.
                //
                hr = StringCbCopyNEx((LPWSTR)Buffer,
                                     *pulLength,
                                     pDeviceID,
                                     ulSize - sizeof(WCHAR),
                                     NULL, NULL,
                                     STRSAFE_NULL_ON_FAILURE);

                if (SUCCEEDED(hr)) {
                    //
                    // Marshall the amount of data copied to the buffer
                    //
                    *pulTransferLen = ulSize;

                } else if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
                    //
                    // Buffer too small, marshall no data
                    //
                    Status = CR_BUFFER_SMALL;
                    *pulTransferLen = 0;

                } else {
                    //
                    // Some other failire, marshall no data.
                    //
                    Status = CR_FAILURE;
                    *pulTransferLen = 0;
                }

                //
                // Whether any data was transfered or not, return the size
                // required.
                //
                *pulLength = ulSize;
            }
            break;

        default:
            //
            // for all the other fields, just get them from the registry
            // open a key to the specified device id
            //
            if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ,
                                &hKey) != ERROR_SUCCESS) {

                hKey = NULL;            // ensure hKey stays NULL so we don't
                                        // erroneously try to close it.
                *pulLength = 0;         // no size info for caller
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }

            //
            // retrieve the string form of the property
            //
            pPropertyName = MapPropertyToString(ulProperty);

            if (pPropertyName) {
                //
                // retrieve property setting
                //
                if (*pulLength == 0) {
                    //
                    // if length of buffer passed in is zero, just looking
                    // for how big a buffer is needed to read the property
                    //
                    if (RegQueryValueEx(hKey, pPropertyName, NULL, pulRegDataType,
                                        NULL, pulLength) != ERROR_SUCCESS) {

                        *pulLength = 0;
                        Status = CR_NO_SUCH_VALUE;
                        goto Clean0;
                    }
                    Status = CR_BUFFER_SMALL;  // According to spec
                } else {
                    //
                    // retrieve the real property value, not just the size
                    //
                    RegStatus = RegQueryValueEx(hKey, pPropertyName, NULL,
                                                pulRegDataType, Buffer, pulLength);

                    if (RegStatus != ERROR_SUCCESS) {

                        if (RegStatus == ERROR_MORE_DATA) {

                            Status = CR_BUFFER_SMALL;
                            goto Clean0;
                        } else {

                            *pulLength = 0;         // no size info for caller
                            Status = CR_NO_SUCH_VALUE;
                            goto Clean0;
                        }
                    }
                }
            } else {

                Status = CR_NO_SUCH_VALUE;
                goto Clean0;
            }
        }

    Clean0:
        //
        // Data only needs to be transferred on CR_SUCCESS.
        //
        if (Status == CR_SUCCESS) {
            *pulTransferLen = *pulLength;
        } else if (ARGUMENT_PRESENT(pulTransferLen)) {
            *pulTransferLen = 0;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetDeviceRegProp



CONFIGRET
PNP_SetDeviceRegProp(
    IN handle_t   hBinding,
    IN LPCWSTR    pDeviceID,
    IN ULONG      ulProperty,
    IN ULONG      ulDataType,
    IN LPBYTE     Buffer,
    IN ULONG      ulLength,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Set_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be written to.

   ulProperty        ID specifying which property (the registry value)
                     to set.

   ulDataType        Supplies the registry data type for the specified
                     property (i.e., REG_SZ, etc).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    LPWSTR      pPropertyName;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // validate property is valid, and writeable
        //
        if ((ulProperty < CM_DRP_MIN) ||
            (ulProperty > CM_DRP_MAX) ||
            (!bDeviceWritePropertyFlags[ulProperty])) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // Currently the only writable fields are in the registry
        // however do any validation of bits
        // this isn't foolproof but can catch some common errors
        //

        switch(ulProperty) {
            case CM_DRP_CONFIGFLAGS: {

                DWORD flags = 0;
                ULONG ulStatus = 0;
                ULONG ulProblem = 0;

                //
                // DWORD value
                // try to catch setting CSCONFIGFLAG_DISABLED on a non-disableable device
                // although we should have validated the size stuff elsewhere, it was at
                // client-side so double-check here
                //
                if (ulDataType != REG_DWORD || ulLength != sizeof(DWORD) || Buffer == NULL) {
                    Status = CR_INVALID_DATA;
                    goto Clean0;
                }
                flags = *(DWORD*)Buffer;
                if(flags & CONFIGFLAG_DISABLED) {
                    //
                    // we're interested in checking this decision to disable device
                    //

                    if (IsRootDeviceID(pDeviceID)) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "UMPNPMGR: Cannot set CONFIGFLAG_DISABLED for root device - did caller try to disable device first?\n"));

                        Status = CR_NOT_DISABLEABLE;
                        goto Clean0;
                    }

                    if((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem)==CR_SUCCESS)
                        && !(ulStatus & DN_DISABLEABLE)) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "UMPNPMGR: Cannot set CONFIGFLAG_DISABLED for non-disableable device - did caller try to disable device first?\n"));

                        Status = CR_NOT_DISABLEABLE;
                        goto Clean0;
                    }
                    //
                    // ok, looks like we can proceed to disable device
                    //
                }
                break;
            }

            default:
                //
                // No special handling on other properties
                //
                break;
        }

        //
        // open a key to the specified device id
        //
        if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);

        if (pPropertyName) {
            //
            // set (or delete) the property value
            //
            if (ulLength == 0) {

                RegStatus = RegDeleteValue(hKey, pPropertyName);
            }
            else {

                RegStatus = RegSetValueEx(hKey, pPropertyName, 0, ulDataType,
                                          Buffer, ulLength);
            }
            if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        } else {

            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // note that changes do not get applied until a reboot / query-remove-remove
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_SetDeviceRegProp



CONFIGRET
PNP_GetClassRegProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  ClassGuid,
    IN     ULONG    ulProperty,
    OUT    PULONG   pulRegDataType  OPTIONAL,
    OUT    LPBYTE   Buffer,
    IN OUT PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle, not used.

   ClassGuid         Supplies a string containing the Class Guid
                     whose property will be read from (Get) or written
                     to (Set).

   ulProperty        ID specifying which property (the registry value)
                     to get or set.

   pulRegDataType    Optionally, supplies the address of a variable that
                     will receive the registry data type for this property
                     (i.e., the REG_* constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKeyClass = NULL;
    HKEY        hKeyProps = NULL;
    LPWSTR      pPropertyName;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);
        *pulTransferLen = 0;

        //
        // validate property is valid, and readable
        //
        if ((ulProperty < CM_CRP_MIN) ||
            (ulProperty > CM_CRP_MAX) ||
            (!bClassReadPropertyFlags[ulProperty])) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // open a key to the specified GUID - this should have already been created
        //
        if (RegOpenKeyEx(ghClassKey, ClassGuid, 0, KEY_READ,
                         &hKeyClass) != ERROR_SUCCESS) {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller

            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }
        //
        // open a key to parameters - if not created, there's no params
        //
        if (RegOpenKeyEx(hKeyClass, pszRegKeyProperties, 0, KEY_READ,
                         &hKeyProps) != ERROR_SUCCESS) {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller

            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);

        if (pPropertyName) {
            //
            // retrieve property setting
            //
            if (*pulLength == 0) {
                //
                // if length of buffer passed in is zero, just looking
                // for how big a buffer is needed to read the property
                //
                *pulTransferLen = 0;

                if (RegQueryValueEx(hKeyProps, pPropertyName, NULL, pulRegDataType,
                                    NULL, pulLength) != ERROR_SUCCESS) {
                    *pulLength = 0;
                    Status = CR_NO_SUCH_VALUE;
                    goto Clean0;
                }

                Status = CR_BUFFER_SMALL;  // According to spec
            } else {
                //
                // retrieve the real property value, not just the size
                //
                RegStatus = RegQueryValueEx(hKeyProps, pPropertyName, NULL,
                                            pulRegDataType, Buffer, pulLength);

                if (RegStatus != ERROR_SUCCESS) {

                    if (RegStatus == ERROR_MORE_DATA) {
                        *pulTransferLen = 0;    // no output data to marshal
                        Status = CR_BUFFER_SMALL;
                        goto Clean0;
                    }
                    else {
                        *pulTransferLen = 0;    // no output data to marshal
                        *pulLength = 0;         // no size info for caller
                        Status = CR_NO_SUCH_VALUE;
                        goto Clean0;
                    }
                }
                *pulTransferLen = *pulLength;
            }
        } else {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyProps = hKeyProps;
        hKeyClass = hKeyClass;
    }

    if (hKeyProps != NULL) {
        RegCloseKey(hKeyProps);
    }

    if (hKeyClass != NULL) {
        RegCloseKey(hKeyClass);
    }

    return Status;

} // PNP_GetClassRegProp



CONFIGRET
PNP_SetClassRegProp(
    IN handle_t   hBinding,
    IN LPCWSTR    ClassGuid,
    IN ULONG      ulProperty,
    IN ULONG      ulDataType,
    IN LPBYTE     Buffer,
    IN ULONG      ulLength,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Set_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle.

   ClassGuid         Supplies a string containing the Class Guid
                     whose property will be read from (Get) or written
                     to (Set).

   ulProperty        ID specifying which property (the registry value)
                     to get or set.

   ulDataType        Supplies the registry data type for the specified
                     property (i.e., REG_SZ, etc).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKeyClass = NULL;
    HKEY        hKeyProps = NULL;
    LPWSTR      pPropertyName;
    DWORD       dwError;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate property is valid, and writeable
        //
        if ((ulProperty < CM_CRP_MIN) ||
            (ulProperty > CM_CRP_MAX) ||
            (!bClassWritePropertyFlags[ulProperty])) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // Currently the only writable fields are in the registry
        //

        //
        // open a key to the specified GUID - this should have already been created
        //
        if (RegOpenKeyEx(ghClassKey, ClassGuid, 0, KEY_READ,
                         &hKeyClass) != ERROR_SUCCESS) {

            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }

        //
        // open a key to parameters - if not created, we need to create it with priv permissions
        // this is harmless for a delete, since we "need" it anyway
        //
        if (RegOpenKeyEx(hKeyClass, pszRegKeyProperties, 0, KEY_ALL_ACCESS,
                         &hKeyProps) != ERROR_SUCCESS) {

            //
            // properties key doesn't exist
            // we need to create it with secure access (system-only access)
            // we don't expect to do this often
            //
            PSID                pSystemSid = NULL;
            PACL                pSystemAcl = NULL;
            SECURITY_DESCRIPTOR SecDesc;
            SECURITY_ATTRIBUTES SecAttrib;
            BOOL                bSuccess;
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
            EXPLICIT_ACCESS     ExplicitAccess;

            bSuccess = AllocateAndInitializeSid( &NtAuthority,
                                                 1, // one authority - SYSTEM
                                                 SECURITY_LOCAL_SYSTEM_RID, // access to system only
                                                 0, 0, 0, 0, 0, 0, 0,  // unused authority locations
                                                 &pSystemSid);

            if (bSuccess) {
                ExplicitAccess.grfAccessMode = SET_ACCESS;
                ExplicitAccess.grfInheritance = CONTAINER_INHERIT_ACE;
                ExplicitAccess.Trustee.pMultipleTrustee = NULL;
                ExplicitAccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
                ExplicitAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
                ExplicitAccess.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                ExplicitAccess.grfAccessPermissions = KEY_ALL_ACCESS;
                ExplicitAccess.Trustee.ptstrName = (LPWSTR)pSystemSid;

                dwError = SetEntriesInAcl( 1,
                                           &ExplicitAccess,
                                           NULL,
                                           &pSystemAcl );
                if (dwError != ERROR_SUCCESS) {
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                bSuccess =
                    InitializeSecurityDescriptor(
                        &SecDesc, SECURITY_DESCRIPTOR_REVISION);
            }

            if (bSuccess) {
                bSuccess =
                    SetSecurityDescriptorDacl(
                        &SecDesc,
                        TRUE,
                        pSystemAcl,
                        FALSE);
            }

            //
            // mostly a setup requirement, but good to have
            // effectively is a pruning point in the security tree
            // child keys inherit our permissions, but not our parents permissions
            //
            if (bSuccess) {
                if (!SetSecurityDescriptorControl(
                        &SecDesc,
                        SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED,
                        SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED)) {
                    //
                    // non fatal if this fails
                    //
                    NOTHING;
                }
            }
            if (bSuccess) {
                bSuccess = IsValidSecurityDescriptor( &SecDesc );
            }

            if (bSuccess) {
                SecAttrib.nLength = sizeof(SecAttrib);
                SecAttrib.bInheritHandle = FALSE;
                SecAttrib.lpSecurityDescriptor = &SecDesc;

                if(RegCreateKeyEx(hKeyClass, pszRegKeyProperties, 0, NULL, REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS, &SecAttrib, &hKeyProps, NULL) != ERROR_SUCCESS) {
                    bSuccess = FALSE;
                }
            }

            //
            // now cleanup
            //
            if (pSystemAcl) {
                LocalFree(pSystemAcl);
            }
            if (pSystemSid) {
                FreeSid(pSystemSid);
            }

            if (bSuccess == FALSE) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);

        if (pPropertyName) {
            //
            // set (or delete) the property value
            //
            if (ulLength == 0) {

                RegStatus = RegDeleteValue(hKeyProps, pPropertyName);
            }
            else {
                RegStatus = RegSetValueEx(hKeyProps, pPropertyName, 0, ulDataType,
                                          Buffer, ulLength);
            }
            if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        } else {

            Status = CR_FAILURE;
            goto Clean0;
        }
        //
        // note that changes do not get applied until a reboot / query-remove-remove
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyProps = hKeyProps;
        hKeyClass = hKeyClass;
    }

    if (hKeyProps != NULL) {
        RegCloseKey(hKeyProps);
    }

    if (hKeyClass != NULL) {
        RegCloseKey(hKeyClass);
    }

    return Status;

} // PNP_SetClassRegProp



CONFIGRET
PNP_GetClassInstance(
   IN  handle_t hBinding,
   IN  LPCWSTR  pDeviceID,
   OUT LPWSTR   pszClassInstance,
   IN  ULONG    ulLength
   )

/*++

Routine Description:

  This is the RPC private server entry point, it doesn't not directly
  map one-to-one to any CM routine.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         Supplies a string containing the device instance

   pszClassInstance  String to return the class instance in

   ulLength          Size of the pszClassInstance string in chars

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_ACCESS_DENIED,
      CR_REGISTRY_ERROR.

--*/

{
    CONFIGRET   Status;
    WCHAR       szInstanceStr[5], szClassGuid[GUID_STRING_LEN];
    WCHAR       szClassInstance[GUID_STRING_LEN + 5];
    DWORD       disposition;
    ULONG       ulType, ulTransferLength, ulTempLength, ulInstance;
    HKEY        hClassKey = NULL, hInstanceKey = NULL;
    HRESULT     hr;
    size_t      ClassInstanceLen;


    try {
        //
        // Validate parameters
        //
        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Get the class instance key name, if one exists.
        //
        ulTempLength = ulLength * sizeof(WCHAR);
        ulTransferLength = ulTempLength;

        Status = PNP_GetDeviceRegProp(hBinding,
                                      pDeviceID,
                                      CM_DRP_DRIVER,
                                      &ulType,
                                      (LPBYTE)pszClassInstance,
                                      &ulTransferLength,
                                      &ulTempLength,
                                      0);

        //
        // The only failure case we will handle beyond attempting to retrieve an
        // existing CM_DRP_DRIVER property for this device is if no such value
        // exists.  Note that any failure to attempt to create a new class
        // instance key below should always return CR_NO_SUCH_VALUE to the
        // caller.
        //
        if (Status != CR_NO_SUCH_VALUE) {
            goto Clean0;
        }

        //
        // Create the class instance since one does not already exist.  To do
        // this, we'll need to create new registry keys, and set a new registry
        // property for this device, both of which require "write" access.  Up
        // until now, only "read" access was required, so make the additional
        // check now.
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {

            //
            // The client does not have access to create a class instance value
            // for this device.  Although the initial request was only to
            // retrieve an existing value, the PNP_GetClassInstance API is used
            // only to attempt to explicitly create a new "Driver" value, and
            // does not directly correlate to any client CM API.  We can return
            // "access denied" to the client, because it should be expected by
            // the caller when modifying persistent state on the server.
            //
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Get the class GUID property for the key to create the instance under.
        //
        ulTempLength = sizeof(szClassGuid);
        ulTransferLength = ulTempLength;

        Status = PNP_GetDeviceRegProp(hBinding,
                                      pDeviceID,
                                      CM_DRP_CLASSGUID,
                                      &ulType,
                                      (LPBYTE)szClassGuid,
                                      &ulTransferLength,
                                      &ulTempLength,
                                      0);
        if (Status != CR_SUCCESS) {
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

        //
        // Open the class key.
        //
        if (RegOpenKeyEx(
                ghClassKey, szClassGuid, 0,
                KEY_READ | KEY_WRITE,
                &hClassKey) != ERROR_SUCCESS) {
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }


        for (ulInstance = 0; ulInstance <= 9999; ulInstance++) {
            //
            // Find the first available class instance key.
            //
            hr = StringCchPrintfEx(szInstanceStr,
                                   SIZECHARS(szInstanceStr),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   L"%04u",
                                   ulInstance);
            ASSERT(SUCCEEDED(hr));

            if (FAILED(hr)) {
                Status = CR_NO_SUCH_VALUE;
                break;
            }

            if (RegCreateKeyEx(
                    hClassKey, szInstanceStr, 0, NULL,
                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hInstanceKey, &disposition) != ERROR_SUCCESS) {
                Status = CR_NO_SUCH_VALUE;
                break;
            }

            RegCloseKey(hInstanceKey);
            hInstanceKey = NULL;

            if (disposition != REG_CREATED_NEW_KEY) {
                //
                // Opened an existing class instance key. Try the next one.
                //
                continue;
            }


            //
            // We created a new class instance key.  Set the CM_DRP_DRIVER value
            // for this device, and return.
            //
            hr = StringCchPrintf(szClassInstance,
                                 SIZECHARS(szClassInstance),
                                 L"%s\\%s",
                                 szClassGuid,
                                 szInstanceStr);
            ASSERT(SUCCEEDED(hr));

            if (FAILED(hr)) {
                RegDeleteKey(hClassKey, szInstanceStr);
                Status = CR_NO_SUCH_VALUE;
                break;
            }

            ClassInstanceLen = 0;
            hr = StringCchLength(szClassInstance,
                                 SIZECHARS(szClassInstance),
                                 &ClassInstanceLen);

            ulTempLength = (ULONG)((ClassInstanceLen + 1)*sizeof(WCHAR));

            Status = PNP_SetDeviceRegProp(hBinding,
                                          pDeviceID,
                                          CM_DRP_DRIVER,
                                          REG_SZ,
                                          (LPBYTE)szClassInstance,
                                          ulTempLength,
                                          0);

            //
            // If we failed to set the devnode property, delete the registry key
            // we just created, or else we'll end up orphaning it.
            //
            if (Status != CR_SUCCESS) {
                RegDeleteKey(hClassKey, szInstanceStr);
                Status = CR_NO_SUCH_VALUE;
                break;
            }

            ASSERT(Status == CR_SUCCESS);

            //
            // Now that we've successfully set the new class instance value for
            // this device, attempt to retreive it again, using the buffer
            // supplied by the caller.
            //

            ulTempLength = ulLength * sizeof(WCHAR);
            ulTransferLength = ulTempLength;

            Status = PNP_GetDeviceRegProp(hBinding,
                                          pDeviceID,
                                          CM_DRP_DRIVER,
                                          &ulType,
                                          (LPBYTE)pszClassInstance,
                                          &ulTransferLength,
                                          &ulTempLength,
                                          0);

            //
            // We just set the property, so we know the value exists.
            //
            ASSERT(Status != CR_NO_SUCH_VALUE);
            ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
            break;
        }

        //
        // If we exhausted all possibile class instance keys, report that no
        // class instance exists for this device.
        //

        if (ulInstance > 9999) {
            Status = CR_NO_SUCH_VALUE;
        }

        //
        // Close the class key.
        //

        RegCloseKey(hClassKey);
        hClassKey = NULL;

        ASSERT(hInstanceKey == NULL);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hClassKey = hClassKey;
        hInstanceKey = hInstanceKey;
    }

    if (hClassKey != NULL) {
        RegCloseKey(hClassKey);
    }

    if (hInstanceKey != NULL) {
        RegCloseKey(hInstanceKey);
    }

    return Status;

} // PNP_GetClassInstance



CONFIGRET
PNP_CreateKey(
    IN handle_t hBinding,
    IN LPCWSTR  pszDeviceID,
    IN REGSAM   samDesired,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Open_DevNode_Key_Ex
  routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   samDesired        Not used.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET                  Status = CR_SUCCESS;
    LONG                       RegStatus = ERROR_SUCCESS;
    HKEY                       hKeyDevice = NULL, hKey = NULL;
    ULONG                      ulSize = 0, i = 0;
    BOOL                       bHasDacl, bStatus;
    SECURITY_DESCRIPTOR        NewSecDesc;
    ACL_SIZE_INFORMATION       AclSizeInfo;
    SID_IDENTIFIER_AUTHORITY   Authority = SECURITY_NT_AUTHORITY;
    PSECURITY_DESCRIPTOR       pSecDesc = NULL;
    PACL                       pDacl = NULL, pNewDacl = NULL;
    PSID                       pAdminSid = NULL;
    PACCESS_ALLOWED_ACE        pAce = NULL;

    UNREFERENCED_PARAMETER(samDesired);

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the specified device id
        //
        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ, &hKeyDevice);

        if (RegStatus != ERROR_SUCCESS) {

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // create the key with security inherited from parent key. Note
        // that I'm not using passed in access mask, in order to set the
        // security later, it must be created with KEY_ALL_ACCESS.
        //
        RegStatus = RegCreateKeyEx( hKeyDevice, pszRegKeyDeviceParam, 0,
                                    NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                    NULL, &hKey, NULL);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // add admin-full privilege to the inherited security info
        //-------------------------------------------------------------
        //
        //
        // NOTE: we don't need to do this unless the key was newly created.  In
        // theory we only get here when the key doesn't already exist.  However
        // there is a remote chance of two threads getting here simultaneously.  If
        // this happens we would end up with two admin full control ACEs.
        //


        //
        // create the admin-full SID
        //
        if (!AllocateAndInitializeSid( &Authority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0, 0, 0, 0, 0, 0,
                                       &pAdminSid)) {
            Status = CR_FAILURE;
            goto Clean0;
        }


        //
        // get the current security descriptor for the key
        //
        RegStatus = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       NULL, &ulSize);


        if (RegStatus != ERROR_INSUFFICIENT_BUFFER &&
            RegStatus != ERROR_SUCCESS) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        pSecDesc = HeapAlloc(ghPnPHeap, 0, ulSize);

        if (pSecDesc == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        RegStatus = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       pSecDesc, &ulSize);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // get the current DACL
        //
        if (!GetSecurityDescriptorDacl(pSecDesc, &bHasDacl, &pDacl, &bStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // create a new absolute security descriptor and DACL
        //
        if (!InitializeSecurityDescriptor( &NewSecDesc,
                                           SECURITY_DESCRIPTOR_REVISION)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // calculate the size of the new DACL
        //
        ZeroMemory(&AclSizeInfo, sizeof(AclSizeInfo));

        if (bHasDacl) {
            if (!GetAclInformation( pDacl, &AclSizeInfo,
                                    sizeof(ACL_SIZE_INFORMATION),
                                    AclSizeInformation)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            ulSize = AclSizeInfo.AclBytesInUse;
        } else {
            ulSize = sizeof(ACL);
        }

        ulSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD);

        //
        // create and initialize the new DACL
        //
        pNewDacl = HeapAlloc(ghPnPHeap, 0, ulSize);

        if (pNewDacl == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        if (!InitializeAcl(pNewDacl, ulSize, ACL_REVISION2)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // copy the current (original) DACL into this new one
        //
        if (bHasDacl) {

            for (i = 0; i < AclSizeInfo.AceCount; i++) {

                if (!GetAce(pDacl, i, (LPVOID *)&pAce)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                //
                // We need to skip copying any ACEs which refer to the Administrator
                // to ensure that our full control ACE is the one and only.
                //
                if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                    pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE) ||
                    !EqualSid((PSID)&pAce->SidStart, pAdminSid)) {

                    if (!AddAce( pNewDacl, ACL_REVISION2, (DWORD)~0U, pAce,
                                pAce->Header.AceSize)) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }
                }
            }
        }

        //
        // and my new admin-full ace to this new DACL
        //
        if (!AddAccessAllowedAceEx( pNewDacl, ACL_REVISION2,
                                    CONTAINER_INHERIT_ACE, KEY_ALL_ACCESS,
                                    pAdminSid)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Set the new DACL in the absolute security descriptor
        //
        if (!SetSecurityDescriptorDacl(&NewSecDesc, TRUE, pNewDacl, FALSE)) {
            Status = CR_FAILURE;
            goto Clean0;
        }
        //
        // validate the new security descriptor
        //
        if (!IsValidSecurityDescriptor(&NewSecDesc)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // apply the new security back to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       &NewSecDesc);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyDevice = hKeyDevice;
        hKey = hKey;
        pAdminSid = pAdminSid;
        pNewDacl = pNewDacl;
        pSecDesc = pSecDesc;
    }

    if (hKeyDevice != NULL) {
        RegCloseKey(hKeyDevice);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pAdminSid != NULL) {
        FreeSid(pAdminSid);
    }

    if (pNewDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pNewDacl);
    }

    if (pSecDesc != NULL) {
        HeapFree(ghPnPHeap, 0, pSecDesc);
    }

    return Status;

} // PNP_CreateKey



CONFIGRET
PNP_DeleteRegistryKey(
      IN handle_t    hBinding,
      IN LPCWSTR     pszDeviceID,
      IN LPCWSTR     pszParentKey,
      IN LPCWSTR     pszChildKey,
      IN ULONG       ulFlags
      )
/*++

Routine Description:

  This is the RPC server entry point for the CM_Delete_DevNode_Key
  routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   pszParentKey      Supplies the parent registry path of the key to be
                     deleted.

   pszChildKey       Supplies the subkey to be deleted.

   ulFlags           If 0xFFFFFFFF then delete for all profiles


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR.

--*/

{
    CONFIGRET   Status = ERROR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szProfile[MAX_PROFILE_ID_LEN];
    PWCHAR      pszRegStr = NULL, pszRegKey1 = NULL, pszRegKey2 = NULL;
    ULONG       ulIndex = 0, ulSize = 0;
    BOOL        bPhantom = FALSE;
    ULONG       ulStatus, ulProblem;
    PWCHAR      pszFormatString = NULL;
    HRESULT     hr;


    //
    // Note, the service currently cannot access the HKCU branch, so I
    // assume the keys specified are under HKEY_LOCAL_MACHINE.
    //

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        // (currently, 0 and -1 are the only accepted flags.)
        //
        if ((ulFlags != 0) &&
            (ulFlags != 0xFFFFFFFF)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // pszParentKey is a registry path to the pszChildKey parameter.
        // pszChildKey may be a single path or a compound path, a compound
        // path is specified if all those subkeys should be deleted (or
        // made volatile). Note that for real keys we never modify anything
        // but the lowest level private key.
        //
        if (!ARGUMENT_PRESENT(pszParentKey) ||
            !ARGUMENT_PRESENT(pszChildKey)  ||
            ((lstrlen(pszParentKey) + 1) > MAX_CM_PATH) ||
            ((lstrlen(pszChildKey)  + 1) > MAX_CM_PATH)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Allocate registry path buffers.
        //
        pszRegStr = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegKey1 = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegKey1 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegKey2 = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegKey2 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Is the device a phantom?
        //
        bPhantom = IsDevicePhantom((LPWSTR)pszDeviceID) ||
                   GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) != CR_SUCCESS ||
                   !(ulStatus & DN_DRIVER_LOADED);

        if (!bPhantom) {
            //
            // for a real key, we never modify anything but the key
            // where private info is so split if compound. This may
            // end up leaving a dead device key around in some cases
            // but another instance of that device could show at any
            // time so we can't make it volatile.
            //
            if (SplitString(pszChildKey,
                            TEXT('\\'),
                            1,
                            pszRegStr,
                            2 * MAX_CM_PATH,
                            pszRegKey2,
                            2 * MAX_CM_PATH)) {
                //
                // compound key, only the last subkey will be affected,
                // tack the rest on as part of the parent key
                //
                hr = StringCchPrintfEx(pszRegKey1,
                                       2 * MAX_CM_PATH,
                                       NULL, NULL,
                                       STRSAFE_NULL_ON_FAILURE,
                                       L"%s\\%s",
                                       pszParentKey,
                                       pszRegStr);
                ASSERT(SUCCEEDED(hr));

            } else {
                //
                // wasn't compound so use the whole child key
                //
                hr = StringCchCopyEx(pszRegKey1,
                                     2 * MAX_CM_PATH,
                                     pszParentKey,
                                     NULL, NULL,
                                     STRSAFE_NULL_ON_FAILURE);
                ASSERT(SUCCEEDED(hr));

                hr = StringCchCopyEx(pszRegKey2,
                                     2 * MAX_CM_PATH,
                                     pszChildKey,
                                     NULL, NULL,
                                     STRSAFE_NULL_ON_FAILURE);
                ASSERT(SUCCEEDED(hr));
            }
        }


        //-------------------------------------------------------------
        // SPECIAL CASE: If ulHardwareProfile == -1, then need to
        // delete the private key for all profiles.
        //-------------------------------------------------------------

        if (ulFlags == 0xFFFFFFFF) {

            hr = StringCchPrintfEx(pszRegStr,
                                   2 * MAX_CM_PATH,
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   L"%s\\%s",
                                   pszRegPathIDConfigDB,
                                   pszRegKeyKnownDockingStates);
            ASSERT(SUCCEEDED(hr));

            RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegStr, 0,
                                      KEY_ALL_ACCESS, &hKey);

            //
            // enumerate the hardware profile keys
            //
            for (ulIndex = 0; RegStatus == ERROR_SUCCESS; ulIndex++) {

                ulSize = MAX_PROFILE_ID_LEN;
                RegStatus = RegEnumKeyEx( hKey, ulIndex, szProfile, &ulSize,
                                          NULL, NULL, NULL, NULL);

                if (RegStatus == ERROR_SUCCESS) {
                    //
                    // if phantom, go ahead and delete it
                    //
                    if (bPhantom) {
                        //
                        // pszParentKey contains replacement symbol for the profile id, %s
                        //
                        pszFormatString = wcschr(pszParentKey, L'%');

                        ASSERT(pszFormatString && (pszFormatString[1] == L's'));

                        if (pszFormatString && (pszFormatString[1] == L's')) {

                            hr = StringCchPrintfEx(pszRegStr,
                                                   2 * MAX_CM_PATH,
                                                   NULL, NULL,
                                                   STRSAFE_NULL_ON_FAILURE,
                                                   pszParentKey,
                                                   szProfile);
                            ASSERT(SUCCEEDED(hr));

                            Status = DeletePrivateKey( HKEY_LOCAL_MACHINE, pszRegStr,
                                                       pszChildKey);
                        } else {
                            Status = CR_FAILURE;
                        }
                    }

                    //
                    // if real, just make it volatile
                    //
                    else {
                        //
                        // pszRegKey1 contains replacement symbol for the profile id, %s
                        //
                        pszFormatString = wcschr(pszRegKey1, L'%');

                        ASSERT(pszFormatString && (pszFormatString[1] == L's'));

                        if (pszFormatString && (pszFormatString[1] == L's')) {

                            hr = StringCchPrintfEx(pszRegStr,
                                                   2 * MAX_CM_PATH,
                                                   NULL, NULL,
                                                   STRSAFE_NULL_ON_FAILURE,
                                                   pszRegKey1,
                                                   szProfile);
                            ASSERT(SUCCEEDED(hr));

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_REGISTRY,
                                       "UMPNPMGR: PNP_DeleteRegistryKey make key %ws\\%ws volatile\n",
                                       pszRegStr,
                                       pszRegKey2));

                            Status = MakeKeyVolatile(pszRegStr, pszRegKey2);

                        } else {
                            Status = CR_FAILURE;
                        }
                    }

                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }
                }
            }
        }

        //------------------------------------------------------------------
        // not deleting for all profiles, so just delete the specified key
        //------------------------------------------------------------------

        else {

            if (bPhantom) {
                //
                // if phantom, go ahead and delete it
                //
                Status = DeletePrivateKey( HKEY_LOCAL_MACHINE, pszParentKey,
                                           pszChildKey);
            }
            else {
                //
                // if real, just make it volatile
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_DeleteRegistryKey make key %ws\\%ws volatile\n",
                           pszRegKey1,
                           pszRegKey2));

                Status = MakeKeyVolatile(pszRegKey1, pszRegKey2);
            }

            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
        pszRegStr = pszRegStr;
        pszRegKey1 = pszRegKey1;
        pszRegKey2 = pszRegKey2;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pszRegStr != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegStr);
    }

    if (pszRegKey1 != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegKey1);
    }

    if (pszRegKey2 != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegKey2);
    }

    return Status;

} // PNP_DeleteRegistryKey



CONFIGRET
PNP_GetClassCount(
      IN  handle_t   hBinding,
      OUT PULONG     pulClassCount,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Class_Count routine.
  It returns the number of valid classes currently installed (listed in
  the registry).

Arguments:

   hBinding          RPC binding handle, not used.

   pulClassCount     Supplies the address of a variable that will
                     receive the number of classes installed.

   ulFlags           Not used.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

Notes:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

    No corresponding CM_Get_Class_Count routine is implemented.
    This routine currently returns CR_CALL_NOT_IMPLEMENTED.

--*/

{
   UNREFERENCED_PARAMETER(hBinding);
   UNREFERENCED_PARAMETER(pulClassCount);
   UNREFERENCED_PARAMETER(ulFlags);

   return CR_CALL_NOT_IMPLEMENTED;

} // PNP_GetClassCount



CONFIGRET
PNP_GetClassName(
      IN  handle_t   hBinding,
      IN  PCWSTR     pszClassGuid,
      OUT PWSTR      Buffer,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Class_Name routine.
  It returns the name of the class represented by the GUID.

Arguments:

   hBinding       RPC binding handle, not used.

   pszClassGuid   String containing the class guid to retrieve a
                  class name for.

   Buffer         Supplies the address of the buffer that receives the
                  class name.

   pulLength      On input, this specifies the size of the Buffer in
                  characters.  On output it contains the number of
                  characters actually copied to Buffer.

   ulFlags        Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL, or
      CR_REGISTRY_ERROR

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH];
   HKEY        hKey = NULL;
   ULONG       ulLength;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // Validate parameters
      //
      if (INVALID_FLAGS(ulFlags, 0)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if ((!ARGUMENT_PRESENT(pulLength)) ||
          (!ARGUMENT_PRESENT(Buffer) && *pulLength != 0)) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      //
      // Open the key for the specified class guid
      //
      if ((lstrlen (pszRegPathClass) + lstrlen (pszClassGuid) + sizeof (TEXT("\\"))) > MAX_CM_PATH) {
          Status = CR_BUFFER_SMALL;
          goto Clean0;
      }

      if (FAILED(StringCchPrintf(
                     RegStr,
                     SIZECHARS(RegStr),
                     TEXT("%s\\%s"),
                     pszRegPathClass,
                     pszClassGuid))) {
         Status = CR_FAILURE;
         goto Clean0;
      }

      RegStatus = RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, RegStr, 0, KEY_QUERY_VALUE, &hKey);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }

      //
      // Retrieve the class name string value
      //
      ulLength = *pulLength;

      *pulLength *= sizeof(WCHAR);              // convert to size in bytes
      RegStatus = RegQueryValueEx(
               hKey, pszRegValueClass, NULL, NULL,
               (LPBYTE)Buffer, pulLength);
      *pulLength /= sizeof(WCHAR);              // convert back to chars

      if (RegStatus == ERROR_SUCCESS) {
         Status = CR_SUCCESS;
      }
      else if (RegStatus == ERROR_MORE_DATA) {
          Status = CR_BUFFER_SMALL;
          if ((ARGUMENT_PRESENT(Buffer)) &&
              (ulLength > 0)) {
              *Buffer = L'\0';
          }
      }
      else {
          Status = CR_REGISTRY_ERROR;
          if ((ARGUMENT_PRESENT(Buffer)) &&
              (ulLength > 0)) {
              *Buffer = L'\0';
              *pulLength = 1;
          }
      }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
       //
       // force compiler to respect statement ordering w.r.t. assignments
       // for these variables...
       //
       hKey = hKey;
   }

   if (hKey != NULL) {
       RegCloseKey(hKey);
   }

   return Status;

} // PNP_GetClassName



CONFIGRET
PNP_DeleteClassKey(
      IN  handle_t   hBinding,
      IN  PCWSTR     pszClassGuid,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Delete_Class_Key routine.
  It deletes the corresponding registry key.

Arguments:

   hBinding       RPC binding handle.

   pszClassGuid   String containing the class guid to delete the device
                  setup class registry key for.

   ulFlags        Either CM_DELETE_CLASS_ONLY or CM_DELETE_CLASS_SUBKEYS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_REGISTRY_ERROR, or
      CR_FAILURE

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DELETE_CLASS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        ASSERT(ARGUMENT_PRESENT(pszClassGuid));

        if ((!ARGUMENT_PRESENT(pszClassGuid)) ||
            (*pszClassGuid == L'\0')) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Check that the specified class key exists.
        //
        if (RegOpenKeyEx(ghClassKey, pszClassGuid, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }

        RegCloseKey(hKey);

        if (ulFlags == CM_DELETE_CLASS_SUBKEYS) {
            //
            // Delete the class key and any subkeys under it
            //
            if (!RegDeleteNode(ghClassKey, pszClassGuid)) {
                Status = CR_REGISTRY_ERROR;
            }

        } else if (ulFlags == CM_DELETE_CLASS_ONLY) {
            //
            // only delete the class key itself (just attempt to delete
            // using the registry routine, it will fail if any subkeys
            // exist)
            //
            if (RegDeleteKey(ghClassKey, pszClassGuid) != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_DeleteClassKey



CONFIGRET
PNP_GetInterfaceDeviceAlias(
   IN     handle_t hBinding,
   IN     PCWSTR   pszInterfaceDevice,
   IN     LPGUID   AliasInterfaceGuid,
   OUT    PWSTR    pszAliasInterfaceDevice,
   IN OUT PULONG   pulLength,
   IN OUT PULONG   pulTransferLen,
   IN     ULONG    ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Interface_Device_Alias routine.
  It returns an alias string for the specified guid and interface device.

Arguments:

   hBinding          RPC binding handle, not used.

   pszInterfaceDevice  Specifies the interface device to find an alias for.

   AliasInterfaceGuid  Supplies the interface class GUID.

   pszAliasInterfaceDevice  Supplies the address of a variable that will
                     receive the device interface alias of the specified device
                     interface, that is a member of the specified alias
                     interface class GUID.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(pszInterfaceDevice) ||
            !ARGUMENT_PRESENT(AliasInterfaceGuid) ||
            !ARGUMENT_PRESENT(pszAliasInterfaceDevice) ||
            !ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that AliasInterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceAlias
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA));
        RtlInitUnicodeString(&ControlData.SymbolicLinkName, pszInterfaceDevice);
        ControlData.AliasClassGuid = AliasInterfaceGuid;
        ControlData.AliasSymbolicLinkName = pszAliasInterfaceDevice;
        ControlData.AliasSymbolicLinkNameLength = *pulLength; // chars

        //
        // Call kernel-mode to get the device interface alias.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceAlias,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.AliasSymbolicLinkNameLength;
            *pulTransferLen = *pulLength + 1;
        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulLength = ControlData.AliasSymbolicLinkNameLength;
            Status = CR_BUFFER_SMALL;
        } else {
            *pulLength = 0;
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:

        //
        // Initialize output parameters
        //
        if ((Status != CR_SUCCESS) &&
            ARGUMENT_PRESENT(pulTransferLen) &&
            ARGUMENT_PRESENT(pszAliasInterfaceDevice) &&
            (*pulTransferLen > 0)) {
            *pszAliasInterfaceDevice = L'\0';
            *pulTransferLen = 1;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceAlias



CONFIGRET
PNP_GetInterfaceDeviceList(
    IN  handle_t  hBinding,
    IN  LPGUID    InterfaceGuid,
    IN  LPCWSTR   pszDeviceID,
    OUT LPWSTR    Buffer,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Device_Interface_List routine.
  It returns a multi_sz interface device list.

Arguments:

   hBinding          RPC binding handle, not used.

   InterfaceGuid     Supplies the interface class GUID.

   pszDeviceID       Supplies the device instance string.

   Buffer            Supplies the address of the buffer that receives the
                     registry data.

   pulLength         Specifies the size, in bytes, of the buffer.

   ulFlags           Flags specifying which device interfaces to return.
                     Currently, may be either:
                       CM_GET_DEVICE_INTERFACE_LIST_PRESENT, or
                       CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_DEVNODE,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_LIST_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pulLength) ||
            !ARGUMENT_PRESENT(Buffer) ||
            (*pulLength == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceList
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.InterfaceList = Buffer;
        ControlData.InterfaceListSize = *pulLength;

        if (ulFlags == CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES) {
            ControlData.Flags = 0x1; // DEVICE_INTERFACE_INCLUDE_NONACTIVE (ntos\inc\pnp.h)
        } else {
            ControlData.Flags = 0;
        }

        //
        // Call kernel-mode to get the device interface list.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.InterfaceListSize;
        } else {
            *pulLength = 0;
            if (ntStatus == STATUS_BUFFER_TOO_SMALL)  {
                Status = CR_BUFFER_SMALL;
            } else {
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceList



CONFIGRET
PNP_GetInterfaceDeviceListSize(
    IN  handle_t   hBinding,
    OUT PULONG     pulLen,
    IN  LPGUID     InterfaceGuid,
    IN  LPCWSTR    pszDeviceID,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Device_Interface_List_Size
  routine. It returns the size (in chars) of a multi_sz interface device list.

Arguments:

   hBinding          RPC binding handle, not used.

   pulLen            Supplies the address of a variable that, upon successful
                     return, receives the the size of buffer required to hold
                     the multi_sz interface device list.

   InterfaceGuid     Supplies the interface class GUID.

   pszDeviceID       Supplies the device instance string.

   ulFlags           Flags specifying which device interfaces to return.
                     Currently, may be either:
                       CM_GET_DEVICE_INTERFACE_LIST_PRESENT, or
                       CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_LIST_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Initialize the returned output length
        //
        *pulLen = 0;

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceList
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.InterfaceList = NULL;
        ControlData.InterfaceListSize = 0;

        if (ulFlags == CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES) {
            ControlData.Flags = 0x1; // DEVICE_INTERFACE_INCLUDE_NONACTIVE (ntos\inc\pnp.h)
        } else {
            ControlData.Flags = 0;
        }

        //
        // Call kernel-mode to get the device interface list size.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLen = ControlData.InterfaceListSize;
        } else {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceListSize



CONFIGRET
PNP_RegisterDeviceClassAssociation(
    IN handle_t   hBinding,
    IN LPCWSTR    pszDeviceID,
    IN LPGUID     InterfaceGuid,
    IN LPCWSTR    pszReference  OPTIONAL,
    OUT PWSTR     pszSymLink,
    IN OUT PULONG pulLength,
    IN OUT PULONG pulTransferLen,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Register_Device_Interface
  routine.  It registers a device interface for the specified device and device
  interface class, and returns the symbolic link name for the device interface.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   InterfaceGuid     Supplies the interface class guid.

   pszReference      Optionally, supplies the reference string name.

   pszSymLink        Receives the symbolic link name.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA ControlData;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pszSymLink) ||
            !ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlDeviceClassAssociation
        // control, for Registration only.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        RtlInitUnicodeString(&ControlData.Reference, pszReference);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.Register = TRUE;
        ControlData.SymLink = pszSymLink;
        ControlData.SymLinkLength = *pulLength;

        //
        // Call kernel-mode to register the device association.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlDeviceClassAssociation,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.SymLinkLength;
            *pulTransferLen = *pulLength;
        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulLength = ControlData.SymLinkLength;
            Status = CR_BUFFER_SMALL;
        } else {
            *pulLength = 0;
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:

        //
        // Initialize output parameters
        //
        if ((Status != CR_SUCCESS) &&
            ARGUMENT_PRESENT(pszSymLink) &&
            ARGUMENT_PRESENT(pulTransferLen) &&
            (*pulTransferLen > 0)) {
            *pszSymLink = L'\0';
            *pulTransferLen = 1;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RegisterDeviceClassAssociation



CONFIGRET
PNP_UnregisterDeviceClassAssociation(
    IN handle_t   hBinding,
    IN LPCWSTR    pszInterfaceDevice,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Unregister_Device_Interface
  routine.

Arguments:

   hBinding             RPC binding handle.

   pszInterfaceDevice   Specifies the interface device to unregister

   ulFlags              Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_DEVICE_INTERFACE_ACTIVE, or
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA ControlData;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (!ARGUMENT_PRESENT(pszInterfaceDevice)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that the DeviceInstance, Reference, and InterfaceGuid members
        // are not required for the PlugPlayControlDeviceClassAssociation
        // control, for unregistration only.  Only the symbolic link name is
        // required to unregister the device interface.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));
        ControlData.Register = FALSE;
        ControlData.SymLink = (LPWSTR)pszInterfaceDevice;
        ControlData.SymLinkLength = lstrlen(pszInterfaceDevice) + 1;

        //
        // Call kernel-mode to deregister the device association.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlDeviceClassAssociation,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            if (ntStatus == STATUS_ACCESS_DENIED) {
                Status = CR_DEVICE_INTERFACE_ACTIVE;
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_UnregisterDeviceClassAssociation


//-------------------------------------------------------------------
// Private export for the Service Controller
//-------------------------------------------------------------------



CONFIGRET
DeleteServicePlugPlayRegKeys(
    IN  LPWSTR   pszService
    )
/*++

Routine Description:

    This routine is called directly and privately by the Service Controller
    whenever a service has been deleted.  It allows the SCM to delete any Plug
    and Play registry keys that may have been created for a service.

Arguments:

    pszService - Specifies the name of the service.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Note:

    This routine is privately exported, and is to be called only by the
    Service Control Manager, during service deletion.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize, ulFlags, ulHardwareProfile, ulPass;
    LPWSTR      pDeviceList = NULL, pDeviceID;
    WCHAR       szParentKey[MAX_CM_PATH], szChildKey[MAX_DEVICE_ID_LEN];
    BOOL        RootEnumerationRequired = FALSE;
    ULONG       ulProblem, ulStatus;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pszService)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // retreive the maximum size required for a buffer to receive the list
        // of devices that this service is controlling
        //
        Status = PNP_GetDeviceListSize(NULL,
                                       pszService,
                                       &ulSize,
                                       CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
        if (pDeviceList == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // retrieve the list of devices that this service is controlling, make
        // sure that we don't generate one if none already exist
        //
        Status = PNP_GetDeviceList(NULL,
                                   pszService,
                                   pDeviceList,
                                   &ulSize,
                                   CM_GETIDLIST_FILTER_SERVICE |
                                   CM_GETIDLIST_DONOTGENERATE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // delete the registry keys for each device instance for this service
        //
        for (pDeviceID = pDeviceList;
             *pDeviceID;
             pDeviceID += lstrlen(pDeviceID) + 1) {

            for (ulPass = 0; ulPass < 4; ulPass++) {
                //
                // delete the registry keys for all hardware profiles, followed
                // by the system global registry keys
                //
                ulFlags = 0;
                ulHardwareProfile = 0;

                if (ulPass == 0) {
                    ulFlags = CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG;
                    ulHardwareProfile = 0xFFFFFFFF;
                } else if (ulPass == 1) {
                    ulFlags = CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG;
                    ulHardwareProfile = 0xFFFFFFFF;
                } else if (ulPass == 2) {
                    ulFlags = CM_REGISTRY_HARDWARE;
                    ulHardwareProfile = 0;
                } else if (ulPass == 3) {
                    ulFlags = CM_REGISTRY_SOFTWARE;
                    ulHardwareProfile = 0;
                }

                //
                // form the registry path based on the device id and the flags
                //
                if (GetDevNodeKeyPath(NULL,
                                      pDeviceID,
                                      ulFlags,
                                      ulHardwareProfile,
                                      szParentKey,
                                      SIZECHARS(szParentKey),
                                      szChildKey,
                                      SIZECHARS(szChildKey),
                                      FALSE) == CR_SUCCESS) {

                    //
                    // remove the specified registry key
                    //
                    PNP_DeleteRegistryKey(
                        NULL,                   // rpc binding handle (NULL)
                        pDeviceID,              // device id
                        szParentKey,            // parent of key to delete
                        szChildKey,             // key to delete
                        ulHardwareProfile);     // flags, not used
                }
            }

            //
            // Uninstall the device instance (see also PNP_UninstallDevInst).
            //

            //------------------------------------------------------------------
            // Uninstall deletes instance key (and all subkeys) for all
            // the hardware keys (this means the main Enum branch, the
            // config specific keys under HKLM, and the Enum branch under
            // HKCU). In the case of the user hardware keys (under HKCU),
            // I delete those whether it's a phantom or not, but since
            // I can't access the user key from the service side, I have
            // to do that part on the client side. For the main hw Enum key
            // and the config specific hw keys, I only delete them outright
            // if they are phantoms. If not a phantom, then I just make the
            // device instance volatile (by saving the original key, deleting
            // old key, creating new volatile key and restoring the old
            // contents) so at least it will go away during the next boot
            //------------------------------------------------------------------

            if ((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) &&
                (ulStatus & DN_DRIVER_LOADED)) {

                //-------------------------------------------------------------
                // device is not a phantom
                //-------------------------------------------------------------

                if ((ulStatus & DN_ROOT_ENUMERATED) &&
                    !(ulStatus & DN_DISABLEABLE)) {
                    //
                    // if a device is root enumerated, but not disableable, it is not uninstallable
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: DeleteServicePlugPlayRegKeys: "
                               "failed uninstall of %ws (this root device is not disableable)\n",
                               pDeviceID));
                } else {
                    //
                    // do the volatile-copy-thing
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: DeleteServicePlugPlayRegKeys: "
                               "doing volatile key thing on %ws\n",
                               pDeviceID));

                    UninstallRealDevice(pDeviceID);
                }

            } else {

                //-------------------------------------------------------------
                // device is a phantom so actually delete it
                //-------------------------------------------------------------

                if (UninstallPhantomDevice(pDeviceID) != CR_SUCCESS) {
                    continue;
                }

                //
                // if it is a root enumerated device, we need to reenumerate the
                // root (if not planning to do so already) so that the PDO will
                // go away, otherwise a new device could be created and the root
                // enumerator would get very confused.
                //
                if ((!RootEnumerationRequired) &&
                    (IsDeviceRootEnumerated(pDeviceID))) {
                    RootEnumerationRequired = TRUE;
                }
            }
        }

        //
        // Now that we're done processing all devices, see if we need to
        // reenumerate the root.
        //
        if (RootEnumerationRequired) {

            //
            // Reenumerate the root devnode asynchronously so that the service
            // controller does not block waiting for this routine to complete!!
            // (If we were processing device events at this time, the SCM would
            // be blocked here and not be able to deliver any events for us.
            // That would stall the event queue, preventing a synchronous device
            // enumeration from completing).
            //

            ReenumerateDevInst(pszRegRootEnumerator,
                               FALSE,
                               CM_REENUMERATE_ASYNCHRONOUS);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        pDeviceList = pDeviceList;
    }

    if (pDeviceList) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }

    return Status;

} // DeleteServicePlugPlayRegKeys



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------



LPWSTR
MapPropertyToString(
   ULONG ulProperty
   )
{
    switch (ulProperty) {

    case CM_DRP_DEVICEDESC:
        return pszRegValueDeviceDesc;

    case CM_DRP_HARDWAREID:
        return pszRegValueHardwareIDs;

    case CM_DRP_COMPATIBLEIDS:
        return pszRegValueCompatibleIDs;

    case CM_DRP_SERVICE:
        return pszRegValueService;

    case CM_DRP_CLASS:
        return pszRegValueClass;

    case CM_DRP_CLASSGUID:
        return pszRegValueClassGuid;

    case CM_DRP_DRIVER:
        return pszRegValueDriver;

    case CM_DRP_CONFIGFLAGS:
        return pszRegValueConfigFlags;

    case CM_DRP_MFG:
        return pszRegValueMfg;

    case CM_DRP_FRIENDLYNAME:
        return pszRegValueFriendlyName;

    case CM_DRP_LOCATION_INFORMATION:
        return pszRegValueLocationInformation;

    case CM_DRP_CAPABILITIES:
        return pszRegValueCapabilities;

    case CM_DRP_UI_NUMBER:
        return pszRegValueUiNumber;

    case CM_DRP_UPPERFILTERS:
        return pszRegValueUpperFilters;

    case CM_DRP_LOWERFILTERS:
        return pszRegValueLowerFilters;

    case CM_DRP_SECURITY: // and CM_CRP_SECURITY
        return pszRegValueSecurity;

    case CM_DRP_DEVTYPE: // and CM_CRP_DEVTYPE
        return pszRegValueDevType;

    case CM_DRP_EXCLUSIVE: // and CM_CRP_EXCLUSIVE
        return pszRegValueExclusive;

    case CM_DRP_CHARACTERISTICS: // and CM_CRP_CHARACTERISTICS
        return pszRegValueCharacteristics;

    case CM_DRP_UI_NUMBER_DESC_FORMAT:
        return pszRegValueUiNumberDescFormat;

    case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        return pszRegValueRemovalPolicyOverride;

    default:
        return NULL;
    }

} // MapPropertyToString



ULONG
MapPropertyToNtProperty(
    ULONG ulProperty
    )
{
    switch (ulProperty) {

    case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:
        return PNP_PROPERTY_PDONAME;

    case CM_DRP_BUSTYPEGUID:
        return PNP_PROPERTY_BUSTYPEGUID;

    case CM_DRP_LEGACYBUSTYPE:
        return PNP_PROPERTY_LEGACYBUSTYPE;

    case CM_DRP_BUSNUMBER:
        return PNP_PROPERTY_BUSNUMBER;

    case CM_DRP_ADDRESS:
        return PNP_PROPERTY_ADDRESS;

    case CM_DRP_DEVICE_POWER_DATA:
        return PNP_PROPERTY_POWER_DATA;

    case CM_DRP_REMOVAL_POLICY:
        return PNP_PROPERTY_REMOVAL_POLICY;

    case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        return PNP_PROPERTY_REMOVAL_POLICY_HARDWARE_DEFAULT;

    case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        return PNP_PROPERTY_REMOVAL_POLICY_OVERRIDE;

    case CM_DRP_INSTALL_STATE:
        return PNP_PROPERTY_INSTALL_STATE;

    case CM_DRP_LOCATION_PATHS:
        return PNP_PROPERTY_LOCATION_PATHS;

    default:
        return 0;
    }
} // MapPropertyToNtProperty



CONFIGRET
PNP_GetCustomDevProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  pDeviceID,
    IN     LPCWSTR  CustomPropName,
    OUT    PULONG   pulRegDataType,
    OUT    LPBYTE   Buffer,
    OUT    PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Custom_Property
  routine.

Arguments:

   hBinding          RPC binding handle, not used.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be read from.

   CustomPropName    Supplies a string identifying the name of the property
                     (registry value entry name) to be retrieved.

   pulRegDataType    Supplies the address of a variable that will receive
                     the registry data type for this property (i.e., the REG_*
                     constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  If the caller is simply retrieving the
                     required size, pulLength will be zero.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occurred) or else the size of buffer
                     required to hold the property data.

   ulFlags           May be a combination of the following values:

                     CM_CUSTOMDEVPROP_MERGE_MULTISZ : merge the
                     devnode-specific REG_SZ or REG_MULTI_SZ property (if
                     present) with the per-hardware-id REG_SZ or REG_MULTI_SZ
                     property (if present).  The result will always be a
                     REG_MULTI_SZ.

                     Note: REG_EXPAND_SZ data is not merged in this manner, as
                     there is no way to indicate that the resultant list needs
                     environment variable expansion (i.e., there's no such
                     registry datatype as REG_EXPAND_MULTI_SZ).

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_REGISTRY_ERROR,
      CR_BUFFER_SMALL,
      CR_NO_SUCH_VALUE, or
      CR_FAILURE.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus;
    HKEY        hDevKey = NULL;
    HKEY        hDevParamsKey = NULL;
    HKEY        hPerHwIdSubKey = NULL;
    WCHAR       PerHwIdSubkeyName[MAX_DEVNODE_ID_LEN];
    ULONG       RequiredSize = 0;
    FILETIME    CacheDate, LastUpdateTime;
    DWORD       RegDataType, RegDataSize;
    LPBYTE      PerHwIdBuffer = NULL;
    DWORD       PerHwIdBufferLen = 0;
    LPWSTR      pCurId;
    BOOL        MergeMultiSzResult = FALSE;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //

        if (!ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // We should never have both arguments pointing to the same memory...
        //
        ASSERT(pulTransferLen != pulLength);

        //
        // ...but if we do, fail the call.
        //
        if (pulTransferLen == pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *pulTransferLen = 0;

        if (INVALID_FLAGS(ulFlags, CM_CUSTOMDEVPROP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if(!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // First, open the device instance key.  We'll then open the "Device
        // Parameters" subkey off of that.  We do this in two steps, because
        // we're likely to need a handle to the device instance key in order
        // to track down the per-hw-id property.
        //
        if(ERROR_SUCCESS != RegOpenKeyEx(ghEnumKey,
                                         pDeviceID,
                                         0,
                                         KEY_READ | KEY_WRITE,
                                         &hDevKey)) {

            hDevKey = NULL;         // ensure hDevKey is still NULL so we
                                    // won't erroneously try to close it.

            RequiredSize = 0;       // no size info for caller

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        if(ERROR_SUCCESS == RegOpenKeyEx(hDevKey,
                                         pszRegKeyDeviceParam,
                                         0,
                                         KEY_READ,
                                         &hDevParamsKey)) {

            RequiredSize = *pulLength;

            RegStatus = RegQueryValueEx(hDevParamsKey,
                                        CustomPropName,
                                        NULL,
                                        pulRegDataType,
                                        Buffer,
                                        &RequiredSize
                                       );

            if(RegStatus == ERROR_SUCCESS) {
                //
                // We need to distinguish between the case where we succeeded
                // because the caller supplied a zero-length buffer (we call it
                // CR_BUFFER_SMALL) and the "real" success case.
                //
                if((*pulLength == 0) && (RequiredSize != 0)) {
                    Status = CR_BUFFER_SMALL;
                }

            } else {

                if(RegStatus == ERROR_MORE_DATA) {
                    Status = CR_BUFFER_SMALL;
                } else {
                    RequiredSize = 0;
                    Status = CR_NO_SUCH_VALUE;
                }
            }

            //
            // At this point, Status is one of the following:
            //
            // CR_SUCCESS       : we found the value and our buffer was
            //                    sufficiently-sized to hold it,
            // CR_BUFFER_SMALL  : we found the value and our buffer wasn't
            //                    large enough to hold it, or
            // CR_NO_SUCH_VALUE : we didn't find the value.
            //
            // If we found a value (whether or not our buffer was large enough
            // to hold it), we're done, except for cases where the caller
            // has asked us to append the per-hw-id string(s) with the
            // per-devnode string(s).
            //
            if(Status == CR_NO_SUCH_VALUE) {
                //
                // No devnode-specific property, so we use the same buffer and
                // length for retrieval of per-hw-id property...
                //
                PerHwIdBuffer = Buffer;
                PerHwIdBufferLen = *pulLength;

            } else {
                //
                // Figure out if we need to worry about appending results
                // together into a multi-sz list...
                //
                if((ulFlags & CM_CUSTOMDEVPROP_MERGE_MULTISZ) &&
                   ((*pulRegDataType == REG_MULTI_SZ) || (*pulRegDataType == REG_SZ))) {

                    MergeMultiSzResult = TRUE;

                    //
                    // Ensure that the size of our string(s) buffer is at least
                    // one Unicode character.  If we have a buffer of one
                    // character, ensure that character is a null.
                    //
                    if(RequiredSize < sizeof(WCHAR)) {
                        RequiredSize = sizeof(WCHAR);
                        if(RequiredSize > *pulLength) {
                            Status = CR_BUFFER_SMALL;
                        } else {
                            ASSERT(Status == CR_SUCCESS);
                            *(PWSTR)Buffer = L'\0';
                        }
                    }
                }

                if(!MergeMultiSzResult) {
                    //
                    // We're outta here!
                    //
                    if(Status == CR_SUCCESS) {
                        //
                        // We have data to transfer.
                        //
                        *pulTransferLen = RequiredSize;
                    }

                    goto Clean0;

                } else {
                    //
                    // We're supposed to merge our per-devnode string(s) with
                    // any per-hw-id string(s) we find.  Make sure our buffer
                    // and length reflect a properly-formatted multi-sz list,
                    // then setup our per-hw-id buffer info so that we'll
                    // append to this list later on...
                    //
                    if(Status == CR_BUFFER_SMALL) {
                        //
                        // We won't even try to retrieve any actual data from
                        // a per-hw-id key (all we'll get is the additional
                        // size requirement).
                        //
                        PerHwIdBuffer = NULL;
                        PerHwIdBufferLen = 0;

                        if(*pulRegDataType == REG_SZ) {
                            //
                            // The data we retrieved from the devnode's "Device
                            // Parameters" subkey was a REG_SZ.  Add one
                            // character width to the required length to
                            // reflect the size of the string after conversion
                            // to multi-sz (unless the size is 1 character,
                            // indicating an empty string, which is also the
                            // size of an empty multi-sz list).
                            //
                            if(RequiredSize > sizeof(WCHAR)) {
                                RequiredSize += sizeof(WCHAR);
                            }

                            *pulRegDataType = REG_MULTI_SZ;
                        }

                    } else {
                        //
                        // We actually retrieved a REG_SZ or REG_MULTI_SZ value
                        // into our caller-supplied buffer.  Ensure that the
                        // string(s) contained therein is(are) in proper
                        // multi-sz format, and that the size is correct.
                        //
                        if(*pulRegDataType == REG_SZ) {

                            RegDataSize = lstrlen((LPWSTR)Buffer) + 1;

                            if((RegDataSize * sizeof(WCHAR)) > RequiredSize) {
                                //
                                // The string we retrieved is longer than the
                                // buffer--this indicates the string wasn't
                                // properly null-terminated.  Discard this
                                // string.
                                //
                                Status = CR_NO_SUCH_VALUE;
                                RequiredSize = 0;
                                PerHwIdBuffer = Buffer;
                                PerHwIdBufferLen = *pulLength;

                            } else {
                                //
                                // The string was large enough to fit in the
                                // buffer.  Add another null character to
                                // turn this into a multi-sz (if there's room).
                                // (Again, we don't need to do increase the
                                // length if this is an empty string.)
                                //
                                if(RegDataSize == 1) {
                                    RequiredSize = sizeof(WCHAR);
                                    PerHwIdBuffer = Buffer;
                                    PerHwIdBufferLen = *pulLength;
                                    //
                                    // Assuming no per-hw-id data is found
                                    // later, this is the size of the data
                                    // we'll be handing back to the caller.
                                    //
                                    *pulTransferLen = RequiredSize;

                                } else {
                                    RequiredSize = (RegDataSize + 1) * sizeof(WCHAR);

                                    if(RequiredSize > *pulLength) {
                                        //
                                        // Oops--while the string fits nicely into
                                        // the caller-supplied buffer, adding an
                                        // extra null char pushes it over the limit.
                                        // Turn this into a CR_BUFFER_SMALL case.
                                        //
                                        Status = CR_BUFFER_SMALL;
                                        PerHwIdBuffer = NULL;
                                        PerHwIdBufferLen = 0;

                                    } else {
                                        //
                                        // We've got room to add the extra null
                                        // character.  Do so, and setup our
                                        // per-hw-id buffer to start at the end of
                                        // our existing (single string) list...
                                        //
                                        PerHwIdBuffer =
                                            (LPBYTE)((LPWSTR)Buffer + RegDataSize);

                                        PerHwIdBufferLen =
                                            *pulLength - (RegDataSize * sizeof(WCHAR));

                                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                                        //
                                        // Assuming no per-hw-id data is found
                                        // later, this is the size of the data
                                        // we'll be handing back to the caller.
                                        //
                                        *pulTransferLen = RequiredSize;
                                    }
                                }

                                *pulRegDataType = REG_MULTI_SZ;
                            }

                        } else {
                            //
                            // We retrieved a multi-sz list.  Step through it
                            // to find the end of the list.
                            //
                            RegDataSize = 0;

                            for(pCurId = (LPWSTR)Buffer;
                                *pCurId;
                                pCurId = (LPWSTR)(Buffer + RegDataSize)) {

                                RegDataSize +=
                                    (lstrlen(pCurId) + 1) * sizeof(WCHAR);

                                if(RegDataSize < RequiredSize) {
                                    //
                                    // This string fits in the buffer, and
                                    // there's still space left over (i.e., for
                                    // at least a terminating null).  Move on
                                    // to the next string in the list.
                                    //
                                    continue;

                                } else if(RegDataSize > RequiredSize) {
                                    //
                                    // This string extends past the end of the
                                    // buffer, indicating that it wasn't
                                    // properly null-terminated.  This could've
                                    // caused an exception, in which case we'd
                                    // have discarded any contents of this
                                    // value.  For consistency, we'll discard
                                    // the contents anyway.  (Note: a multi-sz
                                    // list that simply ommitted the final
                                    // terminating NULL will not fall into this
                                    // category--we deal with that correctly
                                    // and "fix it up".)
                                    //
                                    Status = CR_NO_SUCH_VALUE;
                                    RequiredSize = 0;
                                    PerHwIdBuffer = Buffer;
                                    PerHwIdBufferLen = *pulLength;
                                    break;

                                } else {
                                    //
                                    // This string exactly fits into the
                                    // remaining buffer space, indicating that
                                    // the multi-sz list wasn't properly
                                    // double-null terminated.  We'll go ahead
                                    // and do that now...
                                    //
                                    RequiredSize = RegDataSize + sizeof(WCHAR);

                                    if(RequiredSize > *pulLength) {
                                        //
                                        // Oops--while the string fits nicely
                                        // into the caller-supplied buffer,
                                        // adding an extra null char pushes it
                                        // over the limit. Turn this into a
                                        // CR_BUFFER_SMALL case.
                                        //
                                        Status = CR_BUFFER_SMALL;
                                        PerHwIdBuffer = NULL;
                                        PerHwIdBufferLen = 0;

                                    } else {
                                        //
                                        // We've got room to add the extra null
                                        // character.  Do so, and setup our
                                        // per-hw-id buffer to start at the end
                                        // of our existing list...
                                        //
                                        PerHwIdBuffer = Buffer + RegDataSize;

                                        PerHwIdBufferLen =
                                            *pulLength - RegDataSize;

                                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                                        //
                                        // Assuming no per-hw-id data is found
                                        // later, this is the size of the data
                                        // we'll be handing back to the caller.
                                        //
                                        *pulTransferLen = RequiredSize;
                                    }

                                    //
                                    // We've reached the end of the list, so we
                                    // can break out of the loop.
                                    //
                                    break;
                                }
                            }

                            //
                            // We've now processed all (valid) strings in the
                            // multi-sz list we retrieved.  If there was a
                            // problem (either unterminated string or
                            // unterminated list), we fixed that up (and
                            // adjusted RequiredSize accordingly).  However,
                            // if the list was valid, we need to compute
                            // RequiredSize (e.g., the buffer might've been
                            // larger than the multi-sz list).
                            //
                            // We can recognize a properly-formatted multi-sz
                            // list, because that's the only time we'd have
                            // exited the loop with pCurId pointing to a null
                            // character...
                            //
                            if(!*pCurId) {
                                ASSERT(RequiredSize >= (RegDataSize + sizeof(WCHAR)));
                                RequiredSize = RegDataSize + sizeof(WCHAR);

                                PerHwIdBuffer = Buffer + RegDataSize;
                                PerHwIdBufferLen = *pulLength - RegDataSize;

                                //
                                // Assuming no per-hw-id data is found later,
                                // this is the size of the data we'll be
                                // handing back to the caller.
                                //
                                *pulTransferLen = RequiredSize;
                            }
                        }
                    }
                }
            }

        } else {
            //
            // We couldn't open the devnode's "Device Parameters" subkey.
            // Ensure hDevParamsKey is still NULL so we won't erroneously try
            // to close it.
            //
            hDevParamsKey = NULL;

            //
            // Setup our pointer for retrieval of per-hw-id value...
            //
            PerHwIdBuffer = Buffer;
            PerHwIdBufferLen = *pulLength;

            //
            // Setup our default return values in case no per-hw-id data is
            // found...
            //
            Status = CR_NO_SUCH_VALUE;
            RequiredSize = 0;
        }

        //
        // From this point on use PerHwIdBuffer/PerHwIdBufferLen instead of
        // caller-supplied Buffer/pulLength, since we may be appending results
        // to those retrieved from the devnode's "Device Parameters" subkey...
        //

        //
        // If we get to here, then we need to go look for the value under
        // the appropriate per-hw-id registry key.  First, figure out whether
        // the per-hw-id information has changed since we last cached the
        // most appropriate key.
        //
        RegDataSize = sizeof(LastUpdateTime);

        if((ERROR_SUCCESS != RegQueryValueEx(ghPerHwIdKey,
                                             pszRegValueLastUpdateTime,
                                             NULL,
                                             &RegDataType,
                                             (PBYTE)&LastUpdateTime,
                                             &RegDataSize))
           || (RegDataType != REG_BINARY)
           || (RegDataSize != sizeof(FILETIME))) {

            //
            // We can't ascertain when (or even if) the per-hw-id database was
            // last populated.  At this point, we bail with whatever status we
            // had after our attempt at retrieving the per-devnode property.
            //
            goto Clean0;
        }

        //
        // (RegDataSize is already set appropriately, no need to initialize it
        // again)
        //
        if(ERROR_SUCCESS == RegQueryValueEx(hDevKey,
                                            pszRegValueCustomPropertyCacheDate,
                                            NULL,
                                            &RegDataType,
                                            (PBYTE)&CacheDate,
                                            &RegDataSize)) {
            //
            // Just to be extra paranoid...
            //
            if((RegDataType != REG_BINARY) || (RegDataSize != sizeof(FILETIME))) {
                ZeroMemory(&CacheDate, sizeof(CacheDate));
            }

        } else {
            ZeroMemory(&CacheDate, sizeof(CacheDate));
        }

        if(CompareFileTime(&CacheDate, &LastUpdateTime) == 0) {
            //
            // The Per-Hw-Id database hasn't been updated since we cached away
            // the most-appropriate hardware id subkey.  We can now use this
            // subkey to see if there's a per-hw-id value entry contained
            // therein for the requested property.
            //
            RegDataSize = sizeof(PerHwIdSubkeyName);

            if(ERROR_SUCCESS != RegQueryValueEx(hDevKey,
                                                pszRegValueCustomPropertyHwIdKey,
                                                NULL,
                                                &RegDataType,
                                                (PBYTE)PerHwIdSubkeyName,
                                                &RegDataSize)) {
                //
                // The value entry wasn't present, indicating there is no
                // applicable per-hw-id key.
                //
                goto Clean0;

            } else if(RegDataType != REG_SZ) {
                //
                // The data isn't a REG_SZ, like we expected.  This should never
                // happen, but if it does, go ahead and re-assess the key we
                // should be using.
                //
                *PerHwIdSubkeyName = L'\0';

            } else {
                //
                // We have a per-hw-id subkey to use.  Go ahead and attempt to
                // open it up here.  If we find someone has tampered with the
                // database and deleted this subkey, then we can at least go
                // re-evaluate below to see if we can find a new key that's
                // applicable for this devnode.
                //
                if(ERROR_SUCCESS != RegOpenKeyEx(ghPerHwIdKey,
                                                 PerHwIdSubkeyName,
                                                 0,
                                                 KEY_READ,
                                                 &hPerHwIdSubKey)) {

                    hPerHwIdSubKey = NULL;



                    *PerHwIdSubkeyName = L'\0';
                }
            }

        } else {
            //
            // Per-Hw-Id database has been updated since we last cached away
            // our custom property default key.  (Note: The only time CacheDate
            // could be _newer than_ LastUpdateTime would be when a previous
            // update was (re-)applied to the per-hw-id database.  In this case,
            // we'd want to re-assess the key we're using, since we always want
            // to be exactly in-sync with the current state of the database.
            //
            *PerHwIdSubkeyName = L'\0';
        }

        if(!(*PerHwIdSubkeyName)) {
            //
            // We need to look for a (new) per-hw-id key from which to retrieve
            // properties applicable for this device.
            //
            hPerHwIdSubKey = FindMostAppropriatePerHwIdSubkey(hDevKey,
                                                              KEY_READ,
                                                              PerHwIdSubkeyName,
                                                              &RegDataSize
                                                             );

            if(hPerHwIdSubKey) {

                RegStatus = RegSetValueEx(hDevKey,
                                          pszRegValueCustomPropertyHwIdKey,
                                          0,
                                          REG_SZ,
                                          (PBYTE)PerHwIdSubkeyName,
                                          RegDataSize * sizeof(WCHAR)  // need size in bytes
                                         );
            } else {

                RegStatus = RegDeleteKey(hDevKey,
                                         pszRegValueCustomPropertyHwIdKey
                                        );
            }

            if(RegStatus == ERROR_SUCCESS) {
                //
                // We successfully updated the cached per-hw-id key name.  Now
                // update the CustomPropertyCacheDate to reflect the date
                // associated with the per-hw-id database.
                //
                RegSetValueEx(hDevKey,
                              pszRegValueCustomPropertyCacheDate,
                              0,
                              REG_BINARY,
                              (PBYTE)&LastUpdateTime,
                              sizeof(LastUpdateTime)
                             );
            }

            if(!hPerHwIdSubKey) {
                //
                // We couldn't find an applicable per-hw-id key for this
                // devnode.
                //
                goto Clean0;
            }
        }

        //
        // If we get to here, we have a handle to the per-hw-id subkey from
        // which we can query the requested property.
        //
        RegDataSize = PerHwIdBufferLen; // remember buffer size prior to call

        RegStatus = RegQueryValueEx(hPerHwIdSubKey,
                                    CustomPropName,
                                    NULL,
                                    &RegDataType,
                                    PerHwIdBuffer,
                                    &PerHwIdBufferLen
                                   );

        if(RegStatus == ERROR_SUCCESS) {
            //
            // Again, we need to distinguish between the case where we
            // succeeded because we supplied a zero-length buffer (we call it
            // CR_BUFFER_SMALL) and the "real" success case.
            //
            if(RegDataSize == 0) {

                if(PerHwIdBufferLen != 0) {
                    Status = CR_BUFFER_SMALL;
                } else if(MergeMultiSzResult) {
                    //
                    // We already have the multi-sz results we retrieved from
                    // the devnode's "Device Parameters" subkey ready to return
                    // to the caller...
                    //
                    ASSERT(*pulRegDataType == REG_MULTI_SZ);
                    ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
                    ASSERT(RequiredSize >= sizeof(WCHAR));
                    ASSERT((Status != CR_SUCCESS) || (*pulTransferLen >= sizeof(WCHAR)));

                    goto Clean0;
                }

            } else {
                //
                // Our success was genuine.
                //
                Status = CR_SUCCESS;
            }

            //
            // It's possible that we're supposed to be merging results into a
            // multi-sz list, but didn't find a value under the devnode's
            // "Device Parameters" subkey.  Now that we have found a value
            // under the per-hw-id subkey, we need to ensure the data returned
            // is in multi-sz format.
            //
            if(!MergeMultiSzResult && (RequiredSize == 0)) {

                if((ulFlags & CM_CUSTOMDEVPROP_MERGE_MULTISZ) &&
                   ((RegDataType == REG_MULTI_SZ) || (RegDataType == REG_SZ))) {

                    MergeMultiSzResult = TRUE;
                    *pulRegDataType = REG_MULTI_SZ;
                    RequiredSize = sizeof(WCHAR);

                    if(RequiredSize > *pulLength) {
                        Status = CR_BUFFER_SMALL;
                    }
                }
            }

        } else {

            if(RegStatus == ERROR_MORE_DATA) {
                Status = CR_BUFFER_SMALL;
            } else {
                //
                // If we were merging results into our multi-sz list, ensure
                // that our list-terminating null didn't get blown away.
                //
                if(MergeMultiSzResult) {

                    if(RegDataSize != 0) {
                        *((LPWSTR)PerHwIdBuffer) = L'\0';
                    }

                    //
                    // We already have the multi-sz results we retrieved from
                    // the devnode's "Device Parameters" subkey ready to return
                    // to the caller...
                    //
                    ASSERT(*pulRegDataType == REG_MULTI_SZ);
                    ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
                    ASSERT(RequiredSize >= sizeof(WCHAR));
                    ASSERT((Status != CR_SUCCESS) || (*pulTransferLen >= sizeof(WCHAR)));

                } else {
                    ASSERT(Status == CR_NO_SUCH_VALUE);
                    ASSERT(*pulTransferLen == 0);
                }

                goto Clean0;
            }
        }

        if(!MergeMultiSzResult) {

            *pulRegDataType = RegDataType;
            RequiredSize = PerHwIdBufferLen;

            if(Status == CR_SUCCESS) {
                //
                // We have data to transfer.
                //
                *pulTransferLen = RequiredSize;
            }

        } else {

            ASSERT(*pulRegDataType == REG_MULTI_SZ);
            ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
            ASSERT(RequiredSize >= sizeof(WCHAR));

            //
            // Unless the buffer size we retrieved is greater than one Unicode
            // character, it isn't going to affect the resultant size of our
            // multi-sz list.
            //
            if(PerHwIdBufferLen <= sizeof(WCHAR)) {
                ASSERT((Status != CR_BUFFER_SMALL) || (*pulTransferLen == 0));
                goto Clean0;
            }

            if(Status == CR_BUFFER_SMALL) {
                //
                // We might've previously believed that we could return data to
                // the caller (e.g., because the data retrieved  from the
                // devnode's "Device Parameters" subkey fit into our buffer.
                // Now that we see the data isn't going to fit, we need to
                // ensure that *pulTransferLen is zero to indicate no data is
                // being returned.
                //
                *pulTransferLen = 0;

                if(RegDataType == REG_MULTI_SZ) {
                    //
                    // Just want the lengths of the string(s) plus
                    // their terminating nulls, excluding list-
                    // terminating null char.
                    //
                    RequiredSize += (PerHwIdBufferLen - sizeof(WCHAR));

                } else if(RegDataType == REG_SZ) {
                    //
                    // We can just add the size of this string into our
                    // total requirement (unless it's an empty string,
                    // in which case we don't need to do anything at
                    // all).
                    //
                    RequiredSize += PerHwIdBufferLen;

                } else {
                    //
                    // per-hw-id data wasn't a REG_SZ or REG_MULTI_SZ, so
                    // ignore it.
                    //
                    goto Clean0;
                }

            } else {
                //
                // We succeeded in retrieving more data into our multi-sz list.
                // If the data we retrieved is multi-sz, then we don't have any
                // additional work to do.  However, if we retrieved a simple
                // REG_SZ, then we need to find the end of the string, and add
                // a second list-terminating null.
                //
                if(RegDataType == REG_MULTI_SZ) {

                    RequiredSize += (PerHwIdBufferLen - sizeof(WCHAR));

                } else if(RegDataType == REG_SZ) {

                    RegDataSize = lstrlen((LPWSTR)PerHwIdBuffer) + 1;

                    if((RegDataSize == 1) ||
                       ((RegDataSize * sizeof(WCHAR)) > PerHwIdBufferLen)) {
                        //
                        // The string we retrieved is either (a) empty or
                        // (b) longer than the buffer (the latter indicating
                        // that the string wasn't properly null-terminated).
                        // In either case, we don't want to append anything to
                        // our existing result, but we do need to ensure our
                        // list-terminating null character is still there...
                        //
                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                    } else {
                        //
                        // Compute total size requirement..
                        //
                        RequiredSize += (RegDataSize * sizeof(WCHAR));

                        if(RequiredSize > *pulLength) {
                            //
                            // Adding the list-terminating null character
                            // pushed us over the size of the caller-
                            // supplied buffer. :-(
                            //
                            Status = CR_BUFFER_SMALL;
                            *pulTransferLen = 0;
                            goto Clean0;

                        } else {
                            //
                            // Add list-terminating null character...
                            //
                            *((LPWSTR)PerHwIdBuffer + RegDataSize) = L'\0';
                        }
                    }

                } else {
                    //
                    // per-hw-id data wasn't a REG_SZ or a REG_MULTI_SZ, so
                    // ignore it.  (Make sure, though, that we still have our
                    // final terminating null character.)
                    //
                    *((LPWSTR)PerHwIdBuffer) = L'\0';
                }

                *pulTransferLen = RequiredSize;
            }
        }

    Clean0:

        if (ARGUMENT_PRESENT(pulLength)) {
            *pulLength = RequiredSize;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hDevKey = hDevKey;
        hDevParamsKey = hDevParamsKey;
        hPerHwIdSubKey = hPerHwIdSubKey;
    }

    if(hDevKey != NULL) {
        RegCloseKey(hDevKey);
    }
    if(hDevParamsKey != NULL) {
        RegCloseKey(hDevParamsKey);
    }
    if(hPerHwIdSubKey != NULL) {
        RegCloseKey(hPerHwIdSubKey);
    }

    return Status;

} // PNP_GetCustomDevProp



HKEY
FindMostAppropriatePerHwIdSubkey(
    IN  HKEY    hDevKey,
    IN  REGSAM  samDesired,
    OUT LPWSTR  PerHwIdSubkeyName,
    OUT LPDWORD PerHwIdSubkeyLen
    )

/*++

Routine Description:

    This routine finds the subkey in the per-hw-id database that is most
    appropriate for the device whose instance key was passed as input.  This
    determination is made by taking each of the device's hardware and
    compatible ids, in turn, and forming a subkey name by replacing backslashes
    (\) with hashes (#).  An attempt is made to open that subkey under the
    per-hw-id key, and the first such id to succeed, if any, is the most
    appropriate (i.e., most-specific) database entry.

    Note: we must consider both hardware and compatible ids, because some buses
    (such as PCI) may shift hardware ids down into the compatible id list under
    certain circumstances (e.g., PCI\VENxxxxDEVyyyy gets moved into the
    compatible list in the presence of subsys info).

Arguments:

    hDevKey           Supplies a handle to the device instance key for whom the
                      most-appropriate per-hw-id subkey is to be ascertained.

    samDesired        Supplies an access mask indicating the desired access
                      rights to the per-hw-id key being returned.

    PerHwIdSubkeyName Supplies a buffer (that must be at least
                      MAX_DEVNODE_ID_LEN characters in length) that, upon
                      success, receives the most-appropriate per-hw-id subkey
                      name.

    PerHwIdSubkeyLen  Supplies the address of a variable that, upon successful
                      return, receives the length of the subkey name (in
                      characters), including terminating NULL, stored into the
                      PerHwIdSubkeyName buffer.

Return Value:

   If the function succeeds, the return value is a handle to the most-
   appropriate per-hw-id subkey.

   If the function fails, the return value is NULL.

--*/

{
    DWORD i;
    DWORD RegDataType;
    PWCHAR IdList;
    HKEY hPerHwIdSubkey;
    PWSTR pCurId, pSrcChar, pDestChar;
    DWORD CurIdLen;
    DWORD idSize;
    WCHAR ids[REGSTR_VAL_MAX_HCID_LEN];

    //
    // Note:  we don't need to use structured exception handling in this
    // routine, since if we crash here (e.g., due to retrieval of a bogus
    // hardware or compatible id list), we won't leak any resource.  Thus, the
    // caller's try/except is sufficient.
    //

    //
    // First process the hardware id list, and if no appropriate match
    // found there, then examine the compatible id list.
    //
    for(i = 0; i < 2; i++) {

        idSize = sizeof(ids);
        if((ERROR_SUCCESS != RegQueryValueEx(hDevKey,
                                            (i ? pszRegValueCompatibleIDs
                                               : pszRegValueHardwareIDs),
                                            NULL,
                                            &RegDataType,
                                            (PBYTE)ids,
                                            &idSize))
           || (RegDataType != REG_MULTI_SZ)) {

            //
            // Missing or invalid id list--bail now.
            //
            return NULL;
        }
        IdList = ids;
        //
        // Now iterate through each id in our list, trying to open each one
        // in turn under the per-hw-id database key.
        //
        for(pCurId = IdList; *pCurId; pCurId += CurIdLen) {

            CurIdLen = lstrlen(pCurId) + 1;

            if(CurIdLen > MAX_DEVNODE_ID_LEN) {
                //
                // Bogus id in the list--skip it.
                //
                continue;
            }

            //
            // Transfer id into our subkey name buffer, converting path
            // separator characters ('\') to hashes ('#').
            //
            pSrcChar = pCurId;
            pDestChar = PerHwIdSubkeyName;

            do {
                *pDestChar = (*pSrcChar != L'\\') ? *pSrcChar : L'#';
                pDestChar++;
            } while(*(pSrcChar++));

            if(ERROR_SUCCESS == RegOpenKeyEx(ghPerHwIdKey,
                                             PerHwIdSubkeyName,
                                             0,
                                             samDesired,
                                             &hPerHwIdSubkey)) {
                //
                // We've found our key!
                //
                *PerHwIdSubkeyLen = CurIdLen;
                return hPerHwIdSubkey;
            }
        }
    }

    //
    // If we get to here, we didn't find an appropriate per-hw-id subkey to
    // return to the caller.
    //
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rresdes.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rresdes.c

Abstract:

    This module contains the server-side resource description APIs.

                  PNP_AddResDes
                  PNP_FreeResDes
                  PNP_GetNextResDes
                  PNP_GetResDesData
                  PNP_GetResDesDataSize
                  PNP_ModifyResDes
                  PNP_DetectResourceConflict

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"

#include <pcmciap.h>


//
// private prototypes
//

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    );

BOOL
FindResDes(
    IN  LPBYTE     pList,
    IN  ULONG      RegDataType,
    IN  ULONG      ulLogConfTag,
    IN  ULONG      ulResTag,
    IN  RESOURCEID ResType,
    OUT LPBYTE     *ppRD,
    OUT LPBYTE     *ppLogConf,
    OUT PULONG     pulSubIndex      OPTIONAL
    );

PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    );

ULONG
RANGE_COUNT(
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr
    );

ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    );

ULONG
GetReqDesSize(
    IN ULONG                   ResourceID,
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr,
    IN ULONG                   ulFlags
    );

CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceID,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

CONFIGRET
ResDesToNtRequirements(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PIO_RESOURCE_DESCRIPTOR          pReqDes,
    IN OUT PULONG                           pulResCount,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

CONFIGRET
NtResourceToResDes(
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    );

CONFIGRET
NtRequirementsToResDes(
    IN     PIO_RESOURCE_DESCRIPTOR         pReqDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    );

UCHAR
NT_RES_TYPE(
   IN RESOURCEID    ResourceID
   );

ULONG
CM_RES_TYPE(
   IN UCHAR    ResourceType
   );

USHORT    MapToNtMemoryFlags(IN DWORD);
DWORD     MapFromNtMemoryFlags(IN USHORT);
USHORT    MapToNtPortFlags(IN DWORD, IN DWORD);
DWORD     MapFromNtPortFlags(IN USHORT);
DWORD     MapAliasFromNtPortFlags(IN USHORT);
ULONG     MapToNtAlignment(IN DWORDLONG);
DWORDLONG MapFromNtAlignment(IN ULONG);
USHORT    MapToNtDmaFlags(IN DWORD);
DWORD     MapFromNtDmaFlags(IN USHORT);
USHORT    MapToNtIrqFlags(IN DWORD);
DWORD     MapFromNtIrqFlags(IN USHORT);
UCHAR     MapToNtIrqShare(IN DWORD);
DWORD     MapFromNtIrqShare(IN UCHAR);

//
// prototypes from rlogconf.c
//
CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    );

PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    );

PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    );


//
// global data
//
#define HIDWORD(x)   ((DWORD)(((DWORDLONG)(x) >> 32) & 0xFFFFFFFF))
#define LODWORD(x)   ((DWORD)(x))
#define MAKEDWORDLONG(x,y)  ((DWORDLONG)(((DWORD)(x)) | ((DWORDLONG)((DWORD)(y))) << 32))



CONFIGRET
PNP_AddResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   OUT PULONG     pResourceTag,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine adds
  a res des to the specified log conf.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    ResourceData  Resource data (of ResourceID type) to add to log conf.

    ResourceLen   Size of ResourceData in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, i = 0, ulSize = 0, ulOffset = 0,
                ulAddListSize = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pTemp = NULL;

    //
    // Always add the res des to the end, except in the case where a
    // class-specific res des has already been added. The class-specific
    // res des always MUST be last so add any new (non-class specific)
    // res des just before the class specific. Note that there can be
    // only one class-specific res des.
    //

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pResourceTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pResourceTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(ResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, LogConfTag)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes = NULL;

            //
            // determine size required to hold the new res des
            //
            ulAddListSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (ResourceID == ResType_ClassSpecific) {

                PCS_RESOURCE pCsRes = (PCS_RESOURCE)ResourceData;

                //
                // first make sure there isn't already a cs (only one per lc)
                //
                if (pRes->PartialResourceList.Count != 0 &&
                    pRes->PartialResourceList.PartialDescriptors[pRes->PartialResourceList.Count-1].Type
                          == CmResourceTypeDeviceSpecific) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // account for any extra class specific data in res list
                //
                ulAddListSize += sizeof(GUID) +
                                 pCsRes->CS_Header.CSD_SignatureLength +
                                 pCsRes->CS_Header.CSD_LegacyDataSize;
            }

            //
            // reallocate the resource buffers to hold the new res des
            //
            ulOffset = (DWORD)((ULONG_PTR)pRes - (ULONG_PTR)pResList);   // for restoring later

            pResList = HeapReAlloc(ghPnPHeap, 0, pList, ulListSize + ulAddListSize);
            if (pResList == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }
            pList = (LPBYTE)pResList;
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)((LPBYTE)pResList + ulOffset);

            //
            // Find location for new res des (make a hole if necessary)
            //
            // If the following conditions are true, then can just append the
            // new data to the end of the rsource list:
            // - The selected LogConf is the last LogConf, and
            // - No ClassSpecific resource has been added yet (or no resource period)
            //
            i = pRes->PartialResourceList.Count;

            if ((LogConfTag == pResList->Count - 1) &&
                (i == 0 ||
                pRes->PartialResourceList.PartialDescriptors[i-1].Type !=
                CmResourceTypeDeviceSpecific)) {

                *pResourceTag = i;
                pResDes = &pRes->PartialResourceList.PartialDescriptors[i];

            } else {
                //
                // Need to make a hole for the new data before copying it.
                // Find the spot to add the new res des data at - either as the
                // last res des for this log conf or just before the class
                // specific res des if it exists.
                //
                if (i == 0) {
                    *pResourceTag = 0;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[0];

                } else if (pRes->PartialResourceList.PartialDescriptors[i-1].Type ==
                           CmResourceTypeDeviceSpecific) {

                    *pResourceTag = i-1;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[i-1];

                } else {
                    *pResourceTag = i;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[i];
                }

                //
                // Move any data after this point down a notch to make room for
                // the new res des
                //
                ulSize = ulListSize - (DWORD)((ULONG_PTR)pResDes - (ULONG_PTR)pResList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pResDes, ulSize);
                memcpy((LPBYTE)((LPBYTE)pResDes + ulAddListSize), pTemp, ulSize);
            }

            if (ResourceID == ResType_ClassSpecific) {
                *pResourceTag = RESDES_CS_TAG;
            }

            //
            // Add res des to the log conf
            //
            Status = ResDesToNtResource(ResourceData, ResourceID, ResourceLen,
                                        pResDes, *pResourceTag, ulFlags);

            //
            // update the lc and res header
            //
            pRes->PartialResourceList.Count += 1;  // added a single res des (_DES)
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = NULL;
            PGENERIC_RESOURCE              pGenRes = (PGENERIC_RESOURCE)ResourceData;

            //
            // validate res des type - ClassSpecific not allowed in
            // requirements list (only resource list)
            //
            if (ResourceID == ResType_ClassSpecific ||
                pGenRes->GENERIC_Header.GENERIC_Count == 0) {

                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // determine size required to hold the new res des
            //
            ulAddListSize = pGenRes->GENERIC_Header.GENERIC_Count *
                            sizeof(IO_RESOURCE_DESCRIPTOR);

            //
            // reallocate the resource buffers to hold the new res des
            //
            ulOffset = (DWORD)((ULONG_PTR)pReq - (ULONG_PTR)pReqList);   // for restoring later

            pReqList = HeapReAlloc(ghPnPHeap, 0, pList, ulListSize + ulAddListSize);
            if (pReqList == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }
            pList = (LPBYTE)pReqList;
            pReq = (PIO_RESOURCE_LIST)((LPBYTE)pReqList + ulOffset);

            //
            // Find location for new res des - the new res des always ends
            // up being added as the last res des for this log conf.
            //
            *pResourceTag = pReq->Count;
            pReqDes = &pReq->Descriptors[*pResourceTag];

            //
            // If the selected LogConf is the last LogConf then can just
            // append the new res des data to the end of the requirements
            // list. Otherwise, need to make a whole for the new data
            // before copying it.
            //
            if (LogConfTag != pReqList->AlternativeLists - 1) {

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pReqDes - (ULONG_PTR)pReqList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pReqDes, ulSize);
                memcpy((LPBYTE)((LPBYTE)pReqDes + ulAddListSize), pTemp, ulSize);
            }

            //
            // Add res des to the log conf.
            //
            Status = ResDesToNtRequirements(ResourceData, ResourceID, ResourceLen,
                                            pReqDes, &i, *pResourceTag, ulFlags);

            //
            // update the lc and res header
            //
            pReq->Count += i;                      // _RANGES added
            pReqList->ListSize = ulListSize + ulAddListSize;
        }

        //
        // Write out the new/updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize + ulAddListSize)
                         != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
         HeapFree(ghPnPHeap, 0, pTemp);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_AddResDes



CONFIGRET
PNP_FreeResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT PULONG     pulPreviousResType,
   OUT PULONG     pulPreviousResTag,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine frees
  a res des to the specified log conf.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Specifies the resource within a given type.

    pulPreviousResType  Receives the previous resource type.

    pulPreviousResTag   Receives the previous resource within a given type.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType=0, RdCount=0, ulCount=0, ulListSize=0, ulSize=0;
    LPBYTE      pList=NULL, pLogConf=NULL, pRD=NULL, pTemp=NULL, pNext=NULL;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // If this is the last log conf and last res des, then don't
            // need to do anything except truncate it by writing less data
            // back into the registry.
            //
            if ((LogConfTag == pResList->Count - 1)  &&
                ((ResourceTag == pRes->PartialResourceList.Count - 1) ||
                (ResourceTag == RESDES_CS_TAG))) {

                pRes->PartialResourceList.Count -= 1;
                ulListSize = (DWORD)((ULONG_PTR)(pResDes) - (ULONG_PTR)(pResList));

            } else {
                //
                // If the res des is not at the end of the structure, then
                // migrate the remainder of the structure up to keep the
                // struct contiguous when removing a res des.
                //
                // pResDes points to the beginning of the res des to remove,
                // pNext points to the byte just after the res des to remove
                //
                pNext = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                if (pResDes->Type == CmResourceTypeDeviceSpecific) {
                    pNext += pResDes->u.DeviceSpecificData.DataSize;
                }

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResDes);   // new lc list size

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);
                memcpy((LPBYTE)pResDes, pTemp, ulSize);

                pRes->PartialResourceList.Count -= 1;
            }

            //
            // if no more res des's in this log conf, then return that
            // status (the client side will return a handle to the lc)
            //
            if (pRes->PartialResourceList.Count == 0) {
                Status = CR_NO_MORE_RES_DES;
            } else {
                //
                // return the previous res des type and tag
                //
                *pulPreviousResType =
                    CM_RES_TYPE(pRes->PartialResourceList.PartialDescriptors[ResourceTag-1].Type);

                if (*pulPreviousResType == ResType_ClassSpecific) {
                    *pulPreviousResTag = RESDES_CS_TAG;     // special tag for cs
                } else {
                    *pulPreviousResTag = ResourceTag - 1;
                }
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;

            //
            // If this is the last log conf and last res des, then don't
            // need to do anything except truncate it by writing less data
            // back into the registry.
            //
            RdCount = RANGE_COUNT(pReqDes, (LPBYTE)pReqList + ulListSize - 1);

            if ((LogConfTag == pReqList->AlternativeLists - 1)  &&
                (RdCount + ulCount == pReq->Count - 1)) {

                ulListSize = (DWORD)((ULONG_PTR)(pReqDes) - (ULONG_PTR)pReqList);

            } else {
                //
                // If the res des is not at the end of the structure, then
                // migrate the remainder of the structure up to keep the
                // struct contiguous when removing a res des.
                //
                // pReqDes points to the beginning of the res des(s) to remove,
                // pNext points to the byte just after the res des(s) to remove
                //
                pNext = (LPBYTE)((LPBYTE)pReqDes +
                                  RdCount * sizeof(IO_RESOURCE_DESCRIPTOR));

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqDes);   // new lc list size

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);
                memcpy((LPBYTE)pReqDes, pTemp, ulSize);
            }

            pReqList->ListSize = ulListSize;
            pReq->Count -= RdCount;

            //
            // if no more res des's in this log conf, then return that status
            // (the client side will return a handle to the log conf)
            //
            if (pReq->Count == 0) {
                Status = CR_NO_MORE_RES_DES;
            } else {
                //
                // return the previous res des type and tag
                //
                pReqDes =
                    AdvanceRequirementsDescriptorPtr(
                        &pReq->Descriptors[0],
                        ResourceTag-1, pReq->Count, NULL);

                //
                // Double check whether this is the first ConfigData res des,
                // skip it if so.
                //
                if (pReqDes == NULL || pReqDes->Type == CmResourceTypeConfigData) {
                    Status = CR_NO_MORE_RES_DES;
                } else {
                    *pulPreviousResType = CM_RES_TYPE(pReqDes->Type);
                    *pulPreviousResTag = ResourceTag - 1;
                }
            }
        }


        //
        // Write out the updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_INVALID_RES_DES;     // mostly likely reason we got here
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

   return Status;

} // PNP_FreeResDes



CONFIGRET
PNP_GetNextResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT PULONG     pulNextResDesTag,
   OUT PULONG     pulNextResDesType,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine gets the
  next res des in the specified log conf.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Specifies current resource descriptor (if any).

    pulNextResDesTag   Receives the next resource type.

    pulNextResDesType  Receives the next resource within a given type.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, i = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulNextResDesTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulNextResDesTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, LogConfTag)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // find the next res des. A resource tag of max indicates that we want
        // a find first operation.
        //
        if (ResourceTag == MAX_RESDES_TAG) {
            //
            // This is essentially a Get-First operation
            //
            *pulNextResDesTag = 0;

        } else if (ResourceTag == RESDES_CS_TAG) {
            //
            // By definition, if the resource type is classspecific, it's last,
            // so there aren't any more after this.
            //
            Status = CR_NO_MORE_RES_DES;
            goto Clean0;

        } else {
            *pulNextResDesTag = ResourceTag + 1;      // we want the "next" res des
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            ULONG                           ulTmpResDesTag, ulTmpLogConfTag;

            DBG_UNREFERENCED_PARAMETER(pResList);

            ulTmpResDesTag = *pulNextResDesTag;
            ulTmpLogConfTag = LogConfTag;

            for ( ; ; ) {

                while (ulTmpResDesTag >= pRes->PartialResourceList.Count)  {

                    ulTmpResDesTag -= pRes->PartialResourceList.Count;
                    ulTmpLogConfTag++;

                    //
                    // Seek to the log conf that matches the log conf tag
                    //
                    if (!FindLogConf(pList, &pLogConf, RegDataType, ulTmpLogConfTag)) {

                        Status = CR_NO_MORE_RES_DES;    // there is no "next"
                        goto Clean0;
                    }

                    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
                }

                //
                // Not done yet, if a specific resource type was specified, then
                // we may need to keep looking.
                //
                if (ResourceID != ResType_All) {

                    UCHAR NtResType = NT_RES_TYPE(ResourceID);

                    if (pRes->PartialResourceList.PartialDescriptors[ulTmpResDesTag].Type
                           != NtResType) {

                        (*pulNextResDesTag)++;
                        ulTmpResDesTag++;
                        continue;
                    }
                }

                break;
            }

            //
            // Return the type and tag of the "next" res des
            //
            *pulNextResDesType = CM_RES_TYPE(pRes->PartialResourceList.
                                             PartialDescriptors[ulTmpResDesTag].Type);

            if (*pulNextResDesType == ResType_ClassSpecific) {
                *pulNextResDesTag = RESDES_CS_TAG;     // special tag for cs
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes;

            DBG_UNREFERENCED_PARAMETER(pReqList);

            //
            // Point pResDes at the first possible "next" res des
            //

            if (*pulNextResDesTag == 0) {
                if (pReq->Count == 0) {
                    Status = CR_NO_MORE_RES_DES;    // there is no "next"
                    goto Clean0;
                }

                if (pReq->Descriptors[0].Type == CmResourceTypeConfigData) {
                    //
                    // This one doesn't count, it's privately created and maintained,
                    // skip to the next rd
                    //
                    *pulNextResDesTag = 1;
                }
            }

            if (*pulNextResDesTag > 0) {
                pReqDes =
                    AdvanceRequirementsDescriptorPtr(
                        &pReq->Descriptors[0],
                        *pulNextResDesTag, pReq->Count, &ulCount); // current

                if (pReqDes == NULL) {
                    Status = CR_NO_MORE_RES_DES;    // there is no "next"
                    goto Clean0;
                }
            } else {
                ulCount = 0;
                pReqDes = &pReq->Descriptors[0];
            }

            //
            // Not done yet, if a specific resource type was specified, then
            // we may need to keep looking.
            //
            if (ResourceID != ResType_All) {

                UCHAR NtResType = NT_RES_TYPE(ResourceID);

                while (pReqDes->Type != NtResType) {

                    if (ulCount >= pReq->Count) {
                        Status = CR_NO_MORE_RES_DES;
                        goto Clean0;
                    }
                    pReqDes =
                        AdvanceRequirementsDescriptorPtr(
                            pReqDes,
                            1, pReq->Count - ulCount, &i);

                    if (pReqDes == NULL) {
                        Status = CR_NO_MORE_RES_DES;
                        goto Clean0;
                    }

                    ulCount += i;
                    *pulNextResDesTag += 1;
                }
            }

            *pulNextResDesType = CM_RES_TYPE(pReqDes->Type);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetNextResDes



CONFIGRET
PNP_GetResDesData(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT LPBYTE     Buffer,
   IN  ULONG      BufferLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  the data for the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    Buffer        Returns resource data (of ResourceID type) from log conf.

    BufferLen     Size of Buffer in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data expected is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pRD = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // map the NT-style info into ConfigMgr-style structures
            //
            Status = NtResourceToResDes(pResDes, Buffer, BufferLen,
                                        (LPBYTE)pResList + ulListSize - 1, ulFlags);
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;

            //
            // map the NT-style info into ConfigMgr-style structures
            //
            Status = NtRequirementsToResDes(pReqDes, Buffer, BufferLen,
                                            (LPBYTE)pReqList + ulListSize - 1, ulFlags);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
       HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetResDesData



CONFIGRET
PNP_GetResDesDataSize(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      LogConfTag,
    IN  ULONG      LogConfType,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ResourceTag,
    OUT PULONG     pulSize,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  the data size for the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    pulSize       Returns size of buffer in bytes required to hold the
                  resource data (of ResourceID type) from log conf.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data expected is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pRD = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulSize)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulSize = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // calculate data size required (in terms of ConfigMgr structures)
            //
            *pulSize = GetResDesSize(ResourceID, ulFlags);

            if (ResourceID == ResType_ClassSpecific) {
                //
                // the Reserved fields should not exceed DataSize. if so, they
                // may have been incorrectly initialized, so set them 0.
                // we expect DataSize to be correct in all cases.
                //
                if (pResDes->u.DeviceSpecificData.Reserved1 > pResDes->u.DeviceSpecificData.DataSize) {
                    pResDes->u.DeviceSpecificData.Reserved1 = 0;
                }

                if (pResDes->u.DeviceSpecificData.Reserved2 > pResDes->u.DeviceSpecificData.DataSize) {
                    pResDes->u.DeviceSpecificData.Reserved2 = 0;
                }

                //
                // add space for legacy and signature data but not the
                // GUID - it's already included in the CM structures
                //
                if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                    //
                    // no legacy data or class-specific data
                    //
                    ;
                } else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                    //
                    // add space for legacy data
                    //
                    *pulSize += pResDes->u.DeviceSpecificData.DataSize - 1;
                } else {
                    //
                    // add space for class-specific data and/or legacy data
                    //
                    *pulSize += pResDes->u.DeviceSpecificData.Reserved1 +
                                pResDes->u.DeviceSpecificData.Reserved2 - 1;
                }
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;
            LPBYTE                         pLastReqAddr = (LPBYTE)pList + ulListSize - 1;

            //
            // calculate data size required (in terms of ConfigMgr structures)
            //
            *pulSize = GetReqDesSize(ResourceID, pReqDes, pLastReqAddr, ulFlags);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetResDesDataSize



CONFIGRET
PNP_ModifyResDes(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      LogConfTag,
    IN ULONG      LogConfType,
    IN RESOURCEID CurrentResourceID,
    IN RESOURCEID NewResourceID,
    IN ULONG      ResourceTag,
    IN LPBYTE     ResourceData,
    IN ULONG      ResourceLen,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine modifies
  the specified res des.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceIndex Returns with resource within a given type.

    ResourceData  New resource data (of ResourceID type).

    ResourceLen   Size of ResourceData in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       ulListSize = 0, ulOldSize = 0, ulNewSize = 0, ulSize = 0,
                ulOldCount = 0, ulNewCount = 0, RegDataType = 0, ulCount = 0;
    LONG        AddSize = 0;
    LPBYTE      pList = NULL, pRD = NULL, pLogConf = NULL,
                pTemp = NULL, pNext = NULL;


    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(NewResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, CurrentResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // If new res des type is ClassSpecific, then it must be the last
            // res des that is attempting to be modified (only last res des can
            // be class specific).
            //
            if (NewResourceID == ResType_ClassSpecific  &&
                ResourceTag != RESDES_CS_TAG) {

                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // calculate the current size and the new size of the res des data
            //
            ulNewSize = ulOldSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (CurrentResourceID == ResType_ClassSpecific) {
                ulOldSize += pResDes->u.DeviceSpecificData.DataSize;
            }

            if (NewResourceID == ResType_ClassSpecific) {

                PCS_RESOURCE pCsRes = (PCS_RESOURCE)ResourceData;

                ulNewSize += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                             sizeof(GUID) +
                             pCsRes->CS_Header.CSD_SignatureLength +
                             pCsRes->CS_Header.CSD_LegacyDataSize;
            }

            //
            // How much does data need to grow/shrink to accomodate the change?
            //
            AddSize = ulNewSize - ulOldSize;

            //
            // reallocate the buffers and shrink/expand the contents as
            // necessary
            //
            if (AddSize != 0) {

                if (AddSize > 0) {
                    //
                    // only bother reallocating if the buffer size is growing
                    //
                    ULONG ulOffset = (ULONG)((ULONG_PTR)pResDes - (ULONG_PTR)pResList);

                    pResList = HeapReAlloc(ghPnPHeap, 0, pList, ulListSize + AddSize);
                    if (pResList == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }
                    pList = (LPBYTE)pResList;
                    pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)((LPBYTE)pResList + ulOffset);
                }

                //
                // if not the last lc and rd, then need to move the following data
                // either up or down to account for changed res des data size
                //
                if ((LogConfTag != pResList->Count - 1)  ||
                    ((ResourceTag != pRes->PartialResourceList.Count - 1) &&
                     ResourceTag != RESDES_CS_TAG)) {

                    pNext = (LPBYTE)((LPBYTE)pResDes + ulOldSize);
                    ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);

                    pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                    if (pTemp == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    memcpy(pTemp, pNext, ulSize);
                    memcpy((LPBYTE)((LPBYTE)pResDes + ulNewSize), pTemp, ulSize);
                }
            }

            //
            // write out modified data
            //
            Status = ResDesToNtResource(ResourceData, NewResourceID, ResourceLen,
                                        pResDes, ResourceTag, ulFlags);
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;
            LPBYTE pLastReqAddr = (LPBYTE)pReqList + ulListSize - 1;
            PGENERIC_RESOURCE pGenRes = (PGENERIC_RESOURCE)ResourceData;

            //
            // Can't add class specific resdes to this type of log conf
            //
            if (NewResourceID == ResType_ClassSpecific) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // calculate the current size and the new size of the res des data
            //
            ulOldCount = RANGE_COUNT(pReqDes, pLastReqAddr);
            ulOldSize  = sizeof(IO_RESOURCE_DESCRIPTOR) * ulOldCount;

            ulNewSize  = sizeof(IO_RESOURCE_DESCRIPTOR) *
                         pGenRes->GENERIC_Header.GENERIC_Count;

            //
            // How much does data need to grow/shrink to accomodate the change?
            //
            AddSize = ulNewSize - ulOldSize;

            //
            // reallocate the buffers and shrink/expand the contents as
            // necessary
            //
            if (AddSize != 0) {

                if (AddSize > 0) {
                    //
                    // only bother reallocating if the buffer size is growing
                    //
                    ULONG ulOffset = (ULONG)((ULONG_PTR)pReqDes - (ULONG_PTR)pReqList);

                    pReqList = HeapReAlloc(ghPnPHeap, 0, pList, ulListSize + AddSize);
                    if (pReqList == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }
                    pList = (LPBYTE)pReqList;
                    pReqDes = (PIO_RESOURCE_DESCRIPTOR)((LPBYTE)pReqList + ulOffset);
                }

                //
                // set to last index for this res des (whole)
                //
                ulCount += RANGE_COUNT(pReqDes, (LPBYTE)((ULONG_PTR)pList + ulListSize));

                //
                // if not the last lc and rd, then need to move the following data
                // either up or down to account for changed res des data size
                //
                if (LogConfTag != pReqList->AlternativeLists - 1  ||
                    ulCount != pReq->Count - 1) {

                    pNext = (LPBYTE)((LPBYTE)pReqDes + ulOldSize);
                    ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);

                    pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                    if (pTemp == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    memcpy(pTemp, pNext, ulSize);
                    memcpy((LPBYTE)((LPBYTE)pReqDes + ulNewSize), pTemp, ulSize);
                }
            }

            //
            // write out modified data
            //
            Status = ResDesToNtRequirements(ResourceData, NewResourceID, ResourceLen,
                                            pReqDes, &ulNewCount, ResourceTag, ulFlags);

            if (Status == CR_SUCCESS) {
                //
                // update the requirements header (changes will be zero if CS)
                //
                pReq->Count += ulNewCount - ulOldCount;
                pReqList->ListSize = ulListSize + AddSize;
            }
        }

        if (Status == CR_SUCCESS) {

            //
            // Write out the new/updated log conf list to the registry
            //
            if (RegSetValueEx(hKey, szValueName, 0, RegDataType, pList,
                              ulListSize + AddSize) != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }

    return Status;

} // PNP_ModifyResDes



CONFIGRET
PNP_DetectResourceConflict(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  RESOURCEID ResourceID,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   OUT PBOOL      pbConflictDetected,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine detects
  conflicts with the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ResourceID    Specifies the resource type.

    ResourceData  Specifies resource data (of ResourceID type).

    ResourceLen   Size of ResourceData in bytes.

    pbConflictDetected  Returns whether a conflict was detected.

    ulFlags       Not used, must be zero.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

Note:

    This routine is currently not implemented.  It initializes
    pbConflictDetected to FALSE, and returns CR_CALL_NOT_IMPLEMENTED.

 --*/

{
    CONFIGRET  Status;

    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ResourceData);
    UNREFERENCED_PARAMETER(ResourceLen);
    UNREFERENCED_PARAMETER(ulFlags);

    try {
        //
        // initialize output parameters
        //
        if (ARGUMENT_PRESENT(pbConflictDetected)) {
            *pbConflictDetected = FALSE;
        }

        Status = CR_CALL_NOT_IMPLEMENTED;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_DetectResourceConflict



//------------------------------------------------------------------------
// Private Utility Functions
//------------------------------------------------------------------------

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    )
{

    ULONG   Index = 0;

    //
    // Input data is a Resource List
    //
    if (RegDataType == REG_RESOURCE_LIST) {

        PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
        PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

        if (ulTag >= pResList->Count) {
            return FALSE;
        }

        pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
        for (Index = 0; Index < ulTag; Index++) {
            pRes = AdvanceResourcePtr(pRes);      // next lc
        }

        *ppLogConf = (LPBYTE)pRes;
    }

    //
    // Input data is a Requirments List
    //
    else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

        PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
        PIO_RESOURCE_LIST              pReq = NULL;

        if (ulTag >= pReqList->AlternativeLists) {
            return FALSE;
        }

        pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]);    // first lc
        for (Index = 0; Index < ulTag; Index++) {
            pReq = AdvanceRequirementsPtr(pReq);           // next lc
        }

        *ppLogConf = (LPBYTE)pReq;

    } else {
        return FALSE;
    }

    return TRUE;

} // FindLogConf



BOOL
FindResDes(
    IN  LPBYTE     pList,
    IN  ULONG      RegDataType,
    IN  ULONG      ulLogConfTag,
    IN  ULONG      ulResTag,
    IN  RESOURCEID ResType,
    OUT LPBYTE     *ppRD,
    OUT LPBYTE     *ppLogConf,
    OUT PULONG     pulSubIndex      OPTIONAL
    )
{
    ULONG       ulIndex;

    //
    // Input data is a Resource List
    //
    if (RegDataType == REG_RESOURCE_LIST) {

        PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
        PCM_FULL_RESOURCE_DESCRIPTOR    pRes = NULL;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = NULL;
        ULONG                           ulSubIndex;
        ULONG                           ulResTagOffset;

        if (ulLogConfTag != 0) {
            return FALSE;
        }

        if (pResList->Count == 0) {
            return FALSE;
        }

        //
        // The tag is just the res des index with the exception of a
        // DeviceSpecificData type which has a unique tag. This is
        // necessary because new res des's will always get placed at
        // the end unless there's already a device specific res des,
        // in which case new res des get added just before it.
        //
        if (ulResTag == RESDES_CS_TAG) {
            //
            // If there is a devicespecific res des, it will be the last.
            //
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)&pResList->List[0]; // first lc

            ulSubIndex = 0;

            for (ulIndex = 0; ulIndex < (pResList->Count - 1); ulIndex++) {
                ulSubIndex += pRes->PartialResourceList.Count;
                pRes = AdvanceResourcePtr(pRes);      // next lc
            }

            ulResTagOffset = pRes->PartialResourceList.Count - 1;
            pResDes = &pRes->PartialResourceList.PartialDescriptors[ulResTagOffset];

            if (pResDes->Type != CmResourceTypeDeviceSpecific) {
                return FALSE;
            }

            if (pulSubIndex) {
                *pulSubIndex = ulSubIndex + ulResTagOffset; // for res list, subindex = index
            }

        } else {

            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)&pResList->List[0]; // first lc

            ulResTagOffset = ulResTag;

            for (ulIndex = 0; ulIndex < pResList->Count; ulIndex++) {

                if (ulResTagOffset >= pRes->PartialResourceList.Count) {

                    ulResTagOffset -= pRes->PartialResourceList.Count;
                    pRes = AdvanceResourcePtr(pRes);      // next lc

                } else {

                    break;

                }
            }

            if (ulResTagOffset >= pRes->PartialResourceList.Count) {
                return FALSE;
            }

            if (pulSubIndex) {
                *pulSubIndex = ulResTag;  // for res list, subindex = index = tag
            }
            pResDes = &pRes->PartialResourceList.PartialDescriptors[ulResTagOffset];
        }

        //
        // Validate against res des type
        //
        if (pResDes->Type != NT_RES_TYPE(ResType)) {
            return FALSE;
        }

        *ppLogConf = (LPBYTE)pRes;
        *ppRD = (LPBYTE)pResDes;
    }

    //
    // Input data is a Requirments List
    //
    else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

        LPBYTE                          pLogConf = NULL;
        PIO_RESOURCE_LIST               pReq = NULL;
        PIO_RESOURCE_DESCRIPTOR         pReqDes = NULL;
        ULONG                           Count = 0;


        if (!FindLogConf(pList, &pLogConf, RegDataType, ulLogConfTag)) {
            return FALSE;
        }

        pReq = (PIO_RESOURCE_LIST)pLogConf;

        if (pReq == NULL || pReq->Count == 0 || ulResTag >= pReq->Count) {
            return FALSE;
        }

        //
        // Find the res des that matches the specified tag. In this case the
        // tag is the index based on res des groupings.
        //
        pReqDes =
            AdvanceRequirementsDescriptorPtr(
                &pReq->Descriptors[0],
                ulResTag, pReq->Count, &Count);

        if (pReqDes == NULL) {
            return FALSE;
        }

        if (pulSubIndex) {
            *pulSubIndex = Count;
        }

        //
        // Validate against res des type
        //
        if (pReqDes->Type != NT_RES_TYPE(ResType)) {
            return FALSE;
        }

        *ppLogConf = (LPBYTE)pReq;
        *ppRD = (LPBYTE)pReqDes;
    }

    return TRUE;

} // FindResDes



PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    )
{
    PIO_RESOURCE_DESCRIPTOR     pReqDes = NULL;
    ULONG                       i = 0, Count = 0;

    //
    // Advance requirements descriptor pointer by number passed
    // in ulIncrement parameter. Return the actual index to the
    // first range in this descriptor list and range count if
    // desired. This routine assumes there is at least one more
    // requirements descriptor in the list.
    //

    if (pReqDesStart == NULL) {
        return NULL;
    }

    try {

        pReqDes = pReqDesStart;

        for (i = 0; i < ulIncrement; i++) {
            //
            // skip to next "whole" res des
            //
            if (Count < ulRemainingRanges &&
                (pReqDes->Option == 0 ||
                pReqDes->Option == IO_RESOURCE_PREFERRED ||
                pReqDes->Option == IO_RESOURCE_DEFAULT)) {
                //
                // This is a valid Option, there may be one or more alternate
                // descriptor in the set associated with this descriptor,
                // treat the set as "one" descriptor. (loop through the
                // descriptors until I find another non-alternative descriptor)
                //
                pReqDes++;                  // next range
                Count++;

                while (Count < ulRemainingRanges &&
                       (pReqDes->Option == IO_RESOURCE_ALTERNATIVE ||
                       pReqDes->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_PREFERRED ||
                       pReqDes->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_DEFAULT)) {
                    pReqDes++;              // next range
                    Count++;
                }

                if (Count >= ulRemainingRanges) {
                    pReqDes = NULL;
                    Count = 0;
                    break;
                }
            } else {

                //
                // invalid Option value
                //
                pReqDes = NULL;
                Count = 0;
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        pReqDes = NULL;
        Count = 0;
    }

    if (pulRangeCount) {
        *pulRangeCount = Count;
    }

    return pReqDes;

} // AdvanceRequirementsDescriptorPtr



ULONG
RANGE_COUNT(
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr
    )
{
    ULONG ulRangeCount = 0;

    try {

        if (pReqDes == NULL) {
            goto Clean0;
        }

        ulRangeCount++;

        if (pReqDes->Option == 0 ||
            pReqDes->Option == IO_RESOURCE_PREFERRED ||
            pReqDes->Option == IO_RESOURCE_DEFAULT) {

            PIO_RESOURCE_DESCRIPTOR p = pReqDes;
            p++;

            while (((LPBYTE)p < pLastReqAddr)  &&
                   (p->Option == IO_RESOURCE_ALTERNATIVE ||
                    p->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_PREFERRED ||
                    p->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_DEFAULT)) {

                ulRangeCount++;
                p++;            // skip to next res des
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ulRangeCount = 0;
    }

    return ulRangeCount;

} // RANGE_COUNT



ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    )
{
    switch (ResourceID) {

        case ResType_Mem:
            return sizeof(MEM_RESOURCE);

        case ResType_IO:
            return sizeof(IO_RESOURCE);

        case ResType_DMA:
            return sizeof(DMA_RESOURCE);

        case ResType_IRQ:
            if (ulFlags & CM_RESDES_WIDTH_64) {
                return sizeof(IRQ_RESOURCE_64);
            } else {
                return sizeof(IRQ_RESOURCE_32);
            }

        case ResType_ClassSpecific:
            return sizeof(CS_RESOURCE);

        case ResType_DevicePrivate:
            return sizeof(DEVPRIVATE_RESOURCE);

        case ResType_BusNumber:
            return sizeof(BUSNUMBER_RESOURCE);

        case ResType_PcCardConfig:
            return sizeof(PCCARD_RESOURCE);

        case ResType_MfCardConfig:
            return sizeof(MFCARD_RESOURCE);

        default:
            return 0;
    }

} // GetResDesSize



ULONG
GetReqDesSize(
    IN ULONG                   ResourceID,
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr,
    IN ULONG                   ulFlags
    )
{
    ULONG ulSize = 0;

    switch (ResourceID) {

        case ResType_Mem:
            ulSize = sizeof(MEM_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(MEM_RANGE);
            break;

        case ResType_IO:
            ulSize = sizeof(IO_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(IO_RANGE);
            break;

        case ResType_DMA:
            ulSize = sizeof(DMA_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(DMA_RANGE);
            break;

        case ResType_IRQ:
            if (ulFlags & CM_RESDES_WIDTH_64) {
                ulSize = sizeof(IRQ_RESOURCE_64);
            } else {
                ulSize = sizeof(IRQ_RESOURCE_32);
            }
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(IRQ_RANGE);
            break;

        case ResType_DevicePrivate:
            ulSize = sizeof(DEVPRIVATE_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(DEVPRIVATE_RANGE);
            break;

        case ResType_BusNumber:
            ulSize = sizeof(BUSNUMBER_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(BUSNUMBER_RANGE);
            break;

        case ResType_PcCardConfig:
            //
            // Non-arbitrated types don't have a range side in the user-mode structs
            //
            ulSize = sizeof(PCCARD_RESOURCE);
            break;

        case ResType_MfCardConfig:
            //
            // Non-arbitrated types don't have a range side in the user-mode structs
            //
            ulSize = sizeof(MFCARD_RESOURCE);
            break;

        default:
            break;
    }

    return ulSize;

} // GetReqDesSize



UCHAR
NT_RES_TYPE(
   IN RESOURCEID    ResourceID
   )
{
    ULONG resid = 0;

    if ((ResourceID < 0x06)) {

        //
        // First handle the divergent cases that can only be mapped
        // on a case by case basis. These are the values from zero
        // through five plus the special class specific case.
        //
        switch(ResourceID) {

            case ResType_None:
                return CmResourceTypeNull;
                break;

            case ResType_Mem:
                return CmResourceTypeMemory;

            case ResType_IO:
                return CmResourceTypePort;

            case ResType_DMA:
                return CmResourceTypeDma;

            case ResType_IRQ:
                return CmResourceTypeInterrupt;

            case ResType_DoNotUse:
                return (UCHAR)-1;

            DEFAULT_UNREACHABLE;
        }

    } else if (ResourceID == ResType_ClassSpecific) {

        //
        // ResType_ClassSpecific is another special case.
        //
        return CmResourceTypeDeviceSpecific;

    } else {

        //
        // For all other cases, rules apply as to how to map a kernel-mode
        // resource type id to a user-mode resource type id.
        //

        if (ResourceID >= 0x8080) {

            //
            // Anything larger this can't be mapped to the kernel-mode USHORT
            // values so it's invalid.
            //

            return (UCHAR)-1;

        } else if (!(ResourceID & ResType_Ignored_Bit)) {

            //
            // Values in the range [0x6,0x8000] use the same values
            // for ConfigMgr as for kernel-mode.
            //
            return (UCHAR)ResourceID;

        } else if (ResourceID & ResType_Ignored_Bit) {

            //
            // For the non arbitrated types (0x8000 bit set), do special
            // mapping to get the kernel-mode resource id type.
            //

            resid = ResourceID;
            resid &= ~(ResType_Ignored_Bit);        // clear um non-arbitrated bit
            resid |= CmResourceTypeNonArbitrated;   // set km non-arbitrated bit
            return (UCHAR)resid;

        } else {
            return (UCHAR)-1;
        }
    }

} // NT_RES_TYPE



ULONG
CM_RES_TYPE(
   IN UCHAR    ResourceType
   )
{
    ULONG resid = 0;

    if ((ResourceType < 0x06)) {

        //
        // First handle the divergent cases that can only be mapped
        // on a case by case basis. These are the values from zero
        // through five plus the special class specific case.
        //

        switch(ResourceType) {

            case CmResourceTypeNull:
                return ResType_None;

            case CmResourceTypePort:
                return ResType_IO;

            case CmResourceTypeInterrupt:
                return ResType_IRQ;

            case CmResourceTypeMemory:
                return ResType_Mem;

            case CmResourceTypeDma:
                return ResType_DMA;

            case CmResourceTypeDeviceSpecific:
                return ResType_ClassSpecific;

            DEFAULT_UNREACHABLE;
        }

    } else {

        //
        // For all other cases, rules apply as to how to map a kernel-mode
        // resource type id to a user-mode resource type id.
        //

        if (!(ResourceType & CmResourceTypeNonArbitrated)) {

            //
            // Values in the range [0x6,0x80] use the same values
            // for ConfigMgr as for kernel-mode.
            //
            return (ULONG)ResourceType;

        } else if (ResourceType & CmResourceTypeNonArbitrated) {

            //
            // For the non arbitrated types (0x80 bit set), do special
            // mapping to get the user-mode resource id type.
            //

            resid = (ULONG)ResourceType;
            resid &= ~(CmResourceTypeNonArbitrated); // clear km non-arbitrated bit
            resid |= ResType_Ignored_Bit;            // set um non-arbitrated bit
            return resid;

        } else {
            return (ULONG)-1;
        }
    }

} // NT_RES_TYPE



CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    )
{
    CONFIGRET Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(ulTag);

    //
    // fill in resource type specific info
    //
    switch (ResourceType) {

        case ResType_Mem:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MEM_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pMemData->MEM_Header.MD_Type != MType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy MEM_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeMemory;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pMemData->MEM_Header.MD_Flags, 0);
            pResDes->Flags            = MapToNtMemoryFlags(pMemData->MEM_Header.MD_Flags);

            pResDes->u.Memory.Start.HighPart = HIDWORD(pMemData->MEM_Header.MD_Alloc_Base);
            pResDes->u.Memory.Start.LowPart  = LODWORD(pMemData->MEM_Header.MD_Alloc_Base);

            pResDes->u.Memory.Length = (DWORD)(pMemData->MEM_Header.MD_Alloc_End -
                                               pMemData->MEM_Header.MD_Alloc_Base + 1);
            break;
        }


        case ResType_IO: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //
            // NOTE: alias info lost during this conversion process
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(IO_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pIoData->IO_Header.IOD_Type != IOType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy IO_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypePort;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pIoData->IO_Header.IOD_DesFlags, 0);
            pResDes->Flags            = MapToNtPortFlags(pIoData->IO_Header.IOD_DesFlags, 0);

            pResDes->u.Port.Start.HighPart = HIDWORD(pIoData->IO_Header.IOD_Alloc_Base);
            pResDes->u.Port.Start.LowPart  = LODWORD(pIoData->IO_Header.IOD_Alloc_Base);

            pResDes->u.Port.Length         = (DWORD)(pIoData->IO_Header.IOD_Alloc_End -
                                                     pIoData->IO_Header.IOD_Alloc_Base + 1);
            break;
        }


        case ResType_DMA: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DMA_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pDmaData->DMA_Header.DD_Type != DType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy DMA_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDma;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pDmaData->DMA_Header.DD_Flags, 0);
            pResDes->Flags            = MapToNtDmaFlags(pDmaData->DMA_Header.DD_Flags);

            pResDes->u.Dma.Channel   = pDmaData->DMA_Header.DD_Alloc_Chan;
            pResDes->u.Dma.Port      = 0;
            pResDes->u.Dma.Reserved1 = 0;

            break;
        }


        case ResType_IRQ: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // copy IRQ_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
                //
                pResDes->Type             = CmResourceTypeInterrupt;
                pResDes->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Header.IRQD_Flags);
                //pResDes->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Header.IRQD_Flags, 1);
                pResDes->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Header.IRQD_Flags);

                pResDes->u.Interrupt.Level    = pIrqData->IRQ_Header.IRQD_Alloc_Num;
                pResDes->u.Interrupt.Vector   = pIrqData->IRQ_Header.IRQD_Alloc_Num;

#ifdef _WIN64
                pResDes->u.Interrupt.Affinity = pIrqData->IRQ_Header.IRQD_Affinity;
#else  // !_WIN64
                pResDes->u.Interrupt.Affinity = (ULONG)pIrqData->IRQ_Header.IRQD_Affinity;
#endif // !_WIN64

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // copy IRQ_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
                //
                pResDes->Type             = CmResourceTypeInterrupt;
                pResDes->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Header.IRQD_Flags);
                //pResDes->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Header.IRQD_Flags, 1);
                pResDes->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Header.IRQD_Flags);

                pResDes->u.Interrupt.Level    = pIrqData->IRQ_Header.IRQD_Alloc_Num;
                pResDes->u.Interrupt.Vector   = pIrqData->IRQ_Header.IRQD_Alloc_Num;

                pResDes->u.Interrupt.Affinity = pIrqData->IRQ_Header.IRQD_Affinity;
            }

            break;
        }

        case ResType_DevicePrivate: {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pPrvData->PRV_Header.PD_Type != PType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy DEVICEPRIVATE_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDevicePrivate;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pPrvData->PRV_Header.PD_Flags;

            pResDes->u.DevicePrivate.Data[0] = pPrvData->PRV_Header.PD_Data1;
            pResDes->u.DevicePrivate.Data[1] = pPrvData->PRV_Header.PD_Data2;
            pResDes->u.DevicePrivate.Data[2] = pPrvData->PRV_Header.PD_Data3;
            break;
        }


        case ResType_BusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pBusData->BusNumber_Header.BUSD_Type != BusNumberType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy BUSNUMBER_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeBusNumber;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pBusData->BusNumber_Header.BUSD_Flags;

            pResDes->u.BusNumber.Start = pBusData->BusNumber_Header.BUSD_Alloc_Base;
            pResDes->u.BusNumber.Length = pBusData->BusNumber_Header.BUSD_Alloc_End;
            pResDes->u.BusNumber.Reserved = 0;
            break;
        }


        case ResType_PcCardConfig: {

            //-------------------------------------------------------
            // PcCarConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)ResourceData;
            ULONG index;
            ULONG flags;
            ULONG waitstate[2];

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pResDes->u.DevicePrivate.Data[0] = 0;
            pResDes->u.DevicePrivate.Data[1] = 0;
            pResDes->u.DevicePrivate.Data[2] = 0;

            //
            // copy PCCARD_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            PCMRES_SET_DESCRIPTOR_TYPE(pResDes, DPTYPE_PCMCIA_CONFIGURATION);
            PCMRES_SET_CONFIG_INDEX(pResDes, pPcData->PcCard_Header.PCD_ConfigIndex);
            PCMRES_SET_MEMORY_CARDBASE(pResDes, 0, pPcData->PcCard_Header.PCD_MemoryCardBase1);
            PCMRES_SET_MEMORY_CARDBASE(pResDes, 1, pPcData->PcCard_Header.PCD_MemoryCardBase2);
            
            flags = pPcData->PcCard_Header.PCD_Flags;

            if (flags & (fPCD_MEM_16 | fPCD_MEM1_16)) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_16BIT_ACCESS);
            }                
            if (flags & (fPCD_MEM_16 | fPCD_MEM2_16)) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 1, PCMRESF_MEM_16BIT_ACCESS);
            }
                
            if (flags & fPCD_MEM1_A) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_ATTRIBUTE);
            }
            if (flags & fPCD_MEM2_A) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 1, PCMRESF_MEM_ATTRIBUTE);
            }

            if (flags & fPCD_ATTRIBUTES_PER_WINDOW) {
                waitstate[0] = flags & mPCD_MEM1_WS;
                waitstate[1] = flags & mPCD_MEM2_WS;
            } else {
                waitstate[0] = waitstate[1] = flags & mPCD_MEM_WS;
            }
            
            for (index = 0; index < 2; index++) {
                switch (waitstate[index]) {

                case fPCD_MEM_WS_ONE:
                case fPCD_MEM1_WS_ONE:
                case fPCD_MEM2_WS_ONE:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_1);
                    break;
                  
                case fPCD_MEM_WS_TWO:
                case fPCD_MEM1_WS_TWO:
                case fPCD_MEM2_WS_TWO:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_2);
                    break;
                  
                case fPCD_MEM_WS_THREE:
                case fPCD_MEM1_WS_THREE:
                case fPCD_MEM2_WS_THREE:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_3);
                    break;
                }
            }                
 
            if (flags & (fPCD_IO_16 | fPCD_IO1_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_16BIT_ACCESS);
            }                    
            if (flags & (fPCD_IO_16 | fPCD_IO2_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_16BIT_ACCESS);
            }
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO1_ZW_8)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_ZERO_WAIT_8);
            }                
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO2_ZW_8)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_ZERO_WAIT_8);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO1_SRC_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO2_SRC_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_WS_16 | fPCD_IO1_WS_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_WAIT_16);
            }                
            if (flags & (fPCD_IO_WS_16 | fPCD_IO2_WS_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_WAIT_16);
            }

            break;
        }

        case ResType_MfCardConfig: {

            //-------------------------------------------------------
            // MfCardConfig Resource Type
            //-------------------------------------------------------

            PMFCARD_RESOURCE  pMfData = (PMFCARD_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MFCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pResDes->u.DevicePrivate.Data[0] = 0;
            pResDes->u.DevicePrivate.Data[1] = 0;
            pResDes->u.DevicePrivate.Data[2] = 0;

            //
            // copy MFCARD_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            PCMRES_SET_DESCRIPTOR_TYPE(pResDes, DPTYPE_PCMCIA_MF_CONFIGURATION);
            PCMRES_SET_CONFIG_OPTIONS(pResDes, pMfData->MfCard_Header.PMF_ConfigOptions);
            PCMRES_SET_PORT_RESOURCE_INDEX(pResDes, pMfData->MfCard_Header.PMF_IoResourceIndex);
            PCMRES_SET_CONFIG_REGISTER_BASE(pResDes, pMfData->MfCard_Header.PMF_ConfigRegisterBase);

            if ((pMfData->MfCard_Header.PMF_Flags & mPMF_AUDIO_ENABLE) == fPMF_AUDIO_ENABLE) {
                PCMRES_SET_AUDIO_ENABLE(pResDes);
            }
            break;
        }


        case ResType_ClassSpecific: {

            //-------------------------------------------------------
            // Class Specific Resource Type
            //-------------------------------------------------------

            PCS_RESOURCE   pCsData = (PCS_RESOURCE)ResourceData;
            LPBYTE         ptr = NULL;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(CS_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // copy CS_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDeviceSpecific;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pCsData->CS_Header.CSD_Flags; // none defined

            pResDes->u.DeviceSpecificData.DataSize  = pCsData->CS_Header.CSD_LegacyDataSize +
                                                      sizeof(GUID) +
                                                      pCsData->CS_Header.CSD_SignatureLength;

            pResDes->u.DeviceSpecificData.Reserved1 = pCsData->CS_Header.CSD_LegacyDataSize;
            pResDes->u.DeviceSpecificData.Reserved2 = pCsData->CS_Header.CSD_SignatureLength;

            //
            // copy the legacy and class-specific signature data
            //
            ptr = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

            memcpy(ptr,
                   pCsData->CS_Header.CSD_Signature + pCsData->CS_Header.CSD_LegacyDataOffset,
                   pCsData->CS_Header.CSD_LegacyDataSize);      // copy legacy data first...

            ptr += pCsData->CS_Header.CSD_LegacyDataSize;

            memcpy(ptr,
                   pCsData->CS_Header.CSD_Signature,
                   pCsData->CS_Header.CSD_SignatureLength);     // then copy signature...

            ptr += pCsData->CS_Header.CSD_SignatureLength;

            memcpy(ptr,
                   &pCsData->CS_Header.CSD_ClassGuid,
                   sizeof(GUID));                               // then copy GUID
            break;
        }

        default:
            Status = CR_INVALID_RESOURCEID;
            break;
   }

   Clean0:

   return Status;

} // ResDesToNtResource



CONFIGRET
ResDesToNtRequirements(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PIO_RESOURCE_DESCRIPTOR          pReqDes,
    IN OUT PULONG                           pulResCount,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    )
{
    CONFIGRET               Status = CR_SUCCESS;
    ULONG                   i = 0;
    PIO_RESOURCE_DESCRIPTOR pCurrent = NULL;

    UNREFERENCED_PARAMETER(ulTag);

    //
    // fill in resource type specific info
    //
    switch (ResourceType) {

        case ResType_Mem:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MEM_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pMemData->MEM_Header.MD_Type != MType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pMemData->MEM_Header.MD_Count;

            //
            // copy MEM_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeMemory;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pMemData->MEM_Data[i].MR_Flags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags = MapToNtMemoryFlags(pMemData->MEM_Data[i].MR_Flags);

                pCurrent->u.Memory.Length    = pMemData->MEM_Data[i].MR_nBytes;
                pCurrent->u.Memory.Alignment = MapToNtAlignment(pMemData->MEM_Data[i].MR_Align);

                pCurrent->u.Memory.MinimumAddress.HighPart = HIDWORD(pMemData->MEM_Data[i].MR_Min);
                pCurrent->u.Memory.MinimumAddress.LowPart  = LODWORD(pMemData->MEM_Data[i].MR_Min);

                pCurrent->u.Memory.MaximumAddress.HighPart = HIDWORD(pMemData->MEM_Data[i].MR_Max);
                pCurrent->u.Memory.MaximumAddress.LowPart  = LODWORD(pMemData->MEM_Data[i].MR_Max);
            }
            break;
        }


        case ResType_IO: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(IO_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pIoData->IO_Header.IOD_Type != IOType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pIoData->IO_Header.IOD_Count;

            //
            // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypePort;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pIoData->IO_Data[i].IOR_RangeFlags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags  = MapToNtPortFlags(pIoData->IO_Data[i].IOR_RangeFlags,
                                                    (DWORD)pIoData->IO_Data[i].IOR_Alias);

                pCurrent->u.Port.Length = pIoData->IO_Data[i].IOR_nPorts;

                pCurrent->u.Port.Alignment = MapToNtAlignment(pIoData->IO_Data[i].IOR_Align);

                pCurrent->u.Port.MinimumAddress.HighPart = HIDWORD(pIoData->IO_Data[i].IOR_Min);
                pCurrent->u.Port.MinimumAddress.LowPart  = LODWORD(pIoData->IO_Data[i].IOR_Min);

                pCurrent->u.Port.MaximumAddress.HighPart = HIDWORD(pIoData->IO_Data[i].IOR_Max);
                pCurrent->u.Port.MaximumAddress.LowPart  = LODWORD(pIoData->IO_Data[i].IOR_Max);
            }
            break;
        }


        case ResType_DMA: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DMA_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pDmaData->DMA_Header.DD_Type != DType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pDmaData->DMA_Header.DD_Count;

            //
            // copy DMA_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeDma;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pDmaData->DMA_Data[i].DR_Flags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags = MapToNtDmaFlags(pDmaData->DMA_Data[i].DR_Flags);

                pCurrent->u.Dma.MinimumChannel = pDmaData->DMA_Data[i].DR_Min;
                pCurrent->u.Dma.MaximumChannel = pDmaData->DMA_Data[i].DR_Max;
            }
            break;
        }


        case ResType_IRQ: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }


                *pulResCount = pIrqData->IRQ_Header.IRQD_Count;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (i = 0, pCurrent = pReqDes;
                     i < *pulResCount;
                     i++, pCurrent++) {

                    if (i == 0) {
                        pCurrent->Option = 0;
                    } else {
                        pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                    }

                    pCurrent->Type   = CmResourceTypeInterrupt;
                    pCurrent->Spare1 = 0;
                    pCurrent->Spare2 = 0;

                    pCurrent->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Data[i].IRQR_Flags);
                    //pCurrent->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Data[i].IRQR_Flags, 1);
                    pCurrent->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Data[i].IRQR_Flags);

                    pCurrent->u.Interrupt.MinimumVector = pIrqData->IRQ_Data[i].IRQR_Min;
                    pCurrent->u.Interrupt.MaximumVector = pIrqData->IRQ_Data[i].IRQR_Max;
                }

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }


                *pulResCount = pIrqData->IRQ_Header.IRQD_Count;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (i = 0, pCurrent = pReqDes;
                     i < *pulResCount;
                     i++, pCurrent++) {

                    if (i == 0) {
                        pCurrent->Option = 0;
                    } else {
                        pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                    }

                    pCurrent->Type   = CmResourceTypeInterrupt;
                    pCurrent->Spare1 = 0;
                    pCurrent->Spare2 = 0;

                    pCurrent->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Data[i].IRQR_Flags);
                    //pCurrent->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Data[i].IRQR_Flags, 1);
                    pCurrent->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Data[i].IRQR_Flags);

                    pCurrent->u.Interrupt.MinimumVector = pIrqData->IRQ_Data[i].IRQR_Min;
                    pCurrent->u.Interrupt.MaximumVector = pIrqData->IRQ_Data[i].IRQR_Max;
                }
            }
            break;
        }


        case ResType_DevicePrivate:    {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pPrvData->PRV_Header.PD_Type != PType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pPrvData->PRV_Header.PD_Count;

            //
            // copy DEVICEPRIVATE_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeDevicePrivate;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;
                pCurrent->Flags            = (USHORT)pPrvData->PRV_Header.PD_Flags;

                pCurrent->u.DevicePrivate.Data[0] = pPrvData->PRV_Data[i].PR_Data1;
                pCurrent->u.DevicePrivate.Data[1] = pPrvData->PRV_Data[i].PR_Data2;
                pCurrent->u.DevicePrivate.Data[2] = pPrvData->PRV_Data[i].PR_Data3;
            }
            break;
        }


        case ResType_BusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pBusData->BusNumber_Header.BUSD_Type != BusNumberType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pBusData->BusNumber_Header.BUSD_Count;

            //
            // copy BUSNUMBER_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeBusNumber;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;
                pCurrent->Flags            = (USHORT)pBusData->BusNumber_Data[i].BUSR_Flags;

                pCurrent->u.BusNumber.Length       = pBusData->BusNumber_Data[i].BUSR_nBusNumbers;
                pCurrent->u.BusNumber.MinBusNumber = pBusData->BusNumber_Data[i].BUSR_Min;
                pCurrent->u.BusNumber.MaxBusNumber = pBusData->BusNumber_Data[i].BUSR_Max;
                pCurrent->u.BusNumber.Reserved     = 0;
            }
            break;
        }


        case ResType_PcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)ResourceData;
            ULONG index;
            ULONG flags;
            ULONG waitstate[2];

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = 1;

            //
            // copy PCCARD_DES info to IO_RESOURCE_DESCRIPTOR format
            //
            pReqDes->Option = 0;
            pReqDes->Type             = CmResourceTypeDevicePrivate;
            pReqDes->ShareDisposition = CmResourceShareUndetermined;
            pReqDes->Spare1           = 0;
            pReqDes->Spare2           = 0;
            pReqDes->Flags            = 0;

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pReqDes->u.DevicePrivate.Data[0] = 0;
            pReqDes->u.DevicePrivate.Data[1] = 0;
            pReqDes->u.DevicePrivate.Data[2] = 0;

            PCMRES_SET_DESCRIPTOR_TYPE(pReqDes, DPTYPE_PCMCIA_CONFIGURATION);
            PCMRES_SET_CONFIG_INDEX(pReqDes, pPcData->PcCard_Header.PCD_ConfigIndex);
            PCMRES_SET_MEMORY_CARDBASE(pReqDes, 0, pPcData->PcCard_Header.PCD_MemoryCardBase1);
            PCMRES_SET_MEMORY_CARDBASE(pReqDes, 1, pPcData->PcCard_Header.PCD_MemoryCardBase2);
            
            flags = pPcData->PcCard_Header.PCD_Flags;

            if (flags & (fPCD_MEM_16 | fPCD_MEM1_16)) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_16BIT_ACCESS);
            }                
            if (flags & (fPCD_MEM_16 | fPCD_MEM2_16)) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 1, PCMRESF_MEM_16BIT_ACCESS);
            }
                
            if (flags & fPCD_MEM1_A) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_ATTRIBUTE);
            }
            if (flags & fPCD_MEM2_A) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 1, PCMRESF_MEM_ATTRIBUTE);
            }

            if (flags & fPCD_ATTRIBUTES_PER_WINDOW) {
                waitstate[0] = flags & mPCD_MEM1_WS;
                waitstate[1] = flags & mPCD_MEM2_WS;
            } else {
                waitstate[0] = waitstate[1] = flags & mPCD_MEM_WS;
            }
            
            for (index = 0; index < 2; index++) {
                switch (waitstate[index]) {

                case fPCD_MEM_WS_ONE:
                case fPCD_MEM1_WS_ONE:
                case fPCD_MEM2_WS_ONE:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_1);
                    break;
                  
                case fPCD_MEM_WS_TWO:
                case fPCD_MEM1_WS_TWO:
                case fPCD_MEM2_WS_TWO:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_2);
                    break;
                  
                case fPCD_MEM_WS_THREE:
                case fPCD_MEM1_WS_THREE:
                case fPCD_MEM2_WS_THREE:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_3);
                    break;
                }
            }                
 
            if (flags & (fPCD_IO_16 | fPCD_IO1_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_16BIT_ACCESS);
            }                    
            if (flags & (fPCD_IO_16 | fPCD_IO2_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_16BIT_ACCESS);
            }
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO1_ZW_8)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_ZERO_WAIT_8);
            }                
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO2_ZW_8)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_ZERO_WAIT_8);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO1_SRC_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO2_SRC_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_WS_16 | fPCD_IO1_WS_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_WAIT_16);
            }                
            if (flags & (fPCD_IO_WS_16 | fPCD_IO2_WS_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_WAIT_16);
            }

            break;
        }

        case ResType_MfCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PMFCARD_RESOURCE  pMfData = (PMFCARD_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MFCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = 1;

            //
            // copy PCCARD_DES info to IO_RESOURCE_DESCRIPTOR format
            //
            pReqDes->Option = 0;
            pReqDes->Type             = CmResourceTypeDevicePrivate;
            pReqDes->ShareDisposition = CmResourceShareUndetermined;
            pReqDes->Spare1           = 0;
            pReqDes->Spare2           = 0;
            pReqDes->Flags            = 0;

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pReqDes->u.DevicePrivate.Data[0] = 0;
            pReqDes->u.DevicePrivate.Data[1] = 0;
            pReqDes->u.DevicePrivate.Data[2] = 0;

            PCMRES_SET_DESCRIPTOR_TYPE(pReqDes, DPTYPE_PCMCIA_MF_CONFIGURATION);
            PCMRES_SET_CONFIG_OPTIONS(pReqDes, pMfData->MfCard_Header.PMF_ConfigOptions);
            PCMRES_SET_PORT_RESOURCE_INDEX(pReqDes, pMfData->MfCard_Header.PMF_IoResourceIndex);
            PCMRES_SET_CONFIG_REGISTER_BASE(pReqDes, pMfData->MfCard_Header.PMF_ConfigRegisterBase);

            if ((pMfData->MfCard_Header.PMF_Flags & mPMF_AUDIO_ENABLE) == fPMF_AUDIO_ENABLE) {
                PCMRES_SET_AUDIO_ENABLE(pReqDes);
            }
            break;
        }

        default:
            Status = CR_INVALID_RESOURCEID;
            break;
   }

   Clean0:

   return Status;

} // ResDesToNtRequirements



CONFIGRET
NtResourceToResDes(
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    )
{
    CONFIGRET   Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(pLastAddr);

    //
    // fill in resource type specific info
    //
    switch (pResDes->Type) {

        case CmResourceTypeMemory:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(MEM_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pMemData->MEM_Header.MD_Count    = 0;
            pMemData->MEM_Header.MD_Type     = MType_Range;
            pMemData->MEM_Header.MD_Flags    = MapFromNtMemoryFlags(pResDes->Flags);
            //pMemData->MEM_Header.MD_Flags   |= MapFromNtDisposition(pResDes->ShareDisposition, 0);
            pMemData->MEM_Header.MD_Reserved = 0;

            if (pResDes->u.Memory.Length != 0) {

                pMemData->MEM_Header.MD_Alloc_Base = MAKEDWORDLONG(pResDes->u.Memory.Start.LowPart,
                                                                   pResDes->u.Memory.Start.HighPart);

                pMemData->MEM_Header.MD_Alloc_End  = pMemData->MEM_Header.MD_Alloc_Base +
                                                    (DWORDLONG)pResDes->u.Memory.Length - 1;
            } else {

                pMemData->MEM_Header.MD_Alloc_Base = 1;
                pMemData->MEM_Header.MD_Alloc_End  = 0;
            }
            break;
        }

        case CmResourceTypePort: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //
            // NOTE: alias info lost during this conversion process
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(IO_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IO_DES format
            //
            pIoData->IO_Header.IOD_Count     = 0;
            pIoData->IO_Header.IOD_Type      = IOType_Range;

            pIoData->IO_Header.IOD_DesFlags   = MapFromNtPortFlags(pResDes->Flags);
            //pIoData->IO_Header.IOD_DesFlags  |= MapFromNtDisposition(pResDes->ShareDisposition, 0);

            if (pResDes->u.Port.Length) {

                pIoData->IO_Header.IOD_Alloc_Base = MAKEDWORDLONG(pResDes->u.Port.Start.LowPart,
                                                                  pResDes->u.Port.Start.HighPart);

                pIoData->IO_Header.IOD_Alloc_End  = pIoData->IO_Header.IOD_Alloc_Base +
                                                    (DWORDLONG)pResDes->u.Port.Length - 1;
            } else {

                pIoData->IO_Header.IOD_Alloc_Base = 1;
                pIoData->IO_Header.IOD_Alloc_End  = 0;
            }
            break;
        }


        case CmResourceTypeDma: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(DMA_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DMA_DES format
            //
            pDmaData->DMA_Header.DD_Count      = 0;
            pDmaData->DMA_Header.DD_Type       = DType_Range;
            pDmaData->DMA_Header.DD_Flags      = MapFromNtDmaFlags(pResDes->Flags);
            //pDmaData->DMA_Header.DD_Flags     |= MapFromNtDisposition(pResDes->ShareDisposition, 0);
            pDmaData->DMA_Header.DD_Alloc_Chan = pResDes->u.Dma.Channel;

            break;
        }

        case CmResourceTypeInterrupt: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)Buffer;

                //
                // verify passed in buffer size
                //
                if (BufferLen < GetResDesSize(ResType_IRQ, ulFlags)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count  = 0;
                pIrqData->IRQ_Header.IRQD_Type   = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags  = MapFromNtIrqFlags(pResDes->Flags) |
                                                   MapFromNtIrqShare(pResDes->ShareDisposition);
                //pIrqData->IRQ_Header.IRQD_Flags |= MapFromNtDisposition(pResDes->ShareDisposition, 1);

                pIrqData->IRQ_Header.IRQD_Alloc_Num = pResDes->u.Interrupt.Level;

                pIrqData->IRQ_Header.IRQD_Affinity = pResDes->u.Interrupt.Affinity;
            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)Buffer;

                //
                // verify passed in buffer size
                //
                if (BufferLen < GetResDesSize(ResType_IRQ, ulFlags)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count  = 0;
                pIrqData->IRQ_Header.IRQD_Type   = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags  = MapFromNtIrqFlags(pResDes->Flags) |
                                                   MapFromNtIrqShare(pResDes->ShareDisposition);
                //pIrqData->IRQ_Header.IRQD_Flags |= MapFromNtDisposition(pResDes->ShareDisposition, 1);

                pIrqData->IRQ_Header.IRQD_Alloc_Num = pResDes->u.Interrupt.Level;

#ifdef _WIN64
                pIrqData->IRQ_Header.IRQD_Affinity = (ULONG)((pResDes->u.Interrupt.Affinity >> 32) |
                                                             pResDes->u.Interrupt.Affinity);
#else  // !_WIN64
                pIrqData->IRQ_Header.IRQD_Affinity = pResDes->u.Interrupt.Affinity;
#endif // !_WIN64
            }
            break;
        }

        case CmResourceTypeDevicePrivate: {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE   pPrvData = (PDEVPRIVATE_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DEVICEPRIVATE_DES format
            //
            pPrvData->PRV_Header.PD_Count = 0;
            pPrvData->PRV_Header.PD_Type  = PType_Range;

            pPrvData->PRV_Header.PD_Data1 = pResDes->u.DevicePrivate.Data[0];
            pPrvData->PRV_Header.PD_Data2 = pResDes->u.DevicePrivate.Data[1];
            pPrvData->PRV_Header.PD_Data3 = pResDes->u.DevicePrivate.Data[2];

            pPrvData->PRV_Header.PD_Flags = pResDes->Flags;
            break;
        }


        case CmResourceTypeBusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE   pBusData = (PBUSNUMBER_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to BUSNUMBER_DES format
            //
            pBusData->BusNumber_Header.BUSD_Count = 0;
            pBusData->BusNumber_Header.BUSD_Type  = BusNumberType_Range;
            pBusData->BusNumber_Header.BUSD_Flags = pResDes->Flags;
            pBusData->BusNumber_Header.BUSD_Alloc_Base = pResDes->u.BusNumber.Start;
            pBusData->BusNumber_Header.BUSD_Alloc_End = pResDes->u.BusNumber.Start +
                                                        pResDes->u.BusNumber.Length - 1;
            break;
        }

        case CmResourceTypePcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE   pPcData = (PPCCARD_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to PCCARD_DES format
            //
            pPcData->PcCard_Header.PCD_Reserved[0] = 0;
            pPcData->PcCard_Header.PCD_Reserved[1] = 0;
            pPcData->PcCard_Header.PCD_Reserved[2] = 0;
            pPcData->PcCard_Header.PCD_ConfigIndex = PCMRES_GET_CONFIG_INDEX(pResDes);
            pPcData->PcCard_Header.PCD_MemoryCardBase1 = PCMRES_GET_MEMORY_CARDBASE(pResDes, 0);
            pPcData->PcCard_Header.PCD_MemoryCardBase2 = PCMRES_GET_MEMORY_CARDBASE(pResDes, 1);

            if (PCMRES_GET_IO_FLAG(pResDes, 0, PCMRESF_IO_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_8;
            }
            if (PCMRES_GET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_8;
            }
            break;
        }


        case CmResourceTypeDeviceSpecific: {

            //-------------------------------------------------------
            // Class Specific Resource Type
            //-------------------------------------------------------

            PCS_RESOURCE   pCsData = (PCS_RESOURCE)Buffer;
            LPBYTE         ptr1 = NULL, ptr2 = NULL;
            ULONG          ulRequiredSize = sizeof(CS_RESOURCE);

            //
            // the Reserved fields should not exceed DataSize. if so, they
            // may have been incorrectly initialized, so set them 0.
            // we expect DataSize to be correct in all cases.
            //
            if (pResDes->u.DeviceSpecificData.Reserved1 > pResDes->u.DeviceSpecificData.DataSize) {
                pResDes->u.DeviceSpecificData.Reserved1 = 0;
            }
            if (pResDes->u.DeviceSpecificData.Reserved2 > pResDes->u.DeviceSpecificData.DataSize) {
                pResDes->u.DeviceSpecificData.Reserved2 = 0;
            }

            //
            // verify passed in buffer size
            //
            if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                //
                // there is no legacy data and no class-specific data
                //
                ;
            } else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                //
                // add space for legacy data
                //
                ulRequiredSize += pResDes->u.DeviceSpecificData.DataSize - 1;
            } else {
                //
                // add space for legacy and signature data, as necessary
                //
                ulRequiredSize += pResDes->u.DeviceSpecificData.Reserved1 +
                                  pResDes->u.DeviceSpecificData.Reserved2 - 1;
            }

            if (BufferLen < ulRequiredSize) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to CS_DES format
            //
            pCsData->CS_Header.CSD_Flags = (DWORD)pResDes->Flags;  // none defined


            if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                //
                // There is no legacy data and no class-specific data
                //
                pCsData->CS_Header.CSD_SignatureLength  = 0;
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   = 0;
                pCsData->CS_Header.CSD_Signature[0]     = 0x0;

                memset(&pCsData->CS_Header.CSD_ClassGuid, 0, sizeof(GUID));
            }

            else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                //
                // There is only legacy data
                //
                pCsData->CS_Header.CSD_SignatureLength  = 0;
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   =
                                    pResDes->u.DeviceSpecificData.DataSize;
                pCsData->CS_Header.CSD_Signature[0] = 0x0;

                memset(&pCsData->CS_Header.CSD_ClassGuid, 0, sizeof(GUID));

                ptr1 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(&pCsData->CS_Header.CSD_Signature, ptr1,
                       pResDes->u.DeviceSpecificData.DataSize);
            }

            else if (pResDes->u.DeviceSpecificData.Reserved1 == 0) {
                //
                // There is only class-specific data
                //
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   = 0;

                pCsData->CS_Header.CSD_SignatureLength  =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                ptr1 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(pCsData->CS_Header.CSD_Signature, ptr1,
                       pResDes->u.DeviceSpecificData.Reserved2);

                ptr1 += pResDes->u.DeviceSpecificData.Reserved2;

                memcpy((LPBYTE)&pCsData->CS_Header.CSD_ClassGuid, ptr1, sizeof(GUID));
            }

            else {
                //
                // There is both legacy data and class-specific data
                //

                //
                // copy legacy data
                //
                pCsData->CS_Header.CSD_LegacyDataOffset =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                pCsData->CS_Header.CSD_LegacyDataSize   =
                                        pResDes->u.DeviceSpecificData.Reserved1;

                ptr1 = pCsData->CS_Header.CSD_Signature +
                       pCsData->CS_Header.CSD_LegacyDataOffset;

                ptr2 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(ptr1, ptr2, pResDes->u.DeviceSpecificData.Reserved1);

                //
                // copy signature and class guid
                //
                pCsData->CS_Header.CSD_SignatureLength  =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                ptr2 += pResDes->u.DeviceSpecificData.Reserved1;

                memcpy(pCsData->CS_Header.CSD_Signature, ptr2,
                       pResDes->u.DeviceSpecificData.Reserved2);

                ptr2 += pResDes->u.DeviceSpecificData.Reserved2;

                memcpy((LPBYTE)&pCsData->CS_Header.CSD_ClassGuid, ptr2, sizeof(GUID));
            }
            break;
        }

        default:
            break;
   }

   Clean0:

   return Status;

} // NtResourceToResDes



CONFIGRET
NtRequirementsToResDes(
    IN     PIO_RESOURCE_DESCRIPTOR         pReqDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    )
{
    CONFIGRET               Status = CR_SUCCESS;
    ULONG                   count = 0, i = 0, ReqPartialCount = 0;
    PIO_RESOURCE_DESCRIPTOR pCurrent = NULL;

    //
    // fill in resource type specific info
    //
    switch (pReqDes->Type) {

        case CmResourceTypeMemory:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(MEM_RESOURCE) +
                            sizeof(MEM_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pMemData->MEM_Header.MD_Count      = ReqPartialCount;
            pMemData->MEM_Header.MD_Type       = MType_Range;
            pMemData->MEM_Header.MD_Flags      = 0;
            pMemData->MEM_Header.MD_Reserved   = 0;
            pMemData->MEM_Header.MD_Alloc_Base = 0;
            pMemData->MEM_Header.MD_Alloc_End  = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypeMemory) {
                    pMemData->MEM_Data[i].MR_Align    = MapFromNtAlignment(pCurrent->u.Memory.Alignment);
                    pMemData->MEM_Data[i].MR_nBytes   = pCurrent->u.Memory.Length;

                    pMemData->MEM_Data[i].MR_Min      = MAKEDWORDLONG(
                                                        pCurrent->u.Memory.MinimumAddress.LowPart,
                                                        pCurrent->u.Memory.MinimumAddress.HighPart);

                    pMemData->MEM_Data[i].MR_Max      = MAKEDWORDLONG(
                                                        pCurrent->u.Memory.MaximumAddress.LowPart,
                                                        pCurrent->u.Memory.MaximumAddress.HighPart);

                    pMemData->MEM_Data[i].MR_Flags    = MapFromNtMemoryFlags(pCurrent->Flags);
                    //pMemData->MEM_Data[i].MR_Flags   |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    pMemData->MEM_Data[i].MR_Reserved = 0;
                    i++;
                }
            }
            pMemData->MEM_Header.MD_Count = i;
            break;
        }

        case CmResourceTypePort: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(IO_RESOURCE) +
                            sizeof(IO_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IO_DES format
            //
            pIoData->IO_Header.IOD_Count        = ReqPartialCount;
            pIoData->IO_Header.IOD_Type         = IOType_Range;
            pIoData->IO_Header.IOD_Alloc_Base   = 0;
            pIoData->IO_Header.IOD_Alloc_End    = 0;
            pIoData->IO_Header.IOD_DesFlags     = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to IO_RANGE format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypePort) {
                    pIoData->IO_Data[i].IOR_Align       = MapFromNtAlignment(pCurrent->u.Port.Alignment);
                    pIoData->IO_Data[i].IOR_nPorts      = pCurrent->u.Port.Length;
                    pIoData->IO_Data[i].IOR_Min         = MAKEDWORDLONG(
                                                              pCurrent->u.Port.MinimumAddress.LowPart,
                                                              pCurrent->u.Port.MinimumAddress.HighPart);
                    pIoData->IO_Data[i].IOR_Max         = MAKEDWORDLONG(
                                                              pCurrent->u.Port.MaximumAddress.LowPart,
                                                              pCurrent->u.Port.MaximumAddress.HighPart);

                    pIoData->IO_Data[i].IOR_RangeFlags  = MapFromNtPortFlags(pCurrent->Flags);
                    //pIoData->IO_Data[i].IOR_RangeFlags |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    pIoData->IO_Data[i].IOR_Alias       = MapAliasFromNtPortFlags(pCurrent->Flags);
                    i++;
                }
            }
            pIoData->IO_Header.IOD_Count = i;
            break;
        }

        case CmResourceTypeDma: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(DMA_RESOURCE) +
                            sizeof(DMA_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DMA_DES format
            //
            pDmaData->DMA_Header.DD_Count      = ReqPartialCount;
            pDmaData->DMA_Header.DD_Type       = DType_Range;
            pDmaData->DMA_Header.DD_Flags      = 0;
            pDmaData->DMA_Header.DD_Alloc_Chan = 0;

            //
            // copy DMA_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypeDma) {
                    pDmaData->DMA_Data[i].DR_Min    = pCurrent->u.Dma.MinimumChannel;
                    pDmaData->DMA_Data[i].DR_Max    = pCurrent->u.Dma.MaximumChannel;
                    pDmaData->DMA_Data[i].DR_Flags  = MapFromNtDmaFlags(pCurrent->Flags);
                    //pDmaData->DMA_Data[i].DR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    i++;
                }
            }
            pDmaData->DMA_Header.DD_Count = i;
            break;
        }

        case CmResourceTypeInterrupt: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)Buffer;

                //
                // verify passed in buffer size
                //
                ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

                if (BufferLen < sizeof(IRQ_RESOURCE_64) +
                                sizeof(IRQ_RANGE) * (ReqPartialCount - 1)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count     = ReqPartialCount;
                pIrqData->IRQ_Header.IRQD_Type      = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags     = 0;
                pIrqData->IRQ_Header.IRQD_Alloc_Num = 0;
                pIrqData->IRQ_Header.IRQD_Affinity  = 0;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (count = 0, i = 0, pCurrent = pReqDes;
                     count < ReqPartialCount;
                     count++, pCurrent++) {

                    if (pCurrent->Type == CmResourceTypeInterrupt) {
                        pIrqData->IRQ_Data[i].IRQR_Min    = pCurrent->u.Interrupt.MinimumVector;
                        pIrqData->IRQ_Data[i].IRQR_Max    = pCurrent->u.Interrupt.MaximumVector;
                        pIrqData->IRQ_Data[i].IRQR_Flags  = MapFromNtIrqFlags(pCurrent->Flags) |
                                                            MapFromNtIrqShare(pCurrent->ShareDisposition);
                        //pIrqData->IRQ_Data[i].IRQR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 1);
                        i++;
                    }
                }
                pIrqData->IRQ_Header.IRQD_Count = i;

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)Buffer;

                //
                // verify passed in buffer size
                //
                ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

                if (BufferLen < sizeof(IRQ_RESOURCE_32) +
                                sizeof(IRQ_RANGE) * (ReqPartialCount - 1)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count     = ReqPartialCount;
                pIrqData->IRQ_Header.IRQD_Type      = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags     = 0;
                pIrqData->IRQ_Header.IRQD_Alloc_Num = 0;
                pIrqData->IRQ_Header.IRQD_Affinity  = 0;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (count = 0, i = 0, pCurrent = pReqDes;
                     count < ReqPartialCount;
                     count++, pCurrent++) {

                    if (pCurrent->Type == CmResourceTypeInterrupt) {
                        pIrqData->IRQ_Data[i].IRQR_Min    = pCurrent->u.Interrupt.MinimumVector;
                        pIrqData->IRQ_Data[i].IRQR_Max    = pCurrent->u.Interrupt.MaximumVector;
                        pIrqData->IRQ_Data[i].IRQR_Flags  = MapFromNtIrqFlags(pCurrent->Flags) |
                                                            MapFromNtIrqShare(pCurrent->ShareDisposition);
                        //pIrqData->IRQ_Data[i].IRQR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 1);
                        i++;
                    }
                }
                pIrqData->IRQ_Header.IRQD_Count = i;
            }
            break;
        }

        case CmResourceTypeDevicePrivate:    {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(DEVPRIVATE_RESOURCE) +
                            sizeof(DEVPRIVATE_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pPrvData->PRV_Header.PD_Count = ReqPartialCount;
            pPrvData->PRV_Header.PD_Type  = PType_Range;
            pPrvData->PRV_Header.PD_Data1 = 0;
            pPrvData->PRV_Header.PD_Data2 = 0;
            pPrvData->PRV_Header.PD_Data3 = 0;
            pPrvData->PRV_Header.PD_Flags = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < ReqPartialCount;
                 i++, pCurrent++) {

                pPrvData->PRV_Data[i].PR_Data1 = pCurrent->u.DevicePrivate.Data[0];
                pPrvData->PRV_Data[i].PR_Data2 = pCurrent->u.DevicePrivate.Data[1];
                pPrvData->PRV_Data[i].PR_Data3 = pCurrent->u.DevicePrivate.Data[2];
            }
            break;
        }


        case CmResourceTypeBusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(BUSNUMBER_RESOURCE) +
                            sizeof(BUSNUMBER_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to BUSNUMBER_DES format
            //
            pBusData->BusNumber_Header.BUSD_Count      = ReqPartialCount;
            pBusData->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pBusData->BusNumber_Header.BUSD_Flags      = 0;
            pBusData->BusNumber_Header.BUSD_Alloc_Base = 0;
            pBusData->BusNumber_Header.BUSD_Alloc_End  = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < ReqPartialCount;
                 i++, pCurrent++) {

                pBusData->BusNumber_Data[i].BUSR_Min         = pCurrent->u.BusNumber.MinBusNumber;
                pBusData->BusNumber_Data[i].BUSR_Max         = pCurrent->u.BusNumber.MaxBusNumber;
                pBusData->BusNumber_Data[i].BUSR_nBusNumbers = pCurrent->u.BusNumber.Length;
                pBusData->BusNumber_Data[i].BUSR_Flags       = pCurrent->Flags;
            }
            break;
        }


        case CmResourceTypePcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy IO_RESOURCE_DESCRIPTOR info to PCCARD_DES format
            //
            pPcData->PcCard_Header.PCD_Reserved[0] = 0;
            pPcData->PcCard_Header.PCD_Reserved[1] = 0;
            pPcData->PcCard_Header.PCD_Reserved[2] = 0;
            pPcData->PcCard_Header.PCD_ConfigIndex = PCMRES_GET_CONFIG_INDEX(pReqDes);
            pPcData->PcCard_Header.PCD_MemoryCardBase1 = PCMRES_GET_MEMORY_CARDBASE(pReqDes, 0);
            pPcData->PcCard_Header.PCD_MemoryCardBase2 = PCMRES_GET_MEMORY_CARDBASE(pReqDes, 1);

            if (PCMRES_GET_IO_FLAG(pReqDes, 0, PCMRESF_IO_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_8;
            }

            if (PCMRES_GET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_8;
            }            
            break;
        }

        default:
            break;
   }

   Clean0:

   return Status;

} // NtRequirementsToResDes



//-------------------------------------------------------------------
// Routines to map flags between ConfigMgr and NT types
//-------------------------------------------------------------------

USHORT MapToNtMemoryFlags(IN DWORD CmMemoryFlags)
{
   USHORT NtMemoryFlags = 0x0;

   if (((CmMemoryFlags & mMD_MemoryType) == fMD_ROM) &&
       ((CmMemoryFlags & mMD_Readable) == fMD_ReadAllowed)) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_READ_ONLY;
   }
   else if (((CmMemoryFlags & mMD_MemoryType) == fMD_RAM) &&
            ((CmMemoryFlags & mMD_Readable) == fMD_ReadDisallowed)) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_WRITE_ONLY;
   }
   else {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_READ_WRITE;
   }

   if ((CmMemoryFlags & mMD_32_24) == fMD_24) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_24;
   }

   if ((CmMemoryFlags & mMD_Prefetchable) == fMD_PrefetchAllowed) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
   }

   if ((CmMemoryFlags & mMD_CombinedWrite) == fMD_CombinedWriteAllowed) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_COMBINEDWRITE;
   }

   if ((CmMemoryFlags & mMD_Cacheable) == fMD_Cacheable) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_CACHEABLE;
   }

   return NtMemoryFlags;
}



DWORD MapFromNtMemoryFlags(IN USHORT NtMemoryFlags)
{
   DWORD CmMemoryFlags = 0x0;

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_READ_ONLY) {
      CmMemoryFlags |= (fMD_ReadAllowed | fMD_ROM);
   }
   else if (NtMemoryFlags & CM_RESOURCE_MEMORY_WRITE_ONLY) {
      CmMemoryFlags |= (fMD_ReadDisallowed | fMD_RAM);
   }
   else {
      CmMemoryFlags |= (fMD_ReadAllowed | fMD_RAM);
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
      CmMemoryFlags |= fMD_PrefetchAllowed;
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {
      CmMemoryFlags |= fMD_CombinedWriteAllowed;
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_CACHEABLE) {
      CmMemoryFlags |= fMD_Cacheable;
   }

   if (!(NtMemoryFlags & CM_RESOURCE_MEMORY_24)) {
       CmMemoryFlags |= fMD_32;
   }

   return CmMemoryFlags;
}



USHORT MapToNtPortFlags(IN DWORD CmPortFlags, IN DWORD CmAlias)
{
    USHORT NtFlags = 0;

    if ((CmPortFlags & fIOD_PortType) == fIOD_Memory) {
        NtFlags |= CM_RESOURCE_PORT_MEMORY;
    } else {
        NtFlags |= CM_RESOURCE_PORT_IO;
    }

    //
    // CmAlias uses the following rule:
    //
    // Positive Decode = 0xFF
    // 10-bit decode   = 0x0004 (2 ^ 2)
    // 12-bit decode   = 0x0010 (2 ^ 4)
    // 16-bit decode   = 0x0000 (2 ^ 8 = 0x0100, but since it's a byte, use 0)
    //
    // if CmAlias is zero, use flags to specify decode (new method)
    //

    if (CmAlias == 0) {
        //
        // use CM_RESOURCE_PORT_xxx related flags
        //
        // note that we need to mirror *ALL* flags from
        // CM_RESOURCE_PORT_xxxx to fIOD_xxxx
        // however bits need not be same
        // not doing this will cause at least resource conflicts to fail
        // see also MapFromNtPortFlags
        //
        if (CmPortFlags & fIOD_10_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_10_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_12_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_12_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_16_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_16_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_POSITIVE_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_POSITIVE_DECODE;
        }
    }
    else if (CmAlias == IO_ALIAS_POSITIVE_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_POSITIVE_DECODE;
    } else if (CmAlias == IO_ALIAS_10_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_10_BIT_DECODE;
    } else if (CmAlias == IO_ALIAS_12_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_12_BIT_DECODE;
    } else if (CmAlias == IO_ALIAS_16_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_16_BIT_DECODE;
    }
    //
    // these have no mirror in cmAlias, and can be combined
    //
    if (CmPortFlags & fIOD_PASSIVE_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_PASSIVE_DECODE;
    }
    if (CmPortFlags & fIOD_WINDOW_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_WINDOW_DECODE;
    }

    return NtFlags;
}



DWORD MapFromNtPortFlags(IN USHORT NtPortFlags)
{
    DWORD Flags = 0;

    if ((NtPortFlags & (CM_RESOURCE_PORT_MEMORY|CM_RESOURCE_PORT_IO)) == CM_RESOURCE_PORT_MEMORY) {
        Flags |=fIOD_Memory;
    } else {
        Flags |=fIOD_IO;
    }

    //
    // note that we need to mirror *ALL* flags from
    // CM_RESOURCE_PORT_xxxx to fIOD_xxxx
    // however bits need not be same
    // not doing this will cause at least resource conflicts to fail
    // see also MapToNtPortFlags
    //
    if (NtPortFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        Flags |= fIOD_10_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        Flags |= fIOD_12_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_16_BIT_DECODE) {
        Flags |= fIOD_16_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        Flags |= fIOD_POSITIVE_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_PASSIVE_DECODE) {
        Flags |= fIOD_PASSIVE_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_WINDOW_DECODE) {
        Flags |= fIOD_WINDOW_DECODE;
    }
    return Flags;
}



DWORD MapAliasFromNtPortFlags(IN USHORT NtPortFlags)
{
    DWORD Alias = 0;
    if (NtPortFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        Alias = IO_ALIAS_10_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        Alias = IO_ALIAS_12_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_16_BIT_DECODE) {
        Alias = IO_ALIAS_16_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        Alias = IO_ALIAS_POSITIVE_DECODE;
    }
    return Alias;
}



ULONG MapToNtAlignment(IN DWORDLONG CmPortAlign)
{
   return (ULONG)(~CmPortAlign + 1);
}



DWORDLONG MapFromNtAlignment(IN ULONG NtPortAlign)
{
   return (DWORDLONG)(~((DWORDLONG)NtPortAlign - 1));
}



USHORT MapToNtDmaFlags(IN DWORD CmDmaFlags)
{
    USHORT NtDmaFlags;

    if ((CmDmaFlags & mDD_Width) == fDD_DWORD) {
        NtDmaFlags = CM_RESOURCE_DMA_32;
    } else if ((CmDmaFlags & mDD_Width) == fDD_WORD) {
        NtDmaFlags = CM_RESOURCE_DMA_16;
    } else if ((CmDmaFlags & mDD_Width) == fDD_BYTE_AND_WORD) {
        NtDmaFlags = CM_RESOURCE_DMA_8_AND_16;
    } else {
        NtDmaFlags = CM_RESOURCE_DMA_8;   //default
    }

    if ((CmDmaFlags & mDD_BusMaster) == fDD_BusMaster) {
        NtDmaFlags |= CM_RESOURCE_DMA_BUS_MASTER;
    }

    if ((CmDmaFlags & mDD_Type) == fDD_TypeA) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_A;
    } else if ((CmDmaFlags & mDD_Type) == fDD_TypeB) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_B;
    } else if ((CmDmaFlags & mDD_Type) == fDD_TypeF) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_F;
    }

    return NtDmaFlags;
}



DWORD MapFromNtDmaFlags(IN USHORT NtDmaFlags)
{
    DWORD CmDmaFlags;

    if (NtDmaFlags & CM_RESOURCE_DMA_32) {
        CmDmaFlags = fDD_DWORD;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_8_AND_16) {
        CmDmaFlags = fDD_BYTE_AND_WORD;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_16) {
        CmDmaFlags = fDD_WORD;
    } else {
        CmDmaFlags = fDD_BYTE;
    }

    if (NtDmaFlags & CM_RESOURCE_DMA_BUS_MASTER) {
        CmDmaFlags |= fDD_BusMaster;
    }

    if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_A) {
        CmDmaFlags |= fDD_TypeA;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_B) {
        CmDmaFlags |= fDD_TypeB;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_F) {
        CmDmaFlags |= fDD_TypeF;
    }

    return CmDmaFlags;
}






USHORT MapToNtIrqFlags(IN DWORD CmIrqFlags)
{
   if ((CmIrqFlags & mIRQD_Edge_Level) == fIRQD_Level) {
      return CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
   } else {
      return CM_RESOURCE_INTERRUPT_LATCHED;
   }
}



DWORD MapFromNtIrqFlags(IN USHORT NtIrqFlags)
{
   if (NtIrqFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
      return fIRQD_Level;
   } else {
      return fIRQD_Edge;
   }
}

#if 0
UCHAR MapToNtDisposition(IN DWORD CmFlags, IN BOOL bIrq)
{
    UCHAR disposition;
    DWORD flag = CmFlags & mD_ShareDisposition;

    if (flag == fD_ShareDeviceExclusive) {
        disposition = CmResourceShareDeviceExclusive;
    } else if (flag == fD_ShareDriverExclusive) {
        disposition = CmResourceShareDriverExclusive;
    } else if (flag == fD_ShareShared) {
        disposition = CmResourceShareShared;
    } else if (flag == fD_ShareUndetermined) {
        //
        // if undetermined, also check for the old irq specific
        // share flags
        //
        if ((CmFlags & mIRQD_Share) == fIRQD_Share) {
            disposition = CmResourceShareShared;
        } else {
            disposition = CmResourceShareUndetermined;
        }
    }

    return disposition;
}


DWORD MapFromNtDisposition(IN UCHAR NtDisposition, IN BOOL bIrq)
{
    DWORD flag = 0;

    if (NtDisposition == CmResourceShareUndetermined) {
        flag = fD_ShareUndetermined;
    } else if (NtDisposition == CmResourceShareDeviceExclusive) {
        flag = fD_ShareDeviceExclusive;
    } else if (NtDisposition == CmResourceShareDriverExclusive) {
        flag = fD_ShareDriverExclusive;
    } else if (NtDisposition == CmResourceShareShared) {
        flag = fD_ShareShared;
    }

    if (bIrq) {
        //
        // also set the irq specific shared/exclusive bit, this is for
        // backwards compatibility, new apps should look at the new bits.
        //
        if (flag == fD_ShareShared) {
            flag |= fIRQD_Share;
        } else {
            flag |= fIRQD_Exclusive;
        }
    }

    return flag;
}
#endif


UCHAR MapToNtIrqShare(IN DWORD CmIrqFlags)
{
   if ((CmIrqFlags & mIRQD_Share) == fIRQD_Exclusive) {
      return CmResourceShareDeviceExclusive;
   } else {
      return CmResourceShareShared;
   }
}

DWORD MapFromNtIrqShare(IN UCHAR NtIrqShare)
{
   if (NtIrqShare == CmResourceShareDeviceExclusive) {
      return fIRQD_Exclusive;
   }
   else if (NtIrqShare == CmResourceShareDriverExclusive) {
      return fIRQD_Exclusive;
   }
   else return fIRQD_Share;
}



#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001

#define mBUSD_SubAllocFirst             (0x1)   // Bitmask, whether SubAlloc first value allowed
#define fBUSD_SubAllocFirst_Allowed     (0x0)   // Suballoc from first value
#define fBUSD_SubAllocFirst_Disallowed  (0x1)   // Don't suballoc from first value
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rmisc.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rmisc.c

Abstract:

    This module contains the server-side misc configuration manager routines.

                  PNP_GetVersion
                  PNP_GetVersionInternal
                  PNP_GetGlobalState
                  PNP_SetActiveService
                  PNP_QueryArbitratorFreeData
                  PNP_QueryArbitratorFreeSize
                  PNP_InitDetection
                  PNP_RunDetection
                  PNP_Connect
                  PNP_Disconnect
                  PNP_GetBlockedDriverInfo

    The following routines are used by the RPC server stubs to allocate and free memory.

                  MIDL_user_allocate
                  MIDL_user_free

Author:

    Paula Tomlinson (paulat) 6-28-1995

Environment:

    User-mode only.

Revision History:

    28-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"


//
// global data
//

extern DWORD CurrentServiceState; // current state of the PlugPlay service - DO NOT MODIFY



CONFIGRET
PNP_GetVersion(
   IN handle_t      hBinding,
   IN OUT WORD *    pVersion
   )

/*++

Routine Description:

  This is the RPC server entry point, it returns the version
  number for the server-side component.

Arguments:

   hBinding    Not used.


Return Value:

   Return the version number, with the major version in the high byte and
   the minor version number in the low byte.

--*/

{
   CONFIGRET      Status = CR_SUCCESS;

   UNREFERENCED_PARAMETER(hBinding);

   try {

       *pVersion = (WORD)PNP_VERSION;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetVersion



CONFIGRET
PNP_GetVersionInternal(
   IN handle_t      hBinding,
   IN OUT WORD *    pwVersion
   )
/*++

Routine Description:

  This is the RPC server entry point, it returns the internal version
  number for the server-side component.

Arguments:

   hBinding    Not used.

   pwVersion   Receives the internal cfgmgr32 version number, returns the
               internal server version number, with the major version in the
               high byte and the minor version number in the low byte.

Return Value:

   Return CR_SUCCESS if the function succeeds, otherwise it returns one
   of the CR_* errors.

--*/
{
    CONFIGRET  Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(hBinding);

    try {

        *pwVersion = (WORD)PNP_VERSION_INTERNAL;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetVersionInternal



CONFIGRET
PNP_GetGlobalState(
   IN  handle_t   hBinding,
   OUT PULONG     pulState,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point, it returns the Global State of the
  Configuration Manager.

Arguments:

   hBinding    Not used.

   pulState    Returns the current global state.

   ulFlags     Not used, must be zero.


Return Value:

   Return CR_SUCCESS if the function succeeds, otherwise it returns one
   of the CR_* errors.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;

   UNREFERENCED_PARAMETER(hBinding);

   try {
       //
       // validate parameters
       //
       if (INVALID_FLAGS(ulFlags, 0)) {
           Status = CR_INVALID_FLAG;
           goto Clean0;
       }

       //
       // The following CM global state flags are always set.
       //
       *pulState =
           CM_GLOBAL_STATE_CAN_DO_UI |
           CM_GLOBAL_STATE_SERVICES_AVAILABLE;

       //
       // If the service is shutting down, specify the corresponding CM global
       // state flag.
       //
       if ((CurrentServiceState == SERVICE_STOP_PENDING) ||
           (CurrentServiceState == SERVICE_STOPPED)) {
           *pulState |= CM_GLOBAL_STATE_SHUTTING_DOWN;
       }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetGlobalState



CONFIGRET
PNP_SetActiveService(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pszService,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

    This routine is currently not an rpc routine, it is called directly
    and privately by the service controller.

Arguments:

    hBinding    RPC binding handle, not used.

    pszService  Specifies the service name.

    ulFlags     Either PNP_SERVICE_STARTED or PNP_SERVICE_STOPPED.


Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize = 0;
    LPWSTR      pDeviceList = NULL, pszDevice = NULL;
    HKEY        hKey = NULL, hControlKey = NULL;
    WCHAR       RegStr[MAX_PATH];

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (pszService == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((ulFlags != PNP_SERVICE_STOPPED) &&
            (ulFlags != PNP_SERVICE_STARTED)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // not handling stops right now, everything beyond here assumes
        // the service is starting (or at least it attempted to start)
        //
        if (ulFlags == PNP_SERVICE_STOPPED) {
            Status = CR_SUCCESS;
            goto Clean0;
        }


        //
        // retreive the list of devices that this service is controlling
        //
        Status = PNP_GetDeviceListSize(NULL, pszService, &ulSize,
                                       CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
        if (pDeviceList == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        Status = PNP_GetDeviceList(NULL, pszService, pDeviceList, &ulSize,
                                   CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }


        //
        // set the ActiveService value for each device
        //
        for (pszDevice = pDeviceList;
             *pszDevice;
             pszDevice += lstrlen(pszDevice) + 1) {

            if (FAILED(StringCchPrintf(
                           RegStr,
                           SIZECHARS(RegStr),
                           L"%s\\%s",
                           pszRegPathEnum,
                           pszDevice))) {
                continue;
            }

            //
            // open the device instance key
            //
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
                             &hKey) == ERROR_SUCCESS) {

                //
                // open/create the volatile Control key
                //
                if (RegCreateKeyEx(hKey, pszRegKeyDeviceControl, 0, NULL,
                                   REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL,
                                   &hControlKey, NULL) == ERROR_SUCCESS) {

                    RegSetValueEx(hControlKey, pszRegValueActiveService,
                                  0, REG_SZ, (LPBYTE)pszService,
                                  (lstrlen(pszService) + 1) * sizeof(WCHAR));

                    //
                    // set the statusflag to DN_STARTED
                    //
                    SetDeviceStatus(pszDevice, DN_STARTED, 0);

                    RegCloseKey(hControlKey);
                    hControlKey = NULL;
                }

                RegCloseKey(hKey);
                hKey = NULL;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }


    if (pDeviceList != NULL) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_SetActiveService



//--------------------------------------------------------------------
// Stub server side CM routines - not implemented yet
//--------------------------------------------------------------------


CONFIGRET
PNP_QueryArbitratorFreeData(
    IN  handle_t   hBinding,
    OUT LPBYTE     pData,
    IN  ULONG      ulDataLen,
    IN  LPCWSTR    pszDeviceID,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(ulDataLen);
    UNREFERENCED_PARAMETER(pszDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ulFlags);

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_QueryArbitratorFreeData



CONFIGRET
PNP_QueryArbitratorFreeSize(
    IN  handle_t   hBinding,
    OUT PULONG     pulSize,
    IN  LPCWSTR    pszDeviceID,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    CONFIGRET  Status;

    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pszDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ulFlags);

    try {

        if (ARGUMENT_PRESENT(pulSize)) {
            *pulSize = 0;
        }

        Status = CR_CALL_NOT_IMPLEMENTED;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_QueryArbitratorFreeSize



//---------------------------------------------------------------------------
// Debugging interface - initiate detection through private debug interface
//---------------------------------------------------------------------------

CONFIGRET
PNP_InitDetection(
    handle_t   hBinding
    )

/*++

Routine Description:

    This routine is a private debugging interface to initiate device detection.

Arguments:

    hBinding - RPC binding handle.

Return Value:

    Currently returns CR_CALL_NOT_IMPLEMENTED.

Notes:

    Previously, this routine would kick off the InitializePnPManager thread on
    checked builds only.

    Presumably, this dates way back to a time when this routine actually sought
    out non-configured devices and initiated installation on them (as is
    currently done at the start of the ThreadProc_DeviceInstall thread procedure
    routine).

    Since InitializePnPManager no longer does this, so this behavior has been
    removed altogether.  It is currently never valid to perform initialization
    more than once, however this routine may be used to implement detection of
    non-configured devices.

--*/

{
    //
    // Verify client "execute" access
    //
    if (!VerifyClientAccess(hBinding,
                            PLUGPLAY_EXECUTE)) {
        return CR_ACCESS_DENIED;
    }

    //
    // Verify client privilege
    //
    if (!VerifyClientPrivilege(hBinding,
                               SE_LOAD_DRIVER_PRIVILEGE,
                               L"Plug and Play Action (not implemeted)")) {
        return CR_ACCESS_DENIED;
    }

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_InitDetection



CONFIGRET
PNP_RunDetection(
    IN  handle_t   hBinding,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(ulFlags);

    //
    // Verify client "execute" access
    //
    if (!VerifyClientAccess(hBinding,
                            PLUGPLAY_EXECUTE)) {
        return CR_ACCESS_DENIED;
    }

    //
    // Verify client privilege
    //
    if (!VerifyClientPrivilege(hBinding,
                               SE_LOAD_DRIVER_PRIVILEGE,
                               L"Plug and Play Action (not implemeted)")) {
        return CR_ACCESS_DENIED;
    }

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_RunDetection



CONFIGRET
PNP_Connect(
   IN PNP_HANDLE  UNCServerName
   )
{
   //
   // Note that although this routine is listed in the PNP RPC interface, it
   // uses automatic binding, and does not reference any implicit binding handle
   // (which is how the interface has come to be defined).  As such, it is not
   // callable through the existing PNP RPC interface.
   //
   UNREFERENCED_PARAMETER(UNCServerName);
   return CR_CALL_NOT_IMPLEMENTED;

} // PNP_Connect


CONFIGRET
PNP_Disconnect(
   IN PNP_HANDLE  UNCServerName
   )
{
   //
   // Note that although this routine is listed in the PNP RPC interface, it
   // uses automatic binding, and does not reference any implicit binding handle
   // (which is how the interface has come to be defined).  As such, it is not
   // callable through the existing PNP RPC interface.
   //
   UNREFERENCED_PARAMETER(UNCServerName);
   return CR_CALL_NOT_IMPLEMENTED;

} // PNP_Disconnect



CONFIGRET
PNP_GetBlockedDriverInfo(
    IN handle_t     hBinding,
    OUT LPBYTE      Buffer,
    OUT PULONG      pulTransferLen,
    IN OUT  PULONG  pulLength,
    IN ULONG        ulFlags
    )

/*++

Routine Description:

   This is the RPC server entry point for the CMP_GetBlockedDriverInfo routine.

Arguments:

   hBinding        - RPC binding handle, not used.

   Buffer          - Supplies the address of the buffer that receives the
                     list.  Can be NULL when simply retrieving data size.

   pulTransferLen  - Used by stubs, indicates how much data (in bytes) to
                     copy back into user buffer.

   pulLength       - Parameter passed in by caller, on entry it contains the
                     size (in bytes) of the buffer, on exit it contains either
                     the number of bytes transferred to the caller's buffer (if
                     a transfer occured) or else the size of buffer required to
                     hold the list.

   ulFlags           Not used, must be zero.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one of the
    CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA controlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(pulTransferLen)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // We should never have both arguments pointing to the same memory...
        //
        ASSERT(pulTransferLen != pulLength);

        //
        // ...but if we do, fail the call.
        //
        if (pulTransferLen == pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Retrieve the blocked driver list via kernel-mode.
        //

        memset(&controlData, 0, sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA));
        controlData.Buffer = Buffer;
        controlData.BufferLength = *pulLength;
        controlData.Flags = ulFlags;

        ntStatus = NtPlugPlayControl(PlugPlayControlGetBlockedDriverList,
                                     &controlData,
                                     sizeof(controlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulTransferLen = *pulLength;           // Transfer everything back
            *pulLength = controlData.BufferLength;  // Length of valid data

        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulTransferLen = 0;                    // Nothing to transfer
            *pulLength = controlData.BufferLength;
            Status = CR_BUFFER_SMALL;

        } else {
            *pulLength = *pulTransferLen = 0;       // Nothing to transfer
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetBlockedDriverInfo



void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    size_t cBytes
    )
{
    return HeapAlloc(ghPnPHeap, 0, cBytes);

} // MIDL_user_allocate


void __RPC_USER
MIDL_user_free(
    void __RPC_FAR * pBuffer
    )
{
    HeapFree(ghPnPHeap, 0, pBuffer);

} // MIDL_user_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rtravers.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rtravers.c

Abstract:

    This module contains the server-side hardware tree traversal APIs.

                  PNP_ValidateDeviceInstance
                  PNP_GetRootDeviceInstance
                  PNP_GetRelatedDeviceInstance
                  PNP_EnumerateSubKeys
                  PNP_GetDeviceList
                  PNP_GetDeviceListSize

Author:

    Paula Tomlinson (paulat) 6-19-1995

Environment:

    User-mode only.

Revision History:

    19-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"


//
// private prototypes
//

CONFIGRET
GetInstanceListSize(
    IN  LPCWSTR   pszDevice,
    OUT PULONG    pulLength
    );

CONFIGRET
GetInstanceList(
    IN     LPCWSTR   pszDevice,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    );

CONFIGRET
GetDeviceInstanceListSize(
    IN  LPCWSTR   pszEnumerator,
    OUT PULONG    pulLength
    );

CONFIGRET
GetDeviceInstanceList(
    IN     LPCWSTR   pszEnumerator,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    );

PNP_QUERY_RELATION
QueryOperationCode(
    ULONG ulFlags
    );


//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern HKEY ghClassKey;     // Key to HKLM\CCC\System\Class - NO NOT MODIFY




CONFIGRET
PNP_ValidateDeviceInstance(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine verifies whether
  the specificed device instance is a valid device instance.

Arguments:

    hBinding         RPC binding handle.

    DeviceInstance   Null-terminated string that contains a device instance
                     to be validated.

    ulFlags          One of the CM_LOCATE_DEVNODE_* flags.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL, hKeyHwProfiles = NULL;
    ULONG       ulSize, ulValue, ulStatus = 0, ulProblem = 0;


    //
    // assume that the device instance string was checked for proper form
    // before being added to the registry Enum tree
    //

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_LOCATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // CM_LOCATE_DEVNODE_NOVALIDATION is not supported on NT
        //
        if (IS_FLAG_SET(ulFlags, CM_LOCATE_DEVNODE_NOVALIDATION)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the specified device id
        //
        if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_NO_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // Will specify for now that a moved devinst cannot be located (we
        // could allow this if we wanted to).
        //
        if (IsDeviceMoved(pDeviceID, hKey)) {
            Status = CR_NO_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // if we're locating a phantom devnode, it just has to exist
        // in the registry (the above check) and not already be a
        // phantom (private) devnode
        //
        if (ulFlags & CM_LOCATE_DEVNODE_PHANTOM) {
            //
            // verify that it's not a private phantom
            //
            ulSize = sizeof(ULONG);
            RegStatus = RegQueryValueEx(hKey, pszRegValuePhantom, NULL, NULL,
                                        (LPBYTE)&ulValue, &ulSize);

            if ((RegStatus == ERROR_SUCCESS) && ulValue) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }

        } else if (ulFlags & CM_LOCATE_DEVNODE_CANCELREMOVE) {
            //
            // In the CANCEL-REMOVE case, if the devnode has been removed,
            // (made volatile) then convert it back to nonvolatile so it
            // can be installed again without disappearing on the next
            // boot. If it's not removed, then just verify that it is
            // present.
            //

            //
            // verify that the device id is actually present
            //
            if (!IsDeviceIdPresent(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }

            //
            // Is this a device that is being removed on the next reboot?
            //
            if (GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

                if (ulStatus & DN_WILL_BE_REMOVED) {

                    ULONG ulIndex = 0, ulLen = 0;
                    WCHAR RegStr[MAX_CM_PATH];
                    WCHAR szProfile[MAX_PROFILE_ID_LEN];


                    //
                    // Verify client "write" access
                    //
                    if (!VerifyClientAccess(hBinding,
                                            PLUGPLAY_WRITE)) {
                        Status = CR_ACCESS_DENIED;
                        goto Clean0;
                    }

                    //
                    // This device will be removed on the next reboot,
                    // convert to nonvolatile.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws non-volatile\n",
                               pDeviceID));

                    Status = MakeKeyNonVolatile(pszRegPathEnum, pDeviceID);
                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }

                    //
                    // Now make any keys that were "supposed" to be volatile
                    // back to volatile again!
                    //
                    if (SUCCEEDED(StringCchPrintf(
                                      RegStr,
                                      SIZECHARS(RegStr),
                                      L"%s\\%s",
                                      pszRegPathEnum,
                                      pDeviceID))) {

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_REGISTRY,
                                   "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws\\%ws volatile\n",
                                   RegStr,
                                   pszRegKeyDeviceControl));

                        MakeKeyVolatile(RegStr, pszRegKeyDeviceControl);
                    }

                    //
                    // Also, convert any profile specific keys to nonvolatile
                    //

                    RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathHwProfiles,
                                             0, KEY_READ,
                                             &hKeyHwProfiles);

                    if (RegStatus == ERROR_SUCCESS) {

                        //
                        // Enumerate all existing profile-specific Enum branches.
                        //

                        ulIndex = 0;

                        for ( ; ; ) {

                            ulLen = SIZECHARS(szProfile);

                            RegStatus = RegEnumKeyEx(hKeyHwProfiles, ulIndex++,
                                                     szProfile, &ulLen,
                                                     NULL, NULL, NULL, NULL);

                            if (RegStatus == ERROR_NO_MORE_ITEMS) {
                                //
                                // No more keys to enumerate, stop enumerating.
                                //
                                break;

                            } else if (RegStatus == ERROR_MORE_DATA) {
                                //
                                // Key is not a valid profile key, skip to the next.
                                //
                                continue;

                            } else if (RegStatus != ERROR_SUCCESS) {
                                //
                                // Some other error, stop enumerating.
                                //
                                break;

                            } else {
                                //
                                // Form the profile-specific registry key path.
                                //

                                if (SUCCEEDED(StringCchPrintf(
                                                  RegStr,
                                                  SIZECHARS(RegStr),
                                                  L"%s\\%s\\%s",
                                                  pszRegPathHwProfiles,
                                                  szProfile,
                                                  pszRegPathEnum))) {

                                    //
                                    // Attempt to make the profile-specific
                                    // device instance key volatile.  Ignore the
                                    // status for profile-specific keys since
                                    // they may not exist.
                                    //
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_REGISTRY,
                                               "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws non-volatile\n",
                                               pDeviceID));

                                    MakeKeyNonVolatile(RegStr, pDeviceID);
                                }
                            }
                        }

                        RegCloseKey(hKeyHwProfiles);
                    }

                    //
                    // clear the DN_WILL_BE_REMOVED flag
                    //
                    ClearDeviceStatus(pDeviceID, DN_WILL_BE_REMOVED, 0);
                }
            }
        }

        //
        // in the normal (non-phantom case), verify that the device id is
        // actually present
        //
        else  {
            //
            // verify that the device id is actually present
            //

            if (!IsDeviceIdPresent(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_ValidateDeviceInstance



CONFIGRET
PNP_GetRootDeviceInstance(
    IN  handle_t    hBinding,
    OUT LPWSTR      pDeviceID,
    IN  ULONG       ulLength
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  root device instance for the hardware tree.

Arguments:

    hBinding   Not used.

    pDeviceID  Pointer to a buffer that will hold the root device
               instance ID string.

    ulLength   Size of pDeviceID buffer in characters.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    HRESULT     hr;
    size_t      DeviceIdLen = 0;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // first validate that the root device instance exists
        //
        if (RegOpenKeyEx(ghEnumKey, pszRegRootEnumerator, 0, KEY_QUERY_VALUE,
                         &hKey) != ERROR_SUCCESS) {
            //
            // root doesn't exist, create root devinst
            //
            if (!CreateDeviceIDRegKey(ghEnumKey, pszRegRootEnumerator)) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

        //
        // return the root device instance id
        //
        hr = StringCchLength(pszRegRootEnumerator,
                             MAX_DEVICE_ID_LEN,
                             &DeviceIdLen);
        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (ulLength < (ULONG)(DeviceIdLen + 1)) {
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        hr = StringCchCopyEx(pDeviceID,
                             ulLength,
                             pszRegRootEnumerator,
                             NULL, NULL,
                             STRSAFE_IGNORE_NULLS);

        if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
            Status = CR_BUFFER_SMALL;
        } else if (FAILED(hr)) {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetRootDeviceInstance



CONFIGRET
PNP_GetRelatedDeviceInstance(
      IN  handle_t   hBinding,
      IN  ULONG      ulRelationship,
      IN  LPWSTR     pDeviceID,
      OUT LPWSTR     pRelatedDeviceID,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns a
  device instance that is related to the specified device instance.

Arguments:

   hBinding          Not used.

   ulRelationship    Specifies the relationship of the device instance to
                     be retrieved (can be PNP_GET_PARENT_DEVICE_INSTANCE,
                     PNP_GET_CHILD_DEVICE_INSTANCE, or
                     PNP_GET_SIBLING_DEVICE_INSTANCE).

   pDeviceID         Pointer to a buffer that contains the base device
                     instance string.

   pRelatedDeviceID  Pointer to a buffer that will receive the related
                     device instance string.

   pulLength         Length (in characters) of the RelatedDeviceInstance
                     buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    PLUGPLAY_CONTROL_RELATED_DEVICE_DATA ControlData;
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    HRESULT     hr;
    size_t      DeviceIdLen;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate patameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pRelatedDeviceID) && (*pulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (*pulLength > 0) {
            *pRelatedDeviceID = L'\0';
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            if (*pulLength > 0) {
                *pulLength = 1;
            }
            goto Clean0;
        }

        //
        // initialize control data block
        //
        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));

        //
        // special case behavior for certain devices and relationships
        //
        switch (ulRelationship) {

        case PNP_GET_PARENT_DEVICE_INSTANCE:

            if (IsRootDeviceID(pDeviceID)) {
                //
                // This is the root (which has no parent by definition)
                //
                Status = CR_NO_SUCH_DEVINST;

            } else if (IsDevicePhantom(pDeviceID)) {

                //
                // Phantom devices don't have a kernel-mode device node
                // allocated yet, but during manual install, the process calls
                // for retrieving the parent. So we just fake it out by
                // returning the root in this case. For all other cases, we only
                // return the parent that the kernel-mode device node indicates.
                //

                hr = StringCchCopyEx(pRelatedDeviceID,
                                     *pulLength,
                                     pszRegRootEnumerator,
                                     NULL, NULL,
                                     STRSAFE_IGNORE_NULLS);

                if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
                    Status = CR_BUFFER_SMALL;
                } else if (FAILED(hr)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                //
                // For either CR_SUCCESS or CR_BUFFER_SMALL, we return the
                // length of the root device id as either the amount of data
                // copied, or the size required.
                //

                DeviceIdLen = 0;

                hr = StringCchLength(pszRegRootEnumerator,
                                     MAX_DEVICE_ID_LEN,
                                     &DeviceIdLen);
                ASSERT(SUCCEEDED(hr));

                if (FAILED(hr)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                ASSERT(DeviceIdLen > 0);

                *pulLength = (ULONG)(DeviceIdLen + 1);
                goto Clean0;
            }

            //
            // For all other devnodes, ask the kernel-mode pnp manager for the
            // parent device.
            //
            ControlData.Relation = PNP_RELATION_PARENT;
            break;

        case PNP_GET_CHILD_DEVICE_INSTANCE:
            ControlData.Relation = PNP_RELATION_CHILD;
            break;

        case PNP_GET_SIBLING_DEVICE_INSTANCE:
            //
            // first verify it isn't the root (which has no siblings by definition)
            //
            if (IsRootDeviceID(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
            }

            ControlData.Relation = PNP_RELATION_SIBLING;
            break;

        default:
            Status = CR_FAILURE;
        }

        if (Status == CR_SUCCESS) {
            //
            // Try to locate the relation from the kernel-mode in-memory
            // devnode tree.
            //

            RtlInitUnicodeString(&ControlData.TargetDeviceInstance, pDeviceID);
            ControlData.RelatedDeviceInstance = pRelatedDeviceID;
            ControlData.RelatedDeviceInstanceLength = *pulLength;

            ntStatus = NtPlugPlayControl(PlugPlayControlGetRelatedDevice,
                                         &ControlData,
                                         sizeof(ControlData));

            if (NT_SUCCESS(ntStatus)) {
                *pulLength = ControlData.RelatedDeviceInstanceLength + 1;
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }

        } else if (*pulLength > 0) {
            *pulLength = 1;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetRelatedDeviceInstance



CONFIGRET
PNP_EnumerateSubKeys(
    IN  handle_t   hBinding,
    IN  ULONG      ulBranch,
    IN  ULONG      ulIndex,
    OUT PWSTR      Buffer,
    IN  ULONG      ulLength,
    OUT PULONG     pulRequiredLen,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

    This is the RPC server entry point for the CM_Enumerate_Enumerators and
    CM_Enumerate_Classes.  It provides generic subkey enumeration based on
    the specified registry branch.

Arguments:

    hBinding       Not used.

    ulBranch       Specifies which keys to enumerate.

    ulIndex        Index of the subkey key to retrieve.

    Buffer         Supplies the address of the buffer that receives the
                   subkey name.

    ulLength       Specifies the max size of the Buffer in characters.

    pulRequired    On output it contains the number of characters actually
                   copied to Buffer if it was successful, or the number of
                   characters required if the buffer was too small.

    ulFlags        Not used, must be zero.

Return Value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns
    a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulRequiredLen)) ||
            (!ARGUMENT_PRESENT(Buffer) && (ulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (ulLength > 0) {
            *Buffer = L'\0';
        }

        if (ulBranch == PNP_CLASS_SUBKEYS) {
            //
            // Use the global base CLASS registry key
            //
            hKey = ghClassKey;
        }
        else if (ulBranch == PNP_ENUMERATOR_SUBKEYS) {
            //
            // Use the global base ENUM registry key
            //
            hKey = ghEnumKey;
        }
        else {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // enumerate a subkey based on the passed in index value
        //
        *pulRequiredLen = ulLength;

        RegStatus = RegEnumKeyEx(hKey, ulIndex, Buffer, pulRequiredLen,
                                 NULL, NULL, NULL, NULL);
        *pulRequiredLen += 1;  // returned count doesn't include null terminator

        if (RegStatus == ERROR_MORE_DATA) {
            //
            // This is a special case, the RegEnumKeyEx routine doesn't return
            // the number of characters required to hold this string (just how
            // many characters were copied to the buffer (how many fit). I have
            // to use a different means to return that info back to the caller.
            //
            ULONG ulMaxLen = 0;
            PWSTR p = NULL;

            if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, &ulMaxLen,
                                NULL, NULL, NULL, NULL, NULL,
                                NULL) == ERROR_SUCCESS) {

                ulMaxLen += 1;  // returned count doesn't include null terminator

                p = HeapAlloc(ghPnPHeap, 0, ulMaxLen * sizeof(WCHAR));
                if (p == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                if (RegEnumKeyEx(hKey, ulIndex, p, &ulMaxLen, NULL, NULL, NULL,
                                 NULL) == ERROR_SUCCESS) {
                    *pulRequiredLen = ulMaxLen + 1;
                }

                HeapFree(ghPnPHeap, 0, p);
            }

            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }
        else if (RegStatus == ERROR_NO_MORE_ITEMS) {
            *pulRequiredLen = 0;
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }
        else if (RegStatus != ERROR_SUCCESS) {
            *pulRequiredLen = 0;
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_EnumerateSubKeys



CONFIGRET
PNP_GetDeviceList(
      IN  handle_t   hBinding,
      IN  LPCWSTR    pszFilter,
      OUT LPWSTR     Buffer,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns a
  list of device instances.

Arguments:

   hBinding          Not used.

   pszFilter         Optional parameter, controls which device ids are
                     returned.

   Buffer            Pointer to a buffer that will contain the multi_sz list
                     of device instance strings.

   pulLength         Size in characters of Buffer on input, size (in chars)
                     transferred on output

   ulFlags           Flag specifying which devices ids to return.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
   WCHAR       RegStr[MAX_CM_PATH];
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   LPWSTR      ptr = NULL;
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if ((!ARGUMENT_PRESENT(pulLength)) ||
          (!ARGUMENT_PRESENT(Buffer) && (*pulLength != 0))) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      if (*pulLength > 0) {
          *Buffer = L'\0';
      }

      //-----------------------------------------------------------
      // Query Device Relations filter - go through kernel-mode
      //-----------------------------------------------------------

      if ((ulFlags & CM_GETIDLIST_FILTER_EJECTRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_REMOVALRELATIONS) ||
          (ulFlags & CM_GETIDLIST_FILTER_POWERRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_BUSRELATIONS)) {

          memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));
          RtlInitUnicodeString(&ControlData.DeviceInstance, pszFilter);
          ControlData.Operation = QueryOperationCode(ulFlags);
          ControlData.BufferLength = *pulLength;
          ControlData.Buffer = Buffer;

          ntStatus = NtPlugPlayControl(PlugPlayControlQueryDeviceRelations,
                                       &ControlData,
                                       sizeof(ControlData));

          if (NT_SUCCESS(ntStatus)) {
              *pulLength = ControlData.BufferLength;
          } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
              *pulLength = 0;
              Status = MapNtStatusToCmError(ntStatus);
          }
          goto Clean0;
      }


      //---------------------------------------------------
      // Service filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_SERVICE) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         Status = GetServiceDeviceList(pszFilter, Buffer, pulLength, ulFlags);
         goto Clean0;
      }

      //---------------------------------------------------
      // Enumerator filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_ENUMERATOR) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         SplitDeviceInstanceString(
               pszFilter, szEnumerator, szDevice, szInstance);

         //
         // if both the enumerator and device were specified, retrieve
         // the device instances for this device
         //
         if (*szEnumerator != L'\0' && *szDevice != L'\0') {

            ptr = Buffer;
            Status = GetInstanceList(pszFilter, &ptr, pulLength);
         }

         //
         // if just the enumerator was specified, retrieve all the device
         // instances under this enumerator
         //
         else {
             ptr = Buffer;
             Status = GetDeviceInstanceList(pszFilter, &ptr, pulLength);
         }
      }

      //------------------------------------------------
      // No filtering
      //-----------------------------------------------

      else {

         //
         // return device instances for all enumerators (by enumerating
         // the enumerators)
         //
         // Open a key to the Enum branch
         //
         ulSize = ulBufferLen = *pulLength;     // total Buffer size
         *pulLength = 0;                        // nothing copied yet
         ptr = Buffer;                          // tail of the buffer
         ulIndex = 0;

         //
         //  Enumerate all the enumerators
         //
         while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars
            RegStatus = RegEnumKeyEx(ghEnumKey, ulIndex, RegStr, &ulLen,
                                     NULL, NULL, NULL, NULL);

            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

               Status = GetDeviceInstanceList(RegStr, &ptr, &ulSize);

               if (Status != CR_SUCCESS) {
                  *pulLength = 0;
                  goto Clean0;
               }

               *pulLength += ulSize - 1;            // length copied so far
               ulSize = ulBufferLen - *pulLength;   // buffer length left
            }
         }
         *pulLength += 1;      // now count the double-null
      }


   Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_SUCCESS;
   }

   return Status;

} // PNP_GetDeviceList



CONFIGRET
PNP_GetDeviceListSize(
      IN  handle_t   hBinding,
      IN  LPCWSTR    pszFilter,
      OUT PULONG     pulLen,
      IN  ULONG      ulFlags
      )
/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  size of a list of device instances.

Arguments:

   hBinding          Not used.

   pszEnumerator     Optional parameter, if specified the size will only
                     include device instances of this enumerator.

   pulLen            Returns the worst case estimate of the size of a
                     device instance list.

   ulFlags           Flag specifying which devices ids to return.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   ULONG       ulSize = 0, ulIndex = 0;
   WCHAR       RegStr[MAX_CM_PATH];
   ULONG       RegStatus = ERROR_SUCCESS;
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if (!ARGUMENT_PRESENT(pulLen)) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      //
      // initialize output length param
      //
      *pulLen = 0;

      //-----------------------------------------------------------
      // Query Device Relations filter - go through kernel-mode
      //-----------------------------------------------------------

      if ((ulFlags & CM_GETIDLIST_FILTER_EJECTRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_REMOVALRELATIONS) ||
          (ulFlags & CM_GETIDLIST_FILTER_POWERRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_BUSRELATIONS)) {

          memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA));
          RtlInitUnicodeString(&ControlData.DeviceInstance, pszFilter);
          ControlData.Operation = QueryOperationCode(ulFlags);
          ControlData.BufferLength = 0;
          ControlData.Buffer = NULL;

          ntStatus = NtPlugPlayControl(PlugPlayControlQueryDeviceRelations,
                                       &ControlData,
                                       sizeof(ControlData));

          if (NT_SUCCESS(ntStatus)) {

              //
              // Note - we get here because kernel mode special cases
              // Buffer==NULL and is careful not to return
              // STATUS_BUFFER_TOO_SMALL.
              //
              *pulLen = ControlData.BufferLength;

          } else {

              //
              // ADRIAO ISSUE 02/06/2001 - We aren't returning the proper code
              //                           here. We should fix this in XP+1,
              //                           once we have time to verify no one
              //                           will get an app compat break.
              //
              //Status = MapNtStatusToCmError(ntStatus);
              Status = CR_SUCCESS;
          }
          goto Clean0;
      }


      //---------------------------------------------------
      // Service filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_SERVICE) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         Status = GetServiceDeviceListSize(pszFilter, pulLen);
         goto Clean0;
      }


      //---------------------------------------------------
      // Enumerator filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_ENUMERATOR) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         SplitDeviceInstanceString(
               pszFilter, szEnumerator, szDevice, szInstance);

         //
         // if both the enumerator and device were specified, retrieve
         // the device instance list size for this device only
         //
         if (*szEnumerator != L'\0' && *szDevice != L'\0') {

            Status = GetInstanceListSize(pszFilter, pulLen);
         }

         //
         // if just the enumerator was specified, retrieve the size of
         // all the device instances under this enumerator
         //
         else {
            Status = GetDeviceInstanceListSize(pszFilter, pulLen);
         }
      }

      //---------------------------------------------------
      // No filtering
      //---------------------------------------------------

      else {

         //
         // no enumerator was specified, return device instance size
         // for all enumerators (by enumerating the enumerators)
         //
         ulIndex = 0;

         while (RegStatus == ERROR_SUCCESS) {

            ulSize = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(ghEnumKey, ulIndex, RegStr, &ulSize,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

               Status = GetDeviceInstanceListSize(RegStr, &ulSize);

               if (Status != CR_SUCCESS) {
                  goto Clean0;
               }
               *pulLen += ulSize;
            }
         }
      }

      *pulLen += 1;     // add extra char for double null term


   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetDeviceListSize



CONFIGRET
PNP_GetDepth(
   IN  handle_t   hBinding,
   IN  LPCWSTR    pszDeviceID,
   OUT PULONG     pulDepth,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  depth of a device instance.

Arguments:

   hBinding       Not used.

   pszDeviceID    Device instance to find the depth of.

   pulDepth       Returns the depth of pszDeviceID.

   ulFlags        Not used, must be zero.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEPTH_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulDepth)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // initialize output depth param
        //
        *pulDepth = 0;

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Retrieve the device depth via kernel-mode.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEPTH_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.DeviceDepth = 0;

        ntStatus = NtPlugPlayControl(PlugPlayControlGetDeviceDepth,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            Status = MapNtStatusToCmError(ntStatus);
        } else {
            *pulDepth = ControlData.DeviceDepth;
        }

   Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetDepth




//-------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------

CONFIGRET
GetServiceDeviceListSize(
      IN  LPCWSTR   pszService,
      OUT PULONG    pulLength
      )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszService     service whose device instances are to be listed

   pulLength      On output, specifies the size in characters required to hold
                  the device instance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulType = 0, ulCount = 0, ulMaxValueData = 0, ulSize = 0;
    HKEY        hKey = NULL, hEnumKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszService)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
        }

        //
        // Open a key to the service branch
        //
        if (RegOpenKeyEx(ghServicesKey, pszService, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // check if the service is specialy marked as type
        // PlugPlayServiceSoftware, in which case I will not
        // generate any madeup device ids and fail the call.
        //
        ulSize = sizeof(ulType);
        if (RegQueryValueEx(hKey, pszRegValuePlugPlayServiceType, NULL, NULL,
                            (LPBYTE)&ulType, &ulSize) == ERROR_SUCCESS) {

            if (ulType == PlugPlayServiceSoftware) {

                Status = CR_NO_SUCH_VALUE;
                *pulLength = 0;
                goto Clean0;
            }
        }

        //
        // open the Enum key
        //
        if (RegOpenKeyEx(hKey, pszRegKeyEnum, 0, KEY_READ,
                         &hEnumKey) != ERROR_SUCCESS) {
            //
            // Enum key doesn't exist so one will be generated, estimate
            // worst case device id size for the single generated device id
            //
            *pulLength = MAX_DEVICE_ID_LEN;
            goto Clean0;
        }

        //
        // retrieve the count of device instances controlled by this service
        //
        ulSize = sizeof(ulCount);
        if (RegQueryValueEx(hEnumKey, pszRegValueCount, NULL, NULL,
                            (LPBYTE)&ulCount, &ulSize) != ERROR_SUCCESS) {
            ulCount = 1;      // if empty, I'll generate one
        }

        if (ulCount == 0) {
            ulCount++;        // if empty, I'll generate one
        }

        if (RegQueryInfoKey(hEnumKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            NULL, &ulMaxValueData, NULL, NULL) != ERROR_SUCCESS) {

            *pulLength = ulCount * MAX_DEVICE_ID_LEN;
            goto Clean0;
        }

        //
        // worst case estimate is multiply number of device instances time
        // length of the longest one + 2 null terminators
        //
        *pulLength = ulCount * (ulMaxValueData+1)/sizeof(WCHAR) + 2;


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hEnumKey != NULL) {
        RegCloseKey(hEnumKey);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetServiceDeviceListSize



CONFIGRET
GetServiceDeviceList(
      IN  LPCWSTR   pszService,
      OUT LPWSTR    pBuffer,
      IN OUT PULONG pulLength,
      IN  ULONG     ulFlags
      )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszService     Service whose device instances are to be listed

   pBuffer        Pointer to a buffer that will hold the list in multi-sz
                  format

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies the size in characters actually copied
                  to the buffer.

   ulFlags        Specifies CM_GETIDLIST_* flags supplied to
                  PNP_GetDeviceList (CM_GETIDLIST_FILTER_SERVICE
                  must be specified).  This routine only checks for the
                  presence of the CM_GETIDLIST_DONOTGENERATE flag.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH], szDeviceID[MAX_DEVICE_ID_LEN+1];
    ULONG       ulType=0, ulBufferLen=0, ulSize=0, ulCount=0, i=0;
    HKEY        hKey = NULL, hEnumKey = NULL;
    PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA    ControlData;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOL        ServiceIsPlugPlay = FALSE;

    ASSERT(ulFlags & CM_GETIDLIST_FILTER_SERVICE);

    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszService)) ||
            (!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pBuffer) && (*pulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // the buffer must be at least large enough for a NULL multi-sz list
        //
        if (*pulLength == 0) {
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        *pBuffer = L'\0';
        ulBufferLen = *pulLength;

        //
        // Open a key to the service branch
        //
        if (RegOpenKeyEx(ghServicesKey, pszService, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            *pulLength = 0;
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // check if the service is specialy marked as type
        // PlugPlayServiceSoftware, in which case I will not
        // generate any madeup device ids and fail the call.
        //
        ulSize = sizeof(ulType);
        if (RegQueryValueEx(hKey, pszRegValuePlugPlayServiceType, NULL, NULL,
                            (LPBYTE)&ulType, &ulSize) == ERROR_SUCCESS) {

            if (ulType == PlugPlayServiceSoftware) {
                //
                // for PlugPlayServiceSoftware value, fail the call
                //
                *pulLength = 0;
                Status = CR_NO_SUCH_VALUE;
                goto Clean0;

            }

            ServiceIsPlugPlay = TRUE;
        }

        //
        // open the Enum key
        //
        RegStatus = RegOpenKeyEx(hKey, pszRegKeyEnum, 0, KEY_READ,
                                 &hEnumKey);

        if (RegStatus == ERROR_SUCCESS) {
            //
            // retrieve count of device instances controlled by this service
            //
            ulSize = sizeof(ulCount);
            if (RegQueryValueEx(hEnumKey, pszRegValueCount, NULL, NULL,
                                (LPBYTE)&ulCount, &ulSize) != ERROR_SUCCESS) {
                ulCount = 0;
            }
        }

        //
        // if there are no device instances, create a default one
        //
        if (RegStatus != ERROR_SUCCESS || ulCount == 0) {

            if (ulFlags & CM_GETIDLIST_DONOTGENERATE) {
                //
                // If I'm calling this routine privately, don't generate
                // a new device instance, just give me an empty list
                //
                *pBuffer = L'\0';
                *pulLength = 0;
                goto Clean0;
            }

            if (ServiceIsPlugPlay) {
                //
                // Also, if plugplayservice type set, don't generate a
                // new device instance, just return success with an empty list
                //
                *pBuffer = L'\0';
                *pulLength = 0;
                goto Clean0;
            }

            memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA));
            RtlInitUnicodeString(&ControlData.ServiceName, pszService);
            ControlData.DeviceInstance = pBuffer;
            ControlData.DeviceInstanceLength = *pulLength - 1;
            NtStatus = NtPlugPlayControl(PlugPlayControlGenerateLegacyDevice,
                                         &ControlData,
                                         sizeof(ControlData));

            if (NtStatus == STATUS_SUCCESS)  {

                *pulLength = ControlData.DeviceInstanceLength;
                pBuffer[*pulLength] = L'\0';    // 1st NUL terminator
                (*pulLength)++;                 // +1 for 1st NUL terminator
                pBuffer[*pulLength] = L'\0';    // double NUL terminate
                (*pulLength)++;                 // +1 for 2nd NUL terminator

            } else {

                *pBuffer = L'\0';
                *pulLength = 0;

                Status = CR_FAILURE;
            }

            goto Clean0;
        }


        //
        // retrieve each device instance
        //
        for (i = 0; i < ulCount; i++) {

            if (FAILED(StringCchPrintf(
                           RegStr,
                           SIZECHARS(RegStr),
                           L"%d",
                           i))) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            ulSize = MAX_DEVICE_ID_LEN * sizeof(WCHAR);

            RegStatus = RegQueryValueEx(hEnumKey, RegStr, NULL, NULL,
                                        (LPBYTE)szDeviceID, &ulSize);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // this string is not always null-terminated when I read it from the
            // registry, even though it's REG_SZ.
            //
            ulSize /= sizeof(WCHAR);

            if (szDeviceID[ulSize-1] != L'\0') {
                szDeviceID[ulSize] = L'\0';
            }

            ulSize = ulBufferLen * sizeof(WCHAR);  // total buffer size in bytes

            if (!MultiSzAppendW(pBuffer, &ulSize, szDeviceID)) {
                Status = CR_BUFFER_SMALL;
                *pulLength = 0;
                goto Clean0;
            }

            *pulLength = ulSize/sizeof(WCHAR);  // chars to transfer
        }


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hEnumKey != NULL) {
        RegCloseKey(hEnumKey);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetServiceDeviceList



CONFIGRET
GetInstanceListSize(
    IN  LPCWSTR   pszDevice,
    OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszDevice      device whose instances are to be listed

   pulLength      On output, specifies the size in characters required to hold
                  the device istance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulCount = 0, ulMaxKeyLen = 0;
    HKEY        hKey = NULL;
    size_t      DeviceIdLen = 0;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszDevice)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key to the device instance
        //
        if (RegOpenKeyEx(ghEnumKey, pszDevice, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // how many instance keys are under this device?
        //
        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &ulCount, &ulMaxKeyLen,
                            NULL, NULL, NULL, NULL, NULL, NULL)
                            != ERROR_SUCCESS) {
            ulCount = 0;
            ulMaxKeyLen = 0;
        }

        //
        // do worst case estimate:
        //    length of the <enumerator>\<root> string +
        //    1 char for the back slash before the instance +
        //    the length of the longest instance key + null term +
        //    multiplied by the number of instances under this device.
        //
        if (FAILED(StringCchLength(
                       pszDevice,
                       MAX_DEVICE_ID_LEN,
                       &DeviceIdLen))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        ASSERT(DeviceIdLen > 0);
        ASSERT(DeviceIdLen < MAX_DEVICE_ID_LEN);

        *pulLength = ulCount * (ULONG)(DeviceIdLen + ulMaxKeyLen + 2) + 1;

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetInstanceListSize



CONFIGRET
GetInstanceList(
    IN     LPCWSTR   pszDevice,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   hEnumKey       Handle to open Enum registry key

   pszDevice      device whose instances are to be listed

   pBuffer        On input, this points to place where the next element
                  should be copied (the buffer tail), on output, it also
                  points to the end of the buffer.

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies how many characters actually copied to
                  the buffer. Includes an extra byte for the double-null term.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH], szInstance[MAX_DEVICE_ID_LEN];
    ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
    HKEY        hKey = NULL;
    HRESULT     hr;
    size_t      DeviceIdLen = 0;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszDevice)) ||
            (!ARGUMENT_PRESENT(*pBuffer))  ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key for this Enumerator\Device branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszDevice, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        ulBufferLen = *pulLength;     // total size of pBuffer
        *pulLength = 0;               // no data copied yet
        ulIndex = 0;

        //
        // enumerate the instance keys
        //
        while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szInstance, &ulLen,
                                     NULL, NULL, NULL, NULL);

            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

                hr = StringCchPrintf(RegStr,
                                     SIZECHARS(RegStr),
                                     L"%s\\%s",
                                     pszDevice,
                                     szInstance);

                if ((SUCCEEDED(hr)) &&
                    (IsValidDeviceID(RegStr, NULL, 0))) {

                    hr = StringCchLength(RegStr,
                                         MAX_DEVICE_ID_LEN,
                                         &DeviceIdLen);
                    ASSERT(SUCCEEDED(hr));

                    if (FAILED(hr)) {
                        *pulLength = 0;
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    ulSize = (ULONG)(DeviceIdLen + 1);  // size of new element
                    *pulLength += ulSize;               // size copied so far

                    if ((*pulLength + 1) > ulBufferLen) {
                        *pulLength = 0;
                        Status = CR_BUFFER_SMALL;
                        goto Clean0;
                    }

                    hr = StringCchCopyEx(*pBuffer,
                                         ulBufferLen,
                                         RegStr,
                                         NULL, NULL,
                                         STRSAFE_NULL_ON_FAILURE);
                    ASSERT(SUCCEEDED(hr));

                    if (FAILED(hr)) {
                        ASSERT(HRESULT_CODE(hr) != ERROR_INSUFFICIENT_BUFFER);
                        *pulLength = 0;
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    *pBuffer += ulSize;             // move to tail of buffer
                }
            }
        }

        **pBuffer = 0x0;                // double-null terminate it
        *pulLength += 1;  // include room for double-null terminator

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetInstanceList



CONFIGRET
GetDeviceInstanceListSize(
    IN  LPCWSTR   pszEnumerator,
    OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszEnumerator  Enumerator whose device instances are to be listed

   pulLength      On output, specifies how many characters required to hold
                  the device instance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulSize = 0, ulIndex = 0;
    WCHAR       RegStr[MAX_CM_PATH], szDevice[MAX_DEVICE_ID_LEN];
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszEnumerator)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // initialize output length param
        //
        *pulLength = 0;

        //
        // Open a key for this Enumerator branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszEnumerator, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // Enumerate the device keys
        //
        ulIndex = 0;

        while (RegStatus == ERROR_SUCCESS) {

            ulSize = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szDevice, &ulSize,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

                //
                // Retrieve the size of the instance list for this device
                //

                if (FAILED(StringCchPrintf(
                               RegStr,
                               SIZECHARS(RegStr),
                               L"%s\\%s",
                               pszEnumerator,
                               szDevice))) {
                    Status = CR_FAILURE;
                    *pulLength = 0;
                    goto Clean0;
                }

                Status = GetInstanceListSize(RegStr, &ulSize);

                if (Status != CR_SUCCESS) {
                    *pulLength = 0;
                    goto Clean0;
                }

                *pulLength += ulSize;
            }
        }


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetDeviceInstanceListSize



CONFIGRET
GetDeviceInstanceList(
    IN     LPCWSTR   pszEnumerator,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   hEnumKey       Handle of open Enum (parent) registry key

   pszEnumerator  Enumerator whose device instances are to be listed

   pBuffer        On input, this points to place where the next element
                  should be copied (the buffer tail), on output, it also
                  points to the end of the buffer.

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies how many characters actuall copied to
                  the buffer. Includes an extra byte for the double-null
                  term.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
    WCHAR       RegStr[MAX_CM_PATH], szDevice[MAX_DEVICE_ID_LEN];
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszEnumerator)) ||
            (!ARGUMENT_PRESENT(*pBuffer)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key for this Enumerator branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszEnumerator, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        ulIndex = 0;
        ulSize = ulBufferLen = *pulLength;        // total size of pBuffer
        *pulLength = 0;

        //
        // Enumerate the device keys
        //
        while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szDevice, &ulLen,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

                //
                // Retrieve the instance list for this device
                //

                if (FAILED(StringCchPrintf(
                               RegStr,
                               SIZECHARS(RegStr),
                               L"%s\\%s",
                               pszEnumerator,
                               szDevice))) {
                    Status = CR_FAILURE;
                    *pulLength = 0;
                    goto Clean0;
                }

                Status = GetInstanceList(RegStr, pBuffer, &ulSize);

                if (Status != CR_SUCCESS) {
                    *pulLength = 0;
                    goto Clean0;
                }

                *pulLength += ulSize - 1;           // data copied so far
                ulSize = ulBufferLen - *pulLength;  // buffer size left over
            }
        }

        *pulLength += 1;  // now add room for second null term

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetDeviceInstanceList



PNP_QUERY_RELATION
QueryOperationCode(
    ULONG ulFlags
    )

/*++

Routine Description:

  This routine converts the CM_GETIDLIST_FILTER_Xxx query relation type
  flags into the corresponding enum value that NtPlugPlayControl understands.

Arguments:

   ulFlags        CM API CM_GETIDLIST_FILTER_Xxx value

Return Value:

   One of the enum PNP_QUERY_RELATION values.

--*/

{
    switch (ulFlags) {

    case CM_GETIDLIST_FILTER_EJECTRELATIONS:
        return PnpQueryEjectRelations;

    case CM_GETIDLIST_FILTER_REMOVALRELATIONS:
        return PnpQueryRemovalRelations;

    case CM_GETIDLIST_FILTER_POWERRELATIONS:
        return PnpQueryPowerRelations;

    case CM_GETIDLIST_FILTER_BUSRELATIONS:
        return PnpQueryBusRelations;

    default:
        return (ULONG)-1;
    }

} // QueryOperationCode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rutil.c

Abstract:

    This module contains general utility routines used by umpnpmgr.

            PNP_ENTER_SYNCHRONOUS_CALL
            PNP_LEAVE_SYNCHRONOUS_CALL
            CreateDeviceIDRegKey
            IsRootDeviceID
            MultiSzAppendW
            MultiSzFindNextStringW
            MultiSzSearchStringW
            MultiSzSizeW
            MultiSzDeleteStringW
            IsValidDeviceID
            IsDevicePhantom
            GetDeviceStatus
            SetDeviceStatus
            ClearDeviceStatus
            CopyRegistryTree
            PathToString
            IsDeviceMoved
            MakeKeyVolatile
            MakeKeyNonVolatile
            OpenLogConfKey
            GetActiveService
            IsDeviceIdPresent
            GetDeviceConfigFlags
            MapNtStatusToCmError
            IsValidGuid
            GuidEqual
            GuidFromString
            StringFromGuid

Author:

    Paula Tomlinson (paulat) 7-12-1995

Environment:

    User mode only.

Revision History:

    12-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"

#pragma warning(push)
#pragma warning(disable:4214) // warning C4214: nonstandard extension used : bit field types other than int
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#include <winsta.h>
#pragma warning(pop)
#include <syslib.h>


//
// global data
//
extern HKEY   ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY   ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern CRITICAL_SECTION PnpSynchronousCall;


//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//
static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR szDigits[] = TEXT("0123456789ABCDEF");



VOID
PNP_ENTER_SYNCHRONOUS_CALL(
    VOID
    )
{
    EnterCriticalSection(&PnpSynchronousCall);

} // PNP_ENTER_SYNCHRONOUS_CALL


VOID
PNP_LEAVE_SYNCHRONOUS_CALL(
    VOID
    )
{
    LeaveCriticalSection(&PnpSynchronousCall);

} // PNP_LEAVE_SYNCHRONOUS_CALL



BOOL
CreateDeviceIDRegKey(
   HKEY     hParentKey,
   LPCWSTR  pDeviceID
   )

/*++

Routine Description:

     This routine creates the specified device id subkeys in the registry.

Arguments:

   hParentKey     Key under which the device id key will be created

   pDeviceID      Device instance ID string to open

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
   WCHAR    szBase[MAX_DEVICE_ID_LEN];
   WCHAR    szDevice[MAX_DEVICE_ID_LEN];
   WCHAR    szInstance[MAX_DEVICE_ID_LEN];
   HKEY     hBaseKey, hDeviceKey, hInstanceKey;

   if (!SplitDeviceInstanceString(
         pDeviceID, szBase, szDevice, szInstance)) {
      return FALSE;
   }

   //
   // just try creating each component of the device id
   //
   if (RegCreateKeyEx(
            hParentKey, szBase, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hBaseKey, NULL) != ERROR_SUCCESS) {
      return FALSE;
   }

   if (RegCreateKeyEx(
            hBaseKey, szDevice, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hDeviceKey, NULL) != ERROR_SUCCESS) {
      RegCloseKey(hBaseKey);
      return FALSE;
   }

   if (RegCreateKeyEx(
            hDeviceKey, szInstance, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hInstanceKey, NULL) != ERROR_SUCCESS) {
      RegCloseKey(hBaseKey);
      RegCloseKey(hDeviceKey);
      return FALSE;
   }

   RegCloseKey(hBaseKey);
   RegCloseKey(hDeviceKey);
   RegCloseKey(hInstanceKey);

   return TRUE;

} // CreateDeviceIDRegKey



BOOL
IsRootDeviceID(
   LPCWSTR pDeviceID
   )

/*++

Routine Description:

     This routine determines whether the specified device id is the root
     device id.

Arguments:

     pDeviceID    Pointer to a device id string

Return value:

    The return value is TRUE if the string is the root device id and
    FALSE if it is not.

--*/

{
    size_t  DeviceIDLen = 0;

    ASSERT(ARGUMENT_PRESENT(pDeviceID));

    if (FAILED(StringCchLength(
                   pDeviceID,
                   MAX_DEVICE_ID_LEN,
                   &DeviceIDLen))) {
        return FALSE;
    }

    if (CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE,
                      pDeviceID,
                      -1,
                      pszRegRootEnumerator,
                      -1) == CSTR_EQUAL) {
        return TRUE;
    }

    return FALSE;

} // IsRootDeviceID



BOOL
MultiSzAppendW(
      LPWSTR   pszMultiSz,
      PULONG   pulSize,
      LPCWSTR  pszString
      )

/*++

Routine Description:

     Appends a string to a multi_sz string.

Arguments:

     pszMultiSz   Pointer to a multi_sz string

     pulSize      On input, Size of the multi_sz string buffer in bytes,
                  On return, amount copied to the buffer (in bytes)

     pszString    String to append to pszMultiSz

Return value:

    The return value is TRUE if the function succeeded and FALSE if an
    error occured.

--*/

{
   BOOL     bStatus = TRUE;
   HRESULT  hr;
   LPWSTR   pTail;
   ULONG    ulSize;


    try {
        //
        // if it's an empty string, just copy it
        //
        if (*pszMultiSz == L'\0') {

            ulSize = (lstrlen(pszString) + 2) * sizeof(WCHAR);

            if (ulSize > *pulSize) {
                bStatus = FALSE;
                goto Clean0;
            }

            hr = StringCchCopyEx(pszMultiSz,
                                 *pulSize,
                                 pszString,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE |
                                 STRSAFE_IGNORE_NULLS);
            ASSERT(SUCCEEDED(hr));

            if (FAILED(hr)) {
                bStatus = FALSE;
                goto Clean0;
            }

            pszMultiSz[lstrlen(pszMultiSz) + 1] = L'\0';  // add second NULL term char
            *pulSize = ulSize;
            goto Clean0;
        }

        //
        // first find the end of the multi_sz string
        //
        pTail = pszMultiSz;

        while ((ULONG)(pTail - pszMultiSz) * sizeof(WCHAR) < *pulSize) {

            while (*pTail != L'\0') {
                pTail++;
            }
            pTail++;       // skip past the null terminator

            if (*pTail == L'\0') {
                break;      // found the double null terminator
            }
        }

        if ((pTail - pszMultiSz + lstrlen(pszString) + 2) * sizeof(WCHAR)
                > *pulSize) {
            bStatus = FALSE;     // the copy would overflow the buffer
            goto Clean0;
        }


        hr = StringCchCopyEx(pTail,
                             *pulSize,
                             pszString,
                             NULL, NULL,
                             STRSAFE_NULL_ON_FAILURE |
                             STRSAFE_IGNORE_NULLS);
        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            bStatus = FALSE;
            goto Clean0;
        }

        pTail += lstrlen(pszString) + 1;
        *pTail = L'\0';                      // add second null terminator

        //
        // return buffer size in bytes
        //
        *pulSize = (ULONG)((pTail - pszMultiSz + 1)) * sizeof(WCHAR);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

   return bStatus;

} // MultiSzAppendW



LPWSTR
MultiSzFindNextStringW(
      LPWSTR pMultiSz
      )

/*++

Routine Description:

     Finds next string in a multi_sz string.
     device id.

Arguments:

     pMultiSz  Pointer to a multi_sz string

Return value:

    The return value is a pointer to the next string or NULL.

--*/

{
   LPWSTR   lpNextString = pMultiSz;


   //
   // find the next NULL terminator
   //
   while (*lpNextString != L'\0') {
      lpNextString++;
   }
   lpNextString++;      // skip over the NULL terminator

   if (*lpNextString == L'\0') {
      //
      // two NULL terminators in a row means we're at the end
      //
      lpNextString = NULL;
   }

   return lpNextString;

} // MultiSzFindNextStringW



BOOL
MultiSzSearchStringW(
   IN LPCWSTR   pString,
   IN LPCWSTR   pSubString
   )
{
   LPCWSTR   pCurrent = pString;


   //
   // compare each string in the multi_sz pString with pSubString
   //
   while (*pCurrent != L'\0') {

      if (lstrcmpi(pCurrent, pSubString) == 0) {
         return TRUE;
      }

      //
      // go to the next string
      //
      while (*pCurrent != L'\0') {
         pCurrent++;
      }
      pCurrent++;               // skip past the null terminator

      if (*pCurrent == L'\0') {
         break;      // found the double null terminator
      }
   }

   return FALSE;  // pSubString match not found within pString

} // MultiSzSearchStringW



ULONG
MultiSzSizeW(
   IN LPCWSTR  pString
   )

{
   LPCWSTR p = NULL;


   if (pString == NULL) {
      return 0;
   }

   for (p = pString; *p; p += lstrlen(p)+1) {
       //
       // this should fall out with p pointing to the
       // second null in double-null terminator
       //
       NOTHING;
   }

   //
   // returns size in WCHAR
   //
   return (ULONG)(p - pString + 1);

} // MultiSzSizeW



BOOL
MultiSzDeleteStringW(
   IN OUT LPWSTR  pString,
   IN LPCWSTR     pSubString
   )

{
   LPWSTR   p = NULL, pNext = NULL, pBuffer = NULL;
   ULONG    ulSize = 0;


   if (pString == NULL || pSubString == NULL) {
      return FALSE;
   }

   for (p = pString; *p; p += lstrlen(p)+1) {

      if (lstrcmpi(p, pSubString) == 0) {
         //
         // found a match, this is the string to remove.
         //
         pNext = p + lstrlen(p) + 1;

         //
         // If this is the last string then just truncate it
         //
         if (*pNext == L'\0') {
            *p = L'\0';
            *(++p) = L'\0';       // double null-terminator
            return TRUE;
         }

         //
         // retrieve the size of the multi_sz string (in bytes)
         // starting with the substring after the matching substring
         //
         ulSize = MultiSzSizeW(pNext) * sizeof(WCHAR);
         if (ulSize == 0) {
            return FALSE;
         }

         pBuffer = HeapAlloc(ghPnPHeap, 0, ulSize);
         if (pBuffer == NULL) {
            return FALSE;
         }

         //
         // Make a copy of the multi_sz string starting at the
         // substring immediately after the matching substring
         //
         memcpy(pBuffer, pNext, ulSize);

         //
         // Copy that buffer back to the original buffer, but this
         // time copy over the top of the matching substring.  This
         // effectively removes the matching substring and shifts
         // any remaining substrings up in multi_sz string.
         //
         memcpy(p, pBuffer, ulSize);

         HeapFree(ghPnPHeap, 0, pBuffer);
         return TRUE;
      }
   }

   //
   // if we got here, there was no match but I consider this a success
   // since the multi_sz does not contain the substring when we're done
   // (which is the desired goal)
   //

   return TRUE;

} // MultiSzDeleteStringW



BOOL
IsValidDeviceID(
      IN  LPCWSTR pszDeviceID,
      IN  HKEY    hKey,
      IN  ULONG   ulFlags
      )

/*++

Routine Description:

   This routine checks if the given device id is valid (present, not moved,
   not phantom).

Arguments:

   pszDeviceID          Device instance string to validate

   hKey                 Can specify open registry key to pszDeviceID, also

   ulFlag               Controls how much verification to do


Return value:

   The return value is CR_SUCCESS if the function suceeds and one of the
   CR_* values if it fails.

--*/

{
   BOOL     Status = TRUE;
   LONG     RegStatus = ERROR_SUCCESS;
   WCHAR    RegStr[MAX_CM_PATH];
   HKEY     hDevKey = NULL;
   ULONG    ulValue = 0, ulSize = sizeof(ULONG);


   //
   // Does the device id exist in the registry?
   //
   if (hKey == NULL) {

      if (FAILED(StringCchPrintf(
                     RegStr,
                     SIZECHARS(RegStr),
                     L"%s\\%s",
                     pszRegPathEnum,
                     pszDeviceID))) {
          return FALSE;
      }

      RegStatus =
          RegOpenKeyEx(
              HKEY_LOCAL_MACHINE, RegStr, 0,
              KEY_READ, &hDevKey);

      if (RegStatus != ERROR_SUCCESS) {
          return FALSE;
      }

   } else {
       hDevKey = hKey;
   }

   //-----------------------------------------------------------
   // Is the device id present?
   //-----------------------------------------------------------

   if (ulFlags & PNP_PRESENT) {

      if (!IsDeviceIdPresent(pszDeviceID)) {
         Status = FALSE;
         goto Clean0;
      }
   }


   //-----------------------------------------------------------
   // Is it a phantom device id?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_PHANTOM) {

      RegStatus = RegQueryValueEx(
            hDevKey, pszRegValuePhantom, NULL, NULL,
            (LPBYTE)&ulValue, &ulSize);

      if (RegStatus == ERROR_SUCCESS) {
         if (ulValue) {
            Status = FALSE;
            goto Clean0;
         }
      }
   }


   //-----------------------------------------------------------
   // Has the device id been moved?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_MOVED) {

      if (IsDeviceMoved(pszDeviceID, hDevKey)) {
         Status = FALSE;
         goto Clean0;
      }
   }


   //-----------------------------------------------------------
   // Has the device id been removed?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_REMOVED) {

       ULONG ulProblem = 0, ulStatus = 0;

       if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {
          if (ulStatus & DN_WILL_BE_REMOVED) {
             Status = FALSE;
             goto Clean0;
          }
       }
   }

  Clean0:

   if ((hKey == NULL) && (hDevKey != NULL)) {
       RegCloseKey(hDevKey);
   }

   return Status;

} // IsValidDeviceID



BOOL
IsDevicePhantom(
    IN LPWSTR   pszDeviceID
    )

/*++

Routine Description:

   In this case, the check is actually really "is this not present?". The
   only comparison is done against FoundAtEnum. UPDATE: for NT 5.0, the
   FoundAtEnum registry value has been obsoleted, it's been replaced by a
   simple check for the presense of the devnode in memory.

Arguments:

   pszDeviceID          Device instance string to validate

Return value:

   Returns TRUE if the device is a phantom and FALSE if it isn't.

--*/

{
    return !IsDeviceIdPresent(pszDeviceID);

} // IsDevicePhantom



CONFIGRET
GetDeviceStatus(
    IN  LPCWSTR pszDeviceID,
    OUT PULONG  pulStatus,
    OUT PULONG  pulProblem
    )

/*++

Routine Description:

   This routine retrieves the status and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Returns the device's status

   pulProblem     Returns the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_GET_STATUS;
    ControlData.DeviceStatus = 0;
    ControlData.DeviceProblem = 0;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (NT_SUCCESS(ntStatus)) {
        *pulStatus = ControlData.DeviceStatus;
        *pulProblem = ControlData.DeviceProblem;
    } else {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // GetDeviceStatus



CONFIGRET
SetDeviceStatus(
    IN LPCWSTR pszDeviceID,
    IN ULONG   ulStatus,
    IN ULONG   ulProblem
    )

/*++

Routine Description:

   This routine sets the specified status and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Specifies the device's status

   pulProblem     Specifies the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_SET_STATUS;
    ControlData.DeviceStatus = ulStatus;
    ControlData.DeviceProblem = ulProblem;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // SetDeviceStatus



CONFIGRET
ClearDeviceStatus(
    IN LPCWSTR pszDeviceID,
    IN ULONG   ulStatus,
    IN ULONG   ulProblem
    )

/*++

Routine Description:

   This routine clears the specified status and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Specifies the device's status

   pulProblem     Specifies the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_CLEAR_STATUS;
    ControlData.DeviceStatus = ulStatus;
    ControlData.DeviceProblem = ulProblem;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // ClearDeviceStatus



CONFIGRET
CopyRegistryTree(
   IN HKEY     hSrcKey,
   IN HKEY     hDestKey,
   IN ULONG    ulOption
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   HKEY        hSrcSubKey, hDestSubKey;
   WCHAR       RegStr[MAX_PATH];
   ULONG       ulMaxValueName, ulMaxValueData;
   ULONG       ulDataSize, ulLength, ulType, i;
   LPWSTR      pszValueName=NULL;
   LPBYTE      pValueData=NULL;
   PSECURITY_DESCRIPTOR pSecDesc;


   //----------------------------------------------------------------
   // copy all values for this key
   //----------------------------------------------------------------

   //
   // find out the maximum size of any of the value names
   // and value data under the source device instance key
   //
   RegStatus = RegQueryInfoKey(
         hSrcKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
         &ulMaxValueName, &ulMaxValueData, NULL, NULL);

   if (RegStatus != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   ulMaxValueName++;       // size doesn't already include null terminator

   //
   // allocate a buffer big enough to hold the largest value name and
   // the largest value data (note that the max value name is in chars
   // (not including the null terminator) and the max value data is
   // in bytes
   //
   pszValueName = HeapAlloc(ghPnPHeap, 0, ulMaxValueName * sizeof(WCHAR));
   if (pszValueName == NULL) {
      Status = CR_OUT_OF_MEMORY;
      goto Clean0;
   }

   pValueData = HeapAlloc(ghPnPHeap, 0, ulMaxValueData);
   if (pValueData == NULL) {
      Status = CR_OUT_OF_MEMORY;
      goto Clean0;
   }

   //
   // enumerate and copy each value
   //
   for (i=0; RegStatus == ERROR_SUCCESS; i++) {

      ulLength = ulMaxValueName;
      ulDataSize = ulMaxValueData;

      RegStatus = RegEnumValue(
                  hSrcKey, i, pszValueName, &ulLength, NULL,
                  &ulType, pValueData, &ulDataSize);

        if (RegStatus == ERROR_SUCCESS) {

           RegSetValueEx(
                  hDestKey, pszValueName, 0, ulType, pValueData,
                  ulDataSize);
        }
    }

    HeapFree(ghPnPHeap, 0, pszValueName);
    pszValueName = NULL;

    HeapFree(ghPnPHeap, 0, pValueData);
    pValueData = NULL;


    //---------------------------------------------------------------
    // recursively call CopyRegistryNode to copy all subkeys
    //---------------------------------------------------------------

    RegStatus = ERROR_SUCCESS;

    for (i=0; RegStatus == ERROR_SUCCESS; i++) {

      ulLength = MAX_PATH;

      RegStatus = RegEnumKey(hSrcKey, i, RegStr, ulLength);

      if (RegStatus == ERROR_SUCCESS) {

         if (RegOpenKey(hSrcKey, RegStr, &hSrcSubKey) == ERROR_SUCCESS) {

            if (RegCreateKeyEx(
                     hDestKey, RegStr, 0, NULL, ulOption, KEY_ALL_ACCESS,
                     NULL, &hDestSubKey, NULL) == ERROR_SUCCESS) {

               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION,
                     NULL, &ulDataSize);

               pSecDesc = HeapAlloc(ghPnPHeap, 0, ulDataSize);
               if (pSecDesc == NULL) {
                  Status = CR_OUT_OF_MEMORY;
                  RegCloseKey(hSrcSubKey);
                  RegCloseKey(hDestSubKey);
                  goto Clean0;
               }

               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION,
                     pSecDesc, &ulDataSize);

               CopyRegistryTree(hSrcSubKey, hDestSubKey, ulOption);

               RegSetKeySecurity(hDestSubKey, DACL_SECURITY_INFORMATION, pSecDesc);

               HeapFree(ghPnPHeap, 0, pSecDesc);
               RegCloseKey(hDestSubKey);
            }
            RegCloseKey(hSrcSubKey);
         }
      }
   }

   Clean0:

   if (pszValueName != NULL) {
      HeapFree(ghPnPHeap, 0, pszValueName);
   }
   if (pValueData != NULL) {
      pValueData = NULL;
   }

   return Status;

} // CopyRegistryTree



BOOL
PathToString(
   IN LPWSTR   pszString,
   IN LPCWSTR  pszPath,
   IN ULONG    ulLen
   )
{
   LPWSTR p;
   HRESULT hr;

   hr = StringCchCopyEx(pszString,
                        ulLen,
                        pszPath,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE);
   ASSERT(SUCCEEDED(hr));

   if (FAILED(hr)) {
       return FALSE;
   }

   for (p = pszString; *p; p++) {
      if (*p == TEXT('\\')) {
         *p = TEXT('&');
      }
   }

   return TRUE;

} // PathToString



BOOL
IsDeviceMoved(
   IN LPCWSTR  pszDeviceID,
   IN HKEY     hKey
   )
{
   HKEY  hTempKey;
   WCHAR RegStr[MAX_CM_PATH];

   PathToString(RegStr, pszDeviceID,MAX_CM_PATH);

   if (RegOpenKeyEx(
        hKey, RegStr, 0, KEY_READ, &hTempKey) == ERROR_SUCCESS) {
      RegCloseKey(hTempKey);
      return TRUE;
   }

   return FALSE;

} // IsDeviceMoved



CONFIGRET
SetKeyVolatileState(
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey,
   IN DWORD    dwRegOptions
   )

{
   CONFIGRET   Status = CR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH], szTempKey[MAX_CM_PATH];
   HKEY        hParentKey = NULL, hChildKey = NULL, hKey = NULL;
   HKEY        hTempKey = NULL;


   //---------------------------------------------------------------------
   // Convert the registry key specified by pszChildKey (a subkey of
   // pszParentKey) to a key with the volatile state specified by copying it to
   // a temporary key and recreating the key, then copying the original
   // registry info back. This also converts any subkeys of pszChildKey.
   //---------------------------------------------------------------------

   ASSERT(ARGUMENT_PRESENT(pszParentKey));
   ASSERT(ARGUMENT_PRESENT(pszChildKey));

   //
   // This routine only handles the REG_OPTION bits that specify the volatile
   // state of the key.
   //
   ASSERT((dwRegOptions == REG_OPTION_VOLATILE) || (dwRegOptions == REG_OPTION_NON_VOLATILE));

   if (dwRegOptions & REG_OPTION_VOLATILE) {
       dwRegOptions = REG_OPTION_VOLATILE;
   } else {
       dwRegOptions = REG_OPTION_NON_VOLATILE;
   }

   //
   // Open a key to the parent
   //
   if (RegOpenKeyEx(
           HKEY_LOCAL_MACHINE, pszParentKey, 0,
           KEY_ALL_ACCESS, &hParentKey) != ERROR_SUCCESS) {
       goto Clean0;         // nothing to convert
   }

   //
   // open a key to the child subkey
   //
   if (RegOpenKeyEx(
           hParentKey, pszChildKey, 0,
           KEY_ALL_ACCESS, &hChildKey) != ERROR_SUCCESS) {
       goto Clean0;         // nothing to convert
   }

   //
   // 1. Open a unique temporary key under the special Deleted Key.
   // Use the parent key path to form the unique tempory key. There shouldn't
   // already be such a key, but if there is then just overwrite it.
   //
   if (RegOpenKeyEx(
           HKEY_LOCAL_MACHINE, pszRegPathCurrentControlSet, 0,
           KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {
       Status = CR_REGISTRY_ERROR;
       goto Clean0;
   }

   if (FAILED(StringCchPrintf(
                  RegStr,
                  SIZECHARS(RegStr),
                  L"%s\\%s",
                  pszParentKey,
                  pszChildKey))) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   PathToString(szTempKey, RegStr,MAX_CM_PATH);

   if (FAILED(StringCchPrintf(
                  RegStr,
                  SIZECHARS(RegStr),
                  L"%s\\%s",
                  pszRegKeyDeleted,
                  szTempKey))) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   if (RegCreateKeyEx(
           hKey, RegStr, 0, NULL, dwRegOptions,
           KEY_ALL_ACCESS, NULL, &hTempKey, NULL) != ERROR_SUCCESS) {
       Status = CR_REGISTRY_ERROR;
       goto Clean0;
   }

   //
   // 2. Save the current child key (and any subkeys) to a temporary
   // location
   //
   Status = CopyRegistryTree(hChildKey, hTempKey, dwRegOptions);

   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   RegCloseKey(hChildKey);
   hChildKey = NULL;

   //
   // 3. Delete the current child key (and any subkeys)
   //
   if (!RegDeleteNode(hParentKey, pszChildKey)) {
      Status = CR_REGISTRY_ERROR;
      goto CleanupTempKeys;
   }

   //
   // 4. Recreate the current child key using the volatile state specified
   //
   if (RegCreateKeyEx(
           hParentKey, pszChildKey, 0, NULL,
           dwRegOptions, KEY_ALL_ACCESS, NULL,
           &hChildKey, NULL) != ERROR_SUCCESS) {
       Status = CR_REGISTRY_ERROR;
       goto CleanupTempKeys;
   }

   //
   // 5. Copy the original child key (and any subkeys) back
   // to the new child key as specified by the volatile state.
   //
   Status = CopyRegistryTree(hTempKey, hChildKey, dwRegOptions);

   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   //
   // 6. Remove the temporary instance key (and any subkeys)
   //
   CleanupTempKeys:

   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
      hTempKey = NULL;
   }

   if (SUCCEEDED(StringCchPrintf(
                     RegStr,
                     SIZECHARS(RegStr),
                     L"%s\\%s",
                     pszRegPathCurrentControlSet,
                     pszRegKeyDeleted))) {

       if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, RegStr, 0,
               KEY_ALL_ACCESS, &hTempKey) == ERROR_SUCCESS) {
           RegDeleteNode(hTempKey, szTempKey);
           RegCloseKey(hTempKey);
           hTempKey = NULL;
       }
   }

  Clean0:

   if (hParentKey != NULL) {
      RegCloseKey(hParentKey);
   }
   if (hChildKey != NULL) {
      RegCloseKey(hChildKey);
   }
   if (hKey != NULL) {
      RegCloseKey(hKey);
   }
   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
   }

   return Status;

} // SetKeyVolatileState



CONFIGRET
MakeKeyVolatile(
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )

{
    CONFIGRET  Status;

    //
    // Set the state of the key to volatile.
    //
    Status =
        SetKeyVolatileState(
            pszParentKey,
            pszChildKey,
            REG_OPTION_VOLATILE);

    return Status;

} // MakeKeyVolatile



CONFIGRET
MakeKeyNonVolatile(
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )

{
    CONFIGRET  Status;

    //
    // Set the state of the key to non-volatile.
    //
    Status =
        SetKeyVolatileState(
            pszParentKey,
            pszChildKey,
            REG_OPTION_NON_VOLATILE);

    return Status;

} // MakeKeyNonVolatile



CONFIGRET
OpenLogConfKey(
    IN  LPCWSTR  pszDeviceID,
    IN  ULONG    LogConfType,
    OUT PHKEY    phKey
    )
{
    CONFIGRET      Status = CR_SUCCESS;
    LONG           RegStatus = ERROR_SUCCESS;
    HKEY           hKey = NULL;
    ULONG          ulSize = 0;

    try {

        //
        // Open a key to the device ID
        //

        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                 KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY,
                                 &hKey);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Alloc/Filtered configs are the exception, it's stored in the volative Control
        // subkey, all the other log confs are stored under the nonvolatile
        // LogConf subkey.
        //

        if ((LogConfType == ALLOC_LOG_CONF) || (LogConfType == FILTERED_LOG_CONF)) {

            //
            // Try the control key first, if no alloc config value there,
            // then try the log conf key.
            //

            RegStatus = RegCreateKeyEx(hKey, pszRegKeyDeviceControl, 0, NULL,
                                       REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);

            if (RegStatus == ERROR_SUCCESS) {
                if (RegQueryValueEx(*phKey, pszRegValueAllocConfig, NULL, NULL,
                                    NULL, &ulSize) == ERROR_SUCCESS) {
                    goto Clean0;
                }
                RegCloseKey(*phKey);
            }

            RegStatus = RegCreateKeyEx(hKey, pszRegKeyLogConf, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);

        } else {
            RegStatus = RegCreateKeyEx(hKey, pszRegKeyLogConf, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);
        }

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // OpenLogConfKey



BOOL
GetActiveService(
    IN  PCWSTR pszDevice,
    OUT PWSTR  pszService
    )
{
    WCHAR   RegStr[MAX_CM_PATH];
    HKEY    hKey = NULL;
    ULONG   ulSize;


    if ((!ARGUMENT_PRESENT(pszService)) ||
        (!ARGUMENT_PRESENT(pszDevice))) {
        return FALSE;
    }

    *pszService = TEXT('\0');

    //
    // open the volatile control key under the device instance
    //
    if (FAILED(StringCchPrintf(
                   RegStr,
                   SIZECHARS(RegStr),
                   L"%s\\%s\\%s",
                   pszRegPathEnum,
                   pszDevice,
                   pszRegKeyDeviceControl))) {
        return FALSE;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // query the active service value
    //
    ulSize = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);

    if (RegQueryValueEx(hKey, pszRegValueActiveService, NULL, NULL,
                       (LPBYTE)pszService, &ulSize) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        *pszService = TEXT('\0');
        return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;

} // GetActiveService



BOOL
IsDeviceIdPresent(
    IN  LPCWSTR pszDeviceID
    )

/*++

Routine Description:

     This routine determines whether the specified device instance is
     considered physically present or not. This used to be based on a check
     of the old "FoundAtEnum" registry setting. Now we just look for the presense
     of an in-memory devnode associated with this device instance to decide whether
     it's present or not.

Arguments:

    pszDeviceID - device instance string to test for presense on

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
    ULONG   ulStatus, ulProblem;

    //
    // If the call failed, then assume the device isn't present
    //

    return GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS;

} // IsDeviceIdPresent



ULONG
GetDeviceConfigFlags(
    IN  LPCWSTR pszDeviceID,
    IN  HKEY    hKey
    )
{
    HKEY     hDevKey = NULL;
    ULONG    ulValue = 0, ulSize = sizeof(ULONG);


    //
    // If hKey is null, then open a key to the device instance.
    //
    if (hKey == NULL) {

        if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ,
                         &hDevKey) != ERROR_SUCCESS) {
            goto Clean0;
        }

    } else {
        hDevKey = hKey;
    }

    //
    // Retrieve the configflag value
    //
    if (RegQueryValueEx(hDevKey, pszRegValueConfigFlags, NULL, NULL,
                        (LPBYTE)&ulValue, &ulSize) != ERROR_SUCCESS) {
        ulValue = 0;
    }

    Clean0:

    if ((hKey == NULL) && (hDevKey != NULL)) {
        RegCloseKey(hDevKey);
    }

    return ulValue;

} // GetDeviceConfigFlags



ULONG
MapNtStatusToCmError(
    ULONG NtStatus
    )
{
    switch (NtStatus) {
    case STATUS_BUFFER_TOO_SMALL:
        return CR_BUFFER_SMALL;

    case STATUS_NO_SUCH_DEVICE:
        return CR_NO_SUCH_DEVINST;

    case STATUS_INVALID_PARAMETER:
    case STATUS_INVALID_PARAMETER_1:
    case STATUS_INVALID_PARAMETER_2:
        return CR_INVALID_DATA;

    case STATUS_NOT_IMPLEMENTED:
        return CR_CALL_NOT_IMPLEMENTED;

    case STATUS_ACCESS_DENIED:
        return CR_ACCESS_DENIED;

    case STATUS_OBJECT_NAME_NOT_FOUND:
        return CR_NO_SUCH_VALUE;

    default:
        return CR_FAILURE;
    }

} // MapNtStatusToCmError



//
// GUID-related utility routines.
//

BOOL
IsValidGuid(
   LPWSTR   pszGuid
   )

/*++

Routine Description:

     This routine determines whether a string is of the proper Guid form.

Arguments:

     pszGuid   Pointer to a string that will be checked for the standard Guid
               format.

Return value:

    The return value is TRUE if the string is a valid Guid and FALSE if it
    is not.

--*/

{
   //----------------------------------------------------------------
   // NOTE: This may change later, but for now I am just verifying
   // that the string has exactly MAX_GUID_STRING_LEN characters
   //----------------------------------------------------------------

   if (lstrlen(pszGuid) != MAX_GUID_STRING_LEN-1) {
      return FALSE;
   }

   return TRUE;

} // IsValidGuid



BOOL
GuidEqual(
    CONST GUID UNALIGNED *Guid1,
    CONST GUID UNALIGNED *Guid2
    )
{
    RPC_STATUS rpcStatus;

    //
    // Note - rpcStatus is ignored, the RPC runtime always sets it to RPC_S_OK.
    // The UUID comparison result is returned directly, non-zero if the UUIDs
    // are equal, zero otherwise.
    //
    return (BOOL)(UuidEqual((LPGUID)Guid1, (LPGUID)Guid2, &rpcStatus));

} // GuidEqual



DWORD
GuidFromString(
    IN  PCWSTR GuidString,
    OUT LPGUID Guid
    )
/*++

Routine Description:

    This routine converts the character representation of a GUID into its binary
    form (a GUID struct).  The GUID is in the following form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where 'x' is a hexadecimal digit.

Arguments:

    GuidString - Supplies a pointer to the null-terminated GUID string.  The

    Guid - Supplies a pointer to the variable that receives the GUID structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is RPC_S_INVALID_STRING_UUID.

--*/
{
    WCHAR    UuidBuffer[GUID_STRING_LEN - 1];
    size_t   UuidLen = 0;

    //
    // Since we're using a RPC UUID routine, we need to strip off the surrounding
    // curly braces first.
    //
    if (*GuidString++ != TEXT('{')) {
        return RPC_S_INVALID_STRING_UUID;
    }

    if (FAILED(StringCchCopy(UuidBuffer,
                             SIZECHARS(UuidBuffer),
                             GuidString))) {
        return RPC_S_INVALID_STRING_UUID;
    }

    if (FAILED(StringCchLength(UuidBuffer,
                               SIZECHARS(UuidBuffer),
                               &UuidLen))) {
        return RPC_S_INVALID_STRING_UUID;
    }

    if ((UuidLen != GUID_STRING_LEN - 2) ||
        (UuidBuffer[GUID_STRING_LEN - 3] != TEXT('}'))) {
        return RPC_S_INVALID_STRING_UUID;
    }

    UuidBuffer[GUID_STRING_LEN - 3] = TEXT('\0');

    if (UuidFromString(UuidBuffer, Guid) != RPC_S_OK) {
        return RPC_S_INVALID_STRING_UUID;
    }

    return NO_ERROR;

} // GuidFromString



DWORD
StringFromGuid(
    IN  CONST GUID *Guid,
    OUT PWSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (GUID_STRING_LEN) characters
        long.

Return Value:

    If success, the return value is NO_ERROR.
    if failure, the return value is

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < GUID_STRING_LEN) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return NO_ERROR;

} // StringFromGuid



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\secutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    secutil.c

Abstract:

    This module contains security-related utility routines.

        GetUserSid
        GetInteractiveSid

        IsClientLocal
        IsClientUsingLocalConsole
        IsClientInteractive

Author:

    James G. Cavalaris (jamesca) 31-Jan-2002

Environment:

    User-mode only.

Revision History:

    31-Jan-2002     Jim Cavalaris (jamesca)

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"

#pragma warning(push)
#pragma warning(disable:4214)
#pragma warning(disable:4201)
#include <winsta.h>
#pragma warning(pop)
#include <syslib.h>





PSID
GetUserSid(
    IN  HANDLE  hUserToken
    )

/*++

Routine Description:

    Retrieves the corresponding user SID for the specified user access token.

Arguments:

    hUserToken -

        Specifies a handle to a user access token.

Return Value:

    If successful, returns a pointer to an allocated buffer containing the SID
    for the specified user access token.  Otherwise, returns NULL.

Notes:

    If successful, it is responsibility of the caller to free the the returned
    buffer from the ghPnPHeap with HeapFree.

--*/

{
    BOOL  bResult;
    DWORD cbBuffer, cbRequired;
    PTOKEN_USER pUserInfo = NULL;
    PSID pUserSid = NULL;


    //
    // Determine the size of buffer we need to store the TOKEN_USER information
    // for the supplied user access token.  The TOKEN_USER structure contains
    // the SID_AND_ATTRIBUTES information for the User.
    //

    cbBuffer = 0;

    bResult =
        GetTokenInformation(
            hUserToken,
            TokenUser,
            NULL,
            cbBuffer,
            &cbRequired);

    ASSERT(bResult == FALSE);

    if (bResult) {
        SetLastError(ERROR_INVALID_DATA);
        goto Clean0;
    } else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        goto Clean0;
    }

    ASSERT(cbRequired > 0);

    //
    // Allocate a buffer for the TOKEN_USER data.
    //

    cbBuffer = cbRequired;

    pUserInfo =
        (PTOKEN_USER)HeapAlloc(
            ghPnPHeap, 0, cbBuffer);

    if (pUserInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Clean0;
    }

    //
    // Retrieve the TOKEN_USER data.
    //

    bResult =
        GetTokenInformation(
            hUserToken,
            TokenUser,
            pUserInfo,
            cbBuffer,
            &cbRequired);

    if (!bResult) {
        goto Clean0;
    }

    ASSERT(pUserInfo->User.Sid != NULL);

    //
    // Check that the returned SID is valid.
    // Note - calling GetLastError is not valid for IsValidSid!
    //

    ASSERT(IsValidSid(pUserInfo->User.Sid));

    if (!IsValidSid(pUserInfo->User.Sid)) {
        SetLastError(ERROR_INVALID_DATA);
        goto Clean0;
    }

    //
    // Make a copy of the User SID_AND_ATTRIBUTES.
    //

    cbBuffer =
        GetLengthSid(pUserInfo->User.Sid);

    ASSERT(cbBuffer > 0);

    pUserSid =
        (PSID)HeapAlloc(
            ghPnPHeap, 0, cbBuffer);

    if (pUserSid == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Clean0;
    }

    bResult =
        CopySid(
            cbBuffer,
            pUserSid,
            pUserInfo->User.Sid);

    if (!bResult) {
        HeapFree(ghPnPHeap, 0, pUserSid);
        pUserSid = NULL;
        goto Clean0;
    }

    //
    // Check that the returned SID is valid.
    // Note - calling GetLastError is not valid for IsValidSid!
    //

    ASSERT(IsValidSid(pUserSid));

    if (!IsValidSid(pUserSid)) {
        SetLastError(ERROR_INVALID_DATA);
        HeapFree(ghPnPHeap, 0, pUserSid);
        pUserSid = NULL;
        goto Clean0;
    }

  Clean0:

    if (pUserInfo != NULL) {
        HeapFree(ghPnPHeap, 0, pUserInfo);
    }

    return pUserSid;

} // GetUserSid



PSID
GetInteractiveSid(
    VOID
    )

/*++

Routine Description:

    Retrieves the Interactive Group SID.

Arguments:

    None.

Return Value:

    If successful, returns a pointer to an allocated buffer containing the SID
    for the Interactive Group.  Otherwise, returns NULL.

Notes:

    If successful, it is responsibility of the caller to free the the returned
    buffer from the ghPnPHeap with HeapFree.

--*/

{
    BOOL  bResult;
    DWORD cbBuffer;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL, pInteractiveSid = NULL;


    //
    // Create the Interactive Group SID
    //

    bResult =
        AllocateAndInitializeSid(
            &NtAuthority, 1,
            SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pInteractiveSid);

    if (!bResult) {
        goto Clean0;
    }

    ASSERT(pInteractiveSid != NULL);

    //
    // Check that the returned SID is valid.
    // Note - calling GetLastError is not valid for IsValidSid!
    //

    ASSERT(IsValidSid(pInteractiveSid));

    if (!IsValidSid(pInteractiveSid)) {
        SetLastError(ERROR_INVALID_DATA);
        goto Clean0;
    }

    //
    // Make a copy of the Interactive Group SID.
    //

    cbBuffer =
        GetLengthSid(pInteractiveSid);

    ASSERT(cbBuffer > 0);

    pSid =
        (PSID)HeapAlloc(
            ghPnPHeap, 0, cbBuffer);

    if (pSid == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Clean0;
    }

    bResult =
        CopySid(
            cbBuffer,
            pSid,
            pInteractiveSid);

    if (!bResult) {
        HeapFree(ghPnPHeap, 0, pSid);
        pSid = NULL;
        goto Clean0;
    }

    //
    // Check that the returned SID is valid.
    // Note - calling GetLastError is not valid for IsValidSid!
    //

    ASSERT(IsValidSid(pSid));

    if (!IsValidSid(pSid)) {
        SetLastError(ERROR_INVALID_DATA);
        HeapFree(ghPnPHeap, 0, pSid);
        pSid = NULL;
        goto Clean0;
    }

  Clean0:

    if (pInteractiveSid != NULL) {
        FreeSid(pInteractiveSid);
    }

    return pSid;

} // GetInteractiveSid



//
// RPC client attributes and group membership routines
//

BOOL
IsClientLocal(
    IN  handle_t    hBinding
    )

/*++

Routine Description:

    This routine determines if the client associated with hBinding is on the
    local machine.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is local to this machine, FALSE if
    not or if an error occurs.

--*/

{
    RPC_STATUS  RpcStatus;
    UINT        ClientLocalFlag;


    //
    // If the specified RPC binding handle is NULL, this is an internal call so
    // we assume that the privilege has already been checked.
    //

    if (hBinding == NULL) {
        return TRUE;
    }

    //
    // Retrieve the ClientLocalFlags from the RPC binding handle.
    //

    RpcStatus =
        I_RpcBindingIsClientLocal(
            hBinding,
            &ClientLocalFlag);

    if (RpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: I_RpcBindingIsClientLocal failed, RpcStatus=%d\n",
                   RpcStatus));
        return FALSE;
    }

    //
    // If the ClientLocalFlag is not zero, RPC client is local to server.
    //

    if (ClientLocalFlag != 0) {
        return TRUE;
    }

    //
    // Client is not local to this server.
    //

    return FALSE;

} // IsClientLocal



BOOL
IsClientUsingLocalConsole(
    IN  handle_t    hBinding
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client is using the current active console session.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is using the current active console
    session, FALSE if not or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bResult = FALSE;

    //
    // First, make sure the client is local to the server.
    //
    if (!IsClientLocal(hBinding)) {
        return FALSE;
    }

    //
    // Impersonate the client to retrieve the impersonation token.
    //

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        return FALSE;
    }

    //
    // Compare the client's session with the currently active Console session.
    //

    if (GetClientLogonId() == GetActiveConsoleSessionId()) {
        bResult = TRUE;
    }

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
        ASSERT(rpcStatus == RPC_S_OK);
    }

    return bResult;

} // IsClientUsingLocalConsole



BOOL
IsClientInteractive(
    IN handle_t     hBinding
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client is a member of the INTERACTIVE well-known group.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is interactive, FALSE if not
    or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bIsMember;
    HANDLE          hToken;
    PSID            pInteractiveSid;
    BOOL            bResult = FALSE;


    //
    // First, make sure the client is local to the server.
    //

    if (!IsClientLocal(hBinding)) {
        return FALSE;
    }

    //
    // If the specified RPC binding handle is NULL, this is an internal call so
    // we assume that the privilege has already been checked.
    //

    if (hBinding == NULL) {
        return TRUE;
    }

    //
    // Retrieve the Interactive Group SID
    //

    pInteractiveSid =
        GetInteractiveSid();

    if (pInteractiveSid == NULL) {
        return FALSE;
    }

    //
    // Impersonate the client to retrieve the impersonation token.
    //

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        HeapFree(ghPnPHeap, 0, pInteractiveSid);
        return FALSE;
    }

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

        if (CheckTokenMembership(hToken,
                                 pInteractiveSid,
                                 &bIsMember)) {
            if (bIsMember) {
                bResult = TRUE;
            }
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: CheckTokenMembership failed, error = %d\n",
                       GetLastError()));
        }
        CloseHandle(hToken);

    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: OpenThreadToken failed, error = %d\n",
                   GetLastError()));
    }

    HeapFree(ghPnPHeap, 0, pInteractiveSid);

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
        ASSERT(rpcStatus == RPC_S_OK);
    }

    return bResult;

} // IsClientInteractive



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\umpnpdat.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umpnpdat.c

Abstract:

    This module contains global strings.

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop

#include <pnpmgr.h>


//
// global registry strings
//
WCHAR pszRegPathCurrentControlSet[] =     REGSTR_PATH_CURRENTCONTROLSET;
WCHAR pszRegPathEnum[] =                  REGSTR_PATH_SYSTEMENUM;
WCHAR pszRegPathClass[] =                 REGSTR_PATH_CLASS_NT;
WCHAR pszRegPathDeviceClasses[] =         REGSTR_PATH_DEVICE_CLASSES;
WCHAR pszRegPathServices[] =              REGSTR_PATH_SERVICES;
WCHAR pszRegPathHwProfiles[] =            REGSTR_PATH_HWPROFILES;
WCHAR pszRegPathCurrent[] =               REGSTR_PATH_HWPROFILESCURRENT;
WCHAR pszRegPathIDConfigDB[] =            REGSTR_PATH_IDCONFIGDB;
WCHAR pszRegPathPerHwIdStorage[] =        REGSTR_PATH_PER_HW_ID_STORAGE;

WCHAR pszRegKeySystem[] =                 REGSTR_KEY_SYSTEM;
WCHAR pszRegKeyEnum[] =                   REGSTR_KEY_ENUM;
WCHAR pszRegKeyCurrent[] =                REGSTR_KEY_CURRENT;
WCHAR pszRegKeyCurrentDockInfo[] =        REGSTR_KEY_CURRENT_DOCK_INFO;
WCHAR pszRegKeyKnownDockingStates[] =     REGSTR_KEY_KNOWNDOCKINGSTATES;
WCHAR pszRegKeyDeviceParam[] =            REGSTR_KEY_DEVICEPARAMETERS;
WCHAR pszRegKeyRootEnum[] =               REGSTR_KEY_ROOTENUM;
WCHAR pszRegKeyDeleted[] =                REGSTR_KEY_DELETEDDEVICE;
WCHAR pszRegKeyLogConf[] =                REGSTR_KEY_LOGCONF;
WCHAR pszRegKeyDeviceControl[] =          REGSTR_KEY_DEVICECONTROL;
WCHAR pszRegKeyProperties[] =             REGSTR_KEY_DEVICE_PROPERTIES;

WCHAR pszRegValueDeviceInstance[] =       REGSTR_VAL_DEVICE_INSTANCE;
WCHAR pszRegValueDeviceDesc[] =           REGSTR_VAL_DEVDESC;
WCHAR pszRegValueNewDeviceDesc[] =        REGSTR_VAL_NEW_DEVICE_DESC;
WCHAR pszRegValueSlotNumber[] =           REGSTR_VAL_SLOTNUMBER;
WCHAR pszRegValuePortName[] =             REGSTR_VAL_PORTNAME;
WCHAR pszRegValueHardwareIDs[] =          REGSTR_VAL_HARDWAREID;
WCHAR pszRegValueCompatibleIDs[] =        REGSTR_VAL_COMPATIBLEIDS;
WCHAR pszRegValueSystemBusNumber[] =      REGSTR_VAL_SYSTEMBUSNUMBER;
WCHAR pszRegValueBusDataType[] =          REGSTR_VAL_BUSDATATYPE;
WCHAR pszRegValueInterfaceType[] =        REGSTR_VAL_INTERFACETYPE;
WCHAR pszRegValueService[] =              REGSTR_VAL_SERVICE;
WCHAR pszRegValueDetectSignature[] =      REGSTR_VAL_DETECTSIGNATURE;
WCHAR pszRegValueClass[] =                REGSTR_VAL_CLASS;
WCHAR pszRegValueClassGuid[] =            REGSTR_VAL_CLASSGUID;
WCHAR pszRegValueDriver[] =               REGSTR_VAL_DRIVER;
WCHAR pszRegValueInstanceIdentifier[] =   REGSTR_VAL_INSTANCEIDENTIFIER;
WCHAR pszRegValueDuplicateOf[] =          REGSTR_VAL_DUPLICATEOF;
WCHAR pszRegValueCSConfigFlags[] =        REGSTR_VAL_CSCONFIGFLAGS;
WCHAR pszRegValueConfigFlags[] =          REGSTR_VAL_CONFIGFLAGS;
WCHAR pszRegValueDisableCount[] =         REGSTR_VAL_DISABLECOUNT;
WCHAR pszRegValueUnknownProblems[] =      REGSTR_VAL_UNKNOWNPROBLEMS;
WCHAR pszRegValueCurrentConfig[] =        REGSTR_VAL_CURCONFIG;
WCHAR pszRegValueFriendlyName[] =         REGSTR_VAL_FRIENDLYNAME;
WCHAR pszRegValueDockState[] =            REGSTR_VAL_DOCKSTATE;
WCHAR pszRegValueDockingState[] =         TEXT("DockingState");
WCHAR pszRegValueEjectableDocks[] =       REGSTR_VAL_EJECTABLE_DOCKS;
WCHAR pszRegValuePreferenceOrder[] =      REGSTR_VAL_PREFERENCEORDER;
WCHAR pszRegValueUserWaitInterval[] =     REGSTR_VAL_USERWAITINTERVAL;
WCHAR pszRegValuePhantom[] =              REGSTR_VAL_PHANTOM;
WCHAR pszRegValueFirmwareIdentified[] =   REGSTR_VAL_FIRMWAREIDENTIFIED;
WCHAR pszRegValueFirmwareMember[] =       REGSTR_VAL_FIRMWAREMEMBER;
WCHAR pszRegValueMfg[] =                  REGSTR_VAL_MFG;
WCHAR pszRegValueCount[] =                REGSTR_VAL_Count;
WCHAR pszRegValueBootConfig[] =           REGSTR_VAL_BOOTCONFIG;
WCHAR pszRegValueAllocConfig[] =          REGSTR_VAL_ALLOCCONFIG;
WCHAR pszRegValueForcedConfig[] =         REGSTR_VAL_FORCEDCONFIG;
WCHAR pszRegValueOverrideVector[] =       REGSTR_VAL_OVERRIDECONFIGVECTOR;
WCHAR pszRegValueBasicVector[] =          REGSTR_VAL_BASICCONFIGVECTOR;
WCHAR pszRegValueFilteredVector[] =       REGSTR_VAL_FILTEREDCONFIGVECTOR;
WCHAR pszRegValueActiveService[] =        REGSTR_VAL_ACTIVESERVICE;
WCHAR pszRegValuePlugPlayServiceType[] =  REGSTR_VAL_PNPSERVICETYPE;
WCHAR pszRegValueLocationInformation[] =  REGSTR_VAL_LOCATION_INFORMATION;
WCHAR pszRegValueCapabilities[] =         REGSTR_VAL_CAPABILITIES;
WCHAR pszRegValueUiNumber[] =             REGSTR_VAL_UI_NUMBER;
WCHAR pszRegValueUiNumberDescFormat[] =   REGSTR_VAL_UI_NUMBER_DESC_FORMAT;
WCHAR pszRegValueRemovalPolicyOverride[]= REGSTR_VAL_REMOVAL_POLICY;
WCHAR pszRegValueUpperFilters[] =         REGSTR_VAL_UPPERFILTERS;
WCHAR pszRegValueLowerFilters[] =         REGSTR_VAL_LOWERFILTERS;
WCHAR pszRegValueSecurity[] =             REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR;
WCHAR pszRegValueDevType[] =              REGSTR_VAL_DEVICE_TYPE;
WCHAR pszRegValueExclusive[] =            REGSTR_VAL_DEVICE_EXCLUSIVE;
WCHAR pszRegValueCharacteristics[] =      REGSTR_VAL_DEVICE_CHARACTERISTICS;
WCHAR pszRegValueMigrated[] =             TEXT("Migrated");
WCHAR pszRegValuePreservePreInstall[] =   REGSTR_VAL_PRESERVE_PREINSTALL;

WCHAR pszControlFlags[] =                 INFSTR_CONTROLFLAGS_SECTION;
WCHAR pszInteractiveInstall[] =           INFSTR_KEY_INTERACTIVEINSTALL;

WCHAR pszRegValuePhysicalDeviceObject[] = REGSTR_VAL_PHYSICALDEVICEOBJECT;
WCHAR pszRegRootEnumerator[] =            REGSTR_VAL_ROOT_DEVNODE;

WCHAR pszRegPathPolicies[] =              REGSTR_PATH_POLICIES;
WCHAR pszRegValueUndockWithoutLogon[] =   REGSTR_VAL_UNDOCK_WITHOUT_LOGON;

WCHAR pszRegValueCustomPropertyCacheDate[] = REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE;
WCHAR pszRegValueCustomPropertyHwIdKey[]   = REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY;
WCHAR pszRegValueLastUpdateTime[]          = REGSTR_VAL_LAST_UPDATE_TIME;

WCHAR pszRegKeyPlugPlayServiceParams[] =  TEXT("PlugPlay\\Parameters");
WCHAR pszRegValueDebugInstall[] =         TEXT("DebugInstall");
WCHAR pszRegValueDebugInstallCommand[] =  TEXT("DebugInstallCommand");

#if DBG
WCHAR pszRegValueDebugFlags[] =           TEXT("DebugFlags");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\umpnpdat.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umpnpdat.h

Abstract:

    This module contains extern declarations for the global strings
    in umpnpdat.c

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// global strings
//

extern WCHAR pszRegPathCurrentControlSet[];
extern WCHAR pszRegPathEnum[];
extern WCHAR pszRegPathClass[];
extern WCHAR pszRegPathDeviceClasses[];
extern WCHAR pszRegPathServices[];
extern WCHAR pszRegPathHwProfiles[];
extern WCHAR pszRegPathCurrent[];
extern WCHAR pszRegPathIDConfigDB[];
extern WCHAR pszRegPathPerHwIdStorage[];

extern WCHAR pszRegKeySystem[];
extern WCHAR pszRegKeyEnum[];
extern WCHAR pszRegKeyCurrent[];
extern WCHAR pszRegKeyCurrentDockInfo[];
extern WCHAR pszRegKeyKnownDockingStates[];
extern WCHAR pszRegKeyDeviceParam[];
extern WCHAR pszRegKeyRootEnum[];
extern WCHAR pszRegKeyDeleted[];
extern WCHAR pszRegKeyLogConf[];
extern WCHAR pszRegKeyDeviceControl[];
extern WCHAR pszRegKeyProperties[];

extern WCHAR pszRegValueDeviceInstance[];
extern WCHAR pszRegValueDeviceDesc[];
extern WCHAR pszRegValueNewDeviceDesc[];
extern WCHAR pszRegValueSlotNumber[];
extern WCHAR pszRegValuePortName[];
extern WCHAR pszRegValueHardwareIDs[];
extern WCHAR pszRegValueCompatibleIDs[];
extern WCHAR pszRegValueSystemBusNumber[];
extern WCHAR pszRegValueBusDataType[];
extern WCHAR pszRegValueInterfaceType[];
extern WCHAR pszRegValueService[];
extern WCHAR pszRegValueDetectSignature[];
extern WCHAR pszRegValueClass[];
extern WCHAR pszRegValueClassGuid[];
extern WCHAR pszRegValueDriver[];
extern WCHAR pszRegValueInstanceIdentifier[];
extern WCHAR pszRegValueDuplicateOf[];
extern WCHAR pszRegValueCSConfigFlags[];
extern WCHAR pszRegValueConfigFlags[];
extern WCHAR pszRegValueDisableCount[];
extern WCHAR pszRegValueUnknownProblems[];
extern WCHAR pszRegValueCurrentConfig[];
extern WCHAR pszRegValueFriendlyName[];
extern WCHAR pszRegValueDockState[];
extern WCHAR pszRegValueDockingState[];
extern WCHAR pszRegValueEjectableDocks[];
extern WCHAR pszRegValuePreferenceOrder[];
extern WCHAR pszRegValueUserWaitInterval[];
extern WCHAR pszRegValuePhantom[];
extern WCHAR pszRegValueFirmwareIdentified[];
extern WCHAR pszRegValueFirmwareMember[];
extern WCHAR pszRegValueMfg[];
extern WCHAR pszRegValueCount[];
extern WCHAR pszRegValueBootConfig[];
extern WCHAR pszRegValueAllocConfig[];
extern WCHAR pszRegValueForcedConfig[];
extern WCHAR pszRegValueOverrideVector[];
extern WCHAR pszRegValueBasicVector[];
extern WCHAR pszRegValueFilteredVector[];
extern WCHAR pszRegValueActiveService[];
extern WCHAR pszRegValuePlugPlayServiceType[];
extern WCHAR pszRegValueLocationInformation[];
extern WCHAR pszRegValueCapabilities[];
extern WCHAR pszRegValueUiNumber[];
extern WCHAR pszRegValueUiNumberDescFormat[];
extern WCHAR pszRegValueRemovalPolicyOverride[];
extern WCHAR pszRegValueUpperFilters[];
extern WCHAR pszRegValueLowerFilters[];
extern WCHAR pszRegValueSecurity[];
extern WCHAR pszRegValueDevType[];
extern WCHAR pszRegValueExclusive[];
extern WCHAR pszRegValueCharacteristics[];
extern WCHAR pszRegValueMigrated[];
extern WCHAR pszRegValuePreservePreInstall[];

extern WCHAR pszControlFlags[];
extern WCHAR pszInteractiveInstall[];

extern WCHAR pszRegValuePhysicalDeviceObject[];
extern WCHAR pszRegRootEnumerator[];

extern WCHAR pszRegPathPolicies[];
extern WCHAR pszRegValueUndockWithoutLogon[];

extern WCHAR pszRegValueCustomPropertyCacheDate[];
extern WCHAR pszRegValueCustomPropertyHwIdKey[];
extern WCHAR pszRegValueLastUpdateTime[];

extern WCHAR pszRegKeyPlugPlayServiceParams[];
extern WCHAR pszRegValueDebugInstall[];
extern WCHAR pszRegValueDebugInstallCommand[];

#if DBG
extern WCHAR pszRegValueDebugFlags[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\srventry.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    srventry.c

Abstract:

    This module contains the main entry for the User-mode Plug-and-Play Service.
    It also contains the service control handler and service status update
    routines.

Author:

    Paula Tomlinson (paulat) 6-8-1995

Environment:

    User-mode only.

Revision History:

    8-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//

#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"

#include <svcsp.h>


//
// private prototypes
//

DWORD
PnPControlHandlerEx(
    IN  DWORD  dwControl,
    IN  DWORD  dwEventType,
    IN  LPVOID lpEventData,
    IN  LPVOID lpContext
    );

VOID
PnPServiceStatusUpdate(
    SERVICE_STATUS_HANDLE   hSvcHandle,
    DWORD    dwState,
    DWORD    dwCheckPoint,
    DWORD    dwExitCode
    );

RPC_STATUS
CALLBACK
PnPRpcIfCallback(
    RPC_IF_HANDLE* Interface,
    void* Context
    );


//
// global data
//

PSVCS_GLOBAL_DATA       PnPGlobalData = NULL;
HANDLE                  PnPGlobalSvcRefHandle = NULL;
DWORD                   CurrentServiceState = SERVICE_START_PENDING;
SERVICE_STATUS_HANDLE   hSvcHandle = 0;




VOID
SvcEntry_PlugPlay(
    DWORD               argc,
    LPWSTR              argv[],
    PSVCS_GLOBAL_DATA   SvcsGlobalData,
    HANDLE              SvcRefHandle
    )
/*++

Routine Description:

    This is the main routine for the User-mode Plug-and-Play Service. It
    registers itself as an RPC server and notifies the Service Controller
    of the PNP service control entry point.

Arguments:

    argc, argv     - Command-line arguments, not used.

    SvcsGlobalData - Global data for services running in services.exe that
                     contains function entry points and pipe name for
                     establishing an RPC server interface for this service.

    SvcRefHandle   - Service reference handle, not used.

Return Value:

    None.

Note:

    None.

--*/
{
    RPC_STATUS  RpcStatus;
    HANDLE      hThread;
    DWORD       ThreadID;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    //
    // Save the global data and service reference handle in global variables
    //
    PnPGlobalSvcRefHandle = SvcRefHandle;
    PnPGlobalData = SvcsGlobalData;

    //
    // Register our service ctrl handler
    //
    if ((hSvcHandle = RegisterServiceCtrlHandlerEx(L"PlugPlay",
                                                   (LPHANDLER_FUNCTION_EX)PnPControlHandlerEx,
                                                   NULL)) == 0) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RegisterServiceCtrlHandlerEx failed, error = %d\n",
                   GetLastError()));
        return;
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 1, 0);

    //
    // Create the Plug and Play security object, used to determine client access
    // to the PlugPlay server APIs.  Note that since the security object is used
    // by the PNP RPC interface security callback routine, it must be created
    // before the PNP RPC interface can be registered, below.
    //
    if (!CreatePlugPlaySecurityObject()) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: CreatePlugPlayManagerSecurityDescriptor failed!\n"));
        return;
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 2, 0);

    //
    // Register the PNP RPC interface, and specify a security callback routine
    // for the interface.  The callback will be called for all methods in the
    // interface, before RPC has marshalled any data to the stubs.  This allows
    // us to reject calls before RPC has allocated any memory from our process,
    // preventing possible DOS attacks by unauthorized clients.
    //
    // Few things to note about how we do this...
    //
    // First, NOTE that we previously used the RPC start/stop server routines
    // provided by SVCS_GLOBAL_DATA StartRpcServer/StopRpcServer, however those
    // did not allow for a security callback routine to be registered for the
    // interface (RpcServerRegisterIf).  Instead, we now register and unregister
    // the PNP RPC interface directly ourself, using RpcServerRegisterIfEx.
    //
    // Also NOTE that technically, we should also register the named pipe
    // endpoint and protocol sequence that our CFGMGR32 client uses to access
    // this interface ("ntsvcs", "ncacn_np") with the RPC runtime -- BUT because
    // we know that our server resides in the services.exe process along with
    // the SCM, and that the same endopint and protocol is also used by the SCM,
    // we know that it has already been registered for the process long before
    // our service is started, and will exist after our service is stopped.
    //
    // And also NOTE that technically, we should also make sure that the RPC
    // runtime is listening within the process when we register our interface,
    // and that it remains listening until we have unregistered out interface --
    // BUT because we're in services.exe, RPC should already be listening in the
    // process for the SCM before and after our service needs it to be (see
    // above).  We don't really need to start RPC listening ourselves either,
    // but there's no harm in registering our interface as "auto-listen", so
    // we'll do that anyways.
    //
    //   EXTRA NOTE -- This is really just a safeguard replacement for the
    //   refcounting for that would ordinarily have been done by the
    //   SVCS_GLOBAL_DATA StartRpcServer, StopRpcServer routines that the SCM
    //   and other servers in this process use to register their interfaces.
    //   These routines refcount the need to listen in the process by counting
    //   the number of interfaces in the process that have been registered by
    //   those routines.  Since we are now registering the PNP interface ourself
    //   (outside these routines), no refcounting is done for our interface.  By
    //   registering our interface as "auto-listen", We can make sure that the
    //   RPC runtime is listening when we register our interface, and that it
    //   remains listening until it is unregistered (regardless of the listening
    //   state that is started and stopped on behalf of the other servers in
    //   this process).
    //
    // ... Basically, because we share a process with the SCM, the only work we
    // really need to do ourselves is register our own interface.  If we ever
    // move the PlugPlay service outside of the services.exe process, we will
    // need to do everything else mentioned above ourselves, as well.
    //

    //
    // Even though we will register our interface as "auto-listen", verify that
    // this process is already listening via a previous call to RpcServerListen
    // (note that other "auto-listen" interfaces don't count).  This tells us
    // that the endpoint has already been registered, and RPC is already
    // listening, on behalf of some other server.
    //

    ASSERT(RpcMgmtIsServerListening(NULL) == RPC_S_OK);

    //
    // Register the PNP RPC interface.
    //

    RpcStatus =
        RpcServerRegisterIfEx(
            pnp_ServerIfHandle,
            NULL,
            NULL,
            RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
            RPC_C_LISTEN_MAX_CALLS_DEFAULT,
            PnPRpcIfCallback);

    if (RpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcServerRegisterIfEx failed with RpcStatus = %d\n",
                   RpcStatus));
        return;
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 3, 0);

    //
    // Initialize pnp manager
    //
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)InitializePnPManager,
                           NULL,
                           0,
                           &ThreadID);

    if (hThread != NULL) {
        CloseHandle(hThread);
    }

    //
    // Notify Service Controller that we're now running
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_RUNNING, 0, 0);

    //
    // Service initialization is complete.
    //
    return;

} // SvcEntry_PlugPlay



DWORD
PnPControlHandlerEx(
    IN  DWORD  dwControl,
    IN  DWORD  dwEventType,
    IN  LPVOID lpEventData,
    IN  LPVOID lpContext
    )
/*++

Routine Description:

    This is the service control handler of the Plug-and-Play service.

Arguments:

    dwControl   - The requested control code.

    dwEventType - The type of event that has occurred.

    lpEventData - Additional device information, if required.

    lpContext   - User-defined data, not used.

Return Value:

    Returns NO_ERROR if sucessful, otherwise returns an error code describing
    the problem.

--*/
{
    RPC_STATUS  RpcStatus;

    UNREFERENCED_PARAMETER(lpContext);

    switch (dwControl) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            //
            // If we aren't already in the middle of a stop, then
            // stop the PNP service now and perform the necessary cleanup.
            //
            if (CurrentServiceState != SERVICE_STOPPED &&
                CurrentServiceState != SERVICE_STOP_PENDING) {

                //
                // Notify Service Controller that we're stopping
                //
                PnPServiceStatusUpdate(hSvcHandle, SERVICE_STOP_PENDING, 1, 0);

                //
                // Unregister the RPC server interface registered by our service
                // entry point, do not wait for outstanding calls to complete
                // before unregistering the interface.
                //
                RpcStatus =
                    RpcServerUnregisterIf(
                        pnp_ServerIfHandle,
                        NULL, 0);

                if (RpcStatus != RPC_S_OK) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: RpcServerUnregisterIf failed with RpcStatus = %d\n",
                               RpcStatus));
                }

                //
                // Destroy the Plug and Play security object
                //
                DestroyPlugPlaySecurityObject();

                //
                // Notify Service Controller that we've now stopped
                //
                PnPServiceStatusUpdate(hSvcHandle, SERVICE_STOPPED, 0, 0);
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            //
            // Request to immediately notify Service Controller of
            // current status
            //
            PnPServiceStatusUpdate(hSvcHandle, CurrentServiceState, 0, 0);
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:
            //
            // Session change notification.
            //
            SessionNotificationHandler(dwEventType, (PWTSSESSION_NOTIFICATION)lpEventData);
            break;

        default:
            //
            // No special handling for any other service controls.
            //
            break;
    }

    return NO_ERROR;

} // PnPControlHandlerEx



VOID
PnPServiceStatusUpdate(
      SERVICE_STATUS_HANDLE   hSvcHandle,
      DWORD    dwState,
      DWORD    dwCheckPoint,
      DWORD    dwExitCode
      )
/*++

Routine Description:

    This routine notifies the Service Controller of the current status of the
    Plug-and-Play service.

Arguments:

    hSvcHandle   - Supplies the service status handle for the Plug-and-Play service.

    dwState      - Specifies the current state of the service to report.

    dwCheckPoint - Specifies an intermediate checkpoint for operations during
                   which the state is pending.

    dwExitCode   - Specifies a service specific error code.

Return Value:

    None.

Note:

    This routine also updates the set of controls accepted by the service.

    The PlugPlay service currently accepts the following controls when the
    service is running:

      SERVICE_CONTROL_SHUTDOWN      - the system is shutting down.

      SERVICE_CONTROL_SESSIONCHANGE - the state of some remote or console session
                                      has changed.

--*/
{
   SERVICE_STATUS    SvcStatus;

   SvcStatus.dwServiceType = SERVICE_WIN32;
   SvcStatus.dwCurrentState = CurrentServiceState = dwState;
   SvcStatus.dwCheckPoint = dwCheckPoint;

   if (dwState == SERVICE_RUNNING) {
      SvcStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
   } else {
      SvcStatus.dwControlsAccepted = 0;
   }

   if ((dwState == SERVICE_START_PENDING) ||
       (dwState == SERVICE_STOP_PENDING)) {
      SvcStatus.dwWaitHint = 45000;          // 45 seconds
   } else {
      SvcStatus.dwWaitHint = 0;
   }

   if (dwExitCode != 0) {
      SvcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
      SvcStatus.dwServiceSpecificExitCode = dwExitCode;
   } else {
      SvcStatus.dwWin32ExitCode = NO_ERROR;
      SvcStatus.dwServiceSpecificExitCode = 0;
   }

   SetServiceStatus(hSvcHandle, &SvcStatus);

   return;

} // PnPServiceStatusUpdate



RPC_STATUS
CALLBACK
PnPRpcIfCallback(
    RPC_IF_HANDLE* Interface,
    void* Context
    )

/*++

Routine Description:

    RPC interface callback function for authenticating clients of the Plug and
    Play RPC server.

Arguments:

    Interface - Supplies the UUID and version of the interface.

    Context   - Supplies a server binding handle representing the client

Return Value:

    RPC_S_OK if an interface method can be called, RPC_S_ACCESS_DENIED if the
    interface method should not be called.

--*/

{
    handle_t    hBinding;
    RPC_STATUS  RpcStatus = RPC_S_OK;

    UNREFERENCED_PARAMETER(Interface);

    //
    // The Context supplied to the interface callback routine is an RPC binding
    // handle.
    //
    hBinding = (handle_t)Context;

    //
    // Make sure that the provided RPC binding handle is not NULL.
    //
    // The RPC interface routines sometimes get called directly directly by the
    // SCM and other internal routines, using a NULL binding handle.  This
    // security callback routine should only get called in the context of an RPC
    // call, so the supplied binding handle should never be NULL.
    //
    ASSERT(hBinding != NULL);

    //
    // Verify client basic "read" access for all APIs.
    //
    if (!VerifyClientAccess(hBinding,
                            PLUGPLAY_READ)) {
        RpcStatus = RPC_S_ACCESS_DENIED;
        goto Clean0;
    }

  Clean0:

    return RpcStatus;

} // PnPRpcIfCallback





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\acpitabl.h ===
/*****************************************************************************
 *
 *      (C) Copyright MICROSOFT Corp., 1996
 *
 *      Title:          ACPITABL.H --- Definitions and descriptions of the various BIOS supplied ACPI tables.
 *
 *      Version:        1.00
 *
 *      Date:           6-17-96
 *
 *      Author:         Jason Clark (jasoncl)
 *
 *------------------------------------------------------------------------------
 *
 *      Change log:
 *
 *         DATE     REV DESCRIPTION
 *      ----------- --- -----------------------------------------------------------
 *
 ****************************************************************************/

//      These map to bios provided structures, so turn on 1 byte packing

#ifndef _ACPITABL_H
#define _ACPITABL_H

#ifdef ASL_ASSEMBLER
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS ULONGLONG
#define UNALIGNED
#endif

#include <pshpack1.h>

// Generic Register Address Structure

typedef struct _GEN_ADDR {
    UCHAR               AddressSpaceID;
    UCHAR               BitWidth;
    UCHAR               BitOffset;
    UCHAR               Reserved;
    PHYSICAL_ADDRESS    Address;
} GEN_ADDR, *PGEN_ADDR;

#define RSDP_SIGNATURE 0x2052545020445352       // "RSD PTR "

typedef struct  _RSDP {     // Root System Description Table Pointer Structure
    ULONGLONG       Signature;  // 8 UCHAR table signature 'RSD PTR '
    UCHAR           Checksum;   // checksum for first 20 bytes of table (entire ACPI 1.0 table)
    UCHAR           OEMID[6];   //      String that uniquely ID's the OEM
    UCHAR           Revision;   // 0 - ACPI 1.0;  2 - ACPI 2.0
    ULONG           RsdtAddress;// physical address of Root System Description Table  (1.0 table ended here)
    ULONG           Length;     // Length of the table in bytes
    PHYSICAL_ADDRESS XsdtAddress;// physical address of XSDT
    UCHAR           XChecksum;  // checksum for entire table
    UCHAR           Reserved[3];
} RSDP, *PRSDP;

#define RSDP_SEARCH_RANGE_BEGIN         0xE0000         // physical address where we begin searching for the RSDP
#define RSDP_SEARCH_RANGE_END           0xFFFFF
#define RSDP_SEARCH_RANGE_LENGTH        (RSDP_SEARCH_RANGE_END-RSDP_SEARCH_RANGE_BEGIN+1)
#define RSDP_SEARCH_INTERVAL            16      // search on 16 byte boundaries


typedef struct _DESCRIPTION_HEADER      {       // Header structure appears at the beginning of each ACPI table

ULONG   Signature;                      //      Signature used to identify the type of table
ULONG   Length;                         //      Length of entire table including the DESCRIPTION_HEADER
UCHAR   Revision;                       //      Minor version of ACPI spec to which this table conforms
UCHAR   Checksum;                       //      sum of all bytes in the entire TABLE should = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   OEMTableID[8];                  //      String that uniquely ID's this table (used for table patching and replacement).
ULONG   OEMRevision;                    //      OEM supplied table revision number.  Bigger number = newer table.
UCHAR   CreatorID[4];                   //      Vendor ID of utility which created this table.
ULONG   CreatorRev;                     //      Revision of utility that created the table.
}       DESCRIPTION_HEADER;
typedef DESCRIPTION_HEADER      *PDESCRIPTION_HEADER;

// Header constants

#define ACPI_MAX_SIGNATURE       4
#define ACPI_MAX_OEM_ID          6
#define ACPI_MAX_TABLE_ID        8
#define ACPI_MAX_TABLE_STRINGS   ACPI_MAX_SIGNATURE + ACPI_MAX_OEM_ID + ACPI_MAX_TABLE_ID

#define FACS_SIGNATURE  0x53434146      // "FACS"

typedef enum {
    AcpiGenericSpaceMemory = 0,
    AcpiGenericSpaceIO,
    AcpiGenericSpacePciConfig,
    AcpiGenericSpaceEC,
    AcpiGenericSpaceSMBus,
    AcpiGenericSpaceFixedFunction = 0x7F
} ACPI_GENERIC_ADDRESS_TYPE, *PACPI_GENERIC_ADDRESS_TYPE;

typedef struct _FACS    {       // Firmware ACPI Control Structure.  Note that this table does not have a header, it is pointed to by the FADT
    ULONG           Signature;      //      'FACS'
    ULONG           Length;         //      Length of entire firmware ACPI control structure (must be 64 bytes or larger)
    ULONG           HardwareSignature;
    ULONG           pFirmwareWakingVector;  // physical address of location where the OS needs to put the firmware waking vector
    ULONG           GlobalLock;     // 32 bit structure used for sharing Embedded Controller
    ULONG           Flags;
    PHYSICAL_ADDRESS x_FirmwareWakingVector; // 64-bit capable firmware vector
    UCHAR           version;
    UCHAR           Reserved[31];
} FACS, *PFACS;

// FACS.GlobalLock bit field definitions

#define         GL_PENDING_BIT          0x00
#define         GL_PENDING                      (1 << GL_PENDING_BIT)

#define         GL_OWNER_BIT            0x01
#define         GL_OWNER                        (1 << GL_OWNER_BIT)

#define GL_NON_RESERVED_BITS_MASK       (GL_PENDING+GL_OWNED)

// FACS Flags definitions

#define         FACS_S4BIOS_SUPPORTED_BIT   0   // flag indicates whether or not the BIOS will save/restore memory around S4
#define         FACS_S4BIOS_SUPPORTED       (1 << FACS_S4BIOS_SUPPORTED_BIT)


#define FADT_SIGNATURE  0x50434146      // "FACP"

typedef struct _FADT    {               // Fixed ACPI description table

DESCRIPTION_HEADER      Header;

ULONG           facs;                   // Physical address of the Firmware ACPI Control Structure
ULONG           dsdt;                   // Physical address of the Differentiated System Description Table
UCHAR           int_model;              // System's Interrupt mode, 0=Dual PIC, 1=Multiple APIC, >1 reserved
UCHAR           pm_profile;             // System's preferred power profile
USHORT          sci_int_vector;         // Vector of SCI interrupt.
ULONG           smi_cmd_io_port;        // Address in System I/O Space of the SMI Command port, used to enable and disable ACPI.
UCHAR           acpi_on_value;          // Value out'd to smi_cmd_port to activate ACPI
UCHAR           acpi_off_value;         // Value out'd to smi_cmd_port to deactivate ACPI
UCHAR           s4bios_req;             // Value to write to SMI_CMD to enter the S4 state.
UCHAR           pstate_control;         // Value to write to SMI_CMD to assume control of processor performance states
ULONG           pm1a_evt_blk_io_port;   // Address in System I/O Space of the PM1a_EVT_BLK register block
ULONG           pm1b_evt_blk_io_port;   // Address in System I/O Space of the PM1b_EVT_BLK register block
ULONG           pm1a_ctrl_blk_io_port;  // Address in System I/O Space of the PM1a_CNT_BLK register block
ULONG           pm1b_ctrl_blk_io_port;  // Address in System I/O Space of the PM1b_CNT_BLK register block
ULONG           pm2_ctrl_blk_io_port;   // Address in System I/O Space of the PM2_CNT_BLK register block
ULONG           pm_tmr_blk_io_port;     // Address in System I/O Space of the PM_TMR register block
ULONG           gp0_blk_io_port;        // Address in System I/O Space of the GP0 register block
ULONG           gp1_blk_io_port;        // Address in System I/O Space of the GP1 register block
UCHAR           pm1_evt_len;            // number of bytes decoded for PM1_BLK (must be >= 4)
UCHAR           pm1_ctrl_len;           // number of bytes decoded for PM1_CNT (must be >= 2)
UCHAR           pm2_ctrl_len;           // number of bytes decoded for PM1a_CNT (must be >= 1)
UCHAR           pm_tmr_len;             // number of bytes decoded for PM_TMR (must be >= 4)
UCHAR           gp0_blk_len;            // number of bytes decoded for GP0_BLK (must be multiple of 2)
UCHAR           gp1_blk_len;            // number of bytes decoded for GP1_BLK (must be multiple of 2)
UCHAR           gp1_base;               // index at which GP1 based events start
UCHAR           cstate_control;         // Value to write to SMI_CMD to assume control of _CST states
USHORT          lvl2_latency;           // Worst case latency in microseconds required to enter and leave the C2 processor state
USHORT          lvl3_latency;           // Worst case latency in microseconds required to enter and leave the C3 processor state
USHORT          flush_size;             // Ignored if WBINVD flag is 1 -- indicates size of memory read to flush dirty lines from
                                        //      any processors memory caches. A size of zero indicates this is not supported.
USHORT          flush_stride;           // Ignored if WBINVD flag is 1 -- the memory stride width, in bytes, to perform reads to flush
                                        //      the processor's memory caches.
UCHAR           duty_offset;            // zero based index of where the processor's duty cycle setting is within the processor's P_CNT register.
UCHAR           duty_width;             // bit width of the processor's duty cycle setting value in the P_CNT register.
                                        //      a value of zero indicates that processor duty cycle is not supported
UCHAR           day_alarm_index;
UCHAR           month_alarm_index;
UCHAR           century_alarm_index;
USHORT          boot_arch;
UCHAR           reserved3[1];
ULONG           flags;                  // This is the last field if the table Revision is 1
GEN_ADDR        reset_reg;
UCHAR           reset_val;              // This is the last field if the table Revision is 2
UCHAR           reserved4[3];
PHYSICAL_ADDRESS x_firmware_ctrl;
PHYSICAL_ADDRESS x_dsdt;
GEN_ADDR        x_pm1a_evt_blk;
GEN_ADDR        x_pm1b_evt_blk;
GEN_ADDR        x_pm1a_ctrl_blk;
GEN_ADDR        x_pm1b_ctrl_blk;
GEN_ADDR        x_pm2_ctrl_blk;
GEN_ADDR        x_pm_tmr_blk;
GEN_ADDR        x_gp0_blk;
GEN_ADDR        x_gp1_blk;              // This is the last field if the table Revision is 3
} FADT, *PFADT;

#define FADT_REV_1_SIZE   (FIELD_OFFSET(FADT, flags) + sizeof(ULONG))
#define FADT_REV_2_SIZE   (FIELD_OFFSET(FADT, reset_val) + sizeof(UCHAR))
#define FADT_REV_3_SIZE   (FIELD_OFFSET(FADT, x_gp1_blk) + sizeof(GEN_ADDR))


//
// Static Resource Affinity Table
//
// This table describes the static topology of a ccNUMA machine.
//

#define ACPI_SRAT_SIGNATURE  0x54415253 // "SRAT"

typedef struct _ACPI_SRAT {
    DESCRIPTION_HEADER  Header;
    ULONG               TableRevision;
    ULONG               Reserved[2];
} ACPI_SRAT, *PACPI_SRAT;

typedef struct _ACPI_SRAT_ENTRY {
    UCHAR                       Type;
    UCHAR                       Length;
    UCHAR                       ProximityDomain;
    union {
        struct {
            UCHAR               ApicId;
            struct {
                ULONG           Enabled:1;
                ULONG           Reserved:31;
            }                   Flags;
            UCHAR               SApicEid;
            UCHAR               Reserved[7];
        } ApicAffinity;
        struct {
            UCHAR               Reserved[5];
            PHYSICAL_ADDRESS    Base;
            ULONGLONG           Length;
            ULONG               Reserved2;
            struct {
                ULONG           Enabled:1;
                ULONG           HotPlug:1;
                ULONG           Reserved:30;
            }                   Flags;
            UCHAR               Reserved3[8];
        } MemoryAffinity;
    };
} ACPI_SRAT_ENTRY, *PACPI_SRAT_ENTRY;

typedef enum {
    SratProcessorLocalAPIC,
    SratMemory
} SRAT_ENTRY_TYPE;


#ifdef _IA64_
// FLUSH WORKS IS FOR IA64
#define         FLUSH_WORKS_BIT           0
#define         FLUSH_WORKS               (1 << FLUSH_WORKS_BIT)
#endif // IA64

// definition of FADT.flags bits

// this one bit flag indicates whether or not the WBINVD instruction works properly,if this bit is not set we can not use S2, S3 states, or
// C3 on MP machines
#define         WRITEBACKINVALIDATE_WORKS_BIT           0
#define         WRITEBACKINVALIDATE_WORKS               (1 << WRITEBACKINVALIDATE_WORKS_BIT)

//  this flag indicates if wbinvd works EXCEPT that it does not invalidate the cache
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT   1
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE       (1 << WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT)

//  this flag indicates that the C1 state is supported on all processors.
#define         SYSTEM_SUPPORTS_C1_BIT                  2
#define         SYSTEM_SUPPORTS_C1                      (1 << SYSTEM_SUPPORTS_C1_BIT)

// this one bit flag indicates whether support for the C2 state is restricted to uniprocessor machines
#define         P_LVL2_UP_ONLY_BIT                      3
#define         P_LVL2_UP_ONLY                          (1 << P_LVL2_UP_ONLY_BIT)

//      this bit indicates whether the PWR button is treated as a fix feature (0) or a generic feature (1)
#define         PWR_BUTTON_GENERIC_BIT                  4
#define         PWR_BUTTON_GENERIC                      (1 << PWR_BUTTON_GENERIC_BIT)

#define         SLEEP_BUTTON_GENERIC_BIT                5
#define         SLEEP_BUTTON_GENERIC                    (1 << SLEEP_BUTTON_GENERIC_BIT)

//      this bit indicates whether the RTC wakeup status is reported in fix register space (0) or not (1)
#define         RTC_WAKE_GENERIC_BIT                    6
#define         RTC_WAKE_GENERIC                        (1 << RTC_WAKE_GENERIC_BIT)

#define         RTC_WAKE_FROM_S4_BIT                    7
#define         RTC_WAKE_FROM_S4                        (1 << RTC_WAKE_FROM_S4_BIT)

// This bit indicates whether the machine implements a 24 or 32 bit timer.
#define         TMR_VAL_EXT_BIT                         8
#define         TMR_VAL_EXT                             (1 << TMR_VAL_EXT_BIT)

// This bit indicates whether the machine supports docking
#define         DCK_CAP_BIT                             9
#define         DCK_CAP                                 (1 << DCK_CAP_BIT)

// This bit indicates whether the machine supports reset
#define         RESET_CAP_BIT                           10
#define         RESET_CAP                               (1 << RESET_CAP_BIT)

// This bit indicates whether the machine case can be opened
#define         SEALED_CASE_BIT                         11
#define         SEALED_CASE_CAP                         (1 << SEALED_CASE_BIT)

// This bit indicates whether the machine has no video
#define         HEADLESS_BIT                            12
#define         HEADLESS_CAP                            (1 << HEADLESS_BIT)

//      spec defines maximum entry/exit latency values for C2 and C3, if the FADT indicates that these values are
//      exceeded then we do not use that C state.

#define         C2_MAX_LATENCY  100
#define         C3_MAX_LATENCY  1000

//
// Definition of FADT.boot_arch flags
//

#define LEGACY_DEVICES  1
#define I8042           2


#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY   1
#endif

// Multiple APIC description table

typedef struct _MAPIC   {

DESCRIPTION_HEADER  Header;
ULONG               LocalAPICAddress;   // Physical Address at which each processor can access its local APIC
ULONG               Flags;
ULONG               APICTables[ANYSIZE_ARRAY];  // A list of APIC tables.

}       MAPIC;

typedef MAPIC *PMAPIC;

// Multiple APIC structure flags

#define PCAT_COMPAT_BIT 0   // indicates that the system also has a dual 8259 pic setup.
#define PCAT_COMPAT     (1 << PCAT_COMPAT_BIT)

// APIC Structure Types
#define PROCESSOR_LOCAL_APIC                0
#define IO_APIC                             1
#define ISA_VECTOR_OVERRIDE                 2
#define IO_NMI_SOURCE                       3
#define LOCAL_NMI_SOURCE                    4
#define ADDRESS_EXTENSION_STRUCTURE         5
#define IO_SAPIC                            6
#define LOCAL_SAPIC                         7
#define PLATFORM_INTERRUPT_SOURCE           8

#define PROCESSOR_LOCAL_APIC_LENGTH         8
#define IO_APIC_LENGTH                      12
#define ISA_VECTOR_OVERRIDE_LENGTH          10

#define IO_NMI_SOURCE_LENGTH                8
#define LOCAL_NMI_SOURCE_LENGTH             6
#define PLATFORM_INTERRUPT_SOURCE_LENGTH    16
#define IO_SAPIC_LENGTH                     16
#define PROCESSOR_LOCAL_SAPIC_LENGTH        12

// Platform Interrupt Types
#define PLATFORM_INT_PMI  1
#define PLATFORM_INT_INIT 2
#define PLATFORM_INT_CPE  3

// These defines come from the MPS 1.4 spec, section 4.3.4 and they are referenced as
// such in the ACPI spec.
#define PO_BITS                     3
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0
#define EL_BITS                     0xc
#define EL_BIT_SHIFT                2
#define EL_EDGE_TRIGGERED           4
#define EL_LEVEL_TRIGGERED          0xc
#define EL_CONFORMS_WITH_BUS        0

// The shared beginning info in all APIC Structures

typedef struct _APICTABLE {
   UCHAR Type;
   UCHAR Length;
} APICTABLE;

typedef APICTABLE UNALIGNED *PAPICTABLE;

typedef struct _PROCLOCALAPIC   {

    UCHAR   Type;   // should be zero to identify a ProcessorLocalAPIC structure
    UCHAR   Length; // better be 8
    UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
                                // operator.
    UCHAR   APICID; //  The processor's local APIC ID.
    ULONG   Flags;

} PROCLOCALAPIC;

typedef PROCLOCALAPIC UNALIGNED *PPROCLOCALAPIC;

// Processor Local APIC Flags
#define PLAF_ENABLED_BIT    0
#define PLAF_ENABLED        (1 << PLAF_ENABLED_BIT)

typedef struct _IOAPIC  {

    UCHAR   Type;
    UCHAR   Length; // better be 12
    UCHAR   IOAPICID;
    UCHAR   Reserved;
    ULONG   IOAPICAddress; // Physical address at which this IO APIC resides.
    ULONG   SystemVectorBase; // system interrupt vector index for this APIC

} IOAPIC;

typedef IOAPIC UNALIGNED *PIOAPIC;

// Interrupt Source Override
typedef struct _ISA_VECTOR {
    UCHAR   Type;                           // Must be 2
    UCHAR   Length;                         // Must be 10
    UCHAR   Bus;                            // Must be 0
    UCHAR   Source;                         // BusRelative IRQ
    ULONG   GlobalSystemInterruptVector;    // Global IRQ
    USHORT  Flags;                          // Same as MPS INTI Flags
} ISA_VECTOR;

typedef ISA_VECTOR UNALIGNED *PISA_VECTOR;

// I/O Non-Maskable Source Interrupt
typedef struct _IO_NMISOURCE {
    UCHAR   Type;                           // must be 3
    UCHAR   Length;                         // better be 8
    USHORT  Flags;                          // Same as MPS INTI Flags
    ULONG   GlobalSystemInterruptVector;    // Interrupt connected to NMI
} IO_NMISOURCE;

typedef IO_NMISOURCE UNALIGNED *PIO_NMISOURCE;

// Local Non-Maskable Interrupt Source
typedef struct _LOCAL_NMISOURCE {
    UCHAR   Type;                           // must be 4
    UCHAR   Length;                         // better be 6
    UCHAR   ProcessorID;                    // which processor?  0xff means all
    USHORT  Flags;
    UCHAR   LINTIN;                         // which LINTIN# signal on the processor
} LOCAL_NMISOURCE;

typedef LOCAL_NMISOURCE UNALIGNED *PLOCAL_NMISOURCE;

typedef struct _PROCLOCALSAPIC   {
    UCHAR   Type;               // PROCESSOR_LOCAL_SAPIC
    UCHAR   Length;             // PROCESSOR_LOCAL_SAPIC_LENGTH
                                //     operator.
    UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
    UCHAR   APICID;             //  The processor's local APIC ID.
    UCHAR   APICEID;            //  The processor's local APIC EID.
    UCHAR   Reserved[3];
    ULONG   Flags;
} PROCLOCALSAPIC;

typedef PROCLOCALSAPIC UNALIGNED *PPROCLOCALSAPIC;

typedef struct _IOSAPIC  {
    UCHAR   Type;               // IO_SAPIC
    UCHAR   Length;             // IO_SAPIC_LENGTH
    USHORT  Reserved;
    ULONG   SystemVectorBase;   // system interrupt vector index for this SAPIC
    ULONG_PTR  IOSAPICAddress;   // 64-bit Physical address at which this IO APIC resides.
} IOSAPIC;

typedef IOSAPIC UNALIGNED *PIOSAPIC;

typedef struct _PLATFORM_INTERRUPT {
    UCHAR   Type;               // PLATFORM_INTERRUPT_SOURCE
    UCHAR   Length;             // PLATFORM_INTERRUPT_SOURCE_LENGTH
    USHORT  Flags;              // Same as MPS INTI Flags
    UCHAR   InterruptType;
    UCHAR   APICID;
    UCHAR   ACPIEID;
    UCHAR   IOSAPICVector;
    ULONG   GlobalVector;
    ULONG   Reserved;
} PLATFORM_INTERRUPT;

typedef PLATFORM_INTERRUPT UNALIGNED *PPLATFORM_INTERRUPT;

//
// Smart Battery
//

typedef struct _SMARTBATTTABLE   {

DESCRIPTION_HEADER  Header;
ULONG   WarningEnergyLevel; // mWh at which the OEM suggests we warn the user that the battery is getting low.
ULONG   LowEnergyLevel;     // mWh at which the OEM suggests we put the machine into a sleep state.
ULONG   CriticalEnergyLevel; // mWH at which the OEM suggests we do an emergency shutdown.

}       SMARTBATTTABLE;

typedef SMARTBATTTABLE *PSMARTBATTTABLE;

#define RSDT_SIGNATURE  0x54445352      // "RSDT"
#define XSDT_SIGNATURE  0x54445358      // "XSDT"

typedef struct _RSDT_32    {       // Root System Description Table

DESCRIPTION_HEADER      Header;
ULONG   Tables[ANYSIZE_ARRAY];     // The structure contains an n length array of physical addresses each of which point to another table.
}       RSDT_32;

typedef struct _RSDT_64    {       // Root System Description Table
    DESCRIPTION_HEADER      Header;
    ULONG                   Reserved;               // 4 bytes reserved as per 64 bit extensions to ACPI spec v0.7
    ULONG_PTR               Tables[ANYSIZE_ARRAY];  // The structure contains an n length array of physical addresses each of which point to another table.
} RSDT_64;

#ifdef _IA64_ // XXTF
typedef RSDT_64 RSDT;
#else
typedef RSDT_32 RSDT;
#endif // _IA64_ XXTF

typedef RSDT    *PRSDT;

typedef struct _XSDT {
    DESCRIPTION_HEADER  Header;
    UNALIGNED PHYSICAL_ADDRESS Tables[ANYSIZE_ARRAY];
} XSDT, *PXSDT;


// The below macro uses the min macro to protect against the case where we are running on machine which is compliant with
// a spec prior to .99.  If you had a .92 compliant header and one table pointer we would end of subtracting 32-36 resulting
// in a really big number and hence we would think we had lots and lots of tables...  Using the min macro we end up subtracting
// the length-length getting zero which will be harmless and cause us to fail to load (with a red screen on Win9x) which is
// the best we can do in this case.

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

//
// BUGBUG John Vert (jvert) 4/26/2000
//   alpha64 machines are still running with 32-bit RSDTs. Once that support is dropped we can
//   remove this hack.
//
#ifdef _IA64_
#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(ULONG_PTR)
#else
#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(ULONG)
#endif
#define NumTableEntriesFromXSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(PHYSICAL_ADDRESS)


#define APIC_SIGNATURE  0x43495041      // "APIC"
#define SPIC_SIGNATURE  0x43495053      // "SPIC"  = SAPIC (IA64 extensions to ACPI requirement)
#define DSDT_SIGNATURE  0x54445344      // "DSDT"
#define SSDT_SIGNATURE  0x54445353      // "SSDT"
#define PSDT_SIGNATURE  0x54445350      // "PSDT"
#define SBST_SIGNATURE  0x54534253      // "SBST"
#define DBGP_SIGNATURE  0x50474244      // "DBGP"
#define WDTT_SIGNATURE  0x54524457      // "WDRT"

typedef struct _DSDT    {       // Differentiated System Description Table

DESCRIPTION_HEADER      Header;
UCHAR                   DiffDefBlock[ANYSIZE_ARRAY];    // this is the AML describing the base system.

}       DSDT;

typedef DSDT            *PDSDT;

//      Resume normal structure packing

#include <poppack.h>

typedef struct _PROC_LOCAL_APIC {
    UCHAR   NamespaceProcID;
    UCHAR   ApicID;
    UCHAR   NtNumber;
    BOOLEAN Started;
    BOOLEAN Enumerated;
} PROC_LOCAL_APIC, *PPROC_LOCAL_APIC;

extern PROC_LOCAL_APIC HalpProcLocalApicTable[];

//
// Debug Port Table
//
#pragma pack(1)
typedef struct _DEBUG_PORT_TABLE {

    DESCRIPTION_HEADER  Header;
    UCHAR               InterfaceType;          // Type of registry interface (0 = full 16550 interface)
    UCHAR               Reserved0[3];           // should be 0
    GEN_ADDR            BaseAddress;            // Base address of the Debug Port register set
                                                // described using the Generic Register Address
                                                // Structure.
                                                // 0   - console redirection disabled.
                                                // e.g. COM1 (0x3F8) would be 0x1800000003F8
                                                //      COM2 (Ox2F8) would be 0x1800000002F8


} DEBUG_PORT_TABLE, *PDEBUG_PORT_TABLE;
#pragma pack()



#pragma pack(1)
typedef struct _SERIAL_PORT_REDIRECTION_TABLE {

    DESCRIPTION_HEADER  Header;
    UCHAR               InterfaceType;          // Type of registry interface (0 = full 16550 interface)
    UCHAR               Reserved0[3];           // should be 0
    GEN_ADDR            BaseAddress;            // Base address of the Debug Port register set
                                                // described using the Generic Register Address
                                                // Structure.
                                                // 0   - console redirection disabled.
                                                // e.g. COM1 (0x3F8) would be 0x1800000003F8
                                                //      COM2 (Ox2F8) would be 0x1800000002F8


    UCHAR               InterruptType;          // Interrupt type(s) used by the UART.
                                                // bit 0 = PC-AT-compatible 8259 IRQ interrupt.
                                                // bit 1 = I/O APIC interrupt (Global System INterrupt)
                                                // bit 2 = I/O SAPIC interrupt (Global System Interrupt) (IRQ)
                                                // bit 3:7 = reserved (and must be 0)
                                                // Note: bit == 1 indicates support, bit == 0 indicates no support.
                                                //
                                                // Platforms with both a dual 8259 and an I/O APIC or I/O SAPIC
                                                // must set the IRQ bit (bit 0) and the corresponding Global
                                                // system interrupt bit.  E.g. a system that supported 8259 and
                                                // SAPIC would be 0x5.

    UCHAR               Irq;                    // 0  = none
                                                // 2  = 2
                                                // 3  = 3
                                                // ...
                                                // 16 = 16
                                                // 1, 17-255 reserved

    ULONG               GlobalSystemInterruptVector;
                                                // The I/O APIC or I/O SAPIC Global System Interrupt used
                                                // by the UART.Valid only if Bit[1] or Bit[2] of the
                                                // Interrupt Type field is set.

    UCHAR               BaudRate;               // Baudrate for BIOS redirection
                                                // 3 = 9600
                                                // 4 = 19200
                                                // 6 = 57600
                                                // 7 = 115200
                                                // 0-2,5, 8-255 reserved

    UCHAR               Parity;                 // 0 = no parity
                                                // 1-255 reserved

    UCHAR               StopBits;               // 1 = 1 stop bit
                                                // 0, 2-255 = reserved

    UCHAR               FlowControl;            // 0 = Hadware Flow Control
                                                // 1 - 255 = reserved.

    UCHAR               TerminalType;           // The terminal protocol the BIOS was using for
                                                // console redirection
                                                // 0 = VT100
                                                // 1 = Extended VT100
                                                // 2-255 = reserved

    UCHAR               Language;               // Language which the BIOS was redirecting
                                                // 0 = US Western English (standard ASCII)

    USHORT              PciDeviceId;            // Designates device ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    USHORT              PciVendorId;            // Designates vendor ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    UCHAR               PciBusNumber;           // Designates which PCI system bus the PCI device
                                                // resides on.

    UCHAR               PciSlotNumber;          // Designates which PCI slot the PCI device
                                                // resides in.

    UCHAR               PciFunctionNumber;      // Which PCI function number describes the UART.

    ULONG               PciFlags;               // PCI compatibility flags bitmask.  Should be zero
                                                // by default.
                                                // 0x1 indicates operating system should NOT suppress
                                                // PnP device enumeration or disable power management
                                                // for this device.
                                                // bits 1-31 reserved.

    UCHAR               PciSegment;             // PCI segment number.  For systems w/ < 255 PCI
                                                // busses, this number must be 0.

    UCHAR               Reserved1[4];           // should be 0

} SERIAL_PORT_REDIRECTION_TABLE, *PSERIAL_PORT_REDIRECTION_TABLE;
#pragma pack()

typedef struct _WATCHDOG_TIMER_RESOURCE_TABLE {

    DESCRIPTION_HEADER  Header;

    GEN_ADDR            ControlRegisterAddress; //
    GEN_ADDR            CountRegisterAddress;   //

    USHORT              PciDeviceId;            // Designates device ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    USHORT              PciVendorId;            // Designates vendor ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    UCHAR               PciBusNumber;           // Designates which PCI system bus the PCI device
                                                // resides on.

    UCHAR               PciSlotNumber;          // Designates which PCI slot the PCI device
                                                // resides in.

    UCHAR               PciFunctionNumber;      // Which PCI function number describes the UART.

    UCHAR               PciSegment;             //
#if 0
    ULONG               Filler;                 // Remove this when we get the new BIOS
#endif
    USHORT              MaxCount;               //

    UCHAR               Units;                  //

} WATCHDOG_TIMER_RESOURCE_TABLE, *PWATCHDOG_TIMER_RESOURCE_TABLE;
#pragma pack()

//
// BOOT Table -- based on Simple Boot Flag Specification 1.0
//

typedef struct _BOOT_TABLE {

    DESCRIPTION_HEADER  Header;
    UCHAR               CMOSIndex;
    UCHAR               Reserved[3];
} BOOT_TABLE, *PBOOT_TABLE;

#define BOOT_SIGNATURE  0x544f4f42 // 'BOOT'

//
// Bits in the Boot Register
//

//
// Set by OS to indicate that the bios need only configure boot devices
//

#define SBF_PNPOS_BIT       0
#define SBF_PNPOS           (1 << SBF_PNPOS_BIT)

//
// Set by BIOS to indicate beginning of boot, cleared by OS to indicate a successful boot
//

#define SBF_BOOTING_BIT     1
#define SBF_BOOTING         (1 << SBF_BOOTING_BIT)

//
// Set by BIOS to indicate a diagnostic boot
//

#define SBF_DIAG_BIT        2
#define SBF_DIAG            (1 << SBF_DIAG_BIT)

//
// Set to ensure ODD parity
//

#define SBF_PARITY_BIT      7
#define SBF_PARITY          (1 << SBF_PARITY_BIT)

//
// IPPT Table --  IA64 Platform Properties Table
//

typedef struct _IPPT_TABLE {
    DESCRIPTION_HEADER  Header;
    ULONG               Flags;
    ULONG               Reserved[3];
} IPPT_TABLE, *PIPPT_TABLE;

#define IPPT_DISABLE_WRITE_COMBINING       0x01L
#define IPPT_ENABLE_CROSS_PARTITION_IPI    0x02L
#define IPPT_DISABLE_PTCG_TB_FLUSH         0x04L
#define IPPT_DISABLE_UC_MAIN_MEMORY        0x08L

#define IPPT_SIGNATURE  0x54505049 // 'IPPT'

#endif // _ACPITBL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\umpnpi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umpnpi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the user-mode Plug and Play Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _UMPNPI_H_
#define _UMPNPI_H_


//
// global data
//

extern HANDLE ghPnPHeap;


//
// definitions
//

#define GUID_STRING_LEN    39   // size in chars, including terminating NULL

//
// flags for IsValidDeviceID
//
#define PNP_NOT_MOVED                     0x00000001
#define PNP_NOT_PHANTOM                   0x00000002
#define PNP_PRESENT                       0x00000004
#define PNP_NOT_REMOVED                   0x00000008
#define PNP_STRICT                        0xFFFFFFFF


//
// Define the Plug and Play driver types. (from ntos\io\pnpmgr\pnpi.h)
//

typedef enum _PLUGPLAY_SERVICE_TYPE {
    PlugPlayServiceBusExtender,
    PlugPlayServiceAdapter,
    PlugPlayServicePeripheral,
    PlugPlayServiceSoftware,
    MaxPlugPlayServiceType
} PLUGPLAY_SERVICE_TYPE, *PPLUGPLAY_SERVICE_TYPE;


//
// rdevnode.c
//

CONFIGRET
EnableDevInst(
    IN  PCWSTR      pszDeviceID,
    IN  BOOL        UseDisableCount
    );

CONFIGRET
DisableDevInst(
    IN  PCWSTR      pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR      pszVetoName,
    IN  ULONG       ulNameLength,
    IN  BOOL        UseDisableCount
    );

CONFIGRET
UninstallRealDevice(
    IN  LPCWSTR     pszDeviceID
    );

CONFIGRET
UninstallPhantomDevice(
    IN  LPCWSTR     pszDeviceID
    );

BOOL
IsDeviceRootEnumerated(
    IN  LPCWSTR     pszDeviceID
    );

CONFIGRET
QueryAndRemoveSubTree(
    IN  PCWSTR      pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR      pszVetoName,
    IN  ULONG       ulNameLength,
    IN  ULONG       ulFlags
    );

CONFIGRET
ReenumerateDevInst(
    IN  PCWSTR      pszDeviceID,
    IN  BOOL        EnumSubTree,
    IN  ULONG       ulFlags
    );

typedef enum {

    EA_CONTINUE,
    EA_SKIP_SUBTREE,
    EA_STOP_ENUMERATION

} ENUM_ACTION;

typedef ENUM_ACTION (*PFN_ENUMTREE)(
    IN      LPCWSTR     DevInst,
    IN OUT  PVOID       Context
    );

CONFIGRET
EnumerateSubTreeTopDownBreadthFirst(
    IN      handle_t        BindingHandle,
    IN      LPCWSTR         DevInst,
    IN      PFN_ENUMTREE    CallbackFunction,
    IN OUT  PVOID           Context
    );

//
// revent.c
//

BOOL
InitNotification(
    VOID
    );

DWORD
InitializePnPManager(
    IN  LPDWORD     lpParam
    );

DWORD
SessionNotificationHandler(
    IN  DWORD       EventType,
    IN  PWTSSESSION_NOTIFICATION SessionNotification
    );

ENUM_ACTION
QueueInstallationCallback(
    IN      LPCWSTR         DevInst,
    IN OUT  PVOID           Context
    );

typedef struct {
    BOOL        HeadNodeSeen;
    BOOL        SingleLevelEnumOnly;
    CONFIGRET   Status;
} QI_CONTEXT, *PQI_CONTEXT;


//
// rtravers.c
//

CONFIGRET
GetServiceDeviceListSize(
    IN  LPCWSTR     pszService,
    OUT PULONG      pulLength
    );

CONFIGRET
GetServiceDeviceList(
    IN  LPCWSTR     pszService,
    OUT LPWSTR      pBuffer,
    IN OUT PULONG   pulLength,
    IN  ULONG       ulFlags
    );


//
// rutil.c
//

BOOL
MultiSzAppendW(
    IN OUT LPWSTR   pszMultiSz,
    IN OUT PULONG   pulSize,
    IN     LPCWSTR  pszString
    );

BOOL
MultiSzDeleteStringW(
    IN OUT LPWSTR   pString,
    IN LPCWSTR      pSubString
    );

LPWSTR
MultiSzFindNextStringW(
    IN  LPWSTR      pMultiSz
    );

BOOL
MultiSzSearchStringW(
    IN  LPCWSTR     pString,
    IN  LPCWSTR     pSubString
    );

ULONG
MultiSzSizeW(
    IN  LPCWSTR     pString
    );

BOOL
IsValidGuid(
    IN  LPWSTR      pszGuid
    );

BOOL
GuidEqual(
    CONST GUID UNALIGNED *Guid1,
    CONST GUID UNALIGNED *Guid2
    );

DWORD
GuidFromString(
    IN  PCWSTR      GuidString,
    OUT LPGUID      Guid
    );

DWORD
StringFromGuid(
    IN  CONST GUID *Guid,
    OUT PWSTR       GuidString,
    IN  DWORD       GuidStringSize
    );

BOOL
IsValidDeviceID(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey,
    IN  ULONG       ulFlags
    );

BOOL
IsRootDeviceID(
    IN  LPCWSTR     pDeviceID
    );

BOOL
IsDeviceIdPresent(
    IN  LPCWSTR     pszDeviceID
    );

BOOL
IsDevicePhantom(
    IN  LPWSTR      pszDeviceID
    );

BOOL
IsDeviceMoved(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey
    );

ULONG
GetDeviceConfigFlags(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey
    );

CONFIGRET
GetDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    OUT PULONG      pulStatus,
    OUT PULONG      pulProblem
    );

CONFIGRET
SetDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       ulStatus,
    IN  ULONG       ulProblem
    );

CONFIGRET
ClearDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       ulStatus,
    IN  ULONG       ulProblem
    );

BOOL
GetActiveService(
    IN  PCWSTR      pszDevice,
    OUT PWSTR       pszService
    );

BOOL
PathToString(
    IN  LPWSTR      pszString,
    IN  LPCWSTR     pszPath,
    IN  ULONG       ulLength
    );

CONFIGRET
CopyRegistryTree(
    IN  HKEY        hSrcKey,
    IN  HKEY        hDestKey,
    IN  ULONG       ulOption
    );

CONFIGRET
MakeKeyVolatile(
    IN  LPCWSTR     pszParentKey,
    IN  LPCWSTR     pszChildKey
    );

CONFIGRET
MakeKeyNonVolatile(
    IN  LPCWSTR     pszParentKey,
    IN  LPCWSTR     pszChildKey
    );

CONFIGRET
OpenLogConfKey(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       LogConfType,
    OUT PHKEY       phKey
    );

BOOL
CreateDeviceIDRegKey(
    IN  HKEY        hParentKey,
    IN  LPCWSTR     pDeviceID
    );

VOID
PNP_ENTER_SYNCHRONOUS_CALL(
    VOID
    );

VOID
PNP_LEAVE_SYNCHRONOUS_CALL(
    VOID
    );

ULONG
MapNtStatusToCmError(
    IN  ULONG       NtStatus
    );

ULONG
GetActiveConsoleSessionId(
    VOID
    );


//
// secutil.c
//

PSID
GetUserSid(
    IN  HANDLE  hUserToken
    );

PSID
GetInteractiveSid(
    VOID
    );

BOOL
IsClientUsingLocalConsole(
    IN  handle_t    hBinding
    );

BOOL
IsClientLocal(
    IN  handle_t    hBinding
    );

BOOL
IsClientInteractive(
    IN  handle_t    hBinding
    );

BOOL
VerifyClientPrivilege(
    IN  handle_t    hBinding,
    IN  ULONG       Privilege,
    IN  LPCWSTR     ServiceName
    );

BOOL
VerifyClientAccess(
    IN  handle_t     hBinding,
    IN  ACCESS_MASK  DesiredAccess
    );

BOOL
VerifyKernelInitiatedEjectPermissions(
    IN  HANDLE      UserToken   OPTIONAL,
    IN  BOOL        DockDevice
    );


//
// pnpsec.c
//

#include "pnpsec.h"

BOOL
CreatePlugPlaySecurityObject(
    VOID
    );

VOID
DestroyPlugPlaySecurityObject(
    VOID
    );


//
// osver.c
//

BOOL
IsEmbeddedNT(
    VOID
    );

BOOL
IsTerminalServer(
    VOID
    );

BOOL
IsFastUserSwitchingEnabled(
    VOID
    );



#endif // _UMPNPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\apic.inc ===
;/*
;++
;
;   Copyright (c) 1992  Intel Corporation
;   All rights reserved
;
;   INTEL CORPORATION PROPRIETARY INFORMATION
;
;   This software is supplied to Microsoft under the terms
;   of a license agreement with Intel Corporation and may not be
;   copied nor disclosed except in accordance with the terms
;   of that agreement.
;
;
;   Module Name:
;
;       apic.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       APIC interrupt controller and APIC-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Hugh Bynum and Ron Mosgrove Aug-1992
;
;--
if 0        ; Begin C only code        */

typedef volatile ULONG *PVULONG;


//
//  APIC Version Register (both IO Unit and Local Units)
//

struct ApicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1;
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct ApicVersion APIC_VERSION, *PAPIC_VERSION;
//
//  IO Unit definition
//

struct ApicIoUnit {
    volatile ULONG RegisterSelect;  // Write register number to access register
    volatile ULONG Reserved1[3];
    volatile ULONG RegisterWindow;  // Data read/written here
};

typedef struct ApicIoUnit IO_APIC_UNIT, *PIO_APIC_UNIT;
//
// APIC defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

//
//  Default Physical addresses of the APICs in a PC+MP system
//

#define IO_BASE_ADDRESS 0xFEC00000  // Default address of
                                    // 1st IO Apic
#define LU_BASE_ADDRESS 0xFEE00000  // Default address
                                    // of Local Apic
                                    
#define IO_REGISTER_SELECT      0x00000000 //
#define IO_REGISTER_WINDOW      0x00000010 //

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define LU_ID_REGISTER          0x00000020 //
#define LU_VERS_REGISTER        0x00000030 //
#define LU_TPR                  0x00000080 //
#define LU_APR                  0x00000090 //
#define LU_PPR                  0x000000A0 //
#define LU_EOI                  0x000000B0 //
#define LU_REMOTE_REGISTER      0x000000C0 //

#define LU_LOGICAL_DEST         0x000000D0 //
#define LU_LOGICAL_DEST_MASK    0xFF000000

#define LU_DEST_FORMAT          0x000000E0 //
#define LU_DEST_FORMAT_MASK     0xF0000000
#define LU_DEST_FORMAT_FLAT     0xFFFFFFFF
#define LU_DEST_FORMAT_CLUSTER  0x0FFFFFFF

#define LU_SPURIOUS_VECTOR      0x000000F0 //
#define LU_FAULT_VECTOR         0x00000370 //
#define LU_UNIT_ENABLED         0x00000100
#define LU_UNIT_DISABLED        0x00000000

#define LU_ISR_0                0x00000100 //
#define LU_TMR_0                0x00000180 //
#define LU_IRR_0                0x00000200 //
#define LU_ERROR_STATUS         0x00000280 //
#define LU_INT_CMD_LOW          0x00000300 //
#define LU_INT_CMD_HIGH         0x00000310 //
#define LU_TIMER_VECTOR         0x00000320 //
#define LU_PERF_VECTOR          0x00000340
#define LU_INT_VECTOR_0         0x00000350 //    TEMPORARY - do not use
#define LU_INT_VECTOR_1         0x00000360 //    TEMPORARY - do not use
#define LU_INITIAL_COUNT        0x00000380 //
#define LU_CURRENT_COUNT        0x00000390 //
#define LU_DIVIDER_CONFIG       0x000003E0 //
#define LU_DIVIDE_BY_1          0x0000000B //

#define APIC_ID_MASK            0xFF000000
#define APIC_ID_SHIFT           24

#define INT_VECTOR_MASK         0x000000FF
#define RESERVED_HIGH_INT       0x000000F8
#define DELIVERY_MODE_MASK      0x00000700
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_REMOTE_READ     0x00000300
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_STARTUP         0x00000600
#define DELIVER_EXTINT          0x00000700
#define PHYSICAL_DESTINATION    0x00000000
#define LOGICAL_DESTINATION     0x00000800
#define DELIVERY_PENDING        0x00001000
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define REMOTE_IRR              0x00004000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000
#define PERIODIC_TIMER          0x00020000

#define ICR_LEVEL_ASSERTED      0x00004000
#define ICR_LEVEL_DEASSERTED    0x00000000
#define ICR_RR_STATUS_MASK      0x00030000
#define ICR_RR_INVALID          0x00000000
#define ICR_RR_IN_PROGRESS      0x00010000
#define ICR_RR_VALID            0x00020000
#define ICR_SHORTHAND_MASK      0x000C0000
#define ICR_USE_DEST_FIELD      0x00000000
#define ICR_SELF                0x00040000
#define ICR_ALL_INCL_SELF       0x00080000
#define ICR_ALL_EXCL_SELF       0x000C0000

//
//  Special ICR request to reset a remote processor
//
#define LU_RESET_ASSERT     ( DELIVER_INIT | LEVEL_TRIGGERED | ICR_LEVEL_ASSERTED | \
                           ICR_USE_DEST_FIELD | PHYSICAL_DESTINATION)
#define LU_RESET_DEASSERT   ( DELIVER_INIT | LEVEL_TRIGGERED | ICR_LEVEL_DEASSERTED | \
                           ICR_USE_DEST_FIELD | PHYSICAL_DESTINATION)
//
//  Special ICR request to reset a remote processor
//
#define LU_INIT_DEASSERT     (DELIVER_INIT | LEVEL_TRIGGERED | \
                              ICR_ALL_INCL_SELF | ICR_LEVEL_DEASSERTED )
//
//  Startup ICR Requset - OR in the VV value needed
//
#define LU_STARTUP_IPI   ( DELIVER_STARTUP | ICR_USE_DEST_FIELD | \
                           PHYSICAL_DESTINATION)

#define DESTINATION_MASK        0xFF000000
#define DESTINATION_SHIFT       24
//
// APIC IO unit redirection table, interrupt destination field: this field
// is 32 bits for the 82489DX APIC; future APIC implementations will put the
// destination field in the upper 8 bits of the entry, not the full 32 bits
//
#define DESTINATION_CPU_0       (ULONG) (1 << DESTINATION_SHIFT)
#define DESTINATION_ALL_CPUS    (ULONG) (0xff << DESTINATION_SHIFT)

//
//  Io Apic Entry definitions
//
//  Interrupt Types Possible in the PC+MP Table
//  valid for both local and Io Apics
//
#define INT_TYPE_INTR           0x0
#define INT_TYPE_NMI            0x1
#define INT_TYPE_SMI            0x2
#define INT_TYPE_EXTINT         0x3

/*
endif

;  APIC defines for assembly code
;  BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

;
;  Default Physical addresses of the APICs in a PC+MP system
;

IO_BASE_ADDRESS equ 0FEC00000H  ; Default address of
                                ; 1st IO Apic
LU_BASE_ADDRESS equ 0FEE00000H  ; Default address
                                ; of Local Apic

IO_REGISTER_SELECT      equ     00000000H  ;
IO_REGISTER_WINDOW      equ     00000010H  ;

IO_ID_REGISTER          equ     00000000H  ;
IO_VERS_REGISTER        equ     00000001H  ;
IO_ARB_ID_REGISTER      equ     00000002H  ;
IO_REDIR_00_LOW         equ     00000010H  ;
IO_REDIR_00_HIGH        equ     00000011H  ;

IO_MAX_REDIR_MASK       equ     00FF0000H  ;
IO_VERSION_MASK         equ     000000FFH  ;

LU_ID_REGISTER          equ     00000020H  ;
LU_VERS_REGISTER        equ     00000030H  ;
LU_TPR                  equ     00000080H  ;
LU_APR                  equ     00000090H  ;
LU_PPR                  equ     000000A0H  ;
LU_EOI                  equ     000000B0H  ;
LU_REMOTE_REGISTER      equ     000000C0H  ;

LU_LOGICAL_DEST         equ     000000D0H  ;
LU_LOGICAL_DEST_MASK    equ    0FF000000H  ;

LU_DEST_FORMAT          equ     000000E0H  ;
LU_DEST_FORMAT_MASK     equ    0F0000000H  ;
LU_DEST_FORMAT_FLAT     equ    0FFFFFFFFH  ;
LU_DEST_FORMAT_CLUSTER  equ     0FFFFFFFH

LU_SPURIOUS_VECTOR      equ     000000F0H  ;
LU_FAULT_VECTOR         equ     00000370H  ;
LU_UNIT_ENABLED         equ     00000100H  ;
LU_UNIT_DISABLED        equ     00000000H  ;

LU_ISR_0                equ     00000100H  ;
LU_TMR_0                equ     00000180H  ;
LU_IRR_0                equ     00000200H  ;
LU_ERROR_STATUS         equ     00000280H  ;
LU_INT_CMD_LOW          equ     00000300H  ;
LU_INT_CMD_HIGH         equ     00000310H  ;
LU_TIMER_VECTOR         equ     00000320H  ;
LU_PERF_VECTOR          equ     00000340H  ;
LU_INT_VECTOR_0         equ     00000350H  ;     TEMPORARY - do not use
LU_INT_VECTOR_1         equ     00000360H  ;     TEMPORARY - do not use
LU_INITIAL_COUNT        equ     00000380H  ;
LU_CURRENT_COUNT        equ     00000390H  ;

LU_DIVIDER_CONFIG       equ     000003E0H  ;
LU_DIVIDE_BY_1          equ     0000000BH  ;
LU_DIVIDE_BY_2          equ     00000000H  ;
LU_DIVIDE_BY_4          equ     00000001H  ;
LU_DIVIDE_BY_8          equ     00000002H  ;
LU_DIVIDE_BY_16         equ     00000003H  ;
LU_DIVIDE_BY_32         equ     00000008H  ;
LU_DIVIDE_BY_64         equ     00000009H  ;
LU_DIVIDE_BY_128        equ     0000000AH  ;

APIC_ID_MASK            equ     0FF000000H ;
APIC_ID_SHIFT           equ     24         ;

INT_VECTOR_MASK         equ     000000FFH  ;
RESERVED_HIGH_INT       equ     000000F8H  ;
DELIVERY_MODE_MASK      equ     00000700H  ;
DELIVER_FIXED           equ     00000000H  ;
DELIVER_LOW_PRIORITY    equ     00000100H  ;
DELIVER_SMI             equ     00000200H  ;
DELIVER_REMOTE_READ     equ     00000300H  ;
DELIVER_NMI             equ     00000400H  ;
DELIVER_INIT            equ     00000500H  ;
DELIVER_STARTUP         equ     00000600H  ;
DELIVER_EXTINT          equ     00000700H  ;
PHYSICAL_DESTINATION    equ     00000000H  ;
LOGICAL_DESTINATION     equ     00000800H  ;
DELIVERY_PENDING        equ     00001000H  ;
ACTIVE_LOW              equ     00002000H  ;
ACTIVE_HIGH             equ     00000000H  ;
REMOTE_IRR              equ     00004000H  ;
LEVEL_TRIGGERED         equ     00008000H  ;
EDGE_TRIGGERED          equ     00000000H  ;
INTERRUPT_MASKED        equ     00010000H  ;
INTERRUPT_MOT_MASKED    equ     00000000H  ;
PERIODIC_TIMER          equ     00020000H  ;

ICR_LEVEL_ASSERTED      equ     00004000H  ;
ICR_LEVEL_DEASSERTED    equ     00000000H  ;
ICR_RR_STATUS_MASK      equ     00030000H  ;
ICR_RR_INVALID          equ     00000000H  ;
ICR_RR_IN_PROGRESS      equ     00010000H  ;
ICR_RR_VALID            equ     00020000H  ;
ICR_SHORTHAND_MASK      equ     000C0000H  ;
ICR_USE_DEST_FIELD      equ     00000000H  ;
ICR_SELF                equ     00040000H  ;
ICR_ALL_INCL_SELF       equ     00080000H  ;
ICR_ALL_EXCL_SELF       equ     000C0000H  ;

DESTINATION_MASK        equ    0FF000000H  ;
DESTINATION_SHIFT       equ     24         ; shift count for dest. mask
;
; APIC IO unit redirection table, interrupt destination field: this field
; is 32 bits for the 82489DX APIC; future APIC implementations will put the
; destination field in the upper 8 bits of the entry, not the full 32 bits
;
DESTINATION_CPU_0   equ     1    SHL DESTINATION_SHIFT
DESTINATION_ALL_CPUS    equ     0FFH SHL DESTINATION_SHIFT

;
;  Interrupt Types Possible in the PC+MP Table
;
INT_TYPE_INTR       equ 0H
INT_TYPE_NMI        equ 01H
INT_TYPE_SMI        equ 02H
INT_TYPE_EXTINT     equ 03H

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\evntrace.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    EvnTrace.h

Abstract:

    Public headers for event tracing control applications,
    consumers and providers

--*/

#ifndef _EVNTRACE_
#define _EVNTRACE_

#if defined(_WINNT_) || defined(WINNT)
#ifndef WMIAPI
#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif // _WMI_SOURCE
#endif // MIDL_PASS

#endif // WMIAPI

#include <guiddef.h>

//
// EventTraceGuid is used to identify a event tracing session
//
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    EventTraceGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

//
// SystemTraceControlGuid. Used to specify event tracing for kernel
//
DEFINE_GUID ( /* 9e814aad-3204-11d2-9a82-006008a86939 */
    SystemTraceControlGuid,
    0x9e814aad,
    0x3204,
    0x11d2,
    0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39
  );

//
// EventTraceConfigGuid. Used to report system configuration records
//
DEFINE_GUID ( /* 01853a65-418f-4f36-aefc-dc0f1d2fd235 */
    EventTraceConfigGuid,
    0x01853a65,
    0x418f,
    0x4f36,
    0xae, 0xfc, 0xdc, 0x0f, 0x1d, 0x2f, 0xd2, 0x35
  );

//
// DefaultTraceSecurityGuid. Specifies the default event tracing security
//
DEFINE_GUID ( /* 0811c1af-7a07-4a06-82ed-869455cdf713 */
    DefaultTraceSecurityGuid,
    0x0811c1af,
    0x7a07,
    0x4a06,
    0x82, 0xed, 0x86, 0x94, 0x55, 0xcd, 0xf7, 0x13
  );

#define KERNEL_LOGGER_NAMEW   L"NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEW   L"GlobalLogger"
#define EVENT_LOGGER_NAMEW    L"Event Log"

#define KERNEL_LOGGER_NAMEA   "NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEA   "GlobalLogger"
#define EVENT_LOGGER_NAMEA    "Event Log"

#define MAX_MOF_FIELDS                      16  // Limit of USE_MOF_PTR fields
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

//
// predefined generic event types (0x00 to 0x09 reserved).
//

#define EVENT_TRACE_TYPE_INFO               0x00  // Info or point event
#define EVENT_TRACE_TYPE_START              0x01  // Start event
#define EVENT_TRACE_TYPE_END                0x02  // End event
#define EVENT_TRACE_TYPE_DC_START           0x03  // Collection start marker
#define EVENT_TRACE_TYPE_DC_END             0x04  // Collection end marker
#define EVENT_TRACE_TYPE_EXTENSION          0x05  // Extension/continuation
#define EVENT_TRACE_TYPE_REPLY              0x06  // Reply event
#define EVENT_TRACE_TYPE_DEQUEUE            0x07  // De-queue event
#define EVENT_TRACE_TYPE_CHECKPOINT         0x08  // Generic checkpoint event
#define EVENT_TRACE_TYPE_RESERVED9          0x09

//
// Predefined Event Tracing Levels for Software/Debug Tracing
//
//
// Trace Level is UCHAR and passed in through the EnableLevel parameter
// in EnableTrace API. It is retrieved by the provider using the
// GetTraceEnableLevel macro.It should be interpreted as an integer value
// to mean everything at or below that level will be traced.
//
// Here are the possible Levels.
//

#define TRACE_LEVEL_NONE        0   // Tracing is not on
#define TRACE_LEVEL_FATAL       1   // Abnormal exit or termination
#define TRACE_LEVEL_ERROR       2   // Severe errors that need logging
#define TRACE_LEVEL_WARNING     3   // Warnings such as allocation failure
#define TRACE_LEVEL_INFORMATION 4   // Includes non-error cases(e.g.,Entry-Exit)
#define TRACE_LEVEL_VERBOSE     5   // Detailed traces from intermediate steps
#define TRACE_LEVEL_RESERVED6   6
#define TRACE_LEVEL_RESERVED7   7
#define TRACE_LEVEL_RESERVED8   8
#define TRACE_LEVEL_RESERVED9   9


//
// Event types for Process & Threads
//

#define EVENT_TRACE_TYPE_LOAD                  0x0A      // Load image

//
// Event types for IO subsystem
//

#define EVENT_TRACE_TYPE_IO_READ               0x0A
#define EVENT_TRACE_TYPE_IO_WRITE              0x0B

//
// Event types for Memory subsystem
//

#define EVENT_TRACE_TYPE_MM_TF                 0x0A      // Transition fault
#define EVENT_TRACE_TYPE_MM_DZF                0x0B      // Demand Zero fault
#define EVENT_TRACE_TYPE_MM_COW                0x0C      // Copy on Write
#define EVENT_TRACE_TYPE_MM_GPF                0x0D      // Guard Page fault
#define EVENT_TRACE_TYPE_MM_HPF                0x0E      // Hard page fault

//
// Event types for Network subsystem, all protocols
//

#define EVENT_TRACE_TYPE_SEND                  0x0A     // Send
#define EVENT_TRACE_TYPE_RECEIVE               0x0B     // Receive
#define EVENT_TRACE_TYPE_CONNECT               0x0C     // Connect
#define EVENT_TRACE_TYPE_DISCONNECT            0x0D     // Disconnect
#define EVENT_TRACE_TYPE_RETRANSMIT            0x0E     // ReTransmit
#define EVENT_TRACE_TYPE_ACCEPT                0x0F     // Accept
#define EVENT_TRACE_TYPE_RECONNECT             0x10     // ReConnect


//
// Event Types for the Header (to handle internal event headers)
//

#define EVENT_TRACE_TYPE_GUIDMAP                0x0A
#define EVENT_TRACE_TYPE_CONFIG                 0x0B
#define EVENT_TRACE_TYPE_SIDINFO                0x0C
#define EVENT_TRACE_TYPE_SECURITY               0x0D

//
// Event types for Registry subsystem
//

#define EVENT_TRACE_TYPE_REGCREATE              0x0A     // NtCreateKey
#define EVENT_TRACE_TYPE_REGOPEN                0x0B     // NtOpenKey
#define EVENT_TRACE_TYPE_REGDELETE              0x0C     // NtDeleteKey
#define EVENT_TRACE_TYPE_REGQUERY               0x0D     // NtQueryKey
#define EVENT_TRACE_TYPE_REGSETVALUE            0x0E     // NtSetValueKey
#define EVENT_TRACE_TYPE_REGDELETEVALUE         0x0F     // NtDeleteValueKey
#define EVENT_TRACE_TYPE_REGQUERYVALUE          0x10     // NtQueryValueKey
#define EVENT_TRACE_TYPE_REGENUMERATEKEY        0x11     // NtEnumerateKey
#define EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY   0x12     // NtEnumerateValueKey
#define EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE  0x13     // NtQueryMultipleValueKey
#define EVENT_TRACE_TYPE_REGSETINFORMATION      0x14     // NtSetInformationKey
#define EVENT_TRACE_TYPE_REGFLUSH               0x15     // NtFlushKey
#define EVENT_TRACE_TYPE_REGKCBDMP              0x16     // KcbDump/create

//
// Event types for system configuration records
//
#define EVENT_TRACE_TYPE_CONFIG_CPU             0x0A     // CPU Configuration
#define EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK    0x0B     // Physical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_LOGICALDISK     0x0C     // Logical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_NIC             0x0D     // NIC Configuration
#define EVENT_TRACE_TYPE_CONFIG_VIDEO           0x0E     // Video Adapter Configuration
#define EVENT_TRACE_TYPE_CONFIG_SERVICES        0x0F     // Active Services
#define EVENT_TRACE_TYPE_CONFIG_POWER           0x10     // ACPI Configuration

//
// Enable flags for SystemControlGuid only
//
#define EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
#define EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
#define EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

#define EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
#define EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

#define EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
#define EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

#define EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive

#define EVENT_TRACE_FLAG_REGISTRY           0x00020000  // registry calls
#define EVENT_TRACE_FLAG_DBGPRINT           0x00040000  // DbgPrint(ex) Calls
//
// Pre-defined Enable flags for everybody else
//
#define EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
#define EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
#define EVENT_TRACE_FLAG_ENABLE_RESERVE     0x20000000  // Reserved

//
// Logger Mode flags
//

#define EVENT_TRACE_FILE_MODE_NONE          0x00000000  // logfile is off
#define EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x00000001  // log sequentially
#define EVENT_TRACE_FILE_MODE_CIRCULAR      0x00000002  // log in circular manner
#define EVENT_TRACE_FILE_MODE_APPEND        0x00000004  // append sequential log
#define EVENT_TRACE_FILE_MODE_NEWFILE       0x00000008  // auto-switch log file

#define EVENT_TRACE_FILE_MODE_PREALLOCATE   0x00000020  // pre-allocate mode

#define EVENT_TRACE_REAL_TIME_MODE          0x00000100  // real time mode on
#define EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x00000200  // delay opening file
#define EVENT_TRACE_BUFFERING_MODE          0x00000400  // buffering mode only
#define EVENT_TRACE_PRIVATE_LOGGER_MODE     0x00000800  // Process Private Logger
#define EVENT_TRACE_ADD_HEADER_MODE         0x00001000  // Add a logfile header
#define EVENT_TRACE_USE_GLOBAL_SEQUENCE     0x00004000  // Use global sequence no.
#define EVENT_TRACE_USE_LOCAL_SEQUENCE      0x00008000  // Use local sequence no.

#define EVENT_TRACE_RELOG_MODE              0x00010000  // Relogger

#define EVENT_TRACE_USE_PAGED_MEMORY        0x01000000  // Use pageable buffers   

//
// internal control codes used.
//
#define EVENT_TRACE_CONTROL_QUERY           0
#define EVENT_TRACE_CONTROL_STOP            1
#define EVENT_TRACE_CONTROL_UPDATE          2
#define EVENT_TRACE_CONTROL_FLUSH           3       // Flushes all the buffers

//
// Flags used by WMI Trace Message
// Note that the order or value of these flags should NOT be changed as they are processed
// in this order.
//
#define TRACE_MESSAGE_SEQUENCE		1           // Message should include a sequence number
#define TRACE_MESSAGE_GUID			2           // Message includes a GUID
#define TRACE_MESSAGE_COMPONENTID   4           // Message has no GUID, Component ID instead
#define	TRACE_MESSAGE_TIMESTAMP		8           // Message includes a timestamp
#define TRACE_MESSAGE_PERFORMANCE_TIMESTAMP 16  // *Obsolete* Clock type is controlled by the logger
#define	TRACE_MESSAGE_SYSTEMINFO	32          // Message includes system information TID,PID
#define TRACE_MESSAGE_FLAG_MASK     0xFFFF      // Only the lower 16 bits of flags are placed in the message
                                                // those above 16 bits are reserved for local processing
#define TRACE_MESSAGE_MAXIMUM_SIZE  8*1024      // the maximum size allowed for a single trace message
                                                // longer messages will return ERROR_BUFFER_OVERFLOW
//
// Flags to indicate to consumer which fields
// in the EVENT_TRACE_HEADER are valid
//

#define EVENT_TRACE_USE_PROCTIME   0x0001    // ProcessorTime field is valid
#define EVENT_TRACE_USE_NOCPUTIME  0x0002    // No Kernel/User/Processor Times

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)
//
// Trace header for all (except kernel) events. This is used to overlay
// to bottom part of WNODE_HEADER to conserve space.
//

typedef struct _EVENT_TRACE_HEADER {        // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    union {
        USHORT      FieldTypeFlags;         // Indicates valid fields
        struct {
            UCHAR   HeaderType;             // Header type - internal use only
            UCHAR   MarkerFlags;            // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    };
    ULONG           ThreadId;               // Thread Id
    ULONG           ProcessId;              // Process Id
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    };
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

//
// This header is used to trace and track transaction co-relations
//
typedef struct _EVENT_INSTANCE_HEADER {
    USHORT          Size;
    union {
        USHORT      FieldTypeFlags;     // Indicates valid fields
        struct {
            UCHAR   HeaderType;         // Header type - internal use only
            UCHAR   MarkerFlags;        // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

//
// Following are structures and macros for use with USE_MOF_PTR
//

#define DEFINE_TRACE_MOF_FIELD(MOF, ptr, length, type) \
    (MOF)->DataPtr  = (ULONG64) ptr; \
    (MOF)->Length   = (ULONG) length; \
    (MOF)->DataType = (ULONG) type;

typedef struct _MOF_FIELD {
    ULONG64     DataPtr;    // Pointer to the field. Up to 64-bits only
    ULONG       Length;     // Length of the MOF field
    ULONG       DataType;   // Type of data
} MOF_FIELD, *PMOF_FIELD;

#if !(defined(_NTDDK_) || defined(_NTIFS_)) || defined(_WMIKM_)
//
// This is the header for every logfile. The memory for LoggerName
// and LogFileName must be contiguous adjacent to this structure
// Allows both user-mode and kernel-mode to understand the header
//
typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    };
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   CpuSpeedInMHz;      // Cpu Speed in MHz
        };
    };
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // Reserved
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

#endif // !_NTDDK_ || _WMIKM_


//
// Instance Information to track parent child relationship of Instances.
//
typedef struct EVENT_INSTANCE_INFO {
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

#if !defined(_WMIKM_) && !defined(_NTDDK_) && !defined(_NTIFS_)
//
// Structures that have UNICODE and ANSI versions are defined here
//

//
// Logger configuration and running statistics. This structure is used
// by user-mode callers, such as PDH library
//

typedef struct _EVENT_TRACE_PROPERTIES {
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // age decay time, in minutes

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

// NOTE:
// If AgeLimit is 0, default is used
// If AgeLimit is < 0, buffer aging is turned off

typedef struct _TRACE_GUID_PROPERTIES {
    GUID    Guid;
    ULONG   GuidType;
    ULONG   LoggerId;
    ULONG   EnableLevel;
    ULONG   EnableFlags;
    BOOLEAN     IsEnable;
} TRACE_GUID_PROPERTIES, *PTRACE_GUID_PROPERTIES;


//
// Data Provider structures
//
// Used by RegisterTraceGuids()

typedef struct  _TRACE_GUID_REGISTRATION {
    LPCGUID Guid;           // Guid of data block being registered or updated.
    HANDLE RegHandle;      // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;

//
// Data consumer structures
//

// An EVENT_TRACE consists of a fixed header (EVENT_TRACE_HEADER) and
// optionally a variable portion pointed to by MofData. The datablock
// layout of the variable portion is unknown to the Logger and must
// be obtained from WBEM CIMOM database.
//
typedef struct _EVENT_TRACE {
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    ULONG                   ClientContext;      // Reserved
} EVENT_TRACE, *PEVENT_TRACE;


typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)
                (PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

//
// Prototype for service request callback. Data providers register with WMI
// by passing a service request callback function that is called for all
// wmi requests.

typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *BufferSize,
    IN OUT PVOID Buffer
    );


struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;    // Logfile Name
    LPWSTR                  LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // Mode of the logfile

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW           // callback before each buffer
                            BufferCallback; // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA {
    LPSTR                   LogFileName;    // Logfile Name
    LPSTR                   LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // LogFile Mode.

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA           // callback before each buffer
                            BufferCallback; // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

//
// Define generic structures
//

#if defined(_UNICODE) || defined(UNICODE)
#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEW
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEW
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEA
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEA
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEA

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// Logger control APIs
//

//
// Use the routine below to start an event trace session
//

// ULONG
// StartTrace(
//      OUT PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );


EXTERN_C
ULONG
WMIAPI
StartTraceW(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to stop an event trace session
//

//
// ULONG
// StopTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
StopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );


//
// Use the routine below to query the properties of an event trace session
//

// ULONG
// QueryTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
QueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
QueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to update certain properties of an event trace session
//

// ULONG
// UpdateTrace(
//      IN (PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
UpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
UpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to request that all active buffers an event trace
// session be "flushed", or written out.
//

#if (WINVER >= 0x0501)
// ULONG
// FlushTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
FlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
FlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

#endif

//
// Generic trace control routine
//
EXTERN_C
ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

EXTERN_C
ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

//
// ULONG
// QueryAllTraces(
//  OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
//  IN ULONG PropertyArrayCount,
//  OUT PULONG LoggerCount
//  );
//

EXTERN_C
ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );

EXTERN_C
ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );


//
// Data Provider APIs
//

EXTERN_C
ULONG
WMIAPI
CreateTraceInstanceId(
    IN HANDLE RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInstInfo
    );

EXTERN_C
ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    );

//
// Use the routine below to generate and record an event trace
//


EXTERN_C
ULONG
WMIAPI
TraceEvent(
    IN TRACEHANDLE  TraceHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

EXTERN_C
ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE TraceHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    );

//
// Use the routine below to register a guid for tracing
//

//
// ULONG
// RegisterTraceGuids(
//  IN WMIDPREQUEST  RequestAddress,
//  IN PVOID         RequestContext,
//  IN LPCGUID       ControlGuid,
//  IN ULONG         GuidCount,
//  IN PTRACE_GUID_REGISTRATION TraceGuidReg,
//  IN LPCTSTR       MofImagePath,
//  IN LPCTSTR       MofResourceName,
//  OUT PTRACEHANDLE RegistrationHandle
//  );
//

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCSTR        MofImagePath,
    IN LPCSTR        MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

#if (WINVER >= 0x0501)
EXTERN_C
ULONG
WMIAPI
EnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    );
#endif

EXTERN_C
ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );

EXTERN_C
TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    );

EXTERN_C
UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE TraceHandle
    );

//
// Data Consumer APIs and structures start here
//

//
// TRACEHANDLE
// OpenTrace(
//  IN OUT PEVENT_TRACE_LOGFILE Logfile
//  );
//

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceA(
    IN OUT PEVENT_TRACE_LOGFILEA Logfile
    );

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceW(
    IN OUT PEVENT_TRACE_LOGFILEW Logfile
    );

EXTERN_C
ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    );

EXTERN_C
ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    );

EXTERN_C
ULONG
WMIAPI
RemoveTraceCallback (
    IN LPCGUID pGuid
    );

//
// The routines for tracing Messages follow
//
EXTERN_C
ULONG 
__cdecl
TraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    ...
);

EXTERN_C
ULONG 
TraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
);

#ifdef __cplusplus
}       // extern "C"
#endif

//
//
// Define the encoding independent routines
//

#if defined(UNICODE) || defined(_UNICODE)
#define RegisterTraceGuids      RegisterTraceGuidsW
#define StartTrace              StartTraceW
#define ControlTrace            ControlTraceW
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceW
#define QueryTrace              QueryTraceW
#define UpdateTrace             UpdateTraceW
#endif
#if (WINVER >= 0x0501)
#define FlushTrace              FlushTraceW
#endif
#define QueryAllTraces          QueryAllTracesW
#define OpenTrace               OpenTraceW
#else
#define RegisterTraceGuids      RegisterTraceGuidsA
#define StartTrace              StartTraceA
#define ControlTrace            ControlTraceA
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceA
#define QueryTrace              QueryTraceA
#define UpdateTrace             UpdateTraceA
#endif
#if (WINVER >= 0x0501)
#define FlushTrace              FlushTraceA
#endif
#define QueryAllTraces          QueryAllTracesA
#define OpenTrace               OpenTraceA
#endif  // UNICODE

#endif /* _WMIKM_  && _NTDDK_ */

#endif // WINNT
#endif /* _EVNTRACE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\mce.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    mce.h

Abstract:

    This header file defines the Machine Check Errors definitions.

Author:

    David N. Cutler (davec) 


Revision History:

    Creation: 04-Apr-2001

--*/

#ifndef _MCE_
#define _MCE_

//
// HalMcaLogInformation
//

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// ADDR register for each MCA bank
//

typedef union _MCI_ADDR{
    struct {
        ULONG Address;
        ULONG Reserved;
    };

    ULONGLONG   QuadPart;
} MCI_ADDR, *PMCI_ADDR;


typedef enum {
    HAL_MCE_RECORD,
    HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;


#if defined(_AMD64_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaErrorCode;
        USHORT  ModelErrorCode;
        ULONG   OtherInformation : 25;
        ULONG   ContextCorrupt : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   ErrorEnabled : 1;
        ULONG   UncorrectedError : 1;
        ULONG   StatusOverFlow : 1;
        ULONG   Valid : 1;
    } MciStatus;

    ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif // _AMD64_

#if defined(_X86_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // _X86_

//
// MCA exception log entry
// Defined as a union to contain MCA specific log or Pentium style MCE info.
//

#define MCA_EXTREG_V2MAX       24  // X86: Max. Number of extended registers

#if defined(_X86_) || defined(_AMD64_)

typedef struct _MCA_EXCEPTION {

    // Begin Version 1 stuff
    ULONG               VersionNumber;      // Version number of this record type
    MCA_EXCEPTION_TYPE  ExceptionType;      // MCA or MCE
    LARGE_INTEGER       TimeStamp;          // exception recording timestamp
    ULONG               ProcessorNumber;
    ULONG               Reserved1;

    union {
        struct {
            UCHAR           BankNumber;
            UCHAR           Reserved2[7];
            MCI_STATS       Status;
            MCI_ADDR        Address;
            ULONGLONG       Misc;
        } Mca;

        struct {
            ULONGLONG       Address;        // physical addr of cycle causing the error
            ULONGLONG       Type;           // cycle specification causing the error
        } Mce;
    } u;
    // End   Version 1 stuff

#if defined(_X86_)

    // Begin Version 2 stuff
    ULONG                   ExtCnt;
    ULONG                   Reserved3;
    ULONGLONG               ExtReg[MCA_EXTREG_V2MAX];
    // End   Version 2 stuff

#endif

} MCA_EXCEPTION, *PMCA_EXCEPTION;

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#if defined(_X86_)

#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)

#endif

#endif // _X86_ || _AMD64_

//
// ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this
// type of enums (UCHAR, __int64) could be defined...
//

#if defined(_AMD64_) || defined(_IA64_)

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE  {
    ErrorRecoverable = 0,
    ErrorFatal       = 1,
    ErrorCorrected   = 2,
    ErrorOthers      = 3,   // [3,...] values are reserved
} ERROR_SEVERITY_VALUE;

#endif

#if defined(_IA64_)

#if 0
// FIXFIX: This should not be required for IA64.
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // 0

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION, *PERROR_REVISION;

// For Info:
#define ERROR_MAJOR_REVISION_SAL_03_00 0
#define ERROR_MINOR_REVISION_SAL_03_00 2
#define ERROR_REVISION_SAL_03_00 { ERROR_MINOR_REVISION_SAL_03_00, \
                                   ERROR_MAJOR_REVISION_SAL_03_00 }

//
// Section Header revision is fixed at Major == 2 and Minor == 0
//
#define ERROR_FIXED_SECTION_REVISION { 2,\
                                       0 }

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day
        UCHAR   Month;    // Byte5: Month
        UCHAR   Year;     // Byte6: Year
        UCHAR   Century;  // Byte7: Century
    };
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

//
// IA64 ERRORS: ERROR_GUID definitions
//

typedef struct _ERROR_GUID   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_GUID, *PERROR_GUID;

//
// IA64 ERRORS: ERROR GUIDs definitions
//

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

//
// IA64 ERRORS: ERROR_RECORD_HEADER definitions
//

typedef union _ERROR_RECORD_VALID   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved 
    };
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER { // Offsets:
    ULONGLONG          Id;                //   0: Unique identifier
    ERROR_REVISION     Revision;          //   8: Major and Minor revision number of the record
    ERROR_SEVERITY     ErrorSeverity;     //  10: Error Severity
    ERROR_RECORD_VALID Valid;             //  11: Validation bits
    ULONG              Length;            //  12: Length of this record in bytes, including the header
    ERROR_TIMESTAMP    TimeStamp;         //  16: Timestamp recorded when event occured
    UCHAR              OemPlatformId[16]; //  24: Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER    {
    ERROR_DEVICE_GUID   Guid;         // Unique identifier
    ERROR_REVISION      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO RecoveryInfo; // Recovery Information
    UCHAR               Reserved;
    ULONG               Length;       // Length of this error device section in bytes, 
                                      // including the header.
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//

#if !defined(__midl)
__inline
USHORT
GetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    USHORT lid = (USHORT)((UCHAR)(section->Reserved));
    lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
    return( lid );
} // GetFwMceLogProcessorNumber()
#endif // !__midl

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//
// The MCA architecture supports five different types of error reporting functional units
// with the associated error records and its error severity. 
// At any point in time, a processor could encounter an MCA/CMC event due to errors detected 
// in one or more of the following units:
//  - Cache Check
//  - TLB   Check
//  - Bus   Check
//  - Register File
//  - Micro Architectural
//
// Terminology:
//
//  - Target Address:
//      64-bit integer containing the physical address where the data was to be delivered or
//      obtained. This could also be the incoming address for external snoops and TLB shoot-downs.
//
//  - Requestor Identifier:
//      64-bit integer specifying the bus agent that generated the transaction responsible for
//      the Machine Check event.
//                    
//  - Responder Identifier:
//      64-bit integer specifying the bus agent that responded to a transaction responsible for
//      the Machine Check event.
//                    
//  - Precise Instruction Pointer:
//      64-bit integer specifying the virtual address that points to the IA-64 bundle that 
//      contained the instruction responsible for the Machine Check event.
//                    

#define ERROR_PROCESSOR_GUID \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MODINFO_VALID  {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG CheckInfo: 1;             //       0:
        ULONGLONG RequestorIdentifier: 1;   //       1:
        ULONGLONG ResponderIdentifier: 1;   //       2:
        ULONGLONG TargetIdentifier: 1;      //       3:
        ULONGLONG PreciseIP: 1;             //       4:
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS    {
    isIA64 = 0,
    isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION   {
    CacheUnknownOp = 0,
    CacheLoad  = 1,
    CacheStore = 2,
    CacheInstructionFetch = 3,
    CacheDataPrefetch = 4,
    CacheSnoop = 5,
    CacheCastOut = 6,
    CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI    {
    CacheInvalid = 0,
    CacheHeldShared = 1,
    CacheHeldExclusive = 2,
    CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

typedef union _ERROR_CACHE_CHECK    {
    ULONGLONG CacheCheck;
    struct
    {
        ULONGLONG Operation:4;             // bits  0- 3: Cache operation
        ULONGLONG Level:2;                 //       4- 5: Cache Level
        ULONGLONG Reserved1:2;             //       6- 7
        ULONGLONG DataLine:1;              //       8   : Failure data part of cache line
        ULONGLONG TagLine:1;               //       9   : Failure tag part of cache line
        ULONGLONG DataCache:1;             //      10   : Failure in data cache
        ULONGLONG InstructionCache:1;      //      11   : Failure in instruction cache
        ULONGLONG MESI:3;                  //      12-14:
        ULONGLONG MESIValid:1;             //      15   : MESI field is valid
        ULONGLONG Way:5;                   //      16-20: Failure in Way of Cache
        ULONGLONG WayIndexValid:1;         //      21   : Way and Index fields valid
        ULONGLONG Reserved2:10;            //      22-31
        ULONGLONG Index:20;                //      32-51: Index of cache line
        ULONGLONG Reserved3:2;             //      52-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

typedef enum _ERROR_TLB_CHECK_OPERATION   {
    TlbUnknownOp = 0,
    TlbAccessWithLoad  = 1,
    TlbAccessWithStore = 2,
    TlbAccessWithInstructionFetch = 3,
    TlbAccessWithDataPrefetch = 4,
    TlbShootDown = 5,
    TlbProbe = 6,
    TlbVhptFill = 7,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK  {
    ULONGLONG TlbCheck;
    struct
    {
        ULONGLONG TRSlot:8;                // bits  0- 7: Slot number of Translation Register
        ULONGLONG TRSlotValid:1;           //       8   : TRSlot field is valid
        ULONGLONG Reserved1:1;             //       9
        ULONGLONG Level:2;                 //      10-11: TLB Level
        ULONGLONG Reserved2:4;             //      12-15
        ULONGLONG DataTransReg:1;          //      16   : Error in data translation register
        ULONGLONG InstructionTransReg:1;   //      17   : Error in instruction translation register
        ULONGLONG DataTransCache:1;        //      18   : Error in data translation cache
        ULONGLONG InstructionTransCache:1; //      19   : Error in instruction translation cache
        ULONGLONG Operation:4;             //      20-23: Operation
        ULONGLONG Reserved3:30;            //      24-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION   {
    BusUnknownOp = 0,
    BusPartialRead  = 1,
    BusPartialWrite = 2,
    BusFullLineRead = 3,
    BusFullLineWrite = 4,
    BusWriteBack = 5,
    BusSnoopProbe = 6,
    BusIncomingPtcG = 7,
    BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

typedef union _ERROR_BUS_CHECK  {
    ULONGLONG BusCheck;
    struct
    {
        ULONGLONG Size:5;                  // bits  0- 4: Transaction size
        ULONGLONG Internal:1;              //       5   : Internal bus error
        ULONGLONG External:1;              //       6   : External bus error
        ULONGLONG CacheTransfer:1;         //       7   : Error occured in Cache to Cache Transfer 
        ULONGLONG Type:8;                  //       8-15: Transaction type
        ULONGLONG Severity:5;              //      16-20: Error severity - platform specific
        ULONGLONG Hierarchy:2;             //      21-22: Level or Bus hierarchy
        ULONGLONG Reserved1:1;             //      23
        ULONGLONG Status:8;                //      24-31: Bus error status - processor bus specific
        ULONGLONG Reserved2:22;            //      32-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER   {
    RegFileUnknownId = 0,
    GeneralRegisterBank1 = 1,
    GeneralRegisterBank0 = 2,
    FloatingPointRegister = 3,
    BranchRegister = 4,
    PredicateRegister = 5,
    ApplicationRegister = 6,
    ControlRegister = 7,
    RegionRegister = 8,
    ProtectionKeyRegister = 9,
    DataBreakPointRegister = 10,
    InstructionBreakPointRegister = 11,
    PerformanceMonitorControlRegister = 12,
    PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION   {
    RegFileUnknownOp = 0,
    RegFileRead = 1,
    RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK  {
    ULONGLONG RegFileCheck;
    struct
    {
        ULONGLONG Identifier:4;            // bits  0- 3: Register file identifier
        ULONGLONG Operation:4;             //       4- 7: Operation that causes the MC event
        ULONGLONG RegisterNumber:7;        //       8-14: Register number responsible for MC event
        ULONGLONG RegisterNumberValid:1;   //      15   : Register number field is valid
        ULONGLONG Reserved1:38;            //      16-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG Reserved2:3;             //      60-62
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

typedef enum _ERROR_MS_CHECK_OPERATION   {
    MsUnknownOp = 0,
    MsReadOrLoad = 1,
    MsWriteOrStore = 2,
	MsOverTemperature = 3,
	MsNormalTemperature = 4
} ERROR_MS_CHECK_OPERATION;

typedef union _ERROR_MS_CHECK  {
    ULONGLONG MsCheck;
    struct
    {
        ULONGLONG StructureIdentifier:5;   // bits  0- 4: Structure Identifier - impl. specific
        ULONGLONG Level:3;                 //       5- 7: Structure Level where error was generated
        ULONGLONG ArrayId:4;               //       8-11: Identification of the array 
        ULONGLONG Operation:4;             //      12-15: Operation
        ULONGLONG Way:6;                   //      16-21: Way where the error was located
        ULONGLONG WayValid:1;              //      22   : Way field is valid
        ULONGLONG IndexValid:1;            //      23   : Index field is valid
        ULONGLONG Reserved1:8;             //      24-31
        ULONGLONG Index:8;                 //      32-39: Index where the error was located
        ULONGLONG Reserved2:14;            //      40-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO   {
    ULONGLONG             CheckInfo;
    ERROR_CACHE_CHECK     CacheCheck;
    ERROR_TLB_CHECK       TlbCheck;
    ERROR_BUS_CHECK       BusCheck;
    ERROR_REGFILE_CHECK   RegFileCheck;
    ERROR_MS_CHECK        MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO   {
    ERROR_MODINFO_VALID Valid;
    ERROR_CHECK_INFO    CheckInfo;
    ULONGLONG           RequestorId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;      
    };
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
    ULONGLONG   StateParameter;
    struct {
        ULONGLONG reserved0:2;  //   0-1 : reserved
        ULONGLONG rz:1;         //     2 : Rendez-vous successful
        ULONGLONG ra:1;         //     3 : Rendez-vous attempted
        ULONGLONG me:1;         //     4 : Distinct Multiple errors
        ULONGLONG mn:1;         //     5 : Min-state Save Area registered
        ULONGLONG sy:1;         //     6 : Storage integrity synchronized
        ULONGLONG co:1;         //     7 : Continuable
        ULONGLONG ci:1;         //     8 : Machine Check isolated
        ULONGLONG us:1;         //     9 : Uncontained Storage damage
        ULONGLONG hd:1;         //    10 : Hardware damage
        ULONGLONG tl:1;         //    11 : Trap lost
        ULONGLONG mi:1;         //    12 : More Information
        ULONGLONG pi:1;         //    13 : Precise Instruction pointer
        ULONGLONG pm:1;         //    14 : Precise Min-state Save Area
        ULONGLONG dy:1;         //    15 : Processor Dynamic State valid
        ULONGLONG in:1;         //    16 : INIT interruption
        ULONGLONG rs:1;         //    17 : RSE valid
        ULONGLONG cm:1;         //    18 : Machine Check corrected
        ULONGLONG ex:1;         //    19 : Machine Check expected
        ULONGLONG cr:1;         //    20 : Control Registers valid
        ULONGLONG pc:1;         //    21 : Performance Counters valid
        ULONGLONG dr:1;         //    22 : Debug Registers valid
        ULONGLONG tr:1;         //    23 : Translation Registers valid
        ULONGLONG rr:1;         //    24 : Region Registers valid
        ULONGLONG ar:1;         //    25 : Application Registers valid
        ULONGLONG br:1;         //    26 : Branch Registers valid
        ULONGLONG pr:1;         //    27 : Predicate Registers valid
        ULONGLONG fp:1;         //    28 : Floating-Point Registers valid
        ULONGLONG b1:1;         //    29 : Preserved Bank 1 General Registers valid
        ULONGLONG b0:1;         //    30 : Preserved Bank 0 General Registers valid
        ULONGLONG gr:1;         //    31 : General Registers valid
        ULONGLONG dsize:16;     // 47-32 : Processor Dynamic State size
        ULONGLONG reserved1:11; // 48-58 : reserved
        ULONGLONG cc:1;         //    59 : Cache Check
        ULONGLONG tc:1;         //    60 : TLB   Check
        ULONGLONG bc:1;         //    61 : Bus   Check
        ULONGLONG rc:1;         //    62 : Register File Check
        ULONGLONG uc:1;         //    63 : Micro-Architectural Check
    };
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;
    
typedef union _PROCESSOR_LOCAL_ID  {
    ULONGLONG LocalId;
    struct {
        ULONGLONG reserved:16;  //  0-16 : reserved
        ULONGLONG eid:8;        // 16-23 : Extended Id 
        ULONGLONG id:8;         // 24-31 : Id
        ULONGLONG ignored:32;   // 32-63 : ignored
    };
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;                                       

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
    ULONGLONG     Valid;
    struct {                                // Bits
        // Warning: Match the VALID fields with the _ERROR_PROCESSOR_STATIC_INFO members.
        //          KD extensions use the field names to access the PSI structure.
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BR: 1;                    //       1: Branch      Registers valid.
        ULONGLONG CR: 1;                    //       2: Control     Registers valid.
        ULONGLONG AR: 1;                    //       3: Application Registers valid.
        ULONGLONG RR: 1;                    //       4:             Registers valid.
        ULONGLONG FR: 1;                    //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO  {
    ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
    ERROR_SECTION_HEADER              Header;
    ERROR_PROCESSOR_VALID             Valid;
    ERROR_PROCESSOR_ERROR_MAP         ErrorMap;
    ERROR_PROCESSOR_STATE_PARAMETER   StateParameter;
    PROCESSOR_LOCAL_ID                CRLid;
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

//
// IA64 ERROR PROCESSOR State Parameter - GR18 - definitions.
//

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT         59
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK          0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT           60
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT           61
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_SHIFT           62
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT     63
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK      0x1

//
// For legacy consumers
//
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT       ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK        ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK

////////////////////////////////////////////////////////////////////
//
// IA64 PLATFORM ERRORS Definitions
//
// We tried to respect the order in which these error devices are 
// presented in the SAL specs.

//
// IA64 ERRORS: _ERR_TYPE definitions
//
// Warning 04/01/01: "ERR_TYPE" or "ERROR_TYPE" are already used in the NT namespace.
//

typedef enum _ERR_TYPES    {
// Generic error types:
    ERR_INTERNAL = 1,         // Error detected internal to the component
    ERR_BUS      = 16,        // Error detected in the bus
// Detailed Internal Error Types:
    ERR_MEM      = 4,         // Storage error in memory (DRAM)
    ERR_TLB      = 5,         // Storage error in TLB
    ERR_CACHE    = 6,         // Storage error in cache
    ERR_FUNCTION = 7,         // Error in one or more functional units
    ERR_SELFTEST = 8,         // Component failed self test
    ERR_FLOW     = 9,         // Overflow or Undervalue of internal queue
// Detailed Bus Error Types:
    ERR_MAP      = 17,        // Virtual address not found on IO-TLB or IO-PDIR
    ERR_IMPROPER = 18,        // Improper access error
    ERR_UNIMPL   = 19,        // Access to a memory address which is not mapped to any component
    ERR_LOL      = 20,        // Loss Of Lockstep
    ERR_RESPONSE = 21,        // Response to which there is no associated request
    ERR_PARITY   = 22,        // Bus parity error
    ERR_PROTOCOL = 23,        // Detection of a protocol error
    ERR_ERROR    = 24,        // Detection of PATH_ERROR
    ERR_TIMEOUT  = 25,        // Bus operation time-out
    ERR_POISONED = 26,        // A read was issued to data which has been poisoned
} _ERR_TYPE;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highest severity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow 
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS, *PERROR_STATUS;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

//
// IA64 ERRORS: Platform ERROR_MEMORY device definitions
//
// With reference to the ACPI Memory Device.
//

#define ERROR_MEMORY_GUID \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MEMORY_VALID    {
    ULONGLONG     Valid;
    struct {                                 // Bits
        ULONGLONG ErrorStatus:1;             //       0: Error Status valid bit
        ULONGLONG PhysicalAddress:1;         //       1: Physical Address valid bit
        ULONGLONG AddressMask:1;             //       2: Address Mask bit
        ULONGLONG Node:1;                    //       3: Node valid bit
        ULONGLONG Card:1;                    //       4: Card valid bit
        ULONGLONG Module:1;                  //       5: Module valid bit
        ULONGLONG Bank:1;                    //       6: Bank valid bit
        ULONGLONG Device:1;                  //       7: Device valid bit
        ULONGLONG Row:1;                     //       8: Row valid bit
        ULONGLONG Column:1;                  //       9: Column valid bit
        ULONGLONG BitPosition:1;             //      10: Bit Position valid bit
        ULONGLONG RequestorId:1;             //      11: Platform Requestor Id valid bit
        ULONGLONG ResponderId:1;             //      12: Platform Respinder Id valid bit
        ULONGLONG TargetId:1;                //      13: Platform Target    Id valid bit
        ULONGLONG BusSpecificData:1;         //      14: Platform Bus specific data valid bit
        ULONGLONG OemId:1;                   //      15: Platform OEM id   valid bit
        ULONGLONG OemData:1;                 //      16: Platform OEM data valid bit
        ULONGLONG Reserved:47;               //   63-17: Reserved
    };
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY    {
    ERROR_SECTION_HEADER  Header;
    ERROR_MEMORY_VALID    Valid;
    ERROR_STATUS          ErrorStatus;         // Memory device error status fields - See ERROR_STATUS defs.
    ULONGLONG             PhysicalAddress;     // Physical Address of the memory error
    ULONGLONG             PhysicalAddressMask; // Valid bits for Physical Address
    USHORT                Node;                // Node identifier in a multi-node system
    USHORT                Card;                // Card   number of the memory error location
    USHORT                Module;              // Module number of the memory error location
    USHORT                Bank;                // Bank   number of the memory error location
    USHORT                Device;              // Device number of the memory error location
    USHORT                Row;                 // Row    number of the memory error location
    USHORT                Column;              // Column number of the memory error location
    USHORT                BitPosition;         // Bit within the word that is in error
    ULONGLONG             RequestorId;         // Hardware address of the device or component initiating transaction
    ULONGLONG             ResponderId;         // Hardware address of the responder to transaction
    ULONGLONG             TargetId;            // Hardware address of intended target of transaction       
    ULONGLONG             BusSpecificData;     // Bus dependent data of the on-board processor. It is a OEM specific field.
    UCHAR                 OemId[16];           // OEM defined identification for memory controller
    ERROR_OEM_DATA        OemData;     // OEM platform specific data. 
} ERROR_MEMORY, *PERROR_MEMORY;

//
// IA64 ERRORS: Platform ERROR_PCI_BUS device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_BUS_GUID \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_BUS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorStatus:1;            //       0: Error Status             valid bit
        ULONGLONG ErrorType:1;              //       1: Error Type               valid bit
        ULONGLONG Id:1;                     //       2: Identifier               valid bit
        ULONGLONG Address:1;                //       3: Address                  valid bit
        ULONGLONG Data:1;                   //       4: Data                     valid bit
        ULONGLONG CmdType:1;                //       5: Command Type             valid bit
        ULONGLONG RequestorId:1;            //       6: Requestor Identifier     valid bit
        ULONGLONG ResponderId:1;            //       7: Responder Identifier     valid bit
        ULONGLONG TargetId:1;               //       8: Target    Identifer      valid bit
        ULONGLONG OemId:1;                  //       9: OEM Identification       valid bit
        ULONGLONG OemData:1;                //      10: OEM Data                 valid bit
        ULONGLONG Reserved:53;              //   11-63: Reserved
    };
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
    UCHAR Type;
    UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)
//      PciOtherErrors           Reserved

typedef struct _ERROR_PCI_BUS_ID    {
    UCHAR BusNumber;         // Bus     Number
    UCHAR SegmentNumber;     // Segment Number
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS    {
    ERROR_SECTION_HEADER  Header;
    ERROR_PCI_BUS_VALID   Valid;
    ERROR_STATUS          ErrorStatus;    // PCI Bus Error Status - See ERROR_STATUS definitions.
    ERROR_PCI_BUS_TYPE    Type;           // PCI Bus Error Type 
    ERROR_PCI_BUS_ID      Id;             // PCI Bus Identifier      
    UCHAR                 Reserved[4];    // Reserved
    ULONGLONG             Address;        // Memory or IO Address on the PCI bus at
                                          // the time of the event
    ULONGLONG             Data;           // Data on the PCI bus at time of the event
    ULONGLONG             CmdType;        // Bus Command or Operation at time of the event
    ULONGLONG             RequestorId;    // Bus Requestor Identifier at time of the event
    ULONGLONG             ResponderId;    // Bus Responder Identifier at time of the event
    ULONGLONG             TargetId;       // Intended Bus Target Identifier at time of the event
    UCHAR                 OemId[16];      // OEM defined identification for pci bus
    ERROR_OEM_DATA        OemData;        // OEM specific data. 
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

//
// IA64 ERRORS: Platform ERROR_PCI_COMPONENT device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_COMPONENT_GUID \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_COMPONENT_VALID   {
    ULONGLONG Valid;
    struct {                                       // Bits:
        ULONGLONG ErrorStatus:1;                   //    0: Error Status valid bit
        ULONGLONG Info:1;                          //    1: Information  valid bit
        ULONGLONG MemoryMappedRegistersPairs:1;    //    2: Number of Memory Mapped Registers Pairs valid bit
        ULONGLONG ProgrammedIORegistersPairs:1;    //    3: Number of Programmed IO Registers Pairs valid bit
        ULONGLONG RegistersDataPairs:1;            //    4: Memory Mapped Registers Pairs valid bit
        ULONGLONG OemData:1;                       //    5: OEM Data valid bit.
        ULONGLONG Reserved:58;                     // 63-6: Reserved
    };
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {  // Bytes:
   USHORT VendorId;                         //   0-1: Vendor Identifier
   USHORT DeviceId;                         //   2-3: Device Identifier
   UCHAR  ClassCodeInterface;               //     4: Class Code.Interface field
   UCHAR  ClassCodeSubClass;                //     5: Class Code.SubClass  field
   UCHAR  ClassCodeBaseClass;               //     6: Class Code.BaseClass field
   UCHAR  FunctionNumber;                   //     7: Function Number
   UCHAR  DeviceNumber;                     //     8: Device Number
   UCHAR  BusNumber;                        //     9: Bus Number
   UCHAR  SegmentNumber;                    //    10: Segment Number
   UCHAR  Reserved0;    
   ULONG  Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT  {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;                 // Component Error Status
     ERROR_PCI_COMPONENT_INFO    Info;                        // Component Information
     ULONG                       MemoryMappedRegistersPairs;  // Number of Memory Mapped Registers Pairs
     ULONG                       ProgrammedIORegistersPairs;  // Number of Programmed IO Registers Pairs
#if 0
     ULONGLONG                   RegistersPairs[/* 2 * (MemoryMappedRegistersPairs + ProgrammedIORegistersPairs) */];
     ERROR_OEM_DATA              OemData;
#endif // 0
 } ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

//
// IA64 ERRORS: Platform ERROR_SYSTEM_EVENT_LOG device definitions
//
// With reference to the IPMI System Event Log.
//

#define ERROR_SYSTEM_EVENT_LOG_GUID \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG RecordId:1;               //       0: Record Identifier     valid bit
        ULONGLONG RecordType:1;             //       1: Record Type           valid bit
        ULONGLONG GeneratorId:1;            //       2: Generator Identifier  valid bit
        ULONGLONG EVMRev:1;                 //       3: Event Format Revision valid bit
        ULONGLONG SensorType:1;             //       4: Sensor Type           valid bit
        ULONGLONG SensorNum:1;              //       5: Sensor Number         valid bit
        ULONGLONG EventDirType:1;           //       6: Event Dir             valid bit
        ULONGLONG EventData1:1;             //       7: Event Data1           valid bit
        ULONGLONG EventData2:1;             //       8: Event Data2           valid bit
        ULONGLONG EventData3:1;             //       9: Event Data3           valid bit
        ULONGLONG Reserved:54;              //   10-63:
    };
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG    {
    ERROR_SECTION_HEADER         Header;
    ERROR_SYSTEM_EVENT_LOG_VALID Valid;
    USHORT                       RecordId;     // Record Identifier used for SEL record access
    UCHAR                        RecordType;   // Record Type:
                                               //   0x02 - System Event Record
                                               //   0xC0 - 0xDF OEM     time stamped, bytes 8-16 OEM defined
                                               //   0xE0 - 0xFF OEM non-time stamped, bytes 4-16 OEM defined
    ULONG                        TimeStamp;    // Time stamp of the event log
    USHORT                       GeneratorId;  // Software ID if event was generated by software
                                               //   Byte 1:
                                               //       Bit 0   - set to 1 when using system software
                                               //       Bit 7:1 - 7-bit system ID
                                               //   Byte 2:
                                               //       Bit 1:0 - IPMB device LUN if byte 1 holds slave
                                               //                 address, 0x0 otherwise
                                               //       Bit 7:2 - Reserved.
    UCHAR                        EVMRevision;  // Error message format version
    UCHAR                        SensorType;   // Sensor Type code of the sensor that generated event
    UCHAR                        SensorNumber; // Number of the sensor that generated event
    UCHAR                        EventDir;     // Event Dir
                                               //   Bit 7 - 0: asserted, 1: desasserted
                                               // Event Type
                                               //   Bit 6:0 - Event Type code
    UCHAR                        Data1;        // Event data field
    UCHAR                        Data2;        // Event data field
    UCHAR                        Data3;        // Event data field
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

//
// IA64 ERRORS: Platform ERROR_SMBIOS device definitions
//
// With reference to the SMBIOS Specifications.
//

#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SMBIOS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG EventType:1;              //       0: Event Type valid bit
        ULONGLONG Length:1;                 //       1: Length     valid bit
        ULONGLONG TimeStamp:1;              //       2: Time Stamp valid bit
        ULONGLONG OemData:1;                //       3: Data       valid bit
        ULONGLONG Reserved:60;              //    4-63:
    };
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

//
// ERROR_SMBIOS.Type definitions
//

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;
// enum values defined in SMBIOS 2.3 - 3.3.16.6.1

typedef struct _ERROR_SMBIOS    {
    ERROR_SECTION_HEADER     Header;
    ERROR_SMBIOS_VALID       Valid;
    ERROR_SMBIOS_EVENT_TYPE  EventType;   // Event Type
    UCHAR                    Length;      // Length of the error information in bytes
    ERROR_TIMESTAMP          TimeStamp;   // Event Time Stamp
    ERROR_OEM_DATA           OemData;     // Optional data validated by SMBIOS.Valid.Data.
} ERROR_SMBIOS, *PERROR_SMBIOS;

//
// IA64 ERRORS: Platform Specific error device definitions
//

#define ERROR_PLATFORM_SPECIFIC_GUID \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC  {
     ERROR_SECTION_HEADER           Header;
     ERROR_PLATFORM_SPECIFIC_VALID  Valid;
     ERROR_STATUS                   ErrorStatus; // Platform Generic Error Status
     ULONGLONG                      RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                      ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                      TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA        BusSpecificData; // OEM specific Bus dependent data
     UCHAR                          OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA                 OemData;         // OEM specific data 
#if 0
     UCHAR                          OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

//
// IA64 ERRORS: Platform Bus error device definitions
//

#define ERROR_PLATFORM_BUS_GUID \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_BUS_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
     ERROR_SECTION_HEADER        Header;
     ERROR_PLATFORM_BUS_VALID    Valid;
     ERROR_STATUS                ErrorStatus;       // Bus Error Status
     ULONGLONG                   RequestorId;       // Bus Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Bus Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

//
// IA64 ERRORS: Platform Host Controller error device definitions
//

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}
    

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;       // Host Controller Error Status
     ULONGLONG                   RequestorId;       // Host controller Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Host controller Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Host controller intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

//
// IA64 ERROR_LOGRECORDS definitions
//
//  MCA_EXCEPTION,
//  CMC_EXCEPTION,
//  CPE_EXCEPTION.
//

// For compatibility with previous versions of the definitions:
typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;

typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;    // Machine Check Abort
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#endif // _IA64_

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#endif // _MCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\makefile.inc ===
$(O)\winerror.h : winerror.mc
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) -d $(MC_FLAGS) $?

$(O)\dpfilter.h : componentid.tab
    genlvl -t $(O)

$(O)\mcaia64.mof: mcaia64.mof
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) mcaia64.mof > $(O)\mcaia64.mof

$(O)\ntrtl.h : ntrtl.w $(O)\dpfilter.h makefile.inc
    type ntrtl.w > $@
    type $(O)\dpfilter.h >> $@
    type << >> $@
// end_ntddk end_wdm end_nthal end_ntifs end_ntndis
#endif // _NTRTL_
<<

$(O)\pooltag.txt : pooltag.w
    copy $? $@

$(O)\pooltag.pri : pooltag.w
    copy $? $@

ZWAPI_DEPENDS = \
    $(SDK_INC_PATH)\ntdsapi.h \
    ntelfapi.w \
    ntexapi_h.w \
    ntioapi.w \
    ntkeapi.w \
    $(SDK_INC_PATH)\ntlpcapi.h \
    $(SDK_INC_PATH)\ntlsapi.h \
    ntmmapi.w \
    $(SDK_INC_PATH)\ntmsapi.h \
    ntobapi.w \
    ntpnpapi.w \
    ntpoapi.w \
    ntpsapi.w \
    ntregapi.w \
    $(SDK_INC_PATH)\ntseapi.h \
    $(SDK_INC_PATH)\ntsecapi.h \
    ntwmi.w \
    ntxcapi.w

$(O)\zwapi.h : $(ZWAPI_DEPENDS)
    -del $@
    zwapi -o $@ $(ZWAPI_DEPENDS)
    type << >> $@

#if _MSC_VER > 1000
#pragma once
#endif

<<

WINNT_DEPENDS = ntdef.w \
                $(O)\ntstatus.h \
                ntkeapi.w \
!if exist(ntamd64.w)
                ntamd64.w \
!endif
                ntalpha.w \
                nti386.w \
                ntmips.w \
                ntppc.w \
                ntmppc.w \
                ntia64.w \
                ntxcapi.w \
                $(SDK_INC_PATH)\ntseapi.h \
                ntpsapi.w \
                ntexapi_h.w \
                ntmmapi.w \
                ntioapi.w \
                ntobapi.w \
                ntpoapi.w \
                ntimage.w \
                $(O)\ntrtl.h  \
                nturtl.w  \
                ntldr.w  \
                ntelfapi.w \
                ntregapi.w \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntddtape.h \
                nxalpha.w \
                nxamd64.w \
                nxia64.w \
                nxi386.w \
                sxstypes.w \

########################################################################
# winnt.h
#

$(O)\winnt.h: $(WINNT_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/

#ifndef _WINNT_
#define _WINNT_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -f2 -o $@ -lt winnt -bt begin_winnt end_winnt $(WINNT_DEPENDS)
    type << >> $@

#ifdef __cplusplus
}
#endif

#endif /* _WINNT_ */

<<

########################################################################
# winnt.rh
#

$(O)\winnt.rh: ntdef.w makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winnt.rh

Abstract:

    This module defines the 32-Bit Windows resource codes from winnt.h

Revision History:

--*/
<<
    hextract -o $@ -lt r_winnt -bt begin_r_winnt end_r_winnt ntdef.w

#
# winbase.h, winbasep.h, wbasek.h, winbase.x, winbasep.x
#

$(O)\winbase.x $(O)\winbasep.x $(O)\wbasek.h : winbase.w
    hsplit -e -x $(O)\wbasek.h userk -o $(O)\winbase.x $(O)\winbasep.x winbase.w

$(O)\winbase.y : $(O)\winbase.x
    wcshdr < $? > $@

$(O)\winbase.inl: $(O)\winbase.h

$(O)\winbase.h : $(O)\winbase.y
    shfusion2 $? > $@ SetStubsFile('$(O)\winbase.inl')

$(O)\winbasep.h : $(O)\winbasep.x
    wcshdr < $? > $@

#
# sxstypes.h
#
$(O)\sxstypes.h : sxstypes.w
    echo. > $@
    hextract -o $@ -xt winnt_only -lt sxstypes -bt begin_sxstypes end_sxstypes $?

#
# winnls.h, winnlsp.h, winnls.x
#

$(O)\winnls.x $(O)\winnlsp.h: winnls.w
    hsplit -e -o $(O)\winnls.x $(O)\winnlsp.h winnls.w

$(O)\winnls.h: $(O)\winnls.x
    wcshdr < $? > $@

#
# winreg.h, winregp.x, winreg.x
#

$(O)\winreg.x $(O)\winregp.x: winreg.w
    hsplit -e -o $(O)\winreg.x $(O)\winregp.x winreg.w

$(O)\winreg.h: $(O)\winreg.x
    wcshdr < $? > $@

#
# wmidata.h, wmicore.bmf, wmicore.mof
#

$(O)\wmicore.bmf: $(O)\wmicore.mof

$(O)\wmidata.h : $(O)\wmicore.bmf
    wmimofck -m -h$@ $?
    
#
# lzexpand.h
#

$(O)\lzexpand.h : lzexpand.x
    wcshdr < $? > $@


#
# winsvc.h
#

$(O)\winsvc.h: winsvc.x
    wcshdr < $? > $@


#
# strsafe.h, ntstrsafe.h
#

STRSAFE_DEPENDS = strsafe.w

$(O)\ntstrsafe.h : $(STRSAFE_DEPENDS) ntstrsafe.mng
    type << > $@
<<
    hextract -o $@ -bt begin_ntstrsafe end_ntstrsafe $(STRSAFE_DEPENDS)
    -munge ntstrsafe.mng -k -m -i -l -t $@ >> NUL

$(O)\strsafe.h : $(STRSAFE_DEPENDS)
    type << > $@
<<
    hextract -o $@ -bt begin_strsafe end_strsafe $(STRSAFE_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\oprghdlr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    oprghdlr.h

Abstract:

    This header file contains the shared structures for the ACPI op region
    registration DLL.
    
Author:

    Vincent Geglia 09-Feb-2000

Environment:

    Kernel mode

Notes:

    
Revision History:


--*/

#include "wdm.h"

//
// Make sure that we define the right calling convention
//

#ifdef EXPORT
  #undef EXPORT
#endif
#define EXPORT  __cdecl

//
// Op region handler and callback function prototypes
//

typedef VOID (EXPORT *PACPI_OP_REGION_CALLBACK)();

typedef
NTSTATUS
(EXPORT *PACPI_OP_REGION_HANDLER) (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

//
// Exposed function prototypes
//

NTSTATUS
RegisterOpRegionHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG AccessType,
    IN ULONG RegionSpace,
    IN PACPI_OP_REGION_HANDLER Handler,
    IN PVOID Context,
    IN ULONG Flags,
    IN OUT PVOID *OperationRegionObject
    );

NTSTATUS
DeRegisterOpRegionHandler (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PVOID OperationRegionObject
                           );

//
// Exposed definitions
//

//
// Access types for OpRegions
//
#define ACPI_OPREGION_ACCESS_AS_RAW                         0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED                      0x2

//
// Allowable region spaces
//
#define ACPI_OPREGION_REGION_SPACE_MEMORY                   0x0
#define ACPI_OPREGION_REGION_SPACE_IO                       0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG               0x2
#define ACPI_OPREGION_REGION_SPACE_EC                       0x3
#define ACPI_OPREGION_REGION_SPACE_SMB                      0x4
#define ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG              0x5
#define ACPI_OPREGION_REGION_SPACE_PCIBARTARGET             0x6

//
// Operation to perform on region
//
#define ACPI_OPREGION_READ                                  0x0
#define ACPI_OPREGION_WRITE                                 0x1

//
// Flag definitions for op region registration
//

#define ACPI_OPREGION_ACCESS_AT_HIGH_LEVEL                  0x1 // Indicates the handler function can be called at HIGH_LEVEL IRQL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\ntacpi.h ===
;/*++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Module Name:
;
;   ntacpi.h
;
; Abstract:
;
;
;   This module contains definitions specific to the HAL's
;   ACPI function.
;
; Author:
;
;   Jake Oshins (jakeo) Feb. 18, 1997
;
; Revision History:
;
;-

if 0        ; Begin C only code         */

#ifndef _ACPI_H_
#define _ACPI_H_


#define SLEEP_STATE_FLUSH_CACHE         0x1
#define SLEEP_STATE_FIRMWARE_RESTART    0x2
#define SLEEP_STATE_SAVE_MOTHERBOARD    0x4
#define SLEEP_STATE_OFF                 0x8
#define SLEEP_STATE_RESTART_OTHER_PROCESSORS    0x10

typedef struct {
    union {
        struct {
            ULONG       Pm1aVal:4;
            ULONG       Pm1bVal:4;
            ULONG       Flags:24;
        } bits;
        ULONG   AsULONG;
    };
} SLEEP_STATE_CONTEXT, *PSLEEP_STATE_CONTEXT;


//
// ACPI Register definitions
//

#define P_LVL2          4
#define PBLK_THT_EN                     0x10

//
// Register layout of PM1x_EVT register
// Note also defined in acpiregs.h
//

#define PM1_PWRBTN_STS_BIT      8
#define PM1_PWRBTN_STS          (1 << PM1_PWRBTN_STS_BIT)

//
// Register layout of PM1x_CTL
//

#define SCI_EN              1
#define BM_RLD              2
#define CTL_IGNORE          0x200
#define SLP_TYP_SHIFT       10
#define SLP_EN              0x2000

#define CTL_PRESERVE        (SCI_EN + BM_RLD + CTL_IGNORE)

#define PM_TMR_FREQ     3579545



//
// HAL's table
//

typedef enum {
    HalAcpiTimerInit,
    HalAcpiTimerInterrupt,
    HalAcpiMachineStateInit,
    HalAcpiQueryFlags,
    HalPicStateIntact,
    HalRestorePicState,
    HalPciInterfaceReadConfig,
    HalPciInterfaceWriteConfig,
    HalSetVectorState,
    HalGetIOApicVersion,
    HalSetMaxLegacyPciBusNumber,
    HalIsVectorValid,
    HalAcpiMaxFunction
} HAL_DISPATCH_FUNCTION;

typedef
VOID
(*pHalAcpiTimerInit)(
    IN ULONG    TimerPort,
    IN BOOLEAN  TimerValExt
    );

typedef
VOID
(*pHalAcpiTimerInterrupt)(
    VOID
    );

typedef struct {
    ULONG   Count;
    ULONG   Pblk[1];
} PROCESSOR_INIT, *PPROCESSOR_INIT;

#define HAL_C1_SUPPORTED 0x01
#define HAL_C2_SUPPORTED 0x02
#define HAL_C3_SUPPORTED 0x04
#define HAL_S1_SUPPORTED 0x08
#define HAL_S2_SUPPORTED 0x10
#define HAL_S3_SUPPORTED 0x20
#define HAL_S4_SUPPORTED 0x40
#define HAL_S5_SUPPORTED 0x80

typedef struct {
    BOOLEAN     Supported;
    UCHAR       Pm1aVal;
    UCHAR       Pm1bVal;
} HAL_SLEEP_VAL, *PHAL_SLEEP_VAL;

typedef
VOID
(*pHalAcpiMachineStateInit)(
    IN  PPROCESSOR_INIT ProcInit,
    IN  PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG          PicVal
    );

typedef
ULONG
(*pHalAcpiQueryFlags)(
    VOID
    );

typedef
BOOLEAN
(*pHalPicStateIntact)(
    VOID
    );

typedef
VOID
(*pHalRestorePicState)(
    VOID
    );

typedef
ULONG
(*pHalInterfaceReadWriteConfig)(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Flags for interrupt vectors
//

#define VECTOR_MODE         1
#define VECTOR_LEVEL        1
#define VECTOR_EDGE         0
#define VECTOR_POLARITY     2
#define VECTOR_ACTIVE_LOW   2
#define VECTOR_ACTIVE_HIGH  0

//
// Vector Type:
//
// VECTOR_SIGNAL = standard edge-triggered or
//         level-sensitive interrupt vector
//
// VECTOR_MESSAGE = an MSI (Message Signalled Interrupt) vector
//

#define VECTOR_TYPE         4
#define VECTOR_SIGNAL       0
#define VECTOR_MESSAGE      4

#define IS_LEVEL_TRIGGERED(vectorFlags) \
    (vectorFlags & VECTOR_LEVEL)

#define IS_EDGE_TRIGGERED(vectorFlags) \
    !(vectorFlags & VECTOR_LEVEL)

#define IS_ACTIVE_LOW(vectorFlags) \
    (vectorFlags & VECTOR_ACTIVE_LOW)

#define IS_ACTIVE_HIGH(vectorFlags) \
    !(vectorFlags & VECTOR_ACTIVE_LOW)

typedef
VOID
(*pHalSetVectorState)(
    IN ULONG Vector,
    IN ULONG Flags
    );

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    );

#define HAL_ACPI_PCI_RESOURCES    0x01
#define HAL_ACPI_PRT_SUPPORT      0x02

typedef
ULONG
(*pHalGetIOApicVersion)(
    IN ULONG ApicNo
    );

typedef
VOID
(*pHalSetMaxLegacyPciBusNumber)(
    IN ULONG BusNumber
    );

typedef
BOOLEAN
(*pHalIsVectorValid)(
    IN ULONG Vector
    );

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    );

//
//  typedef struct _PM_DISPATCH_TABLE {
//      ULONG   Signature;
//      ULONG   Version;
//      PVOID   Function[1];
//  } PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;
//

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pHalAcpiTimerInit               HalpAcpiTimerInit;
    pHalAcpiTimerInterrupt          HalpAcpiTimerInterrupt;
    pHalAcpiMachineStateInit        HalpAcpiMachineStateInit;
    pHalAcpiQueryFlags              HalpAcpiQueryFlags;
    pHalPicStateIntact              HalxPicStateIntact;
    pHalRestorePicState             HalxRestorePicState;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceReadConfig;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceWriteConfig;
    pHalSetVectorState              HalpSetVectorState;
    pHalGetIOApicVersion            HalpGetIOApicVersion;
    pHalSetMaxLegacyPciBusNumber    HalpSetMaxLegacyPciBusNumber;
    pHalIsVectorValid               HalpIsVectorValid;
} HAL_ACPI_DISPATCH_TABLE, *PHAL_ACPI_DISPATCH_TABLE;

#define HAL_ACPI_DISPATCH_SIGNATURE   'HAL '
#define HAL_ACPI_DISPATCH_VERSION     2

#define HalAcpiTimerInit            ((pHalAcpiTimerInit)PmHalDispatchTable->Function[HalAcpiTimerInit])
#define HalAcpiTimerInterrupt       ((pHalAcpiTimerInterrupt)PmHalDispatchTable->Function[HalAcpiTimerInterrupt])
#define HalAcpiMachineStateInit     ((pHalAcpiMachineStateInit)PmHalDispatchTable->Function[HalAcpiMachineStateInit])
#define HalPicStateIntact           ((pHalPicStateIntact)PmHalDispatchTable->Function[HalPicStateIntact])
#define HalRestorePicState          ((pHalRestorePicState)PmHalDispatchTable->Function[HalRestorePicState])
#define HalPciInterfaceReadConfig   ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceReadConfig])
#define HalPciInterfaceWriteConfig  ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceWriteConfig])
#define HalSetVectorState           ((pHalSetVectorState)PmHalDispatchTable->Function[HalSetVectorState])
#define HalGetIOApicVersion         ((pHalGetIOApicVersion)PmHalDispatchTable->Function[HalGetIOApicVersion])
#define HalSetMaxLegacyPciBusNumber ((pHalSetMaxLegacyPciBusNumber)PmHalDispatchTable->Function[HalSetMaxLegacyPciBusNumber])
#define HalIsVectorValid            ((pHalIsVectorValid)PmHalDispatchTable->Function[HalIsVectorValid])

extern PPM_DISPATCH_TABLE PmAcpiDispatchTable;
extern PPM_DISPATCH_TABLE PmHalDispatchTable;

//
// ACPI driver's table
//
typedef enum {
    AcpiEnableDisableGPEvents,
    AcpiInitEnableAcpi,
    AcpiGpeEnableWakeEvents,
    AcpiMaxFunction
} ACPI_DISPATCH_FUNCTION;

typedef
VOID
(*pAcpiEnableDisableGPEvents) (
    IN BOOLEAN Enable
    );

typedef
VOID
(*pAcpiInitEnableAcpi) (
    IN BOOLEAN ReEnable
    );

typedef
VOID
(*pAcpiGpeEnableWakeEvents)(
    VOID
    );

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pAcpiEnableDisableGPEvents    AcpipEnableDisableGPEvents;
    pAcpiInitEnableAcpi           AcpipInitEnableAcpi;
    pAcpiGpeEnableWakeEvents      AcpipGpeEnableWakeEvents;
} ACPI_HAL_DISPATCH_TABLE, *PACPI_HAL_DISPATCH_TABLE;

#define ACPI_HAL_DISPATCH_SIGNATURE   'ACPI'
#define ACPI_HAL_DISPATCH_VERSION     1

#define AcpiEnableDisableGPEvents       (*(pAcpiEnableDisableGPEvents)PmAcpiDispatchTable->Function[AcpiEnableDisableGPEvents])
#define AcpiInitEnableAcpi              (*(pAcpiInitEnableAcpi)PmAcpiDispatchTable->Function[AcpiInitEnableAcpi])
#define AcpiGpeEnableWakeEvents         (*(pAcpiGpeEnableWakeEvents)PmAcpiDispatchTable->Function[AcpiGpeEnableWakeEvents])

// from detect\i386\acpibios.h
typedef struct {
    PHYSICAL_ADDRESS    Base;
    LARGE_INTEGER       Length;
    ULONGLONG           Type;
} ACPI_E820_ENTRY, *PACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONGLONG           Count;
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE;
 
typedef ACPI_BIOS_MULTI_NODE UNALIGNED *PACPI_BIOS_MULTI_NODE;

typedef enum {
    AcpiAddressRangeMemory = 1,
    AcpiAddressRangeReserved,
    AcpiAddressRangeACPI,
    AcpiAddressRangeNVS,
    AcpiAddressRangeMaximum,
} ACPI_BIOS_E820_TYPE, *PACPI_BIOS_E820_TYPE;


NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    );

#endif //_ACPI_H_

/*
endif
;
;  Begin assembly part of the definitions
;


;
; Register layout of ACPI processor register block
;

P_CNT                   equ     0
P_LVL2                  equ     4
P_LVL3                  equ     5


;
; Register layout of PM1x_EVT register
;

BM_STS              equ       10h
WAK_STS             equ     8000h

;
; Register layout of PM1x_Enable
;

TMR_EN              equ     0001h
GBL_EN              equ     0020h
PWRBTN_EN           equ     0100h
SLPBTN_EN           equ     0200h
RTC_EN              equ     0400h

;
; Register layout of PM1x_CTL
;

SCI_EN              equ     1
BM_RLD              equ     2
CTL_IGNORE          equ     200h
SLP_TYP_SHIFT       equ     10
SLP_EN              equ     2000h

CTL_PRESERVE        equ     (SCI_EN + BM_RLD + CTL_IGNORE)

;
; Register layout of PM2_CNT
;

ARB_DIS             equ     1

;
; ACPI registers, as laid out in HalpFixedAcpiDescTable
;

PM1a_EVT        EQU _HalpFixedAcpiDescTable + 56
PM1b_EVT        EQU _HalpFixedAcpiDescTable + 60
PM1_EVT_LEN     EQU _HalpFixedAcpiDescTable + 88

PM1a_CNT        EQU _HalpFixedAcpiDescTable + 64
PM1b_CNT        EQU _HalpFixedAcpiDescTable + 68

PM2_CNT_BLK     EQU _HalpFixedAcpiDescTable + 72

PM_TMR_BLK      EQU _HalpFixedAcpiDescTable + 76
PM_TMR_FREQ     EQU 3579545

GPE0_BLK        EQU _HalpFixedAcpiDescTable + 80
GPE1_BLK        EQU _HalpFixedAcpiDescTable + 84

GPE0_BLK_LEN    EQU _HalpFixedAcpiDescTable + 92
GPE1_BLK_LEN    EQU _HalpFixedAcpiDescTable + 93

FLUSH_SIZE      EQU _HalpFixedAcpiDescTable + 100
FLUSH_STRIDE    EQU _HalpFixedAcpiDescTable + 102

DUTY_OFFSET     EQU _HalpFixedAcpiDescTable + 104

RTC_DAY_ALRM    EQU _HalpFixedAcpiDescTable + 106
RTC_MON_ALRM    EQU _HalpFixedAcpiDescTable + 107
RTC_CENTURY     EQU _HalpFixedAcpiDescTable + 108
FADT_FLAGS      EQU _HalpFixedAcpiDescTable + 112

;
; FADT flag values
;
WBINVD_SUPPORTED    EQU 1
WBINVD_FLUSH        EQU 2

;
GeneralWakeupEnable EQU 0
RtcWakeupEnable     EQU 1

;
; Constants used in the Context parameter to HaliAcpiSleep
;  (must match C code above)
;
SLEEP_STATE_FLUSH_CACHE         EQU 1
SLEEP_STATE_FIRMWARE_RESTART    EQU 2
SLEEP_STATE_SAVE_MOTHERBOARD    EQU 4
SLEEP_STATE_OFF                 EQU 8
SLEEP_STATE_RESTART_OTHER_PROCESSORS    EQU 10h
CONTEXT_FLAG_SHIFT              EQU 8


;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\loadperf.h ===
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:
    loadperf.h

Abstract:
    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History
    16-Nov-95   Created (a-robw)
--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument
#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR) 1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR) 2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR) 4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR) 8)

LOADPERF_FUNCTION
InstallPerfDllW(
    IN  LPCWSTR   szComputerName,
    IN  LPCWSTR   lpIniFile,
    IN  ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA(
    IN  LPCSTR    szComputerName,
    IN  LPCSTR    lpIniFile,
    IN  ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA(
    IN  LPSTR     lpCommandLine,
    IN  BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW(
    IN  LPWSTR    lpCommandLine,
    IN  BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW(
    IN  LPWSTR    lpCommandLine,
    IN  BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA(
    IN  LPSTR     lpCommandLine,
    IN  BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA(
    IN  LPCSTR    szNewCtrFilePath,
    IN  LPCSTR    szNewHlpFilePath,
    IN  LPSTR     szLanguageID,
    IN  ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW(
    IN  LPCWSTR   szNewCtrFilePath,
    IN  LPCWSTR   szNewHlpFilePath,
    IN  LPWSTR    szLanguageID,
    IN  ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA(
    IN  LPCSTR    szReserved,
    IN  LPCSTR    szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW(
    IN  LPCWSTR   szReserved,
    IN  LPCWSTR   szServiceName
);

DWORD
BackupPerfRegistryToFileW(
    IN  LPCWSTR   szFileName,
    IN  LPCWSTR   szCommentString
);

DWORD
RestorePerfRegistryFromFileW(
    IN  LPCWSTR   szFileName,
    IN  LPCWSTR   szLangId
);

#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsA
#define UpdatePerfNameFiles             UpdatePerfNameFilesA
#define SetServiceAsTrusted             SetServiceAsTrustedA
#endif

#ifdef __cplusplus
}
#endif


#endif // _LOADPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\riname.c ===
static PWSTR cszFirst = L"First";
static PWSTR cszLast  = L"Last";
static PWSTR cszUserName = L"Username";
static PWSTR cszMAC   = L"MAC";

static const int iFirst = (sizeof(L"First") / sizeof(WCHAR)) - 1;
static const int iLast  = (sizeof(L"Last" ) / sizeof(WCHAR)) - 1;
static const int iUserName = (sizeof(L"Username") / sizeof(WCHAR)) - 1;
static const int iMAC   = (sizeof(L"MAC"  ) / sizeof(WCHAR)) - 1;

#define STRING_MISSING(_x) (((_x) == NULL) || (*(_x) == 0))

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    )
{
    DWORD error;
    DWORD maxLength;
    DWORD fieldLength;
    WCHAR localString[10];
    WCHAR localFormat[10];
    BOOL padding;
    PWSTR pTemplate;
    PWSTR pOutput;
    PWSTR pOutputEnd;
    PWSTR stringToAdd;
    PWSTR pString;
    BOOL usedUserName;

    pTemplate = Template;
    pOutput = Name;
    pOutputEnd = pOutput + NameLength - 1;

    error = GENNAME_NO_ERROR;
    maxLength = 0;
    usedUserName = FALSE;
    if ( UsedCounter != NULL ) {
        *UsedCounter = FALSE;
    }

    while ( *pTemplate != 0 ) {

        if ( *pTemplate == L'%' ) {

            pTemplate++;
            fieldLength = 0;
            padding = FALSE;
            if ( *pTemplate >= L'0' && *pTemplate <= L'9' ) {
                if (*pTemplate == L'0') {
                    padding = TRUE;
                    //
                    // see if this request to do padding is from the "sample"
                    // entrypoint.  If we're doing padding, we want to make
                    // the sample output show that we will actually do some
                    // padding, so we make our counter small enough to show
                    // the padding.
                    //
                    if (Variables->Counter == 123456789 && 
                        Variables->AllowCounterTruncation &&
                        (0 == wcscmp(Variables->UserName, L"JOHNSMI")) &&
                        (0 == wcscmp(Variables->MacAddress, L"123456789012"))) {
                        Variables->Counter = 1;
                    }
                }
                do {
                    fieldLength = (fieldLength * 10) + (*pTemplate - L'0');
                    pTemplate++;
                } while ( *pTemplate >= L'0' && *pTemplate <= L'9' );
            }

            if ( *pTemplate == L'#' ) {

                DWORD maxCounter;
                DWORD counter;
                DWORD i;

                if (fieldLength > 9) {
                    fieldLength = 9;
                }
                if (fieldLength == 0) {
                    fieldLength = 2;
                }
                if(padding){
                    wsprintf(localFormat,L"%s%d%s", L"%0",fieldLength,L"d");
                } else {
                    wcscpy(localFormat,L"%d");
                }
                
                maxCounter = 10;
                for ( i = 1; i < fieldLength; i++ ) {
                    maxCounter *= 10;
                }

                counter = Variables->Counter;
                if ( counter >= maxCounter ) {
                    if ( !Variables->AllowCounterTruncation ) {
                        return GENNAME_COUNTER_TOO_HIGH;
                    }

                    //
                    // Truncate the counter on the right.
                    //

                    while ( counter > maxCounter ) {
                        counter /= 10;
                    }
                }

                if ( UsedCounter != NULL ) {
                    *UsedCounter = TRUE;
                }

                wsprintf( localString, localFormat, counter );
                stringToAdd = localString;

                pTemplate++;

            } else if ( StrCmpNI( pTemplate, cszFirst, iFirst ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->FirstName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_FIRSTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iFirst;
                
            } else if ( StrCmpNI( pTemplate, cszLast, iLast ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->LastName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_LASTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iLast;

            } else if ( StrCmpNI( pTemplate, cszUserName, iUserName ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                if ( !usedUserName ) {
                    stringToAdd = Variables->UserName;
                    if ( STRING_MISSING(stringToAdd) ) {
                        if ( MissingVariable != NULL ) {
                            *MissingVariable = GENNAME_VARIABLE_USERNAME;
                        }
                        return GENNAME_VARIABLE_MISSING;
                    }
                    usedUserName = TRUE;
                }

                pTemplate += iUserName;

            } else if ( StrCmpNI( pTemplate, cszMAC, iMAC ) == 0 ) {

                if (fieldLength > 12) {
                    fieldLength = 12;
                }
                if (fieldLength == 0) {
                    fieldLength = 12;
                }

                stringToAdd = Variables->MacAddress;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( MissingVariable != NULL ) {
                        *MissingVariable = GENNAME_VARIABLE_MAC;
                    }
                    return GENNAME_VARIABLE_MISSING;
                }

                pTemplate += iMAC;
                
            } else {

                return GENNAME_TEMPLATE_INVALID;
            }

        } else {

            fieldLength = 1;

            localString[0] = *pTemplate;
            localString[1] = 0;
            stringToAdd = localString;

            pTemplate++;
        }

        maxLength += fieldLength;

        pString = stringToAdd;
        for ( pString = stringToAdd;
              (fieldLength > 0) && (*pString != 0);
              fieldLength--, pString++ ) {
            if ( pOutput < pOutputEnd ) {
                *pOutput++ = *pString;
            } else {
                error = GENNAME_NAME_TOO_LONG;
                break;
            }
        }
    }

    if ( MaximumGeneratedNameLength != NULL ) {
        *MaximumGeneratedNameLength = maxLength;
    }

    *pOutput++ = 0;
    
    return error;

} // GenerateNameFromTemplate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\riname.h ===
#define GENNAME_NO_ERROR            0
#define GENNAME_TEMPLATE_INVALID    1
#define GENNAME_COUNTER_TOO_HIGH    2
#define GENNAME_VARIABLE_MISSING    3
#define GENNAME_NAME_TOO_LONG       4

#define GENNAME_VARIABLE_USERNAME   L"USERNAME"
#define GENNAME_VARIABLE_FIRSTNAME  L"USERFIRSTNAME"
#define GENNAME_VARIABLE_LASTNAME   L"USERLASTNAME"
#define GENNAME_VARIABLE_MAC        L"MAC"

typedef struct _GENNAME_VARIABLES {
    PWSTR UserName;
    PWSTR FirstName;
    PWSTR LastName;
    PWSTR MacAddress;
    DWORD Counter;
    BOOL AllowCounterTruncation;
} GENNAME_VARIABLES, *PGENNAME_VARIABLES;

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\seopaque.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    seopaque.h

Abstract:

    This module contains definitions of opaque Security data structures.

    These structures are available to user and kernel security routines
    only.

    This file is not included by including "ntos.h".

Author:

    Jim Kelly (Jimk) 23-Mar-1990

Revision History:

--*/

#ifndef _SEOPAQUE_
#define _SEOPAQUE_

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Structures                                                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Generic ACE structures, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

typedef struct _KNOWN_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG Flags;
    // GUID ObjectType;             // Optionally present
    // GUID InheritedObjectType;    // Optionally present
    ULONG SidStart;
} KNOWN_OBJECT_ACE, *PKNOWN_OBJECT_ACE;

typedef struct _KNOWN_COMPOUND_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} KNOWN_COMPOUND_ACE, *PKNOWN_COMPOUND_ACE;

//typedef struct _KNOWN_IMPERSONATION_ACE {
//    ACE_HEADER Header;
//    ACCESS_MASK Mask;
//    USHORT DataType;
//    USHORT Argument;
//    ULONG Operands;
//} KNOWN_IMPERSONATION_ACE, *PKNOWN_IMPERSONATION_ACE;



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Miscellaneous support macros                                         //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
//  Given a pointer return its word aligned equivalent value
//

#define WordAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 1) & -2)     \
    )

//
//  Given a pointer return its longword aligned equivalent value
//

#define LongAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 3) & -4)     \
    )

//
//  Given a size return its longword aligned equivalent value
//

#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
//  Given a size return its sizeof(PVOID) aligned equivalent value
//

#define PtrAlignSize(Size)  \
    (((ULONG)(Size) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))

//
//  Given a pointer return its quadword aligned equivalent value
//

#define QuadAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 7) & -8)     \
    )

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag) (               \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE \
    )

//
//  This macro clears a single flag in a set of flags
//

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
    }

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// A "known" ACE is one of the types that existed before the introduction of
// compound ACEs.  While the name is no longer as accurate as it used to be,
// it's convenient.
//

#define IsKnownAceType(Ace) (                                     \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 3 ACE.
//

#define IsV3AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 4 ACE.
//

#define IsV4AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid ACE.
//

#define IsMSAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_ACE_TYPE)           \
    )

//
//  Determine if an ace is a standard ace
//

#define IsCompoundAceType(Ace) (                                           \
    (((PACE_HEADER)(Ace))->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))

//
// Test if the ACE is an object ACE.
//

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
    )

//
// Update this macro as new ACL revisions are defined.
//

#define ValidAclRevision(Acl) ((Acl)->AclRevision >= MIN_ACL_REVISION && \
                               (Acl)->AclRevision <= MAX_ACL_REVISION )

//
//  Macro to determine if an ace is to be inherited by a subdirectory
//

#define ContainerInherit(Ace) (                      \
    FlagOn((Ace)->AceFlags, CONTAINER_INHERIT_ACE) \
    )

//
//  Macro to determine if an ace is to be proprogate to a subdirectory.
//  It will if it is inheritable by either a container or non-container
//  and is not explicitly marked for no-propagation.
//

#define Propagate(Ace) (                                              \
    !FlagOn((Ace)->AceFlags, NO_PROPAGATE_INHERIT_ACE)  &&            \
    (FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) ||                 \
     FlagOn(( Ace )->AceFlags, CONTAINER_INHERIT_ACE) )               \
    )

//
//  Macro to determine if an ACE is to be inherited by a sub-object
//

#define ObjectInherit(Ace) (                      \
    FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) \
    )

//
// Macro to determine if an ACE was inherited.
//

#define AceInherited(Ace) (                      \
    FlagOn(( Ace )->AceFlags, INHERITED_ACE) \
    )

//
// Extract the SID from a object ACE
//
#define RtlObjectAceObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_OBJECT_TYPE_PRESENT) != 0 )
#define RtlObjectAceInheritedObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) != 0 )

#define RtlObjectAceSid( Ace ) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define RtlObjectAceObjectType( Ace ) \
     ((GUID *)(RtlObjectAceObjectTypePresent(Ace) ? \
        &((PKNOWN_OBJECT_ACE)(Ace))->SidStart : \
        NULL ))

#define RtlObjectAceInheritedObjectType( Ace ) \
     ((GUID *)(RtlObjectAceInheritedObjectTypePresent(Ace) ? \
        ( RtlObjectAceObjectTypePresent(Ace) ? \
            (PULONG)(((PUCHAR)(&((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + sizeof(GUID)) : \
            &((PKNOWN_OBJECT_ACE)(Ace))->SidStart ) : \
        NULL ))

//
// Comparison routine for two GUIDs.
//
#define RtlpIsEqualGuid(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

//
// Macros for mapping DACL/SACL specific security descriptor control bits
//  to generic control bits.
//
// This mapping allows common routines to manipulate control bits generically
//  and have the appropriate bits set in the security descriptor based
//  on whether to ACL is a DACL or a SACL.
//

#define SEP_ACL_PRESENT             SE_DACL_PRESENT
#define SEP_ACL_DEFAULTED           SE_DACL_DEFAULTED
#define SEP_ACL_AUTO_INHERITED      SE_DACL_AUTO_INHERITED
#define SEP_ACL_PROTECTED           SE_DACL_PROTECTED

#define SEP_ACL_ALL ( \
        SEP_ACL_PRESENT | \
        SEP_ACL_DEFAULTED | \
        SEP_ACL_AUTO_INHERITED | \
        SEP_ACL_PROTECTED )

#define SeControlDaclToGeneric( _Dacl ) \
    ((_Dacl) & SEP_ACL_ALL )

#define SeControlGenericToDacl( _Generic ) \
    ((_Generic) & SEP_ACL_ALL )

#define SeControlSaclToGeneric( _Sacl ) ( \
            (((_Sacl) & SE_SACL_PRESENT) ? SEP_ACL_PRESENT : 0 ) | \
            (((_Sacl) & SE_SACL_DEFAULTED) ? SEP_ACL_DEFAULTED : 0 ) | \
            (((_Sacl) & SE_SACL_AUTO_INHERITED) ? SEP_ACL_AUTO_INHERITED : 0 ) | \
            (((_Sacl) & SE_SACL_PROTECTED) ? SEP_ACL_PROTECTED : 0 ) )

#define SeControlGenericToSacl( _Generic ) ( \
            (((_Generic) & SEP_ACL_PRESENT) ? SE_SACL_PRESENT : 0 ) | \
            (((_Generic) & SEP_ACL_DEFAULTED) ? SE_SACL_DEFAULTED : 0 ) | \
            (((_Generic) & SEP_ACL_AUTO_INHERITED) ? SE_SACL_AUTO_INHERITED : 0 ) | \
            (((_Generic) & SEP_ACL_PROTECTED) ? SE_SACL_PROTECTED : 0 ) )




#endif // _SEOPAQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\smbus.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smbus.h

Abstract:

    SMBus Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// SMB Request packet
//

#define SMB_MAX_DATA_SIZE   32

typedef struct {
    UCHAR       Status;             // Completion status
    UCHAR       Protocol;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       BlockLength;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// Protocol values
//

#define SMB_WRITE_QUICK                 0x00    // Issue quick command data bit = 0
#define SMB_READ_QUICK                  0x01    // Issue quick command data bit = 1
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0A
#define SMB_BLOCK_PROCESS_CALL          0x0B
#define SMB_MAXIMUM_PROTOCOL            0x0B

//
// SMB Bus Status codes
//

#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1A

//
// Alarm register/deregister requests
//

typedef
VOID
(*SMB_ALARM_NOTIFY) (
    PVOID       Context,
    UCHAR       Address,
    USHORT      Data
    );

// input buffer is SMB_REGISTER_ALARM.  output buffer is PVOID handle for registration.
// PVOID is passed in via DEREGISTER request to free registration

typedef struct {
    UCHAR               MinAddress;     // Min address for notifications
    UCHAR               MaxAddress;     // Max address for notifications
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

//
// Internal ioctls to SMB class driver
//

#define SMB_BUS_REQUEST             CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_REGISTER_ALARM_NOTIFY   CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_DEREGISTER_ALARM_NOTIFY CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Shared SMB Class / Miniport driver structure
//

typedef
NTSTATUS
(*SMB_RESET_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
VOID
(*SMB_START_IO)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
NTSTATUS
(*SMB_STOP_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );



typedef struct _SMB_CLASS {
    USHORT              MajorVersion;
    USHORT              MinorVersion;

    PVOID               Miniport;           // Miniport extension data

    PDEVICE_OBJECT      DeviceObject;       // Device object for this miniport
    PDEVICE_OBJECT      PDO;                // PDO for this miniport
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Current IO
    //

    PIRP                CurrentIrp;         // current request
    PSMB_REQUEST        CurrentSmb;         // pointer to SMB_REQUEST in the CurrentIrp

    //
    // Miniport functions
    //

    SMB_RESET_DEVICE    ResetDevice;        // Initialize/Reset, start device
    SMB_START_IO        StartIo;            // Perform IO
    SMB_STOP_DEVICE     StopDevice;         // Stop device

} SMB_CLASS, *PSMB_CLASS;

#define SMB_CLASS_MAJOR_VERSION     0x0001
#define SMB_CLASS_MINOR_VERSION     0x0000

//
// Class driver initializtion functions
//

#if !defined(SMBCLASS)
    #define SMBCLASSAPI DECLSPEC_IMPORT
#else
    #define SMBCLASSAPI
#endif


typedef
NTSTATUS
(*PSMB_INITIALIZE_MINIPORT) (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SMBCLASSAPI
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SMBCLASSAPI
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

//
// Class driver interface functions for use by the miniport
//

VOID
SMBCLASSAPI
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    );


VOID
SMBCLASSAPI
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    );


VOID
SMBCLASSAPI
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    );

VOID
SMBCLASSAPI
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\winperf.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
#ifdef _WIN64
    DWORD           ObjectNameTitle;    // Should use this as an offset
#else
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
#ifdef _WIN64
    DWORD           ObjectHelpTitle;    // Should use this as an offset
#else
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000  // 32 bit field
#define PERF_SIZE_LARGE         0x00000100  // 64 bit field
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
#define PERF_COUNTER_PRECISION  0x00070000  // divide ctr / private clock
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)


// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_LARGE_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using 100 Ns timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_100NS_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using Object specific timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in object specific units. Display delta divided by
// delta time as returned in the object type header structure.  Display suffix: "%"
#define PERF_OBJ_TIME_TIMER	\
            (PERF_SIZE_LARGE   | PERF_TYPE_COUNTER  | PERF_COUNTER_RATE |\
             PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)


// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

#define PERF_LARGE_RAW_FRACTION           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

#define PERF_LARGE_RAW_BASE               \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW )

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram
//
//  This counter is used to display the difference from one sample
//  to the next. The counter value is a constantly increasing number
//  and the value displayed is the difference between the current
//  value and the previous value. Negative numbers are not allowed
//  which shouldn't be a problem as long as the counter value is
//  increasing or unchanged.
//
#define PERF_COUNTER_DELTA      \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

#define PERF_COUNTER_LARGE_DELTA      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)
//
//  The precision counters are timers that consist of two counter values:
//      1) the count of elapsed time of the event being monitored
//      2) the "clock" time in the same units
//
//  the precition timers are used where the standard system timers are not
//  precise enough for accurate readings. It's assumed that the service
//  providing the data is also providing a timestamp at the same time which
//  will eliminate any error that may occur since some small and variable
//  time elapses between the time the system timestamp is captured and when
//  the data is collected from the performance DLL. Only in extreme cases
//  has this been observed to be problematic.
//
//  when using this type of timer, the definition of the
//      PERF_PRECISION_TIMESTAMP counter must immediately follow the
//      definition of the PERF_PRECISION_*_TIMER in the Object header
//
// The timer used has the same frequency as the System Performance Timer
#define PERF_PRECISION_SYSTEM_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_TICK    | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used has the same frequency as the 100 NanoSecond Timer
#define PERF_PRECISION_100NS_TIMER  \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_100NS   | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used is of the frequency specified in the Object header's
//  PerfFreq field (PerfTime is ignored)
#define PERF_PRECISION_OBJECT_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_OBJECT_TIMER  | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// This is the timestamp to use in the computation of the timer specified
// in the previous description block
#define PERF_PRECISION_TIMESTAMP    PERF_LARGE_RAW_BASE
//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//
//
#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer
//
//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//
//
typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterNameTitle;
#else
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterHelpTitle;
#else
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;
//
//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none
                                        // this length includes the characters
                                        // in the string plus the size of the
                                        // terminating NULL char. It does not
                                        // include any additional pad bytes to
                                        // correct structure alignment
} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
// Support for New Extensible API starting with NT 5.0
//
#define     PERF_QUERY_OBJECTS      ((LONG)0x80000000)
#define     PERF_QUERY_GLOBAL       ((LONG)0x80000001)
#define     PERF_QUERY_COSTLY       ((LONG)0x80000002)

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);
typedef DWORD (APIENTRY PM_QUERY_PROC) (LPDWORD, LPVOID *, LPDWORD, LPDWORD);

#define     MAX_PERF_OBJECTS_IN_QUERY_FUNCTION      (64L)

//
// The following are the possible values for
// HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\EventLogLevel
// The default is WINPERF_LOG_NONE if the registry value is not defined.
// This should be adopted by all perfdlls to avoid flooding the application
// event log.
//

#define  WINPERF_LOG_NONE       0           // No event reported
#define  WINPERF_LOG_USER       1           // Report only errors
#define  WINPERF_LOG_DEBUG      2           // Report debug errors as well
#define  WINPERF_LOG_VERBOSE    3           // Report everything

#include <poppack.h>

#endif // _WINPERF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\wmiguid.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

--*/

#include <guiddef.h>

//
// This is WMI guid used to return disk performance information from
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

//
// This guid will return additional information about a data provider
// {5494DFDC-A98A-11d1-BF43-00A0C9062910}
#define DATA_PROVIDER_INFO_GUID \
   {0x5494dfdc, 0xa98a, 0x11d1, 0xbf, 0x43, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}


//
// This wmi guid is used to return the entire SMBIOS data table
// {8F680850-A584-11d1-BF38-00A0C9062910}
#define SMBIOS_DATA_GUID \
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

//
// This wmi guid is used to return thermal information
// {A1BC18C0-A7C8-11d1-BF3C-00A0C9062910}
DEFINE_GUID(THERMAL_ZONE_GUID,  \
   0xa1bc18c0, 0xa7c8, 0x11d1, 0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This wmi guid is used to return additional information about the provider
// of an instance name. Note that only QuerySingleInstance is supported.
// {C7BF35D0-AADB-11d1-BF4A-00A0C9062910}
#define INSTANCE_INFO_GUID \
    {0xc7bf35d0, 0xaadb, 0x11d1, 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

#define BINARY_MOF_GUID \
    {0x05901221, 0xD566, 0x11d1, 0xB2, 0xF0, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}

#define ENUMERATE_GUIDS_GUID \
    {0xe3dff7bd, 0x3915, 0x11d2, 0x91, 0x03, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}

//
// Global WMI Logger GUID
//

DEFINE_GUID ( /* e8908abc-aa84-11d2-9a93-00805f85d7c6 */
    GlobalLoggerGuid,
    0xe8908abc,
    0xaa84,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

DEFINE_GUID ( /* 44608a51-1851-4456-98b2-b300e931ee41 */
    WmiEventLoggerGuid,
    0x44608a51,
    0x1851,
    0x4456,
    0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41
  );
DEFINE_GUID ( /* 8d40301f-ab4a-11d2-9a93-00805f85d7c6 */
    GenericMessageGuid,
    0x8d40301f,
    0xab4a,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

//
// Event Trace GUIDs
//

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
DEFINE_GUID ( /* 9a280ac0-c8e0-11d1-84e2-00c04fb998a2 */
    TcpIpGuid,
    0x9a280ac0,
    0xc8e0,
    0x11d1,
    0x84, 0xe2, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
  );
DEFINE_GUID ( /* bf3a50c5-a9c9-4988-a005-2df0b7c80f80 */
    UdpIpGuid,
    0xbf3a50c5,
    0xa9c9,
    0x4988,
    0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80
  );

DEFINE_GUID ( /* 2cb15d1d-5fc1-11d2-abe1-00a0c911f518 */
    ImageLoadGuid,
    0x2cb15d1d,
    0x5fc1,
    0x11d2,
    0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18
  );

DEFINE_GUID ( /* AE53722E-C863-11d2-8659-00C04FA321A1 */
    RegistryGuid, 
    0xae53722e,
    0xc863,
    0x11d2,
    0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1
);

DEFINE_GUID( /* 13976D09-A327-438c-950B-7F03192815C7  */
    DbgPrintGuid,
    0x13976d09,
    0xa327,
    0x438c,
    0x95, 0xb, 0x7f, 0x3, 0x19, 0x28, 0x15, 0xc7
    );


//
// Special WMI events
//
DEFINE_GUID ( /* 398191dc-2da7-11d3-8b98-00805f85d7c6 */
    TraceErrorGuid,
    0x398191dc,
    0x2da7,
    0x11d3,
    0x8b, 0x98, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\wmistr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Wmistr.h

Abstract:

    WMI structure definitions

--*/

#ifndef _WMISTR_
#define _WMISTR_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;    // Provider Id of driver returning this buffer
    union
    {
        ULONG64 HistoricalContext;  // Logger use
        struct
            {
            ULONG Version;           // Reserved
            ULONG Linkage;           // Linkage field reserved for WMI
        };
    };

    union
    {
        ULONG CountLost;         // Reserved
        HANDLE KernelHandle;     // Kernel handle for data block
        LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                                 // since 1/1/1601
    };
    GUID Guid;                  // Guid for data block returned with results
    ULONG ClientContext;
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is
                                              // identical for all instances
                                              // (used with  WNODE_ALL_DATA
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a
                                 // WNODE_ALL_DATA in which the number of
                                 // instances and their names returned
                                 // are identical to those returned from the
                                 // previous WNODE_ALL_DATA query. Only data
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in
                                 // WNODE_ALL_DATA; values specified at
                                 // registration are used instead. Always
                                 // set for guids registered with static
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200
#define WNODE_FLAG_PERSIST_EVENT 0x00000400

#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// The second byte, except the first bit is used exclusively for tracing
#define WNODE_FLAG_TRACED_GUID   0x00020000 // denotes a trace

#define WNODE_FLAG_LOG_WNODE     0x00040000 // request to log Wnode

#define WNODE_FLAG_USE_GUID_PTR  0x00080000 // Guid is actually a pointer

#define WNODE_FLAG_USE_MOF_PTR   0x00100000 // MOF data are dereferenced

#define WNODE_FLAG_NO_HEADER     0x00200000 // Trace without header

// Set for events that are WNODE_EVENT_REFERENCE
// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

//
// This structure is used within the WNODE_ALL_DATA when the data blocks
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block

    ULONG InstanceCount;  // Count of instances whose data follows.

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the
    // offsets and lengths of the data blocks for each instance.
    union
    {
        ULONG FixedInstanceSize;
        OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };

    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data
                            // On Return: offset from WNODE to input and
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    union
    {
                     // If WMIREG_FLAG_INSTANCE_LIST then this has the offset
                     // to a list of InstanceCount counted UNICODE
                     // strings placed end to end.
        ULONG InstanceNameList;
                        
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this has the
                     // offset to a single counted UNICODE string that
                     // has the basename for the instance names.
                        
        ULONG BaseNameOffset;
                        
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will
                     // become the instance name
        ULONG_PTR Pdo;
                        
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to
                     // a WMIREGINSTANCEREF structure.
                        
        ULONG_PTR InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
    };

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020

// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_RESERVED1         0x00020000 // Reserved by WMI
#define WMIREG_FLAG_RESERVED2         0x00040000 // Reserved by WMI

// Set if guid is one that is written to trace log.
// This guid cannot be queried directly via WMI, but must be read using
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000

//
// Only those Trace Guids that have this bit set can receive
// Enable/Disable Notifications.
//
#define WMIREG_FLAG_TRACE_CONTROL_GUID 0x00001000

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG     
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data
                                                // providers
                                                        
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER
// TRACELOG_CREATE_INPROC
// TRACELOG_ACCESS_REALTIME

//
// GuidTypes 
//
//#ifndef _WMIKM_
#define WMI_GUIDTYPE_TRACECONTROL 0
#define WMI_GUIDTYPE_TRACE        1
#define WMI_GUIDTYPE_DATA         2
#define WMI_GUIDTYPE_EVENT        3
//#endif

//
// Specific rights for WMI guid objects. These are available from 0x0001 to
// 0xffff (ie up to 16 rights)
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_READ |     \
                            SYNCHRONIZE | \
                            WMIGUID_QUERY |                \
                            WMIGUID_SET |                  \
                            WMIGUID_NOTIFICATION |         \
                            WMIGUID_READ_DESCRIPTION |     \
                            WMIGUID_EXECUTE |              \
                            TRACELOG_CREATE_REALTIME |     \
                            TRACELOG_CREATE_ONDISK |       \
                            TRACELOG_GUID_ENABLE |         \
                            TRACELOG_ACCESS_KERNEL_LOGGER |\
                            TRACELOG_CREATE_INPROC | \
                            TRACELOG_ACCESS_REALTIME | \
                            TRACELOG_REGISTER_GUIDS  )

#define WMI_GLOBAL_LOGGER_ID          0x0001
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default: 4200) // nonstandard extension used : zero-sized array in struct/union
#pragma warning(default: 4201) // nonstandard extension used : nameless struct/union
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\published\wmium.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Wmium.h

Abstract:

    Public headers for WMI data consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMIUM_
#define _WMIUM_

#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif
#endif

#include <guiddef.h>

#include <basetsd.h>
#include <wmistr.h>
#include <evntrace.h>

typedef PVOID WMIHANDLE, *PWMIHANDLE, MOFHANDLE, *PMOFHANDLE;


//
// When set the guid can be opened and accessed
#define MOFCI_RESERVED0  0x00000001

#define MOFCI_RESERVED1  0x00000002
#define MOFCI_RESERVED2  0x00000004

typedef struct
{
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ImagePath;        // Path to image containing MOF resource
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
#ifdef MIDL_PASS
    [size_is(0)] PDFBYTE
#else
    PUCHAR
#endif
             ResourceBuffer;    // Reserved
} MOFRESOURCEINFOW, *PMOFRESOURCEINFOW;


typedef struct
{
    LPSTR
             ImagePath;        // Path to image containing MOF resource
    LPSTR
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
    UCHAR
             *ResourceBuffer;   // Reserved
} MOFRESOURCEINFOA, *PMOFRESOURCEINFOA;

#ifdef UNICODE
typedef MOFRESOURCEINFOW MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOW PMOFRESOURCEINFO;
#else
typedef MOFRESOURCEINFOA MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOA PMOFRESOURCEINFO;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data consumer apis
ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
);

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
);

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define WmiQueryAllData WmiQueryAllDataW
#else
#define WmiQueryAllData WmiQueryAllDataA
#endif


ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);
#ifdef UNICODE
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleW
#else
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );
#ifdef UNICODE
#define WmiQuerySingleInstance WmiQuerySingleInstanceW
#else
#define WmiQuerySingleInstance WmiQuerySingleInstanceA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN LPCWSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN LPCSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

#ifdef UNICODE
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleW
#else
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleA
#endif

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleInstance WmiSetSingleInstanceW
#else
#define WmiSetSingleInstance WmiSetSingleInstanceA
#endif

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleItem WmiSetSingleItemW
#else
#define WmiSetSingleItem WmiSetSingleItemA
#endif

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

#ifdef UNICODE
#define WmiExecuteMethod WmiExecuteMethodW
#else
#define WmiExecuteMethod WmiExecuteMethodA
#endif

// Set this Flag when calling NotficationRegistration to enable or
// disable a trace logging guid
#define NOTIFICATION_TRACE_FLAG       0x00010000

// Set this flag when enabling a notification that should be delivered via
// a direct callback. Any notifications received will be given their own
// thread and the callback function called immediately.
#define NOTIFICATION_CALLBACK_DIRECT  0x00000004

//
// Set this flag (and only this flag) when you want to only check if the 
// caller has permission to receive events for the guid
//
#define NOTIFICATION_CHECK_ACCESS 0x00000008

//
// Event notification callback function prototype
typedef void (
#ifndef MIDL_PASS
WINAPI
#endif
*NOTIFICATIONCALLBACK)(
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext
    );

#ifndef MIDL_PASS
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_REGISTRATION_CHANGE_NOTIFICATION,
0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);
#endif

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );
#ifdef UNICODE
#define WmiNotificationRegistration WmiNotificationRegistrationW
#else
#define WmiNotificationRegistration WmiNotificationRegistrationA
#endif

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    );


ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    );
#ifdef UNICODE
#define WmiMofEnumerateResources WmiMofEnumerateResourcesW
#else
#define WmiMofEnumerateResources WmiMofEnumerateResourcesA
#endif

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT CHAR *InstanceNames
    );

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT WCHAR *InstanceNames
    );
#ifdef UNICODE
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameW
#else
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameA
#endif

#define WmiInsertTimestamp(WnodeHeader) \
    GetSystemTimeAsFileTime((FILETIME *)&((PWNODE_HEADER)WnodeHeader)->TimeStamp)

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT CHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN CHAR *DevInst,
    IN ULONG InstanceIndex
    );

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT WCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN WCHAR *DevInst,
    IN ULONG InstanceIndex
    );
#ifdef UNICODE
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameW
#else
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameA
#endif

typedef struct _WMIGUIDINFORMATION
{
    ULONG Size;
    BOOLEAN IsExpensive;
    BOOLEAN IsEventOnly;
} WMIGUIDINFORMATION, *PWMIGUIDINFORMATION;


ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE GuidHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    );


ULONG
WMIAPI
WmiReceiveNotificationsW(
    IN ULONG HandleCount,
        IN HANDLE *HandleList,
        IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

ULONG
WMIAPI
WmiReceiveNotificationsA(
    IN ULONG HandleCount,
        IN HANDLE *HandleList,
        IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

#ifdef UNICODE
#define WmiReceiveNotifications WmiReceiveNotificationsW
#else
#define WmiReceiveNotifications WmiReceiveNotificationsA
#endif


//
// Internal Flags for different processing modes.
// Applies to the TRACE_LOGFILE_HEADER ReservedFlags field.
//

// Used with OpenTrace(), prevents conversion of TimeStamps to UTC
#define EVENT_TRACE_USE_RAWTIMESTAMP 0x00000002    

// Used with OpenTrace(), retrieves event from file as is.
#define EVENT_TRACE_GET_RAWEVENT     0x00000100    

// Used with OpenTrace() to ReadBehind  a live logger session
#define EVENT_TRACE_READ_BEHIND      0x00000200

//
// Used in EventCallbacks to indicate that the InstanceId field
// is a sequence number. For Next version, move this constant to evntrace.h
//

#define EVENT_TRACE_USE_SEQUENCE  0x0004

//
// Low level trace consumer routines
//

typedef enum tagWMI_HEADER_TYPE {
    WMIHT_NONE,
    WMIHT_UNKNOWN,
    WMIHT_SYSTEM32,
    WMIHT_SYSTEM64,
    WMIHT_EVENT_TRACE,
    WMIHT_EVENT_INSTANCE,
    WMIHT_TIMED,
    WMIHT_ULONG32,
    WMIHT_WNODE,
    WMIHT_MESSAGE,
    WMIHT_PERFINFO32,
    WMIHT_PERFINFO64
} WMI_HEADER_TYPE;

typedef enum tagWMI_BUFFER_SOURCE {
    WMIBS_FLUSH_LIST,
    WMIBS_FREE_LIST,
    WMIBS_TRANSITION_LIST,
    WMIBS_CURRENT_LIST,
    WMIBS_LOG_FILE
} WMI_BUFFER_SOURCE;

typedef struct {
    WMI_BUFFER_SOURCE BufferSource;
    ULONG BufferSize;   // Size of the Buffer
    ULONG ProcessorNumber;      
    ULONG Alignment;    // Alignment
    PVOID Buffer;       // Pointer to the raw buffer
} WMIBUFFERINFO, *PWMIBUFFERINFO;

//
// Get buffer offset to first event only. Returns Size. 
// Fix up the Buffer for proper termination and alignment. 
//

ULONG
WMIAPI
WmiGetFirstTraceOffset(
    IN PWMIBUFFERINFO BufferInfo
    );

//
// Get the next event, size and type. Caller must advance offset with Size
// 

WMI_HEADER_TYPE
WMIAPI
WmiGetTraceHeader(
    IN  PVOID  Buffer,
    IN  ULONG  Offset,
    OUT ULONG  *Size
    );

//
// Returns a EVENT_TRACE / (new Structure Ian will define) 
// in the Buffer provided

ULONG 
WMIAPI
WmiParseTraceEvent(
    IN PVOID Buffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    );

//
//  Structures and routines to process trace
//  with cursor.
//
typedef struct _WMI_BUFFER_CURSOR {
    PVOID          BufferHeader;
    LARGE_INTEGER  CurrentBufferOffset;
    ULONG          CurrentEventOffset;
    EVENT_TRACE    CurrentEvent;
    BOOLEAN        NoMoreEvents;
} WMI_BUFFER_CURSOR, *PWMI_BUFFER_CURSOR;

#define WMI_MERGE_ETL_CURSOR_VERSION     1

typedef struct _WMI_MERGE_ETL_CURSOR {
    ULONG                CursorVersion;
    HANDLE               TraceMappingHandle;
    PVOID                Base;
    ULONG                CurrentCpu;
    WMI_BUFFER_CURSOR    BufferCursor[MAXIMUM_PROCESSORS];
    EVENT_TRACE_LOGFILEW Logfile;
} WMI_MERGE_ETL_CURSOR, *PWMI_MERGE_ETL_CURSOR;

ULONG
WMIAPI
WmiOpenTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

ULONG
WMIAPI
WmiCloseTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

VOID
WMIAPI 
WmiConvertTimestamp(
    OUT PLARGE_INTEGER DestTime,
    IN PLARGE_INTEGER  SrcTime,
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

ULONG
WMIAPI
WmiGetNextEvent(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );
    
#ifdef __cplusplus
}
#endif

#endif  // _WMIUM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\addwiz.cpp ===
//
// Copyright 1997 - Microsoft

//
// IMOS.CPP - Handles the "IntelliMirror OS" IDD_PROP_INTELLIMIRROR_OS tab
//


#include "pch.h"
#include "addwiz.h"
#include "cservice.h"
#include "utils.h"
#include <lm.h>
#include <shlobj.h>
#include <commdlg.h>

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CAddWiz")
#define THISCLASS CAddWiz
#define LPTHISCLASS LPCADDWIZ

#define BITMAP_WIDTH        16
#define BITMAP_HEIGHT       16
#define LG_BITMAP_WIDTH     32
#define LG_BITMAP_HEIGHT    32
#define NUM_COLUMNS                 5
#define SERVER_START_STRING         L"\\\\%s\\" REMINST_SHARE

//
// CreateInstance()
//
HRESULT
CAddWiz_CreateInstance(
                      HWND  hwndParent,
                      LPUNKNOWN punk )
{
    TraceFunc( "CAddWiz_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT hr;

    if (lpcc == NULL) {

        hr = S_FALSE;

    } else {

        hr   = THR( lpcc->Init( hwndParent, punk ) );
        delete lpcc;

    }

    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CAddWiz()\n" );

    Assert( !_pszServerName );
    Assert( !_pszSourcePath );
    Assert( !_pszDestPath );
    Assert( !_pszSourceImage );
    Assert( !_pszDestImage );
    Assert( !_pszSourceServerName );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init(
               HWND hwndParent,
               LPUNKNOWN punk )
{
    TraceClsFunc( "Init()\n" );

    if (!LoadString( g_hInstance, IDS_NA, _szNA, ARRAYSIZE(_szNA))) {
        HRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (!LoadString( g_hInstance, IDS_USER_LOCATION, _szLocation, ARRAYSIZE(_szLocation))) {
        HRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    if ( !punk )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;

    HPROPSHEETPAGE  rPages[ 10 ];
    PROPSHEETHEADER pshead;

    _punk = punk;
    _punk->AddRef( );

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_HEADER;
    pshead.hInstance    = g_hInstance;
    pshead.pszCaption   = MAKEINTRESOURCE( IDS_ADD_DOT_DOT_DOT );
    pshead.phpage       = rPages;
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );
    pshead.hwndParent   = hwndParent;

    AddWizardPage( &pshead, IDD_ADD_PAGE1,  Page1DlgProc,  IDS_PAGE1_TITLE,  IDS_PAGE1_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE2,  Page2DlgProc,  IDS_PAGE2_TITLE,  IDS_PAGE2_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE6,  Page6DlgProc,  IDS_PAGE6_TITLE,  IDS_PAGE6_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE3,  Page3DlgProc,  IDS_PAGE3_TITLE,  IDS_PAGE3_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE4,  Page4DlgProc,  IDS_PAGE4_TITLE,  IDS_PAGE4_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE5,  Page5DlgProc,  IDS_PAGE5_TITLE,  IDS_PAGE5_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE7,  Page7DlgProc,  IDS_PAGE7_TITLE,  IDS_PAGE7_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE8,  Page8DlgProc,  IDS_PAGE8_TITLE,  IDS_PAGE8_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE9,  Page9DlgProc,  IDS_PAGE9_TITLE,  IDS_PAGE9_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE10, Page10DlgProc, IDS_PAGE10_TITLE, IDS_PAGE10_SUBTITLE, (LPARAM) this );

    PropertySheet( &pshead );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CAddWiz()\n" );

    Assert( !_pszPathBuffer );
    if ( !_pszPathBuffer ) {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
    }


    if ( _punk )
        _punk->Release( );

    if ( _pszServerName )
        TraceFree( _pszServerName );

    if ( _pszSourcePath )
        TraceFree( _pszSourcePath );

    if ( _pszSourceServerName )
        TraceFree( _pszSourceServerName );

    if ( _pszDestPath )
        TraceFree( _pszDestPath );

    if ( _pszSourceImage
         && _pszSourceImage != _szNA
         && _pszSourceImage != _szLocation )
        TraceFree( _pszSourceImage );

    if ( _pszDestImage
         && _pszDestImage != _szNA
         && _pszDestImage != _szLocation )
        TraceFree( _pszDestImage );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// Wizard Functions
//
// ************************************************************************

//
// _PopulateSamplesListView( )
//
STDMETHODIMP
THISCLASS::_PopulateSamplesListView(
    LPWSTR pszStartPath
    )
{
    TraceClsFunc( "_PopulateSamplesListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _dwPathBufferSize = wcslen( pszStartPath ) + MAX_PATH;
    _pszPathBuffer = (LPWSTR) TraceAllocString( LMEM_FIXED, _dwPathBufferSize );
    if ( !_pszPathBuffer ) {
        hr = E_OUTOFMEMORY;
        _dwPathBufferSize = 0;
        goto Error;
    }

    wcscpy( _pszPathBuffer, pszStartPath );

    hr = _EnumerateSIFs( );

    Error:
    if ( _pszPathBuffer ) {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
        _dwPathBufferSize = 0;
    }

    HRETURN(hr);
}

//
// _PopulateTemplatesListView( )
//
STDMETHODIMP
THISCLASS::_PopulateTemplatesListView(
    LPWSTR pszStartPath
    )
{
    TraceClsFunc( "_PopulateTemplatesListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _dwPathBufferSize = wcslen( pszStartPath ) + MAX_PATH ;
    _pszPathBuffer = (LPWSTR) TraceAllocString( LMEM_FIXED, _dwPathBufferSize );
    if ( !_pszPathBuffer ) {
        hr = E_OUTOFMEMORY;
        _dwPathBufferSize = 0;
        goto Error;
    }

    if (_snwprintf(_pszPathBuffer,
                   _dwPathBufferSize,
                   L"%s%s",
                   pszStartPath,
                   SLASH_SETUP) < 0) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    _pszPathBuffer[_dwPathBufferSize-1] = L'\0';

    hr = _FindLanguageDirectory( _EnumerateTemplates );

    Error:
    if ( _pszPathBuffer ) {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
        _dwPathBufferSize = 0;
    }

    HRETURN(hr);
}

//
// _PopulateImageListView( )
//
STDMETHODIMP
THISCLASS::_PopulateImageListView(
    LPWSTR pszStartPath 
    )
{
    TraceClsFunc( "_PopulateImageListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _dwPathBufferSize = wcslen( pszStartPath ) + MAX_PATH ;
    _pszPathBuffer = (LPWSTR) TraceAllocString( LMEM_FIXED, _dwPathBufferSize );
    if ( !_pszPathBuffer ) {
        hr = E_OUTOFMEMORY;
        _dwPathBufferSize = 0;
        goto Error;
    }

    if (_snwprintf(_pszPathBuffer,
                   _dwPathBufferSize,
                   L"%s%s",
                   pszStartPath,
                   SLASH_SETUP) < 0) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = _FindLanguageDirectory( _EnumerateImages );

    Error:
    if ( _pszPathBuffer ) {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
        _dwPathBufferSize = 0;
    }

    HRETURN(hr);
}

//
// _FindLanguageDirectory( )
//
STDMETHODIMP
THISCLASS::_FindLanguageDirectory(
                                 LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_FindLanguageDirectory( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    Assert( lpNextOperation );

    uLength = wcslen( _pszPathBuffer );
    if (uLength + sizeof(L"\\*") > _dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }

    wcscat( _pszPathBuffer, L"\\*" );
    uLength2 = wcslen( _pszPathBuffer ) - 1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
                 && StrCmp( find.cFileName, L"." ) != 0
                 && StrCmp( find.cFileName, L".." ) != 0 ) {
                _pszPathBuffer[uLength2] = L'\0';
                if ( (wcslen(_pszPathBuffer) + wcslen( find.cFileName ) + 1) > 
                      _dwPathBufferSize) {
                    hr = E_INVALIDARG;
                    goto Error;
                }
                wcscat( _pszPathBuffer, find.cFileName );
                hr = _FindOSDirectory( lpNextOperation );
                if (FAILED(hr))  {
                    goto Error;
                }
            }
        }
        while ( FindNextFile( hFind, &find ) );
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    Error:
    if ( hFind != INVALID_HANDLE_VALUE ) {
        FindClose( hFind );
    }

    // restore the trailing NULL
    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _FindOSDirectory( )
//
STDMETHODIMP
THISCLASS::_FindOSDirectory(
                           LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_FindOSDirectory( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    Assert( lpNextOperation );

    uLength = wcslen( _pszPathBuffer );
    if (uLength + sizeof(SLASH_IMAGES L"\\*") > _dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }
    wcscat( _pszPathBuffer, SLASH_IMAGES L"\\*");
    uLength2 = wcslen( _pszPathBuffer ) -1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
                 && StrCmp( find.cFileName, L"." ) != 0
                 && StrCmp( find.cFileName, L".." ) != 0 ) {
                _pszPathBuffer[uLength2] = L'\0';
                if ( (wcslen(_pszPathBuffer) + wcslen( find.cFileName ) + 1) > 
                      _dwPathBufferSize) {
                    hr = E_INVALIDARG;
                    goto Error;
                }
                wcscat( _pszPathBuffer, find.cFileName );
                hr = _EnumeratePlatforms( lpNextOperation );
                if (FAILED(hr)) {
                    goto Error;
                }
            }
        }
        while ( FindNextFile( hFind, &find ) );
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumeratePlatforms( )
//
STDMETHODIMP
THISCLASS::_EnumeratePlatforms(
                              LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_EnumeratePlatforms( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( lpNextOperation );
    Assert( _pszPathBuffer );

    uLength = wcslen( _pszPathBuffer );
    if (uLength + sizeof(L"\\*") > _dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }
    wcscat( _pszPathBuffer, L"\\*" );
    uLength2 = wcslen( _pszPathBuffer ) - 1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
                 && StrCmp( find.cFileName, L"." ) != 0
                 && StrCmp( find.cFileName, L".." ) != 0 ) {
                _pszPathBuffer[uLength2] = L'\0';
                if ( (wcslen(_pszPathBuffer) + wcslen( find.cFileName ) + 1) > 
                      _dwPathBufferSize) {
                    hr = E_INVALIDARG;
                    goto Error;
                }
                wcscat( _pszPathBuffer, find.cFileName );
                hr = lpNextOperation( this );
                //
                // we can get ERROR_PATH_NOT_FOUND in several cases
                // like oem preinstall, etc.  just eat the error and
                // continue
                //
                if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
                    hr = S_OK;
                }
                if (FAILED(hr)) {
                    goto Error;
                }
            }
        }
        while ( FindNextFile( hFind, &find ) );
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    Error:
    if ( hFind != INVALID_HANDLE_VALUE ) {
        FindClose( hFind );
    }

    // restore the path.
    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateTemplates( )
//
HRESULT
THISCLASS::_EnumerateTemplates(
                              LPTHISCLASS lpc )
{
    TraceClsFunc( "_EnumerateTemplates( )\n" );

    HRESULT hr;
    ULONG   uLength;

    Assert( lpc );
    Assert( lpc->_pszPathBuffer );
    uLength = wcslen( lpc->_pszPathBuffer );
    if (uLength + sizeof(SLASH_TEMPLATES) > lpc->_dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }
    
    wcscat( lpc->_pszPathBuffer, SLASH_TEMPLATES );

    hr = lpc->_EnumerateSIFs( );

Error:
    lpc->_pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateImages( )
//
HRESULT
THISCLASS::_EnumerateImages(
                           LPTHISCLASS lpc )
{
    TraceClsFunc( "_EnumerateImages( )\n" );

    HRESULT hr;

    Assert( lpc );

    hr = lpc->_CheckImageType( );
    if ( hr == S_OK ) {
        hr = lpc->_AddItemToListView( );
    }

    HRETURN(hr);
}

//
// _CheckImageType( )
//
// This won't add an item to the listview. It only checks to make
// sure the image path points to a "Flat" image.
//
// Returns: S_OK - Flat image found
//          S_FALSE - not a flat image
//
HRESULT
THISCLASS::_CheckImageType( )
{
    TraceClsFunc( "_CheckImageType( )\n" );

    HRESULT hr = S_FALSE;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;
    ULONG   uLength;
    ULONG   uLength2;

    Assert( _pszPathBuffer );
    uLength = wcslen( _pszPathBuffer );
    if (uLength + sizeof(L"\\ntoskrnl.exe") > _dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }

    //
    // Check for <architecture>\ntoskrnl.exe to see
    // if this is a "flag" image. If we find this file
    // then we're done.
    //
    wcscat( _pszPathBuffer, L"\\ntoskrnl.exe" );

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                Assert( _wcsicmp( find.cFileName, L"ntoskrnl.exe" ) == 0 );
                hr = S_OK;
                goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );

        FindClose( hFind );
        hFind = INVALID_HANDLE_VALUE;
    }

    //
    // Didn't find the kernel.  Now check every sif
    // file in the TEMPLATES subdirectory and see if
    // he's got an OSCHOOSER_IMAGETYPE_ENTRY.  If he
    // does, see if it's a "flat" image.
    //
    _pszPathBuffer[uLength] = L'\0';
    if (uLength + sizeof(SLASH_TEMPLATES L"\\*.sif") > _dwPathBufferSize) {
        hr = E_INVALIDARG;
        goto Error;
    }

    wcscat( _pszPathBuffer, SLASH_TEMPLATES L"\\*.sif");
    uLength2 = wcslen( _pszPathBuffer ) - 5;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                WCHAR szImageType[ 40 ];
                _pszPathBuffer[uLength2] = L'\0';
                if ( (wcslen(_pszPathBuffer) + wcslen( find.cFileName ) + 1) > 
                      _dwPathBufferSize) {
                    hr = E_INVALIDARG;
                    goto Error;
                }
                wcscat( _pszPathBuffer, find.cFileName );

                GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                         OSCHOOSER_IMAGETYPE_ENTRY,
                                         L"",
                                         szImageType,
                                         ARRAYSIZE(szImageType),
                                         _pszPathBuffer );

                if ( _wcsicmp( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) == 0 ) {
                    hr = S_OK;
                    goto Error;
                }
            }
        }
        while ( FindNextFile( hFind, &find ) );

        FindClose( hFind );
        hFind = INVALID_HANDLE_VALUE;
    }

    Error:
    if ( hFind != INVALID_HANDLE_VALUE ) {
        FindClose( hFind );
    }

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateSIFs( )
//
STDMETHODIMP
THISCLASS::_EnumerateSIFs( )
{
    TraceClsFunc( "_EnumerateSIFs( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    if (wcslen(_pszPathBuffer) + ARRAYSIZE(L"\\*.sif") >_dwPathBufferSize) {
        return(E_INVALIDARG);
    }

    wcscat( _pszPathBuffer, L"\\*.sif" );
    uLength = wcslen( _pszPathBuffer ) - ARRAYSIZE(L"*.sif") + 1;
    Assert( uLength <= _dwPathBufferSize );

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ) {
                _pszPathBuffer[uLength] = L'\0';
                if (wcslen(_pszPathBuffer) + wcslen(find.cFileName) + 1 > _dwPathBufferSize) {
                    hr = E_INVALIDARG;
                    goto Error;
                }

                wcscat( _pszPathBuffer, find.cFileName );

                hr = _AddItemToListView( );
                if (FAILED(hr))
                    goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    Error:
    if ( hFind != INVALID_HANDLE_VALUE ) {
        FindClose( hFind );
    }

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _AddItemToListView( )
//
// Returns: S_OK - Item add successfully
//          S_FALSE - Item is not valid
//          E_OUTOFMEMORY - obvious
//
// Note: this code is nearly identical to PopulateListView() in utils.cpp
//
//
HRESULT
THISCLASS::_AddItemToListView( )
{
    TraceClsFunc( "_AddItemToListView( )\n" );

    Assert( _pszPathBuffer );

    HRESULT hr = S_OK;
    LPSIFINFO pSIF = NULL;
    LV_ITEM lvI;
    INT     iCount = 0;
    LPWSTR  psz;
    LPWSTR  pszLanguage;
    LPWSTR  pszImage;
    LPWSTR  pszArchitecture;

    pSIF = (LPSIFINFO) TraceAlloc( LPTR, sizeof(SIFINFO) );
    if ( !pSIF ) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    ZeroMemory( pSIF, sizeof(SIFINFO));

    pSIF->pszFilePath = (LPWSTR) TraceStrDup( _pszPathBuffer );
    if ( !pSIF->pszFilePath ) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    psz = &_pszPathBuffer[ wcslen( _pszPathBuffer ) - 4 ];
    if ( _wcsicmp( psz, L".SIF" ) == 0 ) {
        WCHAR szImageType[ 40 ];

        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                 OSCHOOSER_IMAGETYPE_ENTRY,
                                 L"",
                                 szImageType,
                                 ARRAYSIZE(szImageType),
                                 _pszPathBuffer );
        // only show "Flat" SIFs
        if ( szImageType[0] && _wcsicmp( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) ) {
            hr = S_FALSE; // skipping
            goto Error;
        }

        pSIF->pszDescription =
        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                   REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
        if ( !pSIF->pszDescription ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                 OSCHOOSER_DESCRIPTION_ENTRY,
                                 L"",
                                 pSIF->pszDescription,
                                 REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT, // doesn't need -1
                                 _pszPathBuffer );

        if ( pSIF->pszDescription[0] == L'\0' ) {
            hr = S_FALSE;
            goto Error; // not a valid OSChooser SIF
        }

        pSIF->pszHelpText = 
        (LPWSTR) TraceAllocString( LMEM_FIXED, 
                                   REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );

        if ( !pSIF->pszHelpText ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_HELPTEXT_ENTRY, 
                                 L"", 
                                 pSIF->pszHelpText, 
                                 REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT, // doesn't need -1
                                 _pszPathBuffer );
    }

    // This path will be in one of these forms:
    // \\server\reminst\setup\english\images\nt50.wks\i386           ( Samples )
    // \\server\reminst\setup\english\images\nt50.wks\i386\templates ( template SIFs )
    // \\server\reminst\setup\english\images                         ( Images )

    // Find the language from the path
    psz = StrStr( _pszPathBuffer, SLASH_SETUP L"\\" );
    if (!psz) {
        goto Language_NA;
    }
    psz++;
    if ( !*psz ) {
        goto Language_NA;
    }
    psz = StrChr( psz, L'\\' );
    if (!psz) {
        goto Language_NA;
    }
    psz++;
    if ( !*psz ) {
        goto Language_NA;
    }
    pszLanguage = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz ) {
        *psz = L'\0';   // terminate
    }
    pSIF->pszLanguage = (LPWSTR) TraceStrDup( pszLanguage );
    if ( psz ) {
        *psz = L'\\';   // restore
    }
    if ( !pSIF->pszLanguage ) {
        hr = E_OUTOFMEMORY;
        goto Language_NA;
    }

    // Find the image directory name from the path
    psz = StrStr( _pszPathBuffer, SLASH_IMAGES L"\\" );
    if ( !psz ) {
        goto Image_NA;
    }
    psz++;
    if ( !*psz ) {
        goto Image_NA;
    }
    psz = StrChr( psz, L'\\' );
    if (!psz) {
        goto Image_NA;
    }
    psz++;
    if ( !*psz ) {
        goto Image_NA;
    }
    pszImage = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz ) {
        *psz = L'\0';   // terminate
    }
    pSIF->pszImageFile = (LPWSTR) TraceStrDup( pszImage );
    if ( psz ) {
        *psz = L'\\';    // restore
    }
    if ( !pSIF->pszImageFile ) {
        hr = E_OUTOFMEMORY;
        goto Image_NA;
    }

    // Find the architecture from the path
    if ( !*psz ) {
        goto Architecture_NA;
    }
    psz++;
    if ( !*psz ) {
        goto Architecture_NA;
    }
    pszArchitecture = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz ) {
        *psz = L'\0';    // terminate
    }
    pSIF->pszArchitecture = (LPWSTR) TraceStrDup( pszArchitecture );
    if ( psz ) {
        *psz = L'\\';    // restore
    }
    if ( !pSIF->pszArchitecture ) {
        hr = E_OUTOFMEMORY;
        goto Architecture_NA;
    }

    goto Done;

    // Set columns that we couldn't determine to "n/a"
    Language_NA:
    pSIF->pszLanguage = _szNA;
    Image_NA:
    pSIF->pszImageFile = _szNA;
    Architecture_NA:
    pSIF->pszArchitecture = _szNA;

    Done:    
    if ( !pSIF->pszDescription ) {
        pSIF->pszDescription = (LPWSTR) TraceStrDup( pSIF->pszImageFile );
        if ( !pSIF->pszDescription ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT;
    lvI.lParam      = (LPARAM) pSIF;
    lvI.iItem       = iCount;
    lvI.pszText     = pSIF->pszDescription;
    iCount = ListView_InsertItem( _hwndList, &lvI );
    Assert( iCount != -1 );
    if ( iCount == -1 ) {
        goto Error;
    }

    ListView_SetItemText( _hwndList, iCount, 1, pSIF->pszArchitecture );
    ListView_SetItemText( _hwndList, iCount, 2, pSIF->pszLanguage );
    // ListView_SetItemText( hwndList, iCount, 3, pSIF->pszVersion );
    ListView_SetItemText( _hwndList, iCount, 3, pSIF->pszImageFile );

    pSIF = NULL; // don't free

    Error:
    if ( pSIF )
        THR( _CleanupSIFInfo( pSIF ) );

    HRETURN(hr);
}

//
// _CleanUpSifInfo( )
//
HRESULT
THISCLASS::_CleanupSIFInfo(
                          LPSIFINFO pSIF )
{
    TraceClsFunc( "_CleanupSIFInfo( )\n" );

    if ( !pSIF )
        HRETURN(E_POINTER);

    if ( pSIF->pszFilePath )
        TraceFree( pSIF->pszFilePath );

    if ( pSIF->pszDescription )
        TraceFree( pSIF->pszDescription );

    if (pSIF->pszHelpText) {
        TraceFree( pSIF->pszHelpText );
    }

    //if ( pSIF->pszImageType && pSIF->pszImageType != _szNA )
    //    TraceFree( pSIF->pszImageType );

    if ( pSIF->pszArchitecture  && pSIF->pszArchitecture != _szNA )
        TraceFree( pSIF->pszArchitecture );

    if ( pSIF->pszLanguage && pSIF->pszLanguage != _szNA )
        TraceFree( pSIF->pszLanguage );

    if ( pSIF->pszImageFile && pSIF->pszImageFile != _szNA )
        TraceFree( pSIF->pszImageFile );

    //if ( pSIF->pszVersion && pSIF->pszVersion != _szNA )
    //    TraceFree( pSIF->pszVersion );

    TraceFree( pSIF );

    HRETURN(S_OK);

}

//
// _InitListView( )
//
HRESULT
THISCLASS::_InitListView(
                        HWND hwndList,
                        BOOL fShowDirectoryColumn )
{
    TraceClsFunc( "_InitListView( )\n" );

    CWaitCursor Wait;
    LV_COLUMN   lvC;
    INT         iSubItem;
    INT         iCount;
    LV_ITEM     lvI;
    WCHAR       szText[ 80 ];
    DWORD       dw;

    UINT uColumnWidth[ NUM_COLUMNS ] = { 215, 75, 75, 75, 75};

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = DNS_MAX_NAME_BUFFER_LENGTH;

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ ) {
        INT i;

        if ( iCount == 3 )
            continue; // skip "Version"

        if ( !fShowDirectoryColumn && iCount == 4 )
            continue; // skip "Directory"

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidth[iCount];

        szText[0] = L'\0';
        dw = LoadString( g_hInstance,
                         IDS_OS_COLUMN1 + iCount,
                         szText,
                         ARRAYSIZE(szText));
        Assert( dw );

        i = ListView_InsertColumn ( hwndList, iCount, &lvC );
        Assert( i != -1 );
    }

    ListView_DeleteAllItems( hwndList );

    HRETURN(S_OK);
}


//
// Page1DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page1DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            HRESULT hr;
            DWORD cbSize = DNS_MAX_NAME_BUFFER_LENGTH;
            WCHAR szFQDNS[ DNS_MAX_NAME_BUFFER_LENGTH ];
            IIntelliMirrorSAP * pimsap = NULL;
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;

            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;

            Button_SetCheck( GetDlgItem( hDlg, IDC_B_ADDSIF ), BST_CHECKED );

            Assert( lpc->_punk );
            hr = THR( lpc->_punk->QueryInterface( IID_IIntelliMirrorSAP,
                                                  (void**) &pimsap ) );
            if (FAILED(hr)) {
                goto InitDialog_Error;
            }

            Assert( !lpc->_pszServerName );
            hr = THR( pimsap->GetServerName( &lpc->_pszServerName ) );
            if (FAILED(hr)) {
                goto InitDialog_Error;
            }

            if (GetComputerNameEx( ComputerNameNetBIOS, szFQDNS, &cbSize ) &&
                _wcsicmp( szFQDNS, lpc->_pszServerName ) == 0 ) {
                EnableWindow( GetDlgItem( hDlg, IDC_B_NEWIMAGE ), TRUE );
            }

            InitDialog_Error:
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                if ( Button_GetCheck( GetDlgItem( hDlg, IDC_B_ADDSIF ) )
                     == BST_CHECKED ) {
                    lpc->_fAddSif = TRUE;
                } else if ( Button_GetCheck( GetDlgItem( hDlg, IDC_B_NEWIMAGE ) )
                            == BST_CHECKED ) {
                    STARTUPINFO startupInfo;
                    PROCESS_INFORMATION pi;
                    BOOL bRet;
                    const WCHAR szCommand[] = L"%systemroot%\\system32\\RISETUP.EXE -add";
                    WCHAR szRealCommandLine[MAX_PATH + 5 + 1]; // 5 for ' -add' and 1 for null

                    lpc->_fAddSif = FALSE;

                    ZeroMemory( &startupInfo, sizeof( startupInfo) );
                    startupInfo.cb = sizeof( startupInfo );

                    if (ExpandEnvironmentStrings(
                                szCommand, 
                                szRealCommandLine, 
                                ARRAYSIZE(szRealCommandLine)) && 
                        CreateProcess(NULL,
                                      szRealCommandLine,
                                      NULL,
                                      NULL,
                                      TRUE,
                                      NORMAL_PRIORITY_CLASS,
                                      NULL,
                                      NULL,
                                      &startupInfo,
                                      &pi )) {
                        CloseHandle( pi.hProcess );
                        CloseHandle( pi.hThread );
                    } else {
                        DWORD dwErr = GetLastError( );
                        MessageBoxFromError( hDlg,
                                             IDS_RISETUP_FAILED_TO_START,
                                             dwErr );
                    }

                    PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;
    }

    return FALSE;
}
//
// Page2DlgProc( )
//
// SIF Selection dialog proc.
//
INT_PTR CALLBACK
THISCLASS::Page2DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    LRESULT lResult;

                    lpc->_fCopyFromSamples   = FALSE;
                    lpc->_fCopyFromLocation  = FALSE;
                    lpc->_fCopyFromServer    = FALSE;

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_FROMSAMPLES ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromSamples = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_SERVER ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromServer = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_LOCATION ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromLocation = TRUE;
                    }

                    if ( !lpc->_fCopyFromLocation
                         && !lpc->_fCopyFromSamples && !lpc->_fCopyFromServer ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LRESULT lResult;

                    lpc->_fCopyFromSamples   = FALSE;
                    lpc->_fCopyFromLocation  = FALSE;
                    lpc->_fCopyFromServer    = FALSE;

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_FROMSAMPLES ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromSamples = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_SERVER ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromServer = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_LOCATION ) );
                    if ( lResult == BST_CHECKED ) {
                        lpc->_fCopyFromLocation = TRUE;
                    }

                    Assert( lpc->_fCopyFromLocation
                            || lpc->_fCopyFromSamples
                            || lpc->_fCopyFromServer );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) ) {
        case IDC_B_FROMSAMPLES:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_SERVER:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_LOCATION:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        }
        break;
    }

    return FALSE;
}

//
// Page3DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page3DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromServer ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    ULONG uLength =
                    Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_SERVER ) );
                    if ( !uLength ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    CWaitCursor Wait;
                    LPSHARE_INFO_1 psi;
                    HWND hwndEdit = GetDlgItem( hDlg, IDC_E_SERVER );
                    ULONG uLength = Edit_GetTextLength( hwndEdit );
                    Assert( uLength );
                    uLength++;  // add one for the NULL

                    // if we had a previous buffer allocated,
                    // see if we can reuse it
                    if ( lpc->_pszSourceServerName && uLength
                         > wcslen(lpc->_pszSourceServerName) + 1 ) {
                        TraceFree( lpc->_pszSourceServerName );
                        lpc->_pszSourceServerName = NULL;
                    }

                    if ( !lpc->_pszSourceServerName ) {
                        lpc->_pszSourceServerName =
                        (LPWSTR) TraceAllocString( LMEM_FIXED, uLength );
                        if ( !lpc->_pszSourceServerName )
                            goto PSN_WIZNEXTABORT;
                    }

                    Edit_GetText( hwndEdit, lpc->_pszSourceServerName, uLength );

                    if ( NERR_Success !=
                         NetShareGetInfo( lpc->_pszSourceServerName,
                                          REMINST_SHARE,
                                          1,
                                          (LPBYTE *) &psi ) ) {
                        MessageBoxFromStrings( hDlg,
                                               IDS_NOTARISERVER_CAPTION,
                                               IDS_NOTARISERVER_TEXT,
                                               MB_OK );
                        SetFocus( hwndEdit );
                        goto PSN_WIZNEXTABORT;
                    } else {
                        NetApiBufferFree( psi );
                    }

                    break;
                    PSN_WIZNEXTABORT:
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    return TRUE;
                }
                break;

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) ) {
        case IDC_E_SERVER:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                LONG uLength = Edit_GetTextLength( hwnd );
                if ( !uLength ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                } else {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_BROWSE:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                _OnSearch( hDlg );
            }
            break;
        }
        break;
    }

    return FALSE;
}

HRESULT
THISCLASS::_OnSearch(
                    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED(hr)) {
        goto Error;
    }

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                             | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                             | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;

    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
            (CLIPFORMAT)g_cfDsObjectNames,
            NULL,
            DVASPECT_CONTENT, 
            -1, 
            TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL};

        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            //
            // if we can't get this, it's not a problem because this is
            // only a display value
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDN( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVER, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

    Error:

    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings(
                             hDlg, 
                             IDS_PROBLEM_SEARCHING_TITLE, 
                             IDS_PROBLEM_SEARCHING_TEXT, 
                             MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}


//
// Page4DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page4DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_SIFS ), TRUE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromServer ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszSourceServerName );
                if ( lpc->_pszSourceServerName ) {
                    LPWSTR pszStartPath =
                    (LPWSTR) TraceAllocString( LMEM_FIXED,
                                               wcslen( lpc->_pszSourceServerName )
                                               + ARRAYSIZE(SERVER_START_STRING) );
                    if ( pszStartPath ) {
                        wsprintf( pszStartPath,
                                  SERVER_START_STRING,
                                  lpc->_pszSourceServerName );
                        lpc->_hDlg = hDlg;
                        lpc->_hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                        lpc->_PopulateTemplatesListView( pszStartPath );
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszSourcePath )  {
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                    }

                    if ( lpc->_pszSourceImage
                         && lpc->_pszSourceImage != lpc->_szNA
                         && lpc->_pszSourceImage != lpc->_szLocation ) {
                        TraceFree( lpc->_pszSourceImage );
                        lpc->_pszSourceImage = NULL;
                    }

                    lpc->_pszSourcePath  = pSIF->pszFilePath;
                    lpc->_pszSourceImage = pSIF->pszImageFile;
                    pSIF->pszFilePath    = NULL;   // don't free this, we're using it
                    pSIF->pszImageFile   = NULL;   // don't free this, we're using it

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    UINT iItems = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page5DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page5DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_FILEPATH ), MAX_PATH );
            SHAutoComplete(GetDlgItem( hDlg, IDC_E_FILEPATH ), SHACF_AUTOSUGGEST_FORCE_ON | SHACF_FILESYSTEM);
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromLocation ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    ULONG uLength =
                    Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_FILEPATH ) );
                    if ( !uLength ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    HWND  hwndEdit = GetDlgItem( hDlg, IDC_E_FILEPATH );
                    ULONG uLength = Edit_GetTextLength( hwndEdit );
                    DWORD dw;
                    Assert( uLength );
                    uLength++;  // add one for the NULL

                    // if we had a previous buffer allocated,
                    // see if we can reuse it
                    if ( lpc->_pszSourcePath && uLength
                         > wcslen(lpc->_pszSourcePath) + 1 ) {
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                    }

                    if ( lpc->_pszSourceImage
                         && lpc->_pszSourceImage != lpc->_szNA
                         && lpc->_pszSourceImage != lpc->_szLocation ) {
                        TraceFree( lpc->_pszSourceImage );
                        lpc->_pszSourceImage = NULL;
                    }

                    lpc->_pszSourceImage = lpc->_szLocation;

                    if ( !lpc->_pszSourcePath ) {
                        lpc->_pszSourcePath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED, uLength );
                        if ( !lpc->_pszSourcePath ) {
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't change
                            return TRUE;
                        }
                    }

                    Edit_GetText( hwndEdit, lpc->_pszSourcePath, uLength );

                    DWORD dwAttrs = GetFileAttributes( lpc->_pszSourcePath );
                    if ( dwAttrs == 0xFFFFffff ) {   // file doesn't exist
                        DWORD dwErr = GetLastError( );
                        MessageBoxFromError( hDlg, NULL, dwErr );
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                        return TRUE;
                    } else {   // the SIF image must be a "FLAT" image
                        WCHAR szImageType[ 40 ];

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_IMAGETYPE_ENTRY,
                                                 L"",
                                                 szImageType,
                                                 ARRAYSIZE(szImageType),
                                                 lpc->_pszSourcePath );

                        if ( _wcsicmp( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) ) {
                            MessageBoxFromStrings( hDlg,
                                                   IDS_MUST_BE_FLAT_CAPTION,
                                                   IDS_MUST_BE_FLAT_TEXT,
                                                   MB_OK );
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                            return TRUE;
                        }

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_DESCRIPTION_ENTRY,
                                                 L"",
                                                 lpc->_szDescription,
                                                 ARRAYSIZE(lpc->_szDescription),
                                                 lpc->_pszSourcePath );

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_HELPTEXT_ENTRY,
                                                 L"",
                                                 lpc->_szHelpText,
                                                 ARRAYSIZE(lpc->_szHelpText),
                                                 lpc->_pszSourcePath );
                    }
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) ) {
        case IDC_E_FILEPATH:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                LONG uLength = Edit_GetTextLength( hwnd );
                if ( !uLength ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                } else {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_BROWSE:
            if ( HIWORD( wParam ) == BN_CLICKED ) {
                WCHAR szFilter[ 80 ]; // random
                WCHAR szFilepath[ MAX_PATH ] = { L'\0'};   // bigger?
                WCHAR szSIF[ ] = { L"SIF"};
                DWORD dw;
                OPENFILENAME ofn;

                // Build OpenFileName dialogs filter
                ZeroMemory( szFilter, sizeof(szFilter) );
                dw = LoadString( g_hInstance,
                                 IDS_OFN_SIF_FILTER,
                                 szFilter,
                                 ARRAYSIZE(szFilter) );
                Assert( dw );
                dw++;   // include NULL character
                wcscat( &szFilter[dw], L"*.SIF" );
#ifdef DEBUG
                // paranoid... make sure it fits!
                dw += wcslen( &szFilter[dw] ) + 2; // +2 = one for each NULL character
                Assert( dw + 2 <= sizeof(szFilter) );
#endif // DEBUG

                // Build OpenFileName structure
                ZeroMemory( &ofn, sizeof(ofn) );
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner   = hDlg;
                ofn.hInstance   = g_hInstance;
                ofn.lpstrFilter = szFilter;
                ofn.lpstrFile   = szFilepath;
                ofn.nMaxFile    = ARRAYSIZE(szFilepath);
                ofn.Flags       = OFN_ENABLESIZING | OFN_FILEMUSTEXIST
                                  | OFN_HIDEREADONLY;
                ofn.lpstrDefExt = szSIF;
                if ( GetOpenFileName( &ofn ) ) {
                    SetDlgItemText( hDlg, IDC_E_FILEPATH, szFilepath );
                    return TRUE;
                }
            }
            break;
        }
        break;
    }

    return FALSE;
}

//
// Page6DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page6DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_OSES ), FALSE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszServerName );
                if ( lpc->_pszServerName ) {
                    LPWSTR pszStartPath =
                    (LPWSTR) TraceAllocString( LMEM_FIXED,
                                               wcslen( lpc->_pszServerName )
                                               + ARRAYSIZE(SERVER_START_STRING) );
                    if ( pszStartPath ) {
                        wsprintf( pszStartPath,
                                  SERVER_START_STRING,
                                  lpc->_pszServerName );
                        lpc->_hDlg = hDlg;
                        lpc->_hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                        // bugbug what if this fails?
                        lpc->_PopulateImageListView( pszStartPath );
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszDestPath) {
                        TraceFree( lpc->_pszDestPath );
                        lpc->_pszDestPath = NULL;
                    }

                    lpc->_pszDestPath =
                    (LPWSTR) TraceAllocString( LMEM_FIXED,
                                               wcslen( pSIF->pszFilePath )
                                               + ARRAYSIZE(SLASH_TEMPLATES) );
                    if ( !lpc->_pszDestPath ) {
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue;
                        return TRUE;
                    }

                    wcscpy( lpc->_pszDestPath, pSIF->pszFilePath );
                    wcscat( lpc->_pszDestPath, SLASH_TEMPLATES );
                    lpc->_fDestPathIncludesSIF = FALSE;

                    if ( lpc->_pszDestImage
                         && lpc->_pszDestImage != lpc->_szNA )
                        TraceFree( lpc->_pszDestImage );
                    // no need to NULL - it set again below

                    lpc->_pszDestImage = pSIF->pszImageFile;
                    pSIF->pszImageFile = NULL; // don't free this

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                    UINT iItems =
                    ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page7DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page7DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_SIFS ), FALSE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromSamples ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszDestPath );
                if ( lpc->_pszDestPath ) {
                    LPWSTR pszStartPath =
                    (LPWSTR) TraceStrDup( lpc->_pszDestPath );
                    if ( pszStartPath ) {
                        // remove the "\templates" from the path
                        LPWSTR psz = StrRChr( pszStartPath,
                                              &pszStartPath[wcslen(pszStartPath)],
                                              L'\\' );
                        Assert( psz );
                        if ( psz ) {
                            *psz = L'\0'; // terminate
                            lpc->_hDlg = hDlg;
                            lpc->_hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                            //bugbug this could fail.
                            lpc->_PopulateSamplesListView( pszStartPath );
                            *psz = L'\\'; // restore
                        }
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    DWORD  dw;
                    HWND   hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszSourcePath ) {
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                    }

                    if ( lpc->_pszSourceImage
                         && lpc->_pszSourceImage != lpc->_szNA
                         && lpc->_pszSourceImage != lpc->_szLocation ) {
                        TraceFree( lpc->_pszSourceImage );
                        lpc->_pszSourceImage = NULL;
                    }

                    lpc->_pszSourcePath  = pSIF->pszFilePath;
                    lpc->_pszSourceImage = pSIF->pszImageFile;

                    if ( pSIF->pszDescription ) {
                        wcsncpy( lpc->_szDescription, pSIF->pszDescription, ARRAYSIZE(lpc->_szDescription) );
                        lpc->_szDescription[ARRAYSIZE(lpc->_szDescription)-1] = L'\0';
                    } else {
                        lpc->_szDescription[0] = L'\0';
                    }

                    if ( pSIF->pszHelpText ) {
                        wcsncpy( lpc->_szHelpText, pSIF->pszHelpText, ARRAYSIZE(lpc->_szHelpText) );
                        lpc->_szHelpText[ARRAYSIZE(lpc->_szHelpText)-1] = L'\0';
                    } else {
                        lpc->_szHelpText[0] = L'\0';
                    }

                    pSIF->pszFilePath    = NULL;    // don't free this, we're using it
                    pSIF->pszImageFile   = NULL;    // don't free this, we're using it

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    UINT iItems = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page8DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page8DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    Assert( lpc->_pszSourcePath );
                    Assert( lpc->_pszDestPath );

                    LPWSTR pszDestFilePath;
                    ULONG  uDestLength = wcslen( lpc->_pszDestPath );
                    LPWSTR pszFilename;

                    lpc->_fSIFCanExist = FALSE; // reset

                    if ( lpc->_fDestPathIncludesSIF ) {   // strip the filename
                        LPWSTR psz = StrRChr( lpc->_pszDestPath,
                                              &lpc->_pszDestPath[ uDestLength ],
                                              L'\\' );
                        Assert(psz);
                        *psz = L'\0';   // truncate
                        lpc->_fDestPathIncludesSIF = FALSE;

                        if ( !lpc->_fShowedPage8 ) {
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                            return TRUE;
                        }

                        psz++;
                        pszFilename = psz;
                    } else {
                        pszFilename =
                        StrRChr( lpc->_pszSourcePath,
                                 &lpc->_pszSourcePath[wcslen(lpc->_pszSourcePath)],
                                 L'\\' );
                        Assert( pszFilename );
                        pszFilename++;  // move past the '\'

                        pszDestFilePath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                   uDestLength + 1
                                                   + wcslen( pszFilename ) + 1 );
                        if ( pszDestFilePath ) {
                            wcscpy( pszDestFilePath, lpc->_pszDestPath );
                            wcscat( pszDestFilePath, L"\\" );
                            wcscat( pszDestFilePath, pszFilename );

                            DWORD dwAttrs = GetFileAttributes( pszDestFilePath );
                            if ( dwAttrs == 0xFFFFffff ) { // file does not exist on destination server.
                                                           // Use the same SIF as the source.
                                TraceFree( lpc->_pszDestPath );
                                lpc->_pszDestPath = pszDestFilePath;
                                lpc->_fDestPathIncludesSIF = TRUE;
                                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                                return TRUE;
                            }
                            TraceFree( pszDestFilePath );
                        }
                        // else be paranoid and prompt for a name
                    }

                    HWND hwnd = GetDlgItem( hDlg, IDC_E_FILENAME );
                    Assert( uDestLength <= MAX_PATH );
                    Edit_LimitText( hwnd, MAX_PATH - uDestLength );
                    Edit_SetText( hwnd, pszFilename );
                    lpc->_fShowedPage8 = TRUE;
                }
                break;

            case PSN_WIZBACK:
                lpc->_fShowedPage8 = FALSE;     // reset this
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    Assert( lpc->_pszDestPath );
                    Assert( !lpc->_fDestPathIncludesSIF );

                    HWND  hwndEdit    = GetDlgItem( hDlg, IDC_E_FILENAME );
                    ULONG uLength     = Edit_GetTextLength( hwndEdit );
                    ULONG uLengthDest = wcslen( lpc->_pszDestPath );
                    DWORD dwAttrs;

                    Assert( uLength );
                    AssertMsg( uLengthDest + uLength <= MAX_PATH,
                               "The Edit_LimitText() should prevent this from happening." );

                    uLength++;  // add one for the NULL

                    LPWSTR pszNewDestPath =
                    (LPWSTR) TraceAllocString( LMEM_FIXED,
                                               uLengthDest + 1 + uLength );
                    if ( !pszNewDestPath )
                        goto PSN_WIZNEXT_Abort;

                    wcscpy( pszNewDestPath, lpc->_pszDestPath );
                    wcscat( pszNewDestPath, L"\\" );

                    Edit_GetText( hwndEdit, &pszNewDestPath[uLengthDest + 1], uLength );

                    if ( !VerifySIFText( pszNewDestPath )
                         || StrChr( pszNewDestPath, 32 ) != NULL ) { // no spaces!
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE,
                                               IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT,
                                               MB_OK );
                        goto PSN_WIZNEXT_Abort;
                    }

                    // make sure it doesn't exist.
                    dwAttrs = GetFileAttributes( pszNewDestPath );
                    if ( dwAttrs != 0xFFFFffff ) { // file exists, verify with user to overwrite
                        UINT i = MessageBoxFromStrings( hDlg,
                                                        IDS_OVERWRITE_CAPTION,
                                                        IDS_OVERWRITE_TEXT,
                                                        MB_YESNO );
                        if ( i == IDNO ) {
                            goto PSN_WIZNEXT_Abort;
                        } else {
                            lpc->_fSIFCanExist = TRUE;
                        }
                    }

                    uLength = wcslen( pszNewDestPath );
                    if ( _wcsicmp( &pszNewDestPath[ uLength - 4 ], L".SIF" ) != 0 ) {
                        UINT i = MessageBoxFromStrings( hDlg,
                                                        IDC_IMPROPER_EXTENSION_CAPTION,
                                                        IDC_IMPROPER_EXTENSION_TEXT,
                                                        MB_YESNO );
                        if ( i == IDNO )
                            goto PSN_WIZNEXT_Abort;
                    }

                    TraceFree( lpc->_pszDestPath );
                    lpc->_pszDestPath = pszNewDestPath;
                    lpc->_fDestPathIncludesSIF = TRUE;
                    return FALSE; // do it
                    PSN_WIZNEXT_Abort:
                    if ( pszNewDestPath )
                        TraceFree( pszNewDestPath );
                    // no need to NULL, going out of scope
                    SetFocus( hwndEdit );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                    return TRUE;
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) ) {
        case IDC_E_FILENAME:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                LONG uLength = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_FILENAME ) );
                if ( !uLength ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                } else {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}

//
// Page9DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page9DlgProc(
                       HWND hDlg,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ),
                            ARRAYSIZE(lpc->_szDescription) - 1 );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT),
                            ARRAYSIZE(lpc->_szHelpText) - 1 );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    Assert( lpc->_pszSourcePath );
                    SetDlgItemText( hDlg, IDC_E_DESCRIPTION, lpc->_szDescription);
                    SetDlgItemText( hDlg, IDC_E_HELPTEXT, lpc->_szHelpText );
                    if ( !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) )
                         || !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT ) ) ) {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    } else {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    GetDlgItemText( hDlg,
                                    IDC_E_DESCRIPTION,
                                    lpc->_szDescription,
                                    ARRAYSIZE(lpc->_szDescription) );
                    GetDlgItemText( hDlg,
                                    IDC_E_HELPTEXT,
                                    lpc->_szHelpText,
                                    ARRAYSIZE(lpc->_szHelpText) );
                    if ( !VerifySIFText( lpc->_szDescription ) ) {
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                               MB_OK );
                        SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't change
                        return TRUE;
                    }

                    if ( !VerifySIFText( lpc->_szHelpText ) ) {
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                               MB_OK );
                        SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't change
                        return TRUE;
                    }
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        switch ( LOWORD( wParam ) ) {
        case IDC_E_DESCRIPTION:
        case IDC_E_HELPTEXT:
            if ( HIWORD( wParam ) == EN_CHANGE ) {
                if ( !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) )
                     || !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT ) ) ) {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                } else {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}


//
// Page10DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page10DlgProc(
                        HWND hDlg,
                        UINT uMsg,
                        WPARAM wParam,
                        LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg ) {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch ( lpnmhdr->code ) {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif ) {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                } else {
                    WCHAR szTemp[ MAX_PATH ];
                    RECT  rect;

                    Assert( lpc->_pszSourcePath );
                    Assert( lpc->_pszDestPath );
                    Assert( lpc->_pszSourceImage );
                    Assert( lpc->_pszDestImage );

                    SetDlgItemText( hDlg, IDC_E_SOURCE, lpc->_pszSourcePath );

                    wcsncpy( szTemp, lpc->_pszSourceImage,MAX_PATH );
                    szTemp[MAX_PATH-1] = L'\0';
                    GetWindowRect( GetDlgItem( hDlg, IDC_S_SOURCEIMAGE ), &rect );
                    PathCompactPath( NULL, szTemp, rect.right - rect.left );
                    SetDlgItemText( hDlg, IDC_S_SOURCEIMAGE, szTemp );

                    SetDlgItemText( hDlg, IDC_E_DESTINATION, lpc->_pszDestPath );

                    wcsncpy( szTemp, lpc->_pszDestImage, MAX_PATH );
                    szTemp[MAX_PATH-1] = L'\0';
                    GetWindowRect( GetDlgItem( hDlg, IDC_S_DESTIMAGE ), &rect );
                    PathCompactPath( NULL, szTemp, rect.right - rect.left );
                    SetDlgItemText( hDlg, IDC_S_DESTIMAGE, szTemp );

                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_FINISH );
                }
                break;

            case PSN_WIZFINISH:
                TraceMsg( TF_WM, "PSN_WIZFINISH\n" );
                Assert( lpc->_pszSourcePath );
                Assert( lpc->_pszDestPath );
                Assert( wcslen( lpc->_pszSourcePath ) <= MAX_PATH );
                Assert( wcslen( lpc->_pszDestPath ) <= MAX_PATH );
                if ( !CopyFile( lpc->_pszSourcePath, lpc->_pszDestPath, !lpc->_fSIFCanExist ) ) {
                    DWORD dwErr = GetLastError( );
                    MessageBoxFromError( hDlg, IDS_ERROR_COPYING_FILE, dwErr );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue;
                    return TRUE;
                } else {
                    WCHAR szTemp[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 + 1 ];
                    Assert( REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT
                            < REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
                    wsprintf( szTemp, L"\"%s\"", lpc->_szDescription );
                    WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                               OSCHOOSER_DESCRIPTION_ENTRY,
                                               szTemp,
                                               lpc->_pszDestPath );
                    wsprintf( szTemp, L"\"%s\"", lpc->_szHelpText );
                    WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                               OSCHOOSER_HELPTEXT_ENTRY,
                                               szTemp,
                                               lpc->_pszDestPath );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;
    }

    return FALSE;
}


//
// Verifies that the user wanted to cancel setup.
//
INT
THISCLASS::_VerifyCancel( HWND hParent )
{
    TraceClsFunc( "_VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    RETURN(!fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\addwiz.h ===
//
// Copyright 1997 - Microsoft

//
// ADDWIZ.H - "Add" sif or image wizard class
//


#ifndef _ADDWIZ_H_
#define _ADDWIZ_H_

// Definitions
HRESULT
CAddWiz_CreateInstance( HWND hwndParent, LPUNKNOWN punk );

class CAddWiz;
typedef CAddWiz* LPCADDWIZ;
typedef HRESULT (*LPNEXTOP)( LPCADDWIZ lpc );

// CAddWiz
class
CAddWiz
{
private:
    WCHAR     _szNA[ 32 ];
    WCHAR     _szLocation[ 67 ];
    LPUNKNOWN _punk;
    HWND      _hDlg;
    HWND      _hwndList;
    LPWSTR    _pszPathBuffer;
    DWORD     _dwPathBufferSize;

    // "Add Wizard" flags
    BOOL    _fAddSif:1;
    BOOL    _fNewImage:1;
    BOOL    _fCopyFromServer:1;
    BOOL    _fCopyFromSamples:1;
    BOOL    _fCopyFromLocation:1;
    BOOL    _fDestPathIncludesSIF:1;
    BOOL    _fShowedPage8:1;
    BOOL    _fSIFCanExist:1;

    LPWSTR  _pszServerName;
    LPWSTR  _pszSourcePath;
    LPWSTR  _pszSourceImage;
    LPWSTR  _pszDestPath;
    LPWSTR  _pszDestImage;
    LPWSTR  _pszSourceServerName;

    WCHAR _szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
    WCHAR _szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];

private: // Methods
    CAddWiz();
    ~CAddWiz();
    STDMETHOD(Init)( HWND hwndParent, LPUNKNOWN punk );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    static INT_PTR CALLBACK
        EditSIFDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page1DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page2DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page3DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page4DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page5DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page6DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page7DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page8DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page9DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page10DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT     _VerifyCancel( HWND hDlg );
    STDMETHOD(_PopulateSamplesListView)( LPWSTR pszStartPath );
    STDMETHOD(_PopulateTemplatesListView)( LPWSTR pszStartPath );
    STDMETHOD(_PopulateImageListView)( LPWSTR pszStartPath );
    STDMETHOD(_FindLanguageDirectory)( LPNEXTOP lpNextOperation );
    STDMETHOD(_FindOSDirectory)( LPNEXTOP lpNextOperation );
    STDMETHOD(_EnumeratePlatforms)( LPNEXTOP lpNextOperation );
    static HRESULT _EnumerateTemplates( LPCADDWIZ lpc );
    static HRESULT _EnumerateImages( LPCADDWIZ lpc );
    STDMETHOD(_CheckImageType)( );
    STDMETHOD(_EnumerateSIFs)( );
    STDMETHOD(_AddItemToListView)( );
    STDMETHOD(_CleanupSIFInfo)( LPSIFINFO pSIF );
    STDMETHOD(_InitListView)( HWND hwndList, BOOL fShowDirectoryColumn );
    static HRESULT _OnSearch( HWND hwndParent );

public: // Methods
    friend HRESULT CAddWiz_CreateInstance( HWND hwndParent, LPUNKNOWN punk );
};

#endif // _ADDWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cenumsif.h ===
//
// Copyright 1997 - Microsoft
//

//
// CENUMSIF.H - Handles enumerating OSes and Tools SIFs from DS
//

#ifndef _CENUMSIF_H_
#define _CENUMSIF_H_

// Flag Definitions
#define ENUM_READ   0x00000000
#define ENUM_WRITE  0x00000001

// QI Table
BEGIN_QITABLE( CEnumIMSIFs )
DEFINE_QI( IID_IEnumIMSIFs, IEnumIMSIFs, 4 )
END_QITABLE

// Definitions
LPVOID
CEnumIMSIFs_CreateInstance( 
    LPWSTR pszEnumPath, 
    LPWSTR pszAttribute, 
    DWORD dwFlags, 
    IADs * pads );

// Private Interface Definition
interface 
IEnumIMSIFs:
    public IUnknown
{
public:
    STDMETHOD(Next)( ULONG celt, LPWSTR * rgelt, ULONG * pceltFetched ) PURE; 
    STDMETHOD(Skip)( ULONG celt  ) PURE; 
    STDMETHOD(Reset)(void) PURE;
    STDMETHOD(Clone)( LPUNKNOWN * ppenum ) PURE;    
};

typedef IEnumIMSIFs * LPENUMIMSIFS;

// CEnumIMSIFs
class 
CEnumIMSIFs:
    public IEnumIMSIFs
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CEnumIMSIFs );

    // IIntelliMirror
    IADs *   _pads;                 // ADS Object
    LPWSTR   _pszAttribute;         // Attribute to enumerate
    int      _iIndex;               // Index

    LPWSTR   _pszServerName;        // DNS name of server
    HANDLE   _hLanguage;            // FindFile handle for Languages
    LPWSTR   _pszLanguage;          // last language found
    LPWSTR   _pszEnumPath;          // \\Server\IMIRROR\Setup\<language>\<_pszEnumPath>\*
    HANDLE   _hOS;                  // FindFile handle for OSes
    LPWSTR   _pszOS;                // last OS found
    HANDLE   _hArchitecture;        // FindFile handle for Architectures
    LPWSTR   _pszArchitecture;      // last Architecture found
    HANDLE   _hSIF;                 // FindFile handle for SIF files
    LPWSTR   _pszSIF;               // last SIF found

    // Flags for enumeration -- currently this only supports "read"
    union {
        DWORD       _dwFlags;       
        struct {
            BOOL _fWrite:1;
        };
    };

private: // Methods
    CEnumIMSIFs();
    ~CEnumIMSIFs();
    STDMETHOD(Init)( LPWSTR pszEnumPath, LPWSTR pszAttribute, DWORD dwFlags, IADs * pads );

    HRESULT _FindNextItem( LPWSTR * pszFilePath );
    HRESULT _NextLanguage( );
    HRESULT _NextOS( );
    HRESULT _NextArchitecture( );
    HRESULT _NextSIF( );

public: // Methods
    friend LPVOID 
        CEnumIMSIFs_CreateInstance( LPWSTR pszEnumPath, LPWSTR pszAttribute, 
                                    DWORD dwFlags, IADs * pads );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IEnumIMThings
    STDMETHOD(Next)( ULONG celt, LPWSTR * rgelt, ULONG * pceltFetched ); 
    STDMETHOD(Skip)( ULONG celt  ); 
    STDMETHOD(Reset)(void); 
    STDMETHOD(Clone)( LPUNKNOWN * ppenum );    
};

typedef CEnumIMSIFs* LPENUMSIFS;

#endif // _CENUMSIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cenumsif.cpp ===
//
// Copyright 1997 - Microsoft

//
// CENUMSIF.CPP - Handles enumerating OSes and Tools SIFs from DS
//

#include "pch.h"

#include "cenumsif.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CEnumIMSIFs")
#define THISCLASS CEnumIMSIFs
#define LPTHISCLASS LPENUMSIFS

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CEnumIMSIFs_CreateInstance(
                          LPWSTR pszEnumPath,
                          LPWSTR pszAttribute, 
                          DWORD dwFlags, 
                          IADs * pads )
{
    TraceFunc( "CEnumIMSIFs_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( pszEnumPath, pszAttribute, dwFlags, pads ) );

    if ( FAILED(hr)) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _cRef(0),
    _pads(NULL),
    _pszAttribute(NULL),
    _iIndex(0),
    _pszServerName(NULL),
    _hLanguage(INVALID_HANDLE_VALUE),
    _pszLanguage(NULL),
    _pszEnumPath(NULL),
    _hOS(INVALID_HANDLE_VALUE),
    _pszOS(NULL),
    _hArchitecture(INVALID_HANDLE_VALUE),
    _pszArchitecture(NULL),
    _hSIF(INVALID_HANDLE_VALUE),
    _pszSIF(NULL)
{
    TraceClsFunc( "CEnumIMSIFs()\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}


//
// Init()
//
STDMETHODIMP
THISCLASS::Init(
               LPWSTR pszEnumPath,
               LPWSTR pszAttribute, 
               DWORD dwFlags, 
               IADs * pads )
{
    TraceClsFunc( "Init()\n" );

    HRESULT hr = S_OK;
    LPWSTR  psz;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CEnumIMSIFs, IEnumIMSIFs );
    QITABLE_IMP( IEnumIMSIFs );
    END_QITABLE_IMP( CEnumIMSIFs );
    Assert( _cRef == 0);
    AddRef( );

    // Private Members
    Assert( _iIndex == 0 );
    Assert( !_pszLanguage );
    Assert( !_pszOS );
    Assert( !_pszArchitecture );
    Assert( !_pszSIF );

    pads->AddRef( );
    _pads = pads;

    //
    // get the netbootserver property (dn of the RIS server)
    //
    Str = NETBOOTSERVER;
    hr = THR( _pads->Get( Str, &var ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // now convert it to the FQDN of the server.
    //
    psz = V_BSTR( &var );
    hr = THR( DNtoFQDNEx( psz, &_pszServerName ) );
    if (FAILED(hr)) {
        goto Error;
    }

    _dwFlags = dwFlags;

    _pszAttribute = (LPWSTR) TraceStrDup( pszAttribute );
    if ( !_pszAttribute ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    _pszEnumPath = (LPWSTR) TraceStrDup( pszEnumPath );
    if ( !_pszEnumPath ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    _hLanguage     = INVALID_HANDLE_VALUE;
    _hOS           = INVALID_HANDLE_VALUE;
    _hArchitecture = INVALID_HANDLE_VALUE;
    _hSIF          = INVALID_HANDLE_VALUE;

    Error:  // Destructor will handle cleanup
    VariantClear( &var );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CEnumIMSIFs()\n" );

    // Private Members
    if ( _pads ) {
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
        _pads->Release( );
    }

    if ( _pszAttribute )
        TraceFree( _pszAttribute );

    if ( _pszEnumPath )
        TraceFree( _pszEnumPath );

    if ( _hLanguage != INVALID_HANDLE_VALUE )
        FindClose( _hLanguage );

    if ( _hOS != INVALID_HANDLE_VALUE )
        FindClose( _hOS );

    if ( _hSIF != INVALID_HANDLE_VALUE )
        FindClose( _hSIF  );

    if ( _pszLanguage )
        TraceFree( _pszLanguage );

    if ( _pszOS )
        TraceFree( _pszOS );

    if ( _pszSIF )
        TraceFree( _pszSIF );

    if ( _pszServerName )
        TraceFree( _pszServerName );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
                         REFIID riid, 
                         LPVOID *ppv )
{
    TraceClsFunc( "[IUnknown] QueryInterface( riid=" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IEnumIMSIFs
//
// ************************************************************************

//
// Next( )
//
HRESULT 
THISCLASS::Next(
               ULONG celt, 
               LPWSTR * rgelt, 
               ULONG * pceltFetched )
{
    TraceClsFunc( "[IEnumIMSIFs] Next( ... )\n" );

    HRESULT hr = S_OK;

    if ( !rgelt ) {
        RRETURN(E_POINTER);
    }

    if (pceltFetched) {
        *pceltFetched = 0;
    }

    if ( _fWrite ) {
        hr = THR(E_NOTIMPL);
    } else {    // READ
        for ( ULONG ul = 0; ul < celt; ul++ ) {
            hr = _FindNextItem( &rgelt[ ul ] );
            if ( hr != S_OK) {
                goto Error;
            }
        }

        if (pceltFetched) {
            *pceltFetched = ul;
        }
    }


    Cleanup:
    HRETURN(hr);

    Error:
    goto Cleanup;
}


//
// Skip( )
//
HRESULT 
THISCLASS::Skip(
               ULONG celt  )
{
    TraceClsFunc( "[IEnumIMSIFs] Skip( ... )\n" );

    HRESULT hr = S_OK;

    for ( ULONG ul = 0; ul < celt; ul++ ) {
        _iIndex++;

        hr = THR( _FindNextItem( NULL ) );
        if ( hr == E_POINTER ) {   // expected result
            hr = S_OK;
        } else if ( hr != S_OK ) {
            goto Error;
        }
    }

    Error:
    HRETURN(hr);
}


//
// Reset( )
//
HRESULT 
THISCLASS::Reset( void )
{
    TraceClsFunc( "[IEnumIMSIFs] Reset( ... )\n" );

    HRESULT hr = S_OK;

    _iIndex = 0;

    if ( _hLanguage != INVALID_HANDLE_VALUE ) {
        FindClose( _hLanguage );
        _hLanguage = INVALID_HANDLE_VALUE;
    }

    if ( _hOS != INVALID_HANDLE_VALUE ) {
        FindClose( _hOS );
        _hOS = INVALID_HANDLE_VALUE;
    }

    if ( _hArchitecture != INVALID_HANDLE_VALUE ) {
        FindClose( _hArchitecture );
        _hArchitecture = INVALID_HANDLE_VALUE;
    }

    if ( _hSIF != INVALID_HANDLE_VALUE ) {
        FindClose( _hSIF );
        _hSIF = INVALID_HANDLE_VALUE;
    }

    HRETURN(hr);
}


//
// Clone( )
//
HRESULT 
THISCLASS::Clone(
                LPUNKNOWN * ppenum )
{
    TraceClsFunc( "[IEnumIMSIFs] Clone( ... )\n" );

    if ( !ppenum )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    *ppenum = (LPUNKNOWN) CEnumIMSIFs_CreateInstance( _pszEnumPath, 
                                                      _pszAttribute,
                                                      _dwFlags,
                                                      _pads );

    if ( !*ppenum ) {
        hr = THR(E_FAIL);
    }

    HRETURN(hr);
}


// ************************************************************************
//
// Privates
//
// ************************************************************************


//
// _FindNextItem( )
//
HRESULT
THISCLASS::_FindNextItem(
                        LPWSTR * ppszFileName )
{
    TraceClsFunc( "_FindNextItem( ... )\n" );

    HRESULT hr = S_FALSE;
    WCHAR   szFilePath[ MAX_PATH ];

    if ( _hLanguage == INVALID_HANDLE_VALUE ) {
        hr = _NextLanguage( );
        if (hr != S_OK) {
            goto Error;
        }
    }

    if ( _hOS == INVALID_HANDLE_VALUE ) {
        hr = _NextOS( );
        if (hr != S_OK) {
            goto Error;
        }
    }

    if ( _hArchitecture == INVALID_HANDLE_VALUE ) {
        hr = _NextArchitecture( );
        if (hr != S_OK) {
            goto Error;
        }
    }

    hr = _NextSIF( );
    if (hr != S_OK) {
        goto Error;
    }

    // NOTE: Skip( ) passes NULL in to "skip" and should except this error.
    if ( !ppszFileName ) {
        HRETURN(E_POINTER);
    }

    //
    // make sure we're in an expected internal state.
    //
    if (!_pszServerName || !_pszLanguage || !_pszEnumPath ||
        !_pszOS || !_pszArchitecture || !_pszSIF) {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        goto Error;
    }
    // Create a buffer
    //            1               2           3
    // 12  345678901234567  8  9  0  12345678901  = 31 + NULL = 32
    // \\%s\REMINST\SETUP\%s\%s\%s\%s\templates\%s
    DWORD dwBufLen = 32 + wcslen( _pszServerName ) + wcslen( _pszServerName ) +
                     wcslen( _pszLanguage ) + wcslen( _pszEnumPath ) + 
                     wcslen( _pszOS ) + wcslen( _pszArchitecture ) + wcslen( _pszSIF );

    *ppszFileName = (LPWSTR ) TraceAllocString( LMEM_FIXED, dwBufLen );
    if ( !*ppszFileName || 
         _snwprintf( *ppszFileName,
                     dwBufLen,
                     L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\%s" SLASH_TEMPLATES L"\\%s",
                     _pszServerName,
                     _pszLanguage,
                     _pszEnumPath,
                     _pszOS,
                     _pszArchitecture,
                     _pszSIF ) < 0) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);

Error:
    *ppszFileName = NULL;
    goto Cleanup;
}

//
// _NextLanguage( )
//
HRESULT
THISCLASS::_NextLanguage( )
{
    TraceClsFunc( "_NextLanguage( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszLanguage ) {
        TraceFree( _pszLanguage );
        _pszLanguage = NULL;
    }

    if ( _hLanguage == INVALID_HANDLE_VALUE ) {
        WCHAR szFilePath[ MAX_PATH ];

        if (_snwprintf( 
                szFilePath,
                MAX_PATH,
                L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\*",
                _pszServerName) < 0) {
            hr = E_FAIL;
            goto Cleanup;
        }

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hLanguage = FindFirstFile( szFilePath, &fd );
        if ( _hLanguage == INVALID_HANDLE_VALUE ) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hLanguage, &fd ) ) {
        if ( fd.cFileName[0] != L'.' ) {
            _pszLanguage = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszLanguage ) {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

Cleanup:
    HRETURN(hr);

}

//
// _NextOS( )
//
HRESULT
THISCLASS::_NextOS( )
{
    TraceClsFunc( "_NextOS( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszOS ) {
        TraceFree( _pszOS );
        _pszOS = NULL;
    }

    if ( _hOS == INVALID_HANDLE_VALUE ) {
        WCHAR szFilePath[ MAX_PATH ];

        if (_snwprintf( 
                  szFilePath,
                  MAX_PATH,
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\*",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath) < 0) {
            hr = E_FAIL;
            goto Cleanup;
        }
        szFilePath[MAX_PATH-1] = L'\0';

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hOS = FindFirstFile( szFilePath, &fd );
        if ( _hOS == INVALID_HANDLE_VALUE ) {
            goto TryAgain;
        }

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hOS, &fd ) ) {
        if ( fd.cFileName[0] != L'.' ) {
            _pszOS = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszOS ) {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

    if (hr != S_OK) {
        goto TryAgain;
    }

    Cleanup:
    HRETURN(hr);

    TryAgain:
    if ( _hOS != INVALID_HANDLE_VALUE ) {
        FindClose( _hOS );
        _hOS = INVALID_HANDLE_VALUE;

    }

    hr = _NextLanguage( );
    if (hr != S_OK) {
        goto Cleanup;
    }

    hr = _NextOS( ); // recurse
    goto Cleanup;
}

//
// _NextArchitecture( )
//
HRESULT
THISCLASS::_NextArchitecture( )
{
    TraceClsFunc( "_NextArchitecture( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszArchitecture ) {
        TraceFree( _pszArchitecture );
        _pszArchitecture = NULL;
    }

    if ( _hArchitecture == INVALID_HANDLE_VALUE ) {
        WCHAR szFilePath[ MAX_PATH ];

        if (_snwprintf( 
                  szFilePath,
                  MAX_PATH,
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\*",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath,
                  _pszOS) < 0) {
            hr = E_FAIL;
            goto Cleanup;
        }
        szFilePath[MAX_PATH-1] = L'\0';

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hArchitecture = FindFirstFile( szFilePath, &fd );
        if ( _hArchitecture == INVALID_HANDLE_VALUE ) {
            goto TryAgain;
        }

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hArchitecture, &fd ) ) {
        if ( fd.cFileName[0] != L'.' ) {
            _pszArchitecture = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszArchitecture ) {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

    if (hr != S_OK) {
        goto TryAgain;
    }

    Cleanup:
    HRETURN(hr);

    TryAgain:
    if ( _hArchitecture != INVALID_HANDLE_VALUE ) {
        FindClose( _hArchitecture );
        _hArchitecture = INVALID_HANDLE_VALUE;
    }

    hr = _NextOS( );
    if (hr != S_OK) {
        goto Cleanup;
    }

    hr = _NextArchitecture( ); // recurse
    goto Cleanup;
}

//
// _NextSIF( )
//
HRESULT
THISCLASS::_NextSIF( )
{
    TraceClsFunc( "_NextSIF( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszSIF ) {
        TraceFree( _pszSIF );
        _pszSIF = NULL;
    }

    if ( _hSIF == INVALID_HANDLE_VALUE ) {
        WCHAR szFilePath[ MAX_PATH ];

        if (_snwprintf( 
                  szFilePath,
                  MAX_PATH,
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\%s" SLASH_TEMPLATES L"\\*.sif",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath,
                  _pszOS,
                  _pszArchitecture ) < 0) {
            hr = E_FAIL;
            goto Cleanup;
        }

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hSIF = FindFirstFile( szFilePath, &fd );
        if ( _hSIF == INVALID_HANDLE_VALUE ) {
            goto TryAgain;
        }
    } else {
        if ( !FindNextFile( _hSIF, &fd ) )
            goto TryAgain;
    }

    _pszSIF = (LPWSTR) TraceStrDup( fd.cFileName );
    if ( !_pszSIF ) {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    hr = S_OK;

    Cleanup:
    HRETURN(hr);

    TryAgain:
    if ( _hSIF != INVALID_HANDLE_VALUE ) {
        FindClose( _hSIF );
        _hSIF = INVALID_HANDLE_VALUE;
    }

    hr = _NextArchitecture( );
    if (hr != S_OK) {
        goto Cleanup;
    }

    hr = _NextSIF( ); // recurse
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cfactory.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// CFACTORY.CPP - Class Factory Object
//

#include "pch.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CFactory")
#define THISCLASS CFactory

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// Constructor
//
THISCLASS::THISCLASS( LPCREATEINST pfn )
{
    TraceClsFunc( "CFactory()\n" );

    _pfnCreateInstance = pfn; 

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

STDMETHODIMP
THISCLASS::Init( )
{
    TraceClsFunc( "Init()\n");

    //
    // IUnknown stuff
    //
    Assert( _cRef == 0 );

    // Build QI Table
    BEGIN_QITABLE_IMP( CFactory, IClassFactory );
    QITABLE_IMP( IClassFactory );
    END_QITABLE_IMP( CFactory );

    // Add one count
    AddRef( );

    //
    // Private Members
    //

    HRETURN(S_OK);
};

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CFactory()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IClassFactory
//
// ************************************************************************

//
// CreateInstance()
//
STDMETHODIMP 
THISCLASS::
    CreateInstance(
        IUnknown *pUnkOuter, 
        REFIID riid, 
        void **ppv )
{
    TraceClsFunc( "[IClassFactory] CreateInstance()\n" );

    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;

    HRESULT     hr  = E_NOINTERFACE;
    IUnknown *  pUnk = NULL; 

    if ( NULL != pUnkOuter )
    {
        hr = THR(CLASS_E_NOAGGREGATION);
        goto Cleanup;
    }

	Assert( _pfnCreateInstance != NULL );
    TraceMsgDo( pUnk = (IUnknown *) _pfnCreateInstance( ), "0x%08x" );
    if ( !pUnk )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    TraceMsgDo( hr = pUnk->QueryInterface( riid, ppv ), "0x%08x" );

Cleanup:
    if ( !!pUnk )
    {
        ULONG cRef;
        TraceMsgDo( cRef = pUnk->Release( ), "%u" );
    }

    HRETURN(hr);
}

//
// LockServer()
//
STDMETHODIMP
THISCLASS::
    LockServer( BOOL fLock )
{
    TraceClsFunc( "[IClassFactory] LockServer()\n");

    if ( fLock )
    {
        InterlockIncrement( g_cLock );
    }
    else
    {
        InterlockDecrement( g_cLock );
    }

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cfactory.h ===
//
// Copyright 1997 - Microsoft
//

//
// CFACTORY.H - Class Factory Object
//

#ifndef _CFACTORY_H_
#define _CFACTORY_H_

//
// QueryInterface Table
//
BEGIN_QITABLE( CFactory )
DEFINE_QI( IID_IClassFactory, IClassFactory, 2 )
END_QITABLE


// CFactory
class 
CFactory:
    public IClassFactory
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CFactory );

    // IClassFactory data
    LPCREATEINST _pfnCreateInstance;

private: // Methods
    CFactory( LPCREATEINST lpfn );
    ~CFactory();
    STDMETHOD(Init)( );

public: // Methods
    friend HRESULT CALLBACK 
        DllGetClassObject( REFCLSID rclsid, REFIID riid, void** ppv );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory
    STDMETHOD(CreateInstance)( IUnknown *punkOuter, REFIID riid, LPVOID *ppv );
    STDMETHOD(LockServer)( BOOL fLock );
};

typedef CFactory* LPCFACTORY ;

#endif // _CFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\ccomputr.h ===
//
// Copyright 1997 - Microsoft
//

//
// CComputr.H - Computer properties class
//

#ifndef _CCOMPUTR_H_
#define _CCOMPUTR_H_

#include <adsprop.h>

// QITable
BEGIN_QITABLE( CComputer )
DEFINE_QI( IID_IShellExtInit,      IShellExtInit      , 1 )
DEFINE_QI( IID_IShellPropSheetExt, IShellPropSheetExt , 2 )
DEFINE_QI( IID_IMAO,               IMAO               , 11 )
END_QITABLE

// Definitions
LPVOID
CComputer_CreateInstance( void );

LPVOID
CreateIntelliMirrorClientComputer( 
    IADs * pads);

// Error Codes
#define E_INVALIDSTATE TYPE_E_INVALIDSTATE

// Private IMAO Interface Definition
class
IMAO:
    public IUnknown
{
public:
    STDMETHOD(CommitChanges)( void ) PURE;                          // 1
    STDMETHOD(IsAdmin)( BOOL *fAdmin ) PURE;                        // 2
    STDMETHOD(IsServer)( BOOL *fServer ) PURE;                      // 3
    STDMETHOD(IsClient)( BOOL *fClient ) PURE;                      // 4
    STDMETHOD(SetServerName)( LPWSTR ppszName ) PURE;               // 5
    STDMETHOD(GetServerName)( LPWSTR * ppszName ) PURE;             // 6
    STDMETHOD(SetGUID)( LPWSTR ppGUID ) PURE;                       // 7
    STDMETHOD(GetGUID)( LPWSTR * ppszGUID, LPGUID pGUID ) PURE;     // 8
    //STDMETHOD(GetSAP)( LPVOID * punk ) PURE;                        // 9
    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj ) PURE;       // 10
    STDMETHOD(GetNotifyWindow)( HWND *phNotifyObj ) PURE;           // 11
};

// CComputer
class 
CComputer:
    public IShellExtInit, IShellPropSheetExt, IMAO
{
private:
    // Enums
    enum { 
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CComputer );

    UINT  _uMode;               // Admin or Shell mode

    LPDATAOBJECT _pDataObj;     // Data Object passed to ServerTab
    LPWSTR       _pszObjectName;// DN of the object

    IADs *   _pads;             // ADs to MAO    
    VARIANT  _vGUID;
    VARIANT  _vMachineFilepath;
    VARIANT  _vInitialization;
    VARIANT  _vSCP;

    HWND     _hwndNotify;       // DS notify window handle

    ADSPROPINITPARAMS _InitParams; // DSA init params

private: // Methods
    CComputer();
    ~CComputer();
    STDMETHOD(Init)();
    STDMETHOD(Init2)( IADs * pads );

public: // Methods
    friend LPVOID CComputer_CreateInstance( void );
    friend LPVOID CreateIntelliMirrorClientComputer( IADs * pads);

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IShellExtInit
    STDMETHOD(Initialize)( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage) ( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IMAO
    STDMETHOD(CommitChanges)( void );
    STDMETHOD(IsAdmin)( BOOL *fAdmin );
    STDMETHOD(IsServer)( BOOL *fServer );
    STDMETHOD(IsClient)( BOOL *fClient );
    STDMETHOD(SetServerName)( LPWSTR ppszName );
    STDMETHOD(GetServerName)( LPWSTR * ppszName );
    STDMETHOD(SetGUID)( LPWSTR ppGUID );
    STDMETHOD(GetGUID)( LPWSTR * ppszGUID, LPGUID pGUID );
    //STDMETHOD(GetSAP)( LPVOID *punk );
    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj );
    STDMETHOD(GetNotifyWindow)( HWND *phNotifyObj );
};

typedef CComputer* LPCOMPUTER;

#endif // _CCOMPUTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\client.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _CLIENT_H_
#define _CLIENT_H_

// Definitions
LPVOID
CClientTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CClientTab
class
CClientTab:
    public ITab
{
private: // Members
    HWND      _hDlg;            // dialogs HWND
    LPUNKNOWN _punkComputer;    // Pointer back to computer object
    BOOL      _fChanged:1;      // UI changed by user
    HWND      _hNotify;         // HWND of the DSA notify object

private: // Methods
    CClientTab();
    ~CClientTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    STDMETHOD(_InitDialog)( HWND hDlg, LPARAM lParam );
    STDMETHOD(_OnCommand)( WPARAM wParam, LPARAM lParam );
    STDMETHOD(_ApplyChanges)( VOID);
    STDMETHOD_(INT,_OnNotify)( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    STDMETHOD(_JumpToServer)( BOOLEAN ShowProperties );
    STDMETHOD(_IsValidRISServer)( IN PCWSTR ServerName );
    static HRESULT _OnSearch( HWND hwndParent );

public: // Methods
    friend LPVOID CClientTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)(LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CClientTab* LPCClientTab;

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\ccomputr.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// CCOMPUTR.CPP - Handles the computer object property pages.
//

#include "pch.h"

#include "client.h"
#include "server.h"
#include "ccomputr.h"

#include "varconv.h"

//
// Begin Class Definitions
//
DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CComputer")
#define THISCLASS CComputer
#define LPTHISCLASS LPCComputer

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CComputer_CreateInstance( void )
{
	TraceFunc( "CComputer_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if (!lpcc)
        RETURN(lpcc);

    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr ))
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// CreateCComputer( )
//
LPVOID
CreateIntelliMirrorClientComputer(
    IADs * pads)
{
    TraceFunc( "CreateCComputer(" );
    TraceMsg( TF_FUNC, "pads = 0x%08x )\n", pads );

    HRESULT   hr;
    LPTHISCLASS lpcc = NULL;

    if ( !pads )
    {
        hr = THR( E_POINTER );
        goto Error;
    }

    lpcc = new THISCLASS( );
    if ( !lpcc )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    hr = THR( lpcc->Init( ) );
    if ( FAILED(hr)) {
        goto Error;
    }

    hr = lpcc->Init2( pads );
    if (hr != S_FALSE) {
        hr = THR(E_FAIL);   // account exists?
        goto Error;
    }

Cleanup:
    RETURN((LPVOID) lpcc);

Error:
    if (lpcc) {
        delete lpcc;
        lpcc = NULL;
    }

    switch (hr) {
    case S_OK:
        break;

    default:
        MessageBoxFromHResult( NULL, IDC_ERROR_CREATINGACCOUNT_TITLE, hr );
        break;
    }
    goto Cleanup;
}

//
// Init2( )
//
STDMETHODIMP
THISCLASS::Init2(
    IADs * pads )
{
    TraceClsFunc( "Init2( ... )\n" );

    HRESULT hr;
    _bstr_t Str;

    _pads = pads;
    _pads->AddRef( );

    Str = NETBOOTGUID;
    hr = _pads->Get( Str, &_vGUID );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) 
        goto Cleanup;

    Str = NETBOOTSAP;
    hr = _pads->Get( Str, &_vSCP );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    Str = NETBOOTMACHINEFILEPATH;
    hr = _pads->Get( Str, &_vMachineFilepath );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    Str = NETBOOTINITIALIZATION;
    hr = _pads->Get( Str, &_vInitialization );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( _vSCP.vt == VT_EMPTY
      || _vGUID.vt == VT_EMPTY
      || _vInitialization.vt == VT_EMPTY
      || _vMachineFilepath.vt == VT_EMPTY )
    {
        //
        // These must be blank since we are setting the attributes
        // of a newly created MAO.
        //
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _cRef(0),
    _uMode(MODE_SHELL),
    _pDataObj(NULL),
    _pszObjectName(NULL),
    _pads(NULL),
    _hwndNotify(NULL)    
{
    TraceClsFunc( "CComputer()\n" );

	InterlockIncrement( g_cObjects );

    VariantInit( &_vGUID );
    VariantInit( &_vMachineFilepath );
    VariantInit( &_vInitialization );
    VariantInit( &_vSCP );

    ZeroMemory(&_InitParams, sizeof(_InitParams));
    _InitParams.dwSize = sizeof(_InitParams);

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CComputer, IShellExtInit );
    QITABLE_IMP( IShellExtInit );
    QITABLE_IMP( IShellPropSheetExt );
    QITABLE_IMP( IMAO );
    END_QITABLE_IMP( CComputer );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    // Private Members
    Assert( !_pads );
    Assert( !_pDataObj );

    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CComputer()\n" );

    // Members
    if ( _pads )
    {
        //
        // note: we shouldn't commit anything in the destructor -- we can't 
        // catch failures here.  We'll just have to make sure that we 
        // explicitly commit changes when necessary
        //
#if 0
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
#endif
        _pads->Release( );
    }

    if ( _pDataObj )
        _pDataObj->Release( );

    if ( _pszObjectName )
        TraceFree( _pszObjectName );

    VariantClear( &_vGUID );
    VariantClear( &_vMachineFilepath );
    VariantClear( &_vInitialization );
    VariantClear( &_vSCP );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};


// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    // Ugly ugly ulgy... but it works
    if ( hr == E_NOINTERFACE && _pDataObj ) {
        hr = _pDataObj->QueryInterface( riid, ppv );
    }

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IShellExtInit
//
// ************************************************************************

//
// Initialize()
//
STDMETHODIMP
THISCLASS::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj,
    HKEY hkeyProgID )
{
    TraceClsFunc( "[IShellExtInit] Initialize( " );
    TraceMsg( TF_FUNC, " pidlFolder = 0x%08x, lpdobj = 0x%08x, hkeyProgID = 0x%08x )\n",
        pidlFolder, lpdobj, hkeyProgID );

    if ( !lpdobj )
        RETURN(E_INVALIDARG);

    HRESULT    hr = S_OK;
    FORMATETC  fmte;
    STGMEDIUM  stg = { 0 };
    STGMEDIUM  stgOptions = { 0 };

    LPWSTR     pszObjectName;
    LPWSTR     pszClassName;
    LPWSTR     pszAttribPrefix;

    LPDSOBJECT             pDsObject;
    LPDSOBJECTNAMES        pDsObjectNames;
    LPDSDISPLAYSPECOPTIONS pDsDisplayOptions;

    BOOL b;

    _bstr_t Str;

    // Hang onto it
    _pDataObj = lpdobj;
    _pDataObj->AddRef( );

    //
    // Retrieve the Object Names
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsObjectNames;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stg) );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    pDsObjectNames = (LPDSOBJECTNAMES) stg.hGlobal;

    Assert( stg.tymed == TYMED_HGLOBAL );

    TraceMsg( TF_ALWAYS, "Object's Namespace CLSID: " );
    TraceMsgGUID( TF_ALWAYS, pDsObjectNames->clsidNamespace );
    TraceMsg( TF_ALWAYS, "\tNumber of Objects: %u \n", pDsObjectNames->cItems );

    Assert( pDsObjectNames->cItems == 1 );

    pDsObject = (LPDSOBJECT) pDsObjectNames->aObjects;

    pszObjectName = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetName );
    pszClassName  = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetClass );

    TraceMsg( TF_ALWAYS, "Object Name (Class): %s (%s)\n", pszObjectName, pszClassName );

    //
    // This must be a "Computer" class
    //
    if ( StrCmp( pszClassName, DSCOMPUTERCLASSNAME ) )
    {
        hr = S_FALSE;
        goto Error;
    }

    //
    // Retrieve the Display Spec Options
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsDisplaySpecOptions;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stgOptions ) );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    pDsDisplayOptions = (LPDSDISPLAYSPECOPTIONS) stgOptions.hGlobal;

    Assert( stgOptions.tymed == TYMED_HGLOBAL );
    Assert( pDsDisplayOptions->dwSize >= sizeof(DSDISPLAYSPECOPTIONS) );

    pszAttribPrefix = (LPWSTR) PtrToByteOffset( pDsDisplayOptions, pDsDisplayOptions->offsetAttribPrefix );

    // TraceMsg( TF_ALWAYS, TEXT("Attribute Prefix: %s\n"), pszAttribPrefix );

    if ( StrCmpW( pszAttribPrefix, STRING_ADMIN ) == 0 )
    {
        _uMode = MODE_ADMIN;
    }
    // else default from Init()

    TraceMsg( TF_ALWAYS, TEXT("Mode: %s\n"), _uMode ? TEXT("Admin") : TEXT("Shell") );

    ReleaseStgMedium( &stgOptions );

    _pszObjectName = TraceStrDup( pszObjectName );
    if ( !_pszObjectName ) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // create the DS notify object
    hr = THR( ADsPropCreateNotifyObj( _pDataObj, _pszObjectName, &_hwndNotify ) );
    if (FAILED( hr ))
        goto Error;

    b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
    if ( !b )
    {
        hr = E_FAIL;
        goto Error;
    }

    hr = THR( _InitParams.hr );
    if (FAILED( hr ))
        goto Error;

    hr = THR( _InitParams.pDsObj->QueryInterface( IID_IADs, (void**) &_pads ) );
    if (FAILED( hr ))
        goto Error;

    //
    // Retrieve the attributes
    //
    Str = NETBOOTGUID;
    hr = _pads->Get(Str, &_vGUID );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) 
        goto Error;

    Str = NETBOOTSAP;
    hr = _pads->Get( Str, &_vSCP );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    //
    // Check to see if this is an MAO that we need to add
    // ourselves to.
    //
    if ( _vSCP.vt == VT_EMPTY && _vGUID.vt == VT_EMPTY )
    {
        //
        // since both are empty, this MAO is not a IntelliMirror client
        // or server.
        //
        hr = S_FALSE;
        goto Error;
    }

    Str = NETBOOTMACHINEFILEPATH;
    hr = _pads->Get( Str, &_vMachineFilepath );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    Str = NETBOOTINITIALIZATION;
    hr = _pads->Get( Str, &_vInitialization );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    //
    // Fix HR
    //
    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        hr = S_OK;
    }

Cleanup:

    ReleaseStgMedium( &stg );

    HRETURN(hr);
Error:
    switch (hr) {
    case S_OK:
        break;

    case S_FALSE:
        hr = E_FAIL; // don't show page
        break;

    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
        break;
    }
    goto Cleanup;
}

// ************************************************************************
//
// IShellPropSheetExt
//
// ************************************************************************

//
// AddPages()
//
STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
{
    TraceClsFunc( "[IShellPropSheetExt] AddPages( )\n" );

    if ( !lpfnAddPage )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    BOOL fServer;

    hr = THR( IsServer( &fServer ) );
    if (FAILED( hr ))
        goto Error;

    if ( fServer )
    {
        //
        // Add the "IntelliMirror" tab for servers
        //
        hr = THR( ::AddPagesEx( NULL,
                                CServerTab_CreateInstance,
                                lpfnAddPage,
                                lParam,
                                (LPUNKNOWN) (IShellExtInit*) this ) );
        if (FAILED( hr ))
            goto Error;
    }
    else
    {
        //
        // Add the "IntelliMirror" tab for clients
        //
        hr = THR( ::AddPagesEx( NULL,
                                CClientTab_CreateInstance,
                                lpfnAddPage,
                                lParam,
                                (LPUNKNOWN) (IShellExtInit*) this ) );
        if (FAILED( hr ))
            goto Error;
    }

    // Release our count on it.
    // _pDataObj->Release( );
    // _pDataObj = NULL;

Error:
    HRETURN(hr); 
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam )
{

    TraceClsFunc( "[IShellPropSheetExt] ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

// ************************************************************************
//
// IMAO (Private)
//
// ************************************************************************

//
// CommitChanges( )
//
STDMETHODIMP
THISCLASS::CommitChanges( void )
{
    TraceClsFunc("[IMAO] CommitChanges( )\n" );

    HRESULT hr = THR( _pads->SetInfo( ) );

    HRETURN(hr);
}

//
// IsAdmin( )
//
STDMETHODIMP
THISCLASS::IsAdmin(
    BOOL * fAdmin )
{
    TraceClsFunc( "[IMAO] IsAdmin( )\n" );

    if ( !fAdmin )
        HRETURN( E_POINTER );

    HRESULT hr = S_OK;

    *fAdmin = (_uMode == MODE_ADMIN);

    HRETURN(hr);
}

//
// IsServer( )
//
STDMETHODIMP
THISCLASS::IsServer(
    BOOL * fServer )
{
    TraceClsFunc( "[IMAO] IsServer( )\n" );

    if ( !fServer )
        HRETURN( E_POINTER );

    HRESULT hr = S_OK;

    *fServer = (_vSCP.vt != VT_EMPTY);

    HRETURN(hr);
}

//
// IsClient( )
//
STDMETHODIMP
THISCLASS::IsClient(
    BOOL * fClient )
{
    TraceClsFunc( "[IMAO] IsClient( )\n" );
    if ( !fClient)
        HRETURN( E_POINTER );

    HRESULT hr = S_OK;

    *fClient = (_vGUID.vt != VT_EMPTY ) |
               (_vMachineFilepath.vt != VT_EMPTY ) |
               (_vInitialization.vt != VT_EMPTY );

    HRETURN(hr);
}

//
// SetServerName( )
//
STDMETHODIMP
THISCLASS::SetServerName(
    LPWSTR pszName )
{
    TraceClsFunc( "[IMAO] SetServerName( " );
    TraceMsg( TF_FUNC, "pszName = %s )\n", pszName );

    HRESULT hr = S_OK;
    LPWSTR  pszFilepath = NULL;
    VARIANT var;
    _bstr_t Str;

    if ( V_VT( &_vMachineFilepath ) == VT_BSTR )
    {
        pszFilepath = StrChr( _vMachineFilepath.bstrVal, L'\\' );
    }

    //
    // Create variant with new Server\Filepath string
    //
    VariantInit( &var );
    if ( !pszName || pszName[0] == L'\0' ) {
        Str = NETBOOTMACHINEFILEPATH;
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, Str, var ) );
        DebugMsg( "Cleared MachineFilepath\n" );
    } else {
        if ( pszFilepath ) {
            WCHAR szBuf[ DNS_MAX_NAME_LENGTH + 1 + 128 /* DHCP BOOTP PATH */ + 1 ];
            
            if (_snwprintf( 
                    szBuf,
                    ARRAYSIZE(szBuf),
                    L"%s\\%s", 
                    pszName, 
                    pszFilepath) < 0) {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            PackStringToVariant( &var, szBuf);
            DebugMsg( "Set MachineFilepath to %s\n",  szBuf );
        } else {
            hr = PackStringToVariant( &var, pszName );
            if ( FAILED( hr ) )
                goto Cleanup;
            DebugMsg( "Set MachineFilepath to %s\n",  pszName );
        }

        //
        // Set the property
        //
        Str = NETBOOTMACHINEFILEPATH;
        hr = THR( _pads->Put( Str, var ) );
    }

    if (FAILED( hr ))
        goto Cleanup;
    //
    // Release the old variant and shallow copy the new one to the
    // MachineFilepath variant. No need to release the "var".
    //
    VariantClear( &_vMachineFilepath );
    _vMachineFilepath = var;
    goto exit;

Cleanup:
    VariantClear( &var );
exit:
    HRETURN(hr);
}


//
// GetServerName( )
//
STDMETHODIMP
THISCLASS::GetServerName(
    LPWSTR * ppszName )
{
    TraceClsFunc( "[IMAO] GetServerName( " );
    TraceMsg( TF_FUNC, "*ppszName = 0x%08x )\n", *ppszName );

    HRESULT hr = S_OK;
    LPWSTR psz = _vMachineFilepath.bstrVal;

    if ( !ppszName )
        HRETURN( E_POINTER );

    *ppszName = NULL;

    if ( _vMachineFilepath.vt != VT_BSTR || _vMachineFilepath.bstrVal == NULL )
        HRETURN( E_ADS_PROPERTY_NOT_FOUND );

    if ( *psz == L'\0' ) {
        hr = S_FALSE;
    } else {
        // Find the Filepath
        while ( *psz && *psz != L'\\' )
            psz++;

        *psz = L'\0';
        *ppszName = (LPWSTR) TraceStrDup( _vMachineFilepath.bstrVal );

        if ( !*ppszName )
            hr = E_OUTOFMEMORY;
    }

    HRETURN(hr);
}


//
// SetGUID( )
//
STDMETHODIMP
THISCLASS::SetGUID(
    LPWSTR pszGUID )
{
    TraceClsFunc("[IMAO] SetGUID( )\n" );

    HRESULT hr = E_FAIL;
    GUID Guid;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    if ( !pszGUID ) {

        Str = NETBOOTGUID;
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, Str, var ) );
        if (FAILED( hr ))
            goto Cleanup;

        VariantClear( &_vGUID );

    } else {

        if ( ValidateGuid(pszGUID,&Guid,NULL) == S_OK ) {

            //
            // Put it into a variant
            //
            PackBytesToVariant( &var, (LPBYTE)&Guid, 16 );

            VariantClear( &_vGUID );
            _vGUID = var;

            Str = NETBOOTGUID;
            hr = THR( _pads->Put( Str, _vGUID ) );
            if (FAILED( hr ))
                goto Cleanup;
        }
        else // I don't know what it is.
        {
            Assert( FALSE );
            VariantClear( &var );
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

Cleanup:
    HRETURN(hr);
}

//
// GetGUID( )
//
STDMETHODIMP
THISCLASS::GetGUID(
    IN LPWSTR * ppszGUID OPTIONAL,
    IN LPGUID pGUID OPTIONAL )
{
    TraceClsFunc("[IMAO] GetGUID( )\n" );

    HRESULT hr = S_OK;
    LPGUID  ptr = NULL;
    VARIANT var = _vGUID;
    LONG Length;

    if ( ppszGUID != NULL ) {
        *ppszGUID = NULL;
    }

    if ( var.vt == VT_EMPTY )
        HRETURN( HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    if ( SafeArrayGetDim( var.parray ) != 1 )
        HRETURN( HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    hr = THR( SafeArrayGetUBound( var.parray, 1, &Length ) );
    if (FAILED( hr ))
        goto Cleanup;

    Assert( Length == 15 );
    if ( Length != 15 )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto Cleanup;
    }

    hr = THR( SafeArrayAccessData( var.parray, (LPVOID*)&ptr ) );
    if (FAILED( hr ))
        goto Cleanup;

    if ( pGUID != NULL ) {
        memcpy( pGUID, ptr, sizeof(GUID) );
    }

    if ( ppszGUID != NULL ) {
        *ppszGUID = PrettyPrintGuid( ptr );
        if ( !*ppszGUID )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:
    if ( ptr )
        SafeArrayUnaccessData( var.parray );
    HRETURN(hr);
}

#if 0
//
// GetSAP( )
//
STDMETHODIMP
THISCLASS::GetSAP(
    LPVOID *punk )
{
    TraceClsFunc( "[IMAO] GetSAP( punk )\n" );

    HRESULT hr = S_OK;
    LPWSTR pszDN = NULL;

    *punk = NULL;

    if ( _vSCP.vt != VT_BSTR ) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        goto Cleanup;
    }

    Assert( _vSCP.vt == VT_BSTR );
    Assert( _vSCP.bstrVal );

    // pre-pend the "LDAP://server/" from our DN
    hr = FixObjectPath( _pszObjectName, V_BSTR( &_vSCP ), &pszDN );
    if (FAILED( hr ))
        goto Cleanup;

    // Bind to the MAO in the DS
    hr = THR( ADsGetObject( pszDN, IID_IADs, punk ) );
    if (FAILED( hr ))
        goto Cleanup;

Cleanup:
    if ( pszDN )
        TraceFree( pszDN );

    HRETURN(hr);
}
#endif

//
// GetDataObject( )
//
STDMETHODIMP
THISCLASS::GetDataObject( 
    LPDATAOBJECT * pDataObj 
    )
{
    TraceClsFunc( "GetDataObject( ... )\n ");

    if ( !pDataObj )
        HRETURN(E_POINTER);

    *pDataObj = _pDataObj;
    _pDataObj->AddRef( );

    HRETURN(S_OK);
}

//
//
//
STDMETHODIMP
THISCLASS::GetNotifyWindow(
    HWND *phNotifyObj 
    )
{
    TraceClsFunc( "GetNotifyWindow( ... )\n" );

    if ( !phNotifyObj )
        HRETURN(E_POINTER);

    *phNotifyObj = _hwndNotify;

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\client.cpp ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.CPP - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//

#include "pch.h"

#include "client.h"
#include "ccomputr.h"
#include "winsock2.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CClientTab")
#define THISCLASS CClientTab
#define LPTHISCLASS LPCClientTab

#define LDAPSTRINGNOWACKS   L"LDAP://"

DWORD aClientHelpMap[] = {
    IDC_E_GUID, HIDC_E_GUID,
    IDC_E_SERVERNAME, HIDC_E_SERVERNAME,
    IDC_B_BROWSE, HIDC_B_BROWSE,
    IDC_B_SERVER, HIDC_B_SERVER,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CClientTab_CreateInstance( void )
{
        TraceFunc( "CClientTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if (FAILED( hr ))
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _punkComputer(NULL),
    _fChanged(FALSE),
    _hNotify(NULL)
{
    TraceClsFunc( "CClientTab()\n" );

        InterlockIncrement( g_cObjects );

    Assert( !_punkComputer );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CClientTab()\n" );

    // Private Members
    if ( _punkComputer )
        _punkComputer->Release( );  // matching AddRef() in AddPages()

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore the error.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

        InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_CLIENT);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkComputer = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aClientHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aClientHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            HWND *phwnd = (HWND *) wParam;
            *phwnd = pcc->_hNotify;
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr;
    IMAO *  pmao;
    BOOL    fAdmin;
    HWND    hwndGuid;
    HWND    hwndServer;
    LPWSTR  pszServerName = NULL;
    LPWSTR  pszGUID = NULL;

    CWaitCursor Wait;

    _hDlg = hDlg;
    _fChanged = TRUE; // prevent turning on the Apply button early

    hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
    hwndServer = GetDlgItem( _hDlg, IDC_E_SERVERNAME );
    Edit_LimitText( hwndGuid, MAX_INPUT_GUID_STRING - 1 );
    Edit_LimitText( hwndServer, DNS_MAX_NAME_BUFFER_LENGTH - 1 );

    // retrieve values
    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    hr = THR( pmao->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pmao->IsAdmin( &fAdmin ) );
    EnableWindow( hwndGuid, fAdmin );
    EnableWindow( hwndServer, fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), fAdmin );

    hr = pmao->GetServerName( &pszServerName );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;
    Assert( SUCCEEDED(hr) || pszServerName == NULL );

    hr = THR( pmao->GetGUID( &pszGUID, NULL ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;
    Assert( SUCCEEDED(hr) || pszGUID == NULL );

    if ( pszGUID )
    {
        SetWindowText( hwndGuid, pszGUID );
    }
    else
    {
        SetWindowText( hwndGuid, L"" );
    }

    if ( pszServerName )
    {
        SetWindowText( hwndServer, pszServerName );
        EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVER ), fAdmin );
    }
    else
    {
        SetWindowText( hwndServer, L"" );
    }

    hr = S_OK;

Cleanup:
    if ( pmao )
        pmao->Release( );
    if ( pszGUID )
        TraceFree( pszGUID );
    if ( pszServerName )
        TraceFree( pszServerName );

    _fChanged = FALSE;

    HRETURN(hr);

Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}


//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr;
    BOOL    fAdmin;
    BOOL    fChanged = FALSE;
    IMAO *  pmao;
    HWND    hwnd = (HWND) lParam;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    switch( LOWORD(wParam) )
    {
    case IDC_E_SERVERNAME:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            LRESULT iLength = GetWindowTextLength( (HWND) lParam );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVER ), !!iLength );
            fChanged = TRUE;
        }
        break;

    case IDC_E_GUID:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            fChanged = TRUE;
        }
        break;

    case IDC_B_SERVER:
        if ( HIWORD( wParam ) == BN_CLICKED ) 
        {
            _JumpToServer( TRUE );
        }
        break;

    case IDC_B_BROWSE:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            hr = _OnSearch( _hDlg );
                        
        }
        break;
    }
    //
    // Update apply button as needed
    //
    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;   // indicates we need to save changes
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
        }
    }

Error:
    HRETURN(hr);
}

HRESULT
THISCLASS::_OnSearch(
    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED(hr)) {
        goto Error;
    }

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;
    
    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
                      (CLIPFORMAT)g_cfDsObjectNames,
                      NULL,
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
 
        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDNEx( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVERNAME, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

Error:
    
    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings( 
                        hDlg, 
                        IDS_PROBLEM_SEARCHING_TITLE, 
                        IDS_PROBLEM_SEARCHING_TEXT,
                        MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}



//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRESULT(S_OK); // nothing to do

    HRESULT hr    = S_OK;
    IMAO    *pmao = NULL;
    WCHAR   szGuid[ MAX_INPUT_GUID_STRING ];
    WCHAR   szServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    INT     iLength;
    HWND    hwndServer = GetDlgItem( _hDlg, IDC_E_SERVERNAME );
    HWND    hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
    HWND    eWnd;
    LPWSTR  pszGuid = NULL;

    CWaitCursor Wait;
    eWnd = hwndGuid;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    iLength = GetWindowText( hwndGuid, szGuid, ARRAYSIZE( szGuid ) );
    Assert( iLength <= ARRAYSIZE( szGuid ) );

    if ( iLength == 0 )
    {
        hr = THR( pmao->GetGUID( &pszGuid, NULL ) );
        if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
            goto Error;
        Assert( SUCCEEDED(hr) || pszGuid == NULL );

        if ( pszGuid != NULL )
        {
            LRESULT iResult = MessageBoxFromStrings( _hDlg, IDS_REMOVING_GUID_TITLE, IDS_REMOVING_GUID_TEXT, MB_YESNO );
            if ( iResult == IDYES )
            {
                hr = THR( pmao->SetGUID( NULL ) );
                if (FAILED( hr ))
                    goto Error;
            }
            else
            {   // reset the GUID
                SetWindowText( hwndGuid, pszGuid );
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }
    else
    {
        hr = ValidateGuid( szGuid, NULL, NULL );
        if ( hr != S_OK )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto InvalidGuid;
        }

        hr = THR( pmao->SetGUID( szGuid ) );
        if (FAILED( hr ))
            goto Error;
    }

    iLength = GetWindowText( hwndServer, szServerName, ARRAYSIZE( szServerName ) );
    Assert( iLength <= ARRAYSIZE( szServerName ) );
    if (iLength != 0) {
        hr = _JumpToServer( FALSE );
        if( FAILED(hr) ){
            // Well, server name invalid. Stop and return false.
            eWnd = hwndServer;
            goto Error;
        }

        hr = THR( pmao->SetServerName( szServerName ) );
        if (FAILED( hr ))
            goto Error;

    } else {    
        hr = THR( pmao->SetServerName( NULL ) );
        if (FAILED( hr ))
            goto Error;
    }            

    hr = THR( pmao->CommitChanges( ) );
    if (FAILED( hr ))
        goto Error;

    _fChanged = FALSE;  // reset
    hr = S_OK;

Cleanup:
    if ( pszGuid )
        TraceFree( pszGuid );
    if ( pmao )
        pmao->Release( );

    // Tell DSA that someone hit the Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    SetFocus( eWnd );
    if ( eWnd == hwndGuid ) {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    }
    goto Cleanup;
InvalidGuid:
    SetFocus( hwndGuid );
    MessageBoxFromStrings( NULL, IDS_INVALID_GUID_CAPTION, IDS_INVALID_GUID_TEXT, MB_OK );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;
            CWaitCursor *Wait;

            Wait = new CWaitCursor();

            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            if (Wait) {
                delete Wait;
                Wait = NULL;
            }

            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

HRESULT
THISCLASS::_JumpToServer( 
    BOOLEAN ShowProperties
    )
{
    HRESULT hr = E_FAIL;
    WCHAR             szServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    IDataObject *pido = NULL;
    ULONG ulSize = 0;
    CWaitCursor *Wait;
    const WCHAR       cszFilter[] = L"(&(objectCategory=computer)(servicePrincipalName=host/%s%s))";
    const WCHAR       samname[]   = L"samaccountname";    
    LPCWSTR           patterns[]  = {L""};    
    CHAR              mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    // Later to do pattern matching searches on the dnsHostName or Netbios name
    // expand the above arrays. See the for loop for details.
    ULONG             index;
    WCHAR             *pStart;
    WCHAR             *pEnd;
    LPWSTR            pszFilter   = NULL;
    IADsContainer     *pads       = NULL;
    IEnumVARIANT      *penum      = NULL;
    ADS_SEARCH_COLUMN adsColumn;  // this needs to be freed
    ADS_SEARCH_HANDLE adsHandle   = NULL;
    IDirectorySearch  *pds        = NULL;
    LPWSTR            ComputerAttrs[] = { DISTINGUISHEDNAME, NETBOOTSAP };
    BOOL              badsColumnValid = FALSE;
    ULONG             uFetched;
    VARIANT           varEnum;
    size_t            len;
    HOSTENT           *hent;
    
    TraceClsFunc("_JumpToServer( )\n");

    Wait = new CWaitCursor();
    
    if (!GetDlgItemText( _hDlg, IDC_E_SERVERNAME, szServerName, ARRAYSIZE(szServerName) )) {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr = _IsValidRISServer( szServerName );
    if ( FAILED( hr )) {
        goto Error;
    }    

    if (ShowProperties) {    
        VariantInit( &varEnum );

        //
        // get the full DN of the machine.
        //
        len =  wcstombs( mbszServerName, szServerName, ARRAYSIZE( mbszServerName ) );
        
        if ( !len ) {
            goto Error;
        }
        
        hent = gethostbyname( mbszServerName );
        if (!hent) {
            goto Error;
        }

        len = mbstowcs( szServerName, hent->h_name, strlen( hent->h_name ) );

        if ( !len ) {
            goto Error;
        }

        szServerName[len] = L'\0';

    
        // Build the filter
        pszFilter = (LPWSTR) TraceAllocString( LPTR, ARRAYSIZE(cszFilter) + wcslen(szServerName)
                                           + ARRAYSIZE(samname) + 2 ); // size of the longest         
        if ( !pszFilter ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    
        hr = THR( ADsOpenObject( L"LDAP:", NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pads ) );
        if (FAILED( hr ))
            goto Error;
    
        hr = THR( ADsBuildEnumerator( pads, &penum ) );
        if (FAILED( hr ))
            goto Error;
    
        hr = THR( ADsEnumerateNext( penum, 1, &varEnum, &uFetched ) );
        if (FAILED( hr ))
            goto Error;
        if ( hr == S_FALSE )
            goto Cleanup;   // hum...
        Assert( uFetched == 1 || varEnum.vt == VT_DISPATCH || varEnum.pdispVal != NULL );
    
        hr = THR( varEnum.pdispVal->QueryInterface( IID_IDirectorySearch, (void**)&pds) );
        if (FAILED( hr ))
            goto Error;    

        for ( index = 0; index < ARRAYSIZE(patterns); index ++ ) {

            wsprintf( pszFilter, cszFilter, szServerName,patterns[index] );
    
            DebugMsg( "Filter = '%s'\n", pszFilter );
    
            hr = THR( pds->ExecuteSearch( pszFilter, ComputerAttrs, ARRAYSIZE(ComputerAttrs), &adsHandle ) );
            if (FAILED( hr ))
                continue;        
    
                    do{
                        hr = THR( pds->GetNextRow( adsHandle ) );
                        if (FAILED( hr ) || ( hr == S_ADS_NOMORE_ROWS ) ) {
                            if ( adsHandle )
                                pds->CloseSearchHandle( adsHandle );
                            adsHandle = NULL;
                            break;
                        }
                        hr = THR( pds->GetColumn( adsHandle, ComputerAttrs[1], &adsColumn ) );
                        if (FAILED( hr )){
                            continue;
                        }
                        if ( pds ) {
                            hr = THR( pds->FreeColumn( &adsColumn ) );            
                        }
                        hr = THR( pds->GetColumn( adsHandle, ComputerAttrs[0], &adsColumn ) );
                        if (FAILED( hr )){
                            continue;
                        }
                        Assert( adsColumn.dwADsType == ADSTYPE_DN_STRING );
                        Assert( adsColumn.pADsValues->dwType == ADSTYPE_DN_STRING );
                        Assert( adsColumn.pADsValues->DNString );
                        badsColumnValid = TRUE;
                        break;
                    } while ( TRUE );
        if ( badsColumnValid ) {
            break;
        }

    }

    if (index == ARRAYSIZE( patterns ) ) {
        goto Error;
    }

    
        hr = THR( _punkComputer->QueryInterface( IID_IDataObject, (LPVOID *) &pido ) );
        if (FAILED( hr ))
            goto Error;

        if (Wait) {
            delete Wait;
            Wait = NULL;
        }
    
        hr = THR( PostADsPropSheet( adsColumn.pADsValues->DNString, pido, _hDlg, FALSE) );
        // PostADsPropSheet should put up its own errors
    }

    Cleanup:

        if (Wait) {
            delete Wait;
            Wait = NULL;
        }

        if ( pido )
            pido->Release( );
        if ( pszFilter )
            TraceFree( pszFilter );
        if ( pads )
            pads->Release( );
        if ( penum )
            ADsFreeEnumerator( penum );
        if ( pds && badsColumnValid ) {
            hr = THR( pds->FreeColumn( &adsColumn ) );
        }
        if ( pds && adsHandle ) {
            hr = THR( pds->CloseSearchHandle( adsHandle ) );
        }
        if ( pds )
            pds->Release();
        HRETURN(hr);

Error:

    if (Wait) {
        delete Wait;
        Wait = NULL;
    }

    if ( ShowProperties ){
        MessageBoxFromStrings( 
                    _hDlg, 
                    IDS_PROBLEM_FINDING_SERVER_TITLE, 
                    IDS_PROBLEM_FINDING_SERVER_TEXT, 
                    MB_OK | MB_ICONWARNING );
    } else {
        int retVal = MessageBoxFromStrings( 
                                    _hDlg, 
                                    IDS_PROBLEM_FINDING_SERVER_TITLE, 
                                    IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT, 
                                    MB_YESNO | MB_ICONWARNING);

        hr = (retVal == IDYES)?S_OK:E_ADS_BAD_PARAMETER;
    }
    goto Cleanup;
}

HRESULT
THISCLASS::_IsValidRISServer(
    IN LPCWSTR ServerName
    )
/*++

Routine Description:

    Validates if the specified server name points to a valid RIS server.

Arguments:

    ServerName - name of the server to validate

Return Value:

    HRESULT indicating outcome.
    (S_OK indicates that the server is a valid RIS server).

--*/
{
    HRESULT hr = E_FAIL;
    CHAR mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH +1];
    size_t len;
    PHOSTENT hent;
    WCHAR ServerShare[MAX_PATH];
    
    TraceClsFunc("_IsValidRISServer( )\n");

    Assert( wcslen(ServerName) <= DNS_MAX_NAME_BUFFER_LENGTH );
    
    //
    // Do a DNS Lookup of the server as a first check to ensure it's a 
    // valid name.
    //
    len =  wcstombs( mbszServerName, ServerName, ARRAYSIZE( mbszServerName ) );
    
    if ( !len ) {
        goto e0;        
    }
    
    hent = gethostbyname( mbszServerName );
    if (!hent) {
        goto e0;
    }

    //
    // OK, we know the server actually resolves to a computer name.  Let's search
    // for \\servername\reminst share.  If this succeeds, we assume the server
    // is a valid remote install server
    //

    if (_snwprintf( 
            ServerShare,
            ARRAYSIZE(ServerShare),
            L"\\\\%s\\reminst\\oschooser", 
            ServerName) < 0 ||    
        GetFileAttributes(ServerShare) == -1) {
        goto e0;
    }

    hr = S_OK;

e0:
    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cservice.h ===
//
// Copyright 1997 - Microsoft
//

//
// CComputr.H - Computer properties class
//

#ifndef _CSERVICE_H_
#define _CSERVICE_H_

#include <adsprop.h>

// QITable
BEGIN_QITABLE( CService )
DEFINE_QI( IID_IShellExtInit,      IShellExtInit     , 1  )
DEFINE_QI( IID_IShellPropSheetExt, IShellPropSheetExt, 2  )
DEFINE_QI( IID_IIntelliMirrorSAP,  IIntelliMirrorSAP , 30 )
END_QITABLE

// Definitions
LPVOID
CService_CreateInstance( void );

// Private IIntelliMirrorSAP Interface Definition
interface
IIntelliMirrorSAP:
    public IUnknown
{
public:
    STDMETHOD(CommitChanges)( void ) PURE;                      // 1
    STDMETHOD(IsAdmin)( BOOL * pbool ) PURE;                    // 2

    STDMETHOD(GetAllowNewClients)( BOOL *pbool ) PURE;          // 3
    STDMETHOD(SetAllowNewClients)( BOOL pbool ) PURE;           // 4

    STDMETHOD(GetLimitClients)( BOOL *pbool ) PURE;             // 5
    STDMETHOD(SetLimitClients)( BOOL pbool ) PURE;              // 6

    STDMETHOD(GetMaxClients)( UINT *pint ) PURE;                // 7
    STDMETHOD(SetMaxClients)( UINT pint ) PURE;                 // 8

    STDMETHOD(GetCurrentClientCount)( UINT *pint ) PURE;        // 9
    STDMETHOD(SetCurrentClientCount)( UINT pint ) PURE;         // 10

    STDMETHOD(GetAnswerRequests)( BOOL *pbool ) PURE;           // 11
    STDMETHOD(SetAnswerRequests)( BOOL pbool ) PURE;            // 12

    STDMETHOD(GetAnswerOnlyValidClients)( BOOL *pbool ) PURE;   // 13
    STDMETHOD(SetAnswerOnlyValidClients)( BOOL pbool ) PURE;    // 14

    STDMETHOD(GetNewMachineNamingPolicy)( LPWSTR *pwsz ) PURE;  // 15
    STDMETHOD(SetNewMachineNamingPolicy)( LPWSTR pwsz ) PURE;   // 16

    STDMETHOD(GetNewMachineOU)( LPWSTR *pwsz ) PURE;            // 17
    STDMETHOD(SetNewMachineOU)( LPWSTR pwsz ) PURE;             // 18

    STDMETHOD(EnumIntelliMirrorOSes)( DWORD dwFlags, LPUNKNOWN *punk ) PURE;             // 19
    //STDMETHOD(GetDefaultIntelliMirrorOS)( LPWSTR * pszName, LPWSTR * pszTimeout ) PURE;  // 20
    //STDMETHOD(SetDefaultIntelliMirrorOS)( LPWSTR pszName, LPWSTR pszTimeout ) PURE;      // 21

    STDMETHOD(EnumTools)( DWORD dwFlags, LPUNKNOWN *punk ) PURE;            // 22
    
    STDMETHOD(GetServerDN)( LPWSTR *pwsz ) PURE;              // 23
    STDMETHOD(SetServerDN)( LPWSTR pwsz ) PURE;               // 24

    STDMETHOD(GetSCPDN)( LPWSTR * pwsz ) PURE;                  // 25
    //STDMETHOD(GetGroupDN)( LPWSTR * pwsz ) PURE;                // 26

    STDMETHOD(GetServerName)( LPWSTR *pwsz ) PURE;              // 27

    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj ) PURE;   // 28
    STDMETHOD(GetNotifyWindow)( HWND * phNotifyObj ) PURE;      // 29
};

typedef IIntelliMirrorSAP *LPINTELLIMIRRORSAP;

// CService
class 
CService:
    public IShellExtInit, IShellPropSheetExt, IIntelliMirrorSAP
{
private:
    // Enums
    enum { 
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    UINT  _uMode;               // Admin or Shell mode
    LPWSTR _pszSCPDN;           // LDAP path to SCP
    //LPWSTR _pszGroupDN;         // LDAP path to group. If NULL, not in a group.
    LPWSTR _pszMachineName;     // Machine Name
    LPWSTR _pszDSServerName;    // Save this so we use the same as DSADMIN

    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CService );

    LPDATAOBJECT      _pDataObj;    // DSA's data object
    HWND              _hwndNotify;  // DSA notify window
    ADSPROPINITPARAMS _InitParams;  // DSA init params

    IADs *   _pads;             // ADs to MAO    

private: // Methods
    CService();
    ~CService();
    STDMETHOD(Init)();

    //HRESULT _GetDefaultSIF( LPWSTR pszAttribute, LPWSTR * pszName, LPWSTR * pszTimeout );
    //HRESULT _SetDefaultSIF( LPWSTR pszAttribute, LPWSTR pszName, LPWSTR pszTimeout );
    HRESULT _GetComputerNameFromADs( );

public: // Methods
    friend LPVOID CService_CreateInstance( void );
    STDMETHOD(Init2)( IADs * pads );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IShellExtInit
    STDMETHOD(Initialize)( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                            LPARAM lParam);

    // IIntelliMirrorSAP
    STDMETHOD(CommitChanges)( void );
    STDMETHOD(IsAdmin)( BOOL * pbool );

    STDMETHOD(GetAllowNewClients)( BOOL *pbool );
    STDMETHOD(SetAllowNewClients)( BOOL pbool );

    STDMETHOD(GetLimitClients)( BOOL *pbool );
    STDMETHOD(SetLimitClients)( BOOL pbool );

    STDMETHOD(GetMaxClients)( UINT *pint );
    STDMETHOD(SetMaxClients)( UINT pint );

    STDMETHOD(GetCurrentClientCount)( UINT *pint );
    STDMETHOD(SetCurrentClientCount)( UINT pint );

    STDMETHOD(GetAnswerRequests)( BOOL *pbool );
    STDMETHOD(SetAnswerRequests)( BOOL pbool );

    STDMETHOD(GetAnswerOnlyValidClients)( BOOL *pbool );
    STDMETHOD(SetAnswerOnlyValidClients)( BOOL pbool );

    STDMETHOD(GetNewMachineNamingPolicy)( LPWSTR *pwsz );
    STDMETHOD(SetNewMachineNamingPolicy)( LPWSTR pwsz );

    STDMETHOD(GetNewMachineOU)( LPWSTR *pwsz );
    STDMETHOD(SetNewMachineOU)( LPWSTR pwsz );

    STDMETHOD(EnumIntelliMirrorOSes)( DWORD dwFlags, LPUNKNOWN *punk );
    //STDMETHOD(GetDefaultIntelliMirrorOS)( LPWSTR * pszName, LPWSTR * pszTimeout );
    //STDMETHOD(SetDefaultIntelliMirrorOS)( LPWSTR pszName, LPWSTR pszTimeout );

    STDMETHOD(EnumTools)( DWORD dwFlags, LPUNKNOWN *punk );
    
    STDMETHOD(GetServerDN)( LPWSTR *pwsz );
    STDMETHOD(SetServerDN)( LPWSTR pwsz );

    STDMETHOD(GetSCPDN)( LPWSTR * pwsz );
    //STDMETHOD(GetGroupDN)( LPWSTR * pwsz );

    STDMETHOD(GetServerName)( LPWSTR * pwsz );

    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj );
    STDMETHOD(GetNotifyWindow)( HWND * phNotifyObj );
};

typedef CService* LPSERVICE;

#endif // _CSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dataobj.h ===
//
// Copyright 1997 - Microsoft
//

//
// DATAOBJ.H - A data object
//

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

// QITable
BEGIN_QITABLE( CDsPropDataObj )
DEFINE_QI( IID_IDataObject,      IDataObject      , 9 )
END_QITABLE

LPVOID 
CDsPropDataObj_CreateInstance( 
    HWND hwndParent,
    IDataObject * pido,
    GUID * pClassGUID,
    BOOL fReadOnly,
    LPWSTR pszObjPath,
    LPWSTR bstrClass );


class CDsPropDataObj : public IDataObject
{
private:
    DECLARE_QITABLE( CDsPropDataObj );

    CDsPropDataObj::CDsPropDataObj( HWND hwndParent, IDataObject * pido, GUID * pClassGUID, BOOL fReadOnly);
    ~CDsPropDataObj(void);

    HRESULT Init(LPWSTR pwszObjName, LPWSTR pwszClass);

public:
    friend LPVOID CDsPropDataObj_CreateInstance( 
        HWND hwndParent, 
        IDataObject * pido, 
        GUID * pClassGUID, 
        BOOL fReadOnly,
        LPWSTR pszObjPath,
        LPWSTR bstrClass );

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // Standard IDataObject methods
    //
    // Implemented
    //
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

    STDMETHOD(GetDataHere)(FORMATETC * pFormatEtcIn, STGMEDIUM * pMedium);

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection,
                             IEnumFORMATETC ** ppenumFormatEtc);

    // Not Implemented
private:
    STDMETHOD(QueryGetData)(FORMATETC * pformatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC * pformatectIn,
                                     FORMATETC * pformatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium,
                       BOOL fRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(FORMATETC * pformatetc, DWORD advf,
                       IAdviseSink * pAdvSink, DWORD * pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** ppenumAdvise)
    { return E_NOTIMPL; };

    BOOL                m_fReadOnly;
    PWSTR               m_pwszObjName;
    PWSTR               m_pwszObjClass;
    GUID                m_ClassGUID;
    IDataObject       * m_pPage;
    unsigned long       _cRef;
    HWND                m_hwnd;
};

typedef CDsPropDataObj * LPCDSPROPDATAOBJ;

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\cservice.cpp ===
//
// Copyright 1997 - Microsoft

//
// CCOMPUTR.CPP - Handles the computer object property pages.
//

#include "pch.h"

#include "imos.h"
#include "newclnts.h"
#include "tools.h"
#include "varconv.h"

#include "cservice.h"
#include "cenumsif.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CService")
#define THISCLASS CService
#define LPTHISCLASS LPSERVICE


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CService_CreateInstance( void )
{
    TraceFunc( "CService_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID)lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
_uMode(MODE_SHELL),
_pszSCPDN(NULL),
//_pszGroupDN(NULL),
_pszMachineName(NULL),
_pszDSServerName(NULL),
_cRef(0),
_pDataObj(NULL),
_hwndNotify(NULL),
_pads(NULL)
{
    TraceClsFunc( "CService()\n" );

    InterlockIncrement( g_cObjects );

    ZeroMemory( &_InitParams, sizeof(_InitParams));
    _InitParams.dwSize = sizeof(_InitParams);

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CService, IShellExtInit );
    QITABLE_IMP( IShellExtInit );
    QITABLE_IMP( IShellPropSheetExt );
    QITABLE_IMP( IIntelliMirrorSAP );
    END_QITABLE_IMP( CService );

    Assert( _cRef == 0);
    Assert( !_pads );
    Assert( !_pszSCPDN );
    //Assert( !_pszGroupDN );
    Assert( !_pszMachineName );
    AddRef( );

    HRESULT hr = S_OK;

    hr = CheckClipboardFormats( );

    HRETURN(hr);
}

STDMETHODIMP
THISCLASS::Init2( IADs * pads )
{
    TraceClsFunc( "Init2( " );
    TraceMsg( TF_FUNC, "pads = 0x%08x )\n", pads );

    HRESULT hr;

    if ( !pads )
        HRETURN(E_INVALIDARG);

    _pads = pads;
    _pads->AddRef( );

    hr = _GetComputerNameFromADs( );
    if (FAILED( hr ))
        goto Error;

    Error:
    HRETURN(hr);
}


//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CService()\n" );

    // Private Members
    if ( _pads ) {
        //
        // note: we shouldn't commit anything in the destructor -- we can't 
        // catch failures here.  We'll just have to make sure that we 
        // explicitly commit changes when necessary
        //
#if 0
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
#endif
        _pads->Release( );
    }

    if ( _pszSCPDN )
        TraceFree( _pszSCPDN );

    //if ( _pszGroupDN )
    //    TraceFree( _pszGroupDN );

    if ( _pszMachineName )
        TraceFree( _pszMachineName );

    if ( _pszDSServerName )
        TraceFree( _pszDSServerName );

    if ( _pDataObj )
        _pDataObj->Release( );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
                         REFIID riid,
                         LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IShellExtInit
//
// ************************************************************************

//
// Initialize()
//
HRESULT
THISCLASS::Initialize(
                     LPCITEMIDLIST pidlFolder,
                     LPDATAOBJECT lpdobj, HKEY hkeyProgID)
{
    TraceClsFunc( "[IShellExtInit] Initialize( " );
    TraceMsg( TF_FUNC, " pidlFolder = 0x%08x, lpdobj = 0x%08x, hkeyProgID = 0x%08x )\n",
              pidlFolder, lpdobj, hkeyProgID );

    if ( !lpdobj )
        RETURN(E_INVALIDARG);

    HRESULT    hr = S_OK;
    FORMATETC  fmte;
    STGMEDIUM  stg = { 0};
    STGMEDIUM  stgOptions = { 0};

    LPWSTR     pszObjectName;
    LPWSTR     pszClassName;
    LPWSTR     pszAttribPrefix;

    LPDSOBJECT             pDsObject;
    LPDSOBJECTNAMES        pDsObjectNames;
    LPDSDISPLAYSPECOPTIONS pDsDisplayOptions;

    _bstr_t  Str;

    BOOL b;

    _pDataObj = lpdobj;
    _pDataObj->AddRef( );

    //
    // Retrieve the Object Names
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsObjectNames;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( _pDataObj->GetData( &fmte, &stg) );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    pDsObjectNames = (LPDSOBJECTNAMES) stg.hGlobal;

    Assert( stg.tymed == TYMED_HGLOBAL );

    TraceMsg( TF_ALWAYS, "Object's Namespace CLSID: " );
    TraceMsgGUID( TF_ALWAYS, pDsObjectNames->clsidNamespace );
    TraceMsg( TF_ALWAYS, "\tNumber of Objects: %u \n", pDsObjectNames->cItems );

    Assert( pDsObjectNames->cItems == 1 );

    pDsObject = (LPDSOBJECT) pDsObjectNames->aObjects;

    pszObjectName = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetName );
    pszClassName  = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetClass );

    TraceMsg( TF_ALWAYS, "Object Name (Class): %s (%s)\n", pszObjectName, pszClassName );

    _pszDSServerName = TraceStrDup( pszObjectName );
    if (!_pszDSServerName) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    //
    // If they handed us a "Computer" object, look at the NETBOOTSAP
    // attribute to get the IMSAP object.
    //
    if ( StrCmp( pszClassName, DSCOMPUTERCLASSNAME ) == 0 ) {
        IADs*   pads = NULL;
        VARIANT var;

        VariantInit( &var );

        Assert( !_pszMachineName );
        //
        // Bind to the MAO in the DS
        //
        hr = THR( ADsGetObject( pszObjectName, IID_IADs, (void **)&pads ) );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        Str = NETBOOTSAP;
        hr = THR( pads->Get( Str, &var ) );
        if (FAILED( hr ) ||
            V_VT( &var ) != VT_BSTR ) {
            goto Computer_Cleanup;
        }

        Assert( V_VT( &var ) == VT_BSTR );

        // Try to parse the string to connect to the same server as the DSADMIN
        hr = FixObjectPath( _pszDSServerName, V_BSTR( &var ), &_pszSCPDN );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        DebugMsg( "SCP Path: %s\n", _pszSCPDN );
        VariantClear( &var );

        // while we are here, might as well get the server's NETBIOS name
        Str = SAMNAME;
        hr = THR( pads->Get( Str, &var ) );
        if (FAILED( hr ) ||
            V_VT( &var) != VT_BSTR) {
            goto Computer_Cleanup;
        }

        Assert( V_VT( &var) == VT_BSTR );
        _pszMachineName = TraceStrDup( V_BSTR( &var ) );
        if ( _pszMachineName ) {
            LPWSTR psz = &_pszMachineName[ wcslen( _pszMachineName ) - 1 ];
            if ( *psz == L'$' ) {
                *psz = L'\0';
            }
            DebugMsg( "Server Name: %ws\n", _pszMachineName );
        } else {
            hr = E_OUTOFMEMORY;
        }

Computer_Cleanup:   
        VariantClear( &var );

        if ( pads )
            pads->Release( );

        if (FAILED( hr ))
            goto Error;

        // create the DS notify object
        hr = THR( ADsPropCreateNotifyObj( _pDataObj, pszObjectName, &_hwndNotify ) );
        if (FAILED( hr ))
            goto Error;

        b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
        if ( !b ) {
            hr = E_FAIL;
            goto Error;
        }

        hr = THR( _InitParams.hr );
        if (FAILED( hr ))
            goto Error;

        // Bind to the IMSAP in the DS
        Assert( _pszSCPDN );
        hr = THR( ADsGetObject( _pszSCPDN, IID_IADs, (void **)&_pads ) );
        if (FAILED( hr ))
            goto Error;
    } else if ( StrCmp( pszClassName, DSIMSAPCLASSNAME ) ) {
        //
        // This should be a IMSAP.
        //
        hr = E_INVALIDARG;
        goto Error;
    } else {
        // Keep the DN around
        _pszSCPDN = TraceStrDup( pszObjectName );
        if (!_pszSCPDN) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // create the DS notify object
        hr = THR( ADsPropCreateNotifyObj( _pDataObj, pszObjectName, &_hwndNotify ) );
        if (FAILED( hr ))
            goto Error;

        b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
        if ( !b ) {
            hr = E_FAIL;
            goto Error;
        }

        hr = THR( _InitParams.hr );
        if (FAILED( hr ))
            goto Error;

        // Bind to the IMSAP in the DS
        Assert( _pszSCPDN );
        hr = THR( _InitParams.pDsObj->QueryInterface( IID_IADs, (void **)&_pads ) );
        if (FAILED( hr ))
            goto Error;
    }

    Assert( _pads );
    //
    // Retrieve the Display Spec Options
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsDisplaySpecOptions;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( _pDataObj->GetData( &fmte, &stgOptions ) );
    if ( FAILED(hr) ) {
        goto Error;
    }

    pDsDisplayOptions = (LPDSDISPLAYSPECOPTIONS) stgOptions.hGlobal;

    Assert( stgOptions.tymed == TYMED_HGLOBAL );
    Assert( pDsDisplayOptions->dwSize == sizeof(DSDISPLAYSPECOPTIONS) );

    pszAttribPrefix = (LPWSTR) PtrToByteOffset( pDsDisplayOptions, pDsDisplayOptions->offsetAttribPrefix );

    // TraceMsg( TF_ALWAYS, TEXT("Attribute Prefix: %s\n"), pszAttribPrefix );

    if ( StrCmpW( pszAttribPrefix, STRING_ADMIN ) == 0 ) {
        _uMode = MODE_ADMIN;
    }
    // else default from Init()

    TraceMsg( TF_ALWAYS, TEXT("Mode: %s\n"), _uMode == MODE_ADMIN ? TEXT("Admin") : TEXT("Shell") );

    ReleaseStgMedium( &stgOptions );

Cleanup:
    HRETURN(hr);

    Error:
    MessageBoxFromHResult( NULL, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}


// ************************************************************************
//
// IShellPropSheetExt
//
// ************************************************************************

//
// AddPages()
//
HRESULT
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage,
                   LPARAM lParam)
{
    TraceClsFunc( "[IShellPropSheetExt] AddPages( )\n" );

    if ( !lpfnAddPage )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    hr = THR( ::AddPagesEx( NULL,
                            CNewClientsTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( ::AddPagesEx( NULL,
                            CIntelliMirrorOSTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( ::AddPagesEx( NULL,
                            CToolsTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

    Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
HRESULT
THISCLASS::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                      LPARAM lParam )
{

    TraceClsFunc( "[IShellPropSheetExt] ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

// ************************************************************************
//
// IIntelliMirrorSAP
//
// ************************************************************************

//
// CommitChanges( )
//
HRESULT
THISCLASS::CommitChanges( void )
{
    TraceClsFunc( "[IIntelliMirrorSAP] CommitChanges( )\n" );

    Assert( _pads );

    HRESULT        hr;
    SC_HANDLE      schManager = NULL;
    SC_HANDLE      sch = NULL;
    SERVICE_STATUS ss;

    hr = THR( _pads->SetInfo( ) );
    if ( FAILED( hr ) )
        goto Error;

    // if we don't have this yet, get it now.
    if ( !_pszMachineName ) {
        hr = _GetComputerNameFromADs( );
        if (FAILED( hr ))
            goto Error;
    }

    schManager = OpenSCManager( _pszMachineName, NULL, SC_MANAGER_CONNECT );
    if (!schManager) {
        DWORD dwErr = GetLastError( );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    sch = OpenService( schManager, BINL_SERVER_NAME, SERVICE_USER_DEFINED_CONTROL);
    if (!sch) {
        DWORD dwErr = GetLastError( );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    if ( !ControlService( sch, BINL_SERVICE_REREAD_SETTINGS, &ss ) ) {
        DWORD dwErr = GetLastError( );
        hr = THR(HRESULT_FROM_WIN32( dwErr ));
        goto Error;
    }

    hr = HRESULT_FROM_WIN32( ss.dwWin32ExitCode );

    Error:
    if ( sch )
        CloseServiceHandle( sch );
    if ( schManager )
        CloseServiceHandle( schManager );

    if ( hr == HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE ) ) {
        hr = S_OK;  // ignore error... by design
    }

    HRETURN(hr);
}


//
// IsAdmin( )
//
HRESULT
THISCLASS::IsAdmin(
                  BOOL * fAdmin )
{
    TraceClsFunc( "[IIntelliMirrorSAP] IsAdmin( )\n" );

    if ( !fAdmin )
        RRETURN( E_POINTER );

    HRESULT hr = S_OK;

    *fAdmin = (_uMode == MODE_ADMIN);

    HRETURN(hr);
}

//
// GetAllowNewClients( )
//
HRESULT
THISCLASS::GetAllowNewClients(
                             BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAllowNewClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTALLOWNEWCLIENTS;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL ) {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}

//
// SetAllowNewClients( )
//
HRESULT
THISCLASS::SetAllowNewClients(
                             BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAllowNewClients( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    Str = NETBOOTALLOWNEWCLIENTS;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetLimitClients( )
//
HRESULT
THISCLASS::GetLimitClients(
                          BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetLimitClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTLIMITCLIENTS;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL ) {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetLimitClients( )
//
HRESULT
THISCLASS::SetLimitClients(
                          BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetLimitClients( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    Str = NETBOOTLIMITCLIENTS;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetMaxClients( )
//
HRESULT
THISCLASS::GetMaxClients(
                        UINT *puMax )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetMaxClients( ... )\n" );

    if ( !puMax )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTMAXCLIENTS;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_I4 ) {
        *puMax = V_I4(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetMaxClients( )
//
HRESULT
THISCLASS::SetMaxClients(
                        UINT uMax )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetMaxClients( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_I4;
    V_I4( &var ) = uMax;

    Assert( _pads );

    Str = NETBOOTMAXCLIENTS;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetCurrentClientCount( )
//
HRESULT
THISCLASS::GetCurrentClientCount(
                                UINT *puCount )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetCurrentClientCount( ... )\n" );

    if ( !puCount )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTCURRENTCLIENTCOUNT;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_I4 ) {
        *puCount = V_I4(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetCurrentClientCount( )
//
HRESULT
THISCLASS::SetCurrentClientCount(
                                UINT uCount )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetCurrentClientCount( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_I4;
    V_I4( &var ) = uCount;

    Assert( _pads );

    Str = NETBOOTCURRENTCLIENTCOUNT;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetAnswerRequests( )
//
HRESULT
THISCLASS::GetAnswerRequests(
                            BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAnswerRequests( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTANSWERREQUESTS;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL ) {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetAnswerRequests( )
//
HRESULT
THISCLASS::SetAnswerRequests(
                            BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAnswerRequests( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    Str = NETBOOTANSWERREQUESTS;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetAnswerOnlyValidClients( )
//
HRESULT
THISCLASS::GetAnswerOnlyValidClients(
                                    BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAnswerOnlyValidClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTANSWERONLYVALIDCLIENTS;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL ) {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetAnswerOnlyValidClients( )
//
HRESULT
THISCLASS::SetAnswerOnlyValidClients(
                                    BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAnswerOnlyValidClients( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    Str = NETBOOTANSWERONLYVALIDCLIENTS;
    hr = THR( _pads->Put( Str , var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetNewMachineNamingPolicy( )
//
HRESULT
THISCLASS::GetNewMachineNamingPolicy(
                                    LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetNewMachineNamingPolicy( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTNEWMACHINENAMINGPOLICY;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR ) {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if (!*pwsz) {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetNewMachineNamingPolicy( )
//
HRESULT
THISCLASS::SetNewMachineNamingPolicy(
                                    LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetNewMachineNamingPolicy( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;
    Assert( _pads );

    if ( pwsz ) {
        V_VT( &var ) = VT_BSTR;
        V_BSTR( &var ) = SysAllocString( pwsz );

        if (V_BSTR(&var) == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }

        Str = NETBOOTNEWMACHINENAMINGPOLICY;
        hr = THR( _pads->Put( Str, var ) );
        VariantClear( &var );
    } else {
        VariantInit( &var );
        Str = NETBOOTNEWMACHINENAMINGPOLICY;
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, Str, var ) );
    }

    HRETURN(hr);
}


//
// GetNewMachineOU( )
//
HRESULT
THISCLASS::GetNewMachineOU(
                          LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetNewMachineOU( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTNEWMACHINEOU;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR ) {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if (!*pwsz) {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetNewMachineOU( )
//
HRESULT
THISCLASS::SetNewMachineOU(
                          LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetNewMachineOU( ... )\n" );

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    Assert( _pads );

    if ( pwsz ) {
        V_VT( &var ) = VT_BSTR;
        V_BSTR( &var ) = SysAllocString( pwsz );

        if (V_BSTR(&var) == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }

        Str = NETBOOTNEWMACHINEOU;
        hr = THR( _pads->Put( Str, var ) );
        VariantClear( &var );
    } else {
        VariantInit( &var );
        Str = NETBOOTNEWMACHINEOU;
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, Str, var ) );
    }

    HRETURN(hr);
}

//
// EnumIntelliMirrorOSes( )
//
HRESULT
THISCLASS::EnumIntelliMirrorOSes(
                                DWORD dwFlags,
                                LPUNKNOWN *punk )
{
    TraceClsFunc("[IIntelliMirrorSAP] EnumIntelliMirrorOSes( ... )\n" );

    if ( !punk )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    Assert( _pads );

    *punk = (LPUNKNOWN)
            CEnumIMSIFs_CreateInstance( REMOTE_INSTALL_IMAGE_DIR_W, NETBOOTINTELLIMIRROROSES, dwFlags, _pads );

    if ( !*punk ) {
        hr = E_FAIL;
    }

    HRETURN(hr);
}


//
// EnumTools( )
//
HRESULT
THISCLASS::EnumTools(
                    DWORD dwFlags,
                    LPUNKNOWN *punk )
{
    TraceClsFunc("[IIntelliMirrorSAP] EnumTools( ... )\n" );

    if ( !punk )
        RETURN(E_POINTER);

    HRESULT hr = S_OK;

    Assert( _pads );

    *punk = (LPUNKNOWN)
            CEnumIMSIFs_CreateInstance( REMOTE_INSTALL_TOOLS_DIR_W, NETBOOTTOOLS, dwFlags, _pads );

    if ( !*punk ) {
        hr = E_FAIL;
    }

    HRETURN(hr);
}


//
// GetServerDN( )
//
HRESULT
THISCLASS::GetServerDN(
                      LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetServerDN( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    VariantInit( &var );

    Assert( _pads );

    Str = NETBOOTSERVER;
    hr = _pads->Get( Str, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR ) {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if ( !*pwsz ) {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetServerDN( )
//
HRESULT
THISCLASS::SetServerDN(
                      LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetServerDN( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;
    _bstr_t Str;

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwsz );

    if (V_BSTR(&var) == NULL) {
        RRETURN(E_OUTOFMEMORY);
    }

    Assert( _pads );

    Str = NETBOOTSERVER;
    hr = THR( _pads->Put( Str, var ) );

    VariantClear( &var );

    HRETURN(hr);
}

#if 0
//
// GetDefaultIntelliMirrorOS( )
//
HRESULT
THISCLASS::GetDefaultIntelliMirrorOS(
                                    LPWSTR * pszName,
                                    LPWSTR * pszTimeout )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetDefaultIntelliMirrorOS( ...)\n" );

    HRESULT hr;

    hr = _GetDefaultSIF( NETBOOTINTELLIMIRROROSES, pszName, pszTimeout );

    HRETURN(hr);
}

//
// SetDefaultIntelliMirrorOS( )
//
HRESULT
THISCLASS::SetDefaultIntelliMirrorOS(
                                    LPWSTR pszName,
                                    LPWSTR pszTimeout )
{
    TraceClsFunc( "[IIntelliMirrorSAP] SetDefaultIntelliMirrorOS( " );
    TraceMsg( TF_FUNC, "pszName = '%s', pszTimeout = '%s' )\n",
              pszName, pszTimeout );

    HRESULT hr;

    hr = _SetDefaultSIF( NETBOOTINTELLIMIRROROSES, pszName, pszTimeout );

    HRETURN(hr);
}

//
// _GetDefaultSIF( )
//
HRESULT
THISCLASS::_GetDefaultSIF(
                         LPWSTR pszAttribute,
                         LPWSTR * pszName,
                         LPWSTR * pszTimeout )
{
    TraceClsFunc( "_GetDefaultSIF( " );
    TraceMsg( TF_FUNC, "pszAttribute = '%s', ... )\n" , pszAttribute );

    if ( !pszAttribute )
        RRETURN(E_POINTER);

    if ( !pszName )
        RRETURN(E_POINTER);

    if ( !pszTimeout )
        RRETURN(E_POINTER);

    HRESULT   hr;
    LONG      lUBound;
    VARIANT   var;
    VARIANT * pvar;
    _bstr_t Str;

    VariantInit( &var );
    *pszName = NULL;
    *pszTimeout = NULL;

    Assert( _pads );

    Str = pszAttribute;
    hr = THR( _pads->GetEx( Str, &var ) );
    if (FAILED( hr )) {
        goto Error;
    }

    //
    // Make sure that the var is an array of VARIANTs
    //
    if ( V_VT( &var ) != ( VT_ARRAY | VT_VARIANT ) ) {
        hr = ERROR_INVALID_DATA;
        goto Error;
    }

    Assert( SafeArrayGetDim( V_ARRAY( &var ) ) == 1 );
#ifdef DEBUG
    {
        LONG lLBound;
        SafeArrayGetLBound( V_ARRAY( &var ), 1, &lLBound );
        Assert( lLBound == 0 );
    }
#endif // DEBUG

    SafeArrayGetUBound( V_ARRAY( &var ), 1, &lUBound );

    //
    // Copy the required data
    //
    SafeArrayAccessData( V_ARRAY( &var ), (void **)&pvar );
    *pszName    = (LPWSTR) TraceStrDup( V_BSTR( &pvar[ 0 ] ) );
    if (!*pszName) {
        SafeArrayUnaccessData( V_ARRAY( &var ) );
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if ( lUBound == 2 ) {
        *pszTimeout = (LPWSTR) TraceStrDup( V_BSTR( &pvar[ 1 ] ) );
        if ( !*pszTimeout ) {
            SafeArrayUnaccessData( V_ARRAY( &var ) );
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

    SafeArrayUnaccessData( V_ARRAY( &var ) );

    Error:
    VariantClear( &var );

    HRETURN(hr);
}

//
// _SetDefaultSIF( )
//
HRESULT
THISCLASS::_SetDefaultSIF(
                         LPWSTR pszAttribute,
                         LPWSTR pszName,
                         LPWSTR pszTimeout )
{
    TraceClsFunc( "_SetDefaultSIF( " );
    TraceMsg( TF_FUNC, "pszAttribute = '%s', ... )\n" , pszAttribute );

    if ( !pszAttribute )
        RRETURN(E_POINTER);

    if ( !pszName )
        RRETURN(E_POINTER);

    if ( !pszTimeout )
        RRETURN(E_POINTER);

    HRESULT   hr;
    LONG      lUBound;
    VARIANT   var;
    LPWSTR    pszStrings[ 2 ];
    _bstr_t Str;

    pszStrings[0] = pszName;
    pszStrings[1] = pszTimeout;

    VariantInit( &var );

    hr = THR( StringArrayToVariant( &var, pszStrings, 2 ) );
    if (FAILED( hr ))
        goto Error;

    Assert( _pads );
    Str = pszAttribute;
    hr = THR( _pads->Put( Str, var ) );
    if (FAILED( hr ))
        goto Error;

    Error:
    VariantClear( &var );

    HRETURN(hr);
}
#endif

//
// GetSCPDN( )
//
HRESULT
THISCLASS::GetSCPDN(
                   LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetSCPDN( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN( E_POINTER );

    if ( _pszSCPDN ) {
        LPWSTR psz = StrRChr( _pszSCPDN, NULL, L'/' );
        if ( psz ) {
            psz++;
        } else {
            psz = _pszSCPDN;
        }
        *ppwsz = (LPWSTR) TraceStrDup( psz );
        if ( !*ppwsz ) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        *ppwsz = NULL;
    }

    HRETURN(hr);
}

#if 0
//
// GetGroupDN( )
//
HRESULT
THISCLASS::GetGroupDN(
                     LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetGroupDN( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN( E_POINTER );

    if ( _pszGroupDN ) {
        *ppwsz = (LPWSTR) TraceStrDup( _pszGroupDN );
        if ( !*ppwsz ) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        *ppwsz = NULL;
        hr = S_FALSE;
    }

    HRETURN(hr);
}
#endif
//
// GetServerName( )
//
STDMETHODIMP
THISCLASS::GetServerName(
                        LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetServerName( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN(E_POINTER);

    *ppwsz = NULL;

    if ( !_pszMachineName ) {
        hr = _GetComputerNameFromADs( );
        if (FAILED( hr ))
            goto Error;
    }

    if ( _pszMachineName ) {
        *ppwsz = (LPWSTR) TraceStrDup( _pszMachineName );
        if ( !*ppwsz ) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = S_FALSE;
    }
    Error:
    HRETURN(hr);

}

//
// _GetComputerNameFromADs( )
//
HRESULT
THISCLASS::_GetComputerNameFromADs( )
{
    TraceClsFunc( "_GetComputerNameFromADs( )\n" );

    if ( _pszMachineName )
        HRETURN(S_OK); // nop

    HRESULT hr;
    VARIANT var;
    IADs    *pads = NULL;
    LPWSTR  pszMachinePath = NULL;
    LPWSTR  psz;
    _bstr_t Str;

    VariantInit( &var );

    // Retrieve the NETBOOTSERVER attribute
    Str = NETBOOTSERVER;
    hr = THR( _pads->Get( Str, &var ) );
    if (FAILED( hr )) {
        goto Cleanup;
    }

    Assert( V_VT( &var ) == VT_BSTR );
    hr = FixObjectPath( _pszDSServerName, V_BSTR( &var ), &pszMachinePath );
    if (FAILED( hr )) {
        goto Cleanup;
    }

    VariantClear( &var );

    hr = THR( ADsGetObject( pszMachinePath, IID_IADs, (void**) &pads ) );
    if (FAILED( hr )) {
        goto Cleanup;
    }

    Str = SAMNAME;
    hr = THR( pads->Get( Str, &var ) );
    if (FAILED( hr ) ||
        V_VT( &var ) != VT_BSTR) {
        if (hr == S_OK) {
            hr = E_FAIL;
        }
        goto Cleanup;
    }

    Assert( V_VT( &var ) == VT_BSTR );
    _pszMachineName = TraceStrDup( V_BSTR( &var ) );
    if ( !_pszMachineName ) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    psz = &_pszMachineName[ wcslen( _pszMachineName ) - 1 ];
    if ( *psz == L'$' ) {
        *psz = L'\0';
    }

    DebugMsg( "Server Name: %ws\n", _pszMachineName );

Cleanup:
    VariantClear( &var );
    if ( pads )
        pads->Release( );
    if ( pszMachinePath )
        TraceFree( pszMachinePath );
    HRETURN(hr);
}

//
// GetDataObject( )
//
STDMETHODIMP
THISCLASS::GetDataObject(
                        LPDATAOBJECT * pDataObj 
                        )
{
    TraceClsFunc( "GetDataObject( ... )\n" );

    if ( !pDataObj )
        HRETURN( E_POINTER );

    *pDataObj = _pDataObj;
    _pDataObj->AddRef( );

    HRETURN(S_OK);
}

//
// GetNotifyWindow( )
//
STDMETHODIMP
THISCLASS::GetNotifyWindow(
                          HWND * phNotifyObj 
                          )
{
    TraceClsFunc( "GetNotifyWindow( ... )\n" );

    if ( !phNotifyObj )
        HRETURN(E_POINTER);

    *phNotifyObj = _hwndNotify;

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dataobj.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DATAOBJ.CPP - A data object
//

#include "pch.h"
#include "dataobj.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CDsPropDataObj")
#define THISCLASS CDsPropDataObj
#define LPTHISCLASS CDsPropDataObj*


//
// CreateInstance( )
//
LPVOID 
CDsPropDataObj_CreateInstance( 
    HWND hwndParent,
    IDataObject * pido,
    GUID * pClassGUID,
    BOOL fReadOnly,
    LPWSTR pszObjPath,
    LPWSTR bstrClass )
{
    TraceFunc( "CDsPropDataObj_CreateInstance( ... )\n" );

    LPTHISCLASS lpcc = new THISCLASS( hwndParent, pido, pClassGUID, fReadOnly);
    if (!lpcc)
        RETURN(lpcc);

    HRESULT hr = THR( lpcc->Init( pszObjPath, bstrClass ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}


//
// Constructor
//
THISCLASS::THISCLASS(
    HWND hwndParent,
    IDataObject * pido, 
    GUID * pClassGUID,
    BOOL fReadOnly) :
        m_fReadOnly(fReadOnly),
        m_pwszObjName(NULL),
        m_pwszObjClass(NULL),
        m_hwnd(hwndParent),
        m_pPage(pido),
        m_ClassGUID(*pClassGUID),
        _cRef(0)
{
    TraceClsFunc( "CDsPropDataObj( )\n" );

    if (m_pPage) {
        m_pPage->AddRef();
    }

    TraceFuncExit( );
}

//
// Destructor
//
THISCLASS::~THISCLASS(void)
{
    TraceClsFunc( "~CDsPropDataObj( )\n" );
    if (m_pPage) {
        m_pPage->Release();
    }

    if (m_pwszObjName) {
        TraceFree(m_pwszObjName);
    }

    if (m_pwszObjClass) {
        TraceFree(m_pwszObjClass);
    }

    TraceFuncExit( );
}

//
// Init( )
//
HRESULT
THISCLASS::Init(
    LPWSTR pwszObjName, 
    LPWSTR pwszClass )
{
    TraceClsFunc( "Init( ... )\n" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CDsPropDataObj, IDataObject );
    QITABLE_IMP( IDataObject );
    END_QITABLE_IMP( CDsPropDataObj );
    Assert( _cRef == 0);
    AddRef( );

    if (!pwszObjName || *pwszObjName == L'\0')
    {
        HRETURN(E_INVALIDARG);
    }
    if (!pwszClass || *pwszClass == L'\0')
    {
        HRETURN(E_INVALIDARG);
    }
    
    m_pwszObjName = (LPWSTR) TraceStrDup( pwszObjName );
    if ( !m_pwszObjName ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    m_pwszObjClass = (LPWSTR) TraceStrDup( pwszClass );
    if ( !m_pwszObjClass ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

Cleanup:
    HRETURN(hr);

Error:
    if ( m_pwszObjName ) {
        TraceFree( m_pwszObjName );
        m_pwszObjName = NULL;
    }

    if ( m_pwszObjClass ) {
        TraceFree( m_pwszObjClass );
        m_pwszObjClass = NULL;
    }

    MessageBoxFromHResult( m_hwnd, IDC_ERROR_CREATINGACCOUNT_TITLE, hr );

    goto Cleanup;
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    
    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IDataObject
//
// ************************************************************************

//
// GetData( )
//
STDMETHODIMP
THISCLASS::GetData(
    FORMATETC * pFormatEtc, 
    STGMEDIUM * pMedium)
{
    TraceClsFunc( "[IDataObject] GetData( ... )\n" );
    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM))) {
        HRETURN(E_INVALIDARG);
    }        
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL)) {
        HRETURN(DV_E_TYMED);
    }

    HRESULT hr = S_OK;

    if (pFormatEtc->cfFormat == g_cfDsObjectNames)
    {
        // return the object name and class.
        //
        if (!m_pwszObjName || !m_pwszObjClass) {
            HRETURN(E_INVALIDARG);
        }
        INT cbPath  = sizeof(WCHAR) * (wcslen(m_pwszObjName) + 1);
        INT cbClass = sizeof(WCHAR) * (wcslen(m_pwszObjClass) + 1);
        INT cbStruct = sizeof(DSOBJECTNAMES);

        LPDSOBJECTNAMES pDSObj;

        pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              cbStruct + cbPath + cbClass);
        if (pDSObj == NULL) {
            hr = THR(STG_E_MEDIUMFULL);
            goto Exit;
        }

        ZeroMemory(pDSObj, sizeof(DSOBJECTNAMES));
        pDSObj->clsidNamespace = CLSID_MicrosoftDS;
        pDSObj->cItems = 1;
        pDSObj->aObjects[0].offsetName = cbStruct;
        pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;
        if (m_fReadOnly)
        {
            pDSObj->aObjects[0].dwFlags = DSOBJECT_READONLYPAGES;
        }

        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct), m_pwszObjName);
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct + cbPath), m_pwszObjClass);

        pMedium->hGlobal = (HGLOBAL)pDSObj;
    }
    else if (pFormatEtc->cfFormat == g_cfDsPropCfg)
    {
        // return the property sheet notification info. In this case, it is
        // the invokding sheet's hwnd.
        //
        PPROPSHEETCFG pSheetCfg;

        pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               sizeof(PROPSHEETCFG));
        if (pSheetCfg == NULL) {
            hr = THR(STG_E_MEDIUMFULL);
            goto Exit;
        }

        ZeroMemory(pSheetCfg, sizeof(PROPSHEETCFG));

        pSheetCfg->hwndParentSheet = m_hwnd;

        pMedium->hGlobal = (HGLOBAL)pSheetCfg;
    }
    else
    {
        // Pass call on to "parent" object's data obj.
        if (m_pPage ) {
            hr = m_pPage->GetData( pFormatEtc, pMedium );
#ifdef DEBUG
            if (hr != DV_E_FORMATETC ) {
                THR(hr);
            }
#endif
            goto Exit;
        } else {
            hr = THR(E_FAIL);
            goto Exit;
        }
    }

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->pUnkForRelease = NULL;

Exit:
    HRETURN(hr);
}

//
// GetDataHere( )
//
STDMETHODIMP
THISCLASS::GetDataHere(
    LPFORMATETC pFormatEtc, 
    LPSTGMEDIUM pMedium)
{
    TraceClsFunc( "[IDataObject] GetDataHere( ... )\n" );
    HRESULT hr;

    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM))) {
        HRETURN(E_INVALIDARG);
    }

    if (pFormatEtc->cfFormat == g_cfMMCGetNodeType)
    {   
        if (!(pFormatEtc->tymed & TYMED_HGLOBAL)) {
            hr = THR(DV_E_TYMED);
            goto Error;
        }
        LPSTREAM lpStream;
        ULONG written;

        // Create the stream on the hGlobal passed in.
        //
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &lpStream);
        if (hr)
            goto Error;

        hr = lpStream->Write(&m_ClassGUID, sizeof(m_ClassGUID), &written);

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the
        // stream is released here.
        lpStream->Release();
    } else if (m_pPage ) {
        // Pass call on to "parent" object's data obj.
        hr = THR( m_pPage->GetDataHere( pFormatEtc, pMedium ) );
    } else {
        hr = THR(E_FAIL);
    }

Cleanup:
    HRETURN(hr);

Error:
    goto Cleanup;
}

//
// EnumFormatEtc( )
//
STDMETHODIMP
THISCLASS::EnumFormatEtc(
    DWORD dwDirection,
    LPENUMFORMATETC * ppEnumFormatEtc)
{
    TraceClsFunc( "[IDataObject] EnumFormatEtc( ... )\n" );
    //
    // Pass call on to "parent" object's data obj.
    //
    if (m_pPage )
    {
        HRETURN(m_pPage->EnumFormatEtc(dwDirection, ppEnumFormatEtc));
    }
    else
    {
        HRETURN(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("IMADMUI")

#ifdef DEBUG

// Constants
    #define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

WCHAR g_DebugBuffer[DEBUG_OUTPUT_BUFFER_SIZE];
WCHAR g_DebugFormatBuffer[DEBUG_OUTPUT_BUFFER_SIZE];

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// DebugInitializeTraceFlags( )
//
void
DebugInitializeTraceFlags( )
{
    TCHAR szPath[ MAX_PATH ];
    LPTSTR pszExtension;

    GetModuleFileName( g_hInstance, szPath, ARRAYSIZE( szPath ) );
    pszExtension = &szPath[ lstrlen( szPath ) - 3 ];
    StrCpy( pszExtension, TEXT("ini") );
    DebugMsg( "Reading %s for debug settings...\n", szPath );

    g_dwTraceFlags = GetPrivateProfileInt( __MODULE__, TEXT("TraceFlags"), 0, szPath );
    DebugMsg( "g_dwTraceFlags = 0x%08x\n", g_dwTraceFlags );
}


//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for ( DWORD dw = 1; dw < g_dwCounter; dw++ )
        OutputDebugStringA( "| " );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized ) {
        //
        // The critical section is deleted DeleteCriticalSection( )
        // on process detach.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
                     LPTSTR  pszBuf,
                     LPCTSTR pszFile,
                     const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
                 FORMAT_MESSAGE_FROM_STRING |
                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                 TEXT("%1(%2!u!):"),
                 0,                          // error code
                 0,                          // default language
                 (LPTSTR) pszBuf,            // output buffer
                 DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                 (va_list*) args );           // arguments

    return pszBuf;
}



//
// TraceMsg() - ascii
//
void
TraceMsg(
        DWORD dwCheckFlags,
        LPCSTR pszFormat,
        ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
          || !!( g_dwTraceFlags & dwCheckFlags ) )) {
        dbgEnterCS( );

        mbstowcs( g_DebugFormatBuffer, pszFormat, lstrlenA( pszFormat ) + 1 );

        va_start( valist, pszFormat );
        wvsprintf( g_DebugBuffer, g_DebugFormatBuffer, valist );
        va_end( valist );

        OutputDebugString( g_DebugBuffer );

        dbgExitCS( );
    }
}

//
// TraceMsg() - unicode
//
void
TraceMsg(
        DWORD dwCheckFlags,
        LPCWSTR pszFormat,
        ... )
{
    va_list valist;
    
    if (( dwCheckFlags == TF_ALWAYS
          || !!( g_dwTraceFlags & dwCheckFlags ) )) {
    
        dbgEnterCS( );
    
        va_start( valist, pszFormat );
        wvsprintf( g_DebugBuffer, pszFormat, valist);
        va_end( valist );
    
        OutputDebugString( g_DebugBuffer );
    
        dbgExitCS( );
    }
}

//
// TraceMessage()
//
void
TraceMessage(
            LPCTSTR pszFile,
            const int uLine,
            LPCTSTR pszModule,
            DWORD   dwCheckFlags,
            LPCTSTR pszFormat,
            ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
          || !!( g_dwTraceFlags & dwCheckFlags ) )) {
        dbgEnterCS( );

        if ( !pszModule ) {
            pszModule = g_szUnknown;
        }

        if ( !pszFile ) {
            wsprintf( g_DebugBuffer, g_szFormat, g_szNULL, pszModule );
        } else {
            dbgmakefilelinestring( g_DebugFormatBuffer, pszFile, uLine );
            wsprintf( g_DebugBuffer, g_szFormat, g_DebugFormatBuffer, pszModule );
        }

        OutputDebugString( g_DebugBuffer );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( g_DebugBuffer, pszFormat, valist );
        va_end( valist );

        OutputDebugString( g_DebugBuffer );

        dbgExitCS( );
    }
}

//
// TraceMessageDo()
//
void
TraceMessageDo(
              LPCTSTR pszFile,
              const int uLine,
              LPCTSTR pszModule,
              DWORD   dwCheckFlags,
              LPCTSTR pszFormat,
              LPCTSTR pszFunc,
              ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
          || !!( g_dwTraceFlags & dwCheckFlags ) )) {
        
        LPCTSTR psz = pszFunc;

        dbgEnterCS( );

        if ( !pszModule ) {
            pszModule = g_szUnknown;
        }

        if ( !pszFile ) {
            wsprintf( g_DebugBuffer, g_szFormat, g_szNULL, pszModule );
        } else {
            dbgmakefilelinestring( g_DebugFormatBuffer, pszFile, uLine );
            wsprintf( g_DebugBuffer, g_szFormat, g_DebugFormatBuffer, pszModule );
        }

        
        OutputDebugString( g_DebugBuffer );

        dbgspace( );

        while ( *psz && *psz != TEXT('='))
            psz++;

        lstrcpyn( g_DebugFormatBuffer, pszFunc, (size_t)(1 + psz - pszFunc) );

        wsprintf( g_DebugBuffer, TEXT("V %s= "), g_DebugFormatBuffer );
        OutputDebugString( g_DebugBuffer );

        va_start( valist, pszFunc );
        wvsprintf( g_DebugBuffer, pszFormat, valist );
        va_end( valist );

        OutputDebugString( g_DebugBuffer );
        OutputDebugString( L"\n" );

        dbgExitCS( );
    }
}

//
// DebugMessage()
//
void
DebugMessage(
            LPCTSTR pszFile,
            const int uLine,
            LPCTSTR pszModule,
            LPCTSTR pszFormat,
            ... )
{
    va_list valist;

    dbgEnterCS( );

    if ( !pszModule ) {
        pszModule = g_szUnknown;
    }

    if ( !pszFile ) {
        wsprintf( g_DebugBuffer, g_szFormat, g_szNULL, pszModule );
    } else {
        dbgmakefilelinestring( g_DebugFormatBuffer, pszFile, uLine );
        wsprintf( g_DebugBuffer, g_szFormat, g_DebugFormatBuffer, pszModule );
    }

    OutputDebugString( g_DebugBuffer );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( g_DebugBuffer, pszFormat, valist );
    va_end( valist );

    OutputDebugString( g_DebugBuffer );

    dbgExitCS( );
}

//
// DebugMessageDo()
//
void
DebugMessageDo(
              LPCTSTR pszFile,
              const int uLine,
              LPCTSTR pszModule,
              LPCTSTR pszFormat,
              LPCTSTR pszFunc,
              ... )
{
    va_list valist;
    LPCTSTR psz = pszFunc;

    dbgEnterCS( );

    if ( !pszModule ) {
        pszModule = g_szUnknown;
    }

    if ( !pszFile ) {
        wsprintf( g_DebugBuffer, g_szFormat, g_szNULL, pszModule );
    } else {
        dbgmakefilelinestring( g_DebugFormatBuffer, pszFile, uLine );
        wsprintf( g_DebugBuffer, g_szFormat, g_DebugFormatBuffer, pszModule );
    }

    OutputDebugString( g_DebugBuffer );

    dbgspace( );

    while ( *psz && *psz != TEXT('='))
        psz++;

    lstrcpyn( g_DebugFormatBuffer, pszFunc, (size_t)(1 + psz - pszFunc) );

    wsprintf( g_DebugBuffer, TEXT("V %s= "), g_DebugFormatBuffer );
    OutputDebugString( g_DebugBuffer );

    va_start( valist, pszFunc );
    wvsprintf( g_DebugBuffer, pszFormat, valist );
    va_end( valist );

    OutputDebugString( g_DebugBuffer );
    OutputDebugString( TEXT("\n") );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
        LPCSTR pszFormat,
        ... )
{
    va_list valist;

    dbgEnterCS( );

    mbstowcs( g_DebugFormatBuffer, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( g_DebugBuffer, g_DebugFormatBuffer, valist);
    va_end( valist );

    OutputDebugString( g_DebugBuffer );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
        LPCWSTR pszFormat,
        ... )
{
    va_list valist;

    dbgEnterCS( );

    va_start( valist, pszFormat );
    wvsprintf( g_DebugBuffer, pszFormat, valist);
    va_end( valist );

    OutputDebugString( g_DebugBuffer );

    dbgExitCS( );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
             LPCTSTR pszFile,
             const int uLine,
             LPCTSTR pszModule,
             LPCTSTR pszfn,
             BOOL    fTrue )
{
    if ( !fTrue ) {
        WCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgEnterCS( );

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL ) {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL ) {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL ) {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( g_DebugFormatBuffer, pszFile, uLine );

        wsprintf( g_DebugBuffer, TEXT("%-50s  %-10s ASSERT: %s\n"),
                  g_DebugFormatBuffer, pszModule, pszfn );

        OutputDebugString( g_DebugBuffer );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
                  pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                                 MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
       LPCTSTR pszFile,
       const int uLine,
       LPCTSTR pszModule,
       LPCTSTR pszfn,
       HRESULT hr )
{
    if ( hr != S_OK) {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf = NULL;
        BOOLEAN bDelete=TRUE;

        switch ( hr ) {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage(
                         FORMAT_MESSAGE_ALLOCATE_BUFFER
                         | FORMAT_MESSAGE_FROM_SYSTEM,
                         NULL,
                         hr,
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                         (LPTSTR)&pszMsgBuf,
                         0,
                         NULL
                         );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL ) {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
            bDelete = FALSE;
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
                  szFileLine, pszModule, hr, pszMsgBuf );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
                  pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                                  MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( hr != S_OK && hr != S_FALSE  && bDelete) {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    int     uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
              HGLOBAL hglobal,
              LPCTSTR pszFile,
              const int uLine,
              LPCTSTR pszModule,
              UINT    uFlags,
              DWORD   dwBytes,
              LPCTSTR pszComment )
{
    if ( hglobal ) {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                           GMEM_FIXED,
                                                           sizeof(MEMORYBLOCK) );

        if ( !pmb ) {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
                 HGLOBAL hglobal )
{
    if ( hglobal ) {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal ) {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead ) {
            if ( pmbLast ) {
                pmbLast->pNext = pmbHead->pNext;
            } else {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            memset( pmbHead->hglobal, 0xFA, pmbHead->dwBytes );
            GlobalFree( pmbHead );
        } else {
            DebugMsg( "\n**** Attempted to free memory at 0x%08x (ThreadID = 0x%08x) ****\n\n",
                      hglobal, GetCurrentThreadId( ) );
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
          LPCTSTR pszFile,
          const int uLine,
          LPCTSTR pszModule,
          UINT    uFlags,
          DWORD   dwBytes,
          LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
         HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb ) {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE ) {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
            //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) ) {
            FormatMessage(
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                         0,                          // error code
                         0,                          // default language
                         (LPTSTR) szOutput,         // output buffer
                         ARRAYSIZE( szOutput ),   // size of buffer
                         (va_list*) args );           // arguments
        } else {
            FormatMessage(
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                         0,                          // error code
                         0,                          // default language
                         (LPTSTR) szOutput,         // output buffer
                         ARRAYSIZE( szOutput ),   // size of buffer
                         (va_list*) args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE ) {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    if (g_dwTraceFlags & TF_MEMORYALLOCS) {
        Assert( !fFoundLeak );
    }

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//

#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize, L"new()" );
}

void * __cdecl operator new(size_t t_size )
{
    return DebugAlloc( L"Unknown", 0, L"Unknown", GPTR, t_size, L"unmapped new()" );    
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dll.h ===
//
// Copyright 1997 - Microsoft
//

//
// DLL.H - DLL globals
//

#ifndef _DLL_H_
#define _DLL_H_

extern HINSTANCE g_hInstance;
extern DWORD     g_cObjects;
extern DWORD     g_cLock;
extern UINT      g_cfDsObjectNames;
extern UINT      g_cfDsDisplaySpecOptions;
extern UINT      g_cfDsPropetyPageInfo;
extern UINT      g_cfMMCGetNodeType;
extern WCHAR     g_szDllFilename[ MAX_PATH ];
extern WCHAR     g_cszHelpFile[];


#define DllExport   __declspec( dllimport )

//
// Thread-safe inc/decrements macros.
//
extern CRITICAL_SECTION g_InterlockCS;

#define InterlockDecrement( _var ) {\
    EnterCriticalSection( &g_InterlockCS ); \
    --_var;\
    LeaveCriticalSection( &g_InterlockCS ); \
    }
#define InterlockIncrement( _var ) {\
    EnterCriticalSection( &g_InterlockCS ); \
    ++_var;\
    LeaveCriticalSection( &g_InterlockCS ); \
    }


//
// Class Definitions
//
typedef void *(*LPCREATEINST)();

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
} CLASSTABLE[], *LPCLASSTABLE;

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {

#define DEFINE_CLASS( _pfn, _riid, _name ) { _pfn, &_riid, TEXT(_name) },

#define END_CLASSTABLE  { NULL, NULL, NULL } };

extern const CLASSTABLE  g_DllClasses;

#include "qi.h"
#include "debug.h"

// Macros
#define ARRAYSIZE( _x ) ((UINT) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ))
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags

#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030    // SCP objects


#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const WCHAR g_szTrue[];
extern const WCHAR g_szFalse[];

extern CRITICAL_SECTION g_DebugCS;
extern BOOL  g_fDebugInitialized;


// Macros
#define DEFINE_MODULE( _module ) static const WCHAR g_szModule[] = L"_module";
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const WCHAR g_szClass[] = L"_class"; 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const WCHAR g_szSuper[] = L"_super";
#define __SUPER__ g_szSuper

#if defined(_X86_)
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( );
#endif

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    DebugInitializeTraceFlags( );           \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") ) 

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceAllocString( _flags, _size ) (LPTSTR) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, (_size) * sizeof(WCHAR), TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr != S_OK ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        { TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); }\
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Displays the file, line number, module and function call and return value
// which is formatted in "_msg" for "_fn" only if the TF_CALLS is set in 
// g_dwTraceFlags. 
#define TraceMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), TEXT(#_fn), _fn ); \
    InterlockDecrement(g_dwCounter); \
}

// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#define TraceMsgGUID( _flag, _guid ) \
    TraceMsg( _flag, TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), \
        _guid.Data1, _guid.Data2, _guid.Data3,  \
        _guid.Data4[0], _guid.Data4[1], _guid.Data4[2], _guid.Data4[3], \
        _guid.Data4[4], _guid.Data4[5], _guid.Data4[6], _guid.Data4[7] )

#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );

//
// Debug Macros
//
// These calls are only compiled in DEBUG. They are a NOP in RETAIL (not even
// compiled in.
//

// Same as TraceDo() but only compiled in DEBUG.
#define DebugDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Same as TraceMsgDo() but only compiled in DEBUG.
#define DebugMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), TEXT(#_fn), _fn); \
    InterlockDecrement(g_dwCounter); \
}

//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }

// Warning is display if HRESULT is anything but S_OK (0) only if 
// TF_QUERYINTERFACE is set in g_dwTraceFlags, otherwise only a debug message
// will be printed.
#define QIRETURN( _hr, _riid ) { \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) ) { \
        RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), _hr )); \
    } else if ( _hr != S_OK ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("HRESULT: QueryInterface({%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}) failed(), hr = 0x%08x\n"),  _riid.Data1, _riid.Data2, _riid.Data3,  _riid.Data4[0], _riid.Data4[1], _riid.Data4[2], _riid.Data4[3], _riid.Data4[4], _riid.Data4[5], _riid.Data4[6], _riid.Data4[7], _hr ); \
    RETURN(_hr); \
    }

// Warning is display if HRESULT is not S_OK (0) or "_ok".
#define RRETURN1( _hr, _ok ) {\
    RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), \
                    ( ( _hr == _ok ) ? S_OK : _hr ) ) ); \
    }

//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCWSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
TraceMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

void 
DebugMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT("_handle") );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("_pv") );

#define TraceStrDup( _sz ) \
    (LPTSTR) DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup( _sz )") )

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

void
DebugInitializeTraceFlags( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

#pragma message("BUILD: RETAIL macros being built")

// Debugging -> NOPs
#define Assert( _fn )           
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define TraceMsgGUID( _f, _g )      
#define DebugMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define DebugMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceAllocString( _flags, _size )     (LPTSTR) GlobalAlloc( _flags, (_size) * sizeof(WCHAR))
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dll.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DLL.CPP - DLL entry points
//

#include "pch.h"
#include "register.h"
#include "ccomputr.h"
#include "cservice.h"

DEFINE_MODULE("IMADMUI")

// DLL Globals
HINSTANCE g_hInstance = NULL;
DWORD     g_cObjects  = 0;
DWORD     g_cLock     = 0;
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };
UINT      g_cfDsObjectNames;
UINT      g_cfDsDisplaySpecOptions;
UINT      g_cfDsPropetyPageInfo;
UINT      g_cfMMCGetNodeType;
WCHAR     g_cszHelpFile[] = L"rbadmin.hlp";

CRITICAL_SECTION g_InterlockCS;

//
// DLLMain()
//
BOOL WINAPI
DllMain(
    HANDLE hInst, 
    ULONG uReason, 
    LPVOID lpReserved)
{
    if ( uReason == DLL_PROCESS_ATTACH )
    {
        InitializeCriticalSection( &g_InterlockCS );
    }

    // keep down the noise
#ifdef DEBUG
    if ( g_dwTraceFlags & TF_DLL )
    {
        TraceFunc( "DllMain() - " );
    }
#endif // DEBUG
   
    switch( uReason )
    {
    case DLL_PROCESS_ATTACH:
        TraceMsg( TF_DLL, "DLL_PROCESS_ATTACH - ThreadID = 0x%08x\n", GetCurrentThreadId( ) );

        INITIALIZE_TRACE_MEMORY_PROCESS;

        g_hInstance = (HINSTANCE) hInst;

        TraceAssertIfZero( GetModuleFileName( g_hInstance, g_szDllFilename, ARRAYSIZE( g_szDllFilename ) ) ); 
        break;

    case DLL_PROCESS_DETACH:
        TraceMsg( TF_DLL, "DLL_PROCESS_DETACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        UNINITIALIZE_TRACE_MEMORY;
#ifdef DEBUG
        if (g_fDebugInitialized) {
            DeleteCriticalSection(&g_DebugCS);
            g_fDebugInitialized = FALSE;
        }
#endif

        DeleteCriticalSection( &g_InterlockCS );
        break;

    case DLL_THREAD_ATTACH:
        TraceMsg( TF_DLL, "DLL_THREAD_ATTACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        INITIALIZE_TRACE_MEMORY_THREAD;
        break;

    case DLL_THREAD_DETACH:
        TraceMsg( TF_DLL, "DLL_THREAD_DETACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        UNINITIALIZE_TRACE_MEMORY;
        break;
    }

#ifdef DEBUG
    if ( g_dwTraceFlags & TF_DLL )
    {
        RETURN(TRUE);
    }
#endif // DEBUG

    return TRUE;
} // DLLMain()

//
// DllGetClassObject()
//
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    void** ppv )
{
    TraceFunc( "DllGetClassObject( ");

    if ( !ppv )
    {
        TraceMsg( TF_FUNC, "ppv == NULL! )\n" );
        RRETURN(E_POINTER);
    }

    LPCFACTORY  lpClassFactory;
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    int i = 0; 
    while( g_DllClasses[ i ].rclsid )
    {
        if ( *g_DllClasses[ i ].rclsid == rclsid )
        {
            TraceMsg( TF_FUNC, TEXT("rclsid= %s, riid, ppv )\n"), g_DllClasses[ i ].pszName );
            hr = S_OK;
            break;
        }

        i++;
    }

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        TraceMsg( TF_FUNC, "rclsid= " );
        TraceMsgGUID( TF_FUNC, rclsid );
        TraceMsg( TF_FUNC, ", riid, ppv )\n" );
        goto Cleanup;
    }

	Assert( g_DllClasses[ i ].pfnCreateInstance != NULL );
    lpClassFactory = 
        new CFactory( g_DllClasses[ i ].pfnCreateInstance );

    if ( !lpClassFactory )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    hr = THR( lpClassFactory->Init( ) );
    if ( FAILED(hr) )
    {
        TraceDo( delete lpClassFactory );
        goto Cleanup;
    }

    hr = lpClassFactory->QueryInterface( riid, ppv );
    ((IUnknown *) lpClassFactory )->Release( );

Cleanup:
    HRETURN(hr);
}


//
// DllRegisterServer()
//
STDAPI 
DllRegisterServer(void)
{
    HRESULT hr;

    TraceFunc( "DllRegisterServer()\n" );

    hr = RegisterDll( TRUE );

    HRETURN(hr);
}

//
// DllUnregisterServer()
//
STDAPI 
DllUnregisterServer(void)
{
    TraceFunc( "DllUnregisterServer()\n" );

    HRETURN( RegisterDll( FALSE ) );
}

//
// DllCanUnloadNow()
//
STDAPI 
DllCanUnloadNow(void)
{
    TraceFunc( "DllCanUnloadNow()\n" );

    HRESULT hr = S_OK;

    if ( g_cLock || g_cObjects )
    {
        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        hr = S_FALSE;
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dpguidqy.h ===
//
// Copyright 1997 - Microsoft

//
// DPGUIDQY.H - The duplicate GUID query form
//


#ifndef _DPGUIDQY_H_
#define _DPGUIDQY_H_

// QITable
BEGIN_QITABLE( CRIQueryForm )
DEFINE_QI( IID_IQueryForm, IQueryForm, 3 )
END_QITABLE

// Definitions
LPVOID
CRIQueryForm_CreateInstance( void );

// CRIQueryForm
class CRIQueryForm
    : public IQueryForm
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CRIQueryForm );

    HWND        _hDlg;

private: // methods
    CRIQueryForm( );
    ~CRIQueryForm( );
    HRESULT
        Init( void );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static HRESULT CALLBACK
        PropSheetPageProc( LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _GetQueryParams( HWND hwnd, LPDSQUERYPARAMS* ppdsqp );

public: // methods
    friend LPVOID CRIQueryForm_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IQueryForm methods
    STDMETHOD(Initialize)(HKEY hkForm);
    STDMETHOD(AddForms)(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);
};

typedef CRIQueryForm * LPCRIQueryForm;


#endif // _DPGUIDQY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\guids.h ===
//
// Copyright 1997 - Microsoft
//

//
// GUIDS.H - GUID definitions
//

#ifndef _GUIDS_H_
#define _GUIDS_H_

//
// External CLSIDs
//

// {0F65B1BF-740F-11d1-BBE6-0060081692B3}
DEFINE_GUID(CLSID_Computer, 
0xf65b1bf, 0x740f, 0x11d1, 0xbb, 0xe6, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {AC409538-741C-11d1-BBE6-0060081692B3}
DEFINE_GUID(CLSID_Service, 
0xac409538, 0x741c, 0x11d1, 0xbb, 0xe6, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {C641CF88-892F-11d1-BBEB-0060081692B3}
DEFINE_GUID(CLSID_Group, 
0xc641cf88, 0x892f, 0x11d1, 0xbb, 0xeb, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {D6D8C25A-4E83-11d2-8424-00C04FA372D4}
DEFINE_GUID(CLSID_NewComputerExtension,
0xd6d8c25a, 0x4e83, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {C1293E17-534E-11d2-8424-00C04FA372D4}
DEFINE_GUID(CLSID_RIQueryForm, 
0xc1293e17, 0x534e, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {55650117-5b71-47f7-9fc1-0431f53c006f}
DEFINE_GUID(CLSID_RISrvQueryForm,
0x55650117, 0x5b71, 0x47f7, 0x9f, 0xc1, 0x04, 0x31, 0xf5, 0x3c, 0x00, 0x6f);

//
// Internally Used Private Interfaces
//

// {F6215ED8-819C-11d1-BBE9-00C04FB953EA}
DEFINE_GUID(IID_IMAO, 
0xf6215ed8, 0x819c, 0x11d1, 0xbb, 0xe9, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {C88158C5-87A2-11d1-BBEA-00C04FB953EA}
DEFINE_GUID(IID_IIntelliMirrorSAP, 
0xc88158c5, 0x87a2, 0x11d1, 0xbb, 0xea, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {FA7C2CE0-889D-11d1-BBEA-00C04FB953EA}
DEFINE_GUID(IID_IEnumIMSIFs, 
0xfa7c2ce0, 0x889d, 0x11d1, 0xbb, 0xea, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {562B752D-9140-11d1-BBEF-00C04FB953EA}
DEFINE_GUID(IID_IEnumSAPs, 
0x562b752d, 0x9140, 0x11d1, 0xbb, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {D2378471-523D-11d2-8424-00C04FA372D4}
DEFINE_GUID(IID_ITab, 
0xd2378471, 0x523d, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

#endif // _GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\dpguidqy.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DPGUIDQY.CPP - The duplicate GUID query form
//

#include "pch.h"

#include "dpguidqy.h"
#include "mangdlg.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CRIQueryForm")
#define THISCLASS CRIQueryForm
#define LPTHISCLASS LPCRIQueryForm

#define FILTER_QUERY_BOTH           L"(&(objectClass=computer)(netbootGUID=%ws*)(netbootMachineFilePath=%s))"
#define FILTER_QUERY_GUID_ONLY      L"(&(objectClass=computer)(netbootGUID=%ws*))"
#define FILTER_QUERY_SERVER_ONLY    L"(&(objectClass=computer)(netbootMachineFilePath=%s))"

#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((wcslen(sz)+1)*sizeof(WCHAR))


DWORD aQueryHelpMap[] = {
    IDC_E_SERVER, HIDC_E_SERVER,
    IDC_E_GUID, HIDC_E_GUID,
    NULL, NULL
};

//
// CRIQueryForm_CreateInstance( )
//
LPVOID
CRIQueryForm_CreateInstance( void )
{
    TraceFunc( "CRIQueryForm_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( FAILED(hr) )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CRIQueryForm( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CRIQueryForm, IQueryForm );
    QITABLE_IMP( IQueryForm );
    END_QITABLE_IMP( CRIQueryForm );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CRIQueryForm( )\n" );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(
    HKEY hkForm)
{
    TraceClsFunc( "[IQueryForm] Initialize( )\n" );

    HRETURN(S_OK);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::AddForms(
    LPCQADDFORMSPROC pAddFormsProc,
    LPARAM lParam )
{
    TraceClsFunc( "[IQueryForm] AddForms(" );
    TraceMsg( TF_FUNC, " pAddFormsProc = 0x%p, lParam = 0x%p )\n", pAddFormsProc, lParam );

    if ( !pAddFormsProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQFORM cqf;
    WCHAR szTitle[ 255 ];

    if (!LoadString( 
               g_hInstance, 
               IDS_REMOTE_INSTALL_CLIENTS, 
               szTitle, 
               ARRAYSIZE(szTitle) )) {
        HRETURN(HRESULT_FROM_WIN32(GetLastError()));        
    }
    
    ZeroMemory( &cqf, sizeof(cqf) );
    cqf.cbStruct = sizeof(cqf);
    cqf.dwFlags = CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_RIQueryForm;
    cqf.pszTitle = szTitle;

    hr = THR( pAddFormsProc(lParam, &cqf) );

    HRETURN(hr);
}


//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPCQADDPAGESPROC pAddPagesProc,
    LPARAM lParam)
{
    TraceClsFunc( "[IQueryForm] AddPages(" );
    TraceMsg( TF_FUNC, " pAddPagesProc = 0x%p, lParam = 0x%p )\n", pAddPagesProc, lParam );

    if ( !pAddPagesProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQPAGE cqp;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC) PropSheetPageProc;
    cqp.hInstance = g_hInstance;
    cqp.idPageName = IDS_REMOTE_INSTALL_CLIENTS;
    cqp.idPageTemplate = IDD_GUID_QUERY_FORM;
    cqp.pDlgProc = PropSheetDlgProc;
    cqp.lParam = (LPARAM)this;

    hr = THR( pAddPagesProc(lParam, CLSID_RIQueryForm, &cqp) );

    HRETURN(hr);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( L"PropSheetDlgProc(" );
    //TraceMsg( TF_FUNC, L" hDlg = 0x%p, uMsg = 0x%p, wParam = 0x%p, lParam = 0x%p )\n",
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, L"WM_INITDIALOG\n");

        CQPAGE * pcqp = (CQPAGE *) lParam;
        // bugbug can this fail?
        SetWindowLongPtr( hDlg, GWLP_USERDATA, pcqp->lParam );
        pcc = (LPTHISCLASS) pcqp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aQueryHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aQueryHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
HRESULT CALLBACK
THISCLASS::PropSheetPageProc(
    LPCQPAGE pQueryPage,
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, L"pQueryPage = 0x%p, hwnd = 0x%p, uMsg = 0x%p, wParam= 0x%p, lParam = 0x%p )\n",
        pQueryPage, hwnd, uMsg, wParam, lParam );

    HRESULT hr = E_NOTIMPL;
    Assert( pQueryPage );
    LPTHISCLASS pQueryForm = (LPTHISCLASS )pQueryPage->lParam;
    Assert( pQueryForm );

    switch ( uMsg )
    {
    // Initialize so AddRef the object we are associated with so that
    // we don't get unloaded.

    case CQPM_INITIALIZE:
        TraceMsg( TF_WM, "CQPM_INITIALIZE\n" );
        pQueryForm->AddRef();
        hr = S_OK;
        break;

    // Release, therefore Release the object we are associated with to
    // ensure correct destruction etc.

    case CQPM_RELEASE:
        TraceMsg( TF_WM, "CQPM_RELEASE\n" );
        SetWindowLongPtr( pQueryForm->_hDlg, GWLP_USERDATA, NULL );
        pQueryForm->Release();
        hr = S_OK;
        break;

    // Enable so fix the state of our two controls within the window.

    case CQPM_ENABLE:
        TraceMsg( TF_WM, "CQPM_ENABLE\n" );
        EnableWindow( GetDlgItem( hwnd, IDC_E_GUID ), (BOOL)wParam );
        EnableWindow( GetDlgItem( hwnd, IDC_E_SERVER ), (BOOL)wParam );
        hr = S_OK;
        break;

    // Fill out the parameter structure to return to the caller, this is
    // handler specific.  In our case we constructure a query of the CN
    // and objectClass properties, and we show a columns displaying both
    // of these.  For further information about the DSQUERYPARAMs structure
    // see dsquery.h

    case CQPM_GETPARAMETERS:
        TraceMsg( TF_WM, "CQPM_GETPARAMETERS\n" );
        hr = pQueryForm->_GetQueryParams( hwnd, (LPDSQUERYPARAMS*)lParam );
        break;

    // Clear form, therefore set the window text for these two controls
    // to zero.

    case CQPM_CLEARFORM:
        TraceMsg( TF_WM, "CQPM_CLEARFORM\n" );
        SetDlgItemText( hwnd, IDC_E_GUID, L"" );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"" );
        hr = S_OK;
        break;

    case CQPM_SETDEFAULTPARAMETERS:
        TraceMsg( TF_WM, "CQPM_SETDEFAULTPARAMETERS: wParam = %s  lParam = 0x%p\n", BOOLTOSTRING(wParam), lParam );
        if ( wParam && lParam )
        {
            VARIANT var;
            LPOPENQUERYWINDOW poqwi = (LPOPENQUERYWINDOW) lParam;
            IPropertyBag * ppb = poqwi->ppbFormParameters;
            Assert( ppb );
            VariantInit( &var );

            hr = ppb->Read( L"ServerName", &var, NULL );
            if (SUCCEEDED( hr ))
            {
                SetDlgItemText( hwnd, IDC_E_SERVER, V_BSTR( &var ) );
                VariantClear( &var );
            }          

            hr = ppb->Read( L"ClientGuid", &var, NULL );
            if (SUCCEEDED( hr ))
            {
                SetDlgItemText( hwnd, IDC_E_GUID, V_BSTR( &var ) );
                VariantClear( &var );
            }
        }
        else
        {
            DebugMsg( "No default parameters given.\n" );
            hr = S_OK;
        }
        break;

    default:
        TraceMsg( TF_WM, "CQPM_message 0x%08x *** NOT IMPL ***\n", uMsg );
        hr = E_NOTIMPL;
        break;
    }

    RETURN(hr);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    HRETURN(S_OK);
}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_GUID ), MAX_INPUT_GUID_STRING - 1 );
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );

    HRETURN(S_OK);
}

struct
{
    INT fmt;
    INT cx;
    INT uID;
    PCWSTR pDisplayProperty;
}
columns[] =
{
    0, 20, IDS_NAME, L"cn",
    0, 50, IDS_GUID, L"netbootGuid",
};

//
// _GetQueryParams( )
//
HRESULT
THISCLASS::_GetQueryParams(
    HWND hWnd,
    LPDSQUERYPARAMS* ppdsqp )
{
    TraceClsFunc( "_GetQueryParams( )\n" );

    if ( !ppdsqp )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT     i;
    WCHAR   szServer[DNS_MAX_NAME_BUFFER_LENGTH];
    WCHAR   szGuid[MAX_INPUT_GUID_STRING * 2];   // room for escaped GUID
    WCHAR   szFilter[ARRAYSIZE(szGuid)+ARRAYSIZE(szServer)+ARRAYSIZE(FILTER_QUERY_BOTH)];
    GUID    Guid;
    DWORD   uGuidLength;
    ULONG   offset;
    BOOL    fIncludeGuid = FALSE, fIncludeServer = FALSE;
    BOOL    CallerSpecifiedQuery = FALSE;
    BOOL    CallerQueryStartsWithAmpersand = FALSE;

    ULONG   cbStruct = 0;
    LPDSQUERYPARAMS pDsQueryParams = NULL;

#if 0
    if ( *ppdsqp )
    {
        // This page doesn't support appending its query data to an
        // existing DSQUERYPARAMS strucuture, only creating a new block,
        // therefore bail if we see the pointer is not NULL.
        hr = THR(E_INVALIDARG);
        goto Error;
    }
#endif

    //
    // This is how searches are done:
    // - if both guid and server are left blank, search for all
    //   accounts with netbootGuid specified (all managed computers).
    // - if either or both are specified, search for all computers
    //   that match.
    // - if guid is specified as '*', treat it the same as if it had
    //   been left blank (searches for all accounts with netbootGUID).
    //
    // Note that currently any account with a server in netbootMachineFilePath
    // will also have netbootGUID specified, because prestaging a
    // remote install computer always puts netbootGUID, and that is
    // the only way that netbootMachineFilePath will be set. So if the
    // user specifies a server but no guid, we don't need to include
    // netbootGUID=* in our ldap filter.
    //

    // Compute the size of the argument block
    if ( GetDlgItemText( hWnd, IDC_E_GUID, szGuid, ARRAYSIZE(szGuid)) )
    {
        //
        // Allow only a * as the GUID, to search for all machines with
        // a GUID.
        //

        if (wcscmp(szGuid, L"*") != 0)
        {
            if ( ValidateGuid(szGuid,&Guid,&uGuidLength) == E_FAIL || !uGuidLength ) {
                MessageBoxFromStrings( hWnd,
                                       IDS_INVALID_GUID_CAPTION,
                                       IDS_INVALID_PARTIAL_GUID_TEXT,
                                       MB_OK );
                hr = E_INVALIDARG;
                goto Error;
            }
    
            ZeroMemory( szGuid, sizeof(szGuid) );
            ldap_escape_filter_element((PCHAR)&Guid, uGuidLength, szGuid, sizeof(szGuid) );
        }
        else
        {
            szGuid[0] = L'\0';  // the filter adds a *, and "**" doesn't work, so blank it here
        }

        fIncludeGuid = TRUE;

    }

    if ( GetDlgItemText( hWnd, IDC_E_SERVER, szServer, ARRAYSIZE(szServer)) )
    {
        fIncludeServer = TRUE;
    }
    else
    {
        //
        // If no server or guid was specified, search for any guid.
        //
        if (!fIncludeGuid)
        {
            szGuid[0] = L'\0';
            fIncludeGuid = TRUE;
        }
    }

    if ( fIncludeGuid && fIncludeServer )
    {
        wsprintf( szFilter, FILTER_QUERY_BOTH, szGuid, szServer );
    }
    else if ( fIncludeGuid )
    {
        wsprintf( szFilter, FILTER_QUERY_GUID_ONLY, szGuid );
    }
    else if ( fIncludeServer )
    {
        wsprintf( szFilter, FILTER_QUERY_SERVER_ONLY, szServer );
    }
#ifdef DEBUG
    else
    {
        AssertMsg( 0, "How did we get here?\n" );
        szFilter[0] = L'\0';
    }
#endif // DEBUG

    DebugMsg( "RI Filter: %s\n", szFilter );

    // compute the size of the new query block
    if ( !*ppdsqp )
    {
        CallerSpecifiedQuery = FALSE;
        //  bugbug arraysize(columns)-1?
        offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(columns)-1)*sizeof(DSCOLUMN));
        cbStruct += StringByteSize(szFilter);
        for ( i = 0; i < ARRAYSIZE(columns); i++ )
        {
            cbStruct += StringByteSize(columns[i].pDisplayProperty);
        }
    }
    else
    {
        CallerSpecifiedQuery = TRUE;
        LPWSTR pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        offset = (*ppdsqp)->cbStruct;
        //
        // save off the size that we're gonna need.
        // note that when we concatenate the current query with our query, 
        // we need to make sure the query starts with "(&".  If it doesn't
        // already, then we make this the case -- the buffer szFilter contains
        // these bytes, which ensures that cbStruct is large enough.  If the current
        // query contains these strings, then the allocated buffer is a little
        // bigger than it needs to be.
        cbStruct = (*ppdsqp)->cbStruct + StringByteSize( pszQuery ) + StringByteSize( szFilter );
        
        //
        // do some extra query validation.
        // does the query start with "(&"?
        //        
        if (pszQuery[0] == L'(' && pszQuery[1] == L'&' ) {
            CallerQueryStartsWithAmpersand = TRUE;
            //
            //  we're assuming below that if the specified query
            //  doesn't start with "(&", that it will end with ")".
            //  If that's not the case then bail out.
            //
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] == L')' );
            if (pszQuery[ wcslen( pszQuery ) - 1 ] != L')' ) {
                hr = E_INVALIDARG;
                goto Error;
            }
        } else {
            //
            // conversely, if the query doesn't start with '(&', then
            // we assume that the query doesn't end with ')', and if it
            // does, we bail
            //
            CallerQueryStartsWithAmpersand = FALSE;
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] != L')' );
            if (pszQuery[ wcslen( pszQuery ) - 1 ] == L')' ) {
                hr = E_INVALIDARG;
                goto Error;
            }
        }
    }

    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.
    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);
    if ( !pDsQueryParams )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Did they hand in a query that we need to modify?
    if ( !CallerSpecifiedQuery)
    {   // no... create our own query
        pDsQueryParams->cbStruct = cbStruct;
        pDsQueryParams->dwFlags = 0;
        pDsQueryParams->hInstance = g_hInstance;
        pDsQueryParams->offsetQuery = offset;
        pDsQueryParams->iColumns = ARRAYSIZE(columns);

        // Copy the filter string and bump the offset
        StringByteCopy(pDsQueryParams, offset, szFilter);
        offset += StringByteSize(szFilter);

        // Fill in the array of columns to dispaly, the cx is a percentage of the
        // current view, the propertie names to display are UNICODE strings and
        // are referenced by offset, therefore we bump the offset as we copy
        // each one.

        for ( i = 0 ; i < ARRAYSIZE(columns); i++ )
        {
            pDsQueryParams->aColumns[i].fmt = columns[i].fmt;
            pDsQueryParams->aColumns[i].cx = columns[i].cx;
            pDsQueryParams->aColumns[i].idsName = columns[i].uID;
            pDsQueryParams->aColumns[i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, columns[i].pDisplayProperty);
            offset += StringByteSize(columns[i].pDisplayProperty);
        }
    } else  {   
        // yes, the caller specifed a query... add our parameters to the query
        LPWSTR pszQuery;
        LPWSTR pszNewQuery;
        INT    n;

        // duplicate the existing query
        Assert( offset == (*ppdsqp)->cbStruct );
        CopyMemory( pDsQueryParams, *ppdsqp, offset );
        pDsQueryParams->cbStruct = cbStruct;

        // new query location
        pDsQueryParams->offsetQuery = offset;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        pszNewQuery = (LPWSTR) ((LPBYTE)pDsQueryParams + offset);
        Assert( pszQuery );

        // append to their query
        // append to their query
        if ( CallerQueryStartsWithAmpersand ) {
            //
            // remove ")" from current query so that we can
            // add in our additional filter.  We've got the trailing ")" in our
            // filter.
            // Also note that we can't really fail at this point, and we're 
            // about to free the caller's memory so it's ok for us to overwrite their
            // query text.
            //
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] == L')' );
            pszQuery[ wcslen( pszQuery ) - 1 ] = L'\0'; // remove ")"

            // start with their query
            wcscpy(pszNewQuery, pszQuery);

            //
            // put it back to be a good citizen ")"
            //
            pszQuery[ wcslen( pszQuery )] = L')';

            //
            // now tack on our query, skipping the "(&" part
            //
            wcscat(pszNewQuery,&szFilter[2]);

        } else {
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] != L')' );
            wcscpy( pszNewQuery, L"(&" );               // add "(&" to begining of query
            wcscat( pszNewQuery, pszQuery );                // add their query
            wcscat( pszNewQuery, &szFilter[2] );            // add our query starting after the "(&"
        }

        offset += StringByteSize( pszNewQuery );        // compute new offset
        DebugMsg( "New Query String: %s\n", pszNewQuery );

        // Cleanup
        CoTaskMemFree( *ppdsqp );
    }

    // Success
    *ppdsqp = pDsQueryParams;
    Assert( hr == S_OK );

Cleanup:
    HRETURN(hr);
Error:
    if ( pDsQueryParams ) {
        CoTaskMemFree( pDsQueryParams );
    }

    // If we aren't modifying the query and there wasn't
    // a query handed into us, indicate failure instead.
    if ( hr == S_FALSE && !*ppdsqp ) {
        Assert(FALSE); // how did we get here?
        hr = E_FAIL;
    }
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\guids.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// GUIDS.CPP - GUID definitions
//

#include "pch.h"
#include <initguid.h>

#undef _GUIDS_H_
#include "guids.h"

#include "ccomputr.h"
#include "cservice.h"
#include "newcmptr.h"
#include "dpguidqy.h"
#include "serverqy.h"

//
// Classes in this Component
//
BEGIN_CLASSTABLE
DEFINE_CLASS( CComputer_CreateInstance, CLSID_Computer, "Remote Install Computer Property Pages")
DEFINE_CLASS( CService_CreateInstance,  CLSID_Service,  "Remote Install Service Property Pages" )
DEFINE_CLASS( CNewComputerExtensions_CreateInstance, CLSID_NewComputerExtension, "Remote Install New Computer Extension" )
DEFINE_CLASS( CRIQueryForm_CreateInstance, CLSID_RIQueryForm, "Remote Install DS Query Form" )
DEFINE_CLASS( CRISrvQueryForm_CreateInstance, CLSID_RISrvQueryForm, "Remote Install Server DS Query Form" )
END_CLASSTABLE

const IID IID_IExtendPropertySheet = {0x85DE64DC,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};
const CLSID CLSID_NodeManager = {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IPropertySheetProvider = {0x85DE64DE,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};

#include <dsadmin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\hostdlg.cpp ===
//
// Copyright 1997 - Microsoft

//
// HostDlg.CPP - Handles the IDD_HOST_SERVER_PAGE
//

#include "pch.h"
#include "dns.h"
#include "hostdlg.h"
#include "utils.h"
#include "newcmptr.h"
#include "winsock2.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CHostServerPage")
#define THISCLASS CHostServerPage
#define LPTHISCLASS LPCHostServerPage

DWORD aHostHelpMap[] = {
    IDC_B_ANYSERVER, HIDC_B_ANYSERVER,
    IDC_B_SPECIFICSERVER, HIDC_B_SPECIFICSERVER,
    IDC_E_SERVER, HIDC_E_SERVER,
    IDC_B_BROWSE, HIDC_B_BROWSE,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CHostServerPage_CreateInstance( void )
{
    TraceFunc( "CHostServerPage_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _pNewComputerExtension(NULL),
    _pfActivatable(NULL)
{
    TraceClsFunc( "CHostServerPage()\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pNewComputerExtension );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CHostServerPage()\n" );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage,
                   LPARAM lParam,
                   LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    Assert( lpfnAddPage );
    if ( !lpfnAddPage )
        HRETURN(E_INVALIDARG);

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_HOST_SERVER_PAGE);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage ) {
        if ( !lpfnAddPage( hpage, lParam ) ) {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                      LPARAM lParam,
                      LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
                           LPWSTR pszAttribute,
                           LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    if ( !pszResult )
        HRETURN(E_POINTER);

    if ( !pszAttribute )
        HRETURN(E_INVALIDARG);

    HRESULT hr = E_INVALIDARG;

    *pszResult = NULL;

    if ( _wcsicmp( pszAttribute, NETBOOTSERVER ) == 0 ) {
        LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
        if ( lResult ) {
            Assert( *pszResult == NULL );
            hr = S_OK;
        }

        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult ) {
            HWND  hwnd = GetDlgItem( _hDlg, IDC_E_SERVER );
            DWORD dw = Edit_GetTextLength( hwnd ) + 1;

            Assert( *pszResult == NULL );
            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult ) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwnd, *pszResult, dw );

            hr = S_OK;
        }
    }

    if ( _wcsicmp( pszAttribute, L"Server" ) == 0 ) {
        LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
        if ( lResult ) {
            WCHAR szAny[80];

            if (!LoadString( g_hInstance, IDS_ANY_SERVER, szAny, ARRAYSIZE(szAny)) ||
                !(*pszResult = (LPWSTR) TraceStrDup( szAny ))) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = S_OK;
        }

        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult ) {
            HWND  hwnd = GetDlgItem( _hDlg, IDC_E_SERVER );
            DWORD dw = Edit_GetTextLength( hwnd ) + 1;

            Assert( *pszResult == NULL );
            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult ) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwnd, *pszResult, dw );

            hr = S_OK;
        }
    }

    Cleanup:
    HRETURN(hr);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
                          BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    _pfActivatable = pfAllow;

    HRETURN(S_OK);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
                           HWND hDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG ) {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc) {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg ) {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aHostHelpMap );
            }
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aHostHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
                            HWND hwnd,
                            UINT uMsg,
                            LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
              hwnd, uMsg, ppsp );

    Assert( ppsp );
    LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;

    switch ( uMsg ) {
    case PSPCB_CREATE:
        TraceMsg( TF_WM, "PSPCB_CREATE\n" );
        if ( S_OK == pcc->_OnPSPCB_Create( ) ) {
            RETURN(TRUE);   // create it
        }
        break;

    case PSPCB_RELEASE:
        TraceMsg( TF_WM, "PSPCB_RELEASE\n" );
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    return S_OK;

}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
                      HWND hDlg,
                      LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;

    Assert( _pNewComputerExtension );
    SetWindowText( GetParent( _hDlg ), _pNewComputerExtension->_pszWizTitle );
    SetDlgItemText( _hDlg, IDC_S_CREATEIN, _pNewComputerExtension->_pszContDisplayName );
    SendMessage( GetDlgItem( _hDlg, IDC_S_ICON ), STM_SETICON, (WPARAM) _pNewComputerExtension->_hIcon, 0 );

    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ), BST_CHECKED );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    switch ( LOWORD(wParam) ) {
    case IDC_B_ANYSERVER:
    case IDC_B_SPECIFICSERVER:
        if ( HIWORD(wParam) == BN_CLICKED ) {
            LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
            EnableWindow( GetDlgItem( _hDlg, IDC_E_SERVER), (BOOL)lResult );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE), (BOOL)lResult );
            _UpdateWizardButtons( );
        }
        break;

    case IDC_E_SERVER:
        if ( HIWORD(wParam) == EN_CHANGE ) {
            _UpdateWizardButtons( );
        }
        break;

    case IDC_B_SEARCH:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            HRESULT hr = _OnSearch( _hDlg );            
        }
        break;

    }


    RETURN(FALSE);
}

//
// _UpdateWizardButtons( )
//
HRESULT
THISCLASS::_UpdateWizardButtons( )
{
    TraceClsFunc( "_UpdateWizardButtons( )\n" );

    HRESULT hr = S_OK;

    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
    if ( lResult == BST_CHECKED ) {
        DWORD dw = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_SERVER ) );
        if ( !dw ) {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK );
        } else {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
        }
    }

    lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
    if ( lResult == BST_CHECKED ) {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
    }

    HRETURN(hr);
}


//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
                    WPARAM wParam,
                    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%08x, idFrom = 0x%08x, code = 0x%08x\n",
              lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );

    HRESULT hr;
    LRESULT lResult;
    switch ( lpnmhdr->code ) {
    case PSN_WIZNEXT:
        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult == BST_CHECKED ) {
            WCHAR szServerName[DNS_MAX_NAME_BUFFER_LENGTH];
            CWaitCursor *Wait;

            Wait = new CWaitCursor();

            if (!GetDlgItemText( _hDlg, IDC_E_SERVER, szServerName, ARRAYSIZE(szServerName) )) {
                hr = E_INVALIDARG;
            }  else {
                hr = _IsValidRISServer( szServerName );
            }

            if (Wait) {
                delete Wait;
                Wait = NULL;
            }

            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;
    case PSN_SETACTIVE:
        TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
        Assert( _pfActivatable );
        if ( !*_pfActivatable ) {
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, -1 );   // don't show
            RETURN(TRUE);
        }
        _UpdateWizardButtons( );
        break;

    case PSN_KILLACTIVE:
        TraceMsg( TF_WM, "PSN_KILLACTIVE\n" );
        break;
    }

    RETURN(FALSE);
}


HRESULT
THISCLASS::_IsValidRISServer(
                            IN LPCWSTR ServerName
                            )
/*++

Routine Description:

    Validates if the specified server name points to a valid RIS server.

Arguments:

    ServerName - name of the server to validate

Return Value:

    HRESULT indicating outcome.
    (S_OK indicates that the server is a valid RIS server).

--*/
{
    HRESULT hr = E_FAIL;
    int retVal;
    CHAR mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH +1];
    size_t len;
    PHOSTENT hent;
    WCHAR ServerShare[MAX_PATH];

    TraceClsFunc("_IsValidRISServer( )\n");

    Assert( wcslen(ServerName) <= DNS_MAX_NAME_BUFFER_LENGTH );

    //
    // Do a DNS Lookup of the server as a first check to ensure it's a 
    // valid name.
    //
    len =  wcstombs( mbszServerName, ServerName, ARRAYSIZE( mbszServerName ) );

    hent = NULL;

    if ( !len ) {
        goto e0;

    }

    hent = gethostbyname( mbszServerName );
    if (!hent) {
        goto e0;
    }

    //
    // OK, we know the server actually resolves to a computer name.  Let's search
    // for \\servername\reminst share.  If this succeeds, we assume the server
    // is a valid remote install server
    //

    if (_snwprintf( 
                ServerShare,
                MAX_PATH,
                L"\\\\%s\\reminst\\oschooser", 
                ServerName ) < 0 || 
        GetFileAttributes(ServerShare) == -1) {
        goto e0;
    }

    return(S_OK);

    e0:
    retVal = MessageBoxFromStrings(
                                  _hDlg, 
                                  IDS_PROBLEM_FINDING_SERVER_TITLE, 
                                  IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT, 
                                  MB_YESNO|MB_ICONWARNING );
    hr = (retVal == IDYES)?S_OK:E_ADS_BAD_PARAMETER;


    HRETURN(hr);
}


HRESULT
THISCLASS::_OnSearch(
                    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED(hr)) {
        goto Error;
    }

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                             | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                             | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;

    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
            (CLIPFORMAT)g_cfDsObjectNames,
            NULL,
            DVASPECT_CONTENT, 
            -1, 
            TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL};

        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDN( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVER, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

    Error:

    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings(
                             hDlg, 
                             IDS_PROBLEM_SEARCHING_TITLE, 
                             IDS_PROBLEM_SEARCHING_TEXT, 
                             MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\hostdlg.h ===
//
// Copyright 1997 - Microsoft

//
// HostDlg.H - Handles the IDD_HOST_SERVER_PAGE
//


#ifndef _HOSTDLG_H_
#define _HOSTDLG_H_


class CNewComputerExtensions; // fwd decl

// Definitions
LPVOID
CHostServerPage_CreateInstance( void );

// CHostServerPage
class
CHostServerPage:
    public ITab
{
private: // Members
    HWND  _hDlg;
    CNewComputerExtensions* _pNewComputerExtension;
    BOOL *       _pfActivatable;

private: // Methods
    CHostServerPage();
    ~CHostServerPage();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( VOID );
    HRESULT _IsValidRISServer( IN LPCWSTR ServerName );
    HRESULT _UpdateWizardButtons( VOID );
    static HRESULT _OnSearch( HWND hDlg );

public: // Methods
    friend LPVOID CHostServerPage_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                     LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );

    friend CNewComputerExtensions;
};

typedef CHostServerPage* LPCHostServerPage;

#endif // _HOSTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\imos.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _IMOS_H_
#define _IMOS_H_

// Definitions
LPVOID
CIntelliMirrorOSTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CIntelliMirrorOSTab
class
CIntelliMirrorOSTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to owner object

    BOOL    _fAdmin;
    LPWSTR  _pszDefault;        // default OS
    LPWSTR  _pszTimeout;        // timeout string

    // "Add Wizard" flags
    BOOL    _fAddSif:1;
    BOOL    _fNewImage:1;
    BOOL    _fRiPrep:1;

    HWND    _hNotify;           // DSA's notify object

private: // Methods
    CIntelliMirrorOSTab();
    ~CIntelliMirrorOSTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    BOOL    _InitDialog( HWND hDlg, LPARAM lParam );
    BOOL    _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnSelectionChanged( );

public: // Methods
    friend LPVOID CIntelliMirrorOSTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CIntelliMirrorOSTab* LPCIntelliMirrorOSTab;

#endif // _IMOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\imos.cpp ===
//
// Copyright 1997 - Microsoft

//
// IMOS.CPP - Handles the "IntelliMirror OS" IDD_PROP_INTELLIMIRROR_OS tab
//


#include "pch.h"

#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "imos.h"
#include "ccomputr.h"
#include "addwiz.h"
#include "sifprop.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CIntelliMirrorOSTab")
#define THISCLASS CIntelliMirrorOSTab
#define LPTHISCLASS LPCIntelliMirrorOSTab

#define NUM_COLUMNS				    4

DWORD aImosHelpMap[] = {
    IDC_L_OS, HIDC_L_OS,
    IDC_B_ADD, HIDC_B_ADD,
    IDC_B_REMOVE, HIDC_B_REMOVE,
    IDC_B_PROPERTIES, HIDC_B_PROPERTIES,
    IDC_B_REFRESH, HIDC_B_REFRESH,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CIntelliMirrorOSTab_CreateInstance( void )
{
    TraceFunc( "CIntelliMirrorOSTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
_hDlg(NULL),
_punkService(NULL),
_fAdmin(FALSE),
_pszDefault(NULL),
_pszTimeout(NULL),
_fAddSif(FALSE),
_fNewImage(FALSE),
_fRiPrep(FALSE),
_hNotify(NULL)
{
    TraceClsFunc( "CIntelliMirrorOSTab()\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CIntelliMirrorOSTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage,
                   LPARAM lParam,
                   LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_OS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage ) {
        if ( !lpfnAddPage( hpage, lParam ) ) {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

    Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                      LPARAM lParam,
                      LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    HRETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
                           LPWSTR pszAttribute,
                           LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
                          BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************


//
// _InitDialog( )
//
BOOL
THISCLASS::_InitDialog(
                      HWND hDlg,
                      LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;

    HRESULT hr = S_OK;
    HWND hwndList = GetDlgItem( hDlg, IDC_L_OS );

    LPUNKNOWN punk = NULL;
    IIntelliMirrorSAP * pimsap = NULL;
    IEnumIMSIFs * penum = NULL;
    LV_COLUMN lvC;
    INT iCount;
    WCHAR szText[ 64 ];
    UINT uColumnWidths[NUM_COLUMNS] = { 225, 75, 75, 75};

    if ( hDlg ) {
        _hDlg = hDlg;
    }

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->EnumIntelliMirrorOSes( ENUM_READ, &punk ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( punk->QueryInterface( IID_IEnumIMSIFs, (void**)&penum ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    punk->Release( );
    punk = NULL;

    ListView_DeleteAllItems( hwndList );

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ ) {
        INT i;

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidths[iCount];

        if (!LoadString( g_hInstance, IDS_OS_COLUMN1 + iCount, szText, ARRAYSIZE (szText)) ||
            -1 == ListView_InsertColumn ( hwndList, iCount, &lvC )) {
            hr = E_FAIL;
            goto Error;
        }
    }

    hr = PopulateListView( hwndList, penum );
    if (FAILED(hr)) {
        MessageBoxFromStrings( _hDlg,
                               IDS_COULDNOTCONTACTSERVER_CAPTION,
                               IDS_COULDNOTCONTACTSERVER_TEXT,
                               MB_OK | MB_ICONERROR );
    }

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
    }

    Cleanup:
    if ( penum )
        penum->Release( );
    if ( pimsap )
        pimsap->Release( );
    if ( punk )
        punk->Release( );

    EnableWindow( hwndList, _fAdmin );

    if (hr == S_OK) {
        return(TRUE);
    }
    if (hr == S_FALSE) {
        return(FALSE);
    }

    return(SUCCEEDED(THR(hr)));

Error:
    MessageBoxFromHResult( NULL, IDS_ERROR_OPENNINGGROUPOBJECT, hr );
    goto Cleanup;
}

//
// _OnSelectionChanged( )
//
HRESULT
THISCLASS::_OnSelectionChanged( )
{
    TraceClsFunc( "_OnSelectionChanged( )\n" );

    HRESULT hr = S_OK;
    UINT iItems = ListView_GetSelectedCount( GetDlgItem( _hDlg, IDC_L_OS ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_REMOVE ), !!iItems );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_PROPERTIES ), !!iItems );
    //EnableWindow( GetDlgItem( _hDlg, IDC_B_ADD ), !!iItems  );

    HRETURN( hr );
}

//
// _OnCommand( )
//
BOOL
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch ( LOWORD(wParam) ) {
    case IDC_B_PROPERTIES:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_OS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            if ( lvi.iItem != -1 ) {
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                Assert(lvi.lParam);
                hr = CSifProperties_CreateInstance( _hDlg, MAKEINTRESOURCE(IDD_SIF_PROP_IMAGES), (LPSIFINFO) lvi.lParam );
            }
        }
        break;

    case IDC_B_REFRESH:
        hr = S_OK;
        break;

    case IDC_B_REMOVE:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            UINT iResult;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_OS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            iResult = MessageBoxFromStrings( _hDlg, IDS_AREYOUSURE_CAPTION, IDS_DELETESIF_TEXT, MB_YESNO );
            if ( iResult == IDYES ) {
                if ( lvi.iItem != -1 ) {
                    LPSIFINFO psif;

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );

                    psif = (LPSIFINFO)lvi.lParam;

                    if ( !DeleteFile( psif->pszFilePath ) ) {
                        ::MessageBoxFromError( _hDlg, 0, GetLastError() );
                        hr = E_FAIL;
                    } else {
                        ListView_DeleteItem( hwndList, lvi.iItem );
                        hr = S_FALSE;
                    }
                }
            }
        }
        break;

    case IDC_B_ADD:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            hr = CAddWiz_CreateInstance( _hDlg, _punkService );
        }
        break;
    }

    if ( hr == S_OK ) {
        HWND hwndList = GetDlgItem(_hDlg, IDC_L_OS);
        IIntelliMirrorSAP * pimsap = NULL;
        hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
        if (hr == S_OK) {
            IEnumIMSIFs * penum = NULL;
            hr = THR( pimsap->EnumIntelliMirrorOSes( ENUM_READ, (LPUNKNOWN*)&penum ) );
            if ( hr == S_OK ) {
                hr = PopulateListView( hwndList, penum);
                penum->Release();
            }
            pimsap->Release();
        }

        // See if we still have a selection
        _OnSelectionChanged( );
    }

    if (hr == S_OK) {
        return(TRUE);
    }
    if (hr == S_FALSE) {
        return(FALSE);
    }

    return(SUCCEEDED(hr));
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
                    WPARAM wParam,
                    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch ( lpnmhdr->code ) {
    case PSN_APPLY:
        TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
        // Tell DSA that someone hit Apply
        SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, 0, 0 );
        SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
        RETURN(TRUE);

    case LVN_ITEMCHANGED:
        {
            _OnSelectionChanged( );
        }
        break;

    case LVN_DELETEALLITEMS:
        DebugMsg( "LVN_DELETEALLITEMS - Deleting all items.\n" );
        RETURN(FALSE);

    case LVN_DELETEITEM:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
            LPSIFINFO psif = (LPSIFINFO) pnmv->lParam;
            Assert( psif );

            if ( psif ) {
                if (psif->pszArchitecture) {
                    TraceFree( psif->pszArchitecture );
                }
                if (psif->pszDescription) {
                    TraceFree( psif->pszDescription );
                }
                if (psif->pszDirectory) {
                    TraceFree( psif->pszDirectory );
                }
                if (psif->pszFilePath) {
                    TraceFree( psif->pszFilePath );
                }
                if (psif->pszHelpText) {
                    TraceFree( psif->pszHelpText );
                }
                if (psif->pszImageType) {
                    TraceFree( psif->pszImageType );
                }
                if (psif->pszLanguage) {
                    TraceFree( psif->pszLanguage );
                }
                if (psif->pszVersion) {
                    TraceFree( psif->pszVersion );
                }
                if (psif->pszImageFile) {
                    TraceFree( psif->pszImageFile );
                }

                TraceFree( psif );
            }
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
                           HWND hDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG ) {
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc) {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg ) {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, "WM_COMMAND\n" );
            return pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aImosHelpMap );
            }
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aImosHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
                            HWND hwnd,
                            UINT uMsg,
                            LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
              hwnd, uMsg, ppsp );

    switch ( uMsg ) {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\itab.h ===
//
// Copyright 1997 - Microsoft

//
// ITAB.H - Generic property tab abstract class
//


#ifndef _ITAB_H_
#define _ITAB_H_

// ITab
class 
ITab
{
public: // Methods
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk ) PURE;
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                            LPARAM lParam, LPUNKNOWN punk ) PURE;
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult ) PURE;
    STDMETHOD(AllowActivation)( BOOL * pfAllow ) PURE;
};

typedef ITab* LPTAB;

#endif // _ITAB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\makefile.inc ===
$(O)\newclnts.obj: $(PROJECT_INC_PATH)\riname.h $(PROJECT_INC_PATH)\riname.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\mangdlg.h ===
//
// Copyright 1997 - Microsoft

//
// MangDlg.H - Handles the IDD_MANAGED_WIZARD_PAGE
//


#ifndef _MANGDLG_H_
#define _MANGDLG_H_

class CNewComputerExtensions; // fwd decl

// Definitions
LPVOID
CManagedPage_CreateInstance( void );

// CManagedPage
class
CManagedPage:
    public ITab
{
private: // Members
    HWND  _hDlg;
    CNewComputerExtensions* _pNewComputerExtension;
    LPWSTR       _pszGuid;
    BOOL *       _pfActivate;

private: // Methods
    CManagedPage();
    ~CManagedPage();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    static INT_PTR CALLBACK
        DupGuidDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _UpdateWizardButtons( );
    HRESULT _OnKillActive( );
    HRESULT _OnQuery( HWND hDlg );

public: // Methods
    friend LPVOID CManagedPage_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                     LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );

    friend CNewComputerExtensions;
};

typedef CManagedPage* LPCManagedPage;

#endif // _MANGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\mangdlg.cpp ===
//
// Copyright 1997 - Microsoft

//
// MangDlg.CPP - Handles the IDD_MANAGED_WIZARD_PAGE
//

#include "pch.h"
#include "mangdlg.h"
#include "utils.h"
#include "newcmptr.h"
#include "dpguidqy.h"
#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CManagedPage")
#define THISCLASS CManagedPage
#define LPTHISCLASS LPCManagedPage

DWORD aManagedHelpMap[] = {
    IDC_E_GUID, HIDC_E_GUID,
    IDC_C_MANAGED_PC, HIDC_C_MANAGED_PC,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CManagedPage_CreateInstance( void )
{
	TraceFunc( "CManagedPage_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr))
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _pNewComputerExtension(NULL),
    _pszGuid(NULL),
    _pfActivate(NULL)
{
    TraceClsFunc( "CManagedPage()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pNewComputerExtension );
    Assert( !_pszGuid );
    Assert( !_pfActivate );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CManagedPage()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    Assert( lpfnAddPage );
    if ( !lpfnAddPage )
        HRETURN(E_INVALIDARG);

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_MANAGED_WIZARD_PAGE);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    if ( !pszResult )
        HRETURN(E_POINTER);

    if ( !pszAttribute )
        HRETURN(E_INVALIDARG);

    HRESULT hr = E_INVALIDARG;
    LRESULT lResult;

    *pszResult = NULL;

    lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
    if ( lResult )
    {
        if ( _wcsicmp( pszAttribute, NETBOOTGUID ) == 0 )
        {
            HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
            DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;

            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwndGuid, *pszResult, dw );

            hr = S_OK;
        }

        if ( _wcsicmp( pszAttribute, L"Guid" ) == 0 )
        {
            HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
            DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;
            GUID Guid;
            LPWSTR pszTemp;

            pszTemp = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !pszTemp )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwndGuid, pszTemp, dw );

            hr = ValidateGuid( pszTemp, &Guid, NULL );
            Assert( hr == S_OK );

            TraceFree( pszTemp );

            LPWSTR pszPrettyString = PrettyPrintGuid( &Guid );
            if ( !pszPrettyString )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            *pszResult = pszPrettyString;
            hr = S_OK;
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN(hr);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    _pfActivate = pfAllow;

    HRETURN(S_OK);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aManagedHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aManagedHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    Assert( ppsp );
    LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        TraceMsg( TF_WM, "PSPCB_CREATE\n" );
        if ( S_OK == pcc->_OnPSPCB_Create( ) )
        {
            RETURN(TRUE);   // create it
        }
        break;

    case PSPCB_RELEASE:
        TraceMsg( TF_WM, "PSPCB_RELEASE\n" );
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    return S_OK;

}

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;

    Assert( _pNewComputerExtension );
    SetWindowText( GetParent( _hDlg ), _pNewComputerExtension->_pszWizTitle );
    SetDlgItemText( _hDlg, IDC_S_CREATEIN, _pNewComputerExtension->_pszContDisplayName );
    SendMessage( GetDlgItem( _hDlg, IDC_S_ICON ), STM_SETICON, (WPARAM) _pNewComputerExtension->_hIcon, 0 );
    
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_GUID), MAX_INPUT_GUID_STRING - 1 );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    switch ( LOWORD(wParam) )
    {
    case IDC_C_MANAGED_PC:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
            EnableWindow( GetDlgItem( _hDlg, IDC_E_GUID), (BOOL)lResult );
            EnableWindow( GetDlgItem( _hDlg, IDC_S_GUID), (BOOL)lResult );
            _UpdateWizardButtons( );
        }
        break;

    case IDC_E_GUID:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            _UpdateWizardButtons( );
        }
        break;
    }

    RETURN(FALSE);
}

//
// _UpdateWizardButtons( )
//
HRESULT
THISCLASS::_UpdateWizardButtons( )
{
    TraceClsFunc( "_UpdateWizardButtons( )\n" );

    HRESULT hr = S_OK;

    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
    if ( lResult == BST_CHECKED )
    {
        WCHAR szGuid[ MAX_INPUT_GUID_STRING ];
        if (!Edit_GetText( GetDlgItem( _hDlg, IDC_E_GUID ), szGuid, ARRAYSIZE(szGuid)) ||
            S_OK != (hr = ValidateGuid( szGuid, NULL, NULL ))) {
            if (hr == S_OK) {
                hr = E_INVALIDARG;
            }
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK );
        } else {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
        }
    }
    else
    {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
    }

    HRETURN(hr);
}


//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%08x, idFrom = 0x%08x, code = 0x%08x\n",
        lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );

    switch( lpnmhdr->code )
    {
    case PSN_SETACTIVE:
        TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
        Assert( _pfActivate );
        *_pfActivate = FALSE;
        _UpdateWizardButtons( );
        break;

    case PSN_WIZNEXT:
        TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
        {
            HRESULT hr = _OnKillActive( );
            if (FAILED(hr))
            {
                SetFocus( GetDlgItem( _hDlg, IDC_E_GUID ) );
                SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                RETURN(TRUE);
            }
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// _OnKillActive( )
//
HRESULT
THISCLASS::_OnKillActive( )
{
    TraceClsFunc( "_OnKillActive( )\n" );

    HRESULT hr;
    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );

    Assert( _pfActivate );
    *_pfActivate = ( lResult == BST_CHECKED );

    if ( *_pfActivate )
    {
        HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
        DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;
        GUID  Guid;

        Assert( !_pszGuid );
        _pszGuid = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
        if ( !_pszGuid )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        Edit_GetText( hwndGuid, _pszGuid, dw );

        hr = ValidateGuid( _pszGuid, &Guid, NULL );
        Assert( hr == S_OK );
        if (FAILED(hr)) {
            goto Error;
        }

        hr = CheckForDuplicateGuid( &Guid );
        if ( hr == S_FALSE )
        {
            INT i = (INT)DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_DUPLICATE_GUID), _hDlg, DupGuidDlgProc, (LPARAM) this );
            switch ( i )
            {
            case IDOK:
                hr = S_OK;      // ignore problem and continue
                break;

            case IDCANCEL:
                hr = E_FAIL;    // go back and change the GUID
                break;
#ifdef DEBUG
            default:
                AssertMsg( 0, "Invalid return value from DialogBox( )\n" );
                break;
#endif // debug
            }
        }
        else if ( FAILED( hr ) ) 
        {
            goto Error;
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( _pszGuid )
    {
        TraceFree( _pszGuid );
        _pszGuid = NULL;
    }

    HRETURN(hr);
Error:
    
    MessageBoxFromHResult( _hDlg, NULL, hr );
    goto Cleanup;
}

HRESULT
THISCLASS::_OnQuery(
    HWND hDlg )
{
    TraceClsFunc( "_OnQuery( )\n" );

    HRESULT hr;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    IPropertyBag * ppb = NULL;
    ICommonQuery * pCommonQuery = NULL;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED(hr)) {
        goto Error;
    }

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ppb = (IPropertyBag *) QueryPropertyBag_CreateInstance( );
    if ( !ppb )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    BSTR tmp = SysAllocString( _pszGuid );
    if (!tmp) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = tmp;
    hr = ppb->Write( L"ClientGuid", &var );
    if (FAILED(hr)) {
        goto Error;
    }
    
    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RIQueryForm;
    oqw.pFormParameters    = ppb;

    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, NULL /* don't need results */);

Error:
    VariantClear( &var );

    if ( ppb )
        ppb->Release( );

    if ( pCommonQuery )
        pCommonQuery->Release();

    HRETURN(hr);
}

//
// DupGuidDlgProc()
//
INT_PTR CALLBACK
THISCLASS::DupGuidDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("DupGuidDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));
        SetWindowLongPtr( hDlg, GWLP_USERDATA, (LPARAM) lParam );
    }

    switch ( uMsg )
    {
    case WM_COMMAND:
        TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
        switch( LOWORD(wParam) )
        {
        case IDOK:
        case IDCANCEL:
            EndDialog( hDlg, LOWORD(wParam) );
            break;

        case IDC_B_QUERY:
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                if (pcc)
                {
                    pcc->_OnQuery( NULL );
                }
            }
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\newcmptr.h ===
//
// Copyright 1997 - Microsoft

//
// NEWCMPTR.H - The "New Computer" wizard extensions for Remote Installation Services
//


#ifndef _NEWCMPTR_H_
#define _NEWCMPTR_H_

#include "mangdlg.h"
#include "hostdlg.h"

// QITable
BEGIN_QITABLE( CNewComputerExtensions )
DEFINE_QI( IID_IDsAdminNewObjExt, IDsAdminNewObjExt, 6 )
END_QITABLE

// Definitions
LPVOID
CNewComputerExtensions_CreateInstance( void );

// CNewComputerExtensions
class CNewComputerExtensions
    : public IDsAdminNewObjExt
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CNewComputerExtensions );

    IADsContainer*      _padsContainerObj;
    LPCManagedPage      _pManagedDialog;
    LPCHostServerPage   _pHostServerDialog;
    IADs *              _pads;
    BOOL                _fActivatePages;

    // display info for pages
    LPWSTR       _pszWizTitle;
    LPWSTR       _pszContDisplayName;
    HICON        _hIcon;

private: // methods
    CNewComputerExtensions( );
    ~CNewComputerExtensions( );
    HRESULT
        Init( void );

public: // methods
    friend LPVOID
        CNewComputerExtensions_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IDsAdminNewObjExt methods
    STDMETHOD(Initialize)( IADsContainer* pADsContainerObj, 
                           IADs* pADsCopySource,
                           LPCWSTR lpszClassName,
                           IDsAdminNewObj* pDsAdminNewObj,
                           LPDSA_NEWOBJ_DISPINFO pDispInfo);
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, 
                         LPARAM lParam);
    STDMETHOD(SetObject)( IADs* pADsObj);
    STDMETHOD(WriteData)( HWND hWnd, 
                          ULONG uContext);
    STDMETHOD(OnError)( HWND hWnd,
                        HRESULT hr,
                        ULONG uContext);
    STDMETHOD(GetSummaryInfo)( BSTR* pBstrText);

    friend class CManagedPage;
    friend class CHostServerPage;

};

typedef CNewComputerExtensions * LPCNewComputerExtensions;


#endif // _NEWCMPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\newcmptr.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// NEWCMPTR.CPP - The "New Client" dialog box
//

#include "pch.h"

#include "newcmptr.h"
#include "mangdlg.h"
#include "ccomputr.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CNewComputerExtensions")
#define THISCLASS CNewComputerExtensions
#define LPTHISCLASS LPCNewComputerExtensions

//
// CNewComputerExtensions_CreateInstance( )
//
LPVOID
CNewComputerExtensions_CreateInstance( void )
{
    TraceFunc( "CNewComputerExtensions_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
_padsContainerObj(NULL),
_pManagedDialog(NULL),
_pHostServerDialog(NULL),
_pads(NULL),
_fActivatePages(FALSE),
_pszWizTitle(NULL),
_pszContDisplayName(NULL),
_hIcon(NULL)
{
    TraceClsFunc( "CNewComputerExtensions( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CNewComputerExtensions, IDsAdminNewObjExt );
    QITABLE_IMP( IDsAdminNewObjExt );
    END_QITABLE_IMP( CNewComputerExtensions );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    Assert( !_padsContainerObj );
    Assert( !_pManagedDialog );
    Assert( !_pHostServerDialog );

    Assert( !_pszWizTitle );
    Assert( !_pszContDisplayName );
    Assert( !_hIcon );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CNewComputerExtensions( )\n" );

    if ( _padsContainerObj )
        _padsContainerObj->Release( );

    if ( _pszWizTitle )
        TraceFree( _pszWizTitle );

    if ( _pszContDisplayName )
        TraceFree( _pszContDisplayName );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
                         REFIID riid, 
                         LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IDsAdminNewObjExt
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(IADsContainer* pADsContainerObj, 
                      IADs* pADsCopySource,
                      LPCWSTR lpszClassName,
                      IDsAdminNewObj* pDsAdminNewObj,
                      LPDSA_NEWOBJ_DISPINFO pDispInfo)
{
    TraceClsFunc( "[IDsAdminNewObjExt] Initialize(" );
    TraceMsg( TF_FUNC, " pADsContainerObj = 0x%08x, lpszClassName = '%s', pDispInfo = 0x%08x )\n",
              pADsContainerObj, lpszClassName, pDispInfo );

    UNREFERENCED_PARAMETER(pADsCopySource);

    if ( !pADsContainerObj || !pDispInfo || !lpszClassName ) {
        HRETURN(E_POINTER);
    }

    if ( pDispInfo->dwSize != sizeof(*pDispInfo) ) {
        HRETURN(E_INVALIDARG);
    }

    if ( _wcsicmp( lpszClassName, COMPUTER_CLASS_NAME ) !=0 )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;

    _padsContainerObj = pADsContainerObj;
    _padsContainerObj->AddRef( );

    // deep copy DSA_NEWOBJ_DISPINFO
    _pszWizTitle = (LPWSTR) TraceStrDup( pDispInfo->lpszWizTitle );
    _pszContDisplayName = (LPWSTR) TraceStrDup( pDispInfo->lpszContDisplayName );
    _hIcon = pDispInfo->hObjClassIcon;
    if (!_pszWizTitle || !_pszContDisplayName) {
        hr = E_OUTOFMEMORY;
    }
    HRETURN(hr);
}

//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage, 
                   LPARAM lParam)
{
    TraceClsFunc( "[IDsAdminNewObjExt] AddPages(" );
    TraceMsg( TF_FUNC, " lpfnAddPage = 0x%08x, lParam = 0x%08x )\n", lpfnAddPage, lParam );

    HRESULT hr;

    hr = THR( ::AddPagesEx( (ITab**)&_pManagedDialog, 
                            CManagedPage_CreateInstance, 
                            lpfnAddPage, 
                            lParam,
                            (LPUNKNOWN) NULL ) );
    if (FAILED( hr ))
        goto Error;

    _pManagedDialog->_pNewComputerExtension = this;
    _pManagedDialog->AllowActivation( &_fActivatePages );

    hr = THR( ::AddPagesEx( (ITab**)&_pHostServerDialog, 
                            CHostServerPage_CreateInstance, 
                            lpfnAddPage, 
                            lParam,
                            (LPUNKNOWN) NULL ) );
    if (FAILED( hr ))
        goto Error;

    _pHostServerDialog->_pNewComputerExtension = this;
    _pHostServerDialog->AllowActivation( &_fActivatePages );


    Error:
    HRETURN(hr);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::SetObject(
                    IADs* pADsObj)
{
    TraceClsFunc( "[IDsAdminNewObjExt] SetObject(" );
    TraceMsg( TF_FUNC, " pADsObj = 0x%08x )\n", pADsObj );

    if ( !pADsObj )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;

    _pads = pADsObj;
    _pads->AddRef( );

    HRETURN(hr);
}


//
// WriteData( )
//
STDMETHODIMP
THISCLASS::WriteData(
                    HWND hWnd,
                    ULONG uContext)
{
    TraceClsFunc( "[IDsAdminNewObjExt] WriteData(" );
    TraceMsg( TF_FUNC, " hWnd = 0x%08x, uContext = %d )\n", hWnd, uContext );

    HRESULT hr = S_OK;
    LPWSTR  pszGuid = NULL;
    LPWSTR  pszServer = NULL;
    LPCOMPUTER lpc = NULL;

    //
    // we should set our data during PRECOMMIT, so that the data
    // get's set during the initial SetCommit().  This way we never have
    // to actually commit the data ourselves.
    //
    if ( uContext != DSA_NEWOBJ_CTX_PRECOMMIT ) {
        goto Cleanup;
    }

    lpc = (LPCOMPUTER) CreateIntelliMirrorClientComputer( _pads );
    if ( !lpc )
        goto Error;

    hr = THR( _pManagedDialog->QueryInformation( NETBOOTGUID, &pszGuid ) );
    if (FAILED( hr )) {
        goto Error;
    }

    if ( pszGuid && pszGuid[0] ) {
        hr = THR( lpc->SetGUID( pszGuid ) );
        if (FAILED( hr ))
            goto Error;
    }

    hr = THR( _pHostServerDialog->QueryInformation( NETBOOTSERVER, &pszServer ) );
    if (FAILED( hr ))
        goto Error;

    if ( pszServer && pszServer[0] ) {
        hr = THR( lpc->SetServerName( pszServer ) );
        if (FAILED( hr ))
            goto Error;
    }

    Assert( hr == S_OK );

    Cleanup:
    if ( pszGuid ){
        TraceFree( pszGuid );
    }
    if ( pszServer ){
        TraceFree( pszServer );
    }
    if ( lpc ) {
        lpc->Release( );
    }

    HRETURN(hr);
    
Error:
    MessageBoxFromHResult( NULL, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    goto Cleanup;

}

//
// OnError( )
//
STDMETHODIMP
THISCLASS::OnError(
                  HWND hWnd, 
                  HRESULT hr,
                  ULONG uContext)
{
    TraceClsFunc( "[IDsAdminNewObjExt] OnError(" );
    TraceMsg( TF_FUNC, " hWnd = 0x%08x, uContext = %d )\n", hWnd, uContext );

    HRESULT hrRet = E_NOTIMPL;

    HRETURN(hrRet);
}

//
// GetSummaryInfo( )
//
STDMETHODIMP
THISCLASS::GetSummaryInfo(
                         BSTR* pBstrText)
{
    TraceClsFunc( "[IDsAdminNewObjExt] GetSummaryInfo( ... )\n" );

    if ( !pBstrText )
        HRETURN(E_POINTER);

    HRESULT hr;
    DWORD   dw;
    WCHAR   szManagedPC[ 256 ];
    LPWSTR  pszGuid = NULL;
    LPWSTR  pszServer = NULL;
    LPWSTR  pszOut = NULL;

    *pBstrText = NULL;

    hr = _pManagedDialog->QueryInformation( L"Guid", &pszGuid );
    
    if (FAILED(hr) ||pszGuid == NULL) {
        goto Cleanup;
    }

    dw = LoadString( g_hInstance, IDS_MANAGED_PC, szManagedPC, ARRAYSIZE(szManagedPC) );
    Assert( dw );
    if (!dw) {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( _pHostServerDialog->QueryInformation( L"Server", &pszServer ) );
    if ( FAILED(hr) ) {
        goto Cleanup;
    }

    // Make a buffer
    dw += wcslen( pszGuid ) + 1;
    if ( pszServer ) {
        dw += wcslen( pszServer ) + 1;
    }

    if (!(pszOut = (LPWSTR) TraceAllocString( LMEM_FIXED, dw )) ||
          _snwprintf(
              pszOut, 
              dw, 
              szManagedPC, 
              pszGuid, 
              pszServer) < 0 ) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *pBstrText = SysAllocString( pszOut );
    if ( !*pBstrText ) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

    Cleanup:
    if ( pszOut )
        TraceFree( pszOut );

    if ( pszServer )
        TraceFree( pszServer );

    if ( pszGuid )
        TraceFree( pszGuid );

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\pch.h ===
//
// Copyright 1997 - Microsoft
//

//
// PCH.H - Precompiled header
//

#if DBG==1
#define DEBUG
#endif // DBG==1

#ifdef DEBUG
// Turn these on for Interface Tracking
#define NO_TRACE_INTERFACES
// #define NOISY_QI
#endif


#define INLINE_HRESULT_FROM_WIN32
//
// Global includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <comutil.h>
#include <stdio.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <windowsx.h>
#include <activeds.h>
#include <dsclient.h>
#include <prsht.h>
#include <mmc.h>
#include <ntdsapi.h>
#include <remboot.h>
#include <dsquery.h>
#include <cmnquery.h>
#include <dns.h>
#include <dspropp.h>

#include <dsadmin.h>

#include "dll.h"
#include "guids.h"
#include "resource.h"
#include "resource.hm"
#include "cfactory.h"
#include "itab.h"
#include "utils.h"

//
// Global Defines
//
#define OSCHOOSER_SIF_SECTION           L"OSChooser"
#define OSCHOOSER_DESCRIPTION_ENTRY     L"Description"
#define OSCHOOSER_HELPTEXT_ENTRY        L"Help"
#define OSCHOOSER_VERSION_ENTRY         L"Version"
#define OSCHOOSER_IMAGETYPE_ENTRY       L"ImageType"
#define OSCHOOSER_IMAGETYPE_FLAT        L"Flat"
#define OSCHOOSER_LAUNCHFILE_ENTRY      L"LaunchFile"

// object attributes
#define NETBOOTALLOWNEWCLIENTS          L"netbootAllowNewClients"
#define NETBOOTLIMITCLIENTS             L"netbootLimitClients"
#define NETBOOTMAXCLIENTS               L"netbootMaxClients"
#define NETBOOTCURRENTCLIENTCOUNT       L"netbootCurrentClientCount"
#define NETBOOTANSWERREQUESTS           L"netbootAnswerRequests"
#define NETBOOTANSWERONLYVALIDCLIENTS   L"netbootAnswerOnlyValidClients"
#define NETBOOTNEWMACHINENAMINGPOLICY   L"netbootNewMachineNamingPolicy"
#define NETBOOTNEWMACHINEOU             L"netbootNewMachineOU"
#define NETBOOTINTELLIMIRROROSES        L"netbootIntelliMirrorOSes"
#define NETBOOTTOOLS                    L"netbootTools"
#define NETBOOTGUID                     L"netbootGUID"
#define NETBOOTMACHINEFILEPATH          L"netbootMachineFilepath"
#define NETBOOTINITIALIZATION           L"netbootInitialization"
#define NETBOOTSAP                      L"netbootSCPBL"
#define NETBOOTSERVER                   L"netbootServer"
#define SAMNAME                         L"sAMAccountName"
#define DISTINGUISHEDNAME               L"distinguishedName"
#define DS_CN                           L"cn"

// DS class names
#define DSCOMPUTERCLASSNAME             L"computer"
#define DSGROUPCLASSNAME                L"intelliMirrorGroup"
#define DSIMSAPCLASSNAME                L"intellimirrorSCP"

// path strings
#define SLASH_TEMPLATES                 L"\\" REMOTE_INSTALL_TEMPLATES_DIR_W
#define SLASH_SETUP                     L"\\" REMOTE_INSTALL_SETUP_DIR_W
#define SLASH_IMAGES                    L"\\" REMOTE_INSTALL_IMAGE_DIR_W
#define REMINST_SHARE                   REMOTE_INSTALL_SHARE_NAME_W

// misc
#define STRING_ADMIN                    L"admin"
#define BINL_SERVER_NAME                L"BINLSVC"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\newclnts.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _NEWCLNTS_H_
#define _NEWCLNTS_H_

// Definitions
LPVOID
CNewClientsTab_CreateInstance( void );
#define SAMPLES_LIST_SIZE 512

INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


class CComputer;
typedef CComputer* LPCComputer;

// CNewClientsTab
class
CNewClientsTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to service object

    BOOL   _fAdmin;             // admin mode == TRUE;
    BOOL   _fChanged:1;         // Are we dirty?
    INT    _iCustomId;          // custom ID in the ComboBox

    LPWSTR _pszCustomNamingPolicy; // last customized string
    LPWSTR _pszNewMachineOU;    // netbootNewMachineOU (DN)
    LPWSTR _pszServerDN;        // netbootServer (DN)

    WCHAR  _szSampleName[DNS_MAX_LABEL_BUFFER_LENGTH];   // generated sample machine name

    HWND   _hNotify;            // DSA notify obj

private: // Methods
    CNewClientsTab();
    ~CNewClientsTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _ApplyChanges( );
    HRESULT _UpdateSheet( LPWSTR pszNamingPolicy );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    HRESULT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _GetCurrentNamingPolicy( LPWSTR * ppszNamingPolicy );
    HRESULT _MakeOUPretty( DS_NAME_FORMAT inFlag, DS_NAME_FORMAT outFlag, LPWSTR *ppszOU );

public: // Methods
    friend LPVOID CNewClientsTab_CreateInstance( void );
    friend INT_PTR CALLBACK
        AdvancedDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CNewClientsTab* LPCNewClientsTab;

#endif // _NEWCLNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\newclnts.cpp ===
//
// Copyright 1997 - Microsoft

//
// NEWCLNT.CPP - Handle the "New Clients" IDD_PROP_NEW_CLIENTS property page
//


#include "pch.h"
#include <dnsapi.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include <wininet.h>
#include "newclnts.h"
#include "cservice.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CNewClientsTab")
#define THISCLASS CNewClientsTab
#define LPTHISCLASS LPCNewClientsTab

#define UNKNOWN_INVALID_TEMPLATE L"??"

#include <riname.h>
#include <riname.c>

DWORD aNewClientsHelpMap[] = {
    IDC_B_BROWSE, HIDC_B_BROWSE,
    IDC_E_NEWMACHINEOU, HIDC_E_NEWMACHINEOU,
    IDC_R_SPECIFICLOCATION, HIDC_R_SPECIFICLOCATION,
    IDC_R_SAMEASUSER, HIDC_R_SAMEASUSER,
    IDC_R_DOMAINDEFAULT, HIDC_R_DOMAINDEFAULT,
    IDC_G_CLIENTACCOUNTLOCATION, HIDC_G_CLIENTACCOUNTLOCATION,
    IDC_E_SAMPLE, HIDC_E_SAMPLE,
    IDC_CB_NAMINGPOLICY, HIDC_CB_NAMINGPOLICY,
    IDC_B_ADVANCED, HIDC_B_ADVANCED,
    IDC_G_NAMINGFORMAT, HIDC_G_NAMINGFORMAT,
    NULL, NULL
};

DWORD aAdvancedHelpMap[] = {
    IDC_E_FORMAT, HIDC_E_FORMAT,
    IDC_E_SAMPLE, HIDC_E_SAMPLE,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CNewClientsTab_CreateInstance( void )
{
        TraceFunc( "CNewClientsTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( FAILED(hr) )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _punkService(NULL),
    _fAdmin(FALSE),
    _fChanged(FALSE),
    _iCustomId(0),
    _pszCustomNamingPolicy(NULL),
    _pszNewMachineOU(NULL),
    _pszServerDN(NULL),
    _hNotify(NULL)
{
    TraceClsFunc( "CNewClientsTab()\n" );

    ZeroMemory(_szSampleName,DNS_MAX_LABEL_BUFFER_LENGTH *sizeof(WCHAR));

        InterlockIncrement( g_cObjects );

    TraceFuncExit();
}


//
// Scratch buffer used to load strings.
//
WCHAR   szSamples0[ SAMPLES_LIST_SIZE ];
WCHAR   szSamples1[ SAMPLES_LIST_SIZE ];
WCHAR   szSamples2[ SAMPLES_LIST_SIZE ];

//
// Init()
//
HRESULT __stdcall
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pszNewMachineOU );
    Assert( !_pszServerDN );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CNewClientsTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    if ( _pszServerDN )
        TraceFree( _pszServerDN );

    if ( _pszCustomNamingPolicy )
        TraceFree( _pszCustomNamingPolicy );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_NEW_CLIENTS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = E_FAIL;
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}


//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// GenerateSample( )
//

DWORD
GenerateSample(
    LPWSTR pszPolicy,
    LPWSTR pszSampleOut,
    LPDWORD maxLength )
{
    DWORD error;
    GENNAME_VARIABLES variables;

    TraceClsFunc( "GenerateSample( )\n" );

    if ( !pszPolicy )
        HRETURN(E_POINTER);

    variables.UserName = L"JOHNSMI";
    variables.FirstName = L"John";
    variables.LastName = L"Smith";
    variables.MacAddress = L"123456789012";
    variables.Counter = 123456789;
    variables.AllowCounterTruncation = TRUE;

    error = GenerateNameFromTemplate(
                pszPolicy,
                &variables,
                pszSampleOut,
                DNS_MAX_LABEL_BUFFER_LENGTH,
                NULL,
                NULL,
                maxLength
                );

    if ( error == GENNAME_TEMPLATE_INVALID ) {
        wcscpy( pszSampleOut, UNKNOWN_INVALID_TEMPLATE );
    }

    RETURN(error);
}

//
// _UpdateSheet()
//
HRESULT
THISCLASS::_UpdateSheet( LPWSTR pszNamingPolicy )
{
    TraceClsFunc( "_UpdateSheet( )\n" );

    HRESULT hr = S_FALSE;
    LPWSTR  pszNext;
    DWORD   dw;
    HWND    hwndCB = GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY );

    if (hwndCB == NULL) {
        RRETURN(GetLastError());
    }

    if ( pszNamingPolicy )
    {
        BOOL   fMatched = FALSE;
        INT    iCount;
        INT    iOldCount = ComboBox_GetCurSel( hwndCB );

        // Retrieve the combobox strings
        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples0, ARRAYSIZE( szSamples0 ) );
        Assert( dw );
        if (!dw) {
            HRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }

        iCount = 0;
        pszNext = szSamples0;
        while ( *pszNext )
        {
            LPWSTR pszFriendlyName = pszNext;

            // skip the friendly name
            pszNext =StrChr( pszNext, L';' );
            if ( !pszNext )
                break;
            *pszNext = L'\0'; // terminate
            pszNext++;

            LPWSTR pszCodedString = pszNext;

            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
                break;

            *pszNext = L'\0'; // teminate

            if ( pszNamingPolicy && StrCmpI( pszNamingPolicy, pszCodedString ) == 0 )
            {
                break;
            }

            iCount++;
            pszNext++;
        }

        if ( iOldCount != iCount )
        {
            ComboBox_SetCurSel( hwndCB, iCount );
            hr = S_OK;
        }
    }
    else
    {
        INT    iCount = ComboBox_GetCurSel( hwndCB );

        // Retrieve the combobox strings
        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples0, ARRAYSIZE( szSamples0 ) );
        Assert( dw );
        if (!dw) {
            HRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }

        pszNext = szSamples0;
        while ( *pszNext && iCount >= 0 )
        {
            LPWSTR pszFriendlyName = pszNext;

            // skip the friendly name
            pszNext =StrChr( pszNext, L';' );
            if ( !pszNext )
                break;
            *pszNext = L'\0'; // terminate
            pszNext++;

            pszNamingPolicy = pszNext;

            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
                break;

            *pszNext = L'\0'; // teminate

            iCount--;
            pszNext++;
        }
    }

    GenerateSample( pszNamingPolicy, _szSampleName, &dw );

    SetDlgItemText( _hDlg, IDC_E_SAMPLE, _szSampleName );

    RETURN(hr);
}


//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr;
    HRESULT hResult = S_OK;
    DWORD   dw;
    LPWSTR  pszNext;
    HWND    hwnd;
    LPWSTR  pszNewMachineOU = NULL;

    IIntelliMirrorSAP * pimsap = NULL;

    _hDlg = hDlg;

    dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples1, ARRAYSIZE( szSamples1 ) );
    Assert( dw );
    if (!dw) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;
    
    ADsPropSetHwnd( _hNotify, _hDlg );

    //
    // Populate Naming Policy ComboBox
    //
    hwnd = GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY );
    ComboBox_ResetContent( hwnd );

    _iCustomId = 0;
    pszNext = szSamples1;
    while ( *pszNext )
    {
        // add the friendly name to the combobox
        LPWSTR pszFriendlyName = pszNext;

        pszNext = StrChr( pszNext, L';' );
        if ( !pszNext )
            break;

        *pszNext = L'\0'; // terminate
        ComboBox_AddString( hwnd, pszFriendlyName );
        *pszNext = L';';  // restore

        // skip the formatted string
        pszNext++;
        pszNext = StrChr( pszNext, L';' );
        if ( !pszNext )
            break;

        pszNext++;
        _iCustomId++;
    }

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    Assert( SUCCEEDED(hr) || _fAdmin == FALSE );

    EnableWindow( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ),    _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_ADVANCED ),         _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDD_PROP_NEW_CLIENTS ),   _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), _fAdmin );

    hr = THR( pimsap->GetNewMachineNamingPolicy( &_pszCustomNamingPolicy ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !_pszCustomNamingPolicy );
    _UpdateSheet( _pszCustomNamingPolicy );

    hr = pimsap->GetNewMachineOU( &pszNewMachineOU );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !pszNewMachineOU );
    
    hr = THR( pimsap->GetServerDN( &_pszServerDN ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !_pszServerDN );

    if ( pszNewMachineOU )
    {
        if( StrCmp( pszNewMachineOU, _pszServerDN ) !=0 )
        {
            hr = _MakeOUPretty( DS_FQDN_1779_NAME, DS_CANONICAL_NAME, &pszNewMachineOU );
            BOOLEAN temp = _fChanged;
            _fChanged =TRUE;// Prevent early turning on of the Apply button.
            SetDlgItemText( _hDlg, IDC_E_NEWMACHINEOU, pszNewMachineOU );
            _fChanged = temp;

            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), _fAdmin );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), _fAdmin );

            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ),  BST_CHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),     BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),        BST_UNCHECKED );
        }
        else
        {
            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );

            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    BST_CHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       BST_UNCHECKED );
        }
    }
    else
    {
        EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
        EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );

        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), BST_UNCHECKED );
        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    BST_UNCHECKED );
        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       BST_CHECKED );
    }

    if ( hResult != S_OK )
    {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hResult );
    }

Cleanup:
    if ( pszNewMachineOU )
        TraceFree( pszNewMachineOU );
    if ( pimsap )
        pimsap->Release( );
    HRETURN(hr);

Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}


PCWSTR
GetDCNameForServer(
    PCWSTR InputPath
    )
/*++

Routine Description:

    Given a server name, we retrive the name of a DC for that server's domain.
    We create an LDAP path of the form LDAP://DNSNAMEOFDC/DNOFDOMAIN.        

Arguments:

    ServerName - name of the server to validate

Return Value:

    String indicating DC name.  Must be freed via TraceFree().

--*/
{
    PWSTR FQDN = NULL,p,DCName = NULL,DomainDN = NULL;
    HRESULT hr;
    HANDLE hDC;
    DOMAIN_CONTROLLER_INFO *DomainControllerInfo;
    
    hr = DNtoFQDN( (LPWSTR)InputPath, &FQDN);
    if (!SUCCEEDED(hr)) {
        goto Exit;
    }

    hr = GetDomainDN( (LPWSTR)InputPath, &DomainDN);
    if (!SUCCEEDED(hr)) {
        goto Exit;
    }

    p = StrStrI(FQDN,L".");
    if (!p) {
        goto Exit;
    }
    p += 1;

    if (ERROR_SUCCESS == DsGetDcName(
                            NULL,
                            p,
                            NULL,
                            NULL,
                            DS_IS_DNS_NAME | DS_RETURN_DNS_NAME,
                            &DomainControllerInfo
                            )) {    
        //
        // want a string of form:
        //
        // LDAP://DNSNAMEOFDC/DNOFDOMAIN
        //
        DCName = TraceAllocString(
                            LMEM_FIXED, 
                            sizeof(L"LDAP://") + 
                            (wcslen(DomainControllerInfo->DomainControllerName)-2)*sizeof(WCHAR) +
                            sizeof(L"/") +
                            wcslen(DomainDN)*sizeof(WCHAR) +
                            1 * sizeof (WCHAR)
                            );
        if (DCName) {
            wcscpy(DCName,L"LDAP://");
            //
            // skip the \\ in front of the DC name
            //
            wcscat(DCName,&DomainControllerInfo->DomainControllerName[2]);
            wcscat(DCName,L"/");
            wcscat(DCName,DomainDN);                    
        } 

        NetApiBufferFree(DomainControllerInfo);
    }

Exit:
    if (FQDN) {
        TraceFree( FQDN );
    }
    if (DomainDN) {
        TraceFree( DomainDN );
    }
    return(DCName);

}


//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    BOOL fReturn = TRUE;
    BOOL fChanged = FALSE;
    HWND    hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDC_B_ADVANCED:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            LPWSTR  pszNamingPolicy = _pszCustomNamingPolicy;
            HRESULT hr = _GetCurrentNamingPolicy( &_pszCustomNamingPolicy );
            if ( hr != S_FALSE )
            {
                TraceFree( pszNamingPolicy );
            }
            UINT i = (UINT) DialogBoxParam( g_hInstance, 
                                            MAKEINTRESOURCE( IDD_ADVANCEDNAMIMG), 
                                            _hDlg, 
                                            AdvancedDlgProc,
                                            (LPARAM) this );
            hr = _UpdateSheet( _pszCustomNamingPolicy );
            if ( i == IDOK )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_CB_NAMINGPOLICY:
        if ( HIWORD( wParam ) == CBN_SELCHANGE )
        {
            INT iSelection = ComboBox_GetCurSel( hwndCtl );
            if ( iSelection == _iCustomId )
            {
                UINT i = (UINT) DialogBoxParam( g_hInstance, 
                                                MAKEINTRESOURCE( IDD_ADVANCEDNAMIMG), 
                                                _hDlg, 
                                                AdvancedDlgProc,
                                                (LPARAM) this );
                HRESULT hr = _UpdateSheet( _pszCustomNamingPolicy );
                if ( i == IDOK )
                {
                    fChanged = TRUE;
                }
            }
            else
            {
                _UpdateSheet( NULL );
                fChanged = TRUE;
            }
        }
        break;

    case IDC_R_SPECIFICLOCATION:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            HWND hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
            EnableWindow( hwnd, _fAdmin );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), _fAdmin );

            if ( GetWindowTextLength( hwnd ) != 0 )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_E_NEWMACHINEOU:
        if ( HIWORD( wParam ) == EN_CHANGE )
        {
            HWND hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
            if ( GetWindowTextLength( hwnd ) != 0 )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_R_SAMEASUSER:
    case IDC_R_DOMAINDEFAULT:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );
            fChanged = TRUE;
        }
        break;

    case IDC_B_BROWSE:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            DSBROWSEINFO info;
            WCHAR szCaption[ 64 ];
            WCHAR szTitle[ 64 ];
            WCHAR szPath[ INTERNET_MAX_URL_LENGTH ];
            DWORD dw;

            szCaption[0] = L'\0';
            dw = LoadString( g_hInstance, IDS_BROWSEFOROU_CAPTION, szCaption, ARRAYSIZE( szCaption ) );
            Assert( dw );

            szTitle[0] = L'\0';
            dw = LoadString( g_hInstance, IDS_BROWSEFOROU_TITLE, szTitle, ARRAYSIZE( szTitle ) );
            Assert( dw );

            ZeroMemory( &info, sizeof(info) );
            info.cbStruct   = sizeof(info);
            info.hwndOwner  = _hDlg;
            info.pszRoot    = GetDCNameForServer(_pszServerDN);
            info.pszCaption = szCaption;
            info.pszTitle   = szTitle;
            info.pszPath    = szPath;
            info.cchPath    = ARRAYSIZE(szPath);
            info.dwFlags    = DSBI_ENTIREDIRECTORY;

            if ( IDOK == DsBrowseForContainer( &info ) )
            {
                // Skip the "LDAP://" part
                HRESULT hr = E_FAIL;
                LPWSTR pszOU = NULL;
                if (wcslen(szPath) < 8 ||
                    !(pszOU = TraceStrDup( &szPath[7] ))) {
                    // bail out, neither condition is valid.
                    fChanged = FALSE;
                    if (info.pszRoot) {
                        TraceFree( (HGLOBAL)info.pszRoot );
                    }
                    RRETURN(E_FAIL);
                }
                if ( pszOU )
                {
                    hr = _MakeOUPretty( DS_FQDN_1779_NAME, DS_CANONICAL_NAME, &pszOU );
                    if (SUCCEEDED( hr ))
                    {
                        SetWindowText( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), pszOU );
                        fChanged = TRUE;
                    }
                    TraceFree( pszOU );
                }

                if (FAILED( hr ))
                {
                    SetWindowText( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), &szPath[7] );
                    fChanged = TRUE;
                }
            }

            if (info.pszRoot) {
                TraceFree( (HGLOBAL)info.pszRoot );
            }
        }
        break;
    }

    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;
            SendMessage( GetParent( _hDlg ), PSM_CHANGED, (WPARAM)_hDlg, 0 );
        }
    }

    if (fReturn) {
        RRETURN( S_OK );
    } 

    RRETURN( E_FAIL );
}


//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRETURN(S_OK); // nop

    HRESULT hr;
    HRESULT hResult = S_OK;
    LPWSTR  pszNamingPolicy = NULL;
    UINT    iItem;
    IIntelliMirrorSAP * pimsap = NULL;

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr ))
        goto Error;

    if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ) ) == BST_CHECKED )
    {
        HWND   hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
        ULONG  uLen = GetWindowTextLength( hwnd ) + 1;
        LPWSTR pszNewMachineOU = TraceAllocString( LMEM_FIXED, uLen );
        if ( pszNewMachineOU )
        {
            GetWindowText( hwnd, pszNewMachineOU, uLen );

            hr = _MakeOUPretty( DS_CANONICAL_NAME, DS_FQDN_1779_NAME, &pszNewMachineOU );
            if (SUCCEEDED( hr ))
            {            
                hr = THR( pimsap->SetNewMachineOU( pszNewMachineOU ) );
            }

            TraceFree( pszNewMachineOU );

            if (FAILED(hr) && hResult == S_OK )
            {
                hResult = hr;
                SetFocus( hwnd );
            }
        }
    }
    else if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ) ) == BST_CHECKED )
    {
        hr = THR( pimsap->SetNewMachineOU( _pszServerDN ) );
        if (FAILED(hr) && hResult == S_OK )
        {
            hResult = hr;
            SetFocus( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ) );
        }
    }
    else
    {
        hr = THR( pimsap->SetNewMachineOU( NULL ) );
        if (FAILED(hr) && hResult == S_OK )
        {
            hResult = hr;
            SetFocus( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ) );
        }
    }

    hr = _GetCurrentNamingPolicy( &pszNamingPolicy );
    if (FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
    }

    hr = THR( pimsap->SetNewMachineNamingPolicy( pszNamingPolicy ) );
    if (FAILED( hr ) && hResult == S_OK )
    {
        SetFocus( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ) );
        hResult = hr;
    }

    hr = THR( pimsap->CommitChanges( ) );
    if (FAILED( hr ))
        goto Error;

    if ( hResult != S_OK )
    {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hResult );
        hr = hResult;
    }
    else
    {
        _fChanged = FALSE;
    }

Cleanup:
    if ( pimsap )
        pimsap->Release( );
    if ( pszNamingPolicy )
        TraceFree( pszNamingPolicy );

    // Tell DSA that someone hit Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;
            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aNewClientsHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aNewClientsHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

// ************************************************************************
//
// Advanced Namimg Dialog Proc
//
// ************************************************************************


INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("AdvancedDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );
    WCHAR szFormat[ DNS_MAX_LABEL_BUFFER_LENGTH ];

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        pcc = (LPTHISCLASS) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, (LPARAM) pcc );

        Assert( pcc != NULL );

        HWND hwnd = GetDlgItem( hDlg, IDC_E_FORMAT );
        Edit_LimitText( hwnd, ARRAYSIZE(szFormat) - 1 );

        LPWSTR pszNamingPolicy = NULL;
        HRESULT hr = pcc->_GetCurrentNamingPolicy( &pszNamingPolicy );
        if (SUCCEEDED( hr )  && (hr != S_FALSE))
        {
            SetWindowText( hwnd, pszNamingPolicy );
            TraceFree( pszNamingPolicy );
        }
    }

    if (pcc)
    {
        switch ( uMsg )
        {
        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDCANCEL:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        EndDialog( hDlg, LOWORD( wParam ) );
                        return TRUE;
                    }
                    break;

                case IDOK:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        WCHAR szSample[ DNS_MAX_LABEL_BUFFER_LENGTH ];
                        DWORD maxLength;
                        DWORD nameError;

                        if (!GetDlgItemText( hDlg, IDC_E_FORMAT, szFormat, ARRAYSIZE(szFormat) )) {
                            nameError = GENNAME_TEMPLATE_INVALID;
                        } else {
                            nameError = GenerateSample( szFormat, szSample, &maxLength );
                            Assert( (nameError == GENNAME_NO_ERROR) ||
                                    (nameError == GENNAME_TEMPLATE_INVALID) ||
                                    (nameError == GENNAME_NAME_TOO_LONG) );
                        }

                        if ( nameError == GENNAME_TEMPLATE_INVALID )
                        {
                            MessageBoxFromStrings( hDlg,
                                                   IDS_ADVANCED_NAMING_RESTRICTIONS_TITLE,
                                                   IDS_ADVANCED_NAMING_RESTRICTIONS_TEXT,
                                                   MB_OK );
                            break;
                        }
                        else if ( nameError == GENNAME_NAME_TOO_LONG )
                        {
                            LRESULT lResult = MessageBoxFromStrings( hDlg,
                                                                     IDS_DNS_NAME_LENGTH_WARNING_TITLE,
                                                                     IDS_DNS_NAME_LENGTH_WARNING_TEXT,
                                                                     MB_YESNO );
                            if ( lResult == IDNO )
                                break;
                        }

                        pcc->_pszCustomNamingPolicy = (LPWSTR) TraceStrDup( szFormat );

                        EndDialog( hDlg, LOWORD( wParam ) );

                        return TRUE;
                    }
                    break;

                case IDC_E_FORMAT:
                    if ( HIWORD( wParam ) == EN_CHANGE )
                    {
                        WCHAR szSample[ DNS_MAX_LABEL_BUFFER_LENGTH ] = { L"" };
                        DWORD maxLength;
                        DWORD nameError;

                        if ( !GetDlgItemText( hDlg, IDC_E_FORMAT, szFormat, ARRAYSIZE(szFormat) ) )
                        {
                            nameError = GENNAME_TEMPLATE_INVALID;
                        }
                        else
                        {
                            nameError = GenerateSample( szFormat, szSample, &maxLength );

                            Assert( (nameError == GENNAME_NO_ERROR) ||
                                    (nameError == GENNAME_TEMPLATE_INVALID) ||
                                    (nameError == GENNAME_NAME_TOO_LONG) );

                        }

                        if ( DnsValidateDnsName_W( szSample ) != NO_ERROR ) {
                            nameError = GENNAME_TEMPLATE_INVALID;
                            wcscpy( szSample, UNKNOWN_INVALID_TEMPLATE );
                        }

                        SetDlgItemText( hDlg, IDC_E_SAMPLE, szSample );
                        EnableWindow( GetDlgItem( hDlg, IDOK ),
                                      (BOOL)(nameError != GENNAME_TEMPLATE_INVALID) );
                    }
                    break;
                }
            }
            break; // WM_COMMAND

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aAdvancedHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aAdvancedHelpMap );
            break;
        }
    }

    return FALSE;
}

HRESULT
THISCLASS::_GetCurrentNamingPolicy( LPWSTR * ppszNamingPolicy )
{
    TraceClsFunc( "_GetCurrentNamingPolicy( )\n" );

    if ( !ppszNamingPolicy )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT iItem = ComboBox_GetCurSel( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ) );

    if ( iItem == - 1 )
    {
        *ppszNamingPolicy = NULL;
        HRETURN(S_FALSE);
    }
    else if ( iItem == _iCustomId && _pszCustomNamingPolicy )
    {
        if ( *ppszNamingPolicy == _pszCustomNamingPolicy )
            HRETURN(S_FALSE);

        *ppszNamingPolicy = TraceStrDup( _pszCustomNamingPolicy );
        if (!*ppszNamingPolicy) {
            HRETURN(E_OUTOFMEMORY);
        }
    }
    else if ( iItem != _iCustomId )
    {
        LPWSTR  pszFormat = NULL;
        LPWSTR  pszNext = szSamples2;
        DWORD   dw;

        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples2, ARRAYSIZE( szSamples2 ) );
        Assert( dw );
        if (!dw) {
            HRETURN(E_OUTOFMEMORY);
        }

        for( ; *pszNext && iItem >= 0; iItem-- )
        {
            // find the end of the friendly name which is terminated by a ';'
            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
            {
                pszFormat = NULL;
                break;
            }

            pszNext++;

            pszFormat = pszNext;

            // skip the internal string
            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
            {
                pszFormat = NULL;
                break;
            }

            // next string please...
            pszNext++;
        }
        Assert( pszFormat );

        pszNext = StrChr( pszFormat, L';' );
        Assert( pszNext );
        *pszNext = L'\0';

        *ppszNamingPolicy = TraceStrDup( pszFormat );
    }

    if ( !*ppszNamingPolicy )
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN(hr);
}

typedef enum {
    MOUP_SYNTACTICAL,
    MOUP_LOCAL_DC,
    MOUP_OTHER_DC,
    MOUP_GC
} CRACK_TYPE;

HRESULT
THISCLASS::_MakeOUPretty( 
    DS_NAME_FORMAT inFlag, 
    DS_NAME_FORMAT outFlag, 
    LPWSTR *ppszOU )
{
    TraceClsFunc("_MakeOUPretty()\n");
    Assert( ppszOU );

    HRESULT hr;
    PDS_NAME_RESULT pResults;
    DWORD dw;
    HANDLE hDS;
    CRACK_TYPE crackType;

    //
    // We might need to call DsCrackNames up to four times. The logic goes like this:
    //
    //  Call DsCrackNames to attempt a local-only syntactical mapping.
    //  If that fails with DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING,
    //      Try the local DC.
    //      If can't find the local DC,
    //          Try the GC.
    //      Else if local DC failed with DS_NAME_ERROR_DOMAIN_ONLY,
    //          Try the DC pointed to by the local DC.
    //          If can't find the other DC,
    //              Try the GC.
    //

    crackType = MOUP_SYNTACTICAL;
    hDS = NULL;
    pResults = NULL;

    while ( TRUE ) {

        //
        // If we have a bind handle left over from the previous pass, unbind it now.
        //

        if ( hDS != NULL ) {
            DsUnBind( &hDS );
            hDS = NULL;
        }

        //
        // Bind to the DC or GC.
        //

        if ( crackType == MOUP_SYNTACTICAL ) {

            hDS = NULL;

        } else if ( crackType == MOUP_LOCAL_DC ) {

            //
            // Find a local DC.
            //

            PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

            dw = DsGetDcName(
                    NULL,
                    NULL,
                    NULL,
                    NULL, 
                    DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED,
                    &pDCInfo
                    );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't find a DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

            Assert( pDCInfo != NULL );

            dw = DsBind( pDCInfo->DomainControllerName, NULL, &hDS );

            NetApiBufferFree( pDCInfo );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

        } else if ( crackType == MOUP_OTHER_DC ) {

            //
            // We need to talk to the DC that the local DC referred us to.
            //

            dw = DsBind( NULL, pResults->rItems[0].pDomain, &hDS );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

        } else {

            //
            // Bind to the GC.
            //

            dw = DsBind( NULL, NULL, &hDS );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;
            }
        }

        //
        // If we have pResults left over from a previous call, free it now.
        //

        if ( pResults != NULL ) {
            DsFreeNameResult( pResults );
            pResults = NULL;
        }

        //
        // Try to crack the name.
        //

        dw = DsCrackNames( hDS,
                           (crackType == MOUP_SYNTACTICAL) ?
                                DS_NAME_FLAG_SYNTACTICAL_ONLY : DS_NAME_NO_FLAGS,
                           inFlag,
                           outFlag,
                           1,
                           ppszOU,
                           &pResults );
    
        if ( dw != NO_ERROR ) {

            if ( crackType == MOUP_SYNTACTICAL ) {
            
                //
                // We were doing a syntactical check. We don't expect this to fail.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;

            } else if ( crackType == MOUP_LOCAL_DC ) {

                //
                // We had trouble getting to the local DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;


            } else if ( crackType == MOUP_OTHER_DC ) {

                //
                // We had trouble getting to the other DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;


            } else {

                //
                // We had trouble getting to the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;
            }

        } else {
        
            Assert( pResults != NULL );
            Assert( pResults->cItems == 1 );

            if ( pResults->rItems[0].status == DS_NAME_NO_ERROR ) {

                //
                // We've got what we wanted.
                //

                hr = S_OK;
                break;
            }

            if ( crackType == MOUP_SYNTACTICAL ) {
            
                if ( pResults->rItems[0].status != DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING ) {

                    //
                    // Unexpected error. Give up.
                    //

                    hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                    break;
                }

                //
                // Try the local DC next.
                //

                crackType = MOUP_LOCAL_DC;
                continue;

            } else if ( crackType == MOUP_LOCAL_DC ) {

                if ( pResults->rItems[0].status != DS_NAME_ERROR_DOMAIN_ONLY ) {

                    //
                    // Unexpected error. Give up.
                    //

                    hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                    break;
                }

                //
                // Try the other DC next.
                //

                crackType = MOUP_OTHER_DC;
                continue;

            } else if ( crackType == MOUP_OTHER_DC ) {

                //
                // Unexpected error. Give up.
                //

                hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                break;

            } else {

                //
                // Couldn't get what we need from the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                break;
            }
        }
    }

    if ( hr == S_OK ) {

        Assert( pResults != NULL );
        Assert( pResults->cItems == 1 );
        Assert( pResults->rItems[0].status == DS_NAME_NO_ERROR );
        Assert( pResults->rItems[0].pName );

        LPWSTR psz = TraceStrDup( pResults->rItems[0].pName );
        if ( psz != NULL ) {
            if (*ppszOU) {
                TraceFree( *ppszOU );
                *ppszOU = NULL;
            }
            *ppszOU = psz;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( hDS != NULL ) {
        DsUnBind( &hDS );
    }
    if ( pResults != NULL ) {
        DsFreeNameResult( pResults );
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\qi.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// QI.CPP - Handles the QueryInterface
//

#include "pch.h"

//
// Begin Class Definitions
//
DEFINE_MODULE("IMADMUI")

//
// QueryInterface()
//
extern HRESULT
QueryInterface( 
    LPVOID    that,
    LPQITABLE pQI,
    REFIID    riid, 
    LPVOID*   ppv )
{
    TraceMsg( TF_FUNC, "[IUnknown] QueryInterface( riid=" );
    HRESULT hr = E_NOINTERFACE;

    Assert( ppv != NULL );
    *ppv = NULL;

    for( int i = 0; pQI[ i ].pvtbl; i++ )
    {
        if ( riid == *pQI[ i ].riid )
        {
#ifdef DEBUG
            TraceMsg( TF_FUNC, "%s, ppv=0x%08x )\n", pQI[i].pszName, ppv );
#endif // DEBUG
            *ppv = pQI[ i ].pvtbl;
            hr = S_OK;
            break;
        }
    }

    if ( hr == E_NOINTERFACE )
    {
        TraceMsgGUID( TF_FUNC, riid );
        TraceMsg( TF_FUNC, ", ppv=0x%08x )\n", ppv );
    }

    if ( SUCCEEDED( hr ) )
    {
        ( (IUnknown *) *ppv )->AddRef();
    }

    return hr;
}

///////////////////////////////////////
//
// NOISY_QI
//
#ifndef NOISY_QI

#undef TraceMsg
#define TraceMsg        1 ? (void)0 : (void) 
#undef TraceFunc     
#define TraceFunc       1 ? (void)0 : (void) 
#undef TraceClsFunc     
#define TraceClsFunc    1 ? (void)0 : (void) 
#undef TraceFuncExit
#define TraceFuncExit()
#undef HRETURN
#define HRETURN(_hr)    return(_hr)
#undef RETURN
#define RETURN(_fn)     return(_fn)  
#undef ErrorMsg
#define ErrorMsg        1 ? (void)0 : (void) 

#endif // NOISY_QI
//
// END NOISY_QI
//
///////////////////////////////////////

#ifndef NO_TRACE_INTERFACES
#ifdef DEBUG
///////////////////////////////////////
//
// BEGIN DEBUG
//

///////////////////////////////////////
//
// CITracker
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS LPITRACKER

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// Special new( ) for CITracker
//
#undef new
void* __cdecl operator new( unsigned int nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule, UINT nExtra )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize + nExtra, __THISCLASS__ );
}
#define new new( TEXT(__FILE__), __LINE__, __MODULE__, nExtra )

//
// CreateInstance()
//
LPVOID
CITracker_CreateInstance(
    LPQITABLE pQITable )
{
	TraceFunc( "CITracker_CreateInstance( " );
    TraceMsg( TF_FUNC, "pQITable = 0x%08x )\n", pQITable );

    if ( !pQITable )
    {
        THR( E_POINTER );
        RETURN(NULL);
    }

    HRESULT hr;

    // 
    // Add up the space needed for all the vtbls
    //
    for( int i = 1; pQITable[i].riid; i++ )
    {
        UINT nExtra = VTBL2OFFSET + (( 3 + pQITable[i].cFunctions ) * sizeof(LPVOID));

        // The "new" below is a macro that needs "nExtra" defined. (see above)
        LPTHISCLASS lpc = new THISCLASS( ); 
        if ( !lpc )
        {
            hr = THR(E_OUTOFMEMORY);
            goto Error;
        }

        hr = THR( lpc->Init( &pQITable[i] ) );
        if ( hr )
        {
            delete lpc;
            lpc = NULL;
            goto Error;
        }

    }

Error:
    RETURN(NULL);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "" );
    TraceMsg( TF_FUNC, "%s()\n", __THISCLASS__ );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

STDMETHODIMP
THISCLASS::Init(    
    LPQITABLE  pQITable )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init( " );
    TraceMsg( TF_FUNC, "pQITable = 0x%08x )\n", pQITable );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID *pthisVtbl = (LPVOID*) (IUnknown*) this;
    LPVOID *ppthatVtbl = (LPVOID*) pQITable->pvtbl;
    DWORD dwSize = ( 3 + pQITable->cFunctions ) * sizeof(LPVOID);

    // Interface tracking information initialization
    Assert( _vtbl.cRef == 0 );
    _vtbl.pszInterface = pQITable->pszName;

    // This is so we can get to our object's "this" pointer
    // after someone jumped to our IUnknown.
    _vtbl.pITracker = (LPUNKNOWN) this;

    // Copy the orginal vtbl.
    CopyMemory( &_vtbl.lpfnQueryInterface, *ppthatVtbl, dwSize );

    // Copy our IUnknown vtbl to the beginning 3 entries.
    CopyMemory( &_vtbl.lpfnQueryInterface, *pthisVtbl, 3 * sizeof(LPVOID) );

    // Remember the old vtbl so we can jump to the orginal objects
    // IUnknown functions.
    _vtbl.pOrginalVtbl = (LPVTBL) *ppthatVtbl;

    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    _vtbl.punk = (LPUNKNOWN) pQITable->pvtbl;

    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    *ppthatVtbl = &_vtbl.lpfnQueryInterface;

    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, 
                  L"Tracking %s Interface...\n", _vtbl.pszInterface );

    HRETURN(hr);
}



//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "" );
    TraceMsg( TF_FUNC, "~%s()\n", __THISCLASS__ );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    // TraceClsFunc( "[IUnknown] QueryInterface( )\n" );

    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    HRESULT hr = that->_QueryInterface( riid, ppv );

    // HRETURN(hr);
    return hr;
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    // TraceClsFunc( "[IUnknown] AddRef( )\n" );
    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    ULONG ul = that->_AddRef( );

    // RETURN(ul);
    return ul;
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    // TraceClsFunc( "[IUnknown] Release( )\n" );
    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    ULONG ul = that->_Release( );

    // RETURN(ul);
    return ul;
}

// ************************************************************************
//
// IUnknown2
//
// ************************************************************************

//
// _QueryInterface()
//
STDMETHODIMP
THISCLASS::_QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} QueryInterface( ... )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} QueryInterface( ... )\n", 
        _vtbl.pszInterface );
#endif

    HRESULT hr = _vtbl.pOrginalVtbl->lpfnQueryInterface( _vtbl.punk, riid, ppv );

#ifdef NOISY_QI
    HRETURN(hr);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") );
    InterlockDecrement(g_dwCounter);
    return(hr);
#endif
}

//
// _AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::_AddRef( void )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} AddRef( )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} AddRef()\n", 
        _vtbl.pszInterface );
#endif

    ULONG ul = _vtbl.pOrginalVtbl->lpfnAddRef( _vtbl.punk );

    InterlockIncrement( _vtbl.cRef );

#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
}

//
// _Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::_Release( void )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} Release( )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} Release()\n", 
        _vtbl.pszInterface );
#endif

    ULONG ul = _vtbl.pOrginalVtbl->lpfnRelease( _vtbl.punk );

    InterlockDecrement( _vtbl.cRef );

    if ( ul ) 
    {
#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
    }

    //
    // TODO: Figure out how to destroy the tracking objects.
    //

#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
}

//
// END DEBUG
//
///////////////////////////////////////
#endif // DEBUG
#endif // NO_TRACE_INTERFACES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\qi.h ===
//
// Copyright 1997 - Microsoft
//

//
// QI.H - Handles the query interface functions
//

#ifndef _QI_H_
#define _QI_H_

///////////////////////////////////////
//  
// QueryInterface Definitions
//
typedef struct {
    LPUNKNOWN          pvtbl;   // "punk" - pointer to a specific interface
    const struct _GUID *riid;   // GUID of interfaace

#ifdef DEBUG
    LPCTSTR pszName;    // Text name of interface - used to make sure tables are consistant
    DWORD   cFunctions; // Number of function entries in this interface's vtbl.
#endif // DEBUG

} QITABLE, *LPQITABLE, QIENTRY, *LPQIENTRY;

///////////////////////////////////////
//
// Quick-Lookup table declaration macro
//
#define DECLARE_QITABLE( _Class) QITABLE _QITable[ARRAYSIZE(QIT_##_Class)];

///////////////////////////////////////
//
// Quick-Lookup table construction macros
//
#ifdef DEBUG
#define DEFINE_QI( _iface, _name, _nFunctions ) \
    { NULL, &_iface, L#_name, _nFunctions },
#else // RETAIL
#define DEFINE_QI( _iface, _name, _nFunctions ) \
    { NULL, &_iface },
#endif // DEBUG

#define BEGIN_QITABLE( _Class ) \
    static const QITABLE QIT_##_Class[] = { DEFINE_QI( IID_IUnknown, IUnknown, 0 )

#define END_QITABLE  { NULL, NULL } };

///////////////////////////////////////
//
// Common Quick-Lookup QueryInterface( )
//
extern HRESULT
QueryInterface( 
    LPVOID    that,
    LPQITABLE pQI,
    REFIID    riid, 
    LPVOID   *ppv );

#ifdef DEBUG
///////////////////////////////////////
//
// BEGIN DEBUG 
//

#ifndef NO_TRACE_INTERFACES
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Interface tracking enabled")

///////////////////////////////////////
//
// Debug Quick-Lookup QI Interface Macros
//

// Begins construction of the runtime Quick-Lookup table.
// Adds IUnknown by default.
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i].pvtbl = (_IUnknownPrimaryInterface *) this;

// Checks that the QIENTRY matches the current QITABLE_IMP.
#define QITABLE_IMP( _Interface ) \
    _i++; \
    _QITable[_i].pvtbl = (_Interface *) this; \
{   int ___i = wcscmp( L#_Interface, _QITable[_i].pszName ); \
    AssertMsg( ___i == 0, \
        "DEFINE_QIs and QITABLE_IMPs don't match. Incorrect order.\n" ); }

// Verifies that the number of entries in the QITABLE match
// the number of QITABLE_IMP in the runtime section
#define END_QITABLE_IMP( _Class ) \
    AssertMsg( _i == ( ARRAYSIZE( QIT_##_Class ) - 2 ), \
        "The number of DEFINE_QIs and QITABLE_IMPs don't match.\n" ); \
    LPVOID pCITracker; \
    TraceMsgDo( pCITracker = CITracker_CreateInstance( _QITable ), "0x%08x" );

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk, 
    REFIID    riid, 
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)( 
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    LPCTSTR            pszInterface;
    UINT               cRef;
    LPUNKNOWN          punk;
    LPVTBL             pOrginalVtbl;
    LPUNKNOWN          pITracker;
    // These must be last and in this order QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPVOID
CITracker_CreateInstance( 
    LPQITABLE pQITable );   // QI Table of the object
    
///////////////////////////////////////
//
// CCITracker Class
//
//
class
CITracker:
    public IUnknown
{
private: // Members
    VTBL2 _vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPQITABLE pQITable );

public: // Methods
    friend LPVOID CITracker_CreateInstance( LPQITABLE pQITable );

    // IUnknown (Translates to IUnknown2)
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IUnknown2 (Real Implementation)
    STDMETHOD(_QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, _AddRef)(void);
    STDMETHOD_(ULONG, _Release)(void);
};

typedef CITracker* LPITRACKER;

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !NO_TRACE_INTERFACES
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

// Begins construction of the runtime Quick-Lookup table.
// Adds IUnknown by default.
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    LPVOID pCITracker; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i].pvtbl = (_IUnknownPrimaryInterface *) this;

// Adds a CITracker to interface and checks that the QIENRTY
// matches the current QITABLE_IMP.
#define QITABLE_IMP( _Interface ) \
    _i++; \
    _QITable[_i].pvtbl = (_Interface *) this; \
{   int ___i = wcscmp( L#_Interface, _QITable[_i].pszName ); \
    AssertMsg( ___i == 0, \
        "DEFINE_QIs and QITABLE_IMPs don't match. Incorrect order.\n" ); }

// Verifies that the number of entries in the QITABLE match
// the number of QITABLE_IMP in the runtime section
#define END_QITABLE_IMP( _Class )\
    AssertMsg( _i == ( ARRAYSIZE( QIT_##_Class ) - 2 ), \
        "The number of DEFINE_QIs and QITABLE_IMPs don't match.\n" );

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#endif // NO_TRACE_INTERFACES

#else
///////////////////////////////////////
//
// BEGIN RETAIL
//

//
// Debug Macros -> Retail Code
//
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i++].pvtbl = (_IUnknownPrimaryInterface *) this;

#define QITABLE_IMP( _Interface ) \
    _QITable[_i++].pvtbl = (_Interface *) this;

#define END_QITABLE_IMP( _Class )


//
// END RETAIL
//
///////////////////////////////////////
#endif // DEBUG

#endif _QI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\querypb.cpp ===
//
// Copyright 1997-199 - Microsoft Corporation
//

//
// QUERYPB.CPP - Property Bag for sending arguments to the DSFind Query Form
//

#include "pch.h"

#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("QueryPropertyBag")
#define THISCLASS QueryPropertyBag
#define LPTHISCLASS LPQUERYPROPERTYBAG

//
// QueryPropertyBag_CreateInstance( )
//
LPVOID
QueryPropertyBag_CreateInstance( void )
{
    TraceFunc( "QueryPropertyBag_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "QueryPropertyBag( )\n" );

    InterlockIncrement( g_cObjects );
    _pszServerName = NULL;
    _pszClientGuid = NULL;

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( QueryPropertyBag, IPropertyBag );
    QITABLE_IMP( IPropertyBag );
    END_QITABLE_IMP( QueryPropertyBag );
    Assert( _cRef == 0);
    AddRef( );

    Assert( !_pszServerName );
    Assert( !_pszClientGuid );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~QueryPropertyBag( )\n" );

    if ( _pszServerName )
        TraceFree( _pszServerName );

    if ( _pszClientGuid )
        TraceFree( _pszClientGuid );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
                         REFIID riid,
                         LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

STDMETHODIMP
THISCLASS::Read(
               LPCOLESTR pszPropName,
               VARIANT *pVar,
               IErrorLog *pErrorLog )
{
    TraceClsFunc("Read( )\n" );

    HRESULT hr;

    if ( !pszPropName || !pVar ) {
        HRETURN(E_POINTER);
    }

    if ( V_VT( pVar ) != VT_EMPTY ) {
        HRETURN(OLE_E_CANTCONVERT);
    }

    if ( _wcsicmp( pszPropName, L"ServerName" ) == 0 ) {
        if ( !_pszServerName ) {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        } else {
            BSTR tmp = SysAllocString( _pszServerName );
            if (!tmp) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT( pVar ) = VT_BSTR;
                V_BSTR( pVar ) = tmp;
                hr = S_OK;
            }
        }
    } else if ( _wcsicmp( pszPropName, L"ClientGuid" ) == 0 ) {
        if ( !_pszClientGuid ) {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        } else {
            BSTR tmp = SysAllocString( _pszClientGuid );
            if (!tmp) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT( pVar ) = VT_BSTR;
                V_BSTR( pVar ) = tmp;
                hr = S_OK;
            }
        }
    } else {   // something unexpected came in
        hr = THR(E_INVALIDARG);
    }

    HRETURN(hr);
}

STDMETHODIMP
THISCLASS::Write(
                LPCOLESTR pszPropName,
                VARIANT *pVar )
{
    TraceClsFunc("Write( )\n" );

    HRESULT hr;

    if ( !pszPropName || !pVar ) {
        HRETURN(E_POINTER);
    }

    if ( V_VT( pVar ) != VT_BSTR ) {
        HRETURN(OLE_E_CANTCONVERT);
    }

    if ( _wcsicmp( pszPropName, L"ServerName" ) == 0 ) {
        PWSTR tmp = TraceStrDup( V_BSTR( pVar ) );
        if (tmp) {
            if ( _pszServerName ) {
                TraceFree( _pszServerName );
                _pszServerName = NULL;
            }

            _pszServerName = tmp;
            hr = S_OK;
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else if ( _wcsicmp( pszPropName, L"ClientGuid" ) == 0 ) {
        PWSTR tmp = TraceStrDup( V_BSTR( pVar ) );
        if (tmp) {
            if ( _pszClientGuid ) {
                TraceFree( _pszClientGuid );
                _pszClientGuid = NULL;
            }

            _pszClientGuid = tmp;
            hr = S_OK;
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {   // something unexpected came in
        hr = THR(E_INVALIDARG);
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\register.h ===
//
// Copyright 1997 - Microsoft
//

//
// REGISTER.H - Registery functions
//

#ifndef _REGISTER_H_
#define _REGISTER_H_

LONG
RegisterDll( BOOL fCreate );

#endif // _REGISTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\querypb.h ===
//
// Copyright 1997-199 - Microsoft Corporation
//

//
// QUERYPB.H - Property Bag for sending arguments to the DSFind Query Form
//

// QITable
BEGIN_QITABLE( QueryPropertyBag )
DEFINE_QI( IID_IPropertyBag, IPropertyBag, 3 )
END_QITABLE

// Definitions
LPVOID
QueryPropertyBag_CreateInstance( void );

class QueryPropertyBag : public IPropertyBag
{
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( QueryPropertyBag );

    LPWSTR      _pszServerName;
    LPWSTR      _pszClientGuid;

    QueryPropertyBag( );
    ~QueryPropertyBag( );
    HRESULT Init( );

public:
    friend LPVOID QueryPropertyBag_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IPropertyBag methods
    STDMETHOD(Read)( LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog );
    STDMETHOD(Write)( LPCOLESTR pszPropName, VARIANT *pVar );
};


typedef class QueryPropertyBag *LPQUERYPROPERTYBAG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\server.h ===
//
// Copyright 1997 - Microsoft

//
// SERVER.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _SERVER_H_
#define _SERVER_H_

// Definitions
LPVOID
CServerTab_CreateInstance( void );

// CServerTab
class
CServerTab:
    public ITab
{
private:
    // Enums
    enum {
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    HWND            _hDlg;
    BOOL            _fChanged:1;    // Are we dirty?
    UINT            _uMode;         // Admin or Shell mode
    LPUNKNOWN       _punkService;   // Pointer to service object
    IDataObject *   _pido;          // IDataObject to be pass to "Clients" dialog and PostADsPropSheet
    LPWSTR          _pszSCPDN;      // SCP's DN
    LPWSTR          _pszGroupDN;    // The group's DN. If NULL, not in a group.
    LPUNKNOWN       _punkComputer;  // Pointer to computer object
    HWND            _hNotify;       // ADS notify window handle

private: // Methods
    CServerTab();
    ~CServerTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    BOOL    _InitDialog( HWND hDlg, LPARAM lParam );
    BOOL    _OnCommand( WPARAM wParam, LPARAM lParam );
    HRESULT _ApplyChanges( );
    INT _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _DisplayClientsQueryForm( );

public: // Methods
    friend LPVOID CServerTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CServerTab* LPSERVERTAB;

#endif // _SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\server.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SERVER.CPP - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_SERVER tab
//

#include "pch.h"
#include <dns.h>
#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "ccomputr.h"
#include "server.h"
#include "dpguidqy.h"
#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CServerTab")
#define THISCLASS CServerTab
#define LPTHISCLASS LPSERVERTAB


DWORD aServerHelpMap[] = {
    IDC_C_RESPOND, HIDC_C_RESPOND,
    IDC_C_KNOWNCLIENTS, HIDC_C_KNOWNCLIENTS,
    IDC_B_CHECKSERVER, HIDC_B_CHECKSERVER,
    IDC_B_CLIENTS, HIDC_B_CLIENTS,
    IDC_B_SERVICE, HIDC_B_SERVICE,
    IDC_G_CHECKSERVER, HIDC_G_CHECKSERVER,
    IDC_G_CLIENTSERVICING, HIDC_G_CLIENTSERVICING,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CServerTab_CreateInstance( void )
{
    TraceFunc( "CServerTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr) ) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _fChanged(FALSE),
    _uMode(MODE_SHELL),
    _punkService(NULL),
    _pido(NULL),
    _pszSCPDN(NULL),
    _pszGroupDN(NULL),
    _punkComputer(NULL),
    _hNotify(NULL)
{
    TraceClsFunc( "CServerTab()\n" );

    InterlockIncrement( g_cObjects );

    Assert( !_punkService );
    Assert( !_pido );
    Assert( !_pszGroupDN );
    Assert( !_pszSCPDN );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CServerTab()\n" );

    if ( _pido )
        _pido->Release( );

    if ( _punkService )
        _punkService->Release( );

    if ( _punkComputer )
        _punkComputer->Release( );

    if ( _pszSCPDN )
        TraceFree( _pszSCPDN );

    if ( _pszGroupDN )
        TraceFree( _pszGroupDN );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage,
                   LPARAM lParam,
                   LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    if ( !punk )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_SERVER);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    LPSHELLEXTINIT pShellExtInit = NULL;
    IMAO * pmao = NULL;

    _punkComputer = punk;
    _punkComputer->AddRef( );

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pmao->GetDataObject( &_pido ) );
    if (FAILED( hr ))
        goto Error;

    _punkService = (LPUNKNOWN) CService_CreateInstance( );
    if ( !_punkService ) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = THR( _punkService->QueryInterface( IID_IShellExtInit, (void **) &pShellExtInit ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pShellExtInit->Initialize( NULL, _pido, NULL ) );
    if (FAILED( hr ))
        goto Error;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage ) {
        if ( !lpfnAddPage( hpage, lParam ) ) {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
        }
    }

Cleanup:
    if ( pShellExtInit )
        pShellExtInit->Release( );

    if ( pmao )
        pmao->Release( );

    HRETURN(hr);

Error:
    MessageBoxFromHResult( NULL, NULL, hr );
    goto Cleanup;
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                      LPARAM lParam,
                      LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    HRETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
                           LPWSTR pszAttribute,
                           LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
                          BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************



//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
                           HWND hDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG ) {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        return pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc) {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg ) {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aServerHelpMap );
            }
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aServerHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
                            HWND hwnd,
                            UINT uMsg,
                            LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
              hwnd, uMsg, ppsp );

    switch ( uMsg ) {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _InitDialog( )
//
BOOL
THISCLASS::_InitDialog(
                      HWND hDlg,
                      LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;

    BOOL fAdmin           = FALSE;

    LPINTELLIMIRRORSAP pimsap     = NULL;

    HRESULT hr;
    HRESULT hResult = S_OK;
    WCHAR   szRISETUPPath[ MAX_PATH ];
    HANDLE  hFind;
    BOOL    fOnOff;

    IMAO *  pmao = NULL;

    WIN32_FIND_DATA fda;

    _hDlg = hDlg;

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pmao->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->IsAdmin( &fAdmin ) );
    Assert( SUCCEEDED(hr) || fAdmin == FALSE );

    hr = THR( pimsap->GetAnswerRequests( &fOnOff) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK ) {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_RESPOND ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), fOnOff );

    hr = THR( pimsap->GetAnswerOnlyValidClients( &fOnOff) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK ) {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );



    // See if we can enable the "Check Server" button.
    if (!ExpandEnvironmentStrings(L"%SystemRoot%\\system32\\risetup.exe", szRISETUPPath, ARRAYSIZE(szRISETUPPath))) {
        hr = THR(HRESULT_FROM_WIN32( GetLastError() ));
        goto Error;
    }

    hFind = FindFirstFile( szRISETUPPath, &fda );
    if ( hFind != INVALID_HANDLE_VALUE ) {
        FindClose( hFind );

        LPWSTR pszServerName;
        WCHAR szFQDNS[ DNS_MAX_NAME_BUFFER_LENGTH ];
        DWORD cbSize = ARRAYSIZE( szFQDNS );

        hr = THR( pimsap->GetServerName( &pszServerName ) );
        if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) {
            goto Error;
        }

        if (SUCCEEDED( hr )) {
            GetComputerNameEx( ComputerNameNetBIOS, szFQDNS, &cbSize );
            if ( StrCmpI( szFQDNS, pszServerName ) == 0) {
                EnableWindow( GetDlgItem( _hDlg, IDC_B_CHECKSERVER ), TRUE );
            }

            TraceFree( pszServerName );
        }
    }

    Assert( !_pszSCPDN );
    hr = THR( pimsap->GetSCPDN( &_pszSCPDN ) );
    if (FAILED( hr )) {
        goto Error;
    }
    EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVICE ), !!_pszSCPDN );

    if (FAILED( hResult )) {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hResult );
    }

    Cleanup:
    if ( pmao )
        pmao->Release( );
    if ( pimsap )
        pimsap->Release( );
    RETURN(FALSE);
    Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}

//
// _DisplayClientsQueryForm( )
//
HRESULT
THISCLASS::_DisplayClientsQueryForm( )
{
    TraceClsFunc( "_DisplayClientsQueryForm( )\n" );

    HRESULT hr;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    ICommonQuery *    pCommonQuery = NULL;
    IPropertyBag *    ppb = NULL;
    VARIANT           var;

    LPINTELLIMIRRORSAP pimsap = NULL;
    LPWSTR pszServerName = NULL;
    WCHAR  szServerQuery[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];
    BSTR tmp;

    VariantInit( &var );

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr )) {
        goto Clients_Error;
    }

    hr = THR( pimsap->GetServerName( &pszServerName ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) {
        goto Clients_Error;
    }

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED( hr )) {
        goto Clients_Error;
    }

    if (wcslen(pszServerName) + 1 + 1 <= ARRAYSIZE(szServerQuery)) {
        wcscpy( szServerQuery, pszServerName );
        wcscat( szServerQuery, L"*" );
    } else {
        hr = E_INVALIDARG;
        goto Clients_Error;
    }

    tmp = SysAllocString( szServerQuery );
    if (!tmp) {
        hr = E_OUTOFMEMORY;
        goto Clients_Error;
    }

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = tmp;
    
    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct      = sizeof(dqip);
    dqip.dwFlags       = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags       |= DSQPF_ENABLEADVANCEDFEATURES;

    ppb = (IPropertyBag *) QueryPropertyBag_CreateInstance( );
    if ( !ppb ) {
        hr = E_OUTOFMEMORY;
        goto Clients_Error;
    }

    hr = THR( ppb->Write( L"ServerName", &var ) );
    if (FAILED(hr)) {
        goto Clients_Error;
    }

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN | OQWF_DEFAULTFORM;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RIQueryForm;
    oqw.pFormParameters    = ppb;

    hr = pCommonQuery->OpenQueryWindow( _hDlg, &oqw, NULL /* don't need results */);

Clients_Error:
    VariantClear( &var );

    if ( ppb )
        ppb->Release( );

    if ( pCommonQuery )
        pCommonQuery->Release( );

    if ( pszServerName )
        TraceFree( pszServerName );

    if ( pimsap )
        pimsap->Release( );

    HRETURN(hr);
}

//
// _OnCommand( )
//
BOOL
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    BOOL fChanged = FALSE;
    BOOL fReturn = FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch ( LOWORD(wParam) ) {
    case IDC_C_RESPOND:
        if ( HIWORD(wParam) == BN_CLICKED ) {
            EnableWindow( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), Button_GetCheck( hwndCtl ) == BST_CHECKED );
            fChanged = TRUE;
        }
        break;

    case IDC_C_KNOWNCLIENTS:
        if ( HIWORD(wParam) == BN_CLICKED ) {
            fChanged = TRUE;
        }
        break;


    case IDC_B_CLIENTS:
        if ( HIWORD(wParam) == BN_CLICKED ) {
            HRESULT hr = _DisplayClientsQueryForm( );
            if (FAILED(hr)) {
                MessageBoxFromHResult( _hDlg, 0, hr );
            }
        }
        break;

    case IDC_B_CHECKSERVER:
        {
            const WCHAR szCommand[] = { L"RISETUP.EXE -check"};
            WCHAR szRealCommandLine[MAX_PATH + 7 + 1]; // 7 for ' -check' and 1 for null
            STARTUPINFO startupInfo;
            PROCESS_INFORMATION pi;

            ZeroMemory( &startupInfo, sizeof( startupInfo) );
            startupInfo.cb = sizeof( startupInfo );

            if (ExpandEnvironmentStrings(szCommand, szRealCommandLine, ARRAYSIZE(szRealCommandLine)) &&
                CreateProcess( NULL,
                               szRealCommandLine,
                               NULL,
                               NULL,
                               TRUE,
                               NORMAL_PRIORITY_CLASS,
                               NULL,
                               NULL,
                               &startupInfo,
                               &pi )) {
                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            } else {
                DWORD dwErr = GetLastError( );
                MessageBoxFromError( _hDlg, IDS_RISETUP_FAILED_TO_START, dwErr );
            }
        }
        break;

    case IDC_B_SERVICE:
        if ( HIWORD(wParam) == BN_CLICKED ) {
            Assert( _pszSCPDN );
            THR( PostADsPropSheet( _pszSCPDN, _pido, _hDlg, FALSE) );
        }
        break;
    }

    if ( fChanged ) {
        if ( !_fChanged ) {
            _fChanged = TRUE;
            SendMessage( GetParent( _hDlg ), PSM_CHANGED, (WPARAM)_hDlg, 0 );
        }
    }

    RETURN(fReturn);
}

//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRETURN(S_FALSE); // nop

    HRESULT hr;
    HRESULT hResult = S_OK;
    BOOL    fOnOff;
    HWND    hwnd;
    LPINTELLIMIRRORSAP pimsap;

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr )) {
        goto Error;
    }

    hwnd = GetDlgItem( _hDlg, IDC_C_RESPOND );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetAnswerRequests( fOnOff ) );
    if (FAILED( hr ) && hResult == S_OK ) {
        hResult = hr;
        SetFocus( hwnd );
    }

    hwnd = GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetAnswerOnlyValidClients( fOnOff ) );
    if (FAILED( hr ) && hResult == S_OK ) {
        hResult = hr;
        SetFocus( hwnd );
    }

    hr = THR( pimsap->CommitChanges() );
    if (FAILED( hr ))
        goto Error;

    if (FAILED( hResult )) {
        MessageBoxFromHResult( NULL, NULL, hResult );
        hr = hResult;
    }

Cleanup:
    if ( pimsap )
        pimsap->Release( );

    // Tell DSA that someone hit Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    MessageBoxFromHResult( NULL, NULL, hr );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
                    WPARAM wParam,
                    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LV_DISPINFO * plvdi = (LV_DISPINFO *) lParam;

    switch ( plvdi->hdr.code ) {
    case PSN_APPLY:
        {
            HRESULT hr;
            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            _fChanged = FALSE;
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adminui.rc
//
#define IDS_BIGFONTSIZE                 2
#define IDS_SAMPLENAMINGPOLICY          3
#define IDS_WORD_CUSTOM                 4
#define IDS_COLUMN1                     5
#define IDS_COLUMN2                     6
#define IDS_COLUMN3                     7
#define IDS_COLUMN4                     8
#define IDS_BROWSEFOROU_CAPTION         9
#define IDS_BROWSEFOROU_TITLE           10
#define IDS_NOT_AVAILABLE               11
#define IDS_CLIENTS_COLUMN1             12
#define IDS_CLIENTS_COLUMN2             13
#define IDC_CLIENTS_COLUMN3             14
#define IDS_OS_COLUMN1                  15
#define IDS_OS_COLUMN2                  16
#define IDS_OS_COLUMN3                  17
#define IDS_OS_COLUMN4                  18
#define IDS_OS_COLUMN5                  19
#define IDS_ERROR_ACCOUNTEXISTS         22
#define IDC_ERROR_CREATINGACCOUNT_TITLE 23
#define IDS_ERROR                       24
#define IDS_ERROR_WRITINGTOCOMPUTERACCOUNT 25
#define IDS_ERROR_READINGCOMPUTERACCOUNT 26
#define IDS_ERROR_OPENNINGGROUPOBJECT   27
#define IDS_ERROR_DELETINGCOMPUTERDIRECTORY 28
#define IDS_ERROR_REMOVINGCOMPUTERACCOUNT 29
#define IDS_COULDNOTCONTACTSERVER_CAPTION 30
#define IDS_COULDNOTCONTACTSERVER_TEXT  31
#define IDS_AREYOUSURE_CAPTION          33
#define IDS_DELETESIF_TEXT              34
#define IDS_ADVANCED_NAMING_RESTRICTIONS_TITLE 35
#define IDS_ADVANCED_NAMING_RESTRICTIONS_TEXT 36
#define IDS_DNS_NAME_LENGTH_WARNING_TITLE 37
#define IDS_DNS_NAME_LENGTH_WARNING_TEXT 38
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 39
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 40
#define IDS_UNABLETODETERMINESERVERNAME_TITLE 41
#define IDS_UNABLETODETERMINESERVERNAME_TEXT 42
#define IDS_MANAGED_PC                  43
#define IDS_ANY_SERVER                  44
#define IDS_REMOTE_INSTALL_CLIENTS      45
#define IDS_GUID                        46
#define IDS_HOST_SERVER                 47
#define IDS_NAME                        48
#define IDS_INVALID_GUID_CAPTION        49
#define IDS_INVALID_GUID_TEXT           50
#define IDS_ADD_DOT_DOT_DOT             51
#define IDS_PAGE1_TITLE                 52
#define IDS_PAGE1_SUBTITLE              53
#define IDS_PAGE2_TITLE                 54
#define IDS_PAGE2_SUBTITLE              55
#define IDS_PAGE3_TITLE                 56
#define IDS_PAGE3_SUBTITLE              57
#define IDS_PAGE4_TITLE                 58
#define IDS_PAGE4_SUBTITLE              59
#define IDS_PAGE5_TITLE                 60
#define IDS_PAGE5_SUBTITLE              61
#define IDS_PAGE6_TITLE                 62
#define IDS_PAGE6_SUBTITLE              63
#define IDS_PAGE7_TITLE                 64
#define IDS_PAGE7_SUBTITLE              65
#define IDS_PAGE8_TITLE                 66
#define IDS_PAGE8_SUBTITLE              67
#define IDS_CANCELCAPTION               68
#define IDS_CANCELTEXT                  69
#define IDS_NA                          70
#define IDS_NOTARISERVER_CAPTION        71
#define IDS_NOTARISERVER_TEXT           72
#define IDS_ERROR_COPYING_FILE          73
#define IDS_PAGE9_TITLE                 74
#define IDS_PAGE9_SUBTITLE              75
#define IDS_PAGE10_TITLE                76
#define IDS_PAGE10_SUBTITLE             77
#define IDS_RISETUP_FAILED_TO_START     78
#define IDS_MUST_BE_FLAT_CAPTION        79
#define IDS_MUST_BE_FLAT_TEXT           80
#define IDC_NOT_A_BINL_SERVER           81
#define IDS_USER_LOCATION               82
#define IDS_BROWSE_FOR_BINL_SERVER_TITLE 83
#define IDS_INVALID_PARTIAL_GUID_TEXT   84
#define IDS_OFN_SIF_FILTER              85
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE 86
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT 87
#define IDS_OVERWRITE_CAPTION           88
#define IDS_OVERWRITE_TEXT              89
#define IDC_IMPROPER_EXTENSION_CAPTION  90
#define IDC_IMPROPER_EXTENSION_TEXT     91
#define IDS_CUSTOM_NAMING_DESCRIPTION   92
#define IDS_PROBLEM_FINDING_SERVER_TITLE 93
#define IDS_PROBLEM_FINDING_SERVER_TEXT 94
#define IDS_REMOVING_GUID_TITLE         95
#define IDS_REMOVING_GUID_TEXT          96
#define IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT 97
#define IDI_RBSICON                     101
#define IDD_ADVANCEDNAMIMG              104
#define IDD_PROP_INTELLIMIRROR_OS       107
#define IDD_SIF_PROP_IMAGES             108
#define IDD_PROP_INTELLIMIRROR_SERVER   111
#define IDD_PROP_TOOLS                  112
#define IDD_ADD_PAGE4                   113
#define IDD_PROP_INTELLIMIRROR_CLIENT   115
#define IDD_PROP_NEW_CLIENTS            116
#define IDD_ADD_PAGE2                   117
#define IDD_MANAGED_WIZARD_PAGE         120
#define IDD_HOST_SERVER_PAGE            121
#define IDD_GUID_QUERY_FORM             122
#define IDD_DUPLICATE_GUID              123
#define IDD_ADD_PAGE1                   124
#define IDD_ADD_PAGE3                   125
#define IDB_HEADER                      126
#define IDD_ADD_PAGE5                   126
#define IDD_ADD_PAGE6                   127
#define IDD_ADD_PAGE7                   128
#define IDD_ADD_PAGE8                   129
#define IDD_ADD_PAGE9                   130
#define IDD_ADD_PAGE10                  131
#define IDD_SIF_PROP_TOOLS              132
#define IDD_SERVER_QUERY_FORM           133
#define IDS_REMOTE_INSTALL_SERVERS      134
#define IDS_PROBLEM_SEARCHING_TEXT      135
#define IDS_PROBLEM_SEARCHING_TITLE     136
#define IDC_L_TOOLS                     1000
#define IDC_B_REFRESH                   1011
#define IDC_E_HELP                      1013
#define IDC_E_SERVER                    1013
#define IDC_C_RESPOND                   1015
#define IDC_C_KNOWNCLIENTS              1016
#define IDC_B_CLIENTS                   1020
#define IDC_B_SERVICE                   1021
#define IDC_L_OS                        1024
#define IDC_E_SERVERNAME                1027
#define IDC_E_GUID                      1028
#define IDC_S_GUID                      1029
#define IDC_B_SERVER                    1030
#define IDC_CB_NAMINGPOLICY             1032
#define IDC_B_ADVANCED                  1033
#define IDC_E_NEWMACHINEOU              1034
#define IDC_B_BROWSE                    1035
#define IDC_R_SAMEASUSER                1036
#define IDC_R_DOMAINDEFAULT             1037
#define IDC_R_SPECIFICLOCATION          1038
#define IDC_B_ADD                       1040
#define IDC_B_REMOVE                    1041
#define IDC_B_PROPERTIES                1042
#define IDC_E_FORMAT                    1048
#define IDC_E_DESCRIPTION               1056
#define IDC_B_ANYSERVER                 1062
#define IDC_B_SPECIFICSERVER            1064
#define IDC_S_VERSION                   1070
#define IDC_S_LANGUAGE                  1071
#define IDC_S_LASTMODIFIED              1072
#define IDC_S_IMAGETYPE                 1073
#define IDC_S_DIRECTORY                 1075
#define IDC_B_CHECKSERVER               1078
#define IDC_C_MANAGED_PC                1079
#define IDC_B_QUERY                     1081
#define IDC_B_ADDSIF                    1083
#define IDC_B_NEWIMAGE                  1084
#define IDC_B_FROMSAMPLES               1086
#define IDC_B_LOCATION                  1088
#define IDC_E_FILEPATH                  1091
#define IDC_L_OSES                      1092
#define IDC_E_SOURCE                    1093
#define IDC_E_DESTINATION               1094
#define IDC_L_SIFS                      1096
#define IDC_E_FILENAME                  1097
#define IDC_E_HELPTEXT                  1099
#define IDC_S_SOURCEIMAGE               1100
#define IDC_S_DESTIMAGE                 1101
#define IDC_E_SAMPLE                    1103
#define IDC_S_CREATEIN                  1105
#define IDC_S_ICON                      1106
#define IDC_G_CHECKSERVER               1109
#define IDC_G_CLIENTSERVICING           1110
#define IDC_G_CLIENTACCOUNTLOCATION     1111
#define IDC_G_NAMINGFORMAT              1112
#define IDC_G_IMAGEDETAILS              1113
#define IDC_BUTTON1                     1114
#define IDC_B_SEARCH                    IDC_B_BROWSE
#define IDI_COMPUTER                    4097

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1115
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\register.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// REGISTER.CPP - Registery functions
//

#include "pch.h"
#include "register.h"
#include <advpub.h>
#include <dsquery.h>

DEFINE_MODULE("IMADMUI")

//
// RegisterQueryForm( )
//
HRESULT
RegisterQueryForm( 
    BOOL fCreate,
    const GUID *pclsid )
{
    TraceFunc( "RegisterQueryForm(" );
    TraceMsg( TF_FUNC, " %s )\n", BOOLTOSTRING( fCreate ) );

    HRESULT hr = E_FAIL;
    int     i = 0;
    HKEY    hkclsid = NULL;

    HKEY     hkey = NULL;
    HKEY     hkeyForms = NULL;
    DWORD    cbSize;
    DWORD    dwDisposition;
    DWORD    dwFlags = 0x2;
    LPOLESTR pszCLSID = NULL;

    //
    // Open the "CLSID" under HKCR
    //
    hr = HRESULT_FROM_WIN32( RegOpenKeyEx( 
                                    HKEY_CLASSES_ROOT, 
                                    L"CLSID",
                                    0,
                                    KEY_WRITE,
                                    &hkclsid ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( CLSID_DsQuery, &pszCLSID ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Create the "CLSID" key
    //
    hr = HRESULT_FROM_WIN32( RegOpenKeyEx( 
                                hkclsid, 
                                pszCLSID, 
                                0,
                                KEY_WRITE,
                                &hkey ));
    if (FAILED(hr)) {
        goto Error;
    }

    CoTaskMemFree( pszCLSID );
    pszCLSID = NULL;

    //
    // Create "Forms"
    //
    hr = HRESULT_FROM_WIN32( RegCreateKeyEx( 
                        hkey, 
                        L"Forms", 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_CREATE_SUB_KEY | KEY_WRITE, 
                        NULL,
                        &hkeyForms,
                        &dwDisposition ));

    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( (IID &)*pclsid, &pszCLSID ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Create the "CLSID" key under the forms key
    //
    hr = HRESULT_FROM_WIN32( RegCreateKeyEx( 
                        hkeyForms, 
                        pszCLSID, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_CREATE_SUB_KEY | KEY_WRITE, 
                        NULL,
                        &hkey,
                        &dwDisposition ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Set "CLSID" to the "CLSID" key
    //
    cbSize = ( wcslen( pszCLSID ) + 1 ) * sizeof(WCHAR);
    hr = HRESULT_FROM_WIN32(RegSetValueEx( 
                                    hkey, 
                                    L"CLSID", 
                                    0, 
                                    REG_SZ, 
                                    (LPBYTE) pszCLSID, 
                                    cbSize ));

    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Set "FLAGS" to 0x2
    //
    cbSize = sizeof(dwFlags);
    hr = HRESULT_FROM_WIN32( RegSetValueEx( 
                                    hkey, 
                                    L"Flags", 
                                    0, 
                                    REG_DWORD, 
                                    (LPBYTE) &dwFlags, 
                                    cbSize ));
    if (FAILED(hr)) {
        goto Error;
    }

Error:
    //
    // Cleanup
    //
    if (hkeyForms) {
        RegCloseKey( hkeyForms );
    }
    if (hkey) {
        RegCloseKey( hkey );
    }
    if (hkclsid) {
        RegCloseKey( hkclsid );
    }

    if (pszCLSID) {
        CoTaskMemFree( pszCLSID );
    }

    HRETURN(hr);
}

//
// RegisterDll()
//
LONG
RegisterDll( BOOL fCreate )
{
    TraceFunc( "RegisterDll(" );
    TraceMsg( TF_FUNC, " %s )\n", BOOLTOSTRING( fCreate ) );

    HRESULT hr = E_FAIL;
    int     i = 0;
    HKEY    hkclsid = NULL;
    HKEY    hkey = NULL;
    HKEY    hkeyInProc = NULL;
    DWORD    cbSize;
    DWORD    dwDisposition;
    LPOLESTR pszCLSID = NULL;

    static const WCHAR szApartment[] = L"Apartment";
    static const WCHAR szInProcServer32[] = L"InProcServer32";
    static const WCHAR szThreadingModel[] = L"ThreadingModel";

    //
    // Open the "CLSID" under HKCR
    //
    hr = HRESULT_FROM_WIN32( RegOpenKeyEx( 
                                    HKEY_CLASSES_ROOT, 
                                    L"CLSID",
                                    0,
                                    KEY_WRITE,
                                    &hkclsid ) );
    if (FAILED(hr)) {
        goto Error;
    }

    //
    // Loop until we have created all the keys for our classes.
    //
    while ( g_DllClasses[ i ].rclsid != NULL )
    {
        TraceMsg( TF_ALWAYS, "Registering %s = ", g_DllClasses[i].pszName );
        TraceMsgGUID( TF_ALWAYS, (*g_DllClasses[ i ].rclsid) );
        TraceMsg( TF_ALWAYS, "\n" );

        //
        // Convert the CLSID to a string
        //
        hr = THR( StringFromCLSID( *g_DllClasses[ i ].rclsid, &pszCLSID ) );
        if (FAILED(hr)) {
            goto Error;
        }

        //
        // Create the "CLSID" key
        //
        hr = HRESULT_FROM_WIN32( RegCreateKeyEx( 
                            hkclsid, 
                            pszCLSID, 
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_CREATE_SUB_KEY | KEY_WRITE, 
                            NULL,
                            &hkey,
                            &dwDisposition ) );

        if (FAILED(hr)) {
            goto Error;
        }

        //
        // Set "Default" for the CLSID
        //
        cbSize = ( wcslen( g_DllClasses[i].pszName ) + 1 ) * sizeof(WCHAR);
        hr = HRESULT_FROM_WIN32( RegSetValueEx( 
                                        hkey, 
                                        NULL, 
                                        0, 
                                        REG_SZ, 
                                        (LPBYTE) g_DllClasses[i].pszName, 
                                        cbSize ));
        if (FAILED(hr)) {
            goto Error;
        }

        //
        // Create "InProcServer32"
        //
        hr = HRESULT_FROM_WIN32(RegCreateKeyEx( 
                            hkey, 
                            szInProcServer32, 
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_CREATE_SUB_KEY | KEY_WRITE, 
                            NULL,
                            &hkeyInProc,
                            &dwDisposition ) );
        if (FAILED(hr)) {
            goto Error;
        }

        //
        // Set "Default" in the InProcServer32
        //
        cbSize = ( wcslen( g_szDllFilename ) + 1 ) * sizeof(WCHAR);
        hr =  HRESULT_FROM_WIN32(RegSetValueEx( 
                                    hkeyInProc, 
                                    NULL, 
                                    0, 
                                    REG_SZ, 
                                    (LPBYTE) g_szDllFilename, 
                                    cbSize ));
        if (FAILED(hr)) {
            goto Error;
        }
        //
        // Set "ThreadModel" to "Apartment"
        //
        cbSize = sizeof( szApartment );
        hr = HRESULT_FROM_WIN32(RegSetValueEx( 
                                    hkeyInProc, 
                                    szThreadingModel, 
                                    0, 
                                    REG_SZ, 
                                    (LPBYTE) szApartment, 
                                    cbSize ));          
        if (FAILED(hr)) {
            goto Error;
        }
        //
        // Cleanup
        //
        RegCloseKey( hkeyInProc );
        RegCloseKey( hkey );
        CoTaskMemFree( pszCLSID );
        hkey = NULL;
        hkeyInProc = NULL;
        pszCLSID = NULL;

        //
        // Next!
        //
        i++;
    }
    
    //
    // Ignore failure from RegisterQueryForm. It fails during Setup because
    // some shell stuff isn't registered yet.  when we run "risetup" after
    // gui-setup, this will get registered properly.
    //

    RegisterQueryForm( fCreate, &CLSID_RIQueryForm );
    RegisterQueryForm( fCreate, &CLSID_RISrvQueryForm );
    
    hr = NOERROR;

Error:
    if (hkeyInProc) {
        RegCloseKey( hkeyInProc );
    }
    if (hkey) {
        RegCloseKey( hkey );
    }
    
    if (pszCLSID) {
        CoTaskMemFree( pszCLSID );
    }

    if (hkclsid) {
        RegCloseKey( hkclsid );
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\serverqy.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SERVERQY.CPP - The RIS server query form
//

#include "pch.h"

#include "serverqy.h"
#include "mangdlg.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CRISrvQueryForm")
#define THISCLASS CRISrvQueryForm
#define LPTHISCLASS LPCRISrvQueryForm

#define FILTER_QUERY_SERVER    L"(&(objectClass=computer)(netbootSCPBL=*)(CN=%s))"

#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((wcslen(sz)+1)*sizeof(WCHAR))


DWORD aSrvQueryHelpMap[] = {
    IDC_E_SERVER, HIDC_E_SERVER,
    NULL, NULL
};

//
// CRISrvQueryForm_CreateInstance( )
//
LPVOID
CRISrvQueryForm_CreateInstance( void )
{
    TraceFunc( "CRISrvQueryForm_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( FAILED(hr) )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CRISrvQueryForm( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CRISrvQueryForm, IQueryForm );
    QITABLE_IMP( IQueryForm );
    END_QITABLE_IMP( CRISrvQueryForm );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CRISrvQueryForm( )\n" );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(
    HKEY hkForm)
{
    TraceClsFunc( "[IQueryForm] Initialize( )\n" );

    HRETURN(S_OK);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::AddForms(
    LPCQADDFORMSPROC pAddFormsProc,
    LPARAM lParam )
{
    TraceClsFunc( "[IQueryForm] AddForms(" );
    TraceMsg( TF_FUNC, " pAddFormsProc = 0x%p, lParam = 0x%p )\n", pAddFormsProc, lParam );

    if ( !pAddFormsProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQFORM cqf;
    WCHAR szTitle[ 255 ];
    DWORD dw;

    if (!LoadString( g_hInstance, IDS_REMOTE_INSTALL_SERVERS, szTitle, ARRAYSIZE(szTitle))) {
        HRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    ZeroMemory( &cqf, sizeof(cqf) );
    cqf.cbStruct = sizeof(cqf);
    cqf.dwFlags = CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_RISrvQueryForm;
    cqf.pszTitle = szTitle;

    hr = THR( pAddFormsProc(lParam, &cqf) );

    HRETURN(hr);
}


//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPCQADDPAGESPROC pAddPagesProc,
    LPARAM lParam)
{
    TraceClsFunc( "[IQueryForm] AddPages(" );
    TraceMsg( TF_FUNC, " pAddPagesProc = 0x%p, lParam = 0x%p )\n", pAddPagesProc, lParam );

    if ( !pAddPagesProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQPAGE cqp;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC) PropSheetPageProc;
    cqp.hInstance = g_hInstance;
    cqp.idPageName = IDS_REMOTE_INSTALL_SERVERS;
    cqp.idPageTemplate = IDD_SERVER_QUERY_FORM;
    cqp.pDlgProc = PropSheetDlgProc;
    cqp.lParam = (LPARAM)this;

    hr = THR( pAddPagesProc(lParam, CLSID_RISrvQueryForm, &cqp) );

    HRETURN(hr);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( L"PropSheetDlgProc(" );
    //TraceMsg( TF_FUNC, L" hDlg = 0x%p, uMsg = 0x%p, wParam = 0x%p, lParam = 0x%p )\n",
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, L"WM_INITDIALOG\n");

        CQPAGE * pcqp = (CQPAGE *) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, pcqp->lParam );
        pcc = (LPTHISCLASS) pcqp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aSrvQueryHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aSrvQueryHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
HRESULT CALLBACK
THISCLASS::PropSheetPageProc(
    LPCQPAGE pQueryPage,
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, L"pQueryPage = 0x%p, hwnd = 0x%p, uMsg = 0x%p, wParam= 0x%p, lParam = 0x%p )\n",
        pQueryPage, hwnd, uMsg, wParam, lParam );

    HRESULT hr = E_NOTIMPL;
    Assert( pQueryPage );
    LPTHISCLASS pQueryForm = (LPTHISCLASS )pQueryPage->lParam;
    Assert( pQueryForm );

    switch ( uMsg )
    {
    // Initialize so AddRef the object we are associated with so that
    // we don't get unloaded.

    case CQPM_INITIALIZE:
        TraceMsg( TF_WM, "CQPM_INITIALIZE\n" );
        pQueryForm->AddRef();
        hr = S_OK;
        break;

    // Release, therefore Release the object we are associated with to
    // ensure correct destruction etc.

    case CQPM_RELEASE:
        TraceMsg( TF_WM, "CQPM_RELEASE\n" );
        SetWindowLongPtr( pQueryForm->_hDlg, GWLP_USERDATA, NULL );
        pQueryForm->Release();
        hr = S_OK;
        break;

    // Enable so fix the state of our two controls within the window.

    case CQPM_ENABLE:
        TraceMsg( TF_WM, "CQPM_ENABLE\n" );
        EnableWindow( GetDlgItem( hwnd, IDC_E_SERVER ), (BOOL)wParam );
        hr = S_OK;
        break;

    // Fill out the parameter structure to return to the caller, this is
    // handler specific.  In our case we constructure a query of the CN
    // and objectClass properties, and we show a columns displaying both
    // of these.  For further information about the DSQUERYPARAMs structure
    // see dsquery.h

    case CQPM_GETPARAMETERS:
        TraceMsg( TF_WM, "CQPM_GETPARAMETERS\n" );
        hr = pQueryForm->_GetQueryParams( hwnd, (LPDSQUERYPARAMS*)lParam );
        break;

    // Clear form, therefore set the window text for these two controls
    // to zero.

    case CQPM_CLEARFORM:
        TraceMsg( TF_WM, "CQPM_CLEARFORM\n" );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"" );
        hr = S_OK;
        break;

    case CQPM_SETDEFAULTPARAMETERS:
        TraceMsg( TF_WM, "CQPM_SETDEFAULTPARAMETERS: wParam = %s  lParam = 0x%p\n", BOOLTOSTRING(wParam), lParam );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"*" );
        hr = S_OK;
        break;

    default:
        TraceMsg( TF_WM, "CQPM_message 0x%08x *** NOT IMPL ***\n", uMsg );
        hr = E_NOTIMPL;
        break;
    }

    RETURN(hr);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    HRETURN(S_OK);
}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );

    HRETURN(S_OK);
}

struct
{
    INT fmt;
    INT cx;
    INT uID;
    PCWSTR pDisplayProperty;
}
srvcolumns[] =
{
    0, 20, IDS_NAME, L"cn",    
};

//
// _GetQueryParams( )
//
HRESULT
THISCLASS::_GetQueryParams(
    HWND hWnd,
    LPDSQUERYPARAMS* ppdsqp )
{
    TraceClsFunc( "_GetQueryParams( )\n" );

    if ( !ppdsqp )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT     i;
    WCHAR   szServer[DNS_MAX_NAME_BUFFER_LENGTH];
    WCHAR   szFilter[ARRAYSIZE(FILTER_QUERY_SERVER)+ARRAYSIZE(szServer)];
    ULONG   offset;
    BOOL    CallerSpecifiedQuery;
    BOOL    CallerQueryStartsWithAmpersand = FALSE;
    
    ULONG   cbStruct = 0;
    LPDSQUERYPARAMS pDsQueryParams = NULL;

#if 0
    if ( *ppdsqp )
    {
        // This page doesn't support appending its query data to an
        // existing DSQUERYPARAMS strucuture, only creating a new block,
        // therefore bail if we see the pointer is not NULL.
        hr = THR(E_INVALIDARG);
        goto Error;
    }
#endif

    if (!GetDlgItemText( hWnd, IDC_E_SERVER, szServer, ARRAYSIZE(szServer))) {
        wcscpy( szServer, L"*");
    }

    if (_snwprintf(
               szFilter,
               ARRAYSIZE(szFilter),
               FILTER_QUERY_SERVER, 
               szServer) < 0) {
        hr = THR(E_INVALIDARG);
        goto Error;
    }

    szFilter[ARRAYSIZE(szFilter) -1] = L'\0';
    
    DebugMsg( "RI Filter: %s\n", szFilter );

    // compute the size of the new query block
    // Did they hand in a query that we need to modify?
    if ( !*ppdsqp )
    {
        CallerSpecifiedQuery = FALSE;
        
        //bugbug arraysize(srvcolumns)-1) == 0?
        offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(srvcolumns)-1)*sizeof(DSCOLUMN));
        cbStruct += StringByteSize(szFilter);
        for ( i = 0; i < ARRAYSIZE(srvcolumns); i++ )
        {
            cbStruct += StringByteSize(srvcolumns[i].pDisplayProperty);
        }
    }
    else
    {
        CallerSpecifiedQuery = TRUE;
        LPWSTR pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        offset = (*ppdsqp)->cbStruct;
        
        //
        // save off the size that we're gonna need.
        // note that when we concatenate the current query with our query, 
        // we need to make sure the query starts with "(&".  If it doesn't
        // already, then we make this the case -- the buffer szFilter contains
        // these bytes, which ensures that cbStruct is large enough.  If the current
        // query contains these strings, then the allocated buffer is a little
        // bigger than it needs to be.
        cbStruct = (*ppdsqp)->cbStruct + StringByteSize( pszQuery ) + StringByteSize( szFilter );
        
        //
        // do some extra query validation.
        // does the query start with "(&"?
        //        
        if (pszQuery[0] == L'(' && pszQuery[1] == L'&' ) {
            CallerQueryStartsWithAmpersand = TRUE;
            //
            //  we're assuming below that if the specified query
            //  doesn't start with "(&", that it will end with ")".
            //  If that's not the case then bail out.
            //
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] == L')' );
            if (pszQuery[ wcslen( pszQuery ) - 1 ] != L')' ) {
                hr = E_INVALIDARG;
                goto Error;
            }
        } else {
            //
            // conversely, if the query doesn't start with '(&', then
            // we assume that the query doesn't end with ')', and if it
            // does, we bail
            //
            CallerQueryStartsWithAmpersand = FALSE;
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] != L')' );
            if (pszQuery[ wcslen( pszQuery ) - 1 ] == L')' ) {
                hr = E_INVALIDARG;
                goto Error;
            }
        }
    }

    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.
    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);
    if ( !pDsQueryParams )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Did they hand in a query that we need to modify?
    if ( !CallerSpecifiedQuery)
    {   // no... create our own query
        pDsQueryParams->cbStruct = cbStruct;
        pDsQueryParams->dwFlags = 0;
        pDsQueryParams->hInstance = g_hInstance;
        pDsQueryParams->offsetQuery = offset;
        pDsQueryParams->iColumns = ARRAYSIZE(srvcolumns);

        // Copy the filter string and bump the offset
        StringByteCopy(pDsQueryParams, offset, szFilter);
        offset += StringByteSize(szFilter);

        // Fill in the array of columns to dispaly, the cx is a percentage of the
        // current view, the propertie names to display are UNICODE strings and
        // are referenced by offset, therefore we bump the offset as we copy
        // each one.

        for ( i = 0 ; i < ARRAYSIZE(srvcolumns); i++ )
        {
            pDsQueryParams->aColumns[i].fmt = srvcolumns[i].fmt;
            pDsQueryParams->aColumns[i].cx = srvcolumns[i].cx;
            pDsQueryParams->aColumns[i].idsName = srvcolumns[i].uID;
            pDsQueryParams->aColumns[i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, srvcolumns[i].pDisplayProperty);
            offset += StringByteSize(srvcolumns[i].pDisplayProperty);
        }
    }
    else
    {   // yes, caller specified a query... add our parameters to the query
        LPWSTR pszQuery;
        LPWSTR pszNewQuery;
        INT    n;

        // duplicate the existing query
        Assert( offset == (*ppdsqp)->cbStruct );
        CopyMemory( pDsQueryParams, *ppdsqp, offset );
        pDsQueryParams->cbStruct = cbStruct;

        // new query location
        pDsQueryParams->offsetQuery = offset;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        pszNewQuery = (LPWSTR) ((LPBYTE)pDsQueryParams + offset);
        Assert( pszQuery );

        // append to their query
        if ( CallerQueryStartsWithAmpersand ) {
            //
            // remove ")" from current query so that we can
            // add in our additional filter.  We've got the trailing ")" in our
            // filter.
            // Also note that we can't really fail at this point, and we're 
            // about to free the caller's memory so it's ok for us to overwrite their
            // query text.
            //
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] == L')' );
            pszQuery[ wcslen( pszQuery ) - 1 ] = L'\0'; // remove ")"

            // start with their query
            wcscpy(pszNewQuery, pszQuery);

            //
            // put it back to be a good citizen ")"
            //
            pszQuery[ wcslen( pszQuery )] = L')';

            //
            // now tack on our query, skipping the "(&" part
            //
            wcscat(pszNewQuery,&szFilter[2]);

        } else {
            Assert( pszQuery[ wcslen( pszQuery ) - 1 ] != L')' );
            wcscpy( pszNewQuery, L"(&" );               // add "(&" to begining of query
            wcscat( pszNewQuery, pszQuery );                // add their query
            wcscat( pszNewQuery, &szFilter[2] );            // add our query starting after the "(&"
        }

        offset += StringByteSize( pszNewQuery );        // compute new offset
        DebugMsg( "New Query String: %s\n", pszNewQuery );

        // Cleanup
        CoTaskMemFree( *ppdsqp );
    }

    // Success
    *ppdsqp = pDsQueryParams;
    Assert( hr == S_OK );

Cleanup:
    HRETURN(hr);
Error:
    if ( pDsQueryParams )
        CoTaskMemFree( pDsQueryParams );

    // If we aren't modifying the query and there wasn't
    // a query handed into us, indicate failure instead.
    if ( hr == S_FALSE && !*ppdsqp )
    {
        Assert(FALSE); // how did we get here?
        hr = E_FAIL;
    }
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\serverqy.h ===
//
// Copyright 1997 - Microsoft

//
// DPGUIDQY.H - The duplicate GUID query form
//


#ifndef _SERVERQY_H_
#define _SERVERQY_H_

// QITable
BEGIN_QITABLE( CRISrvQueryForm )
DEFINE_QI( IID_IQueryForm, IQueryForm, 3 )
END_QITABLE

// Definitions
LPVOID
CRISrvQueryForm_CreateInstance( void );

// CRISrvQueryForm
class CRISrvQueryForm
    : public IQueryForm
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CRISrvQueryForm );

    HWND        _hDlg;

private: // methods
    CRISrvQueryForm( );
    ~CRISrvQueryForm( );
    HRESULT
        Init( void );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static HRESULT CALLBACK
        PropSheetPageProc( LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _GetQueryParams( HWND hwnd, LPDSQUERYPARAMS* ppdsqp );

public: // methods
    friend LPVOID CRISrvQueryForm_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IQueryForm methods
    STDMETHOD(Initialize)(HKEY hkForm);
    STDMETHOD(AddForms)(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);
};

typedef CRISrvQueryForm * LPCRISrvQueryForm;


#endif // _DPGUIDQY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\sifprop.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SIFPROP.CPP - Handles the "SIF Properties" IDC_SIF_PROP_IMAGES
//               and IDD_SIF_PROP_TOOLS dialogs
//


#include "pch.h"
#include "sifprop.h"
#include "utils.h"
#include "shellapi.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CSifProperties")
#define THISCLASS CSifProperties
#define LPTHISCLASS CSifProperties*

#define NUM_COLUMNS				    3

DWORD aSifHelpMap[] = {
    IDC_E_DESCRIPTION, HIDC_E_DESCRIPTION,
    IDC_E_HELP, HIDC_E_HELP,
    IDC_S_VERSION, HIDC_S_VERSION,
    IDC_S_LANGUAGE, HIDC_S_LANGUAGE,
    IDC_S_LASTMODIFIED, HIDC_S_LASTMODIFIED,
    IDC_S_IMAGETYPE, HIDC_S_IMAGETYPE,
    IDC_S_DIRECTORY, HIDC_S_DIRECTORY,
    IDC_G_IMAGEDETAILS, HIDC_G_IMAGEDETAILS,
    NULL, NULL
};

//
// CreateInstance()
//
HRESULT
CSifProperties_CreateInstance(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF )
{
	TraceFunc( "CSifProperties_CreateInstance( )\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = lpcc->Init( hParent, lpszTemplate, pSIF );

    delete lpcc;

    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CSifProperties()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF )
{
    HRESULT hr;

    TraceClsFunc( "Init( ... )\n" );

    Assert( pSIF );
    _pSIF = pSIF;

    INT i = (INT)DialogBoxParam( g_hInstance, lpszTemplate, hParent, PropSheetDlgProc, (LPARAM) this );

    switch( i )
    {
    case IDOK:
        hr = S_OK;
        break;

    case IDCANCEL:
        hr = S_FALSE;
        break;

#ifdef DEBUG
    default:
        hr = THR(E_FAIL);
        break;
#endif // DEBUG
    }

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CSifProperties()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr = S_OK;
    WCHAR   szTempBuffer[ 256 ];
    WCHAR   szTmp[ 128 ];
    WCHAR   szTmp2[ 128 ];
    FILETIME   ftLocal;
    SYSTEMTIME stSystem;

    _hDlg = hDlg;

    Assert( _pSIF );
    SetDlgItemText( hDlg, IDC_E_DESCRIPTION, _pSIF->pszDescription);
    SetDlgItemText( hDlg, IDC_E_HELP,        _pSIF->pszHelpText);
    SetDlgItemText( hDlg, IDC_S_IMAGETYPE,   _pSIF->pszImageType);
    SetDlgItemText( hDlg, IDC_S_LANGUAGE,    _pSIF->pszLanguage);
    SetDlgItemText( hDlg, IDC_S_VERSION,     _pSIF->pszVersion);
    SetDlgItemText( hDlg, IDC_S_DIRECTORY,   _pSIF->pszDirectory );

    Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION), REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT - 1 );
    Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELP),        REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT - 1 );

    FileTimeToLocalFileTime( &_pSIF->ftLastWrite, &ftLocal);
    FileTimeToSystemTime( &ftLocal, &stSystem);
    if ( !GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stSystem, NULL, szTmp, ARRAYSIZE(szTmp)) ||
         !GetTimeFormat(LOCALE_USER_DEFAULT, 0, &stSystem, NULL, szTmp2, ARRAYSIZE(szTmp2)) || 
         _snwprintf( szTempBuffer,
                     ARRAYSIZE(szTempBuffer),
                     L"%s, %s",
                     szTmp, szTmp2) < 0 ) {
        hr = E_INVALIDARG;
    } else {
        SetDlgItemText( hDlg, IDC_S_LASTMODIFIED, szTempBuffer );
    }
    
    HRETURN(hr);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDOK:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            Assert( _pSIF );
            WCHAR szTempBuffer[  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 +1 ]; // +2 = the "Quotes"  + NULL

            Assert( REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT <=  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ); // paranoid

            szTempBuffer[0] = L'\"';
            GetDlgItemText( _hDlg, IDC_E_DESCRIPTION, &szTempBuffer[1], REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
            wcscat( szTempBuffer, L"\"" );

            if ( VerifySIFText( szTempBuffer ) )
            {
                if (!WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                           OSCHOOSER_DESCRIPTION_ENTRY,
                                           szTempBuffer,
                                           _pSIF->pszFilePath)) {
                    MessageBoxFromError( _hDlg, NULL, GetLastError());
                    break;
                }
            }
            else
            {
                MessageBoxFromStrings( _hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( _hDlg, IDC_E_DESCRIPTION ) );
                break;
            }

            szTempBuffer[0] = L'\"';
            GetDlgItemText( _hDlg, IDC_E_HELP, &szTempBuffer[1],  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
            wcscat( szTempBuffer, L"\"" );

            if ( VerifySIFText( szTempBuffer ) )
            {
                if (!WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                           OSCHOOSER_HELPTEXT_ENTRY,
                                           szTempBuffer,
                                           _pSIF->pszFilePath)) {
                    MessageBoxFromError( _hDlg, NULL, GetLastError());
                }
            }
            else
            {
                MessageBoxFromStrings( _hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( _hDlg, IDC_E_HELP ) );
                break;
            }

            EndDialog( _hDlg, LOWORD( wParam ) );
        }
        break;

    case IDCANCEL:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            EndDialog( _hDlg, LOWORD( wParam ) );
        }
        break;

    case IDC_E_DESCRIPTION:
    case IDC_E_HELP:
        if ( HIWORD( wParam ) == EN_CHANGE ) {
            DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_DESCRIPTION) );
            DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_HELP) );
            EnableWindow( GetDlgItem( _hDlg, IDOK ), !( dwLen1==0 || dwLen2==0) );
        }
        break;

    case IDC_BUTTON1:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            SHELLEXECUTEINFO shexinfo = { 0 };
            Assert( _pSIF );
            shexinfo.cbSize = sizeof(shexinfo);
            shexinfo.fMask = SEE_MASK_INVOKEIDLIST;
            shexinfo.hwnd = hwndCtl;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = _pSIF->pszFilePath;
            shexinfo.lpVerb = L"properties";
            ShellExecuteEx(&shexinfo);
        }
        break;

    }

    RETURN((SUCCEEDED(hr) ? TRUE : FALSE));
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    // TraceFunc( "PropSheetDlgProc()\n" );
    // TraceMsg( TF_WM, "hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x\n",
       // hDlg, uMsg, wParam, lParam );

    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        Assert( lParam );
        SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );
        lpc = (LPTHISCLASS) lParam;
        lpc->_InitDialog( hDlg );
        return TRUE;
    }

    if ( lpc )
    {
        switch( uMsg )
        {

        case WM_COMMAND:
            TraceMsg( TF_WM, "WM_COMMAND\n" );
            return lpc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aSifHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aSifHelpMap );
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\sifprop.h ===
//
// Copyright 1997 - Microsoft
//

//
// SIFPROP.H - Handles the "SIF Properties" IDC_SIF_PROP_IMAGES
//             and IDD_SIF_PROP_TOOLS dialogs
//


#ifndef _SIFPROP_H_
#define _SIFPROP_H_

// Definitions
HRESULT
CSifProperties_CreateInstance(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF );

// CSifProperties
class
CSifProperties
{
private:
    HWND  _hDlg;
    LPSIFINFO _pSIF;

private: // Methods
    CSifProperties();
    ~CSifProperties();
    STDMETHOD(Init)( HWND hParent, LPCTSTR lpszTemplate, LPSIFINFO pSIF );

    // Property Sheet Functions
    HRESULT _InitDialog( HWND hDlg );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

public: // Methods
    friend HRESULT CSifProperties_CreateInstance( HWND hParent, LPCTSTR lpszTemplate, LPSIFINFO pSIF );
};

typedef CSifProperties* LPCSIFPROPERTIES;

#endif // _SIFPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\tools.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _TOOLS_H_
#define _TOOLS_H_

// Definitions
LPVOID
CToolsTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CToolsTab
class
CToolsTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to owner object

    BOOL    _fAdmin;

    HWND    _hNotify;           // DSA's notify object

private: // Methods
    CToolsTab();
    ~CToolsTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    HRESULT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _OnSelectionChanged( );

public: // Methods
    friend LPVOID CToolsTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CToolsTab* LPCToolsTab;

#endif // _TOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\tools.cpp ===
//
// Copyright 1997 - Microsoft

//
// TOOLS.CPP - Handles the "Tools" IDD_PROP_TOOLS tab
//


#include "pch.h"

#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "tools.h"
#include "ccomputr.h"
#include "sifprop.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CToolsTab")
#define THISCLASS CToolsTab
#define LPTHISCLASS CToolsTab*

#define NUM_COLUMNS				    3

DWORD aToolsHelpMap[] = {
    IDC_L_TOOLS, HIDC_L_TOOLS,
    IDC_B_REMOVE, HIDC_B_REMOVE,
    IDC_B_PROPERTIES, HIDC_B_PROPERTIES,
    IDC_B_REFRESH, HIDC_B_REFRESH,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CToolsTab_CreateInstance( void )
{
    TraceFunc( "CToolsTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( FAILED(hr)) {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( ) :
    _hDlg(NULL),
    _punkService(NULL),
    _fAdmin(FALSE),
    _hNotify(NULL)
{
    TraceClsFunc( "CToolsTab()\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CToolsTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
                   LPFNADDPROPSHEETPAGE lpfnAddPage,
                   LPARAM lParam,
                   LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_TOOLS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage ) {
        if ( !lpfnAddPage( hpage, lParam ) ) {
            DestroyPropertySheetPage( hpage );
            hr = E_FAIL;
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

    Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                      LPARAM lParam,
                      LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
                           LPWSTR pszAttribute,
                           LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
                          BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************


//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
                      HWND hDlg,
                      LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;

    HRESULT hr = S_OK;
    HWND hwndList;

    IIntelliMirrorSAP * pimsap = NULL;
    IEnumIMSIFs * penum = NULL;
    LV_COLUMN lvC;
    INT iCount;
    WCHAR szText[ 64 ];
    UINT uColumnWidths[NUM_COLUMNS] = { 225, 75, 75};

    if ( hDlg ) {
        _hDlg = hDlg;
    }

    hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr )) {
        goto Error;
    }

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
    }

    hr = THR( pimsap->EnumTools( ENUM_READ, (LPUNKNOWN*)&penum ) );
    if (FAILED(hr)) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    ListView_DeleteAllItems( hwndList );

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ ) {
        INT i;

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidths[iCount];

        if (!LoadString( g_hInstance, IDS_OS_COLUMN1 + iCount, szText, ARRAYSIZE (szText) ) ||
            -1 == ListView_InsertColumn ( hwndList, iCount, &lvC )) {
            hr = E_FAIL;
            goto Error;
        }

    }

    if (FAILED(hr = PopulateListView( hwndList, penum ))) {
        MessageBoxFromStrings( _hDlg,
                               IDS_COULDNOTCONTACTSERVER_CAPTION,
                               IDS_COULDNOTCONTACTSERVER_TEXT,
                               MB_OK | MB_ICONERROR );
    }
    Cleanup:
    if ( penum )
        penum->Release( );
    if ( pimsap )
        pimsap->Release( );

    EnableWindow( hwndList, _fAdmin );

    HRETURN(hr);

    Error:

    MessageBoxFromHResult( _hDlg, IDS_ERROR_OPENNINGGROUPOBJECT, hr );
    goto Cleanup;
}

//
// _OnSelectionChanged( )
//
HRESULT
THISCLASS::_OnSelectionChanged( )
{
    TraceClsFunc( "_OnSelectionChanged( )\n" );

    HRESULT hr = S_OK;
    UINT iItems = ListView_GetSelectedCount( GetDlgItem( _hDlg, IDC_L_TOOLS ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_REMOVE ), !!iItems );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_PROPERTIES ), !!iItems );

    HRETURN( hr );
}

//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch ( LOWORD(wParam) ) {
    case IDC_B_PROPERTIES:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            if ( lvi.iItem != -1 ) {
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                Assert(lvi.lParam);
                hr = CSifProperties_CreateInstance( _hDlg, MAKEINTRESOURCE(IDD_SIF_PROP_TOOLS), (LPSIFINFO) lvi.lParam );
            }
        }
        break;

    case IDC_B_REFRESH:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            hr = S_OK;
        }
        break;

    case IDC_B_REMOVE:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            UINT iResult;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            iResult = MessageBoxFromStrings( _hDlg, IDS_AREYOUSURE_CAPTION, IDS_DELETESIF_TEXT, MB_YESNO );
            if ( iResult == IDYES ) {
                if ( lvi.iItem != -1 ) {
                    LPSIFINFO psif;

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );

                    psif = (LPSIFINFO)lvi.lParam;

                    if ( !DeleteFile( psif->pszFilePath ) ) {
                        ::MessageBoxFromError( _hDlg, 0, GetLastError() );
                    } else {
                        ListView_DeleteItem( hwndList, lvi.iItem );
                        hr = S_OK;
                    }
                }
            }
        }
        break;
    }

    if ( hr == S_OK ) {
        HWND hwndList = GetDlgItem(_hDlg, IDC_L_TOOLS);
        IIntelliMirrorSAP * pimsap = NULL;
        hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
        if (hr == S_OK) {
            LPENUMSIFS penum = NULL;
            hr = THR( pimsap->EnumTools( ENUM_READ, (LPUNKNOWN*)&penum ) );
            if ( hr == S_OK ) {
                hr = PopulateListView( hwndList, penum);
                penum->Release();
            }
            pimsap->Release();
        }

        // See if we still have a selection
        _OnSelectionChanged( );
    }

    HRETURN(hr);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
                    WPARAM wParam,
                    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch ( lpnmhdr->code ) {
    case PSN_APPLY:
        TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
        // Tell DSA that someone hit Apply
        SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, 0, 0 );
        SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, PSNRET_NOERROR );
        RETURN(TRUE);

    case LVN_ITEMCHANGED:
        {
            _OnSelectionChanged( );
        }
        break;

    case LVN_DELETEALLITEMS:
        DebugMsg( "LVN_DELETEALLITEMS - Deleting all items.\n" );
        RETURN(FALSE);

    case LVN_DELETEITEM:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
            LPSIFINFO psif = (LPSIFINFO) pnmv->lParam;
            Assert( psif );

            if ( psif ) {
                if (psif->pszArchitecture) {
                    TraceFree( psif->pszArchitecture );
                }
                if (psif->pszDescription) {
                    TraceFree( psif->pszDescription );
                }
                if (psif->pszDirectory) {
                    TraceFree( psif->pszDirectory );
                }
                if (psif->pszFilePath) {
                    TraceFree( psif->pszFilePath );
                }
                if (psif->pszHelpText) {
                    TraceFree( psif->pszHelpText );
                }
                if (psif->pszImageType) {
                    TraceFree( psif->pszImageType );
                }
                if (psif->pszLanguage) {
                    TraceFree( psif->pszLanguage );
                }
                if (psif->pszVersion) {
                    TraceFree( psif->pszVersion );
                }
                if (psif->pszImageFile) {
                    TraceFree( psif->pszImageFile );
                }

                TraceFree( psif );
            }
        }
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
                           HWND hDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG ) {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc) {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg ) {
        case WM_NOTIFY:
            pcc->_OnNotify( wParam, lParam );
            break;

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aToolsHelpMap );
            }
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aToolsHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
                            HWND hwnd,
                            UINT uMsg,
                            LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
              hwnd, uMsg, ppsp );

    switch ( uMsg ) {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\utils.h ===
//
// Copyright 1997 - Microsoft
//

//
// UTILS.H - Common non-class specific utility calls.
//

#ifndef _UTILS_H_
#define _UTILS_H_

#include "cenumsif.h"

///////////////////////////////////////
//
// globals
//

// GUID text size
#define PRETTY_GUID_STRING_BUFFER_SIZE  sizeof(L"{AC409538-741C-11d1-BBE6-0060081692B3}")
#define MAX_INPUT_GUID_STRING       56  // abitrary; allows for spaces in pasted GUIDs

///////////////////////////////////////
//
// structs, enums
//

typedef struct {
    LPWSTR pszFilePath;
    LPWSTR pszDescription;
    LPWSTR pszDirectory;
    LPWSTR pszHelpText;
    LPWSTR pszVersion;
    LPWSTR pszLanguage;
    LPWSTR pszArchitecture;
    LPWSTR pszImageType;
    LPWSTR pszImageFile;
    FILETIME ftLastWrite;
} SIFINFO, *LPSIFINFO;


///////////////////////////////////////
//
// functions
//

HRESULT
AddPagesEx(
    ITab ** pTab,
    LPCREATEINST pfnCreateInstance,
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam,
    LPUNKNOWN );

HRESULT
CheckClipboardFormats( );

HRESULT
DNtoFQDN( 
    LPWSTR pszDN,
    LPWSTR * pszFQDN );

HRESULT
DNtoFQDNEx( 
    LPWSTR pszDN,
    LPWSTR * pszFQDN );

HRESULT
GetDomainDN( 
    LPWSTR pszDN,
    LPWSTR * pszDomainDn);

HRESULT
PopulateListView( 
    HWND hwndList, 
    IEnumIMSIFs * penum );

HRESULT 
FixObjectPath( 
    LPWSTR Object,
    LPWSTR pszOldObjectPath, 
    LPWSTR *ppszNewObjectPath );

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

void
MessageBoxFromError(
    HWND hParent,
    UINT idsCaption,
    DWORD dwErr );

void
MessageBoxFromHResult(
    HWND hParent,
    UINT idsCaption,
    HRESULT hr );

BOOL
VerifySIFText(
    LPWSTR pszText );

#ifndef ADSI_DNS_SEARCH
#include <winldap.h>
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle );
#endif // ADSI_DNS_SEARCH

HRESULT
ValidateGuid(
    IN LPWSTR pszGuid,
    OUT LPGUID Guid OPTIONAL,
    OUT LPDWORD uGuidLength OPTIONAL );

LPWSTR
PrettyPrintGuid( 
    IN LPGUID uGuid 
    );

HRESULT
CheckForDuplicateGuid(
    IN LPGUID uGuid );

void 
AddWizardPage(
    LPPROPSHEETHEADER ppsh, 
    UINT id, 
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle,
    LPARAM lParam );

class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\utils.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

//
// UTILS.CPP - Common non-class specific utility calls.
//


#include "pch.h"

#include <dsgetdc.h>
#include <lm.h>
#include "cenumsif.h"
#include "utils.h"

#include <dsadmin.h>

DEFINE_MODULE("IMADMUI")

#define SMALL_BUFFER_SIZE       256
#define OSVERSION_SIZE          30
#define IMAGETYPE_SIZE          30
#define FILTER_GUID_QUERY L"(&(objectClass=computer)(netbootGUID=%ws))"

WCHAR g_wszLDAPPrefix[] = L"LDAP://";
const LONG SIZEOF_g_wszLDAPPrefix = sizeof(g_wszLDAPPrefix);

//
// AddPagesEx()
//
// Creates and adds a property page.
//
HRESULT
AddPagesEx(
    ITab ** pTab,
    LPCREATEINST pfnCreateInstance,
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam,
    LPUNKNOWN punk )
{ 
    TraceFunc( "AddPagesEx( ... )\n" );

    HRESULT hr = S_OK;
    ITab * lpv;

    if ( pTab == NULL )
    {
        pTab = &lpv;
    }

    *pTab = (LPTAB) pfnCreateInstance( );
    if ( !*pTab )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = THR( (*pTab)->AddPages( lpfnAddPage, lParam, punk ) );
    if (FAILED(hr)) {        
        goto Error;
    }

Cleanup:
    RETURN(hr); 

Error:
    if ( *pTab )
    {
        delete *pTab;
        *pTab = NULL;
    }

    goto Cleanup;
} 


//
// CheckClipboardFormats( )
//
HRESULT
CheckClipboardFormats( )
{
    TraceFunc( "CheckClipboardFormats( )\n" );

    HRESULT hr = S_OK;

    if ( !g_cfDsObjectNames )
    {
        g_cfDsObjectNames = RegisterClipboardFormat( CFSTR_DSOBJECTNAMES );
        if ( !g_cfDsObjectNames )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfDsDisplaySpecOptions && hr == S_OK )
    {
        g_cfDsDisplaySpecOptions = RegisterClipboardFormat( CFSTR_DS_DISPLAY_SPEC_OPTIONS );
        if ( !g_cfDsDisplaySpecOptions )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfDsPropetyPageInfo && hr == S_OK )
    {
        g_cfDsPropetyPageInfo = RegisterClipboardFormat( CFSTR_DSPROPERTYPAGEINFO );
        if ( !g_cfDsObjectNames )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfMMCGetNodeType && hr == S_OK )
    {
        g_cfMMCGetNodeType = RegisterClipboardFormat( CCF_NODETYPE );
        if ( !g_cfMMCGetNodeType )
        {
            hr = E_FAIL;
        }
    }


    RETURN(hr);
}

         
//
// DNtoFQDN( )
//
// Changes a MAO DN to and FQDN. 
//
// Input:   pszDN - string e.g cn=HP,cn=computers,dc=GPEASE,dc=DOM
//
// Output:  *pszFQDN - LocalAlloc'ed string with the generated FQDN
//
HRESULT
DNtoFQDN( 
    IN  LPWSTR pszDN,
    OUT LPWSTR * pszFQDN )
{
    TraceFunc( "DNtoFQDN( " );
    TraceMsg( TF_FUNC, "pszDN = '%s', *pszFQDN = 0x%08x )\n", pszDN, (pszFQDN ? *pszFQDN : NULL) );

    HRESULT hr = S_OK;
    LPWSTR  pszNext;
    LPWSTR  psz;
          
    if (0 != StrCmpNI( pszDN, L"cn=", 3 ) ||
        NULL == StrStrI( pszDN, L"dc=" )) {
        Assert( pszDN ); // this shouldn't happen
        hr = THR(E_INVALIDARG);
        goto Error;
    }

    // skip the "cn=" and duplicate
    *pszFQDN = (LPWSTR) TraceStrDup( &pszDN[3] );
    if ( !*pszFQDN )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    pszNext = *pszFQDN;
    while ( pszNext && *pszNext )
    {
        psz = StrChr( pszNext, L',' );
        if ( !psz ) {
            break;
        }

        *psz = L'.';
        pszNext = psz;
        pszNext++;

        psz = StrStrI( pszNext, L"dc=" );
        Assert( psz ); // this shouldn't happen
        if (!psz) {
            break;
        }

        psz += 3;
        StrCpy( pszNext, psz );
    }

Error:
    HRETURN(hr);
}

HRESULT
DNtoFQDNEx(
    LPWSTR pszDN,
    LPWSTR * pszFQDN )
/*++

Routine Description:

    Given a DN for the RIS SCP, figure out the FQDN of the
    RIS server.  We do this by querying the DN for the 
    "dNSHostName" attribute.  The caller can get the DN for the object
    by reading the netbootserver attribute from the SCP.

Arguments:

    pszDN - The server DN.
    pszFQDN - receives the FQDN of the server.  Must be freed via
            TraceFree();

Return Value:

    HRESULT indicating outcome.    
--*/
{
    PLDAP LdapHandle = NULL;
    PWCHAR * Base;
    DWORD LdapError;
    DWORD entryCount;
    HRESULT hresult = S_OK;
    
    PLDAPMessage LdapMessage;

    PWCHAR * DnsName;
    
    PLDAPMessage CurrentEntry;

    WCHAR Filter[128];
    
    //  Paramters we want from the Computer Object
    PWCHAR ComputerAttrs[2];

    //
    // all we care about is the dNSHostName attribute.
    //
    ComputerAttrs[0] = &L"dNSHostName";
    ComputerAttrs[1] = NULL;

    //
    // just computer objects
    //
    wsprintf( Filter, L"(objectClass=computer)" );

    //
    // initialize a valid ldap handle
    //
    LdapHandle = ldap_init( NULL, LDAP_PORT);
    if (!LdapHandle || 
        (LDAP_SUCCESS != ldap_connect(LdapHandle,0)) ||
        (LDAP_SUCCESS != ldap_bind_s(LdapHandle, NULL, NULL, LDAP_AUTH_NEGOTIATE))) {
        goto e0;
    }

    //
    // search from the passed in DN.
    //
    LdapError = ldap_search_s(LdapHandle,
                              pszDN,
                              LDAP_SCOPE_BASE,
                              Filter,
                              ComputerAttrs,
                              FALSE,
                              &LdapMessage);

    if ( LdapError != LDAP_SUCCESS ) {
        hresult=E_FAIL;
        goto e1;
    }

    //  Did we get a Computer Object?
    entryCount = ldap_count_entries( LdapHandle, LdapMessage );
    if ( entryCount == 0 ) {
        hresult=E_FAIL;
        goto e1;        
    }

    //
    // we should really only get one hit, but... if we get more than more
    // entry back, we will use only the first one.
    //
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    //
    // retreive the value.
    //
    DnsName = ldap_get_values( LdapHandle, CurrentEntry, L"dNSHostName");
    if ( DnsName ) {

        *pszFQDN = (LPWSTR) TraceStrDup( (LPWSTR)*DnsName );
        if (!*pszFQDN) {
            hresult=E_FAIL;
        }

        ldap_value_free( DnsName );
    
    }

    //
    // cleanup and return
    //
e1:
    ldap_msgfree( LdapMessage );
e0:
    if (LdapHandle) {
        ldap_unbind_s(LdapHandle);
    }

    return(hresult);

}



HRESULT
GetDomainDN( 
    LPWSTR pszDN,
    LPWSTR * pszDomainDn)
/*++

Routine Description:

    Given a server name, we retrive the DN of the domain that machine
    is in.  This is done just by moving the the dc portion of the DN.

Arguments:

    pszDN - the source DN
    pszDomainDn - receives the domain DN.  Must be freed via TraceFree().

Return Value:

    HRESULT indicating outcome.

--*/
{
    TraceFunc( "GetDomainDN( " );
    TraceMsg( TF_FUNC, "pszDN = '%s', *pszFQDN = 0x%08x )\n", pszDN, (pszDomainDn ? *pszDomainDn : NULL) );

    HRESULT hr = S_OK;
    
    LPWSTR  pszNext = StrStrI(pszDN, L"dc=");

    if (pszNext) {
        *pszDomainDn = (LPWSTR) TraceStrDup( pszNext );
        if (!*pszDomainDn) {
            hr = THR(E_OUTOFMEMORY);            
        }
    } else {
        hr = THR(E_INVALIDARG);
    }

    HRETURN(hr);
}

//
// PopulateListView( )
//
HRESULT
PopulateListView( 
    HWND hwndList, 
    IEnumIMSIFs * penum )
{
    TraceFunc( "PopulateListView( ... )\n" );

    HRESULT hr = S_OK;
    INT iCount;
    LV_ITEM lvI;

    if ( !penum )
        HRETURN(E_POINTER);

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT;

    ListView_DeleteAllItems( hwndList );

    iCount = 0;
    while ( hr == S_OK )
    {
        WIN32_FILE_ATTRIBUTE_DATA fda;
        WCHAR szBuf[ MAX_PATH ];
        LPSIFINFO pSIF;
        LPWSTR pszFilePath;
        LPWSTR pszBegin;
        INT i;  // general purpose
        
        hr = penum->Next( 1, &pszFilePath, NULL );
        if ( hr != S_OK )
        {
            if ( pszFilePath ) {
                TraceFree( pszFilePath );
                pszFilePath = NULL;
            }
            break;  // abort
        }

        // Create private storage structure
        pSIF = (LPSIFINFO) TraceAlloc( LPTR, sizeof(SIFINFO) );
        if ( !pSIF )
        {
            if ( pszFilePath ) {
                TraceFree( pszFilePath );
                pszFilePath = NULL;    
            }
            continue;   // oh well, try again next OS
        }

        // Save this
        pSIF->pszFilePath = pszFilePath;

        // Get the description
        pSIF->pszDescription = (LPWSTR) TraceAllocString( LMEM_FIXED, REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
        if ( !pSIF->pszDescription ) {
            goto Cleanup;            
        }
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_DESCRIPTION_ENTRY, 
                                 L"??", 
                                 pSIF->pszDescription,
                                 REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT,  // doesn't need -1
                                 pszFilePath );

        // Grab any help text
        pSIF->pszHelpText = (LPWSTR) TraceAllocString( LMEM_FIXED, REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
        if ( !pSIF->pszHelpText ) {
            goto Cleanup;
        }
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_HELPTEXT_ENTRY, 
                                 L"", 
                                 pSIF->pszHelpText,
                                 REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT, // doesn't need -1
                                 pszFilePath );

        // Grab the OS Version
        pSIF->pszVersion= (LPWSTR) TraceAllocString( LMEM_FIXED, OSVERSION_SIZE );
        if ( !pSIF->pszVersion ) {
            goto Cleanup;
        }
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_VERSION_ENTRY, 
                                 L"", 
                                 pSIF->pszVersion,
                                 OSVERSION_SIZE, 
                                 pszFilePath );

        // Grab the last modified Time/Date stamp
        if ( GetFileAttributesEx( pszFilePath, GetFileExInfoStandard, &fda ) )
        {
            pSIF->ftLastWrite = fda.ftLastWriteTime;
        } else {
            ZeroMemory( &pSIF->ftLastWrite, sizeof(pSIF->ftLastWrite) );
        }

        // Figure out the language and architecture. 
        // These are retrieved from the FilePath.
        // \\machine\REMINST\Setup\English\Images\nt50.wks\i386\templates\rbstndrd.sif
        pszBegin = pSIF->pszFilePath;
        for( i = 0; i < 5; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin ) {
                break;
            }

            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd ) {
                *pszEnd = L'\0';   // terminate
                //
                // it's not fatal if we don't find this, but if we fail to
                // allocate memory for it, it is fatal
                //
                pSIF->pszLanguage = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';   // restore
                if ( !pSIF->pszLanguage ) {
                    goto Cleanup;
                }
            }
        }

        Assert( pSIF->pszLanguage );
        for( ; i < 7; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin ) {
                break;
            }
            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd )
            {
                *pszEnd = L'\0';
                //
                // it's not fatal if we don't find this, but if we fail to
                // allocate memory for it, it is fatal
                //
                pSIF->pszDirectory = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';
                if ( !pSIF->pszDirectory ) {
                    goto Cleanup;
                }
            }
        }

        Assert( pSIF->pszDirectory );
        for( ; i < 8; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin ) {
                break;
            }
            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd )
            {
                *pszEnd = L'\0';
                //
                // it's not fatal if we don't find this, but if we fail to
                // allocate memory for it, it is fatal
                //
                pSIF->pszArchitecture = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';
                if ( !pSIF->pszArchitecture ) {
                    goto Cleanup;
                }
            }
        }

        // Figure out what kind of image it is
        pSIF->pszImageType = (LPWSTR) TraceAllocString( LMEM_FIXED, IMAGETYPE_SIZE );
        if ( !pSIF->pszImageType ) {
            goto Cleanup;
        }
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_IMAGETYPE_ENTRY, 
                                 L"??", 
                                 pSIF->pszImageType,
                                 IMAGETYPE_SIZE, 
                                 pszFilePath );

        // Figure out what image it uses
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_LAUNCHFILE_ENTRY, 
                                 L"??", 
                                 szBuf,
                                 ARRAYSIZE( szBuf ), 
                                 pszFilePath );

        pszBegin = StrRChr( szBuf, &szBuf[wcslen(szBuf)], L'\\' );
        if ( pszBegin )
        {
            pszBegin++;
            pSIF->pszImageFile = (LPWSTR) TraceStrDup( pszBegin );
            if (!pSIF->pszImageFile) {
                goto Cleanup;
            }
        }

        // Add the item to list view
        lvI.lParam   = (LPARAM) pSIF;
        lvI.iItem    = iCount;
        lvI.pszText  = pSIF->pszDescription; 
        iCount = ListView_InsertItem( hwndList, &lvI );
        Assert( iCount != -1 );
        if ( iCount == -1 )
            goto Cleanup;
        if ( pSIF->pszArchitecture )
        {
            ListView_SetItemText( hwndList, iCount, 1, pSIF->pszArchitecture );
        }
        if ( pSIF->pszLanguage )
        {
            ListView_SetItemText( hwndList, iCount, 2, pSIF->pszLanguage );
        }
        if ( pSIF->pszVersion )
        {
            ListView_SetItemText( hwndList, iCount, 3, pSIF->pszVersion );
        }

        continue;   // next!
Cleanup:
        if ( pSIF )
        {
            if (pSIF->pszDescription != NULL) {
                TraceFree( pSIF->pszDescription );
                pSIF->pszDescription = NULL;
            }

            TraceFree( pSIF->pszFilePath );
            pSIF->pszFilePath = NULL;

            if (pSIF->pszHelpText != NULL) {
                TraceFree( pSIF->pszHelpText );
                pSIF->pszHelpText = NULL;
            }

            if (pSIF->pszImageType != NULL) {
                TraceFree( pSIF->pszImageType );
                pSIF->pszImageType = NULL;
            }

            TraceFree( pSIF->pszLanguage );
            pSIF->pszLanguage = NULL;
            
            if (pSIF->pszVersion != NULL) {
                TraceFree( pSIF->pszVersion );
                pSIF->pszVersion = NULL;
            }

            if (pSIF->pszImageFile) {
                TraceFree( pSIF->pszImageFile );
                pSIF->pszImageFile = NULL;
            }

            TraceFree( pSIF );
            pSIF = NULL;
        }
    }

    HRETURN(hr);
}




//
// LDAPPrefix( )
//
// Returns:
//     E_OUTOFMEMORY - if out of memory
//     S_OK          - added LDAP:// to the pszObjDN
//     S_FALSE       - didn't have to add anything and copied the pszObjDN
//                     into ppszObjLDAPPath
HRESULT
LDAPPrefix(
    PWSTR pszObjDN, 
    PWSTR * ppszObjLDAPPath)
{
    TraceFunc( "LDAPPrefix( ... )\n" );

    HRESULT hr;

    const ULONG cchPrefix = ARRAYSIZE(g_wszLDAPPrefix) - 1;
    ULONG cch = wcslen(pszObjDN);

    if (wcsncmp(pszObjDN, g_wszLDAPPrefix, cchPrefix))
    {
        LPWSTR psz;
        psz = (LPWSTR) TraceAllocString( LPTR, cch + cchPrefix + 1 );
        if ( !psz ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        wcscpy(psz, g_wszLDAPPrefix);
        wcscat(psz, pszObjDN);

        *ppszObjLDAPPath = psz;
        hr = S_OK;
    }
    else
    {
        *ppszObjLDAPPath = pszObjDN;
        hr = S_FALSE;
    }

Error:
    HRETURN(hr);
}

//
// _FixObjectPath( )
//
HRESULT
FixObjectPath(
    LPWSTR Object,
    LPWSTR pszOldObjectPath, 
    LPWSTR *ppszNewObjectPath )
{
    TraceFunc( "FixObjectPath()\n" );

    HRESULT hr;
    LPWSTR psz = NULL;

    *ppszNewObjectPath = NULL;

    // Try to parse the string to connect to the same server as the DSADMIN
    if ( Object && StrCmpNI( Object, L"LDAP://", 7 ) == 0 )
    {
        psz = Object + 7;
    }
    else if ( Object && StrCmpNI( Object, L"GC://", 5 ) == 0 )
    {
        psz = Object + 5;
    }

    if ( psz )
    {
        psz = StrChr( psz, L'/' );
        psz++;

        INT_PTR uLen = psz - Object;

        // get a chunk of memory, pre-zero'ed
        psz = TraceAllocString( LPTR, (size_t) uLen + wcslen( pszOldObjectPath ) + 1 );
        if ( !psz ) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        MoveMemory( psz, Object, uLen * sizeof(WCHAR) );
        wcscat( psz, pszOldObjectPath);
        *ppszNewObjectPath = psz;
    }
    else
    {   // find another server
        hr = THR( LDAPPrefix( pszOldObjectPath, ppszNewObjectPath ) );
    }

    Assert( ppszNewObjectPath || hr != S_OK );

Exit:
    HRETURN(hr);
}


//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    WCHAR szText[ SMALL_BUFFER_SIZE * 2 ];
    WCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    szCaption[0] = L'\0';
    szText[0] = L'\0';
    dw = LoadString( g_hInstance, idsCaption, szCaption, ARRAYSIZE(szCaption) );
    Assert( dw );
    dw = LoadString( g_hInstance, idsText, szText, ARRAYSIZE(szText));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// MessageBoxFromError( )
//
// Creates a error message box
//
void 
MessageBoxFromError(
    HWND hParent,
    UINT idsCaption,
    DWORD dwErr )
{
    WCHAR szTitle[ SMALL_BUFFER_SIZE ];
    LPWSTR lpMsgBuf = NULL;
    DWORD dw;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !idsCaption ) {
        idsCaption = IDS_ERROR;
    }

    szTitle[0] = L'\0';
    dw = LoadString( g_hInstance, idsCaption, szTitle, ARRAYSIZE(szTitle) );
    Assert( dw );

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        NULL 
    );

    if (lpMsgBuf == NULL) {
        AssertMsg( (lpMsgBuf != NULL), "MessageBoxFromError() called with unknown message." );
        return;
    }

    MessageBox( hParent, lpMsgBuf, szTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// MessageBoxFromError( )
//
// Creates a error message box
//
void
MessageBoxFromHResult(
    HWND hParent,
    UINT idsCaption,
    HRESULT hr )
{
    WCHAR szTitle[ SMALL_BUFFER_SIZE ];
    LPWSTR lpMsgBuf = NULL;
    DWORD dw;

    if ( SUCCEEDED( hr ) ) {
        AssertMsg( SUCCEEDED( hr ), "Why was MessageBoxFromHResult() called when the HR succeeded?" );
        return;
    }

    if ( !idsCaption ) {
        idsCaption = IDS_ERROR;
    }

    szTitle[0] = L'\0';
    dw = LoadString( g_hInstance, idsCaption, szTitle, ARRAYSIZE(szTitle) );
    Assert( dw );

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        hr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        NULL 
    );

    if (lpMsgBuf == NULL) {
        AssertMsg( (lpMsgBuf != NULL), "MessageBoxFromHResult() called with unknown message." );
        return;
    }

    MessageBox( hParent, lpMsgBuf, szTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// VerifySIFText( )
//
BOOL
VerifySIFText(
    LPWSTR pszText )
{
    TraceFunc( "VerifySIFText()\n" );
    BOOL fReturn = FALSE;

    while ( *pszText >= 32 && *pszText < 128 ) {
        pszText++;
    }

    if ( *pszText == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

//bugbug is this compiled or not?
#ifndef ADSI_DNS_SEARCH
//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    TraceFunc( "Ldap_InitializeConnection( ... )\n" );

    PLDAPMessage OperationalAttributeLdapMessage;
    PLDAPMessage CurrentEntry;

    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED |
                     DS_GC_SERVER_REQUIRED;

        *LdapHandle = ldap_init( NULL, LDAP_GC_PORT);

        if ( !*LdapHandle ) 
        {
            LdapError = LDAP_UNAVAILABLE;
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        if ( LdapError != LDAP_SUCCESS ) 
            goto e1;
    }

e0:
    RETURN( LdapError );

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}

#endif // ADSI_DNS_SEARCH

//
// ValidateGuid( )
//
// Returns: S_OK if a complete, valid GUID is in pszGuid.
//          S_FALSE if an valid but incomplete GUID is in pszGuid. "Valid but
//              incomplete" is defined below.
//          E_FAIL if an invalid character is encountered while parsing.
//
// Valid characters are 0-9, A-F, a-f and "{-}"s. All spaces are ignored.
// The GUID must appear in one of the following forms:
//
// 1. 00112233445566778899aabbccddeeff
//      This corresponds to the actual in-memory storage order of a GUID.
//      For example, it is the order in which GUID bytes appear in a
//      network trace.
//
// 2. {33221100-5544-7766-8899-aabbccddeeff}
//      This corresponds to the "standard" way of printing GUIDs. Note
//      that the "pretty" GUID shown here is the same as the GUID shown
//      above.
//
// Note that the DEFINE_GUID macro (see sdk\inc\objbase.h) for the above
// GUID would look like this:
//      DEFINE_GUID(name,0x33221100,0x5544,0x7766,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff)
//
// "Valid but incomplete" means that the input consists of an even number
// of hex characters (no lone nibbles), and if the input is in "pretty"
// format, the input must terminate at one of the dashes or after the
// second-to-the-last dash.
//
// The following are valid but incomplete entries:
//      001122
//      {33221100
//      {33221100-5544
//      {33221100-5544-7766-88
//      
// The following are invalid incomplete entries:
//      00112
//      {332211
//      {33221100-5544-77
//      

//
// In the xxxGuidCharacters arrays, values [0,31] indicate nibble positions within
// the in-memory representation of the GUID. Value 32 indicates the end of the
// GUID string. Values 33 and up indicate special characters (nul,'-','{','}') and
// are used to index into an array containing those characters.
//

#define VG_DONE     32
#define VG_NULL     33
#define VG_DASH     34
#define VG_LBRACK   35
#define VG_RBRACK   36

CHAR InMemoryFormatGuidCharacters[] = {
     1,          0,          3,          2,          5,          4,          7,          6,     
     9,          8,         11,         10,         13,         12,         15,         14,     
    17,         16,         19,         18,         21,         20,         23,         22,     
    25,         24,         27,         26,         29,         28,         31,         30,     
    VG_NULL,    VG_DONE };

CHAR PrettyFormatGuidCharacters[] = {
    VG_LBRACK,   7,          6,          5,          4,          3,          2,          1,    
     0,         VG_DASH,    11,         10,          9,          8,         VG_DASH,    15,     
    14,         13,         12,         VG_DASH,    17,         16,         19,         18,    
    VG_DASH,    21,         20,         23,         22,         25,         24,         27,     
    26,         29,         28,         31,         30,         VG_RBRACK,  VG_NULL,    VG_DONE };

WCHAR SpecialCharacters[] = {
    0,      // VG_NULL
    L'-',   // VG_DASH
    L'{',   // VG_LBRACK
    L'}',   // VG_RBRACK
    };

PWSTR ByteToHex = L"0123456789ABCDEF";

HRESULT
ValidateGuid(
    IN LPWSTR pszGuid,
    OUT LPGUID Guid OPTIONAL,
    OUT LPDWORD puGuidLength OPTIONAL )
{
    TraceFunc( "ValidateGuid( " );
    TraceMsg( TF_FUNC, "pszGuid = '%s'\n", pszGuid );

    HRESULT hr;
    LPBYTE uGuid = (LPBYTE)Guid;
    PCHAR expectedCharacter;
    CHAR e;
    WCHAR g;
    BOOL parsingPrettyFormat;
    DWORD numberOfHexDigitsParsed;

#ifdef DEBUG
    if ( uGuid != NULL ) {
        for ( e = 0; e < 16; e++ ) {
            uGuid[e] = 0;
        }
    }
#endif

    if ( *pszGuid == L'{' ) {
        expectedCharacter = PrettyFormatGuidCharacters;
        parsingPrettyFormat = TRUE;
    } else {
        expectedCharacter = InMemoryFormatGuidCharacters;
        parsingPrettyFormat = FALSE;
    }

    numberOfHexDigitsParsed = 0;

    do {

        e = *expectedCharacter++;
        do {
            g = *pszGuid++;
        } while (iswspace(g));

        switch ( e ) {
        
        case VG_NULL:
        case VG_DASH:
        case VG_LBRACK:
        case VG_RBRACK:
            if ( g != SpecialCharacters[e - VG_NULL] ) {
                if ( g == 0 ) {
                    // valid but incomplete
                    hr = S_FALSE;
                } else {
                    hr = E_FAIL;
                }
                goto done;
            }
            break;

        default:
            Assert( (e >= 0) && (e < VG_DONE) );
            g = towlower( g );
            if ( ((g >= L'0') && (g <= L'9')) ||
                 ((g >= L'a') && (g <= L'f')) ) {
                if ( uGuid != NULL ) {
                    BYTE n = (BYTE)((g > L'9') ? (g - L'a' + 10) : (g - '0'));
                    if ( e & 1 ) {
                        Assert( uGuid[e/2] == 0 );
                        uGuid[e/2] = n << 4;
                    } else {
                        uGuid[e/2] += n;
                    }
                }
                numberOfHexDigitsParsed++;
            } else {
                if ( (g == 0) &&
                     (!parsingPrettyFormat ||
                      (parsingPrettyFormat && (numberOfHexDigitsParsed >= 16))) ) {
                    hr = S_FALSE;
                } else {
                    hr = E_FAIL;
                }
                goto done;
            }
            break;
        }

    } while ( *expectedCharacter != VG_DONE );

    hr = S_OK;

done:

    if ( puGuidLength != NULL ) {
        *puGuidLength = numberOfHexDigitsParsed / 2;
    }

    HRETURN(hr);
}

//
// PrettyPrintGuid( )
//
LPWSTR
PrettyPrintGuid( 
    LPGUID pGuid )
{
    TraceFunc( "PrettyPrintGuid( " );

    LPBYTE uGuid = (LPBYTE)pGuid;
    LPWSTR pszPrettyString = (LPWSTR) TraceAlloc( LMEM_FIXED, PRETTY_GUID_STRING_BUFFER_SIZE );
    if ( pszPrettyString )
    {
        PCHAR characterType = PrettyFormatGuidCharacters;
        LPWSTR pszDest = pszPrettyString;
        CHAR ct;
        BYTE n;

        do {
    
            ct = *characterType++;
    
            switch ( ct ) {
            
            case VG_NULL:
            case VG_DASH:
            case VG_LBRACK:
            case VG_RBRACK:
                *pszDest = SpecialCharacters[ct - VG_NULL];
                break;
    
            default:
                if ( ct & 1 ) {
                    n = uGuid[ct/2] >> 4;
                } else {
                    n = uGuid[ct/2] & 0xf;
                }
                *pszDest = ByteToHex[n];
                break;
            }

            pszDest++;

        } while ( *characterType != VG_DONE );
    }

    RETURN(pszPrettyString);
}


//
// CheckForDuplicateGuid( )
//
// Returns: S_OK if no duplicates found
//          S_FALSE if a duplicate was found
//          E_FAIL if the query failed
//
HRESULT
CheckForDuplicateGuid(
    LPGUID pGuid )
{
    TraceFunc( "CheckForDuplicateGuid( " );

    HRESULT hr = S_OK;
    WCHAR   szGuid[ MAX_INPUT_GUID_STRING * 2 ];  // room for escaped GUID
    WCHAR   szFilter[ARRAYSIZE(szGuid)+ARRAYSIZE(FILTER_GUID_QUERY)];
    PLDAP   LdapHandle = NULL;
    LPWSTR  ComputerAttrs[2];
    DWORD   LdapError;
    DWORD   count;
    PLDAPMessage LdapMessage = NULL;
    
    LdapError = Ldap_InitializeConnection( &LdapHandle );
    Assert( LdapError == LDAP_SUCCESS );
    if ( LdapError != LDAP_SUCCESS ) 
    {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        goto e0;
    }

    ZeroMemory( szGuid, sizeof(szGuid) );
    ldap_escape_filter_element( (PCHAR)pGuid, sizeof(GUID), szGuid, sizeof(szGuid) );


    wsprintf( szFilter, FILTER_GUID_QUERY, szGuid );
    DebugMsg( "Dup Guid Filter: %s\n", szFilter );

    ComputerAttrs[0] = DISTINGUISHEDNAME;
    ComputerAttrs[1] = NULL;

    LdapError = ldap_search_ext_s( LdapHandle,
                                   NULL,
                                   LDAP_SCOPE_SUBTREE,
                                   szFilter,
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage);
    Assert( LdapError == LDAP_SUCCESS );
    if ( LdapError != LDAP_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        goto e1;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count != 0 )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

e1:
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }

    Assert( LdapHandle );
    ldap_unbind( LdapHandle );

e0:
    HRETURN(hr);
}


//
// AddWizardPage( )
//
// Adds a page to the wizard.
//
void 
AddWizardPage(
    LPPROPSHEETHEADER ppsh, 
    UINT id, 
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle,
    LPARAM lParam )
{
    PROPSHEETPAGE psp;
    WCHAR szTitle[ SMALL_BUFFER_SIZE ];
    WCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    psp.pszTitle    = MAKEINTRESOURCE( IDS_ADD_DOT_DOT_DOT );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;
    psp.lParam      = lParam;

    psp.pszHeaderTitle = NULL;
    if ( idTitle  &&
         LoadString( g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle))) {
        psp.pszHeaderTitle = szTitle;
        psp.dwFlags |= PSP_USEHEADERTITLE;
    }
    
    psp.pszHeaderSubTitle = NULL;
    if ( idSubtitle &&
         LoadString( g_hInstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle))) {
        psp.pszHeaderSubTitle = szSubTitle;
        psp.dwFlags |= PSP_USEHEADERSUBTITLE;
    }
    
    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] ) {
        ppsh->nPages++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\varconv.h ===
//
// Copyright 1997 - Microsoft
//

//
// VARCONV.CPP - Handlers for converting from/to VARIANTs.
//


#ifndef _VARCONV_H_
#define _VARCONV_H_

HRESULT
StringArrayToVariant( 
    VARIANT * pvData,
    LPWSTR lpszDatap[],    // array of LPWSTRs
    DWORD  dwCount );      // number of items in the array

HRESULT
PackStringToVariant(
    VARIANT * pvData,
    LPWSTR lpszData );

HRESULT
PackBytesToVariant(
    VARIANT* pvData,
    LPBYTE   lpData,
    DWORD    cbBytes );

HRESULT
PackDWORDToVariant(
    VARIANT * pvData,
    DWORD dwData );

HRESULT
PackBOOLToVariant(
    VARIANT * pvData,
    BOOL fData );

#endif // _VARCONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\admin\varconv.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// VARCONV.CPP - Handlers for converting from/to VARIANTs.
//

#include "pch.h"
#include "varconv.h"

DEFINE_MODULE("IMADMUI")


//
// StringArrayToVariant( )
//
// Creats an array of Vars that are BSTRs.
HRESULT
StringArrayToVariant(
    VARIANT * pvData,
    LPWSTR lpszData[],    // array of LPWSTRs
    DWORD  dwCount )       // number of items in the array
{
    TraceFunc( "StringArrayToVariant( ... )\n" );

    HRESULT hr;
    DWORD   dw;
    VARIANT * pvar;
    SAFEARRAY * sa;
    SAFEARRAYBOUND rgsabound[1];

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwCount;

    sa = SafeArrayCreate( VT_VARIANT, 1, rgsabound );
    if ( !sa )
        RRETURN(E_OUTOFMEMORY);

    hr = THR( SafeArrayAccessData( sa, (void**) &pvar ) );
    if (! SUCCEEDED(hr)) {
        goto Error;
    }

    for ( dw = 0; dw < dwCount; dw++ )
    {
        hr = THR( PackStringToVariant( &pvar[dw], lpszData[dw] ) );
        if (! SUCCEEDED(hr))
        {
            SafeArrayUnaccessData( sa );
            goto Error;
        }
    }

    SafeArrayUnaccessData( sa );

    pvData->vt = VT_ARRAY | VT_VARIANT;
    pvData->parray = sa;

Error:
    HRETURN(hr);
}


//
// PackStringToVariant( )
//
HRESULT
PackStringToVariant(
    VARIANT * pvData,
    LPWSTR lpszData )
{
    TraceFunc( "PackStringToVariant( )\n" );

    BSTR bstrData = NULL;

    if ( !lpszData || !pvData )
        RRETURN(E_INVALIDARG);

    bstrData = SysAllocString(lpszData);

    if ( !bstrData )
        RRETURN(E_OUTOFMEMORY);

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    HRETURN(S_OK);
}

//
// PackBytesToVariant( )
//
HRESULT
PackBytesToVariant(
    VARIANT* pvData,
    LPBYTE   lpData,
    DWORD    cbBytes )
{
    TraceFunc( "PackBytesToVariant( )\n" );

    HRESULT    hr = S_OK;
    LPBYTE     ptr;
    SAFEARRAY* sa = NULL;
    SAFEARRAYBOUND rgsabound[1];

    if ( !lpData )
        RRETURN(E_INVALIDARG);

    if ( !pvData )
        RRETURN(E_INVALIDARG);

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbBytes;

    sa = SafeArrayCreate( VT_UI1, 1, rgsabound );
    if ( !sa )
        RRETURN(E_OUTOFMEMORY);

    hr = THR( SafeArrayAccessData( sa, (LPVOID*)&ptr ) );
    if (! SUCCEEDED(hr)) {
        goto Error;
    }

    CopyMemory( ptr, lpData, cbBytes );
    SafeArrayUnaccessData( sa );

    pvData->vt = VT_UI1 | VT_ARRAY;
    pvData->parray = sa;

Cleanup:
    HRETURN(hr);

Error:
    if ( sa )
        SafeArrayDestroy( sa );

    goto Cleanup;
}


//
// PackDWORDToVariant( )
//
HRESULT
PackDWORDToVariant(
    VARIANT * pvData,
    DWORD dwData )
{
    TraceFunc( "PackDWORDToVariant( )\n" );

    if ( !pvData )
        RRETURN(E_INVALIDARG);

    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    HRETURN(S_OK);
}


//
// PackBOOLToVariant( )
//
HRESULT
PackBOOLToVariant(
    VARIANT * pvData,
    BOOL fData )
{
    TraceFunc( "PackBOOLToVariant( )\n" );

    if ( !pvData )
        RETURN(E_INVALIDARG);

    pvData->vt = VT_BOOL;
    V_BOOL( pvData ) = (VARIANT_BOOL)fData;

    RETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai_arp.asm ===
Struc ArpPkt
	Dest		dw	-1, -1, -1	; destination address
	Source		dw	0, 0, 0		; source address
	Type		dw	0608h		; type field
	HwType		dw	0100h		; hardware type
	Prot		dw	8		; protocol
	HLen		db	6		; hardware length
	PLen		db	4		; protocol length
	Code		dw	0100h		; request code
	SendHA		dw	0, 0, 0		; sender hardware address
	SendIP		dd	0		; sender IP
	TargetHA	dw	0, 0, 0		; target hardware address
	TargetIP	dd	0		; target IP
ends

public	AIAppendCache

;--------------------------------------------------------------------
; AIAppendCache
;
; Sets an IP number and hardware address in the cache.
;
; Parameters:
;	ax:dx - IP number
;	si - pointer to hardware address
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIAppendCache

	; set the IP number
	mov	[word ptr CurrentIP], ax
	mov	[word ptr CurrentIP+2], dx

	; set the hardware address
	mov	di, offset CurrentAddr
	movsw
	movsw
	movsw

	ret

endp

;--------------------------------------------------------------------
; ResolveIP
;
; Converts an IP address into a hardware address using ARP.
;
; Parameters:
;	eax - IP address
;
; Returns:
;	si - pointer to hardware address
;		(0 if unable to find address)
;--------------------------------------------------------------------
Proc ResolveIP

	; first check for a broadcast IP address
	cmp	eax, -1
	jne	notBroadcast

	mov	si, offset Broadcast	; return broadcast address pointer
	ret

notBroadcast:
	; check if the IP address is in the cache
	cmp	[CurrentIP], eax
	jne	notCached

	mov	si, offset CurrentAddr	; return cache pointer
	ret

notCached:
	;----------------------------------------
	; The address is not a broadcast or in the
	; current cache so we must do an ARP to get
	; the address. Hopefully someone on the
	; network will know the address.
	;----------------------------------------
	push	ds
	pop	es			; es = ds

	call	CreateArpRequest	; create the ARP packet
	mov	[Retrys], 5		; set retry count

	mov	[DoingARP], 1		; set "Doing ARP" flag

doArpLoop:
	mov	cx, size ArpPkt
	mov	di, offset TxArp
	call	AITransmitRaw		; transmit the ARP

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

noTimeOut:
	cmp	[TempIP], 0		; got a reply?
	je	doneArp			; yes

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, 9			; is time up (half second)?
	jb	noTimeOut		; loop until times up

	dec	[Retrys]		; increase retry counter
	jne	doArpLoop		; send ARP again

	xor	si, si			; return "no address found"
	jmp	exitResolve

doneArp:
	mov	si, offset CurrentAddr	; return cache pointer

exitResolve:
	mov	[DoingARP], 0		; clear "Doing ARP" flag

	ret

endp

;--------------------------------------------------------------------
; CreateArpRequest
;
; Creates an ARP (address resolution protocol) request.
;
; Parameters:
;	eax - target IP address
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc CreateArpRequest

	push	ax

	;----------------------------------------
	; Put target IP address field.
	;----------------------------------------
	mov	[TxArp.TargetIP], eax
	mov	[TempIP], eax

	;----------------------------------------
	; Put our hardware addresses into source address.
	;----------------------------------------
	lea	di, [TxArp.Source]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	mov	[TxArp.Code], 0100h	; set code as request

	;----------------------------------------
	; Put our hardware addresses into ARP request packet.
	;----------------------------------------
	lea	di, [TxArp.SendHa]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	;----------------------------------------
	; Put local IP address into send field.
	;----------------------------------------
	mov	si, offset LocalIP
	movsw
	movsw

	;----------------------------------------
	; Put null hardware address into receive hardware address field
	;----------------------------------------
	xor	ax, ax
	stosw
	stosw
	stosw

	pop	ax
	ret

endp CreateArpRequest

;--------------------------------------------------------------------
; ArpCallback
;
; Checks for a ARP (address resolution protocol) reply.
; Routine is called from Receive interrupt when an ARP has been received.
;
; Parameters:
;	es:di pointer to packet
;
; Returns:
;	carry set if packet processed
;--------------------------------------------------------------------
Proc ArpCallback

	cmp	[(ArpPkt es:di).Code], 100h; check for request code
	jne	notRequest
	jmp	ProcessArpRequest

notRequest:
	cmp	[DoingARP], 0		; is "Doing ARP" flag set?
	je	notReply		; no

	cmp	[(ArpPkt es:di).Code], 200h; check for reply code
	jne	notReply
	jmp	ProcessArpReply

notReply:
	clc				; clear carry - didn't process packet
	ret

endp

;--------------------------------------------------------------------
; ProcessArpReply
;
; Parameters:
;	es:di pointer to packet
;
; Returns:
;	carry set if packet processed
;--------------------------------------------------------------------
Proc ProcessArpReply

	;------------------------------------------------------------
	; Confirm the IP address we are looking for is
	; in the sender field.
	;------------------------------------------------------------
	mov	eax, [(ArpPkt es:di).SendIP]
	cmp	[TempIP], eax
	je	ourARP			; it is ours

	clc				; clear carry - packet not processed
	ret

ourARP:
	push	si			; save si
	push	di			; save di

	;------------------------------------------------------------
	; Copy the hardware address into the cache.
	;------------------------------------------------------------
	lea	bx, [(ArpPkt di).SendHa]

	mov	ax, [es:bx]
	mov	[CurrentAddr], ax
	mov	ax, [es:bx+2]
	mov	[CurrentAddr+2], ax
	mov	ax, [es:bx+4]
	mov	[CurrentAddr+4], ax

	;----------------------------------------
	; Copy the IP address into the cache.
	;----------------------------------------
	mov	eax, [TempIP]
	mov	[CurrentIP], eax

	mov	[TempIP], 0		; clear the temp address

	pop	di			; restore di
	pop	si			; restore si

	stc				; set carry (processed packet)
	ret

endp

;--------------------------------------------------------------------
; ProcessArpRequest
;
; Handles ARP (address resolution protocol) requests.  Routine is called
; from receive interrupt when an ARP packet has been received.
;
; Parameters:
;	es:di - pointer to packet
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc ProcessArpRequest

	push	si			; save si
	push	di			; save di

	mov	bx, di			; move request packet pointer to bx

	;------------------------------------------------------------
	; Check if the target IP address is us.
	;------------------------------------------------------------
	mov	eax, [(ArpPkt es:di).TargetIP]
	cmp	[dword ptr LocalIP], eax
	jne	notOurRequest		; the ARP was not for us

	;------------------------------------------------------------
	mov	si, di			; move request packet address to si
	push	es			; save request packet segment

	push	ds
	pop	es			; es = our segment

	;------------------------------------------------------------
	; The ARP request is for us, so build a reply and send it.
	;------------------------------------------------------------
	lea	di, [TxArp.Code]	; setup pointer for reply packet
	mov	ax, 0200h
	stosw				; set code for reply

	;------------------------------------------------------------
	; The send hardware address is us.
	;------------------------------------------------------------
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	;----------------------------------------
	; The send IP address is also us.
	;----------------------------------------
	mov	si, offset LocalIP
	movsw
	movsw

	;----------------------------------------
	; Copy the requesters hardware address into the target field.
	;----------------------------------------
	mov	ax, ds			; save our ds in ax
	pop	ds			; set ds to request buffer
	push	ds			; save it again
	lea	si, [(ARPPkt bx).SendHa]
	movsw
	movsw
	movsw

	;----------------------------------------
	; Copy the requesters IP address into the target field.
	;----------------------------------------
	movsw
	movsw

	;----------------------------------------
	; Put our hardware addresses into source address.
	;----------------------------------------
	mov	ds, ax			; restore our ds from ax
	lea	di, [TxArp.Source]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	mov	cx, size ArpPkt
	mov	di, offset TxArp
	call	AITransmitRaw		; transmit the ARP reply

	pop	es			; restore request buffer segment

	stc				; set carry (processed packet)

notOurRequest:
	pop	di			; restore di
	pop	si			; restore si

	ret

endp

;--------------------------------------------------------------------

Broadcast	dw	-1, -1, -1

TempIP		dd	0
CurrentIP	dd	0
CurrentAddr	dw	0, 0, 0

DoingARP	db	0

TxArp		ArpPkt	{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\bootware.asm ===
;----------------------------------------------------------------------------
; BOOTWARE.ASM
;
; Main BootWare module for Goliath.
;
; $Histroy: $
;
;----------------------------------------------------------------------------
IDEAL
_IDEAL_ = 1

include "include\drvseg.inc"
include "include\loader.inc"
;include "include\bwstruct.inc"

public	PCIDevice
public	PCIVendor
public	PCIBusDevFunc
public	CSN
public	Verbose

extrn	EndMark:byte
extrn	PrintTitle:near
extrn	Print:near
extrn	AIInitialize:near
extrn	IPStart:near
extrn	SetupPreboot:near

extrn	AITbl:byte
extrn	RxBuffer2:byte
extrn	LangSeg:word

START_CODE
P386

Proc Entry

	jmp	short Start

	dw	EndMark			; module size

public LanOption
LanOption db	80 dup (0)

endp

;--------------------------------------------------------------------
; Start
;
; Parameters:
;	ds:si - pointer to LoaderInfo structure
;--------------------------------------------------------------------
Proc Start

	push	ds
	pop	es			; es = ds
	push	cs
	pop	ds			; ds = cs

	mov	ax, [(LoaderInfo es:si).LangSeg]
	mov	[LangSeg], ax		; save languge segment
	mov	ax, [(LoaderInfo es:si).DeviceID]
	mov	[PCIDevice], ax
	mov	ax, [(LoaderInfo es:si).VendorID]
	mov	[PCIVendor], ax
	mov	ax, [(LoaderInfo es:si).PCIBusDevFunc]
	mov	[PCIBusDevFunc], ax	; save Bus/Device/Function numbers
	mov	ax, [(LoaderInfo es:si).CSN]
	mov	[CSN], ax		; save PnP Card Select Number

	push	es			; save es

	push	0
	pop	es			; es = 0
	mov	ax, cs			; get current segment
	xor	dx, dx
	mov	cx, 64
	div	cx			; convert to size in K
	mov	[es:413h], ax		; set new top of memory

	pop	es			; restore es

	mov	bl, 7
	call	PrintTitle

	mov	bx, [(LoaderInfo es:si).UNDISeg]
	mov	cx, [(LoaderInfo es:si).UNDICode]
	mov	dx, [(LoaderInfo es:si).UNDIData]
	mov	si, offset RxBuffer2	; si = receive buffer
					; bx = UNDI segment
					; cx = UNDI code segment size
					; dx = UNDI data segment size
	push	bx			; save UNDI segment
	call	AIInitialize

	call	IPStart

	pop	dx			; dx = UNDI segment
	mov	bx, offset AITbl	; pass pointer to AI API table
	call	SetupPreboot		; setup Preboot environment

	mov	ax, 5650h		; PXE request code
	int	1Ah			; do int1A to set starting values

	push	cs			; push current segment
	push	offset return		; push return address

	push	0			; push new segment
	push	7C00h			; push new offset
	retf				; jump to bootstrap

return:
	push	cs
	pop	ds

	mov	bx, offset aborted
	call	Print

	jmp	$			; hang system

endp

aborted	db	"Exiting Remote Installation Boot Floppy", 13, 10
	db	"Please remove the floppy disk and reboot the workstation.", 0

;--------------------------------------------------------------------
public BWTable
label BWTable
		db	(Sum-$)+1	;0 size of table

		db	4		;1 Version of the table format

		dw	0100h		;2 ROM version

		dw	-1		;4 BootWare type code

BWTSettings	dd   0001010000010011b	;6 Current settings
					;     0 - initialized
					;   1-2 - protocol
					;   3-4 - sub protocol
					;     5 - default boot
					;     6 - config screen disabled
					;     7 - floppy boot disabled
					;     8 - hard disk boot disabled
					;     9 - config message disabled
					; 10-11 - time-out
					;    12 - wait for key on reboot
					; 13-15 - protocol specific

BWTCapabilities	dd	-1		;6 ROM capabilities
					;  0 - PXE
					;  1 - TCP/IP
					;  2 - NetWare
					;  3 - RPL

BWTDefaults	dd	1413h		;10 Factory defaults
					; bits same as settings

BWTEEMask	dd	-1		;14 EEROM mask

Sum		db	0		;18 checksum of table


BWTSize		db	0

PCIDevice	dw	0
PCIVendor	dw	0
PCIBusDevFunc	dw	0
CSN		dw	0

Verbose		db	1

END_CODE
end Entry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\endmark.asm ===
IDEAL
_IDEAL_ = 1

	include "include\drvseg.inc"

START_SPARSE

public RxBuffer
RxBuffer	db 1525 dup (?)

public RxBuffer2
RxBuffer2	db 1525 dup (?)

;align 16
public EndMark
label EndMark
END_SPARSE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootsec\bootsec.asm ===
;==========================================================================
; BOOTSEC.ASM
;
; Bootsector for Goliath.
;
; This is taken (directly) from NT's boot sector.
;==========================================================================

seg_a		segment	byte public use16
		assume	cs:seg_a, ds:seg_a

ideal
		org	0

P386
Proc start far

	jmp	short entry
	nop

	;------------------------------------------------------------
	; DOS name
	;------------------------------------------------------------
	db	'(PC**SD)'

	;------------------------------------------------------------
	; BPB (BIOS parameter block)
	;------------------------------------------------------------
SectorBytes	dw	200h		; bytes per sector	(00)
ClusterSectors	db	1		; sectors per cluster	(02)
ReservedSectors	dw	1		; reserved sectors	(03)
NumFATS		db	2		; number of FATS	(05)
MaxRootEntries	dw	00E0h		; max root entries	(06)
NumSectors	dw	0B40h		; number of sectors	(08)
MediaType	db	0F0h		; media type		(0A)
FATSectors	dw	9		; FAT sectors		(0B)
TrackSectors	dw	12h		; track sectors		(0D)
Heads		dw	2		; heads			(0F)
HiddenSectorsLo	dw	0		; hidden sectors	(11)
HiddenSectorsHi	dw	0		; hidden sectors	(13)
TotalSectors	dd	0		; number of sectors	(15)
TempDrive	db	0		; reserved		(19)
TempHead	db	0		; reserved		(1A)
Signature	db	29h		; 			(1B)

SerialNumber	dd	0		;			(1C)
		db	'NoName     '	;			(20)
		db	'FAT12   '	;			(2B)

entry:

	xor	ax, ax			; ax = 0
	mov	ss, ax			; stack segment = 0
	mov	sp, 7C00h		; set stack pointer
	push	07C0h			; push 7C0h
	pop	ds			; ds = 07C0h

					; calc the size of the FAT
	mov	al, [NumFATS]		; get number of FATS
	mul	[FATSectors]		; times sectors per track
	add	ax, [ReservedSectors]	; add reserved sectors
					; we now have number of sectors in FAT
	push	ax			; save value
	xchg	cx, ax			; move to cx

	mov	ax, 32			; size of directory entry
	mul	[MaxRootEntries]	; calc total size of root directory

	mov	bx, [SectorBytes]	; get bytes per sector
	add	ax, bx			; add boot sector size
	dec	ax			; less one byte
	div	bx			; divide by sector size
	add	cx, ax			; add to sectors in FAT
					; ax and cx is offset of data on disk
	mov	[208h], cx		; save value

	; read the directory into 1000:0
	push	1000h			; push 1000h
	pop	es			; es = 1000h

	xor	bx, bx			; bx = 0
	pop	[word ptr 213h]		; put number of FAT sectors in 213h
	mov	[215h], bx		; 215h = 0
	call	ReadSectors
	jc	printError2		; exit if there was an error

	xor	bx, bx			; bx = 0					; Zero register
	mov	cx, [MaxRootEntries]	; get max root directory entries

scanDirLoop:							
	mov	di, bx			; directory entry offet into di
	push	cx			; save cx
	mov	cx, 11			; file name size
	mov	si, offset NTLDR
	repe	cmpsb			; look for file name
	pop	cx			; restore cx
	jz	foundEntry		; jump if found
	add	bx, 20h			; next directory offset
	loop	scanDirLoop		; check next entry

foundEntry:
	jcxz	printError1		; exit if entry not found

	mov	dx, [es:bx+1Ah]		; get file starting cluster
	push	dx			; save value
	mov	ax, 1			; sectors to read
	push	2000h			; push 2000h
	pop	es  			; es = 2000h (load segment)
	xor	bx, bx			; bx = 0
	call	ReadCluster
	jc	printError2		; exit if error

	pop	bx			; bx = starting cluster
	mov	si, 0Bh
	mov	di, 20Bh
	push	ds
	pop	[(word ptr di)+2]	; di+2 = ds
	mov	[word ptr di], offset ReadCluster
	push	ds
	pop	[word ptr di+6]		; di+6 = ds
	mov	[word ptr di+4], offset ReadSectors
	mov	dl, [TempDrive]		; get boot drive
	jmp	far 2000h:0		; jump to loader

;--------------------------------------------------------------------
printError1:
	mov	si, offset Error1	; "Couldn't find Goliath"
	jmp	printError

printError2:
	mov	si, offset Error2	; "I/O error reading disk"

printError:
	call	Print			; print message

	mov	si, offset PleaseInsert	; "Please insert another disk"
	call	Print
	sti				; enable interrupts

	jmp	$			; halt

endp

;==========================================================================
; Print
;==========================================================================
Proc Print

	lodsb				; get byte from ds:si
	or	al,al			; did we get a NULL?
	jz	printExit		; got NULL - exit
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character

	jmp	print			; do next character
	
printExit:
	ret

endp

;--------------------------------------------------------------------
; ReadCluster
;
;--------------------------------------------------------------------
Proc ReadCluster far

	push	ax
	dec	dx			; decrease cluster number
	dec	dx			; decrease cluster number
	mov	al, [ClusterSectors]	; get sectors per cluster
	xor	ah, ah			; ah = 0
	mul	dx			; multiply by cluster number
	add	ax, [208h]
	adc	dx, 0
	mov	[213h], ax
	mov	[215h], dx
	pop	ax			; restore ax

Proc ReadSectors far
	mov	[207h], al		; save number of sectors to read

readLoop:
	mov	ax, [213h]
	mov	dx, [215h]
	add	ax, [HiddenSectorsLo]	; add number of hidden sectors
	adc	dx, [HiddenSectorsHi]
	div	[TrackSectors]		; divide by sectors per track
	inc	dl
	mov	[206h], dl

	xor	dx, dx			; dx = 0
	div	[Heads]			; divide by number of heads
	mov	[TempHead], dl		; save head number
	mov	[204h], ax

	mov	ax, [TrackSectors]	; get number of sectors per track
	sub	al, [206h]
	inc	ax
	cmp	al, [207h]
	jbe	loc_11
	mov	al, [207h]		; get number of sectors to read
	xor	ah, ah			; ah = 0

loc_11:
	push	ax
	mov	ah, 2			; read function
	mov	cx, [204h]
	shl	ch, 6
	or	ch, [206h]
	xchg	ch, cl			; cl = sector, ch = track
	mov	dx, [word ptr TempDrive]; dl = drive, dh = head
	int	13h			; read disk
	jnc	readOK			; jump if no error

	add	sp, 2			; clean stack
	stc				; set carry flag (error)
	ret				; exit

readOK:
	pop	ax
	sub	[207h], al
	jbe	readDone		; file read done
	add	[213h], ax
	adc	[word ptr 215h], 0
	mul	[SectorBytes]
	add	bx, ax
	jmp	readLoop

readDone:
	mov	[207h], al
	clc						; Clear carry flag
	ret						; Return far

endp
endp

Error1		db	"BOOT: Couldn't find Goliath", 13, 10, 0
Error2		db	'BOOT: I/O error reading disk', 13, 10, 0
PleaseInsert	db	'Please insert another disk', 0
NTLDR		db	'GOLIATH    '

		org 510
		db	55h,0AAh

ends
end Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai_tftp.asm ===
;--------------------------------------------------------------------
; AIOpenTFTP
;
; Opens and transfers a file via TFTP.
;
; Parameters:
;	es:di - pointer to OpenTFTP structure
;
; Returns:
;	ax - status
;--------------------------------------------------------------------
Proc AIOpenTFTP

	cmp	[(OpenTFTPStruct es:di).Size], size OpenTFTPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	mov	[word ptr InfoPtr], di
	mov	[word ptr InfoPtr+2], es

	mov	[PacketNum], 1		; set starting packet number
	mov	[WaitTime], 18		; set default timeout to 1 second
	mov	[NoCallbacks], 1	; disable any user callbacks
	mov	[Started], 0
	mov	[PacketSize], 512	; default to normal packet size

	mov	ax, [(OpenTFTPStruct es:di).Flags]
	mov	[Flags], ax		; copy flags into local

	mov	eax, [(OpenTFTPStruct es:di).Callback]
	mov	[CallBackTFTP], eax

	call	BuildTFTP
	
tftpRxLoop1:
	cmp	[Started], 0		; are we waiting for the first packet?
	jne	not0			; no

	push	es			; save es
	push	0
	pop	es			; es = 0
	mov	ax, [es:046ch]		; get clock tick count
	or	ax, 4000h
	mov	[OurPort], ax		; save as "random" number
	mov	[UDP2.SourcePort], ax
	pop	es			; restore es

not0:
	mov	[BufferSize], 0		; clear size value
	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	cmp	ax, 0			; was there an error?
	je	@@noError		; no

	jmp	tftpExit		; error - exit

@@noError:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

tftpRxLoop2:
	call	CheckRxBuffer		; try and get a packet
	or	ax, ax			; did we get anything?
	jne	gotPacket		; we got a packet

	call	CheckTimeout
	jc	tftpRxLoop2		; jump if no timeout

	call	TimeoutCallback		; do client timeout callback
	jne	tftpError		; client wants to stop

	jmp	tftpRxLoop1		; resend the last packet

gotPacket:
	call	ValidatePacket		; validate the packet is TFTP for us
	jc	tftpRxLoop2		; not a good packet

	call	PacketCallback		; do the client callback
	or	ax, ax			; was there an error?
	jne	tftpError		; yes

	or	cx, cx			; was this the last packet?
	jne	tftpRxLoop1		; not last packet

	mov	di, offset UDP2
	call	AITransmitUDP		; send last ACK packet

	mov	ax, 0
	jmp	tftpExit

tftpError:
	mov	ax, -1

tftpExit:
	mov	[NoCallbacks], 0	; enable user callbacks
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc CheckTimeout

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, [WaitTime]		; is time up?
	jb	noTimeOut2		; loop until times up

isTimeOut:
	clc				; clear carry for time out
	ret

noTimeOut2:
	stc				; set carry for no time-out
	ret

endp

;--------------------------------------------------------------------
; BuildTFTP
;
; Builds IP, UDP and data packets needed to do a TFTP.
;
; Parameters:
;	es:di - pointer to OpenTFTP structure
;
; Returns:
;	nothing
;
;--------------------------------------------------------------------
Proc BuildTFTP

	push	es			; save structure segment
	push	di			; save structre pointer

	push	es
	push	0
	pop	es			; es = 0
	mov	ax, [es:046ch]		; get clock tick count
	or	ax, 4000h
	mov	[OurPort], ax		; save as "random" number
	pop	es

	mov	si, [(OpenTFTPStruct es:di).FileName]
	mov	dx, [((OpenTFTPStruct es:di).FileName)+2]

	push	ds
	pop	es			; es = ds

	mov	di, offset TxBuffer
	mov	ax, 0100h		; read request (lo/hi)
	stosw

	;----------------------------------------
	; Copy file name into request packet
	;----------------------------------------
	push	ds			; save our ds
	mov	ds, dx			; set ds to file name segment

	mov	dx, octet_size+2	; start with overhead size

buildLoop:
	lodsb
	stosb
	inc	dx
	or	al, al			; check for terminating null
	jne	buildLoop

	pop	ds			; restore our ds

	mov	si, offset tx_octet
	mov	cx, octet_size		; string length

	rep	movsb			; add "octet" string to buffer

	test	[Flags], 1		; should we do "block size?"
	je	noBlkSize		; no

	mov	si, offset tx_lrgsize
	mov	cx, lrgsize_size
	add	dx, cx			; update packet length
	rep	movsb			; add "blksize" string to buffer

noBlkSize:
	test	[Flags], 2		; should we do "tsize?"
	je	noTSize			; no

	mov	si, offset tx_tsize
	mov	cx, tsize_size
	add	dx, cx			; update packet length
	rep	movsb			; add "blksize" string to buffer

noTSize:
	pop	di			; restore structure pointer
	pop	es			; restore structure segment

	; build the UDP transmit structure
	mov	[UDP2.Size], size TxUDPStruct
	mov	eax, [(OpenTFTPStruct es:di).Address]
	mov	[UDP2.Address], eax
	mov	eax, [((OpenTFTPStruct es:di).Gateway)]
	mov	[(UDP2.Gateway)], eax
	mov	ax, [OurPort]
	mov	[UDP2.SourcePort], ax
	mov	[UDP2.DestPort], 69
	mov	[UDP2.Data], offset TxBuffer
	mov	[(UDP2.Data)+2], ds
	mov	[UDP2.Length], dx

	push	ds
	pop	es			; es = ds

	ret

endp

tx_sumerror	db	'checksum error ', 0

;--------------------------------------------------------------------
; ValidatePacket
;
; Parameters:
;	si - pointer to receive buffer
;
; Returns:
;
;--------------------------------------------------------------------
Proc ValidatePacket

	push	si			; save si

	add	si, 14			; skip MAC header
	mov	al, [(IP si).Protocol]	; get protocol of IP packet
	cmp	al, 17			; is it a UDP packet?
;	je	validateTFTP		; yes

;	cmp	al, 1			; is it a ICMP packet?
	jne	validateBad		; no

;validateTFTP:
	add	si, size IP		; skip IP header

	mov	ax, [si+2]		; get destination port
	xchg	al, ah			; change from network order
	cmp	[OurPort], ax		; is packet on our port?
	jne	validateBad		; no

	mov	ax, [si]		; get source port
	xchg	al, ah			; change from network order
	mov	[UDP2.DestPort], ax	; change destination port

	add	si, size UDP		; skip UDP header

	cmp	[word ptr si], 0600h	; is this an OACK packet?
	jne	notOACK			; no

	add	si, 2			; skip packet type
	call	CheckOACK		; we will process packet 0
	jmp	validateBad

notOACK:
	cmp	[word ptr si], 0500h	; is this an Error packet?
	je	gotError		; yes

	mov	ax, [si+2]		; get packet number
	xchg	al, ah			; flip bytes
	cmp	[PacketNum], ax		; is this the packet we want?
	jne	validateBad		; wrong packet

gotError:
	mov	[Started], 1

	pop	si			; restore si
	clc
	ret				; return no error

validateBad:
	pop	si			; restore si
	mov	[BufferSize], 0		; clear buffer size value
	stc
	ret				; return with error

endp

;--------------------------------------------------------------------
; PacketCallback
;
; Parameters:
;	si - address of receive buffer
;
; Returns:
;
;--------------------------------------------------------------------
Proc PacketCallback

	mov	di, si			; get address of receive buffer
	add	di, 14 + size IP	; skip MAC and IP header

	mov	cx, [di+4]		; get packet size
	xchg	cl, ch			; change from network order
	sub	cx, 12			; subtract UDP & TFTP header size

	add	di, size UDP		; skip UDP header
	mov	ax, [di]		; get packet type
	xchg	al, ah			; change from network order

	mov	bx, [di+2]		; get packet number
	xchg	bl, bh			; change from network order

	add	di, 4			; skip TFTP header

	push	ax			; save packet type
	push	bx			; save packet number
	push	cx			; save packet size
	call	[CallbackTFTP]
	mov	dx, ax			; move return code to dx
	pop	cx			; restore packet size
	pop	bx			; restore packet number
	pop	ax			; restore packet type

	cmp	ax, 5			; was this an error packet?
	je	eof			; yes, return as if done file

	or	dx, dx			; did the callback return an error?
	jne	callBad			; yes

	call	SendAck

	inc	[PacketNum]

	cmp	[PacketSize], cx	; was this a full packet?
	je	notEnd			; yes

	xor	cx, cx			; clear cx to indicate end of file

notEnd:
	xor	ax, ax
eof:
	ret				; return no error

callBad:
	mov	ax, dx			; move error code back to ax
	call	SendNAK
	mov	ax, 1
	ret				; return with error

endp

;--------------------------------------------------------------------
; TimeoutCallback
;
; Parameters:
;	none
;
; Returns:
;
;--------------------------------------------------------------------
Proc TimeoutCallback

	les	di, [InfoPtr]		; get pointer to info structure

	mov	ax, -2			; set packet type as time-out
	mov	cx, [WaitTime]		; get current wait time
	call	[CallbackTFTP]
	mov	[WaitTime], cx		; set new wait time

	or	ax, ax			; check if an error was returned
	ret				; return with client return status

endp

;--------------------------------------------------------------------
; CheckOACK
;
; Parameters:
;	cx - packet size
;	ds:si - pointer to packet
;
; Returns:
;
;--------------------------------------------------------------------
Proc CheckOACK

	mov	di, offset tx_lrgsize
	mov	cx, 7
	rep	cmpsb			; check for blksize string
	jne	badOACK			; string not found

	inc	si

	; convert the ascii value to binary
	xor	ax, ax			; clear start value
	mov	cx, 10			; radix

convertLoop:
	mov	bl, [si]		; get a character
	inc	si
	cmp	bl, 0			; at end of string?
	je	valueDone		; yes

	cmp	bl, '9'
	ja	badOACK			; bad character

	sub	bl, '0'			; convert to numeric
	jb	badOACK			; bad value

	mul	cx			; multiply running value by 10
	add	ax, bx			; add new digit

	jmp	convertLoop		; do next character

valueDone:
	cmp	ax, 1450		; compare with our max value
	ja	badOACK			; bad value

	mov	[PacketSize], ax	; save our new packet size
	mov	[Started], 1

	mov	bx, 0			; packet number is 0
	call	SendACK			; ACK the offer

	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	xor	ax, ax			; return "no error"
	mov	cx, 1			; return "not last packet"
	ret

badOACK:
	mov	bx, 8
	call	SendNAK2
	mov	ax, 1			; return "error"
	mov	cx, 0			; return "last packet"
	ret

endp

;--------------------------------------------------------------------
; SendAck
;
; Sends back an acknowledgment packet for the data packet just received.
;
; Parameters:
;	bx - packet number
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SendAck

	mov	di, offset TxBuffer	; pointer to transmit data
	mov	[word ptr di], ACK	; save value

	xchg	bl, bh
	mov	[di+2], bx		; send packet number

	mov	[UDP2.Length], 4	; update length

	ret

endp

;--------------------------------------------------------------------
; SendNAK
;
; Sends back an acknowledgment packet for the data packet just received.
;
; Parameters:
;	ax - error code
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SendNAK

	mov	bx, NAK			; default value

SendNAK2:
	mov	di, offset TxBuffer	; pointer of transmit data
	mov	[word ptr di], bx	; save value

	xchg	al, ah
	mov	[di+2], ax		; send error code

	mov	[UDP2.Length], 4	; update length

	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	ret

endp

;--------------------------------------------------------------------

tx_octet	db 'octet', 0
octet_size	equ 6

tx_lrgsize	db 'blksize', 0
		db '1450', 0
lrgsize_size	equ 13

tx_tsize	db 'tsize', 0
tsize_size	equ 6

Started		db	?
Flags		dw	?
PacketNum	dw	?
PacketSize	dw	512
InfoPtr		dd	?
OurPort		dw	?
WaitTime	dw	?
UDP2		TxUDPStruct	<?>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\common\common.asm ===
;====================================================================
; COMMON.ASM
;
; "Common" routines for Goliath
;
; $History: COMMON.ASM $
; 
; *****************  Version 7  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 11:31a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Changed banner string.
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 10/08/98   Time: 4:46p
; Updated in $/Client Boot/Goliath/BootWare/Common
; Changed copyright to include 3Com.
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 4:27p
; Updated in $/Client Boot/Goliath/BootWare/Common
; Company name change.
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 10:47a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Added include for config.inc.
;
;====================================================================
IDEAL
_IDEAL_ = 1

include "..\include\drvseg.inc"
include "..\include\bwstruct.inc"
include "..\include\config.inc"

public	ClearScreen
public	Print
public	PrintChar
public	PrintTitle
public	PrintDecimal
public	PrintCRLF
public	PrintSettings
public	StoDec
public	Reboot
public	ErrorMsg

extrn	LanOption:byte			; NAD
extrn	BWTable:BWT

extrn	NIC_RAM:word
extrn	RomBase:word
extrn	NIC_IRQ:byte
extrn	NIC_IO:word
extrn	NetAddress:word

START_CODE
P386

BootWareString	db	"Windows NT Remote Installation Boot Floppy", 13, 10
		db 	"(C) Copyright 1998 Lanworks Technologies Co. a subsidiary of 3Com Corporation", 13, 10
		db	'All rights reserved.'
CRLF		db	13, 10, 0

_NodeString	db	'Node: ', 0
_NodeID		db	'XXXXXXXXXXXX', 0

ErrorMsg	db	'Error: ', 0

include	"print.asm"

;--------------------------------------------------------------------
; PrintTitle
;
; Prints "BootWare Centralized Boot ROM for ..." and copyright
; message at the top of the screen.
;
; Parameters:
;	bl - text attribute
;
; Returns:
;	dx - next screen location for printing
;--------------------------------------------------------------------
Proc PrintTitle

	pusha

	mov	bh, bl			; attribute
	xor	cx, cx			; start row/column
	mov	dx, 194Fh		; end row/column
	mov	ax, 0600h		; scroll up 21 lines
	int	10h			; clear the screen with attribute

	xor	dx, dx
	xor	bh, bh
	mov	ah, 2
	int	10h			; set cursor to top left

	mov	al, bl
	mov	bx, offset BootWareString
	call	Print			; print "Copyright...."

	mov	bx, offset LanOption
	call	Print

	call	PrintCRLF
	call	PrintCRLF

	inc	dh			; next row
	inc	dh			; next row
	xor	dl, dl

	popa
	ret

endp

;--------------------------------------------------------------------
; PrintSettings
;
; Prints the current ROM configuration settings, RAM base, ROM base,
; I/O, IRQ and ethernet standard, if NetWare, using values in the
; NID/NAD table.
;
; Parameters:
;	ax - NAD config text
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc PrintSettings

	pusha				; save everything

	; Convert the node address from binary to ascii and print it
	mov	di, offset _NodeID
	mov	ax, [NetAddress]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	ax, [NetAddress+2]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	ax, [NetAddress+4]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	bx, offset _NodeString
	call	Print

	mov	bx, offset _NodeID
	call	Print

	mov	bx, offset CRLF
	call	Print

	popa				; restore everything
	ret

endp

;----------------------------------------------------------------------
; ClearScreen
;
; Clears the screen.
;
; Parameters:
;	none
;
; Returns:
;	nothng
;----------------------------------------------------------------------
Proc ClearScreen

	mov	ax, 3
	int	010h			; set 80x25 text mode
	mov	ax, 0500h
	int	010h			; page 0

	xor	dx, dx
	xor	bh, bh
	mov	ah, 2
	int	10h			; set cursor to top left

	ret

endp ClearScreen

;----------------------------------------------------------------------
; PrintChar
;
; Prints a single character on the screen.
;
; Parameters:
;	AL - character
;
; Returns:
;	nothing
;----------------------------------------------------------------------
Proc PrintChar

	push	bx			; save bx
	mov	ah, 0Eh
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY

	pop	bx			; restore bx

	ret

endp

;----------------------------------------------------------------------
; PrintDecimal
;
; Prints a decimal value.
;
; Parameters:
;	AX - value to print
;
; Returns:
;	nothing
;----------------------------------------------------------------------
Proc PrintDecimal

	push	bx
	push	cx		; save cx
	push	dx		; save dx

	xor	cx, cx		; clear counter
	mov	bx, 10

__loop1:
	xor	dx, dx
	div	bx		; divide by 10
	add	dl, 30h 	; convert to ASCII character
	push	dx		; save on stack
	inc	cx		; increase counter
	or	ax, ax		; still value remaining?
	jnz	__loop1		; do more

__loop2:
	pop	ax
	mov	ah, 0Eh
	mov	bx, 7
	int	10h
	loop	__loop2

	pop	dx		; restore dx
	pop	cx		; restore cx
	pop	bx

	ret

endp

;----------------------------------------------------------------------
; PrintCRLF
;
;----------------------------------------------------------------------
Proc PrintCRLF

	mov	bx, offset CRLF
	jmp	Print

endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; Parameters:
;	AX - binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
;
; Returns:
;	nothing (ax, di modified)
;
;----------------------------------------------------------------------
Proc StoHex

	push	ax			; save for lower nibble
	shr	al, 4
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al, 0Fh
	add	al, 90h
	daa
	adc	al, 40h
	daa
	stosb				; stuff hex digit in buffer
	ret

endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; Parameters:
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
;
; Returns:
;	nothing (ax, di modified)
;----------------------------------------------------------------------
Proc StoDec

	push	cx		; save cx
	push	dx		; save dx

	push	ax		; save ax
	mov	al, '0'
	mov	ch, 0
	rep	stosb		; fill with zeroes

	mov	cl, 0Ah 	; divide by 10
	pop	ax		; restore value
	push	di		; save ending DI value

stoDecNext:
	xor	dx, dx
	div	cx		; ax, dx rem=dx:ax/reg
	add	dl, 30h 	; '0'
	dec	di
	mov	[es:di], dl
	or	ax, ax
	jnz	stoDecNext

	pop	di		; restore di
	pop	dx		; restore dx
	pop	cx		; restore cx
	ret

endp

;--------------------------------------------------------------------
; Reboot
;
; Delays 5 seconds then reboots the PC.
;
;--------------------------------------------------------------------
Proc Reboot

	test	[BWTable.Settings], CFG_WAITKEY	; should we wait for a key?
	jz	noKey			; no key wait

	mov	bx, offset CRLF
	call	Print
	mov	bx, offset KeyWait
	call	Print			; print "Press a key..."

getKeyLoop:
	mov	ax, 0100h		; check status
	int	16h
	jb	getKeyLoop		; keep checking keyboard

	xor	ax, ax
	int	16h			; read key
	jmp	doReboot

noKey:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	bx, dx			; save starting time
	add	bx, 18*5		; wait 5 seconds

rebootLoop:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	cmp	bx, dx			; is time up?
	jnc	rebootLoop		; loop until times up

doReboot:
	cli				; disable interrupts
	db	0EAh, 0, 0, -1, -1	; reboot system

endp Reboot

KeyWait db	"Press a key to reboot system.", 0

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\common\print.asm ===
;====================================================================
; PRINT.ASM
;
; Print routines for Goliath
;
; $History: PRINT.ASM $
; 
; *****************  Version 2  *****************
; User: Paul Cowan   Date: 17/08/98   Time: 9:26a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Removed _ErrorInit reference
; 
;====================================================================

public DontPrint
DontPrint	db 0

public	LangSeg
LangSeg		dw 0

extrn	_ErrorInit:byte			; AI
extrn	tx_NoServer			; TCP/IP
extrn	tx_NoBINL			; TCP/IP
extrn	tx_toomanytries			; TCP/IP

TABLESIZE = 7

Tbl	dw	ErrorMsg		; 2
	dw	_NodeString		; 4
	dw	tx_NoServer		; 5
	dw	tx_NoBINL		; 6
	dw	tx_toomanytries		; 7
	dw	KeyWait			; 8

;--------------------------------------------------------------------
; Print
;
; Parameters:
;	ds:bx - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc Print

	cmp	[DontPrint], 0		; is printing enabled
	je	doPrint			; yes
	ret

doPrint:
	pusha				; save all registers
	push	es			; save es
	mov	si, bx			; move string address to si

	cmp	[LangSeg], 0		; did we load a language?
	je	notLang			; no

	xor	bx, bx
	mov	cx, TABLESIZE

tblLoop:
	cmp	si, [Tbl+bx]		; is string address in table?
	je	foundString		; yes

	add	bx, 2
	loop	tblLoop
	jmp	notLang			; address not found in table

foundString:
	mov	ax, [LangSeg]
	mov	es, ax			; set es to language segment

	mov	ax, [es:68+bx]		; get pointer from language table
	cmp	ax, 0			; is an address given?
	je	notLang			; no

	mov	si, ax			; use new address
	jmp	printLoop

notLang:
	push	ds
	pop	es			; set es to our segment

printLoop:
	mov	al, [es:si]
	inc	si
	or	al, al			; found NULL?
	jz	done			; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printLoop		; do next character

done:
	pop	es			; restore ds
	popa				; restore all registers
	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\drvseg.inc ===
;----------------------------------------------------------------------
; DRVSEG.INC
;
; Segment definitions for all BootWare ROMs.
;
; 961226 PC - added Code_NID and Code_NAD, changed alignments to para
;	    - added IDEAL mode support
; 960105 PC - added INIT segment
; 951030 PC
;----------------------------------------------------------------------
Group	cGroup Code, Sparse
	assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

Macro	START_CODE
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_CODE
ends
endm

Macro	START_SPARSE
Segment	Sparse Public "Code"
endm

Macro	END_SPARSE
ends
endm

;====================================================================
; Use all the marcos to set the order of the segments.
;====================================================================

START_CODE
END_CODE

START_SPARSE
END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; $Author: Paul Cowan $
; $Modtime: 7/20/98 17:25 $
; $Revision: 5 $
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------

LOADER_FLOPPY 	= 1
LOADER_TSR	= 2
LOADER_BBS	= 4
LOADER_BIOS	= 4000h

Struc	Header
	Jump		dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
ends

Struc	UNDIHdr
			dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
	SizeHdr		dw	?
	SizeCode	dw	?
	SizeData	dw	?
	SizeBSS 	dw	?
	LanOption	db	?
ends

Struc	BWT
	Size		db	?	; size of table
	Ver		db	?	; table version
	RomVer		dw	?	; ROM version
	RomType		dw	?	; ROM BootWare type
	Settings	dd	?	; current configuration settings
	Capabilities	dd	?	; ROM capabilities
	Defaults	dd	?	; factory defaults
	EEMask		dd	?	; EEROM mask
	NWFile		db 14 dup(?)	; NetWare default file name
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\loader.inc ===
Struc	LoaderInfo
	LangSeg		dw	?
	PCIBusDevFunc	dw	?
	VendorID	dw	?
	DeviceID	dw	?
	CSN		dw	?
	UNDICode	dw	?	; UNDI code size
	UNDIData	dw	?	; UNDI data size
	UNDISeg		dw	?	; UNDI segment
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\config.inc ===
;--------------------------------------------------------------------------
; CONFIG.INC
;
; Include file for BootWare ROM Configuration screen.
;
; $Author: Paul Cowan $
; $Modtime: 21/08/98 9:38a $
; $Revision: 8 $
;--------------------------------------------------------------------------

CFG_INITIALIZED	equ	0000000000000001b
CFG_METHOD	equ	0000000000000110b
CFG_PROTOCOL	equ	0000000000011000b
CFG_LOCAL	equ	0000000000100000b
CFG_CONFIG	equ	0000000001000000b
CFG_NOLOCAL	equ	0000000010000000b
CFG_NOTNEXTBBS	equ	0000000100000000b
CFG_MESSAGE	equ	0000001000000000b
CFG_TIMEOUT	equ	0000110000000000b
CFG_WAITKEY	equ	0001000000000000b
CFG_OTHER	equ	1110000000000000b

CFG_VERSION	equ	00010000000000000000b

API_VER		equ	0100h

PROT_PXE	equ	000b
PROT_TCPIP	equ	010b
PROT_NETWARE	equ	100b
PROT_RPL	equ	110b

NW_8022		equ	00000b
NW_8023		equ	01000b
NW_ETHII	equ	10000b

IP_BOOTP	equ	00000b
IP_DHCP		equ	01000b
IP_BINL		equ	10000b

TIME0		equ	0000000000000000b
TIME1		equ	0000010000000000b
TIME2		equ	0000100000000000b
TIME3		equ	0000110000000000b

CAP_PXE		equ	1
CAP_TCPIP	equ	2
CAP_NETWARE	equ	4
CAP_RPL		equ	8

IFDEF _IDEAL_
Struc	CfgData
	Row		db	?	; screen row
	Item		db	?	; current item
	Title		dw	?	; pointer to field name
	Type		db	?	; field type
	Changed		db	?	; field changed flag
	Width		db	?	; field text width
	Options		db	?	; number of options in field
	OldVal		dw	?	; orignal value
	NewVal		dw	?	; new value
	Values		dw	?	; pointer to values
	Text		dw	?	; pointer to value strings
ends
ELSE
CfgData Struc
	ConfigRow	db	?	; screen row
	ConfigItem	db	?	; current item
	ConfigTitle	dw	?	; pointer to field name
	ConfigType	db	?	; field type
	ConfigChanged	db	?	; field changed flag
	ConfigWidth	db	?	; field text width
	ConfigOptions	db	?	; number of options in field
	ConfigOldVal	dw	?	; orignal value
	ConfigNewVal	dw	?	; new value
	ConfigValues	dw	?	; pointer to values
	ConfigText	dw	?	; pointer to value strings
CfgData ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\bwnid.inc ===
;====================================================================
; BWNID.INC
;
; Include for for BootWare NID modules.
;
; 970116 PC - first version
;====================================================================

	include "..\include\bwstruct.inc"
	include "..\include\ai.inc"

;--------------------------------------------------------------------
; COMMON.OBJ functions
;--------------------------------------------------------------------
extrn	PrintTitle:near
extrn	Print:near
extrn	PrintChar:near
extrn	PrintCRLF:near
extrn	PrintDecimal:near
extrn	ClearScreen:near
extrn	StoDec:near
extrn	Reboot:near
extrn	ErrorMsg:byte

;--------------------------------------------------------------------
; Adapter interface functions
;--------------------------------------------------------------------
extrn	AIInitialize:near
extrn	AITransmit:near
extrn	AIReceive:near
extrn	AIChangeReceiveMask:near
extrn	AIDisengage:near
extrn	AITransmitPkt:near
extrn	AITransmitRaw:near
extrn	AITransmitIP:near
extrn	AITransmitUDP:near
extrn	AIOpenTFTP:near
extrn	AISetCallBack:near
extrn	ReceiveExp:near
extrn	CheckRxBuffer:near
extrn	NetAddress:byte
extrn	Verbose:byte
extrn	BWTable:BWT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\ai.inc ===
BW_GETINFO	= 0
BW_DISENGAGE	= 1
BW_RECEIVE	= 2
BW_SETCALLBACK	= 3
BW_CHANGEMASK	= 4
BW_TRANSMITRAW	= 5
BW_TRANSMITIP	= 6
BW_TRANSMITUDP	= 7
BW_OPENTFTP	= 8
BW_TRANSMITPKT	= 9

;------------------------------------------------
; API Structures
;------------------------------------------------
Struc AIINFOStruct
	Ver		dw	?	; version of the info structure
	RomVer		dw	?	; version of the ROM
	RomType		dw	?	; type of ROM
	MaxFrame	dw	?	; maximum frame size
	BootPro		dw	?	; current boot protocol
	NetAddress	dw	?,?,?	; MAC address
	LocalIP		dw	?,?	; local IP address
	ServerIP	dw	?,?	; server IP address
	BOOTPPkt	dw	?, ?	; address of BOOTP/DHCP packet
	DiscoverPkt	dw	?, ?	; address of DHCP discover packet
	BINLPkt		dw	?, ?	; address of BINL packet
ends

Struc TxPktStruct
	Size		dw	?
	Address		dw	?, ?, ?
	Data		dw	?, ?
	Length		dw	?
	Type		dw	?
ends

Struc TxIPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	Data		dw	?, ?
	Length		dw	?
	Protocol	db	?
ends

Struc TxUDPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	SourcePort	dw	?
	DestPort	dw	?
	Data		dw	?, ?
	Length		dw	?
ends

Struc OpenTFTPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	Flags		dw	?
	FileName	dw	?,?
	Callback	dd	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai.asm ===
;====================================================================
; AI.ASM
;
; Adapter interface layer for BootWare.
;
; $History: AI.ASM $
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 4:50p
; Updated in $/Client Boot/BW98/BootWare/AI
; Improved handling of UNDI initialization errors.
;
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 7/21/98    Time: 15:16
; Updated in $/Client Boot/BW98/BootWare/AI
; Corrected AIChangeReceiveMask return codes.
;
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 06/10/98    Time: 12:54
; Updated in $/Client Boot/BW98/BootWare/AI
; Removed printing of UNDI error code.
;
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 05/28/98    Time: 17:44
; Updated in $/Client Boot/BW98/BootWare/AI
; Changed to new config table format.
;
; *****************  Version 2  *****************
; User: Paul Cowan   Date: 05/25/98    Time: 12:05
; Updated in $/Client Boot/BW98/BootWare/AI
; Received ARP's are only processed if we sent the request.
;
;====================================================================

IDEAL
_IDEAL_ = 1
Locals
	include "..\include\drvseg.inc"
	include "..\include\bwstruct.inc"
	include "..\tcpip\tcpip.inc"
	include "..\include\undi_api.inc"
	include "..\include\ai.inc"

MTU = 1525

public	AIInitialize
public	AIChangeReceiveMask
public	AIDisengage
public	AIDisengageNW
public	AITransmitPkt
public	AITransmitIP
public	AITransmitUDP
public	AIOpenTFTP
public	AISetCallback
public	AIPoll

public	CheckRxBuffer

public	AITbl

public	TxBuffer
public	BufferSize

public	UNDI

public	TxData				; public for NW NID
public	TxTBD
public	TxData0
public	TxData1
public	TxData2

public	NIC_IRQ
public	NIC_IO
public	NetAddress

extrn	BootWareSize:word
extrn	ConfigSize:word
extrn	PCIBusDevFunc:word
extrn	CSN:word
extrn	Verbose:byte

extrn	BWTable:BWT

;--------------------------------------------------------------------
; COMMON.OBJ functions
;--------------------------------------------------------------------
extrn	PrintSettings:near
extrn	Print:near
extrn	PrintDecimal:near
extrn	PrintCRLF:near
extrn	Reboot:near

;------------------------------------------------
; TCP/IP NID labels
;------------------------------------------------
extrn	LocalIP:word
extrn	ServerIP:word
extrn	BootPkt:word
extrn	DiscoverPkt:word
extrn	BINLPkt:word

ERROR_UNKNOWNIP	= 25

;====================================================================
;			  Code segment
;====================================================================
START_CODE
P386

public _AIStart
label _AIStart

ID	db	'BWAPI'		; identifer string (don't change)
	db	2		; version of the API table (don't change)
	dw	0		; offset of NAD table
AITbl	dw	ApiEntry, 0	; external jump table

	db	'AI*980525*'	; build date
	dw	0200h		; build version

CallBackRaw	dd	0
CallBackIP	dd	0
CallBackUDP	dd	0
CallBackTFTP	dd	0
ListenPort	dw	0

NoCallbacks	db	0

Ident		dw	0

LastError	dw	0

UNDI		dd	0

Initializing	db	'Initializing adapter...', 13, 10, 0

;public _ErrorInit
;_ErrorInit	db	7, "Error: Unable to initialize adapter", 0

;----------------------------------------------------------------------
; AIInitialize
;
; Parameters:
;	bx - UNDI segment
;	cx - UNDI code size
;	dx - UNDI data size
;	si - pointer to receive buffer
;	ds - RAM segment
;
; Returns:
;	doesn't
;----------------------------------------------------------------------
Proc AIInitialize

	push	cx			; save UNDI code size
	push	dx			; save UNDI data size

	mov	[word ptr UNDI+2], bx	; save UNDI segment
	mov	[RxBuffer], si		; set receive buffer area

	mov	[AITbl+2], ds		; set API segment

	cmp	[Verbose], 0		; is verbose mode on
	je	skip1

	mov	bx, offset Initializing
	call	Print			; print "Initializing adapter"

skip1:
	pop	dx			; restore UNDI data size
	pop	cx			; restore UNDI code size

	call	InitUNDI		; initialize the UNDI
	cmp	ax, 0			; was an error message returned?
	je	undiOK			; no error

;	call	PrintCRLF
;	mov	bx, offset _ErrorInit
;	call	Print			; display the error message

	jmp	Reboot			; reboot the workstation

undiOK:
	call	PrintSettings		; print the adapters settings

	call	InitMemory		; initialize our memory buffers

	ret				; we are initialized

endp

;-----------------------------------------------------------------------------
; InitUNDI
;
; Parameters:
;	cx - UNDI code size
;	dx - UNDI data size
;
; Returns:
;	ax - error code (0 = OK)
;-----------------------------------------------------------------------------
Proc InitUNDI

	push	ds
	pop	es			; es = ds

	push	cx			; save UNDI code size

	mov	di, offset CallBuff
	mov	cx, size S_UNDI_STARTUP_PCI
	xor	ax, ax
	rep	stosb			; clear data structure

	mov	di, offset CallBuff

	mov	ax, [PCIBusDevFunc]	; get PCI Bus/Device/Function value
	cmp	ax, 0			; do we have a value?
	je	notPCI			; no - it's not PCI

	mov	[(S_UNDI_STARTUP_PCI di).BusType], BUS_PCI
	mov	[(S_UNDI_STARTUP_PCI di).BusDevFunc], ax

	jmp	@@skip

notPCI:
	mov	ax, [CSN]		; get PnP card selction number
	mov	[(S_UNDI_STARTUP_PNP di).BusType], BUS_ISA
	mov	[(S_UNDI_STARTUP_PNP di).CSN], ax

@@skip:
	; store UNDI data size
	mov	[(S_UNDI_STARTUP_PCI di).DataSegSize], dx

	; store UNDI code size
	pop	ax			; get UNDI code size
	mov	[(S_UNDI_STARTUP_PCI di).CodeSegSize], ax

	; calc starting location for UNDI data from UNDI segment
	add	ax, 0Fh			; so address will start on a paragraph
	shr	ax, 4			; divide by 16
	add	ax, [word ptr UNDI+2]	; add UNDI starting segment

	mov	[(S_UNDI_STARTUP_PCI di).DataSegment], ax
;	mov	di, offset CallBuff
	mov	bx, UNDI_STARTUP
	call	[UNDI]			; call UNDI_STARTUP

	mov	[(S_UNDI_INITIALIZE di).Status], 0
	mov	[(S_UNDI_INITIALIZE di).ProtocolIni], 0
	mov	[(S_UNDI_INITIALIZE di).ReceiveOffset], offset RxInt
	mov	[(S_UNDI_INITIALIZE di).ReceiveSegment], cs
	mov	[(S_UNDI_INITIALIZE di).GeneralIntOff], offset GeneralInt
	mov	[(S_UNDI_INITIALIZE di).GeneralIntSeg], cs
	mov	di, offset CallBuff
	mov	bx, UNDI_INITIALIZE
	call	[UNDI]			; call UNDI_INITIALIZE
	jnc	initOK			; jump if no error

	; handle returned error message
	mov	bx, offset InitError
	call	Print			; print "UNDI Initialize failed, "

	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	cmp	ax, 61h			; is error media?
	jne	notMedia		; no

	mov	bx, offset MediaError
	call	Print			; print media error message
	jmp	initBad

notMedia:
	mov	bx, offset InitError2
	call	Print

	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	call	PrintDecimal

	jmp	initBad

initOK:
	mov	di, offset CallBuff
	mov	bx, UNDI_GET_INFORMATION
	call	[UNDI]			; call UNDI_GET_INFORMATION

	mov	ax, [(S_UNDI_GET_INFO CallBuff).IntNumber]
	mov	[NIC_IRQ], al

	mov	ax, [(S_UNDI_GET_INFO CallBuff).BaseIo]
	mov	[NIC_IO], ax

	lea	si, [(S_UNDI_GET_INFO CallBuff).PermNodeAddress]
	mov	di, offset NetAddress
	movsw
	movsw
	movsw

	; open the adapter
	mov	[(S_UNDI_OPEN CallBuff).Status], 0
	mov	[(S_UNDI_OPEN CallBuff).OpenFlag], 0
	mov	[(S_UNDI_OPEN CallBuff).PktFilter], FLTR_DIRECTED
	mov	di, offset CallBuff
	mov	bx, UNDI_OPEN
	call	[UNDI]			; call UNDI_OPEN
	jnc	openOK

	mov	bx, offset OpenError
	call	Print

initBad:
	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	ret				; return with error

openOK:
	xor	ax, ax			; return - no error
	ret

endp

InitError  db "UNDI Initialize failed, ", 0
MediaError db "no media detected.", 0
InitError2 db "error # ", 0

OpenError db "UNDI Open failed.", 0

;--------------------------------------------------------------------
; InitMemory
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc InitMemory

	push	ds
	pop	es			; set es=ds

	; Initialize the pointers in the Transmit data structure
	mov	[TxData.TBDOffset], offset TxTBD
	mov	[TxData.TBDSegment], ds
	mov	[TxTBD.Length], 0		; no immediate data
	xor	al, al
	mov	[TxData.XmitFlag], al	; we will always supply dest address
	mov	[TxData.Protocol], al	; we will build the MAC header

	inc	al			; al =1
	mov	[TxData0.PtrType], al	; pounter type is seg:offset
	mov	[TxData1.PtrType], al
	mov	[TxData2.PtrType], al

	mov	[BufferSize], 0		; clear buffer size

	ret

endp

;----------------------------------------------------------------------
;----------------------------------------------------------------------
Proc GeneralInt far

	xor	ax, ax			; return success
	ret

endp


;--------------------------------------------------------------------
; AIChangeReceiveMask
;
; Returns:
;	TRUE/FALSE
;--------------------------------------------------------------------
Proc AIChangeReceiveMask

	test	bx, 2			; are we changing broadcasts?
	je	notBroadcasts		; no

	; enable only unicast packets
	mov	[(S_UNDI_SET_PACKET_FILTER CallBuff).Filter], FLTR_DIRECTED

	test	bx, 1			; are we enabling broadcasts?
	je	disableBroadcasts	; no

	; enable broadcast and unicast packets
	mov	[(S_UNDI_SET_PACKET_FILTER CallBuff).Filter], FLTR_BDRCST or FLTR_DIRECTED

disableBroadcasts:
	mov	di, offset CallBuff
	mov	bx, UNDI_SET_PACKET_FILTER
	call	[UNDI]			; call UNDI_SET_PACKET_FILTER

	cmp	[(S_UNDI_SET_PACKET_FILTER CallBuff).Status], 0
	jne	notBroadcast		; UNDI returned error
	mov	ax, 1			; return TRUE
	ret

notBroadcasts:
	xor	ax, ax			; return FALSE
	ret

endp

;====================================================================
;				Exported functions
;====================================================================
EVEN
APITable	dw	AIGetInfo	; 0
		dw	AIDisengage	; 1
		dw	AIReceive	; 2
		dw	AISetCallBack	; 3
		dw	AIChangeRxMask	; 4
		dw	AITransmitRaw	; 5
		dw	AITransmitIP	; 6
		dw	AITransmitUDP	; 7
		dw	AIOpenTFTP	; 8
		dw	AITransmitPkt	; 9

MAX_API = 9

;--------------------------------------------------------------------
; ApiEntry
;
; Parameters:
;	bx - function number
;
; Returns:
;	what ever the called function returns
;--------------------------------------------------------------------
Proc ApiEntry far

	cmp	bx, MAX_API		; is the function a valid value?
	ja	badAPI			; not valid

	push	ds			; save caller ds
	push	cs
	pop	ds			; ds = cs

	shl	bx, 1			; value times 2
	call	[APITable+bx]		; call the function

	pop	ds			; restore caller ds

	ret

badAPI:
	mov	ax, -1
	ret

endp

;--------------------------------------------------------------------
; AIGetInfo
;
; Returns current settings and information from the ROM.
;
; Parameters:
;	none
;
; Returns:
;	es:di - pointer to Info structure
;--------------------------------------------------------------------
Proc AIGetInfo

	push	ax			; save ax
	push	si			; save si

	push	ds
	pop	es			; es = ds

	mov	[RomInfo.Ver], 2	; version of ROM info structure

	mov	ax, [BWTable.RomVer]
	mov	[RomInfo.RomVer], ax	; set ROM version

	mov	ax, [BWTable.RomType]
	mov	[RomInfo.RomType], ax	; set ROM type

	mov	[RomInfo.MaxFrame], 1500

	xor	ax, ax
;	mov	al, [BWTable.LANOS]
	mov	[RomInfo.BootPro], ax	; set current boot protocol

	mov	di, offset RomInfo.NetAddress
	mov	si, offset NetAddress	; get offset of our network address
	movsw				; copy network address
	movsw
	movsw

	mov	ax, [LocalIP]		; copy local IP address
	mov	[RomInfo.LocalIP], ax
	mov	ax, [LocalIP+2]
	mov	[(RomInfo.LocalIP)+2], ax

	mov	ax, [ServerIP]		; copy server IP address
	mov	[RomInfo.ServerIP], ax
	mov	ax, [ServerIP+2]
	mov	[(RomInfo.ServerIP)+2], ax

	mov	[RomInfo.BOOTPPkt], offset BootPkt
	mov	[(RomInfo.BOOTPPkt)+2], cs

ifdef GOLIATH
	mov	[RomInfo.DiscoverPkt], offset DiscoverPkt
	mov	[(RomInfo.DiscoverPkt)+2], cs

	mov	[RomInfo.BINLPkt], offset BINLPkt
	mov	[(RomInfo.BINLPkt)+2], cs
endif ;GOLIATH

	mov	di, offset RomInfo	; return offset of structure

	pop	si			; restore si
	pop	ax			; restore ax
	ret

endp

;--------------------------------------------------------------------
; AIDisengage
;
; Shuts down the adapter.  Simply calls NADDisengage to do the work.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIDisengage

	; close the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLOSE
	call	[UNDI]			; call UNDI_CLOSE

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_SHUTDOWN
	call	[UNDI]			; call UNDI_SHUTDOWN

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLEANUP
	call	[UNDI]			; call UNDI_CLEANUP

	mov	[word ID], 0		; kill our API ID string
	ret

endp

;--------------------------------------------------------------------
; AIDisengageNW
;
; Special disengage function used with NetWare.  Removes the UNDI
; without shutting down the adapter.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIDisengageNW

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLEANUP
	call	[UNDI]			; call UNDI_CLEANUP

	mov	[word ID], 0		; kill our API ID string
	ret

endp

;--------------------------------------------------------------------
; AISetCallBack
;
; Returns current settings and information from the ROM.
;
; Parameters:
;	none
;
; Returns:
;	es:di - pointer to call back function
;--------------------------------------------------------------------
Proc AISetCallBack

	cmp	cx, -1			; are we clearing callbacks?
	jne	notClearing

	mov	[word ptr CallBackRaw], 0
	mov	[word ptr CallBackIP], 0
	mov	[word ptr CallBackUDP], 0
	ret

notClearing:
	cmp	cx, 1			; are we setting a raw call back?
	jne	notRaw			; no

	mov	[word ptr CallBackRaw], di
	mov	[word ptr CallBackRaw+2], es
	jmp	setCallBackExit

notRaw:
	cmp	cx, 2			; are we setting an IP call back?
	jne	notIP			; no

	mov	[word ptr CallBackIP], di
	mov	[word ptr CallBackIP+2], es
	jmp	setCallBackExit

notIP:
	cmp	cx, 3			; are we setting a UDP call back?
	jne	notUDP			; no

	mov	[word ptr CallBackUDP], di
	mov	[word ptr CallBackUDP+2], es
	xchg	dl, dh			; flip bytes into network order
	mov	[ListenPort], dx	; save listening port

notUDP:
setCallBackExit:
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc AIChangeRxMask

	mov	bx, ax			; move bit mask into bx for NAD
	call	AIChangeReceiveMask
	ret

endp

;--------------------------------------------------------------------
; AITransmitRaw
;
; Exportable version of Transmit.
;
; Parameters:
;	es:di - pointer to complete packet
;	cx - packet length
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitRaw

	pusha				; save everything
	push	es			; save es

	mov	[TxData0.Len], cx	; set data lenght
	mov	[TxData0.Off], di	; set data offset
	mov	[TxData0.Seg], es	; set data segment

	mov	ax, cs
	mov	es, ax			; es = cs

	mov	[TxTBD.DataBlkCount], 1	; set number of data blocks

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitPkt
;
; Exportable version of Transmit.
;
; Parameters:
;	es:di - pointer to TxPkt structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitPkt

	cmp	[(TxPktStruct es:di).Size], size TxPktStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:

	pusha				; save everything
	push	es			; save es

	; Setup data block 1 to supplied data.
	mov	ax, [(TxPktStruct es:di).Length]
	mov	[TxData1.Len], ax		; set the length of the data
	mov	ax, [(word ptr (TxPktStruct es:di).Data)]
	mov	[TxData1.Off], ax		; set the offset of the data
	mov	ax, [(word ptr (TxPktStruct es:di).Data)+2]
	mov	[TxData1.Seg], ax		; set the segment of the data

	;----------------------------------------
	; Build MAC destination address
	;----------------------------------------
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	push	ds

	lea	si, [(TxPktStruct es:di).Address]

	push	es
	push	ds
	pop	es			; es = our segment
	pop	ds			; ds = caller segment

	mov	di, offset MACHeader
	movsw				; set destination address
	movsw
	movsw

	pop	ds			; restore our ds

	mov	si, offset NetAddress	; source address is us
	movsw
	movsw
	movsw

	mov	ax, [TxData1.Len]
	xchg	al, ah
	stosw				; set type/lenght field

	mov	[TxTBD.DataBlkCount], 2	; set number of data blocks

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitIP
;
; IP layer transmit packet.
;
; Parameters:
;	es:di - pointer to TxIP structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitIP

	cmp	[(TxIPStruct es:di).Size], size TxIPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	pusha				; save everything
	push	es			; save es

	; Setup data block 2 to supplied data.
	mov	ax, [(TxIPStruct es:di).Length]
	mov	[TxData2.Len], ax		; set the length of the data
	mov	ax, [(word ptr (TxIPStruct es:di).Data)]
	mov	[TxData2.Off], ax		; set the offset of the data
	mov	ax, [(word ptr (TxIPStruct es:di).Data)+2]
	mov	[TxData2.Seg], ax		; set the segment of the data

	;----------------------------------------
	; Build the IP header.
	;----------------------------------------
	mov	ax, [word ptr (TxIPStruct es:di).Address]
	mov	dx, [word ptr ((TxIPStruct es:di).Address)+2]
	mov	bl, [(TxIPStruct es:di).Protocol]
	mov	cx, [(TxIPStruct es:di).Length]
	call	BuildHeaderIP		; build the IP header

	;----------------------------------------
	; Build the MAC header.
	;----------------------------------------
	mov	eax, [(TxIPStruct es:di).Gateway]
	cmp	eax, 0			; is there a gateway IP address?
	jne	haveGW			; yes, use it

	mov	eax, [(TxIPStruct es:di).Address]
haveGW:
	call	BuildHeaderMAC		; build the MAC header
	je	@@skip

	pop	es			; restore es
	popa				; restore everything
	mov	ax, [LastError]		; return the error code
	ret

@@skip:
	;----------------------------------------
	; Build the transmit structure
	;----------------------------------------
	mov	[TxTBD.DataBlkCount], 3	; set number of data blocks

	; data block 0 is MAC header.
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	; fragment 1 is IP header.
	mov	[TxData1.Len], size IP
	mov	[TxData1.Off], offset IPHdr
	mov	[TxData1.Seg], ds

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitUDP
;
; Transmit packet for UDP layer.
;
; Parameters:
;	es:di - pointer to TxUDP structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitUDP

	cmp	[(TxUDPStruct es:di).Size], size TxUDPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	pusha				; save everything
	push	es			; save es

	;----------------------------------------
	; Setup data block 2 to supplied data.
	;----------------------------------------
	mov	ax, [(TxUDPStruct es:di).Length]
	mov	[TxData2.Len], ax
	mov	ax, [(TxUDPStruct es:di).Data]
	mov	[TxData2.Off], ax
	mov	ax, [((TxUDPStruct es:di).Data)+2]
	mov	[TxData2.Seg], ax

	;----------------------------------------
	; Build the IP header.
	;----------------------------------------
	mov	ax, [word ptr (TxUDPStruct es:di).Address]
	mov	dx, [word ptr ((TxUDPStruct es:di).Address)+2]
	mov	bl, 17			; protocol is UDP
	mov	cx, [(TxUDPStruct es:di).Length]
	add	cx, size UDP		; add UDP header size
	call	BuildHeaderIP		; build the IP header

	;----------------------------------------
	; Build the UDP header.
	;----------------------------------------
	mov	ax, [(TxUDPStruct es:di).SourcePort]
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.SourcePort], ax
	mov	ax, [(TxUDPStruct es:di).DestPort]
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.DestPort], ax
	mov	ax, [(TxUDPStruct es:di).Length]
	add	ax, size UDP		; add UDP header size
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.Len], ax
	mov	[UDPHdr.Sum], 0

	call	CalcUDPSum
	mov	[UDPHdr.Sum], ax	; save sum in header

	;----------------------------------------
	; Build the MAC header.
	;----------------------------------------
	mov	eax, [(TxUDPStruct es:di).Gateway]
	cmp	eax, 0			; is there a gateway IP address?
	jne	haveGW2			; yes, use it

	mov	eax, [(TxUDPStruct es:di).Address]

haveGW2:
	call	BuildHeaderMAC		; build the MAC header
	je	@@skip

	pop	es			; restore es
	popa				; restore everything
	mov	ax, [LastError]		; return the error code
	ret

@@skip:
	;----------------------------------------
	; Build the transmit structure
	;----------------------------------------
	mov	[TxTBD.DataBlkCount], 3	; set number of data blocks

	; data block 0 is MAC header.
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	; data block 1 is IP header & UDP header.
	mov	[TxData1.Len], size IP + size UDP
	mov	[TxData1.Off], offset IPHdr
	mov	[TxData1.Seg], ds

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; CalcUdpSum
;
; Calculates checksum for UDP header.
;
; Parmeters:
;	es:di - pointer to TxUDP structure
;
; Returns:
;	ax	- sum
;--------------------------------------------------------------------
Proc CalcUdpSum

	xor	bx, bx			; sum = 0, carry clear

	;------------------------------------------------------------
	; Add items in the IP header.
	;------------------------------------------------------------
	mov	ah, [IPHdr.Protocol]	; get IP protocol byte
	mov	al, 0
	adc	bx, ax

	; add IP source and destination address values
	adc	bx, [IPHdr.SourceIP]
	adc	bx, [(IPHdr.SourceIP)+2]
	adc	bx, [IPHdr.DestIP]
	adc	bx, [(IPHdr.DestIP)+2]

	;------------------------------------------------------------
	; Add the UDP header.
	;------------------------------------------------------------
	adc	bx, [UDPHdr.Len]	; add value of UDP length

	mov	si, offset UDPHdr	; add all the items in UDP
	mov	cx, (size UDP)/2

sumLoop2:
	lodsw
	adc	bx, ax
	loop	sumLoop2

	;------------------------------------------------------------
	; Add all the words in data buffer.
	;------------------------------------------------------------
	push	ds			; save our ds

	lds	si, [dword ptr (TxUDPStruct es:di).Data]
	mov	cx, [(TxUDPStruct es:di).Length]
	mov	dx, cx			; save length in dx

	pushf				; save flags (carry)
	shr	cx, 1			; change to word count
	popf				; restore flags

sumLoop3:
	lodsw
	adc	bx, ax
	loop	sumLoop3

	adc	bx, 0			; add the carry bit
					; (the next test will clear carry)
	test	dx, 1			; was size odd number?
	je	size_even		; no - it's even

	lodsb				; get last byte
	mov	ah, 0			; change to word
	adc	bx, ax			; add last value

size_even:
	pop	ds			; restore our ds

	adc	bx, 0			; add the last carry bit
	not	bx			; do 1's complement

	or	bx, bx			; was the result 0?
	jne	sumNot0

	not	bx			; change sum to -1

sumNot0:
	mov	ax, bx
	ret				 ; ax has sum

endp

;--------------------------------------------------------------------
; BuildHeaderIP
;
; Builds an IP header.
;
; Parameters:
;	ax:dx - destination IP address
;	bl - IP protocol
;	cx - length of data
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc BuildHeaderIP

	;----------------------------------------
	; Build IP header
	;----------------------------------------
	mov	[IPHdr.Ver], 45h	; set version
	mov	[IPHdr.Type], 0		; set type
	mov	[IPHdr.FragOffSet], 0	; set fragment offset to 0
	mov	[IPHdr.Time], 60	; set time-to-live

	mov	[IPHdr.Protocol], bl	; set protocol

	add	cx, size IP		; add IP header size to length
	xchg	cl, ch			; flip words
	mov	[IPHdr.Len], cx		; set length

	mov	[IPHdr.DestIP], ax
	mov	[(IPHdr.DestIP)+2], dx	; set destination IP address

	mov	ax, [LocalIP]
	mov	[IPHdr.SourceIP], ax	; set source IP address
	mov	ax, [LocalIP+2]
	mov	[(IPHdr.SourceIP)+2], ax

	inc	[Ident]
	mov	ax, [Ident]		; get current identification
	xchg	al, ah			; flip words
	mov	[IPHdr.Ident], ax	; set identification

	;------------------------------------------------------------
	; Calc checksum of IP header.
	;------------------------------------------------------------
	mov	cx, (size IP)/2
	xor	ax, ax			; clear sum
	mov	[IPHdr.CheckSum], ax	; clear checksum

	mov	bx, offset IPHdr	; get location of IP header

ip_sum_loop:
	adc	ax, [bx]
	inc	bx
	inc	bx
	loop	ip_sum_loop

	adc	ax, 0			; add carry bit
	not	ax
	mov	[IPHdr.CheckSum], ax	; save checksum in packet

	ret

endp

;--------------------------------------------------------------------
; BuildHeaderMAC
;
; Builds a MAC header.
;
; Parameters:
;	ax:dx - destination IP address
;	bl - IP protocol
;	cx - length of data
;
; Returns:
;	ax - status (0 = OK)
;--------------------------------------------------------------------
Proc BuildHeaderMAC

	; resolve the IP address into a physical address
	call	ResolveIP		; get the physical address from IP
	or	si, si			; did we get an address?
	jne	resolvedIP		; yes

	; we were unable to resolve the IP address, so return an error
	mov	ax, ERROR_UNKNOWNIP	; return error message
	or	ax, ax
	jmp	@@exit

resolvedIP:
	push	ds
	pop	es			; es = ds

	; set MAC destination address
	mov	di, offset MACHeader
	movsw
	movsw
	movsw

	; set MAC source address
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	; set packet type
	mov	ax, 8
	stosw

	xor	ax, ax			; return "no error"

@@exit:
	mov	[LastError], ax
	ret

endp

;--------------------------------------------------------------------
; AIReceive
;
; Exportable version of Receive.
;
; Parameters:
;	es:di - pointer for complete packet
;	cx - max packet size
;
; Returns:
;	ax - received packet size
;--------------------------------------------------------------------
Proc AIReceive

	push	si			; save si
	push	di			; save di
	push	cx			; save cx

	push	di
	push	es
	call	CheckRxBuffer		; check for available data
	pop	es
	pop	di
	je	noData			; no data available

	mov	cx, ax			; move size to cx
	mov	si, [RxBuffer]		; get address of receive buffer

	rep	movsb			; copy data into caller buffer

	mov	[BufferSize], 0		; free our buffer

noData:
	pop	cx			; restore cx
	pop	di			; restore di
	pop	si			; restore si
	ret

endp

;====================================================================
;			Receive functions
;====================================================================

;----------------------------------------------------------------------
; RxInt
;
; Receive interrupt, called by UNDI when a packet is received.
;
; Parameters:
;	ax - length of media header
;	bl - protocol
;	bh - receive flag
;	cx - length of data
;	es:di - pointer to received buffer
;
; Returns:
;	ax = SUCCESS - packet processed
;	   = DELAY - packet not processed, keep it
;----------------------------------------------------------------------
Proc RxInt far

	pusha				; save everything
	push	ds			; save caller ds

	push	cs
	pop	ds			; ds = cs

	push	di			; save di
	push	cx			; save cx
	call	CheckCallBack		; check for a callback function
	pop	cx			; restore cx
	pop	di			; restore di
	jc	didCallback		; callback was called

	; a callback was not done, so we save the packet in our buffer,
	; but we can only save one packet
	cmp	[BufferSize], 0		; is there a packet in the buffer?
	je	bufferEmpty		; no, it's empty

	; we can't handle the packet now, so tell the UNDI to delay it
	pop	ds			; restore caller ds
	popa				; restore everything else
	mov	ax, DELAY		; return "delay"
	ret

bufferEmpty:
	mov	[BufferSize], cx	; save packet size

	push	es			; save es

	mov	si, di			; move source adddress to si
	mov	di, [RxBuffer]		; get address of receive buffer

	push	ds
	push	es
	pop	ds			; ds = packet segment
	pop	es			; es = our segment

	rep	movsb			; copy packet into RxBuffer

	pop	es			; restore es

didCallback:
	pop	ds			; restore caller ds
	popa				; restore everything
	mov	ax, SUCCESS		; return success
	ret

endp

;--------------------------------------------------------------------
; CheckCallBack
;
; Parameters:
;	es:di - received packet buffer
;	cs - packet length
;
; Returns:
;	carry set if callback done
;--------------------------------------------------------------------
Proc CheckCallBack

	mov	ax, [word ptr es:di+12]	; get packet type value

	cmp	ax, 0608h		; check for an ARP
	jne	noARP			; not an ARP packet

	call	ArpCallback		; process the ARP
	jnc	noARP			; ARP was not processed

	ret

noARP:
	cmp	[NoCallbacks], 0	; are call backs allowed?
	jne	noRawCallBack		; skip the callbacks

	cmp	ax, 8			; check for IP type code
	jne	noIPCallBack		; not an IP packet

	cmp	[word ptr CallBackUDP], 0; is there a UDP callback?
	je	noDUPCallBack		; no

	add	di, 14 + 20		; skip MAC and IP header
	mov	ax, [ListenPort]	; get our listening port
	cmp	[word ptr di+2], ax	; check if destination is our port
	jne	noDUPCallBack		; not on our port

	mov	cx, [word ptr di+4]	; get data length
	sub	cx, 8			; subtrack header size
	mov	ax, [word ptr di]	; get source port
	add	di, 8			; skip UDP header
	call	[CallBackUDP]		; do UDP call back
	stc				; set carry (callback done)
	ret

noDUPCallBack:
	cmp	[word ptr CallBackIP], 0; is a call back set for IP?
	je	noIPCallBack		; no

	sub	cx, 14+20		; subtrack header sizes
	add	di, 14+20		; skip MAC header and IP header
	call	[CallBackIP]		; do raw call back
	stc				; set carry (callback done)
	ret

noIPCallBack:
	cmp	[word ptr CallBackRaw], 0; is a call back set for raw?
	je	noRawCallBack		; no

	call	[CallBackRaw]		; do raw call back
	stc				; set carry (callback done)
	ret

noRawCallBack:
	clc				; clear carry - no callback
	ret

endp

;--------------------------------------------------------------------
; CheckRxBuffer
;
; Checks for data in the receive buffer.
;
; Parameters:
;	none
;
; Returns:
;	ax - received packet size
;	si - buffer address
;--------------------------------------------------------------------
Proc CheckRxBuffer

	cmp	[BufferSize], 0		; is there data in the buffer?
	jne	gotData			; buffer has data

	mov	di, offset CallBuff
	mov	bx, UNDI_FORCE_INTERRUPT
	call	[UNDI]			; call UNDI_FORCE_INTERRUPT

gotData:
	mov	ax, [BufferSize]
	mov	si, [RxBuffer]		; get address of receive buffer
	or	ax, ax
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc AIPoll

	pusha

	mov	di, offset CallBuff
	mov	bx, UNDI_FORCE_INTERRUPT
	call	[UNDI]			; call UNDI_FORCE_INTERRUPT

	popa
	ret

endp

;--------------------------------------------------------------------

include "ai_arp.asm"
include "ai_tftp.asm"

public _AIEnd
label _AIEnd

END_CODE

;====================================================================

START_SPARSE

public	_AIStartSparse
label _AIStartSparse

even
TxData		S_UNDI_TRANSMIT <?>
TxTBD		UNDI_TBD	<?>
TxData0		DATABLK		<?>
TxData1		DATABLK		<?>
TxData2		DATABLK		<?>

MACHeader	db	20 dup (?)	; transmit MAC header
IPHdr		IP	<?>	; transmit IP header
UDPHdr		UDP	<?>	; transmit UDP header

RomInfo		AIINFOStruct	<?>

NetAddress	dw	?, ?, ?	; our network address

StartTime	dw	?
Retrys		db	?

NIC_IRQ 	db	?	; adapter IRQ
NIC_IO		dw	?	; adapter I/O base

BufferSize	dw	?
RxBuffer	dw	?
TxBuffer	db	512 dup (?)

CallBuff	db	64 dup (?)

public	_AIEndSparse
label _AIEndSparse

END_SPARSE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\tftp_api.inc ===
;--------------------------------------------------------------------
; PXE TFTP constants and structures
;
;--------------------------------------------------------------------

PXENV_TFTP_OPEN		equ	20h
PXENV_TFTP_CLOSE	equ	21h
PXENV_TFTP_READ		equ	22h
PXENV_TFTP_READ_FILE	equ	23h

struc S_PXENV_TFTP_OPEN
	Status		dw	?
	ServerIP	db	4 dup(?)
	GatewayIP	db	4 dup(?)
	Filename	db	128 dup(?)
	TFTPPort	dw	?
	Flags		dw	?
ends

struc S_PXENV_TFTP_CLOSE
	Status		dw	?
ends

struc S_PXENV_TFTP_READ
	Status		dw	?
	PacketNumber	dw	?
	BufferSize	dw	?
	BufferOff	dw	?
	BufferSeg	dw	?
ends

struc S_PXENV_TFTP_READ_FILE
        Status		dw	?
        FileName	db	128 dup(?)
        BufferSize	dd	?
        BufferOffset	dd	?
        ServerIP	db	4 dup(?)
        GatewayIP	db	4 dup(?)
        McastIP		db	4 dup(?)
        TFTPClntPort	dw	?
        TFTPSrvPort	dw	?
        TFTPOpenTimeOut	dw	?
        TFTPReopenDelay dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\include\undi_api.inc ===
;--------------------------------------------------------------------
; PXE UNDI constants and structures
;
;--------------------------------------------------------------------

BUS_ISA		equ	0
BUS_PCI		equ	3

SUCCESS		equ	0
DELAY		equ	-1

UNDI_STARTUP	 	equ	01h
UNDI_CLEANUP	 	equ	02h
UNDI_INITIALIZE 	equ	03h
UNDI_RESET_NIC		equ	04h
UNDI_SHUTDOWN		equ	05h
UNDI_OPEN		equ	06h
UNDI_CLOSE		equ	07h
UNDI_TRANSMIT		equ	08h
UNDI_SET_MCAST_ADDR	equ	09h
UNDI_SET_STATION_ADDR	equ	0Ah
UNDI_SET_PACKET_FILTER	equ	0Bh
UNDI_GET_INFORMATION	equ	0Ch
UNDI_GET_STATISTICS	equ	0Dh
UNDI_CLEAR_STATISTICS	equ	0Eh
UNDI_INITIATE_DIAGS	equ	0Fh
UNDI_FORCE_INTERRUPT	equ	10h
UNDI_GET_MCAST_ADDR	equ	11h
UNDI_GET_NIC_TYPE	equ	12h
UNDI_GET_NDIS_INFO	equ	13h

ADDR_LEN		equ	16
MAXNUM_MCADDR		equ	8

struc S_UNDI_MCAST_ADDR
	MCastAddrCount	dw	?
	MCastAddr	db (8*16) dup (?)
ends

struc S_FORCE_INTERRUPT
	Status		dw	?
ends

struc S_UNDI_CLOSE
	Status		dw	?
ends

struc S_UNDI_STARTUP_PCI
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegment	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	BusDevFunc	dw	?
	PCI_ds_off	dw	?
	PCI_ds_seg	dw	?
ends

struc S_UNDI_STARTUP_PNP
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegment	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	CSN		dw	?
	PnP_eh_off	dw	?
	PnP_eh_seg	dw	?
ends

struc S_UNDI_INITIALIZE
	Status		dw	?
	ProtocolIni	dd	?
	ReceiveOffset	dw	?
	ReceiveSegment	dw	?
	GeneralIntOff	dw	?
	GeneralIntSeg	dw	?
ends

struc S_UNDI_OPEN
	Status		dw	?
	OpenFlag	dw	?
	PktFilter	dw	?
	MCastBuffer	S_UNDI_MCAST_ADDR <?>
ends

FLTR_DIRECTED	equ	1
FLTR_BDRCST	equ	2
FLTR_PRMSCS	equ	4
FLTR_SRC_RTG	equ	8

struc S_UNDI_GET_INFO
	Status		dw	?
	BaseIo		dw	?
	IntNumber	dw	?
	MaxTranUnit	dw	?
	HwType		dw	?
	HwAddrLen	dw	?
	CurrentNodeAddress db	ADDR_LEN dup(?)
	PermNodeAddress db	ADDR_LEN dup(?)
	RomAddress	dw	?
	RxBufCt		dw	?
	TxBufCt		dw	?
ends

ETHER_TYPE = 1

struc S_UNDI_GET_NIC_TYPE_PCI
	Status		dw	?
	NicType		db	?
	Vendor_ID	dw	?
	Dev_ID		dw	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	Rev		db	?
	BusDevFunc	dw	?
ends

struc S_UNDI_GET_NIC_TYPE_PNP
	Status		dw	?
	NicType		db	?
	EISA_Dev_ID	dd	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	CardSelNum	dw	?
ends

;--------------------------------------------------------------------
; Transmit structures
;--------------------------------------------------------------------

struc DATABLK
	PtrType		db	?
	Reserved	db	?
	Len		dw	?
	Off		dw	?
	Seg		dw	?
ends

struc UNDI_TBD
	Length		dw	?
	XmitOffset	dw	?
	XmitSegment	dw	?
	DataBlkCount	dw	?
ends

struc S_UNDI_TRANSMIT
	Status		dw	?
	Protocol	db	?
	XmitFlag	db	?
	DestAddrOffset	dw	?
	DestAddrSegment	dw	?
	TBDOffset	dw	?
	TBDSegment	dw	?
	Reserved	dd	?, ?
ends

P_RAW	equ	0
P_IP	equ	1
P_ARP	equ	2

struc S_UNDI_SET_PACKET_FILTER
	Status		dw	?
	Filter		db	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\udp_api.inc ===
;--------------------------------------------------------------------
; PXE UDP constants and structures
;
;--------------------------------------------------------------------

PXENV_UDP_OPEN	equ	30h
PXENV_UDP_CLOSE	equ	31h
PXENV_UDP_READ	equ	32h
PXENV_UDP_WRITE	equ	33h

struc S_PXENV_UDP_OPEN
	status		dw	?
	src_ip		dd	?
ends

struc S_PXENV_UDP_CLOSE
	status		dw	?
ends

struc S_PXENV_UDP_READ
	status		dw	?
	src_ip		dd	?
	dest_ip		dd	?
	s_port		dw	?
	d_port		dw	?
	buffer_size	dw	?
	buffer_off	dw	?
	buffer_seg	dw	?
ends

UDP_READ_ANY_IP	  equ	0	; Accept packets sent to any IP.
UDP_READ_CHECK_IP equ	1	; Only accept packets sent to a
				; specific IP address.

struc S_PXENV_UDP_WRITE
	status		dw	?
	ip		dd	?
	gw		dd	?
	src_port	dw	?
	dst_port	dw	?
	buffer_size	dw	?
	buffer_off	dw	?
	buffer_seg	dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\pxe_api.inc ===
;--------------------------------------------------------------------
; PXE TFTP constants and structures
;
;--------------------------------------------------------------------

PXENV_EXIT_SUCCESS	equ	0
PXENV_EXIT_FAILURE	equ	1

PXENV_STATUS_SUCCESS	equ	00h
PXENV_STATUS_FAILURE	equ	01h
PXENV_STATUS_BAD_FUNC	equ	02h
PXENV_STATUS_UNSUPPORTED equ	03h

PXENV_UNLOAD_STACK	equ	070h
PXENV_GET_BINL_INFO	equ	071h
PXENV_RESTART_DHCP	equ	072h
PXENV_RESTART_TFTP	equ	073h
PXENV_MODE_SWITCH	equ	074h

struc S_PXENV_ENTRY
	Signature	db	6 dup(?)
	Ver		dw	?
	Bytes		db	?
	Checksum	db	?
	rm_entry_off	dw	?
	rm_entry_seg	dw	?
	pm_entry_off	dw	?
	pm_entry_base	dd	?
	stack_sel	dw	?
	stack_size	dw	?
	base_cs_sel	dw	?
	base_cs_size	dw	?
	base_ds_sel	dw	?
	base_ds_size	dw	?
	mlid_ds_sel	dw	?
	mlid_ds_size	dw	?
	mlid_cs_sel	dw	?
	mlid_cs_size	dw	?
ends

struc S_PXENV_GET_BINL_INFO
	Status		dw	?
	PacketType	dw	?
	BufferSize	dw	?
	BufferOffset	dw	?
	BufferSegment	dw	?
ends

PXENV_PACKET_TYPE_DHCP_DISCOVER	equ	1
PXENV_PACKET_TYPE_DHCP_ACK	equ	2
PXENV_PACKET_TYPE_BINL_REPLY	equ	3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\tftp.asm ===
Struc	DESCRIPTOR
	Dummy		dw	?, ?, ?, ?
	GDT_LOC 	dw	?, ?, ?, ?
	SourceLimit	dw	?
	SourceLoWord	dw	?
	SourceHiByte	db	?
	SourceRights	db	?
	SourceInternal	db	?
	SourceHiByteHi	db	?
	TargetLimit	dw	?
	TargetLoWord	dw	?
	TargetHiByte	db	?
	TargetRights	db	?
	TargetInternal	db	?
	TargetHiByteHi	db	?
	Bios		dw	?, ?, ?, ?
	Temp		dw	?, ?, ?, ?
ends

even
TFTP		OpenTFTPStruct <>
GDT		DESCRIPTOR <?>			; global descriptor table
Address		dd	0
Bytes		dd	0
TimeOutCounter	dw	0

;--------------------------------------------------------------------
; TFTPRestart
;
;--------------------------------------------------------------------
Proc TFTPRestart

	call	TFTPReadFile		; get the file
	jc	readError		; was there an error ?

	mov	ax, 5650h
	int	1Ah			; get PXE entry structure pointer

	push	0			; new segment
	push	7C00h			; new offset
	retf				; jump to downloaded file

readError:
	ret

endp

;--------------------------------------------------------------------
; TFTPReadFile
;
;--------------------------------------------------------------------
Proc TFTPReadFile

	; Clear some variables.
	mov	[Bytes], 0
	mov	[TimeOutCounter], 0

;db 0F1h
;extrn break:byte
;mov [break], 0F1h

	; Copy the destination RAM address.
	mov	eax, [(s_PXENV_TFTP_READ_FILE es:di).BufferOffset]
	mov	[Address], eax

	; Fill BootWares' OpenTFTP data structure.
	mov	[TFTP.Size], size TFTP
	mov	[TFTP.Flags], 1                 ; 1 = use large packets
	mov	eax, [dword ptr (s_PXENV_TFTP_READ_FILE es:di).ServerIP]
	mov	[dword ptr TFTP.Address], eax
	mov	eax, [dword ptr (s_PXENV_TFTP_READ_FILE es:di).GatewayIP]
	mov	[TFTP.Gateway], eax
	mov	[(TFTP.FileName)+2], es
	lea	ax, [(s_PXENV_TFTP_READ_FILE es:di).FileName]
	mov	[TFTP.FileName], ax
	mov	[word ptr TFTP.Callback], offset TFTPCallback
	mov	[word ptr (TFTP.Callback)+2], cs

	push	cs
	pop	es			; es = cs

	mov	bx, BW_OPENTFTP		; Function number.
	lea	di, [TFTP]		; es:di -> OpenTFTP structure.
	call	[BWAPI]			; transfer the file

	les	di, [PxePtr]		; Get a pointer to PXE structure.

	or	ax, ax			; was there an error?
	je	gotFile			; no

	; Return the size of the file written into the buffer.
	mov	eax, [Bytes]
	mov	[(s_PXENV_TFTP_READ_FILE es:di).BufferSize], eax

	mov	ax, PXENV_STATUS_FAILURE
	ret

gotFile:
	; Return the size of the file written into the buffer.
	mov	eax, [Bytes]
	mov	[(s_PXENV_TFTP_READ_FILE es:di).BufferSize], eax

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; TftpCallback
;
; Callback function for TFTP transfer.
;
; Parameters:
;	ax - packet type
;	bx - packet number
;	cx - packet size
;	es:di - pointer to data
;
; Returns:
;	ax - status (0 = OK)
;--------------------------------------------------------------------
Proc TftpCallback far

	pusha

	cmp	ax, -2			; is this a timeout callback?
	je	checkTimeOut		; yes

        cmp     ax, 5                   ; is this an error packet ?
        jne     noError
        popa                            ; yes...retry.
        mov     ax, 1                   ; indicate some error.
        ret

noError:
        mov     [TimeOutCounter], 0     ; clear any previous time outs.

	add	[word ptr Bytes], cx	; update byte counter
	adc	[(word ptr Bytes)+2], 0

	call	CopyMemory

	popa
	xor	ax, ax			; indicate success
	jnc	copyOK			; no error

	inc	ax			; return error

copyOK:
	ret

checkTimeOut:
	les	di, [PxePtr]		; Get a pointer to PXE structure.

        mov     ax, [TimeOutCounter]
        cmp     [(s_PXENV_TFTP_READ_FILE es:di).TFTPReopenDelay], ax
        jne     timeoutOK               ; have we reached retry limit?...no

        inc     [TimeOutCounter]
        popa
        add     cx, 18                  ; add ~second to time out
        inc     ax                      ; yes...indicate error
        ret

timeoutOK:
        inc     [TimeOutCounter]
        popa
        add     cx, 18                  ; add ~second to time out
        xor     ax,ax                   ; clear return status
	ret

endp

;--------------------------------------------------------------------
; CopyMemory
;
; Copies image into extended RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyMemory

	push	cx			; save data size

	push	di			; save data offset
	push	es			; save data segment

	push	ds
	pop	es			; es = ds

	mov	di, offset GDT		; get GDT location
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw			; zero the GDT (es:di)

	; source address must be converted to 24 bit address for extended
	; memory INT15 copy function
	pop	ax			; ax = data segment
	xor	dx, dx			; dx = 0
	mov	cx, 16
	mul	cx			; dx:ax = ax * 16
	pop	bx			; get data offset
	add	bx, ax			; add to offset
	adc	dx, 0			; dx:bx is now 24 bit source address

	pop	cx			; restore byte count
	push	cx			; save it again

	mov	[GDT.SourceLimit], cx	; set copy size
	mov	[GDT.TargetLimit], cx	; set copy size
	mov	[GDT.SourceRights], 93h ; set copy rights
	mov	[GDT.TargetRights], 93h ; set copy rights

	mov	[GDT.SourceLoWord], bx	; set source address lo word
	mov	[GDT.SourceHiByte], dl	; set source address hi byte
	mov	[GDT.SourceHiByteHi], dh

	mov	si, [word ptr Address]	; get 24 bit extended memory address
	mov	dx, [(word ptr Address)+2]
	mov	[GDT.TargetLoWord], si	; set dest address low word
	mov	[GDT.TargetHiByte], dl	; set dest address hi byte
	mov	[GDT.TargetHiByteHi], dh

	inc	cx			; increase to evenize
	shr	cx, 1			; now cx is word count
	mov	si, offset GDT		; address of GDT (ds:di)
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	pop	cx			; restore byte count in CX

	pushf				; save INT15 status

	add	[word ptr Address], cx	; calc next address
	adc	[(word ptr Address)+2], 0

	popf				; restore INT15 status
	ret				; return - carry set/cleared in INT15

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\pxe.asm ===
;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------
ideal
_IDEAL_ = 1

include "..\include\drvseg.inc"
include "..\include\ai.inc"

include "pxe_api.inc"
include "udp_api.inc"
include "tftp_api.inc"
include "undi_api.inc"

extrn PCIDevice:word
extrn PCIVendor:word
extrn PCIBusDevFunc:word
extrn NIC_IO:word
extrn NIC_IRQ:byte
extrn NetAddress:word
extrn RxBuffer:byte

START_CODE
P386

public	SetupPreboot

BWAPI		dd	0
OldInt1A	dd	0

PXE		db 'PXENV+'

PXEPtr		dd	0

UNDI		dw	0
UNDISeg		dw	0

align 16
PxeEntry	s_pxenv_entry <>

;--------------------------------------------------------------------
; SetupPreboot
;
; Parameters:
;	bx - pointer to BootWare AI API table
;	dx - UNDI segment (if 0 then no UNDI available)
;
;--------------------------------------------------------------------
Proc SetupPreboot

	mov	[UNDISeg], dx		; save UNDI segment

	mov	eax, [bx]		; get address of BootWare API
	mov	[BWAPI], eax

	push	cs
	pop	es			; es = current

	;------------------------------------------------------------
	; Fill in values of structure.
	;------------------------------------------------------------
	mov	si, offset PXE
	lea	di, [PxeEntry.signature]
	movsw
	movsw
	movsw

	mov	[PxeEntry.ver], 98
	mov	[PxeEntry.bytes], size PxeEntry

	mov	[PxeEntry.rm_entry_seg], cs
	mov	[PxeEntry.rm_entry_off], offset ApiEntry

	xor	bx, bx			; clear sum
	mov	cx, size PxeEntry	; size of structure
	mov	si, offset PxeEntry

sumLoop:
	add	bl, [byte ptr si]
	inc	si
	loop	sumLoop

	sub	[PxeEntry.checksum], bl	; set structure sum

	;------------------------------------------------------------
	; hook INT1A to us.
	;------------------------------------------------------------
	push	0
	pop	es			; es = 0

	mov	ax, offset Int1A	; our INT 1A offset
	xchg	ax, [es:1Ah*4]		; get/set INT 1A offset
	mov	[word ptr OldInt1A], ax ; save original offset

	mov	ax, cs
	xchg	ax, [es:(1Ah*4)+2]	; get/set INT 1A segment
	mov	[word ptr OldInt1A+2], ax	; save original segment

	ret

endp

;--------------------------------------------------------------------
; Int1A
;
;--------------------------------------------------------------------
Proc Int1A far

	cmp	ax, 5650h		; is this a PXE request?
	je	doPXE			; yes

	jmp	[cs:OldInt1A]		; clain to old int1A

doPXE:
	push	cs
	pop	es			; es = current segment
	mov	bx, offset PxeEntry	; es:bx is offset to structure

	; We need to return with carry cleared, but the iret will restore
	; the flags from the stack, so lets pull it off the stack, set the
	; carry and put it back so iret can return correctly.  To make
	; matters worse the flags are hidden behind the return address so
	; we must remove and restore them as well.
	pop	ax
	pop	dx
	popf				; get calls flags
	clc				; clear carry
	pushf				; replace the flags
	push	dx
	push	ax

	; return edx = physical address of structure
	xor	edx, edx
	xor	eax, eax
	mov	dx, cs
	shl	edx, 4
	mov	ax, offset PxeEntry	; physical address of structure
	add	edx, eax

	mov	ax, 564Eh		; return code

	iret				; we are done

endp


;--------------------------------------------------------------------
; ApiEntry
;
;--------------------------------------------------------------------
Proc ApiEntry far

	; If we have an UNDI, and the function being called is an UNDI
	; function, then call the UNDI to handle the function.
	cmp	[cs:UNDISeg], 0		; do we have an UNDI?
	je	noUNDI			; no

	cmp	bx, 1Fh			; is this an UNDI function call?
	ja	noUNDI			; no

	call	[dword ptr cs:UNDI]	; call UNDI
	ret

noUNDI:
	push	ds			; save caller ds
	push	bx
	push	cx
	push	dx
	push	si

	push	cs
	pop	ds			; ds = cs

	; Store pointer to the PXE structure.
	mov	[word ptr PxePtr], di
	mov	[word ptr PxePtr+2], es

	xor	si, si

apiLoop:
	mov	ax, [JmpTable+si]
	cmp	ax, 0			; are we at the end of the table?
	je	tableEnd		; yes

	cmp	ax, bx			; found our function?
	je	foundEntry		; yes

	add	si, 4
	jmp	apiLoop

foundEntry:
	call	[JmpTable+si+2]
	jmp	exit

tableEnd:
	mov	ax, PXENV_STATUS_UNSUPPORTED

exit:
	les	di, [PxePtr]		; reload PXE pointer

	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ds

	mov	[es:di], ax		; set return status

	cmp	ax, PXENV_STATUS_SUCCESS; were we succesfull?
	jne	error			; no

	mov	ax, PXENV_EXIT_SUCCESS	; return success
	clc				; clear carry for success
	ret

error:
	mov	ax, PXENV_EXIT_FAILURE	; return error
	stc				; set carry to error
	ret

endp

even
JmpTable	dw	PXENV_GET_BINL_INFO, GetBinlInfo
		dw	PXENV_UNDI_GET_INFORMATION, UndiGetInfo
		dw	PXENV_UNDI_GET_NIC_TYPE, UndiGetNicType
		dw	PXENV_UDP_OPEN, UDPopen
		dw	PXENV_UDP_WRITE, UDPwrite
		dw	PXENV_UDP_READ, UDPread
		dw	PXENV_UDP_CLOSE, UDPclose
		dw	PXENV_TFTP_READ_FILE, TFTPReadFile
		dw	73h, TFTPRestart
		dw	0, 0

;--------------------------------------------------------------------
; GetBinlInfo
;
; Parameters:
;	es:di = pointer to PXENV_GET_BINL_INFO structure
;
;--------------------------------------------------------------------
Proc GetBinlInfo

	mov	ax, [(s_PXENV_GET_BINL_INFO es:di).PacketType]

	push	es
	push	di			; save "GetBinlInfo" pointer

	mov	bx, BW_GETINFO
	call	[BWAPI]			; call BWAPI "GetInfo"

	lea	si, [(AIINFOStruct es:di).DiscoverPkt]
	cmp	ax, 1			; do they want the discover packet?
	je	gotIt			; yes

	lea	si, [(AIINFOStruct es:di).BOOTPPkt]
	cmp	ax, 2			; do they want the ACK packet?
	je	gotIt			; yes

	lea	si, [(AIINFOStruct es:di).BINLPkt]

gotIt:
	mov	ax, [es:si]
	mov	bx, [(es:si)+2]

	pop	di
	pop	es			; restore BINL structure

	; If size and address is NULL then we return the address and
	; size of our buffer.
	mov	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferSize]
	or	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferOffset]
	or	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferSegment]
	jne	hasBuffer

	; set address to our buffer
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferOffset], ax
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferSegment], bx
	jmp	getInfoExit

hasBuffer:
	cmp	[(s_PXENV_GET_BINL_INFO es:di).BufferSize], 0
	je	getInfoExit

	push	es
	push	di
	push	ds

	; A buffer is specified, so copy the packet into it.
	mov	si, ax
	push	bx
	pop	ds			; ds:si is source address

	les	di, [dword ptr ((s_PXENV_GET_BINL_INFO es:di).BufferOffset)]
	mov	cx, 512
	rep	movsb			; copy data into buffer

	pop	ds			; restore ds
	pop	di
	pop	es

getInfoExit:
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferSize], 512

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; UndiGetInfo
;
; Parameters:
;	es:di = pointer to PXENV_UNDI_GET_INFORMATION structure
;
;--------------------------------------------------------------------
Proc UndiGetInfo

	mov	ax, [NIC_IO]
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).BaseIo], ax

	mov	al, [NIC_IRQ]
	xor	ah, ah
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).IntNumber], ax

	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).MaxTranUnit], 1500
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).HwType], ETHER_TYPE
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).HwAddrLen], 6

	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).RomAddress], 0

	mov	bx, di
	mov	cx, 6
	mov	si, offset NetAddress
	lea	di, [(s_PXENV_UNDI_GET_INFORMATION es:di).CurrentNodeAddress]
	rep	movsb

	mov	cx, 6
	mov	si, offset NetAddress
	lea	di, [(s_PXENV_UNDI_GET_INFORMATION es:bx).PermNodeAddress]
	rep	movsb

	mov	di, bx
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).RxBufCt], 5
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).TxBufCt], 1

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; UndiGetNicType
;
; Parameters:
;	es:di = pointer to PXENV_UNDI_GET_NIC_TYPE structure
;
;--------------------------------------------------------------------
Proc UndiGetNicType

	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).NicType], 2

	mov	ax, [PCIVendor]		; get vendor ID
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Vendor_ID], ax

	mov	ax, [PCIDevice]		; get device ID
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Dev_ID], ax

	mov	ax, [PCIBusDevFunc]	; get Bus/Device/Function numbers
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).BusDevFunc], ax

	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Base_Class], 2
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Sub_Class], 0
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Prog_Intf], 0
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Rev], 0

	mov	ax, PXENV_STATUS_SUCCESS
	ret


endp

include "tftp.asm"
include "udp.asm"

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\udp.asm ===
;--------------------------------------------------------------------
; UDPopen
;
;--------------------------------------------------------------------
Proc UDPopen

	mov	bx, BW_GETINFO		; Call BootWare to get info for us.
	call	[BWAPI]

	mov	eax, [dword ptr (AIINFOStruct es:di).LocalIP]
	les	di, [PxePtr]		; Get a pointer to PXE structure.
	mov	[(s_pxenv_udp_open es:di).src_ip], eax

	mov	ax, PXENV_STATUS_SUCCESS; return success
	ret
endp

;--------------------------------------------------------------------
; UDPclose
;
; A useless function that does nothing!
;--------------------------------------------------------------------
Proc UDPclose

	mov	ax, PXENV_STATUS_SUCCESS; return success
	ret

endp

;--------------------------------------------------------------------
; UDPread
;
;--------------------------------------------------------------------
; Casting structure for dealing with UDP/IP packets.
struc   s_RxPacket
        MACheader    db 14 dup (0)      ; ethernet address, ...
        IPdummy1     db 02 dup (0)      ; version, header length, TOS
        IPlength     dw 00              ; total length (IP+UDP+Data)
        IPdummy2     db 05 dup (0)      ; identification, flags, fragment, TTL
        IPprotocol   db 00              ; protocol number following
        IPchecksum   dw 00              ; 16-bit IP header checksum
        IPsourceip   dd 00              ; source IP address
        IPdestip     dd 00              ; destination IP address
        ;-------------------------------------------------------
        UDPsource    dw 00              ; source port number
        UDPdest      dw 00              ; destination port number
        UDPlength    dw 00              ; length
        UDPchecksum  dw 00              ; 16-bit UDP header checksum
ends

Proc    UDPread

; American ;
;  Arium   ;
;db 0F1h

	; Get a full packet.
	mov	bx, BW_RECEIVE
	push	ds

	pop	es			; es = ds
	mov	di, offset RxBuffer
	mov	cx, 1500
	call	[BWAPI]			; Call ReceivePacket function.

	cmp	ax, 0			; did we get a packet?
        je      noPacket

	;------------------------------------------------------------
	; We got a packet
	;------------------------------------------------------------

	; Check for a UDP protocol packet.
	cmp	[(s_RxPacket RxBuffer).IPprotocol], 17  ; 11h
        jne     noPacket                ; not a UDP packet

	les	di, [PxePtr]		; get pointer to PXE structure.

	; Check if caller specified a destination IP address, if so
	; we only accept packets sent to that address.
	mov	eax, [(s_pxenv_udp_read es:di).dest_ip]
	cmp	eax, 0			; is an address specified?
	je	acceptANYip		; no - accept any address

	; check specified address with received packet
	cmp	eax, [(s_RxPacket RxBuffer).IPdestip]
	je	ipOK			; address match, keep it
        jmp     noPacket                ; nope, no match

acceptANYip:
	; copy destination IP address into UDPRead structure
	mov	eax, [(s_RxPacket RxBuffer).IPdestip]
	mov	[(s_pxenv_udp_read es:di).dest_ip], eax

ipOK:
	; Check if caller specified a destination UDP port, if so
	; we only accept packets sent to that port.
	mov	ax, [(s_pxenv_udp_read es:di).d_port]
	cmp	ax, 0			; was a port specified?
	je	acceptANYudp		; no - accept all packets

	; check specified port with received packet
	cmp	[(s_RxPacket RxBuffer).UDPdest], ax
	je	portOK			; ports match
        jmp     noPacket

acceptANYudp:
	; packets from any port are wanted, so copy the port number
	mov	ax, [(s_RxPacket RxBuffer).UDPdest]
	mov	[(s_pxenv_udp_read es:di).d_port], ax

portOK:
	; copy the senders IP address into UDPRead structure
	mov	eax, [(s_RxPacket RxBuffer).IPsourceip]
	mov	[(s_pxenv_udp_read es:di).src_ip], eax

	; copy the source port number into UDPRead structure
	mov	ax, [(s_RxPacket RxBuffer).UDPsource]
	mov	[(s_pxenv_udp_read es:di).s_port], ax

	; copy packet length into UDPRead structure
	mov	ax, [(s_RxPacket RxBuffer).IPlength]
	xchg	al, ah
	sub	ax, 20 + 8		; subtract IP and UDP header sizes
	mov	[(s_pxenv_udp_read es:di).buffer_size], ax

	; copy the packet into the supplied buffer
	mov	si, offset RxBuffer
	add	si, 14 + 20 + 8		; skip MAC, IP & UDP headers
	mov	bx, [(s_pxenv_udp_read es:di).buffer_seg]
	mov	di, [(s_pxenv_udp_read es:di).buffer_off]
	mov	es, bx
	mov	cx, ax
	rep	movsb			; copy the packet data.

	mov	ax, PXENV_STATUS_SUCCESS
	ret				; return successful

noPacket:
	mov	ax, PXENV_STATUS_FAILURE
	ret				; return failure

endp

;--------------------------------------------------------------------
; UDPwrite
;
;--------------------------------------------------------------------
UDPStruct     TxUDPStruct <>

Proc    UDPwrite

	; Fill the transmit UDP structure.
	mov	[UDPStruct.Size], size TxUDPStruct

	; copy destination IP address
	mov	eax, [(s_pxenv_udp_write es:di).ip]
	mov	[UDPStruct.Address], eax

	; copy gateway IP address
	mov	eax, [(s_pxenv_udp_write es:di).gw]
	mov	[UDPStruct.Gateway], eax

	; copy source port
	mov	ax, [(s_pxenv_udp_write es:di).src_port]
	xchg	al, ah
	cmp	ax, 0			; was a port value given?
	jne	gotPortVal		; yes
	mov	ax, 2069		; default port number

gotPortVal:
	mov	[UDPStruct.SourcePort], ax

	; copy destination port
	mov	ax, [(s_pxenv_udp_write es:di).dst_port]
	xchg	al, ah
	mov	[UDPStruct.DestPort], ax

	push	[word ptr (s_pxenv_udp_write es:di).buffer_off]
	push	[word ptr (s_pxenv_udp_write es:di).buffer_seg]
	pop	[(UDPStruct.Data)+2]
	pop	[(UDPStruct.Data)+0]

	mov	ax, [(s_pxenv_udp_write es:di).buffer_size]
	mov	[UDPStruct.Length], ax

	mov	bx, BW_TRANSMITUDP
	push	cs

	pop	es			; es = cs
	lea	di, [UDPStruct]
	call	[BWAPI]
	cmp	ax, 0			; was there an error?
	je	txUDPOK			; no error

	mov	ax, PXENV_STATUS_FAILURE
	ret				; return failure

txUDPOK:
	mov	ax, PXENV_STATUS_SUCCESS
	ret				; return success

endp

;------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\pxe\undi_api.inc ===
;--------------------------------------------------------------------
; PXE UNDI constants and structures
;
;--------------------------------------------------------------------

PXENV_UNDI_STARTUP	 	equ	01h
PXENV_UNDI_CLEANUP	 	equ	02h
PXENV_UNDI_INITIALIZE 		equ	03h
PXENV_UNDI_RESET_NIC		equ	04h
PXENV_UNDI_SHUTDOWN		equ	05h
PXENV_UNDI_OPEN			equ	06h
PXENV_UNDI_CLOSE		equ	07h
PXENV_UNDI_TRANSMIT		equ	08h
PXENV_UNDI_SET_MCAST_ADDR	equ	09h
PXENV_UNDI_SET_STATION_ADDR	equ	0Ah
PXENV_UNDI_SET_PACKET_FILTER	equ	0Bh
PXENV_UNDI_GET_INFORMATION	equ	0Ch
PXENV_UNDI_GET_STATISTICS	equ	0Dh
PXENV_UNDI_CLEAR_STATISTICS	equ	0Eh
PXENV_UNDI_INITIATE_DIAGS	equ	0Fh
PXENV_UNDI_FORCE_INTERRUPT	equ	10h
PXENV_UNDI_GET_MCAST_ADDR	equ	11h
PXENV_UNDI_GET_NIC_TYPE		equ	12h
PXENV_UNDI_GET_NDIS_INFO	equ	13h

ADDR_LEN			equ	16
MAXNUM_MCADDR			equ	8

struc S_PXENV_FORCE_INTERRUPT
	Status		dw	?
ends

struc S_PXENV_UNDI_CLOSE
	Status		dw	?
ends

struc S_PXENV_UNDI_STARTUP
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegA	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	BusDevFunc	dw	?
	PCI_ds_off	dw	?
	PCI_ds_seg	dw	?
	PnP_csn		dw	?
	PnP_eh_off	dw	?
	PnP_eh_seg	dw	?
ends

struc S_PXENV_UNDI_INITIALIZE
	Status		dw	?
	ProtocolIni	dd	?
	ReceiveOffset	dw	?
	ReceiveSegment	dw	?
	GeneralIntOff	dw	?
	GeneralIntSeg	dw	?
ends

struc S_PXENV_UNDI_GET_INFORMATION
	Status		dw	?
	BaseIo		dw	?
	IntNumber	dw	?
	MaxTranUnit	dw	?
	HwType		dw	?
	HwAddrLen	dw	?
	CurrentNodeAddress db	ADDR_LEN dup(?)
	PermNodeAddress db	ADDR_LEN dup(?)
	RomAddress	dw	?
	RxBufCt		dw	?
	TxBufCt		dw	?
ends

ETHER_TYPE = 1

struc S_PXENV_UNDI_GET_NIC_TYPE_PCI
	Status		dw	?
	NicType		db	?
	Vendor_ID	dw	?
	Dev_ID		dw	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	Rev		db	?
	BusDevFunc	dw	?
ends

struc S_PXENV_UNDI_GET_NIC_TYPE_PNP
	Status		dw	?
	NicType		db	?
	EISA_Dev_ID	dd	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	CardSelNum	dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\language\lang.asm ===
;----------------------------------------------------------------------------
; LANG.ASM
;
; Language module for BootWare Goliath.
;
;----------------------------------------------------------------------------

assume	cs:code, ds:code, es:nothing,ss:nothing
code segment public 'code'
.386

	org 0

	db	"BootWare Goliath Language module: "
ifdef ENGLISH
	db	"English"
endif

ifdef FRENCH
	db	"French"
endif

	db	26, 0

	org	60
	db	"PCSD"

	dw	text0, text1, text2, text3, text4, text5, text6, text7
	dw	text8

	org	128
ifdef ENGLISH
text0	db	"Error: Not a PCI PC!", 0
text1	db	"Error: Couldn't find an adapter!", 0
text2	db	"Error: ", 0
text3	db	"Error: Unable to initialize adapter", 0
text4	db	"MAC: ", 0
text5	db	"No reply from a DHCP server.", 0
text6	db	"No reply from a BINL server.", 0
text7	db	"Too many retries.", 0
text8	db	"Press a key to reboot system.", 0
endif

ifdef FRENCH
text0	db	"Erreur: Ce PC n'est pas PCI!", 0
text1	db	"Erreur: Incapable de trouver l'adapteur!", 0
text2	db	"Erreur: ", 0
text3	db	"Erreur: Incapable d'initialiser l'adapteur!", 0
text4	db	"MAC: ", 0
text5	db	"Le serveur DHCP ne rpond pas!", 0
text6	db	"Le serveur BINL ne rpond pas!", 0
text7	db	"Limite d'erreurs excede.", 0
text8	db	"Appuyez sur une touche pour redmarrer le systme.", 0
endif

	org	1023
	db	0

code ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\ipnid.asm ===
;====================================================================
; BOOTPNID.ASM - Generic code for BootWare for TCP/IP
;
; Includes the file IPCODE.ASM which contains the real TCP/IP code.
;
; Copyright 1993-98 Lanworks Technologies
;
; Revision history:
;
;$History: IPNID.ASM $
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 7/20/98    Time: 17:23
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Added config.inc include
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 7/13/98    Time: 11:28
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Added a CS: override in the INT2F handler.
;
; 980408 3.0  PC - BootWare98 version
;		 - complete rewrite to use UDP & TFTP APIs in AI
;		 - supports TFTP large block size
;		 - supports BINL
; 970814 2.1  PC - added INT2F memory protection if not disengaging
; 970310 2.0  PC - major reworking:
;		   - uses new AI layer
;		   - changed screen layout
;		   - added disengage checking for new API
;		   - changed NID/NAD calls to use new jump table
;		   - removed screen timer
;		   - removed unneeded "PROTOCOL" and "NOTIMER" conditionals
;		   - changed printing to "common" functions
;		   - removed NIDStatus function
;		   - removed ARP and RARP
;		   - added reboot on fatal errors and timeouts
;		   - combined DHCP states into main state loop
;		   - change to TASM IDEAL mode
; 960806 1.52 GY - BPDATANI.INC doesn't allocate enough data area 
;		   for BPPatch BootP Reply Packet (350 bytes -> 544 bytes)
; 960724      JJ - added support for DHCP
; 960112 1.51 GY - Change year to 96 
;		 - Change TCPStart
;		 - All ROM should use CRightStr in AUTOSCAN
;		 - ChgProtBP replaced by TCPStart
;		 - Move Strings and Global Data to end of file
; 951218 1.50 GY - Paul change CRight_Str to CRightStr
; 951128 1.50 GY - Utilize \ROM\GENR\AUTOSCAN\AUTOSCAN.ASM 
;		 - Take out /dNOAS
; 950913      PC - fixed checksum function which would incorrectly report
;		   checksum errors on odd sized packets (mainly TFTP error
;		   packets)
; 950718 1.25 GY - Gbl_RomLocation not updated properly for /dprotocol
; 950201 1.25 GY - Change year to 1995
; 941024 1.25 GY - (BPCODE.INC) Use PrintMessage rather than PrintMsgLoc
;		   in NIDStatus
; 941021 1.25 GY - drop BWTStatus. No longer print BWTStatus
; 941003 1.24 GY - for /dPROTOCOL rely on NW NID for tx_copyright (CRight_Str)
;		 - take out /dIBM4694 and all code that setup CX for PrintMsgLoc
; 940808 1.24 GY - Add /dNOTIMER for AT1500 (no space)
; 940805      PC - TFTP gets file name from saved BOOTP packet
; 940804 1.23 GY - move Timer code from BPCODE.INC to here
; 940721 1.23 GY - Add /dIBM4694.
;                - Use CUI for Print routines.
;                - (BPCODE) Convert all screen output to use CUI
; 940520 1.22 GY - BWTCpyRAM is misused when copying code from ROM to RAM
; 940506 1.22 GY - Add OS/2 support by adding more info in API Table
;                  and all NID routines are far.
; 940221 1.21 Gy - change year to 1994. Change string to "Centralized
;                  boot ROM for TCP/IP"
;                - Take out Gbl_BIOSMemSize
; 931209 1.21 GY - Use BPCODE.INC version 2.00
;                - Use BPDATA.INC. Copy changes from GENERIC.ASM
; 931028 1.2  GY - when calling NADInitialize, the ROMBase at AX is
;                  wiped out.
; 931026 1.2  GY - use SEGNID.INC rather than DRVSEG.INC
; 931022 1.2  GY - To print message from NADInit, use PrintMax rather than
;                  Print
; 931012 1.2  GY - replace Gbl_EtherType with BWTEthStd. Gbl_EtherType is
;                  byte reverse
;                - change SetInitState to properly handle "error" condition
;                  from NADInitialize
;                - update ED structure in BootP.INC
; 931011 1.2  GK - reworked to conform to NID/NAD
; 930810      GK - consolidated code into core .include file
; 930714 1.1  PC
; 930412 1.0  PC - first release
;====================================================================

IDEAL
_IDEAL_ = 1
locals

	include "..\include\drvseg.inc"
	include "..\include\bwnid.inc"
	include "..\include\config.inc"

public	IPStart
P386

extrn	AIAppendCache:near	; AI layer
extrn	TxBuffer:byte		; common transmit buffer
extrn	AITbl:byte		; BWAPI table address

;extrn	BWTable:BWT
extrn	Verbose:byte


;====================================================================
;                         Code segment
;====================================================================
START_CODE

public _TCPIPStart
_TCPIPStart:

IPStart:
	jmp	TCPIP

;	db	'IP*980408*'		; build date
;	dw	0300h			; build version

	include "tcpip.inc"
	include "ipdata.inc"		; include all global data

IPFeature db 0

;--------------------------------------------------------------------	
; IPStart
;
; Entry function for BootWare TCP/IP.
;
;--------------------------------------------------------------------	
Proc TCPIP

	sti				; enable interrupts

	mov	eax, [BWTable.Settings]	; get current settings
	and	ax, CFG_PROTOCOL	; keep protocol bits
	mov	[Protocol], ax		; save setting

	call	DoBootP
	je	doneBOOTP

rebootJmp:	
	jmp	Reboot

doneBOOTP:
	cmp	[Verbose], 0		; are we in verbose mode?
	je	noIP			; no

	; display the BOOTP server and our assigned IP address
	call	ShowIPs			; show server & local IPs

noIP:
	call	TransferFile
	jne	rebootJmp

	;------------------------------------------------------------
	; The boot image is now in memory.
	;------------------------------------------------------------

	call	PrintCRLF

	sti

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@notBINL		; no

	ret				; return to an upper layer

@@notBINL:
	cmp	[NoDisengage], 0	; should we disengage?
	je	doDisengage		; yes

	call	SetupInt2F		; setup our Int2F handler

	jmp	skipDisengage

doDisengage:
	call	AIDisengage		; call interface to disengage

;	mov	[BWTAPI], 0

	mov	[word ptr AITbl-8], 0	; remove "BWAPI" identifer

skipDisengage:
	; and relinquish control to new boot image...
	mov	ax, 1000h
	push	ax			; push new code segment
	xor	ax, ax			; offset to jump to is 0
	push	ax			; push offset (ax = 0 from above)
	mov	ax, cs			; put ROM code segment in ax
	mov	bx, offset BootPkt	; BOOTP packet address in BX
	xor	cx, cx			; cx = 0
	mov	dx, offset AITbl	; get address of API table
	retf				; far return to new address

endp

OldInt2F	dd	0

;--------------------------------------------------------------------
; SetupInt2F
;
;--------------------------------------------------------------------
Proc SetupInt2F

	xor	ax, ax
	mov	es, ax			; es = 0

	mov	ax, offset Int2F	; our INT 2F offset
	xchg	ax, [es:2Fh*4]		; get/set INT 2F offset
	mov	[word ptr OldInt2F], ax ; save original offset

	mov	ax, cs
	xchg	ax, [es:(2Fh*4)+2]	; get/set INT 2F segment
	mov	[word ptr OldInt2F+2], ax	; save original segment

	ret

endp

;--------------------------------------------------------------------
; Int2F
;
;--------------------------------------------------------------------
Proc Int2F far

	jmp	short skipString	; explicitly specify short and add NOP
	db	90h			; to make sure not optimized out

	db	'RPL'			; DOS5 looks for this @ INT2F+3

skipString:
	cmp	ax, 4A06h		; is this DOS5.0 IO.SYS request?
	jz	returnBase

	cmp	[word ptr cs:OldInt2F+2], 0
	je	intRet			; there was no INT 2F, just iret

	jmp	[cs:OldInt2F] 

returnBase:
	mov	dx, cs
	dec	dx

intRet:
	iret

endp

;===================================================================
; NID CODE
;===================================================================

include "bootp.asm"			; BOOTP/DHCP code module
include "tftp.asm"			; file transfer code module

;----------------------------------------------------------------------
;----------------------------------------------------------------------
Proc PrintTransferValue

	cmp	[Verbose], 0		; are we in verbose mode?
	jne	@@doIt			; yes

	test	[PacketNum], 32
	jne	@@back

	mov	ax, 0E2Eh
	int	10h			; print '.'
	ret

@@back:
	mov	ax, 0E08h
	int	10h			; backspace
	mov	ax, 0E20h
	int	10h			; print ' '
	mov	ax, 0E08h
	int	10h			; backspace

	ret

@@doIt:
	push	cx

	mov	di, offset StringBuffer

	mov	[byte ptr di], '('
	inc	di

	mov	ax, [Counter]
	mov	cx, 2
	call	StoDec
	
	mov	al, '-'
	stosb

	mov	ax, [PacketNum]
	mov	cx, 4
	call	StoDec

	mov	[word ptr di], 0029h	; print ')'

	mov	bx, offset StringBuffer
	call	Print

	mov	cx, 9

backLoop:
	mov	ax, 0E08h
	int	10h			; backspace
	loop	backLoop

	pop	cx
	ret

endp

;----------------------------------------------------------------------
; ShowIP
;
; Displays the IP address of a server and the local workstation.
;
; Parameters:
;----------------------------------------------------------------------
Proc ShowIPs

	call	PrintCRLF
	mov	bx, offset tx_ServerIP
	call	Print

	mov	si, offset ServerIP
	call	PrintIP			; print servers IP address

	call	PrintCRLF
	mov	bx, offset tx_LocalIP
	call	Print			; Print "Local IP:"

	mov	si, offset LocalIP
	call	PrintIP			; print our IP number
	call	PrintCRLF

	cmp	[GatewayIP], 0		; is there a gateway?
	je	notgate			; no

	mov	bx, offset tx_Gateway
	call	Print			; Print "Gateway:"

	mov	si, offset GatewayIP
	call	PrintIP			; print our IP number
	call	PrintCRLF

notGate:
	ret

endp

;--------------------------------------------------------------------
; PrintIP
;
; Prints a 4 number period delimited IP address on the screen.
;
; Input:
;       si - pointer to IP address
;	dx - screen location
;--------------------------------------------------------------------
Proc PrintIP

	mov	cx, 4
	jmp	printip2

printIPLoop:
	mov	ax, 0E2Eh
	int	10h			; print '.'

printip2:
	lodsb
	xor	ah, ah
	call	PrintDecimal

	loop	printIPLoop

	ret

endp

;----------------------------------------------------------------------
; Input bx=ptr error msg
;----------------------------------------------------------------------
Proc PrintError

	push	bx			; save pointer to error message

	call	PrintCRLF
	mov	bx, offset tx_error
	call	Print

	pop	bx			; restore pointer to error message
	call	Print
	ret

endp

public _TCPIPEnd
label _TCPIPEnd

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\tftp.asm ===
;===================================================================
; TFTP.ASM
;
; TFTP file transfer code for TCP/IP NID.
;===================================================================

;--------------------------------------------------------------------
; TransferFile
;
; Main BOOTP processing loop.
;
;--------------------------------------------------------------------
Proc TransferFile

	push	ds
	pop	es			; es = ds

	call	PrintCRLF

	cmp	[Verbose], 0		; are we in verbose mode?
	jne	@@doIt			; yes

	mov	bx, offset tx_TFTP
	call	Print
	jmp	@@skip

@@doIt:
	mov	bx, offset tx_Transfering
	call	Print

;	mov	bx, 3
;	call	AIChangeReceiveMask	; enable broadcast reception

	mov	bx, [NamePtr]		; get pointer to file name
	call	Print			; print image file name

	mov	al, ' '
	call	PrintChar

@@skip:
	mov	[Counter], 1
	call	PrintTransferValue	; update screen counter

	mov	ax, 1000h		; BootWare load segment
	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@notBINL

	mov	ax, 7c0h		; PXE load segment

@@notBINL:
	; set starting pointer for image (1000:0)
	mov	[word ptr Transfer+2], ax
	mov	[word ptr Transfer], 0

	mov	[PacketNum], 0

	mov	[TFTP.Size], size OpenTFTPStruct
	mov	[TFTP.Flags], 1		; enable large block size
	mov	eax, [GatewayIP]
	mov	[(TFTP.Gateway)], eax
	mov	eax, [ServerIP]
	mov	[TFTP.Address], eax
	mov	ax, [NamePtr]
	mov	[TFTP.FileName], ax
	mov	[(TFTP.FileName)+2], ds
	mov	[word ptr TFTP.Callback], offset TFTPCallback
	mov	[(word ptr TFTP.Callback)+2], cs

	mov	di, offset TFTP
	call	AIOpenTFTP		; transfer the file
	or	ax, ax			; was there an error?
	je	@@notIP			; no error

	push	ax
	call	PrintCRLF
	mov	bx, offset ErrorMsg
	call	Print			; print "Error: "

	pop	ax
	cmp	ax, 25			; IP error?
	jne	@@notIP

	mov	bx, offset tx_CantResolve
	call	Print

	lea	si, [GatewayIP]
	cmp	[GatewayIP], 0		; is there a gateway?
	jne	isGW

	lea	si, [ServerIP]

isGW:
	call	PrintIP

	xor	ax, 1			; set flags to return with error

@@notIP:
	ret

endp

;--------------------------------------------------------------------
; TftpCallback
;
; Callback function for TFTP transfer.
;
; Parameters:
;	ax - packet type
;	bx - packet number
;	cx - packet size
;	es:di - pointer to data
;
; Returns:
;	ax - status
;--------------------------------------------------------------------
Proc TftpCallback far

	push	ds			; save caller ds

	push	cs
	pop	ds			; set ds = cs

	cmp	ax, -2			; is this a timeout callback?
	jne	notTimeout		; no

	call	Timeout
	jmp	callbackExit

notTimeout:
	call	ProcessPacket
	or	ax, ax			; was there an error?
	jne	callbackExit		; yes

	call	PrintTransferValue	; update screen counter

	inc	[PacketNum]		; increase packet number

	xor	ax, ax			; return "no error"

callbackExit:
	pop	ds			; restore ds
	ret				; status returned in ax

endp

;--------------------------------------------------------------------
; CheckTimeout
;
; Parameters:
;	none
;
; Returns:
;	ax = 0 if ok
;--------------------------------------------------------------------
Proc Timeout

	mov	ah, 1
	int	16h			; check keyboard for a key
	jz	noKey2			; no key pressed

	xor	ax, ax
	int	16h			; read keyboard

	cmp	ax, 011Bh		; ESC code
	je	timeoutDone		; ESC - time's up

noKey2:
	inc	[Counter]
	call	PrintTransferValue	; update screen

	add	cx, 9			; add half second to time out

	xor	ax, ax			; clear return status
	cmp	[Counter], 20		; have we reached retry limit?
	jne	timeoutOK		; no

timeoutDone:
	inc	ax			; return error value

timeoutOK:
	ret

endp

;--------------------------------------------------------------------
; ProcessPacket
;
; Parameters:
;	es:di - pointer to data
;	bx - packet number
;	cx - packet size
;
; Returns:
;	ax = 0 if ok
;--------------------------------------------------------------------
Proc ProcessPacket

	cmp	ax, 5			; is this an error packet
	jne	no_error		; nope
	call	ErrorTFTP		; handle the error

tftp_error:
	mov	ax, -1
	ret				; return with error

no_error:
	cmp	ax, 3			; is this a data packet
	jne	tftp_error		; nope

	;------------------------------------------------------------
	; Copy data from packet into memory
	;------------------------------------------------------------
	cmp	[PacketNum], 0		; is this the first packet?
	jne	not_first		; no

	call	CheckAPI		; check if image uses the ROMs API

	call	CheckExtended		; check if extended image
	jc	tftp_error		; there was an error

not_first:
	cmp	[HeadSize], 0		; data left in header?
	jne	saveHeader		; yes put data in conventional RAM

	cmp	[ExtFlag], 1		; are we using extended memory
	je	doExtended		; copy to extended memory

	call	CopyRam			; copy all to convetional RAM
	jc	tftp_error		; if error - send NAK
	jmp	processOK		; no error - done

saveHeader:
	mov	ax, cx			; save total size in ax
	cmp	[HeadSize], cx		; do we have more data then needed?
	ja	moreTogo

	mov	cx, [HeadSize]

moreTogo:
	sub	[HeadSize], cx

notExtended:
	call	CopyRam			; copy to convetional RAM
	jc	tftp_error		; if error - send NAK

	add	di, cx			; update new starting offset

	sub	ax, cx			; subtract what we saved from total
	cmp	ax, 0
	je	processOK		; nothing remaining
	mov	cx, ax

doExtended:
	call	CopyExtended		; put packet in extended RAM
	jc	tftp_error		; if error - send NAK

processOK:
	xor	ax, ax
	ret				; return with no error

endp

;--------------------------------------------------------------------
; CheckAPI
;
; Checks the contents of the first packet received to see if the image
; is a BWAPI image, if it is we set a flag to not disengage the ROM.
;
; Parameters:
;	es:di - pointer to packet data
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc CheckAPI

	cmp	[word ptr es:di+2], 'WB'
	jne	notAPI			; look for "BWAPI" at offset 2

	cmp	[word ptr es:di+4], 'PA'
	jne	notAPI

	mov	[NoDisengage], 1	; set flag to not disengage

notAPI:
	ret

endp

;--------------------------------------------------------------------
; CheckExtended
;
; Checks the contents of the first packet received to see if the image
; should be saved in extended memory.
;
; Parameters:
;	es:di - pointer to packet data
;
; Returns:
;	ax = 0 if OK
;--------------------------------------------------------------------
Proc CheckExtended

	; look for extended memory signature
	cmp	[word ptr es:di+14], 'xE'
	jne	not_extended		; no signature

	cmp	[word ptr es:di+16], 'xT'
	jne	not_extended		; no signature

	mov	ah, 88h
	int	15h			; get extended memory size

	cmp	[es:di+12], ax		; compare with size of image
	ja	exterror		; not enough memory

	mov	ax, [es:di+10]		; get size of header code
	mov	[HeadSize], ax		; save header size
	mov	[ExtFlag], 1		; set extended memory flag

	mov	[ExtendedAddress], 0	; set starting extended memory address
	mov	[ExtendedAddress+2], 11h

not_extended:
	clc
	ret				; return no error

exterror:
	mov	bx, offset tx_extmemerror
	call	PrintError

	stc
	ret				; return with error

endp

;--------------------------------------------------------------------
; CopyRam
;
; Copies image into conventional RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data packet
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyRam

ifdef TSR
	clc				; clear carry for OK
	ret
endif

	push	ax
	push	cx			; save count
	push	di			; save data address

	push	es			; save data segment
	push	ds			; save our ds

	; set ds:si to packet address, es:di to RAM address
	mov	si, di			; move source address into si
	push	es
	les	di, [Transfer]		; get RAM pointer into es:di
	pop	ds			; ds = packet segment

	rep	movsb			; copy packet

	pop	ds			; restore our ds

	mov	ax, di			; move ending offset to ax
	mov	cl, 16			; divide offset into a paragraph
	div	cl			; number

	xor	cx, cx			; cx = 0
	xchg	cl, ah			; cx is new offset,
					; ax is paragraph count

	mov	bx, es			; add paragraphs to segment
	add	bx, ax

	mov	[word ptr Transfer], cx	; save new offset
	mov	[word ptr Transfer+2], bx	; save new segment

	pop	es			; restore our es

	;------------------------------------------------------------
	; Check new segment to make sure the image is not going to
	; over write our code.  If it is print error message and
	; set error state.
	;------------------------------------------------------------
	mov	ax, cs			; get our current code segment
	cmp	bx, ax
	jb	copyRamOk		; not going to over write

	mov	bx, offset tx_toolarge
	call	PrintError		; error: "Image file too large."

	stc				; set carry for error
	jc	copyRamExit

copyRamOk:
	clc				; clear carry for OK

copyRamExit:
	pop	di			; restore data pointer
	pop	cx			; restore packet size
	pop	ax
	ret

endp

;--------------------------------------------------------------------
; CopyExtended
;
; Copies image into extended RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyExtended

	push	es			; save es
	pusha				; save all registers

	;------------------------------------------------------------
	; Source address must be converted to 24 bit address for
	; extended memory INT15 copy function
	;------------------------------------------------------------
	push	cx			; save packet size
	push	di			; save packet address
	push	es			; save packet segment

	push	ds
	pop	es			; es = our segment

	mov	di, offset GDT		; get GDT location
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw			; zero the GDT (es:di)

	pop	ax			; ax = packet segment
	pop	bx			; bx = packet offset
	xor	dx, dx			; dx = 0
	mov	cx, 16
	mul	cx			; dx:ax = ax * 16
	add	ax, bx			; add offset
	adc	dx, 0			; dx:ax is now 24 bit source address

	pop	cx			; get copy bytes size
	push	cx			; save it again

	mov	[GDT.SourceLimit], cx	; set copy size
	mov	[GDT.TargetLimit], cx	; set copy size
	mov	[GDT.SourceRights], 93h	; set copy rights
	mov	[GDT.TargetRights], 93h	; set copy rights

	mov	[GDT.SourceLoWord], ax	; set source address lo word
	mov	[GDT.SourceHiByte], dl	; set source address hi byte

	mov	ax, [ExtendedAddress]	; get 24 bit extended memory address
	mov	dx, [ExtendedAddress+2]
	mov	[GDT.TargetLoWord], ax	; set dest address low word
	mov	[GDT.TargetHiByte], dl	; set dest address hi byte

	inc	cx
	shr	cx, 1			; now cx is word count
	mov	si, offset GDT		; address of GDT (ds:di)
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	pop	cx			; restore byte count in CX

	pushf				; save INT15 status

	add	[ExtendedAddress], cx	; calc next address
	adc	[ExtendedAddress+2], 0

	popf				; restore INT15 status

	popa				; restore registers
	pop	es			; restore es
	ret				; return - carry set/cleared in INT15

endp

;--------------------------------------------------------------------
; ErrorTFTP
;
; Something is wrong with the TFTP transfer.
;
; Parameters:
;	ds:di - pointer to packet
;
;--------------------------------------------------------------------
Proc ErrorTFTP

	mov	si, di
	mov	di, offset StringBuffer

err_loop:				; copy error message into local memory
	lodsb
	stosb
	or	al, al			; was a null moved?
	jne	err_loop

	call	PrintCRLF
	mov	bx, offset tx_error
	call	Print

	mov	bx, offset StringBuffer
	call	Print

	ret

endp

;--------------------------------------------------------------------
; Check4SecureMode
;
; Checks if TFTP secure mode is enabled, if it is then the path
; is removed from the file name returned from the BOOTP/DHCP server.
;
;--------------------------------------------------------------------
Proc Check4SecureMode

	cmp	[byte ptr si], 0	; check first character of name
	je	noName			; no file name specified

	;------------------------------------------------------------
	; Check for secure mode, if so then we only want the file name.
	;------------------------------------------------------------
	test	[IPFeature], 1		; check for secure mode 
					; clear = non secure, set = secure
	jz	notSecure		; nope

	mov	di, si			; save path start in di

	; find the end of the file name
findEnd:
	inc	si
	cmp	[byte ptr si], 0
	jne	findEnd

	; now scan back to find the beginning of the name
findStart:
	cmp	si, di			; at start of path string?
	je	notSecure		; yep, there is no /
	dec	si
	mov	al, [si]		; get character
	cmp	al, '\'
	je	foundIt
	cmp	al, ':'
	je	foundIt
	cmp	al, '/'
	jne	findStart

foundIt:
	inc	si

notSecure:
	mov	[NamePtr], si		; save pointer to file name

noName:
	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\ipdata.inc ===
;====================================================================
; IPDATA.INC
;
; Global data for TCP/IP NID
;
;====================================================================
public	LocalIP
public	ServerIP
public	BootPkt
public	DiscoverPkt
public	BINLPkt

public tx_NoServer
public tx_NoBINL
public tx_toomanytries

STATE_DONE	equ	0
STATE_BOOTP	equ	1
STATE_OFFER	equ	2
STATE_ACK	equ	4
STATE_BINL	equ	8

;---------------------------------------------------------------------
;  BOOTP bootstrap packet structure
;---------------------------------------------------------------------
Struc	BOOTP
	OP		db	?		; Op Code
	htype		db	?		; hardware address type
	hlen		db	?		; hardware address lenght
	hops		db	?		; hop count
	xid		dw	?		; transaction id
	xid2		dw	?
	secs		dw	?		; seconds counter
	spare 		dw	?		; spare word
	ciaddr		dd	?		; client IP address
	yiaddr		dd	?		; "your" address, from server
	siaddr		dd	?		; server IP address
	gwaddr		dd	?		; gateway address
	chaddr		db	16 dup(?)	; hardware address
	sname		db	64 dup(?)	; server name
	filename	db	128 dup(?)	; boot file name
	options		db	64 dup(?)	; vender information
ends

;---------------------------------------------------------------------
; Extended memory global descriptor structure
;---------------------------------------------------------------------
Struc	DESCRIPTOR
	Dummy		dw	?, ?, ?, ?
	GDT_LOC 	dw	?, ?, ?, ?
	SourceLimit	dw	?
	SourceLoWord	dw	?
	SourceHiByte	db	?
	SourceRights	db	?
	SourceInternal	dw	?
	TargetLimit	dw	?
	TargetLoWord	dw	?
	TargetHiByte	db	?
	TargetRights	db	?
	TargetInternal	dw	?
	Bios		dw	?, ?, ?, ?
	Temp		dw	?, ?, ?, ?
ends

START_CODE

Even

State		dw	0		; current state
LocalIP		dd	0		; workstation IP address
ServerIP	dd	-1		; server IP address
GatewayIP	dd	0		; gateway IP address
BinlIP		dd	0		; IP number from proxy server
PacketNum	dw	0		; TFTP packet number
ExtFlag		db	0		; extended memory flag
NoDisengage	db	0		; don't disengage when jump to image
WaitTime	dw	18		; wait time between retries
NamePtr		dw	DefaultFile	; pointer to file name
DHCPType	db	2		; type of DHCP packet we want

BINLID		db	55, 9, 1, 3, 2, 4, 6, 12, 15, 60, 43
		db	57, 2, 4, 236
		db	93, 2, 0, 0
		db	94, 3, 1, 2, 0
		db	60, 9
PXE		db	'PXEClient'

BINLID_SIZE	equ	35

;----------------------------------------------------------------------
; Message Definitions
;----------------------------------------------------------------------
tx_bootp	db	"BOOTP", 0
tx_dhcp		db	"DHCP", 0
;tx_binl	db	"BINL", 0
tx_TFTP		db	"TFTP", 0
tx_ServerIP	db	"Server: ", 0
tx_LocalIP	db	"Local: ",0
tx_Gateway	db	"Gateway: ", 0
tx_NoServer	db	"No reply from a server.", 0
tx_NoBINL	db	"No reply from a BINL server.", 0
tx_Transfering	db	"Transferring ", 0
tx_extmemerror	db	"Not enough extended memory for image.", 0
tx_toomanytries	db	"Too many retries.", 0
tx_error	db	"File transfer error: ", 0
tx_toolarge	db	"Image file too large for low memory.", 0
tx_CantResolve	db	"Can't resolve IP address ", 0
tx_TransmitError db	"Transmit error # ", 0
DefaultFile	db	"bootware.img", 0

END_CODE

;----------------------------------------------------------------------
; Uninitialized data
;----------------------------------------------------------------------
START_SPARSE

public _IPSparseStart
label _IPSparseStart

Protocol	dw	?
ReplyIP		dd	?	; IP number that replied to us
DestPort	dw	?	; destination port for TFTP
Random		dw	?	; a "random" value (from clock tick)
HeadSize	dw	?	; # byte in packet header
StartTime	dw	?	; starting time of transmitting
Transfer	dd	?	; dword ptr
ExtendedAddress	dw	?	; current extended memory address
		dw	?	; extended address high word
GDT		DESCRIPTOR <?>	; global descriptor table
Counter		dw	?	; retry counter
Replies		dw	?	; number of BOOTP/DHCP replies we got
TickStart	dd	?

TxUDP		TxUDPStruct <?>
TFTP		OpenTFTPStruct <?>

BootPkt		db 512 dup (?)

IFDEF GOLIATH
	DiscoverPkt	db 512 dup (?)
	BINLPkt		db 512 dup (?)
ELSE
	extrn NetWareStart:byte
	DiscoverPkt 	= NetWareStart + 512
	BINLPkt		= DiscoverPkt + 512
ENDIF
StringBuffer	= BINLPkt + 512

public	_IPEndSparse
label _IPEndSparse

END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\loader\loader.inc ===
Struc	LoaderInfo
	LangSeg		dw	?
	PCIBusDevFunc	dw	?
	VendorID	dw	?
	DeviceID	dw	?
	CSN		dw	?
	UNDICode	dw	?	; UNDI code size
	UNDIData	dw	?	; UNDI data size
	UNDISeg		dw	?	; UNDI segment
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\bootp.asm ===
;===================================================================
; BOOTP.ASM
;
;$History: BOOTP.ASM $
; 
; *****************  Version 8  *****************
; User: Paul Cowan   Date: 17/08/98   Time: 10:30a
; Updated in $/Client Boot/Goliath/BootWare/TCPIP
; BINL server IP address was always used for TFTP, now the ServerIP field
; in the BINL reply is used.
; 
; *****************  Version 7  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 4:49p
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Better error message handling for failed transmit.
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 11:37a
; Updated in $/Client Boot/Goliath/BootWare/TCPIP
; Change: BOOTP vendor field now terminated correctly.
; Change: Gateway address retrieved from BINL packet.
; Change: DHCP server IP was not retrieved if no file name was specifeid.
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 22/07/98   Time: 5:34p
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; DHCP ACK packet was being saved (for Goliath) and overwritting OFFER
; packet so no image file name was found.  ACK is only saved if doing
; BINL.
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 7/07/98    Time: 14:33
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Replaced missing label.
; 
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 7/07/98    Time: 14:17
; Updated in $/Client Boot/Goliath/BootWare/TCP-IP
; Fixed problems with BINL - BINL options could be incorrectly
; included with standard DHCP request.
;===================================================================

TEMPSEG = 5000h

;--------------------------------------------------------------------
; DoBOOTP
;
; Main BOOTP processing loop.
;
;--------------------------------------------------------------------
Proc DoBOOTP

	call	InitBOOTP		; initialize BOOT/DHCP

startLoop:
	mov	[Replies], 0		; clear reply counter

	mov	[word ptr Transfer], 0
	mov	[(word ptr Transfer)+2], TEMPSEG

bootpLoop:
	call	Transmit		; transmit a packet

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

	; -----------------------------------------------------------
	; We sit and wait a while to collect any replies, this
	; allows us to receive more then one reply then pick which
	; reply we want later.  If a key is pressed the waiting stops,
	; unless the ESCAPE key is pressed, then we abort the boot.
	; -----------------------------------------------------------
waitLoop:
	mov	ah, 1
	int	16h			; check keyboard for a key
	jz	noKey			; no key pressed

	xor	ax, ax
	int	16h			; read keyboard

	cmp	ax, 011Bh		; ESC code
	jne	waitDone		; not ESC - exit wait loop

	cmp	ax, 0			; set flags for not equal
	jmp	exit			; abort

noKey:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, [WaitTime]		; is time up?
	jb	waitLoop		; loop until times up

	inc	[Counter]		; increase transmit count

waitDone:
	cmp	[Replies], 0		; did we get any replies?
	jne	gotSome			; yes

	cmp	[Counter], 20		; have we tried 20 times?
	jne	bootpLoop		; no, keep trying

	call	PrintCRLF
	mov	bx, offset tx_NoServer
	call	Print			; say "No reply from a server."

	xor	ax, 1			; set error state to reboot
	jmp	exit

gotSome:
	call	ProcessReplies		; process the replies we got
	cmp	[State], 0		; are we still doing something?
	jne	startLoop		; more to do

	xor	ax, ax

exit:
	pushf				; save return status
	mov	bx, 2
;	call	AIChangeReceiveMask	; disable broadcast reception

	mov	di, 0
	mov	cx, 1
	call	AISetCallBack		; clear callback

	popf				; restore return status
	ret				; BOOTP, or DHCP is done, return

endp

;--------------------------------------------------------------------
; InitBOOTP
;
; Sets up for BOOTP or DHCP depending on the method selected in
; the BootWare table.
;
; Parameters:
;	none
;
; Returns:
;	nothing (first packet is built and sent)
;
;--------------------------------------------------------------------
Proc InitBOOTP

	mov	[WaitTime], 18		; start timeout at 1 second
	mov	[Counter], 0		; clear counter

	xor	dx, dx
	mov	es, dx			; es=0
	mov	edx, [es:046ch]		; get clock tick count
	mov	[TickStart], edx
	mov	[Random], dx		; save low word as "random" number

	push	ds
	pop	es			; es = ds

	mov	bx, offset tx_bootp	; get pointer to BOOTP string
	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	init2			; yes

	mov	bx, offset tx_dhcp	; get pointer to DHCP string

init2:
	call	Print			; print "BOOTP:"

	mov	bx, 3
	call	AIChangeReceiveMask	; enable broadcast reception

	mov	di, offset BootpCallback
	mov	cx, 1
	call	AISetCallBack		; setup Raw callback

	call	CreateRequest		; create the request packet
	ret

endp

;--------------------------------------------------------------------
; CreateRequest
;
; Build a BOOTP request or DHCP discover packet.
;
;--------------------------------------------------------------------
Proc CreateRequest

	; Clear the packet buffer.
	xor	ax, ax
	mov	di, offset TxBuffer
	mov	cx, (size BOOTP) / 2
	rep	stosw

	; build the UDP transmit structure
	mov	[TxUDP.Size], size TxUDP
	mov	[TxUDP.Address], -1	; IP address is broadcast
	mov	[TxUDP.SourcePort], 68
	mov	[TxUDP.DestPort], 67
	mov	[TxUDP.Data], offset TxBuffer
	mov	[(TxUDP.Data)+2], ds
	mov	[TxUDP.Length], size BOOTP

	; fill in request packet details
	mov	bx, offset TxBuffer
	mov	[(BOOTP bx).OP], 1	; set op code for request
	mov	[(BOOTP bx).htype], 1	; hardware type is ethernet
	mov	[(BOOTP bx).hlen], 6	; hardware address length is 6

	mov	ax, [Random]		; get the "random" number
	inc	ax
	mov	[(BOOTP bx).xid], ax	; save as transaction ID
	mov	[(BOOTP bx).xid2], 'cp'
	mov	[Random], ax

	; put local hardware address into BOOTP packet
	lea	di, [(BOOTP bx).chaddr]
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	lea	di, [(BOOTP bx).options]; get offset for options field

	; stuff RFC 1048 magic cookie
	mov	ax, 8263h
	stosw
	mov	ax, 6353h
	stosw

	mov	[State], STATE_BOOTP	; default to BOOTP state

	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	createExit		; yes

	mov	[State], STATE_OFFER	; we are waiting for an offer reply

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	stosb				; DHCP discover 

	cmp	[Protocol], IP_BINL	; are we doing BINL?
	jne	createExit		; no

	;------------------------------------------------------------
	; We are doing BINL so add the BINL data to the options field.
	;------------------------------------------------------------
	mov	cx, BINLID_SIZE
	mov	si, offset BINLID	; put BINL option in packet
	rep	movsb

	; copy the packet into local memory buffer
	push	di
	mov	si, offset TxBuffer
	mov	di, offset DiscoverPkt	; get location for packet
	mov	cx, size BOOTP
	rep	movsb			; copy discover packet
	pop	di

createExit:
	mov	al, -1
	stosb				; truncate option field

	ret

endp

;--------------------------------------------------------------------
; BootpCallback
;
; Calls the interface layer to check if a packet has been received.
; If a packet has been received the packet is processed on our current
; state.
;
; Parameters:
;	cx - packet length
;	es:di - packet buffer address
;
; Returns:
;	ax - new state
;	carry set if packet received for us
;--------------------------------------------------------------------
Proc BootpCallback far

	pusha				; save everything
	push	es			; save es
	push	ds			; save ds

	push	es
	pop	ds			; ds = packet buffer segment

	push	cs
	pop	es			; es = cs

	mov	si, di			; move packet address into si

	; Skip the MAC header so we don't have to worry about it later.
	add	si, 14			; skip MAC header
	sub	cx, 14

	call	VerifyPacket
	jc	@@skipPacket		; not for us or bad

	les	di, [cs:Transfer]	; get current buffer location

	mov	ax, cx
	stosw				; save packet size
	rep	movsb			; copy packet into our buffer

	mov	[word ptr es:di], 0

	mov	[word ptr cs:Transfer], di

	inc	[cs:Replies]		; increase reply count

@@skipPacket:
	pop	ds			; restore ds
	pop	es			; restore es
	popa				; restore everything
	ret

endp

;--------------------------------------------------------------------
; VerifyPacket
;
; Verifys that the packet given to us is a BOOT, or DHCP, reply
; for us.
;
; Parameters:
;	ds:si - pointer to received packet
;	cs - packet size
;	es set to our current segment
;
; Returns:
;	carry set if we want the packet
;--------------------------------------------------------------------
Proc VerifyPacket

	push	si			; save packet pointer
	push	cx			; save packet size

	lea	bx, [si + 20]		; skip IP header

	; check the UDP destination port for BOOTP client
	cmp	[word ptr bx+2], 4400h	; is dest bootp client?
	jne	@@badPacket		; no good

	add	bx, 8			; skip UDP header

	; check if the packet is a BOOTP reply for us
	cmp	[(BOOTP bx).OP], 2	; check for a reply packet
	jne	@@badPacket		; no good

	; check for our hardware address in the hardware field
	lea	si, [(BOOTP bx).chaddr]
	mov	di, offset NetAddress
	mov	cx, 3
	rep	cmpsw
	jne	@@badPacket		; no good

	cmp	[es:Protocol], IP_BOOTP	; are we doing BOOTP?
	je	@@goodPacket		; yes

	lea	di, [((BOOTP bx).Options)+4]

	cmp	[byte ptr di], 53	; make sure this is a DHCP reply
	jne	@@badPacket		; not DHCP

	mov	al, [di+2]		; get DHCP message type
	cmp	al, [es:DHCPType]	; is this the type we want?
	jne	@@badPacket		; no

@@goodPacket:
	clc				; clear carry - packet good
	jmp	@@verifyExit

@@badPacket:
	stc				; set carry - bad packet

@@verifyExit:
	pop	cx			; restore packet szie
	pop	si			; restore packet pointer
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessReplies

	cmp	[State], STATE_BOOTP	; are we doing BOOTP?
	jne	@@skip1			; no

	jmp	ProcessBOOTP

@@skip1:
	cmp	[State], STATE_OFFER	; are we doing DHCP offer?
	jne	@@skip2

	jmp	ProcessOffer		; process the offer reply

@@skip2:
	cmp	[State], STATE_ACK	; are we doing DHCP ACK?
	jne	@@skip3

	jmp	ProcessACK		; process the ACK reply

@@skip3:
	cmp	[State], STATE_BINL	; are we doing BINL reply?
	jne	@@skip4

	jmp	ProcessBINL		; process the BINL reply

@@skip4:
	ret				; we shouldn't be here

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessBOOTP

	call	SelectReply
	jnc	@@done			; didn't find anything

	call	ProcessReply

	mov	[State], STATE_DONE	; set state to done

@@done:
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessOffer

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@skip1			; no

	call	SelectProxy		; select a proxy reply packet

@@skip1:
	call	SelectReply		; select a DHCP reply
	jnc	@@done			; didn't find anything

	call	ProcessReply
	call	DhcpRequestTx

@@done:
	ret

endp

;--------------------------------------------------------------------
; ProcessBINL
;
; Processes the BINL reply packet.  It's assumed only one packet
; is in the buffer so we use the fist packet.
;
;--------------------------------------------------------------------
Proc ProcessBINL

	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

	; copy the entire reply packet into local memory buffer
	mov	di, offset BINLPkt	; get location for packet
	call	CopyPacket

	lea	si, [(BOOTP di).filename]
	cmp	[byte ptr ds:si], 0	; did we get a file name?
	je	@@skip			; no name specified

	mov	[NamePtr], si		; save pointer to file name

@@skip:
	mov	eax, [(BOOTP di).siaddr]; get server IP
	cmp	eax, 0			; get a value?
	jne	gotIP			; yes

	mov	eax, [BINLIP]		; use BINL server IP address

gotIP:
	mov	[ServerIP], eax

	mov	eax, [(BOOTP di).gwaddr]; get gateway IP
	mov	[GatewayIP], eax

	mov	[State], STATE_DONE	; now we are done
	ret

endp

;--------------------------------------------------------------------
; SelectReply
;
; Scans all the BOOTP/DHCP replies we got to find one that has a file
; name and an IP address for us.  If a reply is found with a file
; then the first reply with an IP address will be used and the file
; name will default to "bootware.img".
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to full packet
;	carry set if packet selected
;--------------------------------------------------------------------
Proc SelectReply

	cmp	[State], STATE_BOOTP	; are we doing BOOTP?
	jne	@@notBOOTP		; yes

	call	SelectBOOTP		; select a BOOTP reply
	jc	@@selected
	ret				; nothing selected

@@notBOOTP:
	call	SelectDHCP		; select a DHCP reply
	jc	@@selected		; found a reply

	ret				; no packet selected

@@selected:
	mov	di, offset BootPkt
	call	CopyPacket		; copy packet into local memory

	stc				; set carry
	ret

endp

;--------------------------------------------------------------------
; SelectBOOTP
;
; Scans all the BOOTP replies we got to find one that has an IP
; address for us and a file name.  If no entry with a file name is
; found we check the replies again and accept the first one that has
; an IP address.  The image will default to "bootware.img".
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to selected packet (carry set)
;--------------------------------------------------------------------
Proc SelectBOOTP

	mov	si, TEMPSEG
	mov	es, si

	xor	ax, ax			; clear file name skip flag

@@selectStart:
	xor	si, si			; start at beginning of buffer

@@processNext:
	cmp	[word ptr es:si], 0	; does this packet have data?
	je	@@notFound		; end of data packets
	lea	bx, [si+2+20+8]		; skip size word, IP & UDP headers
	cmp	[word ptr (BOOTP es:bx).yiaddr], 0; is there an IP address?
	je	@@noIP			; no - skip packet

	cmp	ax, 0			; first time checking?
	jne	@@gotName		; no - skip file name check

	cmp	[(BOOTP es:bx).filename], 0; is there a file name?
	jne	@@gotName		; yes

@@noIP:
	add	si, [es:si]		; add size of packet
	add	si, 2			; skip size byte
	jmp	@@processNext		; check the next packet

@@notFound:
	cmp	ax, 0
	jne	@@noneFound

	inc	ax
	jmp	@@selectStart		; check again

@@noneFound:
	clc				; clear carry - we didn't find a packet
	ret

@@gotName:
	stc				; set carry - we found a packet
	ret

endp

;--------------------------------------------------------------------
; SelectDHCP
;
; Scans all the DHCP replies we got to find one that has a file name,
; and a DHCP server IP number.
; If no reply if found with a file name then the first packet is used
; to get just our IP number and we will default to "bootware.img" for
; the image.
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to selected packet
;	carry set if packet selected
;--------------------------------------------------------------------
Proc SelectDHCP

	call	SelectBOOTP		; find a reply with a file name
	jc	@@selected
	ret

@@selected:
	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 54
	call	FindDhcpOption		; look for server IP

	cmc				; flip carry
	ret				; return - we found a packet

	;------------------------------------------------------------
	; We didn't find a reply that had both a file name and a 
	; DHCP server IP number, so let's use the first one that
	; does have a server IP number.
	;------------------------------------------------------------
;@@noIP:
;	mov	si, TEMPSEG
;	mov	es, si
;	xor	si, si			; start at beginning of buffer

;@@processNext:
;	cmp	[word ptr es:si], 0	; does this packet have data?
;	je	@@notFound		; end of data packets

;	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
;	mov	bl, 54
;	call	FindDhcpOption		; look for server IP
;	jc	@@gotIP			; option found

;	add	si, [es:si]		; add size of packet
;	add	si, 2			; skip size byte
;	jmp	@@processNext		; check the next packet

;@@notFound:
;	clc				; clear carry - bad
;	ret

;@@gotIP:
;	stc				; set carry - OK
;	ret

endp

;--------------------------------------------------------------------
; SelectProxy
;
; Scans all the replies we got to find one that is a PXE proxy reply.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SelectProxy

	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

@@checkNext:
	cmp	[word ptr es:si], 0	; does this packet have data?
	je	@@notFound		; end of data packets
	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 60
	call	FindDhcpOption		; look for class identifier
	jnc	@@found			; option was found

@@next:
	add	si, [es:si]		; add size of packet
	add	si, 2			; skip size byte
	jmp	@@checkNext		; check the next packet

@@notFound:
	xor	si, si			; set zero flag - not found
	ret

@@found:
	push	si			; save si
	mov	si, offset PXE		; offset to static text
	mov	cx, 9
	rep	cmpsb			; check for "PXEClient" string
	pop	si			; restore si
	jne	@@next			; string not found

	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 54
	call	FindDhcpOption		; look for server IP
	jc	@@next			; option was not found

	mov	eax, [es:di]		; get the BINL server's IP address
	mov	[BinlIP], eax

	xor	di, 1			; clear flag
	ret

endp

;--------------------------------------------------------------------
; Parameters:
;	es:si - pointer to entire packet
;--------------------------------------------------------------------
Proc ProcessReply

	;------------------------------------------------------------
	; Copy the replying servers IP address from the IP header.
	; For now assume the replying server is going to be the only
	; server.
	;------------------------------------------------------------
	add	si, 2			; skip buffer size word

	mov	eax, [dword ptr (IP es:si).SourceIP]
	mov	[ReplyIP], eax
	mov	[ServerIP], eax

	;------------------------------------------------------------
	; Set pointer to BOOTP packet.
	;------------------------------------------------------------
	mov	bx, offset BootPkt	; get location for BOOTP packet
	push	ds
	pop	es			; es = ds

	;------------------------------------------------------------
	; Get our IP number.
	;------------------------------------------------------------
	lea	si, [(BOOTP bx).yiaddr]	; get our IP address from reply
	mov	di, offset LocalIP
	movsw
	movsw

	mov	eax, [(BOOTP bx).gwaddr]; gateway IP
	mov	[GatewayIP], eax

	;------------------------------------------------------------
	; Check if a different server IP address was specified in the
	; BOOTP server IP field, if it was then use that servers address.
	;------------------------------------------------------------
	mov	eax, [(BOOTP bx).siaddr]; get IP address
	cmp	eax, 0			; is there a value?
	je	sameIP			; no

	cmp	[ReplyIP], eax		; is the IP the same as the servers
	je	sameIP			; yes

	mov	[ServerIP], eax		; update servers IP address

sameIP:
	lea	si, [(BOOTP bx).filename]
	cmp	[byte ptr ds:si], 0	; did we get a file name?
	je	@@noName		; no name specified

	mov	[NamePtr], si		; save pointer to file name

@@noName:
	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	@@processExit		; yes - we are done

	;------------------------------------------------------------
	; We are doing DHCP so get the servers IP address.
	;------------------------------------------------------------
	mov	bl, 54			; get and save server IP address
	mov	di, offset BOOTPkt	; skip IP and UDP headers
	call	FindDhcpOption
	mov	si, offset ServerIP
	xchg	di, si
	movsw				; save DHCP servers IP number
	movsw

@@processExit:
	ret

endp

;-----------------------------------------------------------------------------
; DhcpRequestTx
;
; Build and send a DHCP request packet (an offer packet has been received).
;
;-----------------------------------------------------------------------------
Proc DhcpRequestTx

	lea	di, [((BOOTP TxBuffer).Options)+4]

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	mov	al, 3
	stosb				; DHCP request

;	mov	cx, 6				
;	mov	si, offset DHCPRequest
;	rep	movsb			; add DHCP request option

;	mov	cx, 6
;	mov	si, offset NetAddress
;	rep	movsb			; add our node address

	mov	ax, 0432h
	stosw				; add host IP token

	mov	si, offset LocalIP
	movsw				; add our IP
	movsw

	mov	ax, 0436h
	stosw				; add server IP token

	mov	si, offset ServerIP
	movsw
	movsw				; add DHCP's server IP

	mov	al, -1
	stosb				; truncate options

	mov	[DHCPType], 5		; set next type
	mov	[State], STATE_ACK	; next we are waiting for an ACK
	ret

endp

;--------------------------------------------------------------------
; DhcpAckRx - Server responds to the REQUEST with an ACK which means
;		that the IP address is ours.
;--------------------------------------------------------------------
Proc ProcessACK

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	je	@@doingBINL		; yes

@@noBINL:
	mov	[State], STATE_DONE	; set state to done
	ret

@@doingBINL:
	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

	mov	di, offset BootPkt
	call	CopyPacket		; copy packet into local memory

	push	ds
	pop	es			; es = ds

	; check if we got an image file name, if we did we don't
	; need to do the BINL request
	cmp	[NamePtr], offset DefaultFile
	jne	@@noBINL

	jmp	RequestBINL		; send BINL request

endp

;------------------------------------------------------------------------------
; FindDhcpOption
; 	- scan dhcp options fields of packet for DHCP option
; 
; Parameters:
;	bl = option value
;	es:di - pointer to packet
;
; Returns:
;	di - pointer to option data
;	carry clear if option found
;------------------------------------------------------------------------------
Proc FindDhcpOption

	lea	di, [((BOOTP di).Options)+4]

look4Option:
	mov	bh, [es:di]
	cmp	bh, 0ffh
	je	noOption
	cmp	bh, bl			; have we found the option ?
	je	foundOption		; jump if yes
	xor	ax, ax
	mov	al, [byte ptr es:di+1]
	add	di, ax
	add	di, 2
	jmp	look4Option

foundOption:
	add	di, 2			; point past the option and size bytes
	clc
	ret				; found - return no carry

noOption:
	stc
	ret				; not found - return with carry

endp

;--------------------------------------------------------------------
; Transmit
;
; Updates a packet (IP & UDP checksums, if needed) and transmits it.
;
; Parameters:
;	none
;
; Returns:
;	al - status of transmit
;--------------------------------------------------------------------
Proc Transmit

	mov	ax, 0E2Eh
	int	10h			; print .

	cmp	[Counter], 0		; is this the first packet?
	je	firstTx			; yes

	push	0
	pop	es			; es = 0;
	mov	eax, [es:046ch]		; get clock tick count
	sub	eax, [TickStart]	; subtract starting time
	mov	edx, eax		; convert to two words
	shr	edx, 16
	mov	cx, 18			; ticks per second
	div	cx			; calc number of seconds since start

	mov	[(BOOTP TxBuffer).secs], ax; update seconds
	inc	[(BOOTP TxBuffer).xid]	; change transaction ID

firstTx:
	push	ds
	pop	es			; es = ds

	mov	di, offset TxUDP	; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	or	ax, ax			; check for returned error code
	je	txOK

	cmp	ax, 25			; is it IP address error?
	je	ipError

	push	ax
	mov	bx, offset tx_TransmitError
	call	Print			; print "Transmit error"

	pop	ax
	call	PrintDecimal		; print error number

	jmp	Reboot			; reboot the system

ipError:
	call	PrintCRLF
	mov	bx, offset ErrorMsg
	call	Print			; print "Error: "

	mov	bx, offset tx_CantResolve
	call	Print

	lea	si, [TxUDP.Address]
	call	PrintIP

	jmp	Reboot			; reboot the system

txOK:
	; increase the time-out by 0.5 seconds.
	add	[WaitTime], 9		; add 0.5 seconds
	ret

endp

;-----------------------------------------------------------------------------
; RequestBINL
;
; Build and send a DHCP request packet (an offer packet has been received).
;
;-----------------------------------------------------------------------------
Proc RequestBINL

	mov	eax, [BinlIP]
	cmp	eax, 0
	jne	@@skip

	call	PrintCRLF
	mov	bx, offset tx_NoBINL
	call	Print			; say "No reply from a server."

	jmp	Reboot

@@skip:
	lea	di, [((BOOTP TxBuffer).Options)+4]

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	mov	al, 3
	stosb				; DHCP request

	mov	cx, BINLID_SIZE
	mov	si, offset BINLID	; put BINL option in packet
	rep	movsb

	mov	al, -1
	stosb				; truncate options

	mov	[DHCPType], 5		; set next type

;	mov	[TxUDP.Size], size TxUDP
	mov	eax, [BinlIP]
	mov	[TxUDP.Address], eax
	mov	[TxUDP.SourcePort], 68
	mov	[TxUDP.DestPort], 4011
	mov	[TxUDP.Length], size BOOTP

	mov	[State], STATE_BINL	; set state to BINL request

	ret

endp

;-----------------------------------------------------------------------------
; CopyPacket
;
; Copies packet into local memory.
;
; Parameters:
;	es:si - pointer to packet to copy
;	ds:di - pointer to packet buffer
;-----------------------------------------------------------------------------
Proc CopyPacket

	push	es			; save es
	push	ds			; save ds
	push	si			; save si
	push	di			; save di

	push	es
	pop	ds			; set ds to source segment
	push	cs
	pop	es			; set es to our segment

	mov	cx, [si]		; get packet size
	add	si, 2+28		; skip size word & IP/UDP headers
	rep	movsb			; copy packet

	pop	di			; restore di
	pop	si			; restore si
	pop	ds			; restore ds	
	pop	es			; restore es

;	mov	di, offset BootPkt	; get location for packet
;	mov	al, [BWType]		; get BootWare type from table
;	mov	[(BOOTP di).hlen], al	; save in packet for BPPATCH
;	mov	ax, [NIC_IO]		; get IO address from table
;	mov	[(BOOTP di).secs], ax	; save in packet for BPPATCH
;	mov	ax, [NIC_RAM]		; get RAM address from table
;	mov	[(BOOTP di).spare], ax	; save in packet for BPPATCH

	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\tcpip.inc ===
;----------------------------------------------------------------------
;
; File Name:	   BOOTP.INC
;
; Program Name:    BOOTP Boot ROM Module
;
; Companion Files: None
;
; Function:	This module contains all the data strcuture definitions
;		for the various BOOTP Frame formats.
;
; History:
; 96-Jul-24     JJ - added support for DHCP.
; 94-Jun-23 1.1 GK - added SMCELITE conditional for XY_DESCRIPT
; 93-Apr-19 1.0 PC - first release
;----------------------------------------------------------------------

;---------------------------------------------------------------------
; Internet Protocol structure.
;---------------------------------------------------------------------
Struc IP
	Ver		db	?
	Type 		db	?
	Len		dw	?
	Ident		dw	?
	FragOffSet	dw	?
	Time 		db	?
	Protocol	db	?
	CheckSum	dw	?
	SourceIP	dw	2 dup (?)
	DestIP		dw	2 dup (?)
ends

;---------------------------------------------------------------------
; User Datagram Protocol structure.
;---------------------------------------------------------------------
Struc	UDP
	SourcePort	dw	?
	DestPort	dw	?
	Len		dw	?
	Sum		dw	?
ends

;---------------------------------------------------------------------
; other values
;---------------------------------------------------------------------

; TFTP ACK NAK values

ACK		equ	0400h
NAK		equ	0500h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\loader\5x9.asm ===
;--------------------------------------------------------------------
; BW5X9.ASM
;
; 3Com 3C509/3C509B detection support for the loader.
;
;--------------------------------------------------------------------
include "vulcan.inc"

;--------------------------------------------------------------------
; Detect a 3C5X9 NIC
;
;       Carry Flag set if found.
;       or
;       Carry Flag cleared if not found.
;
;--------------------------------------------------------------------
Proc    Detect5X9

        ; Preserve the environment.
        pushad
        push    ds
        push    es

        sti
        cld
	call	Find_Vulcan

        ; Restore the original environment.
        pop     es
        pop     ds
        popad

        ret

endp    Detect5X9

;--------------------------------------------------------------------
;
;   Find_Vulcan: 
;
;   On Entry:
;
;	sti
;	cld
;
;   On Exit:
;       Carry Flag set if found.
;       or
;       Carry Flag cleared if not found.
;
;--------------------------------------------------------------------

proc    Find_Vulcan

	cli

;-----------------------------------------------------------------------------
;  ISA-specific init code
;-----------------------------------------------------------------------------

		mov    dx, ID_PORT
		call   Write_ID_Sequence 		 ; IDS enters ID_CMD state

		mov    al, SET_TAG_REGISTER + 0		 ; 04-06-92
		out    dx, al				 ; 04-06-92, untag adapter

; look for the first adapter and activate it.  we will use contention test to
; make sure there is at least 1 Vulcan on system bus and activate the first
; Vulcan adapter we find.

		mov    al, EE_MANUFACTURER_CODE
		call   Contention_Test			 ; read EISA manufacturer ID
		cmp    ax, EISA_MANUFACTURER_ID		 ; is it 3Com's EISA ID?
		je     isa_vlucan_found

		sti
                clc
		ret

isa_vlucan_found:
		sti
                stc
		ret

endp    Find_Vulcan

;-----------------------------------------------------------------------------
;   Write_ID_Sequence:
;
;		   This routine writes ID sequence to the specified ID port
;		   on Vulcan adapter; when the complete ID sequence has been
;		   written, the ID sequence State Machine (IDS) enters the
;		   ID_CMD state.  This routine is called when IDS is in
;		   ID_WAIT state.
;
;   On Entry:
;		   dx = the ID port desired (1x0h)
;
;   On Exit:
;		   dx = preserved
;		   ax, cx are not preserved
;-----------------------------------------------------------------------------

proc    Write_ID_Sequence

       mov    al, 0
       out    dx, al				 ; to setup new ID port
       out    dx, al
       mov    cx, 0ffh				 ; 255-byte sequence
       mov    al, 0ffh				 ; initial value of sequence

wr_id_loop:
       out    dx, al
       shl    al, 1
       jnc    wr_id
       xor    al, 0cfh
wr_id:
       loop   wr_id_loop

       ret

endp    Write_ID_Sequence

;--------------------------------------------------------------------
;
;   Contention_Test: This routine, first, writes an "EEPROM Read Command" to
;		     ID port (dx), the write operation actually causes the
;		     content of the specified EEPROM data to be read into
;		     EEPROM data register.  Then it reads ID port 16 times
;		     and saves the results in ax.  During each read, the
;		     hardware drives bit 15 of EEPROM data register out onto
;		     bit 0 of the host data bus, reads this bit 0 back from
;		     host bus and if it does not match what is driven, then
;		     the IDS has a contention failure and returns to ID_WAIT
;		     state.  If the adapter does not experience contention
;		     failure, it will join the other contention tests when
;		     this routine is called again.
;
;		     Eventually, only one adapter is left in the ID_CMD state,
;		     so it can be activated.
;
;   On Entry:
;	      al = word of EEPROM data on which test will contend
;	      dx = ID port (to which ID sequence was written)
;	      cli
;
;   On Exit:
;	      ax = EEPROM data read back by hardware through contention test.
;	      dx = preserved
;	      bx = trashed
;	      cli
;
;--------------------------------------------------------------------
proc    Contention_Test

	push	bx
	push	cx
	push	dx

       add    al, READ_EEPROM			 ; select EEPROM data to
       out    dx, al				 ;  contend on

       cli
       ; seems to solve some problem when Init is ran a few times
       mov     cx, 3000h               ; 5 ms
       call    WaitTime
       sti

       mov    cx, 16				 ; read 16 times
       xor    bx, bx				 ; reset the result

contention_read:
       shl    bx, 1
       in     al, dx				 ; reading ID port causes
						 ;  contention test

       and    ax, 1				 ; each time, we read bit 0
       add    bx, ax
       loop   contention_read

       mov    ax, bx

       pop	dx
       pop	cx
       pop	bx
       ret

endp    Contention_Test

;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------

proc    WaitTime

         	push	ax
		push	bx
		call	ReadTimer0		; get Timer0 value in AX
         	mov	bx, ax			; save in BX

ReadTimer0Loop:
         	call	ReadTimer0
         	push	bx
         	sub	bx, ax
         	cmp	bx, cx
         	pop	bx
         	jc	ReadTimer0Loop
         
		pop	bx
		pop	ax
		ret

endp    WaitTime

proc    ReadTimer0

         	mov	al, 6
         	out	43h, al 		; port 43h, 8253 wrt timr mode 3
         	call	RT0
         
RT0:
         	jmp	short $+2
         	jmp	short $+2
         	jmp	short $+2
         	in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al
		ret

endp    ReadTimer0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\rbf1.h ===
struct NICINFO
{
	WORD	VendorID;
	WORD	DeviceID;
	PSTR	Name;
	int		Resource;
};

struct ADAPTERINFO
{
	int		Version;
	int		DataVersion;
	int		NICCount;
	NICINFO *NICS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RBFG.RC
//
#define PB_OK                           1
#define IDS_VERSION                     1
#define PB_CANCEL                       2
#define IDS_TITLE                       2
#define PB_ABOUT                        3
#define IDS_INVALIDFILE                 4
#define IDS_COPYRIGHT                   5
#define IDS_DATAVER                     6
#define IDS_ERRFILERD1                  7
#define IDS_ERRFILERD2                  8
#define IDS_ERROR                       9
#define ST_INFO                         10
#define IDS_ERRFORMAT                   10
#define IDS_ERRFILEWR1                  11
#define IDS_WRITE                       12
#define IDS_READ                        13
#define PB_DRIVEA                       100
#define PB_DRIVEB                       101
#define PB_ADAPTERS                     1005
#define ST_VERSION                      1008
#define ST_DATAVERSION                  1009
#define ST_COPYRIGHT                    1010
#define PB_CREATE                       1011
#define ST_LANGUAGEVERSION              1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbf1.rc
//
#define ID_BOOTSECT                     1
#define ID_LOADER                       10
#define ID_BOOTWARE                     20

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\loader\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;									     ;
;	This file contains Vulcan-specific equates, structures and	     ;
;	macros.  It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1988 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
ST_FAILED	    equ 00800h			; command failed
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

STH_FAILED	    equ ST_FAILED shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

ifdef REV0
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE or INT_ADAPTERFAIL or INT_UPDATESTATS)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ (INT_TXCOMPLETE or INT_UPDATESTATS)
else
INT_ONTXCOMPLETE    equ ((NOT INT_ADAPTERFAIL) and (0FFh))
endif

else
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
;940107INT_ONTXCOMPLETE    equ MASK_NONE
endif
endif
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 07FFh			; bytes in RxFIFO
RXS_ERRTYPE	    equ 3800h			; Rx error type, bit 13-11
ifdef REV0
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_DRIBBLE	    equ 0800h			; dribble bit
RXS_CRC 	    equ 1000h			; CRC error
RXS_RUNT	    equ 1800h			; runt packet error
RXS_OVERSIZE	    equ 2000h			; oversize packet error
RXS_FRAMING	    equ 2800h			; framing error
else
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_OVERSIZE	    equ 0800h			; oversize packet error
RXS_DRIBBLE	    equ 1000h			; dribble bit (not an error)
RXS_RUNT	    equ 1800h			; runt packet error
RXS_CRC 	    equ 2800h			; CRC error
RXS_FRAMING	    equ 2000h			; framing error
endif

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
RXSH_ERRTYPE	    equ RXS_ERRTYPE shr 8
RXSH_OVERRUN	    equ RXS_OVERRUN shr 8
RXSH_DRIBBLE	    equ RXS_DRIBBLE shr 8
RXSH_CRC	    equ RXS_CRC shr 8
RXSH_RUNT	    equ RXS_RUNT shr 8
RXSH_OVERSIZE	    equ RXS_OVERSIZE shr 8
RXSH_FRAMING	    equ RXS_FRAMING shr 8
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 38h			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
;
; Port offsets, Window 1
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 0Ch			; free transmit bytes
PORT_TxStatus	    equ 0Bh			; transmit status (byte)
PORT_Timer	    equ 0Ah			; latency timer (byte)
PORT_RxStatus	    equ 08h			; receive status
PORT_RxFIFO	    equ 00h			; RxFIFO read
PORT_TxFIFO	    equ 00h			; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch			; EEProm data register
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration
PORT_CfgAddress     equ 06h			; address configuration
PORT_CfgControl     equ 04h			; configuration control
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_RomControl     equ 04h			; 940425 RomControl Register

;
; Port offsets, Window 4
;
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_SlingshotStatus equ 08h			; Slingshot status
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_HostDiagnostic equ 02h			; host diagnostic
PORT_TxDiagnostic   equ 00h			; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Various command arguments
;
INT_ALLDISABLED 	equ 00000000000b	    ; all interrupts disabled
ifdef REV0
INT_ALLENABLED		equ 00011111100b	    ; all but AdapterFailure
else
INT_ALLENABLED		equ 00011111110b	    ; all interrupts enabled
endif

MASK_ALL		equ INT_ALLDISABLED
MASK_NONE		equ INT_ALLENABLED

FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode

RXEARLY_DISABLED	equ 2032		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 2040		    ; TxAvailable to disable
TXAVAIL_MIN		equ 4

TXSTART_DISABLED	equ 2040		    ; TxStart to disable
TXSTART_MIN		equ 0
MAX_TXSTART		equ TXSTART_DISABLED

MAX_RXLENGTH		equ 1792		    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 0100b               ; DUMMY DUMMY This value is copied
						; from 59xp even though it doesn't
						; exist on isa board

;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size
TXP_INTONSUCCESS	equ 8000h		    ; interrupt on successful tx
;
; Bits in various diagnostics registers
;
MEDIA_TP		equ 8000h		    ; TP transciever
MEDIA_BNC		equ 4000h		    ; Thinnet transciever
MEDIA_INTENDEC		equ 2000h		    ; internal encoder/decoder
MEDIA_SQE		equ 1000h		    ; SQE present
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_UNSQUELCH 	equ 0100h		    ; unsquelch (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics

NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_CORELOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting
NETD_TXRESETREQD	equ 0100h		    ; tx reset required

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXSTATUSOVER	equ 1000h		    ; rx status overrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
FIFOD_BISTRESULTS	equ 00FFh		    ; BIST results (mask)

SLING_TXUNDERRUN	equ 2000h		    ; Slingshot TxUnderrun bit
;
; board identification codes, byte swapped in Rev 0
;
ifdef REV0
EISA_MANUFACTURER_ID	equ 0506Dh		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 05090h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0FFF0h		    ; Mask off revision nibble
else
EISA_MANUFACTURER_ID	equ 06D50h		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 09050h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0F0FFh		    ; Mask off revision nibble
endif
;
; EEProm access
;
EE_BUSY 		    equ 8000h			; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID	    equ 03h
EE_MANUFACTURING_DATA	    equ 04h
EE_SERIAL_NUMBER_WORD0	    equ 05h
EE_SERIAL_NUMBER_WORD1	    equ 06h
EE_MANUFACTURER_CODE	    equ 07h
EE_ADDR_CONFIGURATION	    equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD		    equ 0Eh
EE_CHECKSUM		    equ 0Fh
EE_CAPABILITIES		    equ	010h
;
; contention logic
;
ID_PORT 		equ 110h
READ_EEPROM		equ 080h
SET_TAG_REGISTER	equ 0D0h
TEST_TAG_REGISTER	equ 0D8h
ACTIVATE_AND_SET_IO	equ 0E0h
ACTIVATE_VULCAN 	equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ		equ 0F000h
;
; Address Configuration Register bits
;
ACONFIG_XCVR		equ 0C000h
ACONFIG_IOBASE		equ 0001Fh
ACONFIG_ROM		equ 03f00h
ACONFIG_ROMSIZE 	equ 03000h
ACONFIG_ROMBASE 	equ 0f00h
;

IOBASE_EISA		equ 0001Fh

TP_XCVR 		equ 00000h
BNC_XCVR		equ 0C000h
AUI_XCVR		equ 04000h

MIN_IO_BASE_ADDR	equ 200h
MAX_IO_BASE_ADDR	equ 3F0h
REGISTER_SET_SIZE	equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h		; Maximum Modem Speed
SW_LINKBEAT		equ 4000h
SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS	 ; all the bits assigned to BootWare



;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT	equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER 	equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER		equ 01h
;
; Possibilities for SW_MAXCLI ( Max Modem Speed )
; GY 931007
MODEM_NONE		equ	03F00h
MODEM_1200		equ	03300h
MODEM_2400		equ	02700h
MODEM_9600		equ	01300h
MODEM_19200		equ	0900h
MODEM_38400		equ	0400h
;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5		; for BW5X9 overlay
BOOTPROT_BOOTP		equ 5
BOOTPROT_DHCP		equ 6

;
; Bus Types
;
BUS_ISA 		equ	1		; ISA card in  ISA mode on ISA	machine
BUS_EISA		equ	2		; EISA card
BUS_MCA 		equ	3		; MCA  card
BUS_EISA_ISAMODE	equ	4		; ISA card in  ISA mode on EISA machine
BUS_EISA_EISAMODE	equ	5		; ISA card in EISA mode on EISA machine
BUS_EISA_ISA2EISA	equ	6		; ISA card on EISA bus switch from ISA->EISA
BUS_EISA_EISA2ISA	equ	7		; ISA card on EISA bus switch from EISA->ISA
BUS_PCI			equ	8		; PCI card

; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; 940923 Capabilities Word (EEPROM Offset 010h)
CAPA_PNP		equ	1
CAPA_FULLDUPLEX		equ	2
CAPA_BIGPACKET		equ	4
CAPA_SLAVEDMA		equ	8

;------ Structures ----------------------------------------------------------;
;
; TxStart structure
;
struc           TxStartStruc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_min 	dw	?		; minimum threshold
txs_uTxOK	dw	?		; TxOK low word at last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
ends            TxStartStruc

SIZE_TxStart	equ	SIZE TxStartStruc

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
macro           SelectWindow wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm

;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

FALSE           equ     0
TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
struc           doubleword
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
ends            doubleword

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
struc           farpointer
off             dw      0               ; offset
segm            dw      0               ; segment or selector
ends            farpointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\main.cpp ===
#define STRICT
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include "rbf1\rbf1.h"
//#include "rbf2\rbf2.h"
#include "resource.h"

#define cbMaxSz  4095

TCHAR szString[cbMaxSz];

typedef struct
{
	WORD	Bytes;
	BYTE	ClusterSectors;
	WORD	Reserved;
	BYTE	Fats;
	WORD	Root;
	WORD	Sectors;
	BYTE	Descript;
	WORD	FatSectors;
	WORD	TrackSectors;
	WORD	Heads;
} BPBSTRUCT;

typedef struct
{
	char	Name[8];
	char	Ext[3];
	BYTE	Attribute;
	char	Reserved[10];
	WORD	Time;
	WORD	Date;
	WORD	Cluster;
	long	Size;
} DIRSTRUCT;

void Start (HWND);
void CreateDisk (HWND, int);
int  WriteBootSector (HWND, int);
int  EraseDisk (HANDLE, BPBSTRUCT *);
int  WriteDataFile (HWND, int);
//int  WriteLanguageFile (HWND, int, int);

INT_PTR CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK MainDlgProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AdapterDlgProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK StatusDlgProc (HWND, UINT, WPARAM, LPARAM);

HINSTANCE Inst;
HWND WndMain;
int Language;

ADAPTERINFO *Info;

ADAPTERINFO *GetAdapterList (void);
void  GetBootSector (LPSTR);
DWORD GetBootFile (HANDLE *);

//LANGINFO *GetLanguageList (void);
DWORD GetLanguage (int, HANDLE *);

/*-------------------------------------------------------------------
	WinMain

-------------------------------------------------------------------*/
int PASCAL WinMain (HINSTANCE inst, HINSTANCE h, LPSTR l, int q)
{
MSG  msg ;
WNDCLASS wndclass;
DWORD dw;

	Inst = inst;

	wndclass.style         = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc   = WndProc;
	wndclass.cbClsExtra    = 0;
	wndclass.cbWndExtra    = 0;
	wndclass.hInstance     = inst;
	wndclass.hIcon         = LoadIcon (inst, MAKEINTRESOURCE (1));
	wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
	wndclass.lpszMenuName  = NULL;
	wndclass.lpszClassName = "NTFloppy";

	RegisterClass (&wndclass);

	dw = LoadString(inst, IDS_TITLE, szString, ARRAYSIZE( szString ));
	Assert( dw );
	WndMain = CreateWindow ("NTFloppy", szString,
		WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL, Inst, NULL);

	if (!WndMain)
		return 0;

	ShowWindow (WndMain, SW_SHOW);

	while (GetMessage (&msg, NULL, 0, 0))
	{
    	TranslateMessage (&msg);
    	DispatchMessage (&msg);
    }

	return msg.wParam;

}

/*-------------------------------------------------------------------
	WndProc

-------------------------------------------------------------------*/
LRESULT CALLBACK WndProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
		case WM_CREATE:
			SendMessage (wnd, WM_USER, 0, 0);
			return TRUE;

		case WM_USER:
			Start (wnd);
			DestroyWindow (wnd);
			return 0;

		case WM_DESTROY:
        	PostQuitMessage (0);
        	return 0;

    }

	return DefWindowProc (wnd, msg, wParam, lParam);
}

/*-------------------------------------------------------------------
	Start

-------------------------------------------------------------------*/
void Start (HWND wnd)
{
	TCHAR szBuf[50];
	DWORD dw;

	Info = GetAdapterList ();

	if (Info->Version != 1)
	{
		dw = LoadString(Inst, IDS_INVALIDFILE, szBuf, ARRAYSIZE(szBuf));
		Assert( dw );
		dw = LoadString(Inst, IDS_TITLE, szString, ARRAYSIZE( szString ));
		Assert( dw );
		MessageBox (wnd, szBuf, szString, MB_OK | MB_ICONSTOP);
		return;
	}

	DialogBox (Inst, MAKEINTRESOURCE (1), wnd, MainDlgProc);

}

/*-------------------------------------------------------------------
	MainDlgProc

-------------------------------------------------------------------*/
INT_PTR CALLBACK MainDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
int i;

	switch (msg)
	{
		case WM_INITDIALOG:
			if (GetDriveType ("b:\\") == 1)
				EnableWindow (GetDlgItem (wnd, PB_DRIVEB), FALSE);

			Button_SetCheck (GetDlgItem (wnd, PB_DRIVEA), TRUE);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_ADAPTERS:
					DialogBox (Inst, MAKEINTRESOURCE (10), wnd, AdapterDlgProc);
					return 0;

				case PB_ABOUT:
					DialogBox (Inst, MAKEINTRESOURCE (5), wnd, AboutDlgProc);
					return 0;

				case PB_CREATE:
					i = (Button_GetCheck (GetDlgItem (wnd, PB_DRIVEA))) ? 0:1;
					CreateDisk (wnd, i);
					return 0;

				case PB_CANCEL:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;
}

/*-------------------------------------------------------------------
	AdapterDlgProc

-------------------------------------------------------------------*/
INT_PTR CALLBACK AdapterDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
int i;

	switch (msg)
	{
		case WM_INITDIALOG:
			for (i = 0; i < Info->NICCount; i++)
				ListBox_AddString (GetDlgItem (wnd, 10), Info->NICS[i].Name);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;
}

/*-------------------------------------------------------------------
	AboutDlgProc

-------------------------------------------------------------------*/
INT_PTR CALLBACK AboutDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
TCHAR s[256];
DWORD dw;

	switch (msg)
	{
		case WM_INITDIALOG:
			dw = LoadString(Inst, IDS_DATAVER, s, ARRAYSIZE(s));
			Assert( dw );
			wsprintf (szString, s, Info->DataVersion/256, Info->DataVersion&255);
			SetWindowText (GetDlgItem (wnd, ST_DATAVERSION), szString);

			dw = LoadString(Inst, IDS_VERSION, s, ARRAYSIZE(s));
			Assert( dw );
			SetWindowText (GetDlgItem (wnd, ST_VERSION), s);
			dw = LoadString(Inst, IDS_COPYRIGHT, s, ARRAYSIZE(s));
			Assert( dw );
			SetWindowText (GetDlgItem (wnd, ST_COPYRIGHT), s);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;

}

/*-------------------------------------------------------------------
	CreateDisk

-------------------------------------------------------------------*/
void CreateDisk (HWND wnd, int drive)
{
HWND dlg;

	dlg = CreateDialog (Inst, MAKEINTRESOURCE (20), wnd, StatusDlgProc);

	SetCursor (LoadCursor (NULL, IDC_WAIT));

	if (WriteBootSector (wnd, drive))
	{
		if (WriteDataFile (wnd, drive))
		{
//			if (Language)
//				WriteLanguageFile (wnd, Language, drive);
		}
	}

	DestroyWindow (dlg);
	SetCursor (LoadCursor (NULL, IDC_ARROW));

}

/*-------------------------------------------------------------------
	StatusDlgProc

-------------------------------------------------------------------*/
INT_PTR CALLBACK StatusDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
		case WM_INITDIALOG:
			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;

}

/*-------------------------------------------------------------------
	WriteBootSector

-------------------------------------------------------------------*/
int WriteBootSector (HWND wnd, int drive)
{
char s[256];
TCHAR s1[256];
HANDLE device;
char dataBuffer[512];
LPSTR diskBuffer;
DWORD d;
DWORD dw;

	GetBootSector (dataBuffer);

	lstrcpy (s, "\\\\.\\?:");
	s[4] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (device == INVALID_HANDLE_VALUE)
		return FALSE;

	diskBuffer = (LPSTR)VirtualAlloc (NULL, 512, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	SetFilePointer (device, 0, NULL, FILE_BEGIN);

	if (!ReadFile (device, diskBuffer, 512, &d, NULL))
	{
		d = GetLastError ();
		dw = LoadString(Inst, IDS_ERRFILERD1, s1, ARRAYSIZE(s1));
		Assert( dw );
		wsprintf (szString, s1, d);
		dw = LoadString(Inst, IDS_READ, s1, ARRAYSIZE(s1));
		Assert( dw );
		MessageBox (GetActiveWindow (), szString, s1, MB_OK);
		return FALSE;
	}

	if (*(WORD *)&diskBuffer[510] != 0xAA55)
	{
		dw = LoadString(Inst, IDS_ERRFILERD2, s1, ARRAYSIZE(s1));
		Assert( dw );
		dw = LoadString(Inst, IDS_ERROR, szString, ARRAYSIZE( szString ));
		Assert( dw );
		MessageBox (wnd, s1, szString, MB_ICONSTOP | MB_OK);

		CloseHandle (device);
		VirtualFree (diskBuffer, 0, MEM_RELEASE);
		return FALSE;
	}

	if (memcmp (&diskBuffer[0x0b], &dataBuffer[0x0b], sizeof (BPBSTRUCT)))
	{
		dw = LoadString(Inst, IDS_ERRFORMAT, s1, ARRAYSIZE(s1));
		Assert( dw );
		dw = LoadString(Inst, IDS_ERROR, szString, ARRAYSIZE( szString ));		
		Assert( dw );
		MessageBox (wnd, s1, szString, MB_ICONSTOP | MB_OK);

		CloseHandle (device);
		VirtualFree (diskBuffer, 0, MEM_RELEASE);
		return FALSE;
	}

	memcpy (diskBuffer, dataBuffer, 512);

	SetFilePointer (device, 0, NULL, FILE_BEGIN);

	if (!WriteFile (device, diskBuffer, 512, &d, NULL))
	{
		d = GetLastError ();
		dw = LoadString(Inst, IDS_ERRFILEWR1, s1, ARRAYSIZE(s1));
		Assert( dw );
		wsprintf (szString, s1, d);
		dw = LoadString(Inst, IDS_WRITE, s1, ARRAYSIZE(s1));
		Assert( dw );
		MessageBox (GetActiveWindow (), szString, s1, MB_OK);
		return FALSE;
	}

	EraseDisk (device, (BPBSTRUCT *)&diskBuffer[0x0b]);

	CloseHandle (device);

	VirtualFree (diskBuffer, 0, MEM_RELEASE);

	return TRUE;

}

/*-------------------------------------------------------------------
	EraseDisk

-------------------------------------------------------------------*/
int EraseDisk (HANDLE device, BPBSTRUCT *bpb)
{
int dirSize, fatSize;
HANDLE hFat, hDir;
LPSTR fat, dir;
DWORD d;
DIRSTRUCT *p;

	dirSize = bpb->Root * 32;
	fatSize = bpb->FatSectors * bpb->Bytes;

	hFat = GlobalAlloc (GHND, fatSize);
	fat = (LPSTR)GlobalLock (hFat);

	fat[0] = bpb->Descript;		// copy disk descriptor to FAT
	fat[1] = (BYTE)255;
	fat[2] = (BYTE)255;

	hDir = GlobalAlloc (GHND, dirSize);
	dir = (LPSTR)GlobalLock (hDir);

	p = (DIRSTRUCT *)dir;
	lstrcpy (p->Name, "Lanworks");
	p->Attribute = 8;

	SetFilePointer (device, 512, NULL, FILE_BEGIN);

	WriteFile (device, fat, fatSize, &d, NULL);
	WriteFile (device, fat, fatSize, &d, NULL);

	WriteFile (device, dir, dirSize, &d, NULL);

	GlobalUnlock (hFat);
	GlobalFree (hFat);
	GlobalUnlock (hDir);
	GlobalFree (hDir);

	return TRUE;
}

/*-------------------------------------------------------------------
	WriteDataFile

-------------------------------------------------------------------*/
int WriteDataFile (HWND wnd, int drive)
{
HANDLE h;
LPSTR p;
DWORD len, d;
HANDLE device;
char s[25];

	len = GetBootFile (&h);

	p = (LPSTR)GlobalLock (h);

	lstrcpy (s, " :\\GOLIATH");
	s[0] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile (device, p, len, &d, NULL);

	CloseHandle (device);

	GlobalUnlock (h);
	GlobalFree (h);

	return TRUE;
}

/*-------------------------------------------------------------------
	WriteLanguageFile

-------------------------------------------------------------------*
int WriteLanguageFile (HWND wnd, int x, int drive)
{
HANDLE h;
LPSTR p;
DWORD len, d;
HANDLE device;
char s[25];

	len = GetLanguage (x, &h);

	p = (LPSTR)GlobalLock (h);

	lstrcpy (s, " :\\GOLIATH.DAT");
	s[0] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile (device, p, len, &d, NULL);

	CloseHandle (device);

	GlobalUnlock (h);
	GlobalFree (h);

	return TRUE;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\loader\loader.asm ===
;----------------------------------------------------------------------------
; loader.asm
;
; Loader code for Goliath.  This code is based (a lot) on Microsoft's
; NTLDR as it is loaded by their NT boot sector.
;
;$History: LOADER.ASM $
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 10/08/98   Time: 4:28p
; Updated in $/Client Boot/Goliath/Loader
; Removed startup banner.
; 
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 4:41p
; Updated in $/Client Boot/Goliath/Loader
; Changed displayed version number.
;
;----------------------------------------------------------------------------
ideal
_IDEAL_ = 1

Segment Code para public use16
	Assume	cs:code, ds:code

include "loader.inc"

Struc	NICInfo
	VendorID	dw	?
	DeviceID	dw	?
	Offset		dd	?
	DataSize	dw	?
ends

Struc	UNDIHdr
			dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
	SizeHdr		dw	?
	SizeCode	dw	?
	SizeData	dw	?
	SizeBSS 	dw	?
	LanOption	db	?
ends

FATSEG = 5000h
DIRSEG = 1000h

P386

;START_CODE

;==========================================================================
; LoaderEntry
;
; The first 512 bytes are loaded by the boot sector.  The boot sector
; jumps to the start of this code.  Throughout this code, DS remains
; the boot sector segment to use the BPB and disk read functions in
; the boot sector.
;
; Parameters (passed from boot sector):
;	ax =
;	bx = starting cluster
;	cx = 
;	dx = 
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = 07C0h (boot sector segment)
;	es = 2000h
;
; The directory from the disk is in memory at 1000:0, this code has been
; loaded into 2000:0.
;
; Returns:
;	never does
;==========================================================================
Proc Start

	push	si			; save BPB pointer
	push	di			; save jump table pointer

	push	bx			; save file starting cluster

;	push	si			; save si
;	mov	si, offset Banner
;	call	PrintCS			; display program banner
;	pop	si			; restore si

	;------------------------------------------------------------
	; Read the FAT from the floppy into 5000:0h.
	;------------------------------------------------------------
	push	FATSEG
	pop	es			; es = FAT segment

	xor	bx, bx			; load offset = 0
	mov	cx, [si+3]		; get "reserved sectors" from BPB
	mov	[di+8], cx		; update starting sector to read
	mov	[word ptr di+10], 0
 	mov	ax, [si+0Bh]		; get "FAT sectors" from BPB
	call	[dword ptr di+4]	; call boot sector read function

	mov	ax, 0E2Eh
	int	10h			; print first "."

	pop	dx			; restore file starting cluster

	mov	ax, 2000h
	mov	es, ax			; load segment is 2000h

	call	LoadFile		; load the remainder of this file

	pop	di			; restore jump table pointer
	pop	si			; restore BPB pointer
	jmp	Startup			; contine with remainder of loader

endp

;--------------------------------------------------------------------
; LoadFile
;
; Reads an entire file into memory by walking the FAT on the disk.
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	dx = starting cluster
;	es = destination segment
;--------------------------------------------------------------------
Proc LoadFile

	xor	bx, bx			; load offset = 0

	; Two counters are used, al and ah.  ah is the total number of
	; clusters we can read, it starts at 128 which is 64K of data.
	; al is the number of clusters we want to read.
	mov	ah, 128			; ah = number of clusters we can read

readLoop:
	push	dx			; save cluster number
	mov	al, [si+2]		; get "sectors per cluster"
	sub	ah, [si+2]		; subtract from total
	cmp	dx, 0FFFFh		; last cluster?
	jne	more			; no - more to load
	pop	dx			; clean stack
	jmp	fileLoaded		; we are done - start the file

	; Scan the FAT for the file.  If consecutive clusters are found
	; they are done with a single read call.
more:
	mov	cx, dx			; cx = current cluster
	call	ReadFAT			; get next cluster from FAT
	inc	cx			
	cmp	dx, cx			; consecutive cluster?
	jne	doRead			; no
	cmp	ah, 0			; can we read more at this time?
	jne	loc_4			; sure
	mov	ah, 128			; restore ah = 128
	jmp	doRead

loc_4:
	add	al, [si+2]		; add "sectors per cluster"
	sub	ah, [si+2]		; decrease sectors we can read
	jmp	more			; check next cluster

doRead:
	pop	cx			; get current cluster
	push	dx			; save next cluster value
	mov	dx, cx			; dx = current cluster

	mov	cx, 10			; retry count

readRetry:
	push	bx
	push	ax			; save cluster count
	push	dx			; save cluster number
	push	cx			; save retry counter
	call	[dword ptr di]		; read disk clusters
	jnc	readOK			; jump if no error

	; there was an error reading the disk
	xor	ax, ax
	int	13h			; reset disk
	
	xor	ax, ax			; ax =0
	int	13h			; reset disk
	
	xor	ax, ax			; ax = 0

delay:
	dec	ax
	jnz	delay

	pop	cx
	pop	dx
	pop	ax
	pop	bx
	dec	cx			; decrease retry count
	jnz	readRetry		; jump if retries not up

	mov	si, offset error	; pointer to message
	call	PrintCS			; print error message

	jmp	$			; hang

readOK:
	mov	ax, 0E2Eh
	int	10h			; print second "."

	pop	cx
	pop	dx
	pop	ax
	pop	bx
	pop	dx
	mov	cl, al			; cl = cluster read count
	xor	ch, ch			; ch = 0
	shl	cx, 9			; divide cluster count by 512
	add	bx, cx			; update load offset
	jz	changeSeg		; jump if over segment
	jmp	readLoop			; continue loading file

changeSeg:
	mov	ax, es			; get current segment
	add	ax, 1000h		; change segment
	mov	es, ax
	mov	ah, 80h
	jmp	readLoop		; continue loading file

fileLoaded:
	ret

endp

;--------------------------------------------------------------------
; ReadFAT
;
; Reads a value from the FAT in memory.
;
; Parameters:
;	dx = current cluster
;--------------------------------------------------------------------
Proc ReadFAT

	push	bx			; save bx
	push	ds			; save ds

	push	FATSEG
	pop	ds			; set ds to FAT segment

	; current cluster * 1.5
	mov	bx, dx			; bx = current cluster
	shr	dx, 1			; divide cluster by 2
	pushf				; save flags
	add	bx, dx			;

	mov	dx, [bx]		; get next link
	popf				; restore flags
	jc	loc_12			; Jump if carry Set
	and	dx, 0FFFh		; keep lower 3 nibbles
	jmp	loc_13

loc_12:
	shr	dx, 4			; keep upper 3 nibbles

loc_13:
	cmp	dx, 0FF8h		; "end of file" found?
	jb	readFatExit		; no
	mov	dx, 0FFFFh		; return "end of file"

readFatExit:
	pop	ds			; restore ds
	pop	bx			; restore bx
	ret

endp

;--------------------------------------------------------------------
; PrintCS
;
; Prints a string from the code segment.
;
; Parameters:
;	cs:si - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc PrintCS

	mov	al, [cs:si]		; get character
	inc	si
	or	al, al			; found NULL?
	jz	printDone		; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printCS			; do next character

printDone:
	ret

endp

;Banner	db 'BootWare Goliath Beta 2', 0

Error	db 13, 10
	db 'Goliath: I/O error reading disk', 13, 10
	db '         Please insert another disk', 13, 10, 0

org	510
	dw	offset DataTable	; pointer to data table

;--------------------------------------------------------------------
; Startup
;
; Entry function after entire file has been loaded into memory.
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = bootsector segment
;--------------------------------------------------------------------
Proc Startup

	mov	ax, 0E2Ah
	int	10h			; print "*"

	call	LoadLanguage		; load the language file

	push	cs
	pop	ds			; ds = cs

	jnc	noLang			; jump if no language was loaded

	mov	[Info.LangSeg], es	; save language segment

noLang:
	call	CheckPCI		; check for a PCI adapter
	call	CheckISA

	mov	si, offset CRLF
	call	Print
	mov	si, offset NoAdapter
	call	Print			; display "No adapter found"
	jmp	$			; hang the PC

endp

;--------------------------------------------------------------------
; LoadLanguage
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = bootsector segment
;
; Returns:
;	carry set if file loaded
;	es = language segment
;--------------------------------------------------------------------
Proc LoadLanguage

	xor	bx, bx			; bx = 0					; Zero register
	mov	cx, [si+6]		; get max root directory entries

	push	DIRSEG
	pop	es			; set es to directory segment

	push	ds			; save ds
	push	cs
	pop	ds			; ds = current segment

	push	si
	push	di

scanDirLoop:							
	mov	di, bx			; directory entry offet into di
	push	cx			; save cx
	mov	cx, 11			; file name size
	mov	si, offset LangFile
	repe	cmpsb			; look for file name
	pop	cx			; restore cx
	jz	foundEntry		; jump if found
	add	bx, 20h			; next directory offset
	loop	scanDirLoop		; check next entry

foundEntry:
	pop	di
	pop	si
	pop	ds			; restore original ds
	jcxz	noEntry			; exit if entry not found

	; Calc the segment needed to locate the language file
	; at the very top of memory.
	push	es			; save current es
	push	0
	pop	es			; es = 0

	mov	dx, [es:413h]		; get current memory size
	sub	dx, 4			; keep 4K
	shl	dx, 6			; convert to segment

	pop	es			; restore es
	mov	ax, [es:bx+1Ah]		; get file starting cluster
	push	ax			; save it

	mov	eax, [es:bx+1Ch]	; get file size
	mov	cx, 16
	div	cl			; divide into paragraphs
	inc	al
	xor	ah, ah
	sub	dx, ax			; subtract size from top segment

	mov	es, dx			; es = new segment

	pop	dx			; restore starting cluster
	call	LoadFile

	cmp	[word ptr es:60], 'CP'	; check ID string
	jne	noEntry

	stc				; return carry set - file loaded
	ret

noEntry:
;	mov	si, offset NoLangFile
;	call	PrintCS			; print "Warning: Language file not.."
	clc				; return carry clear - no file loaded
	ret

endp

;--------------------------------------------------------------------
; CheckISA
;
; Parameters:
;	none
;
; Returns:
;	only if no adapter is found
;--------------------------------------------------------------------
include "5x9.asm"

Proc CheckISA

	call	Detect5X9
	jnc	noISA

	mov	ebx, [Offset5X9]          ; source offset
	mov	cx, [Size5X9]             ; file size

	jmp	RelocateUNDI

noISA:
	ret

endp

;--------------------------------------------------------------------
; CheckPCI
;
; Parameters:
;	none
;
; Returns:
;	only if no adapter is found
;--------------------------------------------------------------------
Proc CheckPCI

	mov	ax, 0b101h
	int	1ah			; are we running on a PCI PC?

	cmp	edx, ' ICP'		; did we get PCI?
	je	isPCI			; we have PCI!

	ret

isPCI:
	mov	di, offset NICs
	call	FindPCINIC		; check UNDI table
	jnc	notFound		; not found

	mov	[Info.PCIBusDevFunc], bx
	mov	[Info.VendorID], dx
	mov	[Info.DeviceID], cx

	mov	ebx, [(NICInfo di).Offset]; source offset
	mov	cx, [(NICInfo di).DataSize]; cx = file size

	jmp	RelocateUNDI

notFound:
	ret				; return - no adapter found

endp

;--------------------------------------------------------------------
; FindPCINIC
;
; Look for a PCI adapter in the PCI based on a table of supported
; vendor and device IDs.
;
; Parameters:
;	di - pointer to NIC table
;
; Returns:
;	bx - PCI Bus/Device/Function numbers
;	cx - device ID
;	dx - vendor ID
;	di - pointer to entry in NIC table
;	carry set if adapter found
;--------------------------------------------------------------------
Proc FindPCINIC

findLoop:
	mov	dx, [(NICInfo di).VendorID]; get vendor ID from table
	cmp	dx, 0
	je	endLoop

	mov	cx, [(NICInfo di).DeviceID]; get device ID from table

	mov	si, 0			; Device Index (0-n).
	mov	ax, 0B102h		; find PCI device
	int	1Ah			; try and find PCI device

	jnc	found			; found a device

	add	di, size NICInfo
	jmp	findLoop		; do next device

endLoop:
	clc				; clear carry - not found
	ret

found:
	stc				; set carry - adapter found
	ret

endp

;--------------------------------------------------------------------
; RelocateUNDI
;
; Relocates an UNDI to top of memory.  The UNDI has a header attached
; to the beginning of it.
;
; Parameters:
;	ebx - UNDI offset in file
;	cx - UNDI size
;--------------------------------------------------------------------
Proc RelocateUNDI

	shr	ebx, 4
	mov	ax, cs
	add	bx, ax
	mov	es, bx			; set es to UNDI segment

	cmp	[(UNDIHdr es:0).ID], 'IDNU'; check identifer
	je	gotUNDI

	mov	si, offset _noUNDI
	call	Print
	jmp	$			; hang

gotUNDI:
	push	cx			; save UNDI size

	mov	bx, [Info.LangSeg]	; get segment of language module
	cmp	bx, 0			; do we have an language module?
	jne	notTop			; yes

	; no language module was loaded so determine our segment from
	; top of memory
	push	es
	push	0
	pop	es			; es = 0
	mov	bx, [es:413h]		; get current memory size
	sub	bx, 4			; keep 4K
	shl	bx, 6			; convert to segment
	pop	es

notTop:
	; get the size of the UNDI code and data segment from the header
	mov	ax, [(UNDIHdr es:0).SizeCode]; get UNDI code size
	mov	[Info.UNDICode], ax	; save it to pass to BootWare

	mov	cx, [(UNDIHdr es:0).SizeData]
	add	cx, [(UNDIHdr es:0).SizeBSS]
	mov	[Info.UNDIData], cx	; save total data size
	add	ax, cx			; add UNDI data size to code size

	shr	ax, 4			; divide size into paragraphs
	inc	al			; plus one for remainder
	sub	bx, ax			; subtract from top segment
	mov	[Info.UNDISeg], bx	; save UNDI segment

	pop	cx			; get UNDI size

	push	ds			; save ds
	push	es			; save es

	push	es
	pop	ds			; ds = UNDI current segment
	mov	es, bx			; es = new segment

	; copy UNDI to new segment
	xor	di, di			; destination offset
	mov	si, [(UNDIHdr ds:0).SizeHdr]
	rep	movsb			; relocate the UNDI

	;------------------------------------------------------------
	; Copy adapter ID string into the BootWare module.
	;------------------------------------------------------------
	lea	si, [(UNDIHdr ds:0).LanOption]

	push	cs
	pop	es			; es = our segment

	mov	di, [cs:BWOffset]
	add	di, 4

copyID:
	lodsb
	stosb
	cmp	al, 0			; end of string?
	jne	copyID			; no

	pop	es			; restore es
	pop	ds			; restore ds

	;------------------------------------------------------------
	; Now relocate the BootWare module below the UNDI.
	;------------------------------------------------------------
	mov	si, [BWOffset]
	mov	ax, [si+2]		; get size from module
	shr	ax, 4			; divide by 16
	sub	bx, ax			; subtract from UNDI segment

	mov	es, bx			; es is new segment
	mov	cx, [BWSize]		; get our code size
	mov	si, [BWOffset]
	xor	di, di
	rep	movsb			; relocate our code

	mov	si, offset Info		; get address of LoaderInfo structure

	push	es			; setup continuation address on stack
	push	0

	retf				; jump to relocated BootWare

endp

_noUNDI	db	"UNDI not found.", 0

;--------------------------------------------------------------------
; Print
;
; Prints a string from the code segment.
;
; Parameters:
;	cs:si - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc Print

	push	es			; save ds
	push	bx			; save bx

	cmp	[Info.LangSeg], 0	; did we load a language?
	je	notLang			; no

	mov	bx, [Info.LangSeg]
	mov	es, bx			; set es to language segment

	cmp	si, offset NoAdapter
	jne	notLang
	
	mov	bx, [es:66]		; get address from language module
	cmp	bx, 0			; did we get a pointer?
	je	notLang			; no

	mov	si, bx			; set new pointer
	jmp	printLoop

notLang:
	push	ds
	pop	es			; set es to our segment

printLoop:
	mov	al, [es:si]
	inc	si
	or	al, al			; found NULL?
	jz	done			; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printLoop		; do next character

done:
	pop	bx			; restore bx
	pop	es			; restore ds
	ret

endp

;====================================================================
LangFile	db 'GOLIATH DAT'
CRLF		db 7, 13, 10, 0
;NoLangFile	db 7, 13, 10, "Warning: Language file not found.", 0
NoAdapter	db "Error: No supported adapter found!", 0

Info		LoaderInfo <?>

align 16
DataTable:
BWSize		dw	0		; size of common BootWare module
BWOffset	dw	0		; starting offset of BootWare

Size5X9         dw	0
Offset5X9       dd	0

;	   VendorID, DeviceID, Offset, Size
NICs	NICInfo <>

	db	0

org	2047
	db	0

ends
end Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\rbf1.cpp ===
#include <windows.h>
#include <crtdbg.h>
#include "resource.h"
#include "rbf1.h"

#define NUM_NICS 22
NICINFO NICS[NUM_NICS] = {
	{     0,      0, "3Com 3C509 ISA", 200},
	{0x10B7, 0x9050, "3Com 3C905-TX", 101},
	{0x10B7, 0x9051, "3Com 3C905-T4", 101},
	{0x10B7, 0x9000, "3Com 3C900-TP0", 101},
	{0x10B7, 0x9001, "3Com 3C900-Combo", 101},
	{0x10B7, 0x9004, "3Com 3C900B-TPO", 102},
	{0x10B7, 0x9005, "3Com 3C900B-Combo", 102},
	{0x10B7, 0x9055, "3Com 3C905B-TX", 102},
	{0x10B7, 0x9056, "3Com 3C905B-T4", 102},
	{0x10B7, 0x9058, "3Com 3C905B-Combo", 102},
	{0x10B7, 0x900A, "3Com 3C900B", 102},
	{0x10B7, 0x905A, "3Com 3C905B", 102},
	{0x10B7, 0x9006, "3Com 3C900B-TPC", 102},
	{0x10B8, 0x0005, "SMC 9432", 100},
	{0x8086, 0x1229, "HP DeskDirect 10/100 TX", 103},
	{0x8086, 0x1227, "Intel Pro 100+", 103},
	{0x8086, 0x1226, "Intel Pro 10+", 103},
	{0x8086, 0x1229, "Intel Pro 100B", 103},
	{0x1011, 0x0019, "DEC DE500", 105},
	{0x1011, 0x0014, "SMC 8432", 106},
	{0x1011, 0x0009, "SMC 9332", 107},
	{0x1022, 0x2000, "AMD PCnet", 104},
};

typedef struct
{
	WORD	VendorID;
	WORD	DeviceID;
	DWORD	Offset;
	WORD	DataSize;
} NICTABLE;

typedef struct
{
	WORD	BootWareSize;
	WORD	BootWareOffset;
	WORD	Size5x9;
	DWORD	Offset5x9;
	NICTABLE NICS[16];
} DATATABLE;

ADAPTERINFO Adapters = {1, 0x0100, NUM_NICS, &NICS[0]};

HINSTANCE Inst;

#define DllExport __declspec( dllexport )

DllExport ADAPTERINFO *GetAdapterList (void);
DllExport void GetBootSector (LPSTR);
DllExport DWORD GetBootFile (HANDLE *);

DWORD GetLoader (LPSTR);
DWORD GetBootWare (LPSTR);

/*-------------------------------------------------------------------
	DllMain

-------------------------------------------------------------------*/
BOOL WINAPI DllMain (HINSTANCE inst, DWORD reason, LPVOID p)
{

	if (reason == DLL_PROCESS_ATTACH)
		Inst = inst;

	return TRUE;

}

/*-------------------------------------------------------------------
 GetAdapterList

-------------------------------------------------------------------*/
ADAPTERINFO *GetAdapterList (void)
{
	return &Adapters;
}

/*-------------------------------------------------------------------
	GetBootSector

	Loads the boot sector from resource data.

-------------------------------------------------------------------*/
void GetBootSector (LPSTR p)
{
HGLOBAL h;
LPSTR data;

	h = LoadResource (Inst, FindResource (Inst, MAKEINTRESOURCE (ID_BOOTSECT), MAKEINTRESOURCE (100)));
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	_ASSERTE (data != NULL);

	CopyMemory (p, data, 512);

	UnlockResource (h);

	FreeResource (h);

}

/*-------------------------------------------------------------------
	GetBootFile

-------------------------------------------------------------------*/
DWORD GetBootFile (HANDLE *mem)
{
HGLOBAL h, hMem;
LPSTR data, buffer;
HRSRC res;
DATATABLE *table;
DWORD size, offset, d;
int last = 0, count, i;

	size = 0;
	for (i = 0; i < NUM_NICS; i++)
	{
		if (NICS[i].Resource != last)
		{
			res = FindResource (Inst, MAKEINTRESOURCE (NICS[i].Resource), MAKEINTRESOURCE (500));
			_ASSERTE (res != NULL);
			size += SizeofResource (Inst, res);

			last = NICS[i].Resource;
		}
	}

	// allocate buffer for file
	hMem = GlobalAlloc (GHND, size+32768);
	_ASSERTE (hMem != NULL);
	buffer = (LPSTR)GlobalLock (hMem);

	// add Loader module
	size = GetLoader (buffer);

	// create a pointer to the loader adapter table
	d = *(WORD *)&buffer[510];
	table = (DATATABLE *)&buffer[d];

	offset = size;

	 // add BootWare module
	table->BootWareOffset = (WORD)size;
	size = GetBootWare (&buffer[size]);
	table->BootWareSize = (WORD)size;

	count = 0;
	for (i = 0; i < NUM_NICS; i++)
	{
		if (NICS[i].Resource != last)
		{
			offset += size;

			res = FindResource (Inst, MAKEINTRESOURCE (NICS[i].Resource), MAKEINTRESOURCE (500));
			_ASSERTE (res != NULL);
			h = LoadResource (Inst, res);
			_ASSERTE (h != NULL);

			data = (LPSTR)LockResource (h);
			size = SizeofResource (Inst, res);

			// copy data into buffer
			CopyMemory (&buffer[offset], data, size);

			// free the resource
			UnlockResource (h);
			FreeResource (h);
		}

		if (i == 0)
		{
			table->Offset5x9 = offset;
			table->Size5x9 = (WORD)size;
		}
		else
		{
			// record the starting location and size in the loader table
			table->NICS[count].VendorID = NICS[i].VendorID;
			table->NICS[count].DeviceID = NICS[i].DeviceID;
			table->NICS[count].Offset   = offset;
			table->NICS[count].DataSize = (WORD)size;

			count++;
		}

		last = NICS[i].Resource;
	}

	offset = (offset + size + 1) & 0xfffffffe;

	GlobalUnlock (hMem);

	*mem = hMem;

	return offset;
}

/*-------------------------------------------------------------------
	GetLoader

-------------------------------------------------------------------*/
DWORD GetLoader (LPSTR p)
{
HGLOBAL h;
HRSRC res;
DWORD len;
LPSTR data;

	// get loader.bin from resource data
	res = FindResource (Inst, MAKEINTRESOURCE (ID_LOADER), MAKEINTRESOURCE (100));
	_ASSERTE (res != NULL);
	h = LoadResource (Inst, res);
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	len = SizeofResource (Inst, res);

	// copy loader into buffer
	CopyMemory (p, data, len);

	// free the loader resource
	UnlockResource (h);
	FreeResource (h);

	return len;
}

/*-------------------------------------------------------------------
	GetBootWare

-------------------------------------------------------------------*/
DWORD GetBootWare (LPSTR p)
{
HGLOBAL h;
HRSRC res;
DWORD len;
LPSTR data;

	// get BootWare.bin from resource data
	res = FindResource (Inst, MAKEINTRESOURCE (ID_BOOTWARE), MAKEINTRESOURCE (100));
	_ASSERTE (res != NULL);
	h = LoadResource (Inst, res);
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	len = SizeofResource (Inst, res);

	// copy loader into buffer
	CopyMemory (p, data, len);

	// free the loader resource
	UnlockResource (h);
	FreeResource (h);

	// return length of data
	return len;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\rbf2.h ===
struct LANGINFO
{
	PSTR	Name;
	int		Resource;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RBF2.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\genmacro.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/GENMACRO.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Generic macros used by all Speedo3 ASM driver
;

IFDEF            GENMACRO_INC
ELSE
GENMACRO_INC     equ       1

;--------------------------------------------------------------------------
; Small/quick way to set a register to NULL, all F's (avoid 32-bit constants).
;--------------------------------------------------------------------------
@NULLPTR macro reg
    xor     reg, reg
    dec     reg
    ENDM

;--------------------------------------------------------------------------
; Port I/O macros
;--------------------------------------------------------------------------
;- 32-bit Output
@OUTPD     MACRO    portid, low, high
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    push   high
    push   low
    pop    eax
    out    dx, eax
.SALL
    ENDM

;- 16-bit Output
@OUTPW     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    ax, value
ENDIF
    out    dx, ax
.SALL
    ENDM

;- 8-bit Output
@OUTPB     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    al, value
ENDIF
    out    dx, al
.SALL
    ENDM

;- 32-bit Input
@INPD      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     eax, dx
.SALL
    ENDM

;- 16-bit Input
@INPW      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     ax, dx
.SALL
    ENDM

;- 8-bit Input
@INPB      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     al, dx
.SALL
    ENDM

;--------------------------------------------------------------------------
; Macro @POPF (DESTROYS AX!!!)                   v1.6
;--------------------------------------------------------------------------
@POPF MACRO                                      
    pop     ax      
    test    ax, 200H
    jz      @F      
    sti                
@@:
    ENDM

;--------------------------------------------------------------------------
; FASTCOPY
; Macro to perform fast DWORD memory copy
; Handles data transfers that are not multiples of 4
;--------------------------------------------------------------------------
@FASTCOPY  MACRO
.XALL
    push   cx
    shr    cx, 2
    rep    movsd
    pop    cx
    and    cx, 3
    rep    movsb
.SALL
    ENDM

;--------------------------------------------------------------------------
; REALLY_FASTCOPY
; Macro to perform fast DWORD memory copy, optimized by processor type.
; Handles data transfers that are not multiples of 4, or not dword-aligned.
;
; Each time REALLY_FASTCOPY is invoked, make sure that:
;  - pass macro value returned by "GetCpuType" (=PENTIUM_CPU does special move)
;  - CX has length
;  - ES:EDI points to destination (must clear upper 16 bits under DOS, OS/2)
;  - DS:ESI points to source      (must clear upper 16 bits under DOS, OS/2)
;--------------------------------------------------------------------------
@REALLY_FASTCOPY  MACRO CpuTypeValue
    local   CopyDword, RepCopy, CopyRemainder, CopyByte, Exit
    push    ax                                             ; v1.04
    push    dx                                             ; v1.04

    mov     dx, cx
    cmp     dx, 4
    jb      CopyRemainder

;--------------------------------------------------
;  Align destination to dword boundary
;--------------------------------------------------
    movsd
    sub     dx, 4

    mov     ax, di
    and     ax, 00003h
    sub     di, ax
    sub     si, ax
    add     dx, ax

    cmp     CpuTypeValue, PENTIUM_CPU                      ; v1.04
    jb      RepCopy

;-------------------------------------------------
; Do Pentium Optimized Block Copy
;-------------------------------------------------
    mov     ax, dx
    shr     ax, 2
    jz      CopyRemainder

CopyDword:
    movsd
    dec     ax
    jnz     CopyDword
    jmp     CopyRemainder

;-------------------------------------------------
; Do i386 and i486 Optimized Block Copy
;-------------------------------------------------
RepCopy:
    mov     cx, dx
    shr     cx, 2
    rep     movsd

;------------------------------------------------
; Copy any remaining bytes
;------------------------------------------------
CopyRemainder:
    mov     ax, dx
    and     ax, 00003h
    jz      Exit

CopyByte:
    movsb
    dec     ax
    jnz     CopyByte

Exit:
    pop     dx                                             ; v1.04
    pop     ax                                             ; v1.04
    ENDM

;--------------------------------------------------------------------------
; SLOW
; Macro to delay execution
; Processor speed independent. Executes an I/O to the keyboard port.  We
; use port 61h and not port 60h, because polling 60h can cause the
; "crazy mouse" problem under windows.
;--------------------------------------------------------------------------
@SLOW      MACRO
.XALL
    push   ax
    in     al,61h
    pop    ax
.SALL
    ENDM

;--------------------------------------------------------------------------
; READ_TICK_COUNTER
; This macro reads the 16-bit Timer Tick Count register 
; (8254 System Board Timer 0).
; The count register decrements by 2 (even numbers) every 838ns.
;
; Entry:    Interrupts disabled
;
; Exit:     AX with the current count
;           Interrupts disabled
;--------------------------------------------------------------------------
@READ_TICK_COUNTER     MACRO
;- Setup 8254 To Latch T0's Current Count
    xor     al, al
    out     43h, al
;- Read The Latched Counter Value, LSB First and MSB Next
    in      al, 40h
    mov     ah, al
    in      al, 40h
;- Swap The Counter Bytes To Correct Format
    xchg    al, ah
    ENDM


;--------------------------------------------------------------------------
; DELAY 
; This macro inserts a delay of specified milliseconds. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@DELAY MACRO MSEC
    local   Delay_Loop

    @READ_TICK_COUNTER
    mov     cx, ax
Delay_Loop:
    @READ_TICK_COUNTER
    neg     ax
    add     ax, cx
    cmp     ax, MSEC
    jb      Delay_Loop
    ENDM

;--------------------------------------------------------------------------
; INC32  
; This macro increments a 32 bit counter. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@INC32      MACRO     num32
    add     word ptr num32[0], 1
    adc     word ptr num32[2], 0
    ENDM

;--------------------------------------------------------------------------
; @FATAL
;
; Description : Macro to Halt execution (TRAP) in case of Fatal error
;
; Entry       : none
;
; Exit        : none
;--------------------------------------------------------------------------
@FATAL     MACRO 
    int 3
    ENDM

;--------------------------------------------------------------------------
; @INT3BP
;
; Description : inserts an INT 3 in way that is easy to find with an editor.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@INT3BP macro
    Int    3
endm


;--------------------------------------------------------------------------
; @BP_IFDEBUG
; Description : inserts an INT 3 instruction if debug switch has been set.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@BP_IFDEBUG macro
IF  DEBUG_BP
    @INT3BP
ENDIF    
endm

ENDIF


; EOF - $Workfile:   genmacro.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\buildcfg.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/BUILDCFG.INV   1.2   19 Sep 1997 21:39:16   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Compilation Switches used to build NDIS DOS, OS/2 driver
;

;
;   Description      :    Compilation Switches used to build the NDIS DOS
;                         and OS2 drivers.   Controls version numbers,
;                         default values for parameters, debug inclusion.
;
;                         This file will be included in all of the NDIS
;                         driver source files. Any changes to this file must
;                         (through makefile) force a complete remake of the
;                         entire driver.

.386

TRUE        Equ  1
FALSE       Equ  0


Ifndef DOS
DOSNDIS         Equ     FALSE
OS2NDIS         Equ     TRUE
Else
DOSNDIS         Equ     TRUE
OS2NDIS         Equ     FALSE
Endif

OS2             Equ     OS2NDIS
DOS             Equ     DOSNDIS

;- Switch to enable debug breakpoints (int 3)
DEBUG_BP             equ         FALSE

;- Switch to enable Early Receive Code
EARLY_RCV            equ         FALSE

;- Switch to enable Code Profiling
CODE_PROFILE         equ         FALSE

StratStack           equ         TRUE

;- when transmitter hangs, when should we reset?
TRANSMIT_TIMEOUT Equ     2

;- Interval (in seconds) between successive reads of SCB statistics
UPDATE_STATS_INTERVAL    equ     4

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.

;- Number Of Multicast Addresses Supported By This Driver
MAX_MULTICAST_ADDRESSES  equ     20

;- Optional data area in TCB for Flexible mode
TXCB_BUFFER_SIZE         equ     60

;- Transmit buffer size is max Eth Size (not incl. CRC) plus slop to 1536
TCB_SLOP                 equ     22
TCB_BUFFER_SIZE          equ     MAX_PACKET+TCB_SLOP

;- Receive buffer size is max Eth size plus CRC plus slop to 1536
RCB_SLOP                 equ     22
RCB_BUFFER_SIZE          equ     MAX_PACKET+RCB_SLOP

;- minimum number of Tx buffers and/or Rx buffers allowed to run driver.
MIN_TXRX_BUF_CTS         equ     2

;- Interframe Spacing 96 Tx Clocks
IFS_SPACING              equ     60h

;- Slot Time 512 Tx Clocks
SLOT_TIME                equ     200h

;- Default CUSTOM parameter values
DEFAULT_TXFIFO           equ     8
DEFAULT_RXFIFO           equ     8
DEFAULT_LINE_SPEED       equ     100
DEFAULT_ADAPTIVE_IFS     equ     0
DEFAULT_TXTHRESHOLD      equ     32
DEFAULT_FORCEFDX         equ     0
DEFAULT_IOMAPMODE        equ     0
DEFAULT_TXDMACOUNT       equ     0
DEFAULT_RXDMACOUNT       equ     0
DEFAULT_PHYADDRESS       equ     0FFh
DEFAULT_FRAME_GAP equ 6
FRAME_GAP_MIN equ  6
FRAME_GAP_MAX equ  15

IF DOS
DEFAULT_TXBUF_COUNT      equ     4
DEFAULT_RXBUF_COUNT      equ     8               ; v40
ENDIF

DEFAULT_CONGENB          equ     0               ; v0.49

USE_DEFAULT_VALUE        equ     (-1)

DEFAULT_MCWA_EventCount  equ     6               ; v44

;- used by timer tick interrupt routine to count out one second
TICKS_PER_SECOND         equ     18



;- this indicates the offset to add to get to the '$' in the driver name
;  '0123456789'
;  'E100B$'
DOLLAR_OFFSET            equ     5               ; v0.38

; TRANSMIT_CHECK equ 1


; EOF - $Workfile:   buildcfg.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\rbf2.cpp ===
#include <windows.h>
#include "rbf2.h"

#define NUM_LANG 2
LANGINFO Languages[NUM_LANG] = {
	{"English", 1},
	{"French",  2}};

HINSTANCE Inst;

#define DllExport __declspec( dllexport )

DllExport LANGINFO *GetLanguageList (void);
DllExport DWORD GetLanguage (int, HANDLE *);

/*-------------------------------------------------------------------
	DllMain

-------------------------------------------------------------------*/
BOOL WINAPI DllMain (HINSTANCE inst, DWORD reason, LPVOID p)
{

	if (reason == DLL_PROCESS_ATTACH)
		Inst = inst;

	return TRUE;

}

/*-------------------------------------------------------------------
 GetAdapterList

-------------------------------------------------------------------*/
LANGINFO *GetLanguageList (void)
{
	return &Languages[0];
}

/*-------------------------------------------------------------------
	GetLanguage

-------------------------------------------------------------------*/
DWORD GetLanguage (int index, HANDLE *mem)
{
HGLOBAL h, hMem;
LPSTR data;
HRSRC res;
DWORD size;
LPSTR p;

	if (index >= NUM_LANG)
		return 0;

	res = FindResource (Inst, MAKEINTRESOURCE (Languages[index].Resource), MAKEINTRESOURCE (100));
	if (res == 0)
		return 0;

	h = LoadResource (Inst, res);

	data = (LPSTR)LockResource (h);
	size = SizeofResource (Inst, res);

	hMem = GlobalAlloc (GHND, size);
	p = (LPSTR)GlobalLock (hMem);

	CopyMemory (p, data, size);

	GlobalUnlock (hMem);

	*mem = hMem;

	UnlockResource (h);
	FreeResource (h);

	return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\nad5x9.asm ===
title	BootWare Boot PROM (C) Lanworks Technologies Inc.
	subttl	3C5x9 EtherLink III
	page	80,132

;************************************************************************
;* NAD5x9.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3Com 5x9 family
;*
;* Modules included:-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: 98
;************************************************************************


;====================================================================
;  5X9NAD.ASM - produces 3Com 3C5X9 EtherLink III version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1997 All rights reserved.
;
;  Revision History - version numbers refer to 5X9.ASM changes only
;
;
;  970213 3.00  GY - combine CPYPAGE.ASM into this file
;		   - take out check for 286 machine
;  950318 1.71  GY - In NADTransmitPacket, error message pointer is incorrect
;  950123 1.71  GY - take out PIPXDataLen
;  950113 1.71  GY - Clean up RxPIO as suggested by JJ
;  940109 1.71  GY - Release v1.71 which is a patched version of v1.70.
;		     Changes:
;			1. RAMSegment = 5000h not 6000h for Pentium support
;			2. version/date chaged to v1.71 940109
;  941214 1.73  GY - CliBufferSize changed from 64 to 128 bytes. Allow
;		     us to store the whole BootWareTable
;  941213 1.72  GY - Change PEROM so that when BootWareTable is updated, 
;		     both page0 and page1 are updated.
;  941107 1.70  GY - Release version 1.70
;				   - (5X9CONF) BootP -> BOOTP 
;  941104 1.70  GY - In DriverISR when a ISR_IntRequest is found, we
; 		     Acknowledge interrupt and leave ISR. Previously, we
;		     stay in ISR and check if there is any other interrupt
;		     triggered. Solve problem where in some machines with V2,
;		     machine would hung at MSD: after continuous rebooting
;		     for a while (Gateway 486/66 and PS2/E)
;  941007 1.70  GY - For V2, strongly discourage them from using 8/16K ROMSize
;		     In Autoscan, if 8K/16K ROMSize is detected, dump err
;			msg and disable config. menu and ROMShield
;		     In ELNK3CONF, if user choose 8/16K, warn them but still
;			let them change
;  940923 1.66  GY - shrink code
;		   - see 5X9CONF
;		   - PEROMSDP didn't set romPage back to Page0. Cause a 
;		     problem with V2 boot (ROMShield on wrong page)
;		   - replace PEROMSDP with PEROM and AccessPEROM so that
;		     we can write data to Atmel, read/verify Product
; 		     Identification and enable SDP of Atmel
;		   - create EESoft2BWT and BWT2EESoft so that for V2 and
;		     Atmel PEROM, we fetch/save data to PEROM rather than
;		     to NIC EEPROM.
;		   - When ROMBase is changed, need to change ROMShield
;		     Int 13 pointer so that machine doesn't hang.
;		
;  940824 1.61  GY - Integrate McAfee ROMShield into 3C5X9.
;*		     Comments:
;*		     : ROMSH_19, ROMSH_AS are placed on 1st page
;*		     : ROMSH_13 is placed on 2nd page. Code is executed from
;*			ROM and because of the 800h header, all offsets on
;*			2nd page are off by 800hh.
;* 940629 1.60	GY - When a V2 is detected and ROMSize is NOT 8K, enable
;*		     PEROM data protection.
;* 940628 1.60	GY - When Ethernet_802.2U is detected, display message
;*		     to inform user. Press <ENTER> will enter ELNK3CONF
;*		     or wait 8s to boot 802.2
;* 940426 1.52	GY - Add support for OS/2 NetWare boot.
;*		     (CPYPAGE) ROM is moved 32K higher
;*		     (NWNID) BWAPI table, add pointer to NetworkSend,
;*			     ServerAddressTable. All NID calls are far
;*		     (5X9NAD) NAD calls are far routines
;* 940425 1.51	GY - (CPYPAGE) For V2 and virtual paging being used, need to
;*		     support Paging because ROM only appear in 16K window.
;*		     Add variable ASICVersion to distinguish V1 & V2.
;*		     (ROMTOP) Make sure 1st page of ROM is mapped.
;* 940413 1.51	GY - (ROMTOP) change Init_Vulcan so that it will work on
;*		     systems with PnP BIOS, non-PnP PROM (this one) and
;*		     non-PnP OS. Change:
;*		     : Init_Vulcan, use the IOBase I fetch from EEPROM word 8
;*		       and use it to activate the adapter
;*		     : Init_Vulcan, use IRQ from EEPROM word 9 and ignore
;*		       the one from Window 0. Write RCR to IOPort.
;* 940328 1.51	GY - CallBWAPI uses RET 2 rather than RET.
;*		   - Link with new BPCODE.INC for additional features on
;*		     TCP/IP.
;* 940324 1.51	GY - (5X9CONF) Fix problem with Farallon EtherWave
;*		     in InitSpecCase.
;  940314 1.50  GY - First release 
;   		    - Add BootWare Configuration Utility which allows users
;		      to change the configuration of the EtherLink III
;		      adapter (IOBase, IRQ, ROM Setting, Media, Driver Opti,
;		      Modem Speed) and the Boot Protocol Setting of BootWare
;		    - Support ISA, EISA, MCA 509
;		    - Autoconfigure IOBase and ROMBase setting if conflict 
;		      detected
;		    - Under Novell NetWare, default image file ELNK3.SYS
;		      is added in addition to NET$DOS.SYS.
;		    - Wildcard character (?) for network number and node
;		      address in BOOTCONF.SYS is supported
;		    - Support for NetWare, RPL and BootP is included in
;		      this BootWare. 
;  		    - By default, BootProt is UNINIT ( assume 802.2 ). Once
;		      Bootware is used to save any setting, BootProt will
;		      become 802.2, 802.3, II, RPL or TCPIP. 
;		    - change the way ROMSize of 8/16k is supported
;		      Scheme - : ROMTOP on every page
;				 ROMTOP will contain Init_Vulcan and code to
;				   expand ROM into 32k
;			       : ROMTOP for Page 0
;				 hook into Int C0 and C1 and replace with
;				   ISRRomSize which "shrink" PROM back to its
;				   original size
;				 Copy last 24k of PROM into RAM. Make sure
;				   that the ROMTOP portions of page1,2,3 are
;				   skipped
;			       : HookConfig
;				 Call ISRRomSize to shrink PROM back to
;				   8/16k
;====================================================================

ACR_MEDIA	equ	0c000h


SUCCESSFUL		    EQU	0000h

TRANSMIT_ERROR		EQU	000bh


SlaveEOIPort        EQU 0A0h

MasterEOIPort       EQU 20h



CR	equ	0Dh
LF	equ	0Ah
COMMONCODE	equ	0380h	; amount of memory allocated to ROMTOP Common Code

;-------------------------------------
; Include all general companion files
;-------------------------------------

;	include \rom\sdk\include\drvseg.inc
;	include \rom\sdk\include\bwnad.inc
;	include ..\cui.ext
	include     vulcan.inc


include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	spdosegs.inc


_TEXT	Segment para public

	assume	cs:CGroup, ds:DGroup


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADInitiateDiags 
public  NADSetMACAddress


public  OrgIntVector_OFF  
public  OrgIntVector_SEG  


ifdef HARD_INT
    public	NADRequestINT
endif

public	NADMCastChange
public	DriverISR_Proc

extrn	GetED:near
extrn	PostED:near
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	UNDI_DriverISR:far
extrn	IOBase:word
extrn	IRQNumber:byte
;extern GenIntCallBack:dword
;extern RxCallback:dword
extrn EDListHead:word
extrn EDListTail:word
;extern IntReqPending:byte




extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word


; definition for BWTADDRRES
;;BWTTCPBOOTP	equ	1
;;BWTTCPDHCP	equ	4

public		LanOption
public		NADDescription

public	NADDisengage
				; for CUI...
public	ErrConfSpace

public	MemBase
public	WaitEEBusy

public	AConfig_Value
	
;-----------------------------------
; External Data/Variable References
;-----------------------------------

	extrn	IOBase:word		; ROMTOP.ASM

	extrn	BusType:byte		; ROMTOP.ASM

	
;;	extrn	ErrIRQ7:byte		; 5X9CONF.ASM


	
;;	extrn	StartTime:near		; NWNID.ASM
;;	extrn	CheckTime:near		; NWNID.ASM


; enable mask for all BootWare-supported interrupts

BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_TXCOMPLETE + INT_REQUESTED
;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
ReverseAttr	equ	070h		; Attribute for reverse video
NormalAttr	equ	07h		; attribute for normal video

	.386


;	include \rom\sdk\include\bwnadapi.asm



;--------------------------------------------------------------------
; NADInit
;
; Initializes the network adapter 
; 
;
;
; Parameters:
;	dx - screen location for message
;	ax - PCI adapter ID
;	ds - RAM segment
;	es - ROM base
;
; Returns:
;	ax = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------

NADInit	proc	near

        push    es

		push	ds
		pop	es

		sti

		; Copy rest of ROM into RAM. For V2, need to switch page

;;        int     03
		call	FindIOBase
		mov	    DGroup:IOBase, ax

		call	BringUp

		call	Init_Vulcan
		call	Init_hw


		mov	    si, COMMONCODE + 04000h

		mov	    dx, ax
       	mov	    al, EE_CAPABILITIES
       	call	ReadEE

       	test	ax, CAPA_PNP
		jz	CpyPage

		or	DGroup:Modebits, ModeV2

		; switch to Page 1 
		mov	dx, IOBase
		add	dx, PORT_CmdStatus
	
		SelectWindow WNO_FIFO			  ; switch to window 3
		add	dx, PORT_RomControl - PORT_CmdStatus
		in	ax, dx
		and	ax, ROMPageMask 		; clear last 2 bits
		or	ax, RomPage1			; choose Page1
		out	dx, ax

		add	dx, PORT_CmdStatus - PORT_RomControl
		SelectWindow WNO_SETUP

IFNDEF  	TSR
		; verify if ROM is Atmel PEROM. modebits.MODEATMEL will be 
		; set accordingly
;;		mov	cx, 3
;;		call	PEROM
		
		; enable Software Data Production
;;		mov	cx, 1
;;		call	PEROM
		
ENDIF		

		mov	si, COMMONCODE

CpyPage:	; copy last 16K of code

;;;		push	ds
;;;		mov	ds, ROMBase
;;;		mov	di, 04000h
;;;		mov	cx, 04000h-COMMONCODE
;;;		rep	movsb
;;;		pop	ds

		; Make sure Page0 is mapped. DX still points to PortCmdStatus
;;		mov	cx, 0
;;		call	AccessPEROM

		call	Init_Vulcan			; init vulcan hardware and
				  		      	;  variables


		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	al, EE_CWORD
		call	ReadEEPROM

        pop     es

;        jmp short NADInitExit   ; !!!!!!!!!!!!

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel
        
        stc
;;		mov	ax, offset DGroup:StrFailLevel
		jmp	NADInitErrExit

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	NADInitExit
        stc

NADInitErrExit:	
                xor ax, ax
                ret

NADInitExit:clc	
            xor	ax, ax
    		ret

NADInit	endp



;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:	DS = DataSeg
;
; Returns:
;=========================================================================
NADReset	proc	near


;;		call	Init_Vulcan2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters
        clc            
    
    	ret

NADReset	endp



;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near


	call	NADDisengage	; stop adapter, unhook ISR


	ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near


; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

        clc

		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near


		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx
        clc
    	ret

NADClose	endp



NADInitiateDiags    proc    near
;;    stc
    clc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp



;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;
; check whether our board caused the interrupt
;


		pushf
		call	BootISR 	; (BWAMD.INC)
        sti
		ret

DriverISR_Proc	endp

;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:
;=========================================================================
NADSetFilter	proc	near

;;		SelectWindow WNO_SETUP
		push	ax
		mov	dx, DGroup:PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

;db  0f1h
		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	DGroup:HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
;;		SelectWindow WNO_OPERATING
        clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

;int 03        

		push	dx
; more code here

		pop	dx
;;        stc
        clc
		ret

NADGetStatistics	endp


ifdef HARD_INT


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Returns:
;=========================================================================
NADRequestINT	proc	near


;		sti
		ret



NADRequestINT	endp


endif



;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		or 	ax, ax
		jz	UseSavedList

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
UseSavedList:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		ret

NADMCastChange	endp




;--------------------------------------------------------------------
;
;   Init_Vulcan: Initializes NIC variables and enable NIC hardware (txmitter,
;		 receiver, ...)
;
;   On Entry:
;	Assume set to window 0
;
;   On Exit:
;      ax  = 0, init successful
;	   = offset of an error message indicating type of error
;
;	Initialization code is split into 3 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------

Init_Vulcan	proc	near

		; setup all ports
		mov	ax, DGroup:IOBase
		mov	di, offset DGroup:PortCmdStatus
		mov	cx, 7
		rep	stosw
	
		mov	di, offset DGroup:PortCmdStatus
		add	word ptr [di], PORT_CmdStatus
		add	word ptr [di+2], PORT_TxFree
		add	word ptr [di+4], PORT_TxSTatus
		add	word ptr [di+6], PORT_Timer
		add	word ptr [di+8], PORT_RxStatus
		add	word ptr [di+14], PORT_RxFree

		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

; read OEM node address and software config from EEPROM

;         	mov	ax, ds
;         	mov    es, ax
;         	assume es:CGroup
         
                mov    di, offset DGroup:Net_Address
         
                mov    al, EE_OEM_NODE_ADDR_WORD0
                call   ReadEEProm		; read word 0 of node addr
                xchg   ah, al
                stosw
         
                mov    al, EE_OEM_NODE_ADDR_WORD1
                call   ReadEEProm		; read word 1 of node addr
                xchg   ah, al
                stosw
         
                mov    al, EE_OEM_NODE_ADDR_WORD2
                call   ReadEEProm		; read word 2 of node addr
                xchg   ah, al
                stosw


        		mov	    si, offset DGroup:Net_Address
        		mov	    di, offset DGroup:Node_Address
        		movsw
        		movsw
        		movsw


                mov    al, EE_SOFTWARE_CONFIG_INFO
                call   ReadEEProm
                mov    DGroup:EESoftConfigInfo, ax	; save it for later use
         
                mov    al, EE_CWORD
                call   ReadEEProm
                mov    DGroup:Cword, ax
         
         	    mov	    al, EE_CAPABILITIES
             	call	ReadEEProm
             	mov	    DGroup:EECapabilities, ax
         

         	; find out what AConfig_Value and RConfig_Value are
             	add    dx, ( PORT_CfgAddress - PORT_CmdStatus )
         						 ; address configuration reg
             	in     ax, dx
             	mov    DGroup:AConfig_Value, ax		  ; save it
         
         	; Fetch RCR from EEPROM rather than PnP. Write EEPROM RCR
         	; to IOPort to force card to use EEPROM RCR.
						 ; resource configuration reg
             	add    dx, ( PORT_CfgResource - PORT_CfgAddress )
             	in     ax, dx
             	mov    DGroup:RConfig_Value, ax		  ; save it
         
		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		mov    ax, 0
		ret

Init_Vulcan	endp

;--------------------------------------------------------------------
;
;   Init_hw: enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;	dx = IOBase
;
;   On Exit:
;      ax  = 0, init successful
;	   = offset of an error message indicating type of error
;
;	Initialization code is split into 3 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------
Init_hw		proc	near

		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		mov    ax, DGroup:RConfig_Value
		and    ax, RCONFIG_IRQ			 ; strip out the IRQ level
		rol    ax, 4
		mov    DGroup:IRQNumber, al			 ; save it
		call   SetInterruptVector

;------------------------------------------------------------------------------
; initialize Vulcan hardware, driver variables & tables

		call   init_vulcan_hw		; initialize Vulcan hardware

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver

       mov    dx, DGroup:Int_mask_port
       in     al, dx

       and    al, DGroup:IntMaskOnBit
       jmp    $+2

       out    dx, al

       cmp    dx, MASTER_MASK_PORT		 ; are we using IRQ from slave?
       je     turn_on_tx_rx			 ; no

       in     al, MASTER_MASK_PORT		 ; yes, turn on cascaded input
       and    al, not 04			 ;  on master 8259
       out    21h, al

turn_on_tx_rx:

; setup TxStartThreshold, RxEarlyThreshold, RxFilter

		mov    dx, DGroup:PortCmdStatus

		mov    ax, DGroup:CurTxStart
		out    dx, ax

		mov    ax, CMD_SETRXEARLY+RXEARLY_DISABLED ; early threshold = 2032 (off)
		out    dx, ax				 ;  too many runt packets

		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL ; ---no bcasts for BootWare!
		out    dx, ax
		mov    DGroup:HWFilter, ax

		mov    ax, CMD_SETINTMASK + BOOTWARE_INTS ; all BootWare-supported ints on
		out    dx, ax

		mov     ah, CMDH_TXENABLE
		out     dx, ax

		mov     ah, CMDH_RXENABLE
		out     dx, ax

		SelectWindow WNO_SETUP

		mov    ax, 0
		ret
Init_hw		endp

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------


SetInterruptVector proc near

;;	assume	ds:CGroup, es:CGroup

	push	es

;--------------------------------------------------------------------
; determine the mask value for the selected IRQ level

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    DGroup:IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    DGroup:IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr DGroup:int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetInt1
       mov    word ptr DGroup:int_mask_port, SLAVE_MASK_PORT
SetInt1:

;--------------------------------------------------------------------
; determine EOI values for both master and slave 8259

       mov    al, DGroup:IRQNumber
       cmp    al, 8				 ; IRQ on slave?
       jae    SetInt2				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetInt2:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    DGroup:eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave

;--------------------------------------------------------------------
; save and remap IRQ vector

; convert IRQ to interrupt vector number

       mov    al, DGroup:IRQNumber		    ; al = IRQ level
       mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
       cmp    al, 8
       jb     SetInt3

       mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
SetInt3:
       add    al, ah			    ; al = int vector number
       cli

; save old interrupt vector

	xor	bx, bx
	mov	es, bx			; ES = 0
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	les	bx, es:[bx]

;;    mov    DGroup:OldInterrupt.loword, bx
;;    mov    DGroup:OldInterrupt.hiword, es

	mov	DGroup:OrgIntVector_OFF,bx ; old interrupt pointer is stored in
	mov	DGroup:OrgIntVector_SEG,es ; this variable

; remap int vector to our DriverISR

	mov	dx, offset CGroup:UNDI_DriverISR
	xor	di, di
	mov	es, di			; ES = 0
	cbw
	mov	di, ax
	shl	di, 1
	shl	di, 1

	mov	DGroup:IntVectorAddress, di

	mov	ax, dx
	stosw
	mov	ax, cs
	stosw

;970227 mov RemapInt, YES		 ; indicate vector remapped 
	pop	es

       sti
       ret

SetInterruptVector endp

;--------------------------------------------------------------------
;   init_vulcan_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine, since we need to compute some
;		     timing-sensitive variables (ex. TxCopyCli & RxCopyCli).
;		     system DMA channel is also initialized if specified.
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQNumber
;			3. DMAChannel	 - if ff, no DMA specified.
;			4. RConfig_Value - content of Resource Config Reg
;			5. AConfig_Value - content of Address Config Reg
;			6. NIDNetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;--------------------------------------------------------------------

		   public    init_vulcan_hw
init_vulcan_hw	   proc      near



;--------------------------------------------------------------------
; enable INT & DRQ drivers.  since we need to use timer to time events, so this
; command must be done before we intend to do timing measurements.

       mov    dx, DGroup:IOBase
       add    dx, PORT_CfgControl
       mov    ax, 01				 ; EnableAdapter
       out    dx, ax

;--------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.

       add    dx, (PORT_CmdStatus - PORT_CfgControl)
       mov    ax, CMD_SELECTWINDOW+WNO_STATIONADDRESS	   ; window 2
       out    dx, ax				 ; switch to window 2

       mov    si, offset DGroup:Net_Address

       sub    dx, PORT_CmdStatus-PORT_SA0_1	 ; dx = port addr 5, 4
       lodsw
       out    dx, ax

       add    dx, 2				 ; dx = port addr 3, 2
       lodsw
       out    dx, ax

       add    dx, 2				 ; dx = port addr 1, 0 = IO base
       lodsw
       out    dx, ax

; do not enable SQE statistics collection; BootWare doesn't keep stats
	   mov	  dx, DGroup:PortCmdStatus
       mov    ax, CMD_SELECTWINDOW+WNO_DIAGNOSTICS
       out    dx, ax				 ; switch to window 4

       add    dx, PORT_MediaStatus-PORT_CmdStatus
       in     ax, dx

						 ; 04-01-92
       test   DGroup:AConfig_Value, ACONFIG_XCVR	 ; bit<15,14>=00, if TP
       jnz    Init1				 ;
						 ;
       or     ax, MEDIA_JABBERENABLE		 ;
						 ;
       test   DGroup:EESoftConfigInfo, SW_LINKBEAT	 ;
       jnz    Init1				 ;
						 ;
       or     ax, MEDIA_LBEATENABLE		 ;
Init1:						 ; 04-01-92

       out    dx, ax

       add    dx, PORT_CmdStatus-PORT_MediaStatus
       mov    ax, CMD_SELECTWINDOW+WNO_OPERATING ; window 1
       out    dx, ax				 ; switch to window 1

;--------------------------------------------------------------------
; configure Ethernet Core.  this piece of code sets up operational features
; required to run the adapter properly. (in window 1)

       mov    ax, CMD_SETRZMASK+MASK_NONE
       out    dx, ax

; just enable request int bit during configuration of Ethernet Core.

       mov    ax, CMD_SETINTMASK+(INT_LATCH+INT_REQUESTED)
       out    dx, ax				 ; unmask request int bit
       cli

; mask off int channel on 8259

       mov    dx, DGroup:int_mask_port
       in     al, dx

       or     al, DGroup:IRQBit			 ; read 8259's mask port
       jmp    $+2
       out    dx, al
       sti

		mov	  dx, DGroup:PortCmdStatus

       mov    ax, CMD_TXRESET			 ; 03-02-92
       out    dx, ax

       mov    ax, CMD_RXRESET
       out    dx, ax

; disable statistics

       mov    ax, CMD_STATSDISABLE	; *** BootWare doesn't enable statistics...
       out    dx, ax

;--------------------------------------------------------------------
; start internal transciever if specified

       mov    ax, DGroup:AConfig_Value
       and    ax, ACONFIG_XCVR
       cmp    ax, BNC_XCVR
       mov    ax, CMD_STARTINTXCVR		 ; if BNC, start internal xcvr
       je     Init2
       mov    ax, CMD_STOPINTXCVR		 ; not BNC, stop internal xcvr
Init2:
       out    dx, ax

; issue request interrupt command

       mov    ax, CMD_ACKNOWLEDGE+INT_REQUESTED+INT_LATCH
       out    dx, ax				 ; clear previous timer int
       mov    ax, CMD_REQUESTINT
       out    dx, ax				 ; "request int" starts timer

; wait till timer reaches the max value 0ffh

       add    dx, (PORT_TIMER-PORT_CmdStatus)	 ; dx = port timer
Init3:
       in     al, dx				 ; delay at least 800 us
       cmp    al, 0ffh				 ;  before using internal
       jne    Init3				 ;   transciever


; acknowlege request int, so it can be re-used later on

       add    dx, (PORT_CmdStatus-PORT_TIMER)	 ; dx = port CmdStatus
       mov    ax, CMD_ACKNOWLEDGE+INT_REQUESTED+INT_LATCH
       out    dx, ax

       ret

init_vulcan_hw	   endp

;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------

DriverUnhook  proc near


       push   es   
       xor    ax, ax
       mov    es, ax
       mov    di,word ptr DGroup:IntVectorAddress



       mov	  ax, DGroup:OrgIntVector_OFF	 ; segment
;;;       mov    ax, OldInterrupt.off
       mov    es: [di].off, ax
	   mov	  ax, DGroup:OrgIntVector_SEG   ; offset
;;;       mov    ax, OldInterrupt.segm
       mov    es: [di].segm, ax

unhook_rtn:
       pop    es   
       ret

DriverUnhook  endp

;------ ReadEEProm/ReadEE ---------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	dx = IOBase (for ReadEE) 
;	IOBase	= valid (for ReadEEPROM)
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
ReadEE		proc	near
		push	dx
		jmp	short ReadEECont

       public  ReadEEProm
ReadEEProm     proc    near
		push	dx

; issue an EEProm read command

                mov    dx, DGroup:IOBase

ReadEECont:
                add    dl, PORT_EECmd
                add    al, READ_EEPROM
                out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

                add    dl, PORT_EEData - PORT_EECmd
                in     ax, dx
         
         	pop	dx
		ret
ReadEEProm	endp
ReadEE		endp

;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
         	push	cx
         
         	mov	cx, 0
         
WaitEELoop:

         	in	ax, dx
         	test	ax, EE_BUSY
         	jz	WaitEEBusyExit
         
		loop	WaitEELoop


WaitEEBusyExit: and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
	mov	dx, DGroup:IOBase
	add	dl, PORT_EECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
	add	dx, ( PORT_EEData - PORT_EECmd )
	out	dx, ax				; load data

	add	dx, ( PORT_EECmd - PORT_EEData )
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp

;--------------------------------------------------------------------
; NADChangeReceiveMask
;
; Change the receive mask of the controller. Can force the adapter to
; enable/disable broadcast, multicast or promiscuous receptions
;
; Parameters:
;	BL - new receive bit mask:
;		bit 0:	set   = enable
;			clear = disable
;		bit 1:	change broadcast mask based on bit 0 flag
;		bit 2:	change multicast mask based on bit 0 flag
;		bit 3:	change Multicast Address Table:
;			if bit 0 is set, ES:DI will point to the
;				multicast address to add
;			if bit 0 is cleared, ES:DI will point to
;				multicast address to delete.
;			if bit 0 is cleared and DI = 0,
;				clear whole Multicast Table
;
;	ES:DI pointer to multicast address 
;
; Returns:
;	bx - TRUE/FALSE status if change was made
;--------------------------------------------------------------------

NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		; ** 509 does NOT allow you to read the current
		; ** receive mask. I will assume that broadcast
		; ** and multicast will NOT be concurrently
		; ** enabled

		mov	dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		test	bl, 2			; want to change broadcast?
		jnz	NADChgReceiveBroad

		test	bl, 4			; want to change Multicast?
		jnz	NADChgReceiveMulti
	
		jmp	short NADChgReceiveMaskEnd

NADChgReceiveBroad:
	 	mov    ax, CMD_SETRXFILTER+FILTER_BROADCAST+FILTER_INDIVIDUAL

		test	bl, 1
		jnz	NADChgRxBroad

		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
NADChgRxBroad:
		out	dx, ax
		mov	DGroup:HWFilter, ax
		jmp	short NADChgReceiveMaskEnd

NADChgReceiveMulti:
		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL

		test	bl, 1
		jz	NADChgRxMulti

		mov	si, offset DGroup:NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov    ax, CMD_SETRXFILTER+FILTER_MULTICAST+FILTER_INDIVIDUAL

NADChgRxMulti:
		out    dx, ax
		mov    DGroup:HWFilter, ax

NADChgReceiveMaskEnd:
		pop	ax
		pop	dx
		pop	si
		mov	bx, 1
		retf

NADChangeReceiveMask	endp




;--------------------------------------------------------------------
;
;   FindIOBase:	Find IOBase & ACR of EtherLink III (509, 509B, 527, 529)
;
;   On Entry:
;      ds = es = CGroup
;
;   On Exit:
;	ax = IO Address or 0 if failure
;	bx = Address Config. Register
;
;	Initialization code is split into 4 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------
FindIOBase	proc	near

;;            assume ds:CGroup
         
            cli					 ; 01-14
         
    		call   GetBusType

            mov     DGroup:BusType, al

;;;            int 03

         	cmp	al, BUS_MCA
         	je	inite_mca
         
         	cmp	al, BUS_EISA
         	je	inite_eisa
         	
         	jmp	init_isa

;-----------------------------------------------------------------------------
;  MCA-specific init code
;-----------------------------------------------------------------------------
FindIOBaseBadJmp:
		jmp	FindIOBaseBad

inite_mca:
		call	Find529
		jnz	FindIOBaseBadJmp

       	; Find IOBase
       	mov	dx, 104h		; POS[4]
       	in	al, dx
         
       	xchg	ah, al
       	and	ax, 0fc00h		; only consider higher 6 bits
       	or	ax, 0200h		; bit 9 is always set

		push	ax
       	mov	dx, 0096h
       	xor	al, al
       	out	dx, al			; turn setup mode off
		pop	ax
		jmp	init_ACR
         
;-----------------------------------------------------------------------------
;  EISA-specific init code
;-----------------------------------------------------------------------------
		; search the slots from 1 to 15 until we find a Vulcan adapter.
inite_eisa:
		xor    cl, cl			; slot number

inite_loop:
        inc    cl			; next slot
        cmp    cl, 15
        ja     init_isa			; if not found, try ISA

		call   CheckEISASlot		; check slot CL
		jnz    inite_loop		; nope? keep looking
;		jnc    inite_loop		; nope? keep looking

; found a Vulcan adapter in slot CL.  set the IOBase for EISA slot-specific
; addressing (I/O address x000 where x is a don't care).

		mov    ch, cl			; IOBase = x000 where
		xor    cl, cl			; x is the slot number
		shl    cx, 4
		mov	ax, cx

init_ACR:
		push	ax
		mov	dx, ax
       	add 	dx, PORT_CfgAddress
       	in	ax, dx
		mov	bx, ax
		pop	ax
        xor cx, cx          ; it's not an ISA , definitely
		jmp	FindIOBaseExit

;-----------------------------------------------------------------------------
;  ISA-specific init code
;-----------------------------------------------------------------------------

init_isa:
;;;        int     03
		mov    dx, ID_PORT
		call   Write_ID_Sequence 		 ; IDS enters ID_CMD state
         
		mov    al, SET_TAG_REGISTER + 0
		out    dx, al				 ; untag adapter

; look for the first adapter and activate it.  we will use contention test to
; make sure there is at least 1 Vulcan on system bus and activate the first
; Vulcan adapter we find.

        mov    al, EE_MANUFACTURER_CODE
        call   Contention_Test			 ; read EISA manufacturer ID
        cmp    ax, EISA_MANUFACTURER_ID		 ; is it 3Com's EISA ID?
        jnz	FindIOBaseBad

		jmp	$+2
		jmp	$+2
		jmp	$+2

        mov    al, EE_ADDR_CONFIGURATION
        call   Contention_Test
		mov	bx, ax
                and	ax, ACONFIG_IOBASE		 ; strip off IO base
                shl	ax, 4
		add	ax, MIN_IO_BASE_ADDR		 ; ax = IO base of adapter

        mov cx, 1                       ; it's an ISA card, no matter what
                                        ; bus is

FindIOBaseExit:
		push	ax
                mov	dx, ax				; set to window 0,
                add	dx, PORT_CmdStatus		;  so warm boot will
                mov	ax, CMD_SELECTWINDOW+WNO_SETUP	;   not confuse the
                out	dx, ax				;    hardware
		pop	ax
         	sti
         	ret

FindIOBaseBad:
		xor	ax, ax
		jmp	short FindIOBaseExit

FindIOBase	endp

;--------------------------------------------------------------------
;
;   BringUp: Activate NIC
;
;   On Entry:
;      ax = IOBase
;
;   On Exit:
;      bx     = 0, init successful
;	      = pointer to error message
;
;	Initialization code is split into 4 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------

BringUp		proc	near

		; Should only do it for ISA board?????????????
		push	ax
		push	ax
		mov	dx, ID_PORT
		sub	ax, MIN_IO_BASE_ADDR
		shr	ax, 4
		add	ax, 0e0h	 ; value to write to ID_PORT
		out	dx, ax		; IO is changed !!
		pop	dx

;----------------------------------------------------------------------------
;  ISA/EISA/MCA common init code
;----------------------------------------------------------------------------

init_found:

	       add    dx, PORT_CmdStatus		 ;  so warm boot will
	       mov    ax, CMD_SELECTWINDOW+WNO_SETUP	 ;   not confuse the
	       out    dx, ax				 ;    hardware
	
; the adapter has been brought up, read some information out of register set
; to make sure there is no I/O conflict.  Note that the adapter is in Window
; 0 after being activated.

		add    dx, PORT_ProductID - PORT_CmdStatus
		in     ax, dx
	
		xor	bx, bx
		; first check for MCA card
		cmp	 ax, 0627Ch			 ; 32bit 10 Base2
		je	 IOBaseOk
	
		cmp	ax, 0627Dh			; 32bit 10 Base-T
		je	IOBaseOk
	
		cmp	ax, 062F7h			; TP only
		je	IOBaseOk
	
		cmp	ax, 062F6h			; WHAT IS THIS ??????? Found it
		je	IOBaseOk			; in ODI drv

		cmp	ax, 061d8h			; Test mode. Prom is disabled in
		je	IOBaseOk			; anyways but ...
	
	       ; ISA/EISA ??
		and    ax, PRODUCT_ID_MASK
		cmp    ax, ISA_PRODUCT_ID		 ; is it 5X9?
		je     IOBaseOk
	
		sti

IOBaseOk:	pop	ax
		ret
BringUp		endp


;-----------------------------------------------------------------------------
;   Write_ID_Sequence:
;
;		   This routine writes ID sequence to the specified ID port
;	